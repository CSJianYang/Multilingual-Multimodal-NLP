[
    {
        "title": "Count Prefixes of a Given String",
        "question_content": "You are given a string array words and a string s, where words[i] and s comprise only of lowercase English letters.\nReturn the number of strings in words that are a prefix of s.\nA prefix of a string is a substring that occurs at the beginning of the string. A substring is a contiguous sequence of characters within a string.\n&nbsp;\nExample 1:\n\nInput: words = [\"a\",\"b\",\"c\",\"ab\",\"bc\",\"abc\"], s = \"abc\"\nOutput: 3\nExplanation:\nThe strings in words which are a prefix of s = \"abc\" are:\n\"a\", \"ab\", and \"abc\".\nThus the number of strings in words which are a prefix of s is 3.\nExample 2:\n\nInput: words = [\"a\",\"a\"], s = \"aa\"\nOutput: 2\nExplanation:\nBoth of the strings are a prefix of s. \nNote that the same string can occur multiple times in words, and it should be counted each time.\n&nbsp;\nConstraints:\n\n\t1 <= words.length <= 1000\n\t1 <= words[i].length, s.length <= 10\n\twords[i] and s consist of lowercase English letters only.",
        "solutions": [
            {
                "id": 1994777,
                "title": "java-c-python-starts-with",
                "content": "# **Explanation**\\nfor each word `w` in `words` list,\\ncheck if word `w` `startsWith` the string `s`\\n<br>\\n\\n# **Complexity**\\nTime `O(NS)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int countPrefixes(String[] words, String s) {\\n        int res = 0;\\n        for (String w : words)\\n            if (s.startsWith(w))\\n                res++;\\n        return res;\\n    }\\n```\\n\\n**C++**\\nTime O(NWS)\\n```cpp\\n    int countPrefixes(vector<string>& words, string s) {\\n        int res = 0;\\n        for (auto& w : words)\\n            res += s.find(w) < 1;\\n        return res; \\n    }\\n```\\n\\n**C++**\\nSuggested by @mzchen\\n```cpp\\n    int countPrefixes(vector<string>& words, string s) {\\n        int res = 0;\\n        for (auto& w : words)\\n            res += !s.compare(0, w.size(), w);\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def countPrefixes(self, words, s):\\n        return sum(map(s.startswith, words))\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int countPrefixes(String[] words, String s) {\\n        int res = 0;\\n        for (String w : words)\\n            if (s.startsWith(w))\\n                res++;\\n        return res;\\n    }\\n```\n```cpp\\n    int countPrefixes(vector<string>& words, string s) {\\n        int res = 0;\\n        for (auto& w : words)\\n            res += s.find(w) < 1;\\n        return res; \\n    }\\n```\n```cpp\\n    int countPrefixes(vector<string>& words, string s) {\\n        int res = 0;\\n        for (auto& w : words)\\n            res += !s.compare(0, w.size(), w);\\n        return res;\\n    }\\n```\n```py\\n    def countPrefixes(self, words, s):\\n        return sum(map(s.startswith, words))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1994746,
                "title": "c-easy-o-nxs-solution-string",
                "content": "```\\nclass Solution {\\npublic:\\n    //iterate over each words[i] and take the sub-string str from s of size equals to words[i].\\n    //and compare str with words[i] if both are equal increase count by 1.\\n    int countPrefixes(vector<string>& words, string s) \\n    {\\n        int count=0;\\n        for(auto it: words)\\n        {\\n            string str = s.substr(0, it.size());\\n            if(str == it) count++;            \\n        }\\n        return count;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //iterate over each words[i] and take the sub-string str from s of size equals to words[i].\\n    //and compare str with words[i] if both are equal increase count by 1.\\n    int countPrefixes(vector<string>& words, string s) \\n    {\\n        int count=0;\\n        for(auto it: words)\\n        {\\n            string str = s.substr(0, it.size());\\n            if(str == it) count++;            \\n        }\\n        return count;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1997418,
                "title": "java-1-liner",
                "content": "```java\\npublic int countPrefixes(String[] words, String s) {\\n        return (int) Arrays.stream(words).filter(s::startsWith).count();\\n    }\\n```\\n\\nMy repositories with leetcode problems solving - [Java](https://github.com/FLlGHT/algorithms/tree/master/j-algorithms/src/main/java),  [C++](https://github.com/FLlGHT/algorithms/tree/master/c-algorithms/src/main/c%2B%2B)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic int countPrefixes(String[] words, String s) {\\n        return (int) Arrays.stream(words).filter(s::startsWith).count();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2076295,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count=0\\n        for i in words:\\n            if (s[:len(i)]==i):\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count=0\\n        for i in words:\\n            if (s[:len(i)]==i):\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994712,
                "title": "c-easy-to-understand-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) \\n    {\\n        int counter = 0;\\n        \\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(words[i] == s.substr(0,words[i].size()))  \\n                counter++;\\n        }\\n\\n        return counter;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) \\n    {\\n        int counter = 0;\\n        \\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(words[i] == s.substr(0,words[i].size()))  \\n                counter++;\\n        }\\n\\n        return counter;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1999377,
                "title": "count-if",
                "content": "**C++**\\n```cpp\\nint countPrefixes(vector<string>& words, string s) {\\n    return count_if(begin(words), end(words), [&](const auto &w){ return s.compare(0, w.size(), w) == 0; });\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint countPrefixes(vector<string>& words, string s) {\\n    return count_if(begin(words), end(words), [&](const auto &w){ return s.compare(0, w.size(), w) == 0; });\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1994767,
                "title": "2-lines-c-java",
                "content": "Apply **find()** in case of c++ and **indexof()** in case of java on every word and check if return position is 0.\\nReturn the count of such strings.\\n# C++\\n    int countPrefixes(vector<string>& words, string s, int cnt=0){\\n        for(auto i:words) if(s.find(i)==0) cnt++;\\n        return cnt;\\n    }\\n\\t\\n# Java\\n    public int countPrefixes(String[] words, String s) {\\n        int cnt=0;\\n        for(var i:words) if(s.indexOf(i)==0) cnt++;\\n        return cnt;\\n    }",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "Apply **find()** in case of c++ and **indexof()** in case of java on every word and check if return position is 0.\\nReturn the count of such strings.\\n# C++\\n    int countPrefixes(vector<string>& words, string s, int cnt=0){\\n        for(auto i:words) if(s.find(i)==0) cnt++;\\n        return cnt;\\n    }\\n\\t\\n# Java\\n    public int countPrefixes(String[] words, String s) {\\n        int cnt=0;\\n        for(var i:words) if(s.indexOf(i)==0) cnt++;\\n        return cnt;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1994720,
                "title": "c-basic-string-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int cnt = 0;\\n        int i, j;\\n        for(i=0; i<words.size(); i++){\\n            j = 0;\\n            while(j< words[i].size()){\\n                if(words[i][j] != s[j])\\n                    break;\\n                j++;\\n            }\\n            if(j == words[i].size())\\n                cnt++;\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int cnt = 0;\\n        int i, j;\\n        for(i=0; i<words.size(); i++){\\n            j = 0;\\n            while(j< words[i].size()){\\n                if(words[i][j] != s[j])\\n                    break;\\n                j++;\\n            }\\n            if(j == words[i].size())\\n                cnt++;\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3003590,
                "title": "python-simple-solution",
                "content": "# Approach\\nCheck for each word if is prefix of s.\\n\\n# Code\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        res = 0\\n\\n        for word in words:\\n            if s.startswith(word):\\n                res += 1\\n\\n        return res\\n```\\n\\nLike it? Please upvote!",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        res = 0\\n\\n        for word in words:\\n            if s.startswith(word):\\n                res += 1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2726605,
                "title": "java-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n        public int countPrefixes(String[] words, String s) {\\n        \\n        int result = 0;\\n        for (int i=0; i<=s.length(); i++) {\\n            String x = s.substring(0, i);\\n            for (int j = 0; j<words.length; j++) {\\n                if (x.equals(words[j]))\\n                    result++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n        public int countPrefixes(String[] words, String s) {\\n        \\n        int result = 0;\\n        for (int i=0; i<=s.length(); i++) {\\n            String x = s.substring(0, i);\\n            for (int j = 0; j<words.length; j++) {\\n                if (x.equals(words[j]))\\n                    result++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2461131,
                "title": "3-different-fastest-approaches-with-javascript-including-one-liner",
                "content": "// approach 1 \\n\\n```\\nvar countPrefixes = function(words, s) {\\n     let counter = 0\\n     for (let i = 0; i < words.length; i++) {\\n         if (words[i]) === s.slice(0,words[i].length)) {\\n            counter++\\n        }\\n     }\\n    return counter\\n};\\n```\\n\\n// one liner approach - 2\\n\\n```\\nvar countPrefixes = function(words, s) {\\n    return words.filter((word) => word === s.slice(0,word.length)).length;\\n};\\n```\\n\\n// approach 3\\n\\n```\\nvar countPrefixes = function(words, s) {\\n    return words.filter(data=> s.indexOf(data) == 0).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countPrefixes = function(words, s) {\\n     let counter = 0\\n     for (let i = 0; i < words.length; i++) {\\n         if (words[i]) === s.slice(0,words[i].length)) {\\n            counter++\\n        }\\n     }\\n    return counter\\n};\\n```\n```\\nvar countPrefixes = function(words, s) {\\n    return words.filter((word) => word === s.slice(0,word.length)).length;\\n};\\n```\n```\\nvar countPrefixes = function(words, s) {\\n    return words.filter(data=> s.indexOf(data) == 0).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2084421,
                "title": "straightforward-javascript-solution-faster-than-96-67",
                "content": "```\\nvar countPrefixes = function(words, s) {\\n    let count = 0;\\n    for (let word of words) {\\n        if (s.startsWith(word)) count++\\n    } return count;\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/9ebdaad0-0ac6-40e8-98da-26c37a70fab5_1653758537.70002.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countPrefixes = function(words, s) {\\n    let count = 0;\\n    for (let word of words) {\\n        if (s.startsWith(word)) count++\\n    } return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2008421,
                "title": "js-easiest-way",
                "content": "```\\nvar countPrefixes = function(words, s) {\\n  \\n    let cont = 0;\\n    \\n    for(i = 0; i < words.length; i++){\\n        for(j = 1; j <= s.length; j++){\\n            if(words[i] == s.slice(0, j)){\\n                cont++;\\n            }\\n        }        \\n    }\\n     return cont;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countPrefixes = function(words, s) {\\n  \\n    let cont = 0;\\n    \\n    for(i = 0; i < words.length; i++){\\n        for(j = 1; j <= s.length; j++){\\n            if(words[i] == s.slice(0, j)){\\n                cont++;\\n            }\\n        }        \\n    }\\n     return cont;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1994686,
                "title": "python-straightforward-with-startswith",
                "content": "```\\ndef countPrefixes(self, words: List[str], s: str) -> int:\\n\\n    c = 0\\n    for w in words:\\n        if s.startswith(w):\\n            c += 1\\n\\n    return c\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef countPrefixes(self, words: List[str], s: str) -> int:\\n\\n    c = 0\\n    for w in words:\\n        if s.startswith(w):\\n            c += 1\\n\\n    return c\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3955799,
                "title": "java-100-beats-2-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0;\\n        for (String i : words)\\n            if (s.startsWith(i)) count++;\\n        return count;\\n\\n\\n//                          Another solution\\n\\n        // int count = 0;\\n        // int low = 0;\\n        // for(int i=1; i<=s.length(); i++){\\n        //    for(int j=0; j<words.length; j++){\\n        //        if(words[j].equals(s.substring(low,i))){\\n        //           count++;\\n        //        } \\n        //    }\\n        // }\\n        // return count;\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0;\\n        for (String i : words)\\n            if (s.startsWith(i)) count++;\\n        return count;\\n\\n\\n//                          Another solution\\n\\n        // int count = 0;\\n        // int low = 0;\\n        // for(int i=1; i<=s.length(); i++){\\n        //    for(int j=0; j<words.length; j++){\\n        //        if(words[j].equals(s.substring(low,i))){\\n        //           count++;\\n        //        } \\n        //    }\\n        // }\\n        // return count;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994877,
                "title": "c-simple-solution-using-substr",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int n = words.size();\\n        int cnt = 0;\\n        for(int i=0; i<n; i++) {\\n            string str = words[i];\\n            if(str == s.substr(0, str.size())) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int n = words.size();\\n        int cnt = 0;\\n        for(int i=0; i<n; i++) {\\n            string str = words[i];\\n            if(str == s.substr(0, str.size())) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994683,
                "title": "java-easy-appraoch",
                "content": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int i = 0;\\n        int j = 0;\\n        int count = 0;\\n        for(int k = 0; k < words.length; k++){\\n            if(words[k].length() > s.length()){\\n                continue;\\n            }\\n            \\n            while(i < words[k].length() && words[k].charAt(i) == s.charAt(j)){\\n                i++;\\n                j++;\\n            }\\n            if(i == words[k].length()){\\n                count++;\\n            }\\n            i = 0;\\n            j = 0;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int i = 0;\\n        int j = 0;\\n        int count = 0;\\n        for(int k = 0; k < words.length; k++){\\n            if(words[k].length() > s.length()){\\n                continue;\\n            }\\n            \\n            while(i < words[k].length() && words[k].charAt(i) == s.charAt(j)){\\n                i++;\\n                j++;\\n            }\\n            if(i == words[k].length()){\\n                count++;\\n            }\\n            i = 0;\\n            j = 0;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994652,
                "title": "best-solution-using-set-easy-to-understand",
                "content": "Approach\\nStep 1 : Define a map and empty stirng\\nStep2 : insert prefixes in map\\nStep3 : check how many array of words element is present in map\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        unordered_set<string> mp;\\n        string st = \"\";\\n        for(int i=0;i<s.length();i++){\\n            st += s[i];\\n            mp.insert(st);\\n        }\\n        int k=0;\\n        for(auto it:words){\\n            if(mp.count(it)){\\n                k++;\\n            }\\n        }\\n        return k;\\n    }\\n};\\n```\\n\\n# ****PLEASE UPVOTE",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        unordered_set<string> mp;\\n        string st = \"\";\\n        for(int i=0;i<s.length();i++){\\n            st += s[i];\\n            mp.insert(st);\\n        }\\n        int k=0;\\n        for(auto it:words){\\n            if(mp.count(it)){\\n                k++;\\n            }\\n        }\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2864115,
                "title": "c-3-line-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\t//time:O(n), space: O(1)\\n\\t\\tint countPrefixes(vector<string>& words, string s) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor(auto wd : words)\\n\\t\\t\\t\\tif(s.find(wd) < 1) count++; //if first occurrence of sub-string is in the specified string\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\t//time:O(n), space: O(1)\\n\\t\\tint countPrefixes(vector<string>& words, string s) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor(auto wd : words)\\n\\t\\t\\t\\tif(s.find(wd) < 1) count++; //if first occurrence of sub-string is in the specified string\\n\\t\\t\\treturn count;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3583196,
                "title": "one-line-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n       return sum(1 for x in words if s.startswith(x))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n       return sum(1 for x in words if s.startswith(x))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2965007,
                "title": "python3-code",
                "content": "# Code\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        return len([word for word in words if s.startswith(word)])\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/7ded423d-5651-41aa-8a7e-b8343efb856e_1672271463.1473987.png)\\n![image.png](https://assets.leetcode.com/users/images/65605e1b-564a-4ea3-8bf0-acad0d5862ea_1672271490.074425.png)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        return len([word for word in words if s.startswith(word)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2938964,
                "title": "easy-and-fast-c-solution",
                "content": "# Approach\\nUsing **s.find(words[i])** function which returns the index of words[i] if it is present in the string s , and to check whether words[i] occurs as a prefix use **s.find(words[i])==0**  ( since prefix always occurs at index 0).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n\\n      int countPrefix = 0;\\n\\n      for(int i=0;i<words.size();++i){\\n          if(s.find(words[i])!=string::npos && s.find(words[i])==0){\\n              countPrefix++;\\n          }\\n      }  \\n      return countPrefix;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n\\n      int countPrefix = 0;\\n\\n      for(int i=0;i<words.size();++i){\\n          if(s.find(words[i])!=string::npos && s.find(words[i])==0){\\n              countPrefix++;\\n          }\\n      }  \\n      return countPrefix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2768430,
                "title": "easy-o-n-maintain-a-set",
                "content": "We maintian a set called seen and add all the prefixes in the set and then simply check if the word in word list is present in the set or not\\n\\n***Leave an upvote if this helps!!!***\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        seen=set()\\n        count=0\\n        for i in range(1,len(s)+1):\\n            seen.add(s[:i])\\n        for i in words:\\n            if i in seen:\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        seen=set()\\n        count=0\\n        for i in range(1,len(s)+1):\\n            seen.add(s[:i])\\n        for i in words:\\n            if i in seen:\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2048968,
                "title": "easy-python-solution",
                "content": "```\\ndef countPrefixes(self, words: List[str], s: str) -> int:\\n        c=0\\n        for i in words:\\n            l=len(i)\\n            if i==s[:l]:\\n                c+=1\\n        return c\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef countPrefixes(self, words: List[str], s: str) -> int:\\n        c=0\\n        for i in words:\\n            l=len(i)\\n            if i==s[:l]:\\n                c+=1\\n        return c\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1995252,
                "title": "c-online-with-std-count-if-and-string-rfind",
                "content": "This [stackover flow post](https://stackoverflow.com/questions/1878001/how-do-i-check-if-a-c-stdstring-starts-with-a-certain-string-and-convert-a) descrives how to you ```string::rfind``` to implement ```startsWith```, which leads to following over all code to solve to problem.\\n\\n```\\nint countPrefixes(const vector<string>& ws, const string& s) {\\n    return count_if(begin(ws), end(ws), [&](const string& w) { return s.rfind(w, 0) == 0; });\\n}\\n```\\n\\nOne might was well could use ```string::compare``` to solve the problem as well:\\n\\n```\\nint countPrefixes(const vector<string>& ws, const string& s) {\\n    return count_if(begin(ws), end(ws), [&](const string& w) {\\n        return s.compare(0, size(w), w) == 0;\\n    });\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```string::rfind```\n```startsWith```\n```\\nint countPrefixes(const vector<string>& ws, const string& s) {\\n    return count_if(begin(ws), end(ws), [&](const string& w) { return s.rfind(w, 0) == 0; });\\n}\\n```\n```string::compare```\n```\\nint countPrefixes(const vector<string>& ws, const string& s) {\\n    return count_if(begin(ws), end(ws), [&](const string& w) {\\n        return s.compare(0, size(w), w) == 0;\\n    });\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1995152,
                "title": "c-5-lines-code-very-easy-o-n-solution",
                "content": "```\\nint countPrefixes(vector<string>& words, string s) {\\n       int c=0;\\n       for(string str:words){\\n            int len=str.length();\\n           string subs=s.substr(0,len);\\n           if(str==subs){\\n                c++;\\n           }\\n       } \\n       return c;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Iterator"
                ],
                "code": "```\\nint countPrefixes(vector<string>& words, string s) {\\n       int c=0;\\n       for(string str:words){\\n            int len=str.length();\\n           string subs=s.substr(0,len);\\n           if(str==subs){\\n                c++;\\n           }\\n       } \\n       return c;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1994752,
                "title": "java",
                "content": "int ans=0;\\n        HashMap<String,Integer> l=new HashMap<>();\\n        for(String str:words)\\n            l.put(str,l.getOrDefault(str,0)+1);\\n        for(int i=0;i<=s.length();i++)\\n        {\\n            String st=s.substring(0,i);\\n            if(l.containsKey(st))\\n                ans=ans+l.get(st);\\n        }\\n        return ans;",
                "solutionTags": [
                    "Java"
                ],
                "code": "int ans=0;\\n        HashMap<String,Integer> l=new HashMap<>();\\n        for(String str:words)\\n            l.put(str,l.getOrDefault(str,0)+1);\\n        for(int i=0;i<=s.length();i++)\\n        {\\n            String st=s.substring(0,i);\\n            if(l.containsKey(st))\\n                ans=ans+l.get(st);\\n        }\\n        return ans;",
                "codeTag": "Unknown"
            },
            {
                "id": 3827383,
                "title": "python-one-line-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        return len([i for i in words if s.startswith(i)])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        return len([i for i in words if s.startswith(i)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534504,
                "title": "simple-easy-100-java-solution",
                "content": "\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count=0;\\n        for(String word: words){\\n            if(s.startsWith(word)) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count=0;\\n        for(String word: words){\\n            if(s.startsWith(word)) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450978,
                "title": "easy-to-understand",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n        if it starts with element present in array count++;\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count=0;\\n\\n        for(String word: words){\\n            if(s.startsWith(word)) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count=0;\\n\\n        for(String word: words){\\n            if(s.startsWith(word)) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443668,
                "title": "simple-using-substr-c",
                "content": "`Please Upvote If you Like the Solution !!!`\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int ans = 0;\\n        for(auto &w : words) {\\n            int n = w.size();\\n            if(s.substr(0,n) == w) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int ans = 0;\\n        for(auto &w : words) {\\n            int n = w.size();\\n            if(s.substr(0,n) == w) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362962,
                "title": "simple-java-3-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0;\\n        for(int i =0; i<words.length; i++){\\n            if(s.startsWith(words[i])) count++;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0;\\n        for(int i =0; i<words.length; i++){\\n            if(s.startsWith(words[i])) count++;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3337621,
                "title": "esay-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int c=0;\\n        while(s.length()!=0){\\n        for(String y:words){\\n             if(y.equals(s))\\n             c++;\\n        }\\n        s=s.substring(0,s.length()-1); //Decreasing the length by 1\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int c=0;\\n        while(s.length()!=0){\\n        for(String y:words){\\n             if(y.equals(s))\\n             c++;\\n        }\\n        s=s.substring(0,s.length()-1); //Decreasing the length by 1\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278881,
                "title": "c-easy-simple",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int count = 0;\\n        for (string word : words)\\n        {\\n            if(s.find(word) == 0) \\n            { \\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int count = 0;\\n        for (string word : words)\\n        {\\n            if(s.find(word) == 0) \\n            { \\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176731,
                "title": "simple-c-code-easy-beats-100",
                "content": "\\n\\nRuntime: Beats 100%\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int c=0;\\n        for(auto j:words){\\n            int b=1;\\n            for(int i=0;i<j.size();i++){\\n                if(j[i]!=s[i]){\\n                    b=0;\\n                    break;\\n                }\\n            }\\n            if(b==1){\\n                    c++;\\n                }\\n        }\\n        return c;\\n    }\\n};\\n```\\nHope you liked the implementation of the code, if you like it feel free to upvote \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int c=0;\\n        for(auto j:words){\\n            int b=1;\\n            for(int i=0;i<j.size();i++){\\n                if(j[i]!=s[i]){\\n                    b=0;\\n                    break;\\n                }\\n            }\\n            if(b==1){\\n                    c++;\\n                }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174986,
                "title": "c-o-n-simple-approach-using-string-s-find-func",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n\\n    int count = 0;\\n    for (int i = 0; i < words.size(); i++)\\n    {\\n        if (s.find(words[i])==0)\\n        {\\n            count++;\\n        }\\n    }\\n    return count;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n\\n    int count = 0;\\n    for (int i = 0; i < words.size(); i++)\\n    {\\n        if (s.find(words[i])==0)\\n        {\\n            count++;\\n        }\\n    }\\n    return count;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868501,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s)\\n    {\\n        string w = \"\" ;\\n        int count = 0 ;\\n        for(int i=0 ; i<words.size() ; i++)\\n        {\\n            w = words[i] ;\\n            int j ;\\n            for(j=0 ; j<w.size() ; j++)\\n            {\\n                if(w[j]!=s[j])\\n                {\\n                    break ;\\n                }\\n            }\\n            if(j==w.size())\\n            {\\n                count++ ;\\n            }\\n        }   \\n        return count ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s)\\n    {\\n        string w = \"\" ;\\n        int count = 0 ;\\n        for(int i=0 ; i<words.size() ; i++)\\n        {\\n            w = words[i] ;\\n            int j ;\\n            for(j=0 ; j<w.size() ; j++)\\n            {\\n                if(w[j]!=s[j])\\n                {\\n                    break ;\\n                }\\n            }\\n            if(j==w.size())\\n            {\\n                count++ ;\\n            }\\n        }   \\n        return count ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2701416,
                "title": "c-easy-approach-93-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) { \\n        int ans = 0;\\n        for(int i = 0 ; i<words.size() ; i++){\\n            string element = words[i];\\n            int len = element.length();\\n            \\n            for(int j = 0 ; j<len ; j++){\\n               \\n                if(element[j] != s[j]){\\n                    break;      \\n                }     \\n                if(j==len-1){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) { \\n        int ans = 0;\\n        for(int i = 0 ; i<words.size() ; i++){\\n            string element = words[i];\\n            int len = element.length();\\n            \\n            for(int j = 0 ; j<len ; j++){\\n               \\n                if(element[j] != s[j]){\\n                    break;      \\n                }     \\n                if(j==len-1){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2651729,
                "title": "startswith-in-java-java",
                "content": "```\\nif(you like)\\n\\tplease upvote;\\n```\\n![image.png](https://assets.leetcode.com/users/images/c46bfd5c-cd60-4a0f-a3af-d56e67ae236a_1664727810.0896583.png)\\n\\n# Java Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int cnt = 0;\\n        for(String str:words)        \\n        {\\n            if(s.startsWith(str) == true)\\n                cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nif(you like)\\n\\tplease upvote;\\n```\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int cnt = 0;\\n        for(String str:words)        \\n        {\\n            if(s.startsWith(str) == true)\\n                cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649512,
                "title": "python-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef countPrefixes(self, words: List[str], s: str) -> int:\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor word in words:\\n\\t\\t\\t\\tif s[:len(word)] == word: res += 1\\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef countPrefixes(self, words: List[str], s: str) -> int:\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor word in words:\\n\\t\\t\\t\\tif s[:len(word)] == word: res += 1\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 2566238,
                "title": "python-straight-forward-one-liner",
                "content": "Here is what I did:\\n\\n```python\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        return sum(s.startswith(word) for word in words)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        return sum(s.startswith(word) for word in words)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2229509,
                "title": "javascript-straightforward-solution-simple-understandable-fast",
                "content": "**Runtime: 68 ms, faster than 91.85% of JavaScript online submissions for Count Prefixes of a Given String.\\nMemory Usage: 43 MB, less than 40.00% of JavaScript online submissions for Count Prefixes of a Given String.**\\n\\n```\\nvar countPrefixes = function(words, s) {\\n    let count = 0\\n    for (i of words) {\\n        if (s.startsWith(i)) {\\n            count++\\n        }\\n    } \\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "String"
                ],
                "code": "```\\nvar countPrefixes = function(words, s) {\\n    let count = 0\\n    for (i of words) {\\n        if (s.startsWith(i)) {\\n            count++\\n        }\\n    } \\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2007119,
                "title": "c-linq-one-line",
                "content": "```\\n\\tpublic int CountPrefixes(string[] words, string s) \\n        => words.Count(w => s.StartsWith(w));    \\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int CountPrefixes(string[] words, string s) \\n        => words.Count(w => s.StartsWith(w));    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1997642,
                "title": "rust-solutions",
                "content": "1. Simle use of `starts_with`:\\n```\\nimpl Solution {\\n    pub fn count_prefixes(words: Vec<String>, s: String) -> i32 {\\n        words.iter().filter(|w| s.starts_with(w.as_str())).count() as _\\n    }\\n}\\n```\\n2. Slice comparison\\n```\\nimpl Solution {\\n    pub fn count_prefixes(words: Vec<String>, s: String) -> i32 {\\n        words\\n            .iter()\\n            .filter(|w| w.len() <= s.len() && w.as_str() == &s[..w.len()])\\n            .count() as _\\n    }\\n}\\n```\\n3. Functional solution with `zip`:\\n```\\nimpl Solution {\\n    pub fn count_prefixes(words: Vec<String>, s: String) -> i32 {\\n        words\\n            .iter()\\n            .filter(|w| w.len() <= s.len() && w.chars().zip(s.chars()).all(|(a, b)| a == b))\\n            .count() as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn count_prefixes(words: Vec<String>, s: String) -> i32 {\\n        words.iter().filter(|w| s.starts_with(w.as_str())).count() as _\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn count_prefixes(words: Vec<String>, s: String) -> i32 {\\n        words\\n            .iter()\\n            .filter(|w| w.len() <= s.len() && w.as_str() == &s[..w.len()])\\n            .count() as _\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn count_prefixes(words: Vec<String>, s: String) -> i32 {\\n        words\\n            .iter()\\n            .filter(|w| w.len() <= s.len() && w.chars().zip(s.chars()).all(|(a, b)| a == b))\\n            .count() as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1995303,
                "title": "c-very-easy-to-understand-solution-using-unordered-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        unordered_set<string> st;\\n        int size = s.size();\\n        for(int i = 0;i<size;i++){\\n            string temp = \"\";\\n            for(int j = 0;j<=i;j++){\\n                temp+=s[j];\\n            }\\n            st.insert(temp);\\n        }\\n        int ans = 0;\\n        for(int i = 0;i<words.size();i++){\\n            if(st.find(words[i])!=st.end())\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        unordered_set<string> st;\\n        int size = s.size();\\n        for(int i = 0;i<size;i++){\\n            string temp = \"\";\\n            for(int j = 0;j<=i;j++){\\n                temp+=s[j];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1994612,
                "title": "c-easy-to-understand-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int c=0;\\n        for(auto word:words)\\n        {\\n                string str=word;\\n                int l=word.size();\\n                string s2=s.substr(0,l);\\n                if(s2==word)\\n                    c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int c=0;\\n        for(auto word:words)\\n        {\\n                string str=word;\\n                int l=word.size();\\n                string s2=s.substr(0,l);\\n                if(s2==word)\\n                    c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994558,
                "title": "java-simple",
                "content": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n    \\n       int preFixCount=0;\\n       for(String curr:words){\\n           int i=0;\\n           \\n           if(curr.length()>s.length())     // if current  string length greater than s length invalid prefix\\n           continue; \\n           int j;\\n           for(j=0;j<curr.length();j++,i++){\\n               if(curr.charAt(j)==s.charAt(i))\\n               continue;\\n               else \\n               break;\\n                   \\n           }\\n           if(j==curr.length())             // if all character matches than mark valid \\n           preFixCount++;\\n       }\\n     return preFixCount;     \\n    }\\n   \\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int countPrefixes(String[] words, String s) {\\n    \\n       int preFixCount=0;\\n       for(String curr:words){\\n           int i=0;\\n           \\n           if(curr.length()>s.length())     // if current  string length greater than s length invalid prefix\\n           continue; \\n           int j;\\n           for(j=0;j<curr.length();j++,i++){\\n               if(curr.charAt(j)==s.charAt(i))\\n               continue;\\n               else \\n               break;\\n                   \\n           }",
                "codeTag": "Java"
            },
            {
                "id": 3972694,
                "title": "javascript-easy-one-line-solution",
                "content": "# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function (words, s) {\\n  return words.filter((item) => s.startsWith(item)).length\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function (words, s) {\\n  return words.filter((item) => s.startsWith(item)).length\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3917786,
                "title": "go-easy",
                "content": "\\n\\n# Code\\n```\\nfunc countPrefixes(words []string, s string) int {\\n\\tvar count int\\n\\n\\tfor _, v := range words {\\n\\t\\tif strings.HasPrefix(s, v) {\\n\\t\\t\\tcount++\\n\\t\\t}\\n\\t}\\n\\n\\treturn count\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc countPrefixes(words []string, s string) int {\\n\\tvar count int\\n\\n\\tfor _, v := range words {\\n\\t\\tif strings.HasPrefix(s, v) {\\n\\t\\t\\tcount++\\n\\t\\t}\\n\\t}\\n\\n\\treturn count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3297434,
                "title": "count-prefixes-of-a-given-string-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*m)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int i, j, count=0;\\n        string str=\"\";\\n        for(i=0 ; i<s.length() ; i++)\\n        {\\n            str += s[i];\\n            for(j=0 ; j<words.size() ; j++)\\n            {\\n                if(str==words[j])\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int i, j, count=0;\\n        string str=\"\";\\n        for(i=0 ; i<s.length() ; i++)\\n        {\\n            str += s[i];\\n            for(j=0 ; j<words.size() ; j++)\\n            {\\n                if(str==words[j])\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249714,
                "title": "pyhton3-oneliner-using-startswith",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count = 0\\n        for i in words:\\n            if s.startswith(i):\\n                count += 1\\n        return count\\n\\n        #One Liner\\n\\n        return sum(1 for i in words if s.startswith(i))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count = 0\\n        for i in words:\\n            if s.startswith(i):\\n                count += 1\\n        return count\\n\\n        #One Liner\\n\\n        return sum(1 for i in words if s.startswith(i))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149760,
                "title": "pooping-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPoop the loop\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        c = 0\\n        for i in words:\\n            if i in s[:len(i)]:\\n                c+=1\\n        return c \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        c = 0\\n        for i in words:\\n            if i in s[:len(i)]:\\n                c+=1\\n        return c \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3114743,
                "title": "count-prefixes-of-a-given-string",
                "content": "```\\nint count=0;\\n        for(auto it:words){\\n            string str=s.substr(0,it.size());\\n            if(str==it)\\n            count++;\\n        }\\n        \\n        return count;\\n\\t\\t\\n```",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nint count=0;\\n        for(auto it:words){\\n            string str=s.substr(0,it.size());\\n            if(str==it)\\n            count++;\\n        }\\n        \\n        return count;\\n\\t\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2804300,
                "title": "count-prefixes-of-a-given-string-solution-java",
                "content": "class Solution {\\n  public int countPrefixes(String[] words, String s) {\\n    return (int) Arrays.stream(words).filter(word -> s.startsWith(word)).count();\\n  }\\n}\\n",
                "solutionTags": [
                    "Array",
                    "String"
                ],
                "code": "class Solution {\\n  public int countPrefixes(String[] words, String s) {\\n    return (int) Arrays.stream(words).filter(word -> s.startsWith(word)).count();\\n  }",
                "codeTag": "Java"
            },
            {
                "id": 2672445,
                "title": "java-solution-startswith-or-indexof",
                "content": "### Please Upvote :D\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0;\\n        \\n        for (String str : words) {\\n            // if (s.indexOf(str) == 0) count++;\\n            if (s.startsWith(str)) count++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n\\n// TC: O(n)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0;\\n        \\n        for (String str : words) {\\n            // if (s.indexOf(str) == 0) count++;\\n            if (s.startsWith(str)) count++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n\\n// TC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2651727,
                "title": "c-short-97-faster-than-all",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int countPrefixes(vector<string>& words, string s) {\\n        int count = 0;\\n        for(auto word:words){\\n            bool isPrefix = true;\\n            for(int i=0; i<word.length(); i++){\\n                if(word[i] != s[i]){\\n                    isPrefix = false;\\n                    break;\\n                }\\n            }\\n            if(isPrefix) count++;\\n        }\\n    return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int countPrefixes(vector<string>& words, string s) {\\n        int count = 0;\\n        for(auto word:words){\\n            bool isPrefix = true;\\n            for(int i=0; i<word.length(); i++){\\n                if(word[i] != s[i]){\\n                    isPrefix = false;\\n                    break;\\n                }\\n            }\\n            if(isPrefix) count++;\\n        }\\n    return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2626764,
                "title": "python-o-n",
                "content": "Time Complexcity O(N)\\nspace Complexcity O(1)\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count=0\\n        for word in words:\\n            n=len(word)\\n            if s[0:n]==word:\\n                count+=1\\n        return count\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count=0\\n        for word in words:\\n            n=len(word)\\n            if s[0:n]==word:\\n                count+=1\\n        return count\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612849,
                "title": "java-soln",
                "content": "class Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        \\n        int count =0;\\n        for(int i=0; i<words.length; i++){\\n         if(s.startsWith(words[i])){\\n             count++;\\n         }\\n        } \\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        \\n        int count =0;\\n        for(int i=0; i<words.length; i++){\\n         if(s.startsWith(words[i])){\\n             count++;\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 2601418,
                "title": "javascript-easy-solution",
                "content": "```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function(words, s) {\\n    let count = 0;\\n    for(let i=0; i<words.length; i++) {\\n        if(words[i] === s.slice(0, words[i].length)) {\\n            count++;\\n        }\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function(words, s) {\\n    let count = 0;\\n    for(let i=0; i<words.length; i++) {\\n        if(words[i] === s.slice(0, words[i].length)) {\\n            count++;\\n        }\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2561291,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int ct=0;\\n        for(string&word:words){\\n          bool flag=true;\\n          if(word.length()<=s.length()){\\n             for(int i=0; i<min(word.length(),s.length()); ++i){\\n                if(word[i]!=s[i]){\\n                   flag=false;\\n                   break;\\n                }\\n             }\\n            flag?ct++:ct+=0;\\n          }\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int ct=0;\\n        for(string&word:words){\\n          bool flag=true;\\n          if(word.length()<=s.length()){\\n             for(int i=0; i<min(word.length(),s.length()); ++i){\\n                if(word[i]!=s[i]){\\n                   flag=false;\\n                   break;\\n                }\\n             }\\n            flag?ct++:ct+=0;\\n          }\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2545761,
                "title": "count-prefixes-of-a-given-string",
                "content": "python3 sol\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count= 0 \\n        for i in words:\\n            if i ==s:\\n                count+=1\\n            else:\\n                if i ==s[:len(i)]:\\n                    count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count= 0 \\n        for i in words:\\n            if i ==s:\\n                count+=1\\n            else:\\n                if i ==s[:len(i)]:\\n                    count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2502759,
                "title": "easy-fast-short-solution",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```\\n```\\n        int count = 0;\\n        for(String temp: words)\\n            if (s.indexOf(temp) == 0)\\n                count++;\\n        return count;",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2500078,
                "title": "c-solution-count-prefixes-of-a-given-string",
                "content": "```\\nclass Solution {\\nprivate:\\n    int linear_search(vector<string>& words , string prefix){\\n        int count = 0;\\n        for(int i = 0 ; i < words.size() ; i++){\\n            if(prefix == words[i])\\n                count++;\\n        }\\n        return count;\\n    }\\n    \\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        vector<string> prefix;\\n        int count = 0;\\n        \\n        for(int i = 1 ; i <= s.length() ; i++){\\n            prefix.push_back(s.substr(0,i));\\n        }\\n        \\n        \\n        for(int i = 0 ; i < prefix.size() ; i++){\\n            count = count + linear_search(words , prefix[i]);\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int linear_search(vector<string>& words , string prefix){\\n        int count = 0;\\n        for(int i = 0 ; i < words.size() ; i++){\\n            if(prefix == words[i])\\n                count++;\\n        }\\n        return count;\\n    }\\n    \\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        vector<string> prefix;\\n        int count = 0;\\n        \\n        for(int i = 1 ; i <= s.length() ; i++){\\n            prefix.push_back(s.substr(0,i));\\n        }\\n        \\n        \\n        for(int i = 0 ; i < prefix.size() ; i++){\\n            count = count + linear_search(words , prefix[i]);\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2498493,
                "title": "java-solution-easy-100",
                "content": "public static int prefixcount(String[] words, String s) {\\n        int out = 0;\\n\\n        for (int i = 0; i < words.length; i++) {\\n            if (s.startsWith(words[i])) {\\n                out++;\\n            }\\n        }\\n        return out;",
                "solutionTags": [],
                "code": "public static int prefixcount(String[] words, String s) {\\n        int out = 0;\\n\\n        for (int i = 0; i < words.length; i++) {\\n            if (s.startsWith(words[i])) {\\n                out++;\\n            }\\n        }\\n        return out;",
                "codeTag": "Unknown"
            },
            {
                "id": 2488556,
                "title": "runtime-22-ms-faster-than-18-45-of-c-online-submissions-for-count-prefixes-of-a-given-string",
                "content": "\\n    int count = 0;\\n    for (int i = 0; i < words.size(); i++)\\n    {\\n        if (s.find(words[i])==0)\\n        {\\n            count++;\\n        }\\n    }\\n    return count;\\n}\\n//   upvote if you like\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n    int count = 0;\\n    for (int i = 0; i < words.size(); i++)\\n    {\\n        if (s.find(words[i])==0)\\n        {\\n            count++;\\n        }\\n    }\\n    return count;\\n}\\n//   upvote if you like\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2471556,
                "title": "java-solution-0ms-100-faster-easy-to-understand-linear-search-o-n",
                "content": "```\\nclass Solution {\\n    public int countPrefixes(String[] arr, String s) {\\n        int cnt = 0;\\n        for (String str : arr) {\\n            if (s.startsWith(str)) cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] arr, String s) {\\n        int cnt = 0;\\n        for (String str : arr) {\\n            if (s.startsWith(str)) cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2402405,
                "title": "easy-and-clear-solution-python3",
                "content": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count=0\\n        for word in words:\\n            if word == s[:len(word)]:\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count=0\\n        for word in words:\\n            if word == s[:len(word)]:\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2346554,
                "title": "c-brute-force-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        string sk;\\n        bool istrue;\\n        int count=0;\\n        for(int i=0;i<words.size();i++){\\n            sk=words[i];\\n            for(int j=0;j<sk.length();j++){\\n                if(sk[j]!=s[j]){\\n                    istrue=false; \\n                    break;\\n                }\\n                else{\\n                     istrue=true;\\n                }\\n            }\\n            \\n            if(istrue==true){\\n                cout<<sk<<endl;\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        string sk;\\n        bool istrue;\\n        int count=0;\\n        for(int i=0;i<words.size();i++){\\n            sk=words[i];\\n            for(int j=0;j<sk.length();j++){\\n                if(sk[j]!=s[j]){\\n                    istrue=false; \\n                    break;\\n                }\\n                else{\\n                     istrue=true;\\n                }\\n            }\\n            \\n            if(istrue==true){\\n                cout<<sk<<endl;\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2326109,
                "title": "one-liner-python",
                "content": "```\\nreturn sum([1 for word in words if s.startswith(word)])\\n```\\n**Please upvote if you want to see more one liners and simple solutions**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nreturn sum([1 for word in words if s.startswith(word)])\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2308148,
                "title": "c-solution-easy-to-understand-one-line",
                "content": "```C#\\npublic class Solution {\\n    public int CountPrefixes(string[] words, string s) => words.Count(x => s.StartsWith(x));\\n}\\n```",
                "solutionTags": [],
                "code": "```C#\\npublic class Solution {\\n    public int CountPrefixes(string[] words, string s) => words.Count(x => s.StartsWith(x));\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2303504,
                "title": "cpp-trie-solution",
                "content": "```\\n class Trie{\\n        public:\\n        char c;\\n        Trie* ch[26];\\n        int we;\\n        Trie(char d){\\n            c=d;\\n            for(int i=0;i<26;i++) ch[i]=NULL;\\n            we=0;\\n        }\\n    };\\n    Trie* r=new Trie(\\'0\\');\\n    \\n    void add(string s){\\n        Trie* h=r;\\n        for(int i=0;i<s.size();i++){\\n            int ind=s[i]-\\'a\\';\\n            h->ch[ind]=new Trie(s[i]);\\n            h=h->ch[ind];\\n        }\\n        h->we=1;\\n    }\\n    \\n    bool check(string s){\\n        Trie* h=r;\\n        for(int i=0;i<s.size();i++){\\n            int ind=s[i]-\\'a\\';\\n            if(h->ch[ind]==NULL) return 0;\\n            h=h->ch[ind];\\n        }\\n        return 1;\\n    }\\n    int countPrefixes(vector<string>& words, string s) {\\n        add(s);\\n        int ans=0;\\n        for(int i=0;i<words.size();i++){\\n            if(check(words[i])){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Trie"
                ],
                "code": "```\\n class Trie{\\n        public:\\n        char c;\\n        Trie* ch[26];\\n        int we;\\n        Trie(char d){\\n            c=d;\\n            for(int i=0;i<26;i++) ch[i]=NULL;\\n            we=0;\\n        }\\n    };\\n    Trie* r=new Trie(\\'0\\');\\n    \\n    void add(string s){\\n        Trie* h=r;\\n        for(int i=0;i<s.size();i++){\\n            int ind=s[i]-\\'a\\';\\n            h->ch[ind]=new Trie(s[i]);\\n            h=h->ch[ind];\\n        }\\n        h->we=1;\\n    }\\n    \\n    bool check(string s){\\n        Trie* h=r;\\n        for(int i=0;i<s.size();i++){\\n            int ind=s[i]-\\'a\\';\\n            if(h->ch[ind]==NULL) return 0;\\n            h=h->ch[ind];\\n        }\\n        return 1;\\n    }\\n    int countPrefixes(vector<string>& words, string s) {\\n        add(s);\\n        int ans=0;\\n        for(int i=0;i<words.size();i++){\\n            if(check(words[i])){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2200749,
                "title": "python-straightforward",
                "content": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        countPrefixe = 0\\n        for word in words:\\n            if word in s and word == s[:len(word)]:\\n                countPrefixe += 1\\n        return countPrefixe\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        countPrefixe = 0\\n        for word in words:\\n            if word in s and word == s[:len(word)]:\\n                countPrefixe += 1\\n        return countPrefixe\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2197461,
                "title": "javascript-solution-with-foreach",
                "content": "```\\nvar countPrefixes = function(words, s) {    \\n\\n    let count = 0; \\n\\t\\n    words.forEach((word) => {\\n        if( s.startsWith(word) ) \\n\\t\\t\\tcount++;\\n    });\\n    \\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countPrefixes = function(words, s) {    \\n\\n    let count = 0; \\n\\t\\n    words.forEach((word) => {\\n        if( s.startsWith(word) ) \\n\\t\\t\\tcount++;\\n    });\\n    \\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2191967,
                "title": "my-easy-to-understand-2ms-java-code",
                "content": "```\\nclass Solution \\n{\\n    public int countPrefixes(String[] words, String s) \\n    {\\n        int c=0;\\n        for(String i:words)\\n        {\\n            if(s.startsWith(i))\\n            {\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution \\n{\\n    public int countPrefixes(String[] words, String s) \\n    {\\n        int c=0;\\n        for(String i:words)\\n        {\\n            if(s.startsWith(i))\\n            {\\n                c++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2181067,
                "title": "python-trie-for-fast-queries",
                "content": "Prefix Tree aka Trie might be an overkill for this easy problem, but when you are not allowed to use startswith and need to reduce time complexity of multiple queries it\\'s a good option - linear scan of path to get sum of all words on the path.\\n\\n```\\nclass Node(object):\\n    def __init__(self):\\n        self.children = {}\\n        self.is_word = False\\n        self.count = 0\\n\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        root = Node()\\n        \\n        # build a trie\\n        for w in words:\\n            node = root\\n            for c in w:\\n                if c not in node.children:\\n                    node.children[c] = Node()\\n                node = node.children[c]\\n            node.count = 1 if not node.is_word else node.count + 1\\n            node.is_word = True\\n        \\n        # count prefix-words in s\\n        node = root\\n\\n        res = 0\\n        for c in s:\\n            if c in node.children:\\n                node = node.children[c]\\n                res += node.count if node.is_word else 0\\n            else:\\n                break\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Trie"
                ],
                "code": "```\\nclass Node(object):\\n    def __init__(self):\\n        self.children = {}\\n        self.is_word = False\\n        self.count = 0\\n\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        root = Node()\\n        \\n        # build a trie\\n        for w in words:\\n            node = root\\n            for c in w:\\n                if c not in node.children:\\n                    node.children[c] = Node()\\n                node = node.children[c]\\n            node.count = 1 if not node.is_word else node.count + 1\\n            node.is_word = True\\n        \\n        # count prefix-words in s\\n        node = root\\n\\n        res = 0\\n        for c in s:\\n            if c in node.children:\\n                node = node.children[c]\\n                res += node.count if node.is_word else 0\\n            else:\\n                break\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2147734,
                "title": "c-simple-solution",
                "content": "class Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int ans=0;\\n        for(auto w : words)\\n        {\\n            int count=0;\\n            for(int i=0;i<w.length();i++)\\n            {\\n               if(w[i]==s[i])\\n                   count++; \\n            }\\n            if(count==w.length())\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int ans=0;\\n        for(auto w : words)\\n        {\\n            int count=0;\\n            for(int i=0;i<w.length();i++)\\n            {\\n               if(w[i]==s[i])\\n                   count++; \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2143292,
                "title": "c-very-easy-solution-using-sets",
                "content": "```\\nint countPrefixes(vector<string>& words, string s) {\\n        int count = 0;\\n        set<string>ss;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            ss.insert(s.substr(0,i+1));\\n        }\\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(ss.find(words[i])!=ss.end())\\n                count++;\\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nint countPrefixes(vector<string>& words, string s) {\\n        int count = 0;\\n        set<string>ss;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            ss.insert(s.substr(0,i+1));\\n        }\\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(ss.find(words[i])!=ss.end())\\n                count++;\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2140038,
                "title": "c-easy-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n       unordered_map<string,int>harsh;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            harsh[s.substr(0,i+1)]++;\\n        }\\n        int cnt=0;\\n        for(auto val:words)\\n        {\\n            if(harsh.find(val) != harsh.end())\\n            {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n       unordered_map<string,int>harsh;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            harsh[s.substr(0,i+1)]++;\\n        }\\n        int cnt=0;\\n        for(auto val:words)\\n        {\\n            if(harsh.find(val) != harsh.end())\\n            {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2132698,
                "title": "easy-java-solution-faster-100",
                "content": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int sum = 0;\\n        for(int i=0;i<words.length;i++){\\n            if(s.startsWith(words[i])){\\n                sum++;\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int sum = 0;\\n        for(int i=0;i<words.length;i++){\\n            if(s.startsWith(words[i])){\\n                sum++;\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2098364,
                "title": "python-easy-beginer-friendly",
                "content": "```\\nclass Solution:\\n    def countPrefixes(self, a: List[str], s: str) -> int:\\n        r=0\\n        for i in a:\\n            if len(i)<=len(s) and i==s[:len(i)]:\\n                r+=1\\n        return r\\n```\\n![image](https://assets.leetcode.com/users/images/c570329e-69a5-4674-aff5-3562d8a29ea8_1654088247.904313.jpeg)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, a: List[str], s: str) -> int:\\n        r=0\\n        for i in a:\\n            if len(i)<=len(s) and i==s[:len(i)]:\\n                r+=1\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2070262,
                "title": "fastest-java-solution-0ms",
                "content": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int c = 0;\\n        for(String word:words)\\n            if(s.startsWith(word))\\n                c++;\\n        return c;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int c = 0;\\n        for(String word:words)\\n            if(s.startsWith(word))\\n                c++;\\n        return c;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2048287,
                "title": "python3-two-1-liners",
                "content": "class Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        \\n        return sum(word == s[:len(word)] for word in words)\\n\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n\\t\\n        return sum(s.find(word) == 0 for word in words)",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        \\n        return sum(word == s[:len(word)] for word in words)\\n\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n\\t\\n        return sum(s.find(word) == 0 for word in words)",
                "codeTag": "Java"
            },
            {
                "id": 2037971,
                "title": "c-easy-solution",
                "content": "class Solution {\\npublic:\\n    int countPrefixes(vector<string>& w, string s) {\\n        int res=0;\\n        for(int i=0;i<w.size();i++)\\n        {\\n            int flag=0;\\n            for(int j=0;j<w[i].size();j++)\\n            {\\n                if(w[i][j]!=s[j])\\n                    flag=1;\\n            }\\n            if (flag==0)\\n                res++;\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int countPrefixes(vector<string>& w, string s) {\\n        int res=0;\\n        for(int i=0;i<w.size();i++)\\n        {\\n            int flag=0;\\n            for(int j=0;j<w[i].size();j++)\\n            {\\n                if(w[i][j]!=s[j])\\n                    flag=1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2022531,
                "title": "python3-one-line-solution",
                "content": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        return sum([1 for w in words if w == s[:len(w)]])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        return sum([1 for w in words if w == s[:len(w)]])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2014637,
                "title": "3ms-beats-95-c-submissions-easytounderstand",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& a, string s) {\\n        int ans=0;\\n        int n=s.size();\\n        for(auto it:a){\\n            int m=it.size();\\n            if(m<=n){\\n                int f=1;\\n                int k=0;\\n                for(auto i:it)\\n                    if(i!=s[k++])\\n                        {\\n                            f=0;\\n                            break;\\n                        }\\n                if(f)ans++;\\n            }\\n        }\\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& a, string s) {\\n        int ans=0;\\n        int n=s.size();\\n        for(auto it:a){\\n            int m=it.size();\\n            if(m<=n){\\n                int f=1;\\n                int k=0;\\n                for(auto i:it)\\n                    if(i!=s[k++])\\n                        {\\n                            f=0;\\n                            break;\\n                        }\\n                if(f)ans++;\\n            }\\n        }\\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2013095,
                "title": "runtime-12-ms-c-solution",
                "content": "class Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        string str=\"\";\\n        int count=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            str+=s[i];\\n            for(int j=0;j<words.size();j++)\\n            {\\n                if(words[j]==str)\\n                {\\n                    count++;\\n                }\\n                \\n            }\\n            \\n        }\\n        return count;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        string str=\"\";\\n        int count=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            str+=s[i];\\n            for(int j=0;j<words.size();j++)\\n            {\\n                if(words[j]==str)\\n                {\\n                    count++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2006744,
                "title": "c-efficient-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool contains(vector<string> vec, string & elem){\\n    bool result = false;\\n    if( find(vec.begin(), vec.end(), elem) != vec.end() )\\n    {\\n        result = true;\\n    }\\n    return result;\\n    }\\n    \\n    vector<string> vec;\\n    string temp=\"\";\\n    int c=0;\\n    int countPrefixes(vector<string>& words, string s) {\\n        for(int i=0;i<s.size();i++){\\n            temp+=s[i];\\n            vec.push_back(temp);\\n        }\\n        for(int i=0;i<words.size();i++){\\n            if(contains(vec,words[i])) c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool contains(vector<string> vec, string & elem){\\n    bool result = false;\\n    if( find(vec.begin(), vec.end(), elem) != vec.end() )\\n    {\\n        result = true;\\n    }\\n    return result;\\n    }\\n    \\n    vector<string> vec;\\n    string temp=\"\";\\n    int c=0;\\n    int countPrefixes(vector<string>& words, string s) {\\n        for(int i=0;i<s.size();i++){\\n            temp+=s[i];\\n            vec.push_back(temp);\\n        }\\n        for(int i=0;i<words.size();i++){\\n            if(contains(vec,words[i])) c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1998165,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        c=0\\n        for i in range(len(words)):\\n            if s.startswith(words[i]):\\n                    c+=1\\n        return c\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        c=0\\n        for i in range(len(words)):\\n            if s.startswith(words[i]):\\n                    c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1997765,
                "title": "c-using-substr",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int ans1 = 0;\\n        for(int i=0;i<=s.size();i++){\\n            string h = s.substr(0,i);\\n            int x = count(words.begin(),words.end(),h);\\n            if(x>0)    ans1+=x;\\n        }\\n        return ans1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int ans1 = 0;\\n        for(int i=0;i<=s.size();i++){\\n            string h = s.substr(0,i);\\n            int x = count(words.begin(),words.end(),h);\\n            if(x>0)    ans1+=x;\\n        }\\n        return ans1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995903,
                "title": "go-golang-solution",
                "content": "```go\\nfunc countPrefixes(words []string, s string) int {\\n    ans := 0\\n    for _, word := range words {\\n        n := len(word)\\n        if n > len(s) { continue }\\n        if word == s[:n] { ans++ }\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc countPrefixes(words []string, s string) int {\\n    ans := 0\\n    for _, word := range words {\\n        n := len(word)\\n        if n > len(s) { continue }\\n        if word == s[:n] { ans++ }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1995794,
                "title": "easy-java-implementation",
                "content": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        \\n        int count =0;\\n        \\n        for(String str : words){\\n \\xA0 \\xA0 \\xA0 \\xA0 if\\xA0(s.indexOf(str)==0) count++;\\n \\xA0 \\xA0 \\xA0 \\xA0}\\n \\xA0 \\xA0 \\xA0 \\xA0return count;\\n \\xA0 \\xA0}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        \\n        int count =0;\\n        \\n        for(String str : words){\\n \\xA0 \\xA0 \\xA0 \\xA0 if\\xA0(s.indexOf(str)==0) count++;\\n \\xA0 \\xA0 \\xA0 \\xA0}\\n \\xA0 \\xA0 \\xA0 \\xA0return count;\\n \\xA0 \\xA0}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995491,
                "title": "c-3-lines-no-substr-copy-or-global-find",
                "content": "Use `string::compare` to avoid substring copy and whole string scanning.\\n```\\nint countPrefixes(vector<string>& words, string s) {\\n    return count_if(words.begin(), words.end(), [&](string &w) {\\n        return !s.compare(0, w.size(), w);\\n    });\\n}\\n```\\n\\nEven better if LeetCode allows C++20 so that we could use the standard `string::starts_with`.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint countPrefixes(vector<string>& words, string s) {\\n    return count_if(words.begin(), words.end(), [&](string &w) {\\n        return !s.compare(0, w.size(), w);\\n    });\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1995485,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        return sum(w == s[:len(w)] for w in words)\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        return sum(w == s[:len(w)] for w in words)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995010,
                "title": "ruby-solution",
                "content": "```\\n# @param {String[]} words\\n# @param {String} s\\n# @return {Integer}\\ndef count_prefixes(words, s)\\n    count = 0\\n    words.each {|word| count += 1 if word == s[0...word.length]}\\n    count\\nend\\n",
                "solutionTags": [],
                "code": "```\\n# @param {String[]} words\\n# @param {String} s\\n# @return {Integer}\\ndef count_prefixes(words, s)\\n    count = 0\\n    words.each {|word| count += 1 if word == s[0...word.length]}\\n    count\\nend\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1994972,
                "title": "c",
                "content": "Just use substring to check is the same or not,\\nprefix must be a substring of string and length will be prefix self length.\\n[C# testcase](https://github.com/AhChao/OnceLeetCodePerDay/blob/main/OnceLeetCodePerDay/Contest/0430/Tests/L6051CountPrefixesOfAGivenStringTests.cs)\\n```\\npublic int CountPrefixes(string[] words, string s) {\\n\\tvar result = 0;\\n\\tforeach(var i in words)\\n\\t{\\n\\t\\tif(i.Length > s.Length) continue;\\n\\t\\tresult += s.Substring(0,i.Length) == i ? 1 : 0;\\n\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int CountPrefixes(string[] words, string s) {\\n\\tvar result = 0;\\n\\tforeach(var i in words)\\n\\t{\\n\\t\\tif(i.Length > s.Length) continue;\\n\\t\\tresult += s.Substring(0,i.Length) == i ? 1 : 0;\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1994856,
                "title": "python-hashset",
                "content": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        \\n        c = 0 \\n        n = len(words)\\n        d = []\\n        for i in range(len(s)):\\n            d.append(s[:i+1])\\n        \\n        dd = set(d)\\n        \\n        for i in words:\\n            if i in dd:\\n                c += 1 \\n        return c\\n```\\n\\nDont miss to **Upvote** Coders, wish your very **great journey of coding**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        \\n        c = 0 \\n        n = len(words)\\n        d = []\\n        for i in range(len(s)):\\n            d.append(s[:i+1])\\n        \\n        dd = set(d)\\n        \\n        for i in words:\\n            if i in dd:\\n                c += 1 \\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994706,
                "title": "easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        map<string, int> mpp;\\n        int ans = 0;\\n        string str;\\n        for(auto str : words) mpp[str]++;\\n        for(int i = 0; i < s.size(); i++){\\n                str += s[i];\\n                ans += mpp[str];\\n                cout << str << \" \";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        map<string, int> mpp;\\n        int ans = 0;\\n        string str;\\n        for(auto str : words) mpp[str]++;\\n        for(int i = 0; i < s.size(); i++){\\n                str += s[i];\\n                ans += mpp[str];\\n                cout << str << \" \";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1994667,
                "title": "3-liner-easy-to-implement",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int count = 0;\\n        for(int i = 0 ; i < words.size() ; i++) if(words[i] == s.substr(0,words[i].size())) count++;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int count = 0;\\n        for(int i = 0 ; i < words.size() ; i++) if(words[i] == s.substr(0,words[i].size())) count++;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994641,
                "title": "one-liner-easy-c-substr",
                "content": "```\\n    int countPrefixes(vector<string>& words, string s) {\\n        int count = 0;\\n        for(int i = 0; i < words.size(); i++)\\n            if(words[i].substr(0,words[i].size()) == s.substr(0,words[i].size()))\\n                count++;\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int countPrefixes(vector<string>& words, string s) {\\n        int count = 0;\\n        for(int i = 0; i < words.size(); i++)\\n            if(words[i].substr(0,words[i].size()) == s.substr(0,words[i].size()))\\n                count++;\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1994629,
                "title": "very-easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int c = 0;\\n        unordered_map<string,int> hmp;\\n        int l = s.length();\\n        for(int i=0; i<words.size(); i++) {\\n            hmp[words[i]]++;\\n        }\\n        for(int i=1; i<=l; i++) {\\n            string str = s.substr(0,i);\\n            if(hmp.find(str)!=hmp.end())\\n                c += hmp[str];\\n        }\\n        return c;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int c = 0;\\n        unordered_map<string,int> hmp;\\n        int l = s.length();\\n        for(int i=0; i<words.size(); i++) {\\n            hmp[words[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1994607,
                "title": "simple-c-substring",
                "content": "class Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        \\n        int num = 0;\\n        for(auto str:words){\\n            int len = str.size();\\n            string sub = s.substr(0,len);\\n            if(str == sub)\\n                num++;\\n        }\\n        \\n        return num;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        \\n        int num = 0;\\n        for(auto str:words){\\n            int len = str.size();\\n            string sub = s.substr(0,len);\\n            if(str == sub)\\n                num++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1994580,
                "title": "java-startswith-easiest",
                "content": "```\\nclass Solution\\n{\\n    public int countPrefixes(String[] words, String s)\\n    {\\n        int count = 0;\\n        for(String word : words)\\n            if(s.startsWith(word))\\n                count++;\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int countPrefixes(String[] words, String s)\\n    {\\n        int count = 0;\\n        for(String word : words)\\n            if(s.startsWith(word))\\n                count++;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994576,
                "title": "c-3-lines-find-function",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int a=0;\\n        for(auto i:words)   a += s.find(i)==0;\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int a=0;\\n        for(auto i:words)   a += s.find(i)==0;\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994564,
                "title": "c-4-lines-elegant-solution-using-std-mismatch",
                "content": "Built in C++ functions always comes handy in contests \\uD83D\\uDCAF\\n\\n```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& a, string s) {\\n        int res = 0;\\n        for(auto i: a)\\n            if(mismatch(i.begin(), i.end(), s.begin(), s.end()).first == i.end()) res++;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& a, string s) {\\n        int res = 0;\\n        for(auto i: a)\\n            if(mismatch(i.begin(), i.end(), s.begin(), s.end()).first == i.end()) res++;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994561,
                "title": "simple-elegant-4-line-cpp-code-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& w, string s) {\\n        int ct=0;\\n        for(int i=0; i<w.size(); i++){\\n            if(s.substr(0,w[i].length())==w[i]) ct++;\\n        }\\n        return ct;\\n    }\\n};\\n```\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n\\nLet me know if you\\'d like to add any point of if I have missed anything.\\nHappy Coding!",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& w, string s) {\\n        int ct=0;\\n        for(int i=0; i<w.size(); i++){\\n            if(s.substr(0,w[i].length())==w[i]) ct++;\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4093620,
                "title": "easy-one-liner-c",
                "content": "\\n# Approach\\nUsing Count and StartsWith\\n\\n# Code\\n```\\npublic class Solution {\\n    public int CountPrefixes(string[] words, string s) {\\n        return words.Count(i => s.StartsWith(i));\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int CountPrefixes(string[] words, string s) {\\n        return words.Count(i => s.StartsWith(i));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088337,
                "title": "java-best-ever-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int c=0;\\n        for(int i=0;i<words.length;i++){\\n            if(s.startsWith(words[i])){\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int c=0;\\n        for(int i=0;i<words.length;i++){\\n            if(s.startsWith(words[i])){\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085650,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int count = 0;\\n\\n        for(int i=0; i<words.size(); i++){\\n            if (s.rfind(words[i], 0) == 0) { \\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int count = 0;\\n\\n        for(int i=0; i<words.size(); i++){\\n            if (s.rfind(words[i], 0) == 0) { \\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083046,
                "title": "detailed-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe have to find how many the elements in a words(list) can be prefixes to the string **S.**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe have to take a variabe named counter.\\nstr\\n```python []\\ncount=0\\n\\n```\\nThen iterate through the loop to find whether the **elements in list  will match to the string S.** \\n```python []\\n    s[:len(i)]==i:\\n\\n```\\nthen increase the count value by 1\\n```python []\\ncount+=1\\n\\n```\\nFinally return the value of the count.\\n```python []\\nreturn count\\n\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count=0\\n        for i in words:\\n            if s[:len(i)]==i:\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "String Matching"
                ],
                "code": "```python []\\ncount=0\\n\\n```\n```python []\\n    s[:len(i)]==i:\\n\\n```\n```python []\\ncount+=1\\n\\n```\n```python []\\nreturn count\\n\\n```\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count=0\\n        for i in words:\\n            if s[:len(i)]==i:\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081682,
                "title": "easy-to-understand-iterative",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIteratively check if each words is prefix or not\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize the count.\\n2. Iterate through each word.\\n3. If the word is the prefix of s, increment count.\\n4. Return count.\\n\\n# Complexity\\n- Time complexity: O(n*m) , n=number of words, m=size of each word\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        \\n        count=0\\n        for w in words:\\n            n=len(w)\\n            if n<=len(s) and w==s[:n]:\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        \\n        count=0\\n        for w in words:\\n            n=len(w)\\n            if n<=len(s) and w==s[:n]:\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079643,
                "title": "simple-java-solution-100-beats-4-lines-of-code-with-expanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    Please Upvote.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        // Variable to store the value of answer.\\n        int ans=0;\\n        // Iterate through all the strings of the array.\\n        for(String word:words){\\n            // If \\'s\\' starts with the current string then increse the answer count by one.\\n            if(s.startsWith(word)) ans++;\\n        }\\n        // Finaly return the answer.\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        // Variable to store the value of answer.\\n        int ans=0;\\n        // Iterate through all the strings of the array.\\n        for(String word:words){\\n            // If \\'s\\' starts with the current string then increse the answer count by one.\\n            if(s.startsWith(word)) ans++;\\n        }\\n        // Finaly return the answer.\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079160,
                "title": "c-100-faster-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n\\n    \\tint countOfPattern = 0;\\n\\n    \\tint inputSize = words.size();\\n\\n    \\tfor (int i = 0; i < inputSize; ++i)\\n    \\t{\\n    \\t\\tif(isPrefix(s,words[i])){\\n                countOfPattern++;\\n    \\t\\t}\\n    \\t}\\n\\n    \\treturn countOfPattern;\\n\\n    }\\n\\n\\tbool isPrefix(string str,string pattern){\\n\\n\\t\\tint size = pattern.size();\\n\\n\\t\\tfor (int i = 0; i < size; ++i)\\n\\t\\t{\\n\\t\\t\\tif(str[i] != pattern[i]){\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n\\n    \\tint countOfPattern = 0;\\n\\n    \\tint inputSize = words.size();\\n\\n    \\tfor (int i = 0; i < inputSize; ++i)\\n    \\t{\\n    \\t\\tif(isPrefix(s,words[i])){\\n                countOfPattern++;\\n    \\t\\t}\\n    \\t}\\n\\n    \\treturn countOfPattern;\\n\\n    }\\n\\n\\tbool isPrefix(string str,string pattern){\\n\\n\\t\\tint size = pattern.size();\\n\\n\\t\\tfor (int i = 0; i < size; ++i)\\n\\t\\t{\\n\\t\\t\\tif(str[i] != pattern[i]){\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077227,
                "title": "beats-100-only-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0;\\n        for(int i=0;i<words.length;i++){\\n            if(s.startsWith(words[i])) count ++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0;\\n        for(int i=0;i<words.length;i++){\\n            if(s.startsWith(words[i])) count ++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4076286,
                "title": "one-line-solution",
                "content": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        return sum(s.startswith(word) for word in words)       \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        return sum(s.startswith(word) for word in words)       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073928,
                "title": "beats-100-00-of-users-with-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n         int count=0;\\n        for(String word: words)\\n        {\\n            if(s.indexOf(word)==0)\\n            {\\n                  count++;\\n            }\\n        }\\n        \\n    return count;}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n         int count=0;\\n        for(String word: words)\\n        {\\n            if(s.indexOf(word)==0)\\n            {\\n                  count++;\\n            }\\n        }\\n        \\n    return count;}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071268,
                "title": "naive-method-96-beats-simple-solution-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count=0\\n        for i in words:\\n            if len(i)<=len(s):\\n                c=0\\n                for j in range(len(i)):\\n                    if s[j]!=i[j]:\\n                        c=1\\n                        break\\n                if c==0:\\n                    count+=1\\n        return count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count=0\\n        for i in words:\\n            if len(i)<=len(s):\\n                c=0\\n                for j in range(len(i)):\\n                    if s[j]!=i[j]:\\n                        c=1\\n                        break\\n                if c==0:\\n                    count+=1\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069485,
                "title": "easy-c-soln",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int n = words.size();\\n        int m = s.size();\\n        int count = 0;\\n        string str = \"\";\\n        for(int i=0; i<m; i++){\\n            str += s[i];\\n            for(int j=0; j<n; j++){\\n                if(words[j] == str){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int n = words.size();\\n        int m = s.size();\\n        int count = 0;\\n        string str = \"\";\\n        for(int i=0; i<m; i++){\\n            str += s[i];\\n            for(int j=0; j<n; j++){\\n                if(words[j] == str){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067888,
                "title": "1-line-c-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public int CountPrefixes(string[] words, string s)\\n    {\\n        return words.Count(s.StartsWith);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int CountPrefixes(string[] words, string s)\\n    {\\n        return words.Count(s.StartsWith);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064105,
                "title": "1-line-of-code-beast-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n func countPrefixes(_ words: [String], _ s: String) -> Int {\\n    \\n    return words.filter {s.hasPrefix($0)}.count\\n}\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n func countPrefixes(_ words: [String], _ s: String) -> Int {\\n    \\n    return words.filter {s.hasPrefix($0)}.count\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063523,
                "title": "c-solution-by-ajeet20-iit-kanpur",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n\\n        int count = 0;\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            string str = s.substr(0, i+1);\\n            for(int j = 0; j < words.size(); j++) {\\n                if(words[j] == str) count++;\\n            }\\n        }    \\n        return count;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n\\n        int count = 0;\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            string str = s.substr(0, i+1);\\n            for(int j = 0; j < words.size(); j++) {\\n                if(words[j] == str) count++;\\n            }\\n        }    \\n        return count;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062738,
                "title": "hash-map-unordered-set-c-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        \\n        unordered_map<string,int> map;\\n        for(auto it :words)\\n        {\\n            map[it]++;\\n        }\\n        int ans  = 0;\\n        unordered_set<string> seti(words.begin(), words.end());\\n        for(int j = 1;j <= s.size();j++)\\n        {\\n            string temp = s.substr(0,j);\\n            if(seti.find(temp) != seti.end())\\n            {\\n                seti.erase(temp);\\n                ans += map[temp]++;\\n                map.erase(temp);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        \\n        unordered_map<string,int> map;\\n        for(auto it :words)\\n        {\\n            map[it]++;\\n        }\\n        int ans  = 0;\\n        unordered_set<string> seti(words.begin(), words.end());\\n        for(int j = 1;j <= s.size();j++)\\n        {\\n            string temp = s.substr(0,j);\\n            if(seti.find(temp) != seti.end())\\n            {\\n                seti.erase(temp);\\n                ans += map[temp]++;\\n                map.erase(temp);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061412,
                "title": "using-hashset-without-any-in-build-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0 ; \\n        Set<String> hs = new HashSet<>() ;\\n        for(int j=1;j<=s.length();j++) {\\n               hs.add(s.substring(0,j)) ; \\n            }\\n        for(int i = 0 ; i<words.length ; i++){\\n            if(words[i].length()>s.length())continue ; \\n            // for(int j=1;j<=s.length();j++) {\\n            //     if(words[i].equals(s.substring(0,j))) {count++ ; break ;}\\n            // }\\n            if(hs.contains(words[i]))count++ ; \\n        }\\n        return count ; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0 ; \\n        Set<String> hs = new HashSet<>() ;\\n        for(int j=1;j<=s.length();j++) {\\n               hs.add(s.substring(0,j)) ; \\n            }\\n        for(int i = 0 ; i<words.length ; i++){\\n            if(words[i].length()>s.length())continue ; \\n            // for(int j=1;j<=s.length();j++) {\\n            //     if(words[i].equals(s.substring(0,j))) {count++ ; break ;}\\n            // }\\n            if(hs.contains(words[i]))count++ ; \\n        }\\n        return count ; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050484,
                "title": "js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function(words, s) {\\n      return words.filter((item) => s.startsWith(item)).length\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function(words, s) {\\n      return words.filter((item) => s.startsWith(item)).length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4050311,
                "title": "simple-easy-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function(words, s) {\\n   let count = 0\\n    for(let i = 0; i<words.length; i++){\\n         if(s.startsWith(words[i])){\\n            count = count + 1\\n         }\\n    }\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function(words, s) {\\n   let count = 0\\n    for(let i = 0; i<words.length; i++){\\n         if(s.startsWith(words[i])){\\n            count = count + 1\\n         }\\n    }\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4037732,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int countPrefixes(String[] words, String s) \\n    {\\n        int c = 0;\\n        for(int i = 1; i<=s.length(); i++)\\n        {\\n            String s1 = s.substring(0,i);\\n            for(int j = 0; j<words.length; j++)\\n            {\\n                if(words[j].equals(s1))\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int countPrefixes(String[] words, String s) \\n    {\\n        int c = 0;\\n        for(int i = 1; i<=s.length(); i++)\\n        {\\n            String s1 = s.substring(0,i);\\n            for(int j = 0; j<words.length; j++)\\n            {\\n                if(words[j].equals(s1))\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031001,
                "title": "100-beats-in-java",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0;\\n        for (String i : words)\\n            if (s.startsWith(i)) count++;\\n        return count;\\n\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0;\\n        for (String i : words)\\n            if (s.startsWith(i)) count++;\\n        return count;\\n\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023312,
                "title": "begineers-must-see",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {int a=0;\\n    for(int j=0;j<s.length();j++){\\n        for(int i=0;i<words.length;i++){\\n            if(words[i].equals (s.substring(0,j+1)))a++;\\n        }}\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {int a=0;\\n    for(int j=0;j<s.length();j++){\\n        for(int i=0;i<words.length;i++){\\n            if(words[i].equals (s.substring(0,j+1)))a++;\\n        }}\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014679,
                "title": "3lines-code-easy-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count=0;\\n        for(String str:words)\\n        {\\n            if(s.indexOf(str)==0)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count=0;\\n        for(String str:words)\\n        {\\n            if(s.indexOf(str)==0)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011936,
                "title": "direct-approach-using-java",
                "content": "\\n\\n# Java Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0;\\n        String temp = \"\";\\n        for(int i =0;i<s.length();i++){\\n            temp+=Character.toString(s.charAt(i));\\n            for(String x:words)\\n                if(temp.equals(x))\\n                    count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0;\\n        String temp = \"\";\\n        for(int i =0;i<s.length();i++){\\n            temp+=Character.toString(s.charAt(i));\\n            for(String x:words)\\n                if(temp.equals(x))\\n                    count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011673,
                "title": "easy-python-linear-search-82-72-faster",
                "content": "faster than\\xA082.72%\\n\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count = 0        \\n        # make s into tree.\\n        \\n        # traverse for each to see. If not, then not. \\n        for word in words:\\n            \\n            # word longer, cannot be prefix\\n            if len(word) > len(s):\\n                continue\\n                \\n            for i, ch in enumerate(word):\\n                \\n                if ch != s[i]:\\n                    break\\n                    \\n                if i == len(word) - 1:\\n                    count += 1\\n        \\n        return count\\n                \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count = 0        \\n        # make s into tree.\\n        \\n        # traverse for each to see. If not, then not. \\n        for word in words:\\n            \\n            # word longer, cannot be prefix\\n            if len(word) > len(s):\\n                continue\\n                \\n            for i, ch in enumerate(word):\\n                \\n                if ch != s[i]:\\n                    break\\n                    \\n                if i == len(word) - 1:\\n                    count += 1\\n        \\n        return count\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007127,
                "title": "easy-java-solution-0-ms-beats-100-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int c=0;\\n        for(int i=0;i<words.length;i++){\\n            if(s.startsWith(words[i]))\\n                c++;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int c=0;\\n        for(int i=0;i<words.length;i++){\\n            if(s.startsWith(words[i]))\\n                c++;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005419,
                "title": "world-easy-solution-in-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function(words, s) {\\n    let number=0;\\n    for(let i = 0 ; i< words.length; i++){\\n        let a = checkme(words[i], s);\\n        if(a){\\n            number++;\\n        }\\n    }\\n    return number;\\n    \\n};\\nfunction checkme(word, s){\\n    // if(word.length>s.length){\\n        for(let i = 0 ; i< word.length; i++){\\n            if(word[i]!=s[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    // }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function(words, s) {\\n    let number=0;\\n    for(let i = 0 ; i< words.length; i++){\\n        let a = checkme(words[i], s);\\n        if(a){\\n            number++;\\n        }\\n    }\\n    return number;\\n    \\n};\\nfunction checkme(word, s){\\n    // if(word.length>s.length){\\n        for(let i = 0 ; i< word.length; i++){\\n            if(word[i]!=s[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    // }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4004148,
                "title": "easy-c-solution-using-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int cnt=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            string str=words[i];\\n            if(s.find(str)==0)cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int cnt=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            string str=words[i];\\n            if(s.find(str)==0)cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4000672,
                "title": "typescript-1-line-solution-o-n",
                "content": "# Complexity\\n- Time complexity: $O(n)$\\n- Space complexity: $O(1)$\\n\\n# Code\\n```\\nconst countPrefixes = (words: string[], s: string): number => words.reduce((a, w) => s.startsWith(w) ? a + 1 : a, 0)\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Array",
                    "String"
                ],
                "code": "```\\nconst countPrefixes = (words: string[], s: string): number => words.reduce((a, w) => s.startsWith(w) ? a + 1 : a, 0)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3989630,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n int countPrefixes(List<String> words, String s) {\\n  int result = 0;\\n\\n  for (int i = 0; i < words.length; i++) {\\n    if (s.startsWith(words[i])) {\\n      result++;\\n    }\\n  }\\n  return result;\\n}\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n int countPrefixes(List<String> words, String s) {\\n  int result = 0;\\n\\n  for (int i = 0; i < words.length; i++) {\\n    if (s.startsWith(words[i])) {\\n      result++;\\n    }\\n  }\\n  return result;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3986090,
                "title": "simple-java-solution-no-sms-nor-registration-required",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf a word is a prefix of the string s, it means the string s starts with that word. The Java String class provides a method startsWith() that can be used to determine if a string starts with a certain prefix. We can use this method to simplify our solution.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize a Counter: Start by initializing a counter to zero. This will keep track of how many words from the array are prefixes of s.\\n\\n2. Iterate Over the Words: Go through each word in the words array.\\n\\n3. Check for Prefix: For each word, check if s starts with that word using the startsWith() method. If it does, increment the counter.\\n\\n4. Return the Counter: After checking all the words, return the counter.\\n\\n# Complexity\\n- Time complexity: O(n * m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nwhere n is the number of words and m is the average length of a word. This is because the startsWith() method compares characters of the word with the string s and, in the worst case, this can be O(m).\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nas we are using only a fixed amount of extra space (the counter) regardless of the size of the input.\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0;\\n\\n        for (int i = 0; i < words.length; i++){\\n            if (s.startsWith(words[i])){\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0;\\n\\n        for (int i = 0; i < words.length; i++){\\n            if (s.startsWith(words[i])){\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981590,
                "title": "easy-python-solution-slicing-string",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        output = 0 \\n        for i in words :\\n            if i == s[:len(i)] :\\n                output += 1\\n        return output\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        output = 0 \\n        for i in words :\\n            if i == s[:len(i)] :\\n                output += 1\\n        return output\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974113,
                "title": "check-prefix-java-o-n",
                "content": "\\tclass Solution {\\n\\t\\tpublic int countPrefixes(String[] words, String s) {\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor(String word: words){\\n\\t\\t\\t\\tint temp = word.length(); // substring length\\n\\t\\t\\t\\tif((s.length() >= temp) && word.equals(s.substring(0,temp))) count++;\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n\\t\\tpublic int countPrefixes(String[] words, String s) {\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor(String word: words){\\n\\t\\t\\t\\tint temp = word.length(); // substring length\\n\\t\\t\\t\\tif((s.length() >= temp) && word.equals(s.substring(0,temp))) count++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3971387,
                "title": "one-line-solution-using-list-comprehensions",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        return sum([words.count(s[:i]) for i in range(1, len(s)+1)])\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        return sum([words.count(s[:i]) for i in range(1, len(s)+1)])\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954226,
                "title": "easy",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count = 0\\n        for i in words:\\n            if i == s[0:len(i)]: \\n                count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count = 0\\n        for i in words:\\n            if i == s[0:len(i)]: \\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946446,
                "title": "easy-php-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param String[] $words\\n     * @param String $s\\n     * @return Integer\\n     */\\n    function countPrefixes($words, $s) {\\n        $count = 0;\\n        $sLen = strlen($s);\\n        for($i=1; $i<=$sLen; $i++){\\n            $str = substr($s,0,$i);\\n            foreach($words as $word){\\n                if($word == $str){\\n                    $count++;\\n                }\\n            }\\n        }\\n\\n        return $count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param String[] $words\\n     * @param String $s\\n     * @return Integer\\n     */\\n    function countPrefixes($words, $s) {\\n        $count = 0;\\n        $sLen = strlen($s);\\n        for($i=1; $i<=$sLen; $i++){\\n            $str = substr($s,0,$i);\\n            foreach($words as $word){\\n                if($word == $str){\\n                    $count++;\\n                }\\n            }\\n        }\\n\\n        return $count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941401,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function(words, s) {\\n  const hasPrefix = words.filter( string => {\\n    return s.startsWith(string)\\n  })\\n\\n  return hasPrefix.length\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function(words, s) {\\n  const hasPrefix = words.filter( string => {\\n    return s.startsWith(string)\\n  })\\n\\n  return hasPrefix.length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3941261,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int countPrefixes(List<String> words, String s) {\\n      var c = 0;\\n      for (int i = 0; i < words.length; i++) {\\n          if (s.startsWith(words[i])) {\\n              c += 1;\\n          }\\n      }\\n\\n      return c;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int countPrefixes(List<String> words, String s) {\\n      var c = 0;\\n      for (int i = 0; i < words.length; i++) {\\n          if (s.startsWith(words[i])) {\\n              c += 1;\\n          }\\n      }\\n\\n      return c;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3940064,
                "title": "javascript-single-line-functional-declarative-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function(words, s) {\\n    return words.filter(word => s.startsWith(word)).length\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function(words, s) {\\n    return words.filter(word => s.startsWith(word)).length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3937084,
                "title": "javascript-beats-32-51",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function(words, s) {\\n    let count=0;\\n   for (let index = 0; index < words.length; index++) if (s.startsWith(words[index])) count += 1;\\n   return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function(words, s) {\\n    let count=0;\\n   for (let index = 0; index < words.length; index++) if (s.startsWith(words[index])) count += 1;\\n   return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3936190,
                "title": "python-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def countPrefixes(self, words, s):\\n        count = 0\\n        for i in range(len(words)):\\n            item = words[i]\\n            if s[0 : len(item)] == item:\\n                count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def countPrefixes(self, words, s):\\n        count = 0\\n        for i in range(len(words)):\\n            item = words[i]\\n            if s[0 : len(item)] == item:\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3932521,
                "title": "simple-approach-runtime-60ms-beat-93-in-runtime-and-memory",
                "content": "# Intuition\\n=>check prefix of each string in word if equal then increment the count otherwise pass on\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n=>create count equal to zero and iterate a loop and check for each string in word if its string equal to starting elements of prefix string increment the count otherwise pass\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        cnt=0\\n        for i in words:\\n            if i==s[:len(i)]:\\n                cnt+=1\\n        return cnt\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        cnt=0\\n        for i in words:\\n            if i==s[:len(i)]:\\n                cnt+=1\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931816,
                "title": "ez-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int sum=0;\\n        for(int i=0;i<words.size();i++){\\n            if(words[i].size()>s.size()){\\n                continue;\\n            }\\n            else {\\n                if(words[i]==s.substr(0,words[i].size())){\\n                    sum++;\\n                }\\n            }\\n        }\\n        return sum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int sum=0;\\n        for(int i=0;i<words.size();i++){\\n            if(words[i].size()>s.size()){\\n                continue;\\n            }\\n            else {\\n                if(words[i]==s.substr(0,words[i].size())){\\n                    sum++;\\n                }\\n            }\\n        }\\n        return sum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923639,
                "title": "very-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n# - Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count=0;\\n\\n        for(String word: words){\\n            if(s.startsWith(word)) count++;\\n        }\\n        return count;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count=0;\\n\\n        for(String word: words){\\n            if(s.startsWith(word)) count++;\\n        }\\n        return count;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923636,
                "title": "very-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count=0;\\n\\n        for(String word: words){\\n            if(s.startsWith(word)) count++;\\n        }\\n        return count;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count=0;\\n\\n        for(String word: words){\\n            if(s.startsWith(word)) count++;\\n        }\\n        return count;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1732909,
                "content": [
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string allowed) {\\n        int ans=0;\\n        for(int i=0;i<words.size();i++){\\n            string s=words[i];\\n            int z=s.size();\\n            for(int k=0;k<s.size();k++){\\n               if (s[k] == allowed[k]) {\\n                   z--;\\n               }\\n            }\\n            if(z==0){\\n                ans++;\\n            }\\n        }\\n        return ans; \\n    }\\n};"
                    },
                    {
                        "username": "DeepaSingh13",
                        "content": "word =[\"feh\",\"w\",\"w\",\"lwd\",\"c\",\"s\",\"vk\",\"zwlv\",\"n\",\"w\",\"sw\",\"qrd\",\"w\",\"w\",\"mqe\",\"w\",\"w\",\"w\",\"gb\",\"w\",\"qy\",\"xs\",\"br\",\"w\",\"rypg\",\"wh\",\"g\",\"w\",\"w\",\"fh\",\"w\",\"w\",\"sccy\"]\\nString s= \"w\";\\n\\nExpected output : 14 \\nMy output : 15\\nHow the expected o/p is coming as 14 if we count manually so it is 15\\n"
                    },
                    {
                        "username": "DhanushAM",
                        "content": " \\'wh\\' is not a prefix of \\'w\\'. A prefix is a sequence of characters that appears at the beginning of a longer string. In this case, \\'w\\' is a single character, and \\'wh\\' is two characters. \\'w\\' is not a longer string containing \\'wh\\' as a prefix, so \\'wh\\' cannot be considered a prefix of \\'w\\'."
                    },
                    {
                        "username": "manuatleet12195",
                        "content": "return sum([1 for i in words if s.startswith(i)])"
                    },
                    {
                        "username": "NarayanSharma",
                        "content": "Please check the test case No 122, in this case words have \"a\" also, so its output should be 135 \\n\\n`var countPrefixes = function(words, s) {\\n    let count = 0;\\n    for(let i = 0; i < words.length; i++){\\n        if((words[i][0] === s[0]) && s.includes(words[i])){\\n            count++\\n        }\\n    }\\n    return count\\n}; `"
                    },
                    {
                        "username": "nancychauhan99",
                        "content": "What is the time complexity for best and worst case? This question has come as google interview and an official solution from leetcode is missing, why? though its a easy one but approaches to handle and TC worth discussing, NO?"
                    },
                    {
                        "username": "brandonallen",
                        "content": "[vaguely] Every solution involves some form of iterating through words[], and comparing each word to s. So if n == length(words) and m == length(s), worst case is O(n*m); if every word is a prefix, and has a length proportional to m. Best case, if every word in words isn't a prefix, and the first character isn't shared between words[i] and s, then it's O(1) time to compare each word to s, so O(n) complexity. You still have to check every word, since they aren't sorted, so you could never beat O(n).\nIf you use a trie and store the number of occurrences of each distinct element in words, if seems like you could potentially optimize slightly. But I sampled the fastest submitted code, and the constraints (n and m) are small enough that it's faster to just brute force it."
                    }
                ]
            },
            {
                "id": 2039571,
                "content": [
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string allowed) {\\n        int ans=0;\\n        for(int i=0;i<words.size();i++){\\n            string s=words[i];\\n            int z=s.size();\\n            for(int k=0;k<s.size();k++){\\n               if (s[k] == allowed[k]) {\\n                   z--;\\n               }\\n            }\\n            if(z==0){\\n                ans++;\\n            }\\n        }\\n        return ans; \\n    }\\n};"
                    },
                    {
                        "username": "DeepaSingh13",
                        "content": "word =[\"feh\",\"w\",\"w\",\"lwd\",\"c\",\"s\",\"vk\",\"zwlv\",\"n\",\"w\",\"sw\",\"qrd\",\"w\",\"w\",\"mqe\",\"w\",\"w\",\"w\",\"gb\",\"w\",\"qy\",\"xs\",\"br\",\"w\",\"rypg\",\"wh\",\"g\",\"w\",\"w\",\"fh\",\"w\",\"w\",\"sccy\"]\\nString s= \"w\";\\n\\nExpected output : 14 \\nMy output : 15\\nHow the expected o/p is coming as 14 if we count manually so it is 15\\n"
                    },
                    {
                        "username": "DhanushAM",
                        "content": " \\'wh\\' is not a prefix of \\'w\\'. A prefix is a sequence of characters that appears at the beginning of a longer string. In this case, \\'w\\' is a single character, and \\'wh\\' is two characters. \\'w\\' is not a longer string containing \\'wh\\' as a prefix, so \\'wh\\' cannot be considered a prefix of \\'w\\'."
                    },
                    {
                        "username": "manuatleet12195",
                        "content": "return sum([1 for i in words if s.startswith(i)])"
                    },
                    {
                        "username": "NarayanSharma",
                        "content": "Please check the test case No 122, in this case words have \"a\" also, so its output should be 135 \\n\\n`var countPrefixes = function(words, s) {\\n    let count = 0;\\n    for(let i = 0; i < words.length; i++){\\n        if((words[i][0] === s[0]) && s.includes(words[i])){\\n            count++\\n        }\\n    }\\n    return count\\n}; `"
                    },
                    {
                        "username": "nancychauhan99",
                        "content": "What is the time complexity for best and worst case? This question has come as google interview and an official solution from leetcode is missing, why? though its a easy one but approaches to handle and TC worth discussing, NO?"
                    },
                    {
                        "username": "brandonallen",
                        "content": "[vaguely] Every solution involves some form of iterating through words[], and comparing each word to s. So if n == length(words) and m == length(s), worst case is O(n*m); if every word is a prefix, and has a length proportional to m. Best case, if every word in words isn't a prefix, and the first character isn't shared between words[i] and s, then it's O(1) time to compare each word to s, so O(n) complexity. You still have to check every word, since they aren't sorted, so you could never beat O(n).\nIf you use a trie and store the number of occurrences of each distinct element in words, if seems like you could potentially optimize slightly. But I sampled the fastest submitted code, and the constraints (n and m) are small enough that it's faster to just brute force it."
                    }
                ]
            },
            {
                "id": 1908446,
                "content": [
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string allowed) {\\n        int ans=0;\\n        for(int i=0;i<words.size();i++){\\n            string s=words[i];\\n            int z=s.size();\\n            for(int k=0;k<s.size();k++){\\n               if (s[k] == allowed[k]) {\\n                   z--;\\n               }\\n            }\\n            if(z==0){\\n                ans++;\\n            }\\n        }\\n        return ans; \\n    }\\n};"
                    },
                    {
                        "username": "DeepaSingh13",
                        "content": "word =[\"feh\",\"w\",\"w\",\"lwd\",\"c\",\"s\",\"vk\",\"zwlv\",\"n\",\"w\",\"sw\",\"qrd\",\"w\",\"w\",\"mqe\",\"w\",\"w\",\"w\",\"gb\",\"w\",\"qy\",\"xs\",\"br\",\"w\",\"rypg\",\"wh\",\"g\",\"w\",\"w\",\"fh\",\"w\",\"w\",\"sccy\"]\\nString s= \"w\";\\n\\nExpected output : 14 \\nMy output : 15\\nHow the expected o/p is coming as 14 if we count manually so it is 15\\n"
                    },
                    {
                        "username": "DhanushAM",
                        "content": " \\'wh\\' is not a prefix of \\'w\\'. A prefix is a sequence of characters that appears at the beginning of a longer string. In this case, \\'w\\' is a single character, and \\'wh\\' is two characters. \\'w\\' is not a longer string containing \\'wh\\' as a prefix, so \\'wh\\' cannot be considered a prefix of \\'w\\'."
                    },
                    {
                        "username": "manuatleet12195",
                        "content": "return sum([1 for i in words if s.startswith(i)])"
                    },
                    {
                        "username": "NarayanSharma",
                        "content": "Please check the test case No 122, in this case words have \"a\" also, so its output should be 135 \\n\\n`var countPrefixes = function(words, s) {\\n    let count = 0;\\n    for(let i = 0; i < words.length; i++){\\n        if((words[i][0] === s[0]) && s.includes(words[i])){\\n            count++\\n        }\\n    }\\n    return count\\n}; `"
                    },
                    {
                        "username": "nancychauhan99",
                        "content": "What is the time complexity for best and worst case? This question has come as google interview and an official solution from leetcode is missing, why? though its a easy one but approaches to handle and TC worth discussing, NO?"
                    },
                    {
                        "username": "brandonallen",
                        "content": "[vaguely] Every solution involves some form of iterating through words[], and comparing each word to s. So if n == length(words) and m == length(s), worst case is O(n*m); if every word is a prefix, and has a length proportional to m. Best case, if every word in words isn't a prefix, and the first character isn't shared between words[i] and s, then it's O(1) time to compare each word to s, so O(n) complexity. You still have to check every word, since they aren't sorted, so you could never beat O(n).\nIf you use a trie and store the number of occurrences of each distinct element in words, if seems like you could potentially optimize slightly. But I sampled the fastest submitted code, and the constraints (n and m) are small enough that it's faster to just brute force it."
                    }
                ]
            },
            {
                "id": 1875133,
                "content": [
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string allowed) {\\n        int ans=0;\\n        for(int i=0;i<words.size();i++){\\n            string s=words[i];\\n            int z=s.size();\\n            for(int k=0;k<s.size();k++){\\n               if (s[k] == allowed[k]) {\\n                   z--;\\n               }\\n            }\\n            if(z==0){\\n                ans++;\\n            }\\n        }\\n        return ans; \\n    }\\n};"
                    },
                    {
                        "username": "DeepaSingh13",
                        "content": "word =[\"feh\",\"w\",\"w\",\"lwd\",\"c\",\"s\",\"vk\",\"zwlv\",\"n\",\"w\",\"sw\",\"qrd\",\"w\",\"w\",\"mqe\",\"w\",\"w\",\"w\",\"gb\",\"w\",\"qy\",\"xs\",\"br\",\"w\",\"rypg\",\"wh\",\"g\",\"w\",\"w\",\"fh\",\"w\",\"w\",\"sccy\"]\\nString s= \"w\";\\n\\nExpected output : 14 \\nMy output : 15\\nHow the expected o/p is coming as 14 if we count manually so it is 15\\n"
                    },
                    {
                        "username": "DhanushAM",
                        "content": " \\'wh\\' is not a prefix of \\'w\\'. A prefix is a sequence of characters that appears at the beginning of a longer string. In this case, \\'w\\' is a single character, and \\'wh\\' is two characters. \\'w\\' is not a longer string containing \\'wh\\' as a prefix, so \\'wh\\' cannot be considered a prefix of \\'w\\'."
                    },
                    {
                        "username": "manuatleet12195",
                        "content": "return sum([1 for i in words if s.startswith(i)])"
                    },
                    {
                        "username": "NarayanSharma",
                        "content": "Please check the test case No 122, in this case words have \"a\" also, so its output should be 135 \\n\\n`var countPrefixes = function(words, s) {\\n    let count = 0;\\n    for(let i = 0; i < words.length; i++){\\n        if((words[i][0] === s[0]) && s.includes(words[i])){\\n            count++\\n        }\\n    }\\n    return count\\n}; `"
                    },
                    {
                        "username": "nancychauhan99",
                        "content": "What is the time complexity for best and worst case? This question has come as google interview and an official solution from leetcode is missing, why? though its a easy one but approaches to handle and TC worth discussing, NO?"
                    },
                    {
                        "username": "brandonallen",
                        "content": "[vaguely] Every solution involves some form of iterating through words[], and comparing each word to s. So if n == length(words) and m == length(s), worst case is O(n*m); if every word is a prefix, and has a length proportional to m. Best case, if every word in words isn't a prefix, and the first character isn't shared between words[i] and s, then it's O(1) time to compare each word to s, so O(n) complexity. You still have to check every word, since they aren't sorted, so you could never beat O(n).\nIf you use a trie and store the number of occurrences of each distinct element in words, if seems like you could potentially optimize slightly. But I sampled the fastest submitted code, and the constraints (n and m) are small enough that it's faster to just brute force it."
                    }
                ]
            },
            {
                "id": 1676289,
                "content": [
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string allowed) {\\n        int ans=0;\\n        for(int i=0;i<words.size();i++){\\n            string s=words[i];\\n            int z=s.size();\\n            for(int k=0;k<s.size();k++){\\n               if (s[k] == allowed[k]) {\\n                   z--;\\n               }\\n            }\\n            if(z==0){\\n                ans++;\\n            }\\n        }\\n        return ans; \\n    }\\n};"
                    },
                    {
                        "username": "DeepaSingh13",
                        "content": "word =[\"feh\",\"w\",\"w\",\"lwd\",\"c\",\"s\",\"vk\",\"zwlv\",\"n\",\"w\",\"sw\",\"qrd\",\"w\",\"w\",\"mqe\",\"w\",\"w\",\"w\",\"gb\",\"w\",\"qy\",\"xs\",\"br\",\"w\",\"rypg\",\"wh\",\"g\",\"w\",\"w\",\"fh\",\"w\",\"w\",\"sccy\"]\\nString s= \"w\";\\n\\nExpected output : 14 \\nMy output : 15\\nHow the expected o/p is coming as 14 if we count manually so it is 15\\n"
                    },
                    {
                        "username": "DhanushAM",
                        "content": " \\'wh\\' is not a prefix of \\'w\\'. A prefix is a sequence of characters that appears at the beginning of a longer string. In this case, \\'w\\' is a single character, and \\'wh\\' is two characters. \\'w\\' is not a longer string containing \\'wh\\' as a prefix, so \\'wh\\' cannot be considered a prefix of \\'w\\'."
                    },
                    {
                        "username": "manuatleet12195",
                        "content": "return sum([1 for i in words if s.startswith(i)])"
                    },
                    {
                        "username": "NarayanSharma",
                        "content": "Please check the test case No 122, in this case words have \"a\" also, so its output should be 135 \\n\\n`var countPrefixes = function(words, s) {\\n    let count = 0;\\n    for(let i = 0; i < words.length; i++){\\n        if((words[i][0] === s[0]) && s.includes(words[i])){\\n            count++\\n        }\\n    }\\n    return count\\n}; `"
                    },
                    {
                        "username": "nancychauhan99",
                        "content": "What is the time complexity for best and worst case? This question has come as google interview and an official solution from leetcode is missing, why? though its a easy one but approaches to handle and TC worth discussing, NO?"
                    },
                    {
                        "username": "brandonallen",
                        "content": "[vaguely] Every solution involves some form of iterating through words[], and comparing each word to s. So if n == length(words) and m == length(s), worst case is O(n*m); if every word is a prefix, and has a length proportional to m. Best case, if every word in words isn't a prefix, and the first character isn't shared between words[i] and s, then it's O(1) time to compare each word to s, so O(n) complexity. You still have to check every word, since they aren't sorted, so you could never beat O(n).\nIf you use a trie and store the number of occurrences of each distinct element in words, if seems like you could potentially optimize slightly. But I sampled the fastest submitted code, and the constraints (n and m) are small enough that it's faster to just brute force it."
                    }
                ]
            }
        ]
    },
    {
        "title": "Check if Number Has Equal Digit Count and Digit Value",
        "question_content": "<p>You are given a <strong>0-indexed</strong> string <code>num</code> of length <code>n</code> consisting of digits.</p>\n\n<p>Return <code>true</code> <em>if for <strong>every</strong> index </em><code>i</code><em> in the range </em><code>0 &lt;= i &lt; n</code><em>, the digit </em><code>i</code><em> occurs </em><code>num[i]</code><em> times in </em><code>num</code><em>, otherwise return </em><code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;1210&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong>\nnum[0] = &#39;1&#39;. The digit 0 occurs once in num.\nnum[1] = &#39;2&#39;. The digit 1 occurs twice in num.\nnum[2] = &#39;1&#39;. The digit 2 occurs once in num.\nnum[3] = &#39;0&#39;. The digit 3 occurs zero times in num.\nThe condition holds true for every index in &quot;1210&quot;, so return true.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;030&quot;\n<strong>Output:</strong> false\n<strong>Explanation:</strong>\nnum[0] = &#39;0&#39;. The digit 0 should occur zero times, but actually occurs twice in num.\nnum[1] = &#39;3&#39;. The digit 1 should occur three times, but actually occurs zero times in num.\nnum[2] = &#39;0&#39;. The digit 2 occurs zero times in num.\nThe indices 0 and 1 both violate the condition, so return false.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == num.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10</code></li>\n\t<li><code>num</code> consists of digits.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 2083839,
                "title": "brute-force-and-one-liner",
                "content": "I am sure some clever solution exists, but I did not want to spend too much time.\\n\\nYou can realize that the number of strings that match the criteria is very small - 7, to be exact (see the second solution below).\\n\\n#### Brute-Force\\n**C++**\\n```cpp\\nbool digitCount(string num) {\\n    int cnt[10] = {};\\n    for (auto n : num)\\n        ++cnt[n - \\'0\\'];\\n    for (int i = 0; i < num.size(); ++i)\\n        if (cnt[i] != num[i] - \\'0\\')\\n            return false;\\n    return true;\\n}\\n```\\n\\n#### One-Liner\\n```cpp\\nbool digitCount(string &num) {\\n    return unordered_set<string>{\"1210\", \"2020\" , \"21200\", \"3211000\", \"42101000\", \"521001000\", \"6210001000\"}.count(num);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nbool digitCount(string num) {\\n    int cnt[10] = {};\\n    for (auto n : num)\\n        ++cnt[n - \\'0\\'];\\n    for (int i = 0; i < num.size(); ++i)\\n        if (cnt[i] != num[i] - \\'0\\')\\n            return false;\\n    return true;\\n}\\n```\n```cpp\\nbool digitCount(string &num) {\\n    return unordered_set<string>{\"1210\", \"2020\" , \"21200\", \"3211000\", \"42101000\", \"521001000\", \"6210001000\"}.count(num);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2084196,
                "title": "java-using-freq-array-easy-straightforward-solution",
                "content": "***UpVote if u find this Solution Useful***\\n\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] freqArr = new int[10];  // n = 10 given in constraints;\\n        \\n        \\n        for(char ch : num.toCharArray()){\\n            freqArr[ch-\\'0\\']++;\\n        }\\n        \\n        for(int i=0;i<num.length();i++){\\n            int freq = num.charAt(i)-\\'0\\';  //freq of each indexValue;\\n            freqArr[i] = freqArr[i] - freq; \\n        }\\n        for(int i=0;i<10;i++){\\n            if(freqArr[i]!=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] freqArr = new int[10];  // n = 10 given in constraints;\\n        \\n        \\n        for(char ch : num.toCharArray()){\\n            freqArr[ch-\\'0\\']++;\\n        }\\n        \\n        for(int i=0;i<num.length();i++){\\n            int freq = num.charAt(i)-\\'0\\';  //freq of each indexValue;\\n            freqArr[i] = freqArr[i] - freq; \\n        }\\n        for(int i=0;i<10;i++){\\n            if(freqArr[i]!=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083864,
                "title": "java-python-3-simple-code",
                "content": "```java\\n    public boolean digitCount(String num) {\\n        int[] cnt = new int[11];\\n        char[] charArr = num.toCharArray();\\n        for (char d : charArr) {\\n            ++cnt[d - \\'0\\'];\\n        }\\n        for (int i = 0; i < charArr.length; ++i) {\\n            if (cnt[i] != charArr[i] - \\'0\\') {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```\\n```python\\n    def digitCount(self, num: str) -> bool:\\n        c = Counter(map(int, num))\\n        return all(c[i] == int(d) for i, d in enumerate(num))\\n```",
                "solutionTags": [],
                "code": "```java\\n    public boolean digitCount(String num) {\\n        int[] cnt = new int[11];\\n        char[] charArr = num.toCharArray();\\n        for (char d : charArr) {\\n            ++cnt[d - \\'0\\'];\\n        }\\n        for (int i = 0; i < charArr.length; ++i) {\\n            if (cnt[i] != charArr[i] - \\'0\\') {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```\n```python\\n    def digitCount(self, num: str) -> bool:\\n        c = Counter(map(int, num))\\n        return all(c[i] == int(d) for i, d in enumerate(num))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2083791,
                "title": "confusing-yet-simple-hashmap-solution-c",
                "content": "This question was really easy, but head scratching at the same time. I had to waste so much time only because of the confusion to chose number or character type hashmap.\\nSo, for simplicity we will maintain a int to int hashmap, which will store the frequency of a particular number.\\nThen for every index, **we have to check if the frequency of that index in hashmap is equal to the number at that index**.\\nHere is the solution too \\uD83D\\uDE0A\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        unordered_map<int,int> mpp;\\n        int n= num.length();\\n        for(auto it:num){\\n            int x = it - \\'0\\';\\n            mpp[x]++; // Store the frequency of the char as a number\\n        }\\n        for(int i=0;i<n;i++){\\n            int x = num[i] - \\'0\\'; // get the char as number\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if(mpp[i] != x) // f the number is not equal to its frequency we return false\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n```\\n\\n**Approach 2:**\\nWe just count the occurences of that index in the string. Thanks to @VisD566 for this approach.\\n\\n```\\nbool digitCount(string s) {\\n    for(int i=0; i<s.size(); i++){\\n        if(count(s.begin(), s.end(), i+\\'0\\') !=  s[i]-\\'0\\')\\n            return false;\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        unordered_map<int,int> mpp;\\n        int n= num.length();\\n        for(auto it:num){\\n            int x = it - \\'0\\';\\n            mpp[x]++; // Store the frequency of the char as a number\\n        }\\n        for(int i=0;i<n;i++){\\n            int x = num[i] - \\'0\\'; // get the char as number\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if(mpp[i] != x) // f the number is not equal to its frequency we return false\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n```\n```\\nbool digitCount(string s) {\\n    for(int i=0; i<s.size(); i++){\\n        if(count(s.begin(), s.end(), i+\\'0\\') !=  s[i]-\\'0\\')\\n            return false;\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083892,
                "title": "c-map-solution-o-n-easy-and-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        unordered_map<char, int> mpp;\\n        \\n        for(int i=0; i<num.size(); i++)\\n            mpp[num[i]]++;\\n        \\n\\n        for(int i=0; i<num.size(); i++){\\n            char c =\\'0\\' + i;\\n            // cout<<c<<endl;\\n            if(num[i] != \\'0\\' + mpp[c]){\\n                // cout<<num[i]<<\" \"<<mpp[c]<<endl;\\n                return false;\\n            }\\n                \\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\n\\n**Check out my youtube channel for related content\\nhttps://www.youtube.com/@ignition548/featured**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        unordered_map<char, int> mpp;\\n        \\n        for(int i=0; i<num.size(); i++)\\n            mpp[num[i]]++;\\n        \\n\\n        for(int i=0; i<num.size(); i++){\\n            char c =\\'0\\' + i;\\n            // cout<<c<<endl;\\n            if(num[i] != \\'0\\' + mpp[c]){\\n                // cout<<num[i]<<\" \"<<mpp[c]<<endl;\\n                return false;\\n            }\\n                \\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3164855,
                "title": "easy-python3-solution-using-count",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        for i in range(len(num)):\\n            if int(num[i]) != num.count(str(i)):\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        for i in range(len(num)):\\n            if int(num[i]) != num.count(str(i)):\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083889,
                "title": "straightforward",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string nums) {\\n        unordered_map<int,int> umap;\\n        for(int i=0;i<nums.length();i++)\\n        {\\n            string temp=\"\";\\n            temp+=nums[i];\\n            int n=stoi(temp);\\n            umap[n]++;\\n        }\\n        for(int i=0;i<nums.length();i++)\\n        {\\n            string temp=\"\";\\n            temp+=nums[i];\\n            int n=stoi(temp);\\n            \\n            //Number of times expected != Number of times occured \\n            if(n!=umap[i])\\n                return false;\\n                \\n        }\\n        return true;\\n    }\\n};\\n```\\n**Like it? Please Upvote ;-)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string nums) {\\n        unordered_map<int,int> umap;\\n        for(int i=0;i<nums.length();i++)\\n        {\\n            string temp=\"\";\\n            temp+=nums[i];\\n            int n=stoi(temp);\\n            umap[n]++;\\n        }\\n        for(int i=0;i<nums.length();i++)\\n        {\\n            string temp=\"\";\\n            temp+=nums[i];\\n            int n=stoi(temp);\\n            \\n            //Number of times expected != Number of times occured \\n            if(n!=umap[i])\\n                return false;\\n                \\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083808,
                "title": "java-simple",
                "content": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n         \\n        int  indexCount[] = new int[10];\\n        \\n        for(char c:num.toCharArray()){\\n            indexCount[c-\\'0\\']++;\\n        }\\n        \\n        for(int i=0;i<num.length();i++){\\n            if(Character.getNumericValue(num.charAt(i)) != indexCount[i])\\n            return false;   \\n        }\\n            \\n        return true;\\n    }\\n}\\n   \\n\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n         \\n        int  indexCount[] = new int[10];\\n        \\n        for(char c:num.toCharArray()){\\n            indexCount[c-\\'0\\']++;\\n        }\\n        \\n        for(int i=0;i<num.length();i++){\\n            if(Character.getNumericValue(num.charAt(i)) != indexCount[i])\\n            return false;   \\n        }\\n            \\n        return true;\\n    }\\n}\\n   \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2132635,
                "title": "simple-and-fast-javascript-typescript-solution",
                "content": "My simple and fast JS/TS solution:\\n```\\nfunction digitCount(num: string): boolean {\\n    const arr = Array(num.length).fill(0);\\n    for (const char of num) {\\n        arr[Number(char)]++;\\n    }\\n    return arr.join(\\'\\') === num;\\n};\\n```\\n\\nResult:\\nRuntime:\\xA073 ms, faster than\\xA097.44%\\xA0of\\xA0TypeScript\\xA0online submissions for\\xA0Check if Number Has Equal Digit Count and Digit Value.\\nMemory Usage:\\xA044.5 MB, less than\\xA053.85%\\xA0of\\xA0TypeScript\\xA0online submissions for\\xA0Check if Number Has Equal Digit Count and Digit Value.\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction digitCount(num: string): boolean {\\n    const arr = Array(num.length).fill(0);\\n    for (const char of num) {\\n        arr[Number(char)]++;\\n    }\\n    return arr.join(\\'\\') === num;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2083994,
                "title": "python-3-using-counter-fast-solution-one-liner",
                "content": "Approach: Create a dict storing frequency of each number and then just compare the index with frequency.\\n\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        d = Counter(num)\\n        for i in range(len(num)):\\n            if int(num[i])!=d.get(str(i), 0):\\n                return False\\n        return True\\n```\\n\\nTwo-Liner:\\n\\n```\\n\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        d = collections.Counter(num)\\n        return all([int(num[i])==d.get(str(i), 0) for i in range(len(num))])\\n```\\n\\nOne Liner (slight modification):\\n\\n```\\n\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        return all([int(num[i])==Counter(num)[f\\'{i}\\'] for i in range(len(num))])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        d = Counter(num)\\n        for i in range(len(num)):\\n            if int(num[i])!=d.get(str(i), 0):\\n                return False\\n        return True\\n```\n```\\n\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        d = collections.Counter(num)\\n        return all([int(num[i])==d.get(str(i), 0) for i in range(len(num))])\\n```\n```\\n\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        return all([int(num[i])==Counter(num)[f\\'{i}\\'] for i in range(len(num))])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084001,
                "title": "brute-force-c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<num.length();i++)\\n        {\\n             mp[num[i]]++;\\n        }\\n        for(auto ele: mp)\\n        {\\n            \\n            if(ele.second!=num[ele.first-\\'0\\']-\\'0\\')\\n                return false;\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<num.length();i++)\\n        {\\n             mp[num[i]]++;\\n        }\\n        for(auto ele: mp)\\n        {\\n            \\n            if(ele.second!=num[ele.first-\\'0\\']-\\'0\\')\\n                return false;\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2730033,
                "title": "c-easy-explained-map",
                "content": "1. create a map to calculate the frequency\\n2. iterate the string & check if frequncy is same with index+1 if not matched return false\\n3. else return true\\n\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string s) {\\n        unordered_map<char, int>mp;\\n        for(int i=0;i<s.size();i++)\\n            mp[s[i]]++;\\n        for(int i=0; i<s.size(); i++)\\n        {\\n            char c=i+\\'0\\';\\n            if(mp[c]!=s[i]-\\'0\\')\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string s) {\\n        unordered_map<char, int>mp;\\n        for(int i=0;i<s.size();i++)\\n            mp[s[i]]++;\\n        for(int i=0; i<s.size(); i++)\\n        {\\n            char c=i+\\'0\\';\\n            if(mp[c]!=s[i]-\\'0\\')\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322016,
                "title": "easy-python-solution-using-hashmap",
                "content": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        \\n        h = {}\\n        n = len(num)\\n        \\n        for i in range(n):\\n            h[i] = num[i]\\n            \\n        for i in h:\\n            if(num.count(str(i))!=int(h[i])):\\n                return 0\\n        \\n        return 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        \\n        h = {}\\n        n = len(num)\\n        \\n        for i in range(n):\\n            h[i] = num[i]\\n            \\n        for i in h:\\n            if(num.count(str(i))!=int(h[i])):\\n                return 0\\n        \\n        return 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2100089,
                "title": "easy-python-solution",
                "content": "```\\ndef digitCount(self, num: str) -> bool:\\n        for i in range(len(num)):\\n            if num.count(str(i))!=int(num[i]):\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef digitCount(self, num: str) -> bool:\\n        for i in range(len(num)):\\n            if num.count(str(i))!=int(num[i]):\\n                return False\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2089906,
                "title": "o-n-solution",
                "content": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n          HashMap<Integer,Integer> map = new HashMap<>();\\n//        First we are marking the frequency for the number. As we are given in the question, num.charAt(i) is the\\n//        frequency of the number i in the num String.\\n        for(int number = 0; number < num.length(); number++){\\n            int frequency = Character.getNumericValue(num.charAt(number));\\n            map.put(number,frequency);\\n        }\\n//        Now we are traversing through the string.\\n        for(int index = 0; index< num.length(); index++) {\\n//            If character at index i is less than num.length(), then only we need to know its frequency.\\n            if (Character.getNumericValue(num.charAt(index)) < num.length()) {\\n//                Get the frequency of the number and subtract 1 from it if it is present.\\n                int frequency = map.get(Character.getNumericValue(num.charAt(index))) - 1;\\n                map.put(Character.getNumericValue(num.charAt(index)), frequency);\\n            }\\n        }\\n//      If all the values are 0 , then only it is right otherwise , the frequency is either more or less than the\\n//        specified frequency, hence return false;\\n        for (int i = 0; i < num.length(); i++) {\\n            if(map.get(i) !=0){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\nIf you liked the solution or found the solution unique , please upvote :)\\nThank you",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n          HashMap<Integer,Integer> map = new HashMap<>();\\n//        First we are marking the frequency for the number. As we are given in the question, num.charAt(i) is the\\n//        frequency of the number i in the num String.\\n        for(int number = 0; number < num.length(); number++){\\n            int frequency = Character.getNumericValue(num.charAt(number));\\n            map.put(number,frequency);\\n        }\\n//        Now we are traversing through the string.\\n        for(int index = 0; index< num.length(); index++) {\\n//            If character at index i is less than num.length(), then only we need to know its frequency.\\n            if (Character.getNumericValue(num.charAt(index)) < num.length()) {\\n//                Get the frequency of the number and subtract 1 from it if it is present.\\n                int frequency = map.get(Character.getNumericValue(num.charAt(index))) - 1;\\n                map.put(Character.getNumericValue(num.charAt(index)), frequency);\\n            }\\n        }\\n//      If all the values are 0 , then only it is right otherwise , the frequency is either more or less than the\\n//        specified frequency, hence return false;\\n        for (int i = 0; i < num.length(); i++) {\\n            if(map.get(i) !=0){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084112,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        counter=Counter(num)\\n        for i in range(len(num)):\\n            if counter[f\\'{i}\\'] != int(num[i]):\\n                return False\\n        return True\\n```\\n\\n**Time - O(n)\\nSpace - O(n)**\\n\\n---\\n\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        counter=Counter(num)\\n        for i in range(len(num)):\\n            if counter[f\\'{i}\\'] != int(num[i]):\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3363169,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[]arr = new int[10];\\n\\n      for(int i=0;i<num.length();i++){\\n          arr[num.charAt(i)-\\'0\\']+=1;\\n      }\\n      //System.out.println(Arrays.toString(arr));\\n   \\n\\n      for(int i=0;i<num.length();i++){\\n          if(arr[i]!=num.charAt(i)-\\'0\\'){\\n              return false;\\n          }\\n      }\\n     return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[]arr = new int[10];\\n\\n      for(int i=0;i<num.length();i++){\\n          arr[num.charAt(i)-\\'0\\']+=1;\\n      }\\n      //System.out.println(Arrays.toString(arr));\\n   \\n\\n      for(int i=0;i<num.length();i++){\\n          if(arr[i]!=num.charAt(i)-\\'0\\'){\\n              return false;\\n          }\\n      }\\n     return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282316,
                "title": "java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n  public boolean digitCount(String num) {\\n    final char[] digit = num.toCharArray(); // convert string to char array\\n    final int n = digit.length; // length of char array\\n    int[] count = new int[10]; // count arr length 10 because constraint 1<=n<=10\\n    for (char c : digit) {\\n      count[c - \\'0\\']++; // count of digits \\n    }\\n    for (int i = 0; i < n; i++) {\\n      if (digit[i] - \\'0\\' != count[i]) { // check \\n        return false;\\n      }\\n    }\\n\\n    return true;\\n  }\\n}\\n\\n// DRY RUN TO CLEARLY UNDERSTAND THE WORKING OF CODE \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public boolean digitCount(String num) {\\n    final char[] digit = num.toCharArray(); // convert string to char array\\n    final int n = digit.length; // length of char array\\n    int[] count = new int[10]; // count arr length 10 because constraint 1<=n<=10\\n    for (char c : digit) {\\n      count[c - \\'0\\']++; // count of digits \\n    }\\n    for (int i = 0; i < n; i++) {\\n      if (digit[i] - \\'0\\' != count[i]) { // check \\n        return false;\\n      }\\n    }\\n\\n    return true;\\n  }\\n}\\n\\n// DRY RUN TO CLEARLY UNDERSTAND THE WORKING OF CODE \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2600012,
                "title": "java-hashmap-string-straightforward-solution",
                "content": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<num.length();i++){\\n            int n = Character.getNumericValue(num.charAt(i));\\n            map.put(n,map.getOrDefault(n,0)+1);\\n        }\\n        for(int i=0;i<num.length();i++){\\n            if(map.containsKey(i)){\\n                int nn = map.get(i);\\n                if(nn!=Character.getNumericValue(num.charAt(i)))\\n                    return false;\\n            }\\n            else{\\n                if(Character.getNumericValue(num.charAt(i))>0)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<num.length();i++){\\n            int n = Character.getNumericValue(num.charAt(i));\\n            map.put(n,map.getOrDefault(n,0)+1);\\n        }\\n        for(int i=0;i<num.length();i++){\\n            if(map.containsKey(i)){\\n                int nn = map.get(i);\\n                if(nn!=Character.getNumericValue(num.charAt(i)))\\n                    return false;\\n            }\\n            else{\\n                if(Character.getNumericValue(num.charAt(i))>0)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2115384,
                "title": "python-fast-solution-faster-than-93",
                "content": "![image](https://assets.leetcode.com/users/images/2cc0a03a-545f-4144-a1be-d86804fc0d45_1654452047.1386557.png)\\n\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        base = {}\\n        for i in range(len(num)):\\n            if base.get(num[i], None) is None:\\n                base[num[i]]=1\\n            else:\\n                base[num[i]]+=1\\n            if base.get(str(i), None) is None:\\n                base[str(i)]=0\\n                \\n        for i in range(len(num)):\\n            if str(base[str(i)])!=num[i]:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        base = {}\\n        for i in range(len(num)):\\n            if base.get(num[i], None) is None:\\n                base[num[i]]=1\\n            else:\\n                base[num[i]]+=1\\n            if base.get(str(i), None) is None:\\n                base[str(i)]=0\\n                \\n        for i in range(len(num)):\\n            if str(base[str(i)])!=num[i]:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084818,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        int n=num.length();\\n        map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            mp[num[i]-\\'0\\']++;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(mp[i]!=num[i]-\\'0\\'){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        int n=num.length();\\n        map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            mp[num[i]-\\'0\\']++;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(mp[i]!=num[i]-\\'0\\'){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084006,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        \\n        int[] result = new int[10];\\n        for(int i=0;i<num.length();i++)\\n        {\\n            result[num.charAt(i)-\\'0\\']++;\\n        }\\n      \\n       for(int i=0;i<num.length();i++)\\n       {\\n           if(num.charAt(i)-\\'0\\'!=result[i])\\n              return false;\\n       }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        \\n        int[] result = new int[10];\\n        for(int i=0;i<num.length();i++)\\n        {\\n            result[num.charAt(i)-\\'0\\']++;\\n        }\\n      \\n       for(int i=0;i<num.length();i++)\\n       {\\n           if(num.charAt(i)-\\'0\\'!=result[i])\\n              return false;\\n       }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083852,
                "title": "javascript-map",
                "content": "```js\\n/**\\n * @param {string} num\\n * @return {boolean}\\n */\\nvar digitCount = function(num) {\\n    const numLength = num.length;\\n    const numArray = num.split(\\'\\').map(Number);\\n    let result = \"\";\\n    \\n    const numFreq = numArray.reduce((acc,item)=>acc.set(item,acc.get(item) + 1 || 1),new Map())\\n    \\n    for(let i=0;i<numLength;i++){\\n        result+=numFreq.get(i) || \"0\";        \\n    }\\n    \\n    return result === num\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\n/**\\n * @param {string} num\\n * @return {boolean}\\n */\\nvar digitCount = function(num) {\\n    const numLength = num.length;\\n    const numArray = num.split(\\'\\').map(Number);\\n    let result = \"\";\\n    \\n    const numFreq = numArray.reduce((acc,item)=>acc.set(item,acc.get(item) + 1 || 1),new Map())\\n    \\n    for(let i=0;i<numLength;i++){\\n        result+=numFreq.get(i) || \"0\";        \\n    }\\n    \\n    return result === num\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3955024,
                "title": "java-100-beats-0-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        char temp[] = new char[11];\\n        int temp1 = 0 , temp2 = 0;\\n        for(int i=0; i<num.length(); i++){\\n            char ch = num.charAt(i); temp1 = ch-\\'0\\';\\n            temp[temp1]++;\\n        }\\n        for(int i=0; i<num.length(); i++){\\n            char ch = num.charAt(i); temp2 = ch-\\'0\\';\\n            if(temp[i]!=temp2) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        char temp[] = new char[11];\\n        int temp1 = 0 , temp2 = 0;\\n        for(int i=0; i<num.length(); i++){\\n            char ch = num.charAt(i); temp1 = ch-\\'0\\';\\n            temp[temp1]++;\\n        }\\n        for(int i=0; i<num.length(); i++){\\n            char ch = num.charAt(i); temp2 = ch-\\'0\\';\\n            if(temp[i]!=temp2) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437755,
                "title": "easy-java-beats-99",
                "content": "# Intuition\\nconsidering {1210}\\n\\n    HASHMAP :\\n\\n    {\\n        0:1\\n        1:2\\n        2:3\\n    }\\n\\n    index : 0 1 2 3\\n    number: 1 2 1 0\\n\\n    according to the question,\\n\\n    num[i] should be equal to frequency of index i\\n\\n    let x = num.charAt(i)\\n    convert character to integer using -\\n    int a = x - \\'0\\';\\n\\n    thus, if(a != frequency of a) i.e if(a != map.get(i)) return false;\\n\\n\\n    but to avoid null pointer exception, we must check if the hashmap contains all indices or not, if it doesnt, then num[i] must be 0 as in this case,\\n\\nindex 3 is not in hashmap {\\n        0:1\\n        1:2\\n        2:3\\n    }\\n\\nso , if it doesnot contain in hashmap (! map.containsKey(i))\\n\\nthen check if num[i] must be 0, else return false;,\\nif it is 0, then continue\\n\\n# Time Complexity - O(n)\\n# Space Complexity - O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n\\n        //creating an integer - integer hashmap\\n\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n\\n        for(int i = 0; i < num.length(); i++)\\n        {\\n            char x = num.charAt(i);\\n\\n            int a = x - \\'0\\'; // to create character to integer\\n\\n            if(map.containsKey(a))\\n                map.put(a,map.get(a)+1);\\n\\n            else\\n                map.put(a,1);\\n\\n        }\\n\\n        for(int i = 0; i<num.length(); i++)\\n        {\\n\\n            // to avoid nullPointerException\\n\\n            if(!map.containsKey(i))\\n            {\\n                if(num.charAt(i)!=\\'0\\') //it must be 0, else false\\n                    return false;\\n                else //if it is 0, then continue\\n                    continue;\\n            }\\n            char x = num.charAt(i); //let num[i] = x\\n            int a = x - \\'0\\'; //convert x to int\\n            if(a!=map.get(i)) //check if its equal to frequency\\n                return false;\\n\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n\\n        //creating an integer - integer hashmap\\n\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n\\n        for(int i = 0; i < num.length(); i++)\\n        {\\n            char x = num.charAt(i);\\n\\n            int a = x - \\'0\\'; // to create character to integer\\n\\n            if(map.containsKey(a))\\n                map.put(a,map.get(a)+1);\\n\\n            else\\n                map.put(a,1);\\n\\n        }\\n\\n        for(int i = 0; i<num.length(); i++)\\n        {\\n\\n            // to avoid nullPointerException\\n\\n            if(!map.containsKey(i))\\n            {\\n                if(num.charAt(i)!=\\'0\\') //it must be 0, else false\\n                    return false;\\n                else //if it is 0, then continue\\n                    continue;\\n            }\\n            char x = num.charAt(i); //let num[i] = x\\n            int a = x - \\'0\\'; //convert x to int\\n            if(a!=map.get(i)) //check if its equal to frequency\\n                return false;\\n\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359639,
                "title": "easy-beginner-friendly-solution-using-frequency-hashmap",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        dic=Counter(num)\\n        c=0\\n        for i in range(len(num)):\\n            if dic[str(i)]==int(num[i]):\\n                c+=1\\n                \\n        if c==len(num):\\n            return 1\\n        return 0\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        dic=Counter(num)\\n        c=0\\n        for i in range(len(num)):\\n            if dic[str(i)]==int(num[i]):\\n                c+=1\\n                \\n        if c==len(num):\\n            return 1\\n        return 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312486,
                "title": "c-solution-brute-force-hash-table",
                "content": "# Approach : Brute Force\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n    vector<int> v(10,0);\\n    for (int i = 0; i < num.size(); i++)\\n        v[num[i] - \\'0\\']++;\\n\\n    for (int i = 0; i < num.size(); i++)\\n        if (num[i] - \\'0\\' != v[i])\\n           return false;\\n\\n    return true;\\n\\n    }\\n};\\n```\\n# Approach : Hash Table\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n    unordered_map<int, int> m;\\n    for (auto e : num)\\n        m[e - \\'0\\']++;\\n\\n    for (int i = 0; i < num.size(); i++)\\n        if (m[i] != num[i] - \\'0\\')\\n            return false;\\n    return true;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n    vector<int> v(10,0);\\n    for (int i = 0; i < num.size(); i++)\\n        v[num[i] - \\'0\\']++;\\n\\n    for (int i = 0; i < num.size(); i++)\\n        if (num[i] - \\'0\\' != v[i])\\n           return false;\\n\\n    return true;\\n\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n    unordered_map<int, int> m;\\n    for (auto e : num)\\n        m[e - \\'0\\']++;\\n\\n    for (int i = 0; i < num.size(); i++)\\n        if (m[i] != num[i] - \\'0\\')\\n            return false;\\n    return true;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278845,
                "title": "c-easy-simple",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\no(k)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string nums) {\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums[i]-\\'0\\']++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mp[i]!=nums[i]-\\'0\\')\\n                return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string nums) {\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums[i]-\\'0\\']++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mp[i]!=nums[i]-\\'0\\')\\n                return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3237543,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string nums) {\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums[i]-\\'0\\']++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mp[i]!=nums[i]-\\'0\\')\\n                return 0;\\n        }\\n        return 1;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string nums) {\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums[i]-\\'0\\']++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mp[i]!=nums[i]-\\'0\\')\\n                return 0;\\n        }\\n        return 1;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852794,
                "title": "beats-99-easy-python-solution",
                "content": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        checked = set()\\n        i = 0\\n        while i < len(num):\\n            if num[i] not in checked:\\n                count = num.count(str(i))\\n                if int(num[i]) != count:\\n                    return False\\n                else:\\n                    checked.add(num[i])\\n                    i += 1\\n            else:\\n                i += 1\\n        \\n        return True\\n``",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        checked = set()\\n        i = 0\\n        while i < len(num):\\n            if num[i] not in checked:\\n                count = num.count(str(i))\\n                if int(num[i]) != count:\\n                    return False\\n                else:\\n                    checked.add(num[i])\\n                    i += 1\\n            else:\\n                i += 1\\n        \\n        return True\\n``",
                "codeTag": "Java"
            },
            {
                "id": 2561099,
                "title": "java-c-one-liner-100-00-0-ms-o-1",
                "content": "**UPVOTE PLEASE**\\n```\\ncpp:\\n\\n\\n    return unordered_set<string>{\"1210\", \"2020\" , \"21200\", \"3211000\", \"42101000\", \"521001000\", \"6210001000\"}.count(num);\\n\\t\\n\\tjava:\\n\\t\\n\\treturn new HashSet<String>(List.of(\"1210\", \"2020\" , \"21200\", \"3211000\", \"42101000\", \"521001000\", \"6210001000\")).contains(num); \\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\ncpp:\\n\\n\\n    return unordered_set<string>{\"1210\", \"2020\" , \"21200\", \"3211000\", \"42101000\", \"521001000\", \"6210001000\"}.count(num);\\n\\t\\n\\tjava:\\n\\t\\n\\treturn new HashSet<String>(List.of(\"1210\", \"2020\" , \"21200\", \"3211000\", \"42101000\", \"521001000\", \"6210001000\")).contains(num); \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2530024,
                "title": "here-is-my-solution",
                "content": "*****plz upvote if you find my solution helpful*****\\n```\\nclass Solution:\\n    def digitCount(self, n: str) -> bool:\\n        l=len(n)\\n        for i in range(l):\\n            if n.count(str(i))!=int(n[i]):\\n                \\n                return False\\n        return True\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, n: str) -> bool:\\n        l=len(n)\\n        for i in range(l):\\n            if n.count(str(i))!=int(n[i]):\\n                \\n                return False\\n        return True\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2210762,
                "title": "java-easy-to-understand-2-hashmaps",
                "content": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        // Create a map for given frequencies\\n        HashMap<Character, Integer> givenFreqMap = new HashMap<>();\\n        \\n        // Create a map to count frequencies manually\\n        HashMap<Character, Integer> countFreqMap = new HashMap<>();\\n        \\n        // Loop through num\\n        for(int i = 0; i < num.length(); i++){\\n            \\n            // We only want to put in map if value at index is not equals to 0\\n            // because 0 means it\\'s not in the string so we do not need that\\n            if(num.charAt(i) != \\'0\\'){\\n                // Add to givenFreqMap convert the index to char and it\\'s value from char to int\\n                givenFreqMap.put((char)(i+\\'0\\'), num.charAt(i) - \\'0\\');\\n            }\\n        }\\n        \\n        // Loop through num     \\n        for(char c : num.toCharArray()){\\n            \\n            // Add to countFreqMap and count thier frequencies\\n            countFreqMap.put(c, countFreqMap.getOrDefault(c, 0) + 1);\\n        }\\n                 \\n        // If the characters and its frequencies are same in both map then return true, else false\\n        return givenFreqMap.equals(countFreqMap);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        // Create a map for given frequencies\\n        HashMap<Character, Integer> givenFreqMap = new HashMap<>();\\n        \\n        // Create a map to count frequencies manually\\n        HashMap<Character, Integer> countFreqMap = new HashMap<>();\\n        \\n        // Loop through num\\n        for(int i = 0; i < num.length(); i++){\\n            \\n            // We only want to put in map if value at index is not equals to 0\\n            // because 0 means it\\'s not in the string so we do not need that\\n            if(num.charAt(i) != \\'0\\'){\\n                // Add to givenFreqMap convert the index to char and it\\'s value from char to int\\n                givenFreqMap.put((char)(i+\\'0\\'), num.charAt(i) - \\'0\\');\\n            }\\n        }\\n        \\n        // Loop through num     \\n        for(char c : num.toCharArray()){\\n            \\n            // Add to countFreqMap and count thier frequencies\\n            countFreqMap.put(c, countFreqMap.getOrDefault(c, 0) + 1);\\n        }\\n                 \\n        // If the characters and its frequencies are same in both map then return true, else false\\n        return givenFreqMap.equals(countFreqMap);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2194225,
                "title": "python-easy-2-liner-faster-than-93",
                "content": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:            \\n        for i in range(len(num)):\\n            if(num.count(str(i))!=int(num[i])): return False\\n        return True\\n```\\n***Pls upvote if you find it helpful***",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:            \\n        for i in range(len(num)):\\n            if(num.count(str(i))!=int(num[i])): return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2122515,
                "title": "easy-java-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public boolean digitCount(String num) \\n    {\\n        HashMap<Integer,Integer> hmap = new HashMap<>();\\n        for(char ch:num.toCharArray())\\n            hmap.put(Character.getNumericValue(ch),hmap.getOrDefault(Character.getNumericValue(ch),0)+1);\\n        \\n        for(int i=0;i<num.length();i++)\\n        {\\n            if(hmap.get(i)!=null && hmap.get(i)!=Character.getNumericValue(num.charAt(i)))\\n                return false;\\n            else if(hmap.get(i)==null && Character.getNumericValue(num.charAt(i))!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean digitCount(String num) \\n    {\\n        HashMap<Integer,Integer> hmap = new HashMap<>();\\n        for(char ch:num.toCharArray())\\n            hmap.put(Character.getNumericValue(ch),hmap.getOrDefault(Character.getNumericValue(ch),0)+1);\\n        \\n        for(int i=0;i<num.length();i++)\\n        {\\n            if(hmap.get(i)!=null && hmap.get(i)!=Character.getNumericValue(num.charAt(i)))\\n                return false;\\n            else if(hmap.get(i)==null && Character.getNumericValue(num.charAt(i))!=0)\\n                return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2087105,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn digit_count(num: String) -> bool {\\n        let mut counter = [0; 10];\\n        let num_it = num.bytes().map(|b| (b - b\\'0\\') as usize);\\n        num_it.clone().for_each(|idx| counter[idx] += 1);\\n        num_it.enumerate().all(|(i, idx)| counter[i] == idx)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn digit_count(num: String) -> bool {\\n        let mut counter = [0; 10];\\n        let num_it = num.bytes().map(|b| (b - b\\'0\\') as usize);\\n        num_it.clone().for_each(|idx| counter[idx] += 1);\\n        num_it.enumerate().all(|(i, idx)| counter[i] == idx)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2085306,
                "title": "very-easy-c-solution-using-1-for-loop",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        for(int i=0;i<num.length();i++){\\n\\t\\t\\t// int to char\\n            char ch =  i + \\'0\\';\\n\\t\\t\\t\\n\\t\\t\\t// count no. of occurance\\n            int req = count(num.begin(),num.end(),ch);\\n\\t\\t\\t\\n\\t\\t\\t// check the given condtion\\n            if(req!=(num[i]-\\'0\\'))     return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        for(int i=0;i<num.length();i++){\\n\\t\\t\\t// int to char\\n            char ch =  i + \\'0\\';\\n\\t\\t\\t\\n\\t\\t\\t// count no. of occurance\\n            int req = count(num.begin(),num.end(),ch);\\n\\t\\t\\t\\n\\t\\t\\t// check the given condtion\\n            if(req!=(num[i]-\\'0\\'))     return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084641,
                "title": "python-easy-understanding-solution",
                "content": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        n=len(num)\\n        \\n        for i in range(n):\\n            if(num.count(str(i))!=int(num[i])):\\n                return False\\n            \\n        return True",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        n=len(num)\\n        \\n        for i in range(n):\\n            if(num.count(str(i))!=int(num[i])):\\n                return False\\n            \\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 2084158,
                "title": "o-n-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        map<int,int> m;\\n        int n=num.size();\\n        for(int i=0;i<n;i++){\\n            m[num[i]-\\'0\\']++;\\n        }\\n        for(int i=0;i<n;i++ ){\\n            if(num[i]==\\'0\\'&&m.find(i)==m.end())continue;\\n            if(m.find(i)!=m.end()&&m[i]==(num[i]-\\'0\\'))continue;\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        map<int,int> m;\\n        int n=num.size();\\n        for(int i=0;i<n;i++){\\n            m[num[i]-\\'0\\']++;\\n        }\\n        for(int i=0;i<n;i++ ){\\n            if(num[i]==\\'0\\'&&m.find(i)==m.end())continue;\\n            if(m.find(i)!=m.end()&&m[i]==(num[i]-\\'0\\'))continue;\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084130,
                "title": "javascript-counter-105ms",
                "content": "```\\nconst counter = (a_or_s) => { let m = new Map(); for (const x of a_or_s) m.set(x, m.get(x) + 1 || 1); return m; };\\n\\nconst digitCount = (a) => {\\n    let m = counter(a), n = a.length;\\n    for (let i = 0; i < n; i++) {\\n        let cnt = m.get(i + \\'\\') || 0\\n        if (a[i] != cnt) return false;\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst counter = (a_or_s) => { let m = new Map(); for (const x of a_or_s) m.set(x, m.get(x) + 1 || 1); return m; };\\n\\nconst digitCount = (a) => {\\n    let m = counter(a), n = a.length;\\n    for (let i = 0; i < n; i++) {\\n        let cnt = m.get(i + \\'\\') || 0\\n        if (a[i] != cnt) return false;\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2084121,
                "title": "python3-very-elegant-and-straightforward",
                "content": "\\n```\\n        c = Counter(num)\\n        for idx, x in enumerate(num):\\n            if c[str(idx)] != int(x):\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n        c = Counter(num)\\n        for idx, x in enumerate(num):\\n            if c[str(idx)] != int(x):\\n                return False\\n        return True\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2084061,
                "title": "brute-force-c-100",
                "content": "class Solution {\\npublic:\\n    bool digitCount(string num) {\\n        int count=0;\\n        bool ans=true;\\n        for(int i=0;i<num.size();i++){\\n            for(int j=0;j<num.size();j++){\\n                if((num[j]-\\'0\\')==i){\\n                    count=count+1;\\n                }\\n            }\\n            if((num[i]-\\'0\\')!=count){\\n                ans=false; \\n            }\\n            count=0;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    bool digitCount(string num) {\\n        int count=0;\\n        bool ans=true;\\n        for(int i=0;i<num.size();i++){\\n            for(int j=0;j<num.size();j++){\\n                if((num[j]-\\'0\\')==i){\\n                    count=count+1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2083804,
                "title": "2-liner-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        for(int i=0;i<num.size();i++) if(count(num.begin(),num.end(),(i+\\'0\\')) != num[i]-\\'0\\') return false;\\n        return true;\\n    }\\n};\\n```\\n\\n\\n\\n**With Using Extra space :** \\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        unordered_map<char,int> mpp;\\n        for(auto c : num) mpp[c]++;\\n        for(int i=0;i<num.size();i++){\\n            char c = (char)i+\\'0\\';\\n            if(num[i]-\\'0\\' != mpp[c]) return false;\\n        }\\n         return true;\\n     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        for(int i=0;i<num.size();i++) if(count(num.begin(),num.end(),(i+\\'0\\')) != num[i]-\\'0\\') return false;\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        unordered_map<char,int> mpp;\\n        for(auto c : num) mpp[c]++;\\n        for(int i=0;i<num.size();i++){\\n            char c = (char)i+\\'0\\';\\n            if(num[i]-\\'0\\' != mpp[c]) return false;\\n        }\\n         return true;\\n     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3936222,
                "title": "python-beginner-friendly-explanation-beats-91",
                "content": "# Approach\\nSimple Compare the count of current index with value at corrent index\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        for i in range(len(num)):\\n            if num.count(str(i)) != int(num[i]):\\n                return False\\n        return True        \\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        for i in range(len(num)):\\n            if num.count(str(i)) != int(num[i]):\\n                return False\\n        return True        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904905,
                "title": "easy-approach-for-beginners-time-complexity-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        for i in range(len(num)):\\n            if num.count(str(i))!=int(num[i]):\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        for i in range(len(num)):\\n            if num.count(str(i))!=int(num[i]):\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3577641,
                "title": "java-simple-solution-hashmap-counting-100-faster",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public boolean digitCount(String num) {\\n        Map<Integer, Integer> occurrence = new HashMap<>(num.length());\\n        for (int i = 0; i < num.length(); i++) {\\n            int currentDigit = num.charAt(i) - \\'0\\';\\n            occurrence.put(currentDigit, occurrence.getOrDefault(currentDigit, 0) + 1);\\n        }\\n\\n        for (int i = 0; i < num.length(); i++) {\\n            int currentDigit = num.charAt(i) - \\'0\\';\\n            int count = 0;\\n            if (occurrence.containsKey(i)) {\\n                count = occurrence.get(i);\\n            }\\n            if (count != currentDigit) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n\\n    public boolean digitCount(String num) {\\n        Map<Integer, Integer> occurrence = new HashMap<>(num.length());\\n        for (int i = 0; i < num.length(); i++) {\\n            int currentDigit = num.charAt(i) - \\'0\\';\\n            occurrence.put(currentDigit, occurrence.getOrDefault(currentDigit, 0) + 1);\\n        }\\n\\n        for (int i = 0; i < num.length(); i++) {\\n            int currentDigit = num.charAt(i) - \\'0\\';\\n            int count = 0;\\n            if (occurrence.containsKey(i)) {\\n                count = occurrence.get(i);\\n            }\\n            if (count != currentDigit) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573736,
                "title": "check-if-number-has-equal-digit-count-and-digit-value-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        int i, j, count=0;\\n        for(i=0 ; i<num.length() ; i++)\\n        {\\n            count=0;\\n            for(j=0 ; j<num.length() ; j++)\\n            {\\n                if(i==(int)num[j]-48)\\n                {\\n                    count++;\\n                }\\n            }\\n            if((int)num[i]-48!=count)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/98f8d2dd-d2eb-4f98-991a-e52107e37b08_1685332542.106816.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        int i, j, count=0;\\n        for(i=0 ; i<num.length() ; i++)\\n        {\\n            count=0;\\n            for(j=0 ; j<num.length() ; j++)\\n            {\\n                if(i==(int)num[j]-48)\\n                {\\n                    count++;\\n                }\\n            }\\n            if((int)num[i]-48!=count)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548379,
                "title": "simplest-efficient-c-code-time-o-n-2-space-o-1",
                "content": "# Intuition\\nThe code aims to compare the count of each digit in the string with the actual digit itself.\\n\\n# Approach\\nThe code iterates through each digit in the given string and compares its count with the actual digit itself. If any count doesn\\'t match, it returns false; otherwise, it returns true. \\n\\n# Complexity\\n- Time complexity: Let\\'s consider the length of the string num as n. The code uses two nested loops, with each loop iterating over the entire string. Therefore, the time complexity of the code is $O(n^2)$.\\n\\n- Space complexity: The code uses a constant amount of additional space to store variables l, i, j, and count. Hence, the space complexity is $O(1)$.\\n\\n# Code\\n```\\nbool digitCount(char * num)\\n{\\n    int l = strlen(num);\\n    for(int i=0;i<l;i++)\\n    {\\n        int count = 0;\\n        for(int j = 0;j<l;j++)\\n        {\\n            if(i==num[j]-\\'0\\')\\n            count++;\\n        }\\n        if(count != num[i]-\\'0\\')\\n        return false;\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool digitCount(char * num)\\n{\\n    int l = strlen(num);\\n    for(int i=0;i<l;i++)\\n    {\\n        int count = 0;\\n        for(int j = 0;j<l;j++)\\n        {\\n            if(i==num[j]-\\'0\\')\\n            count++;\\n        }\\n        if(count != num[i]-\\'0\\')\\n        return false;\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3464006,
                "title": "easy-understanding-hash-java-99-85-beats-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n\\n        for(int i=0;i<num.length();i++){\\n            int ch=num.charAt(i)-\\'0\\';\\n            map.put(ch,map.getOrDefault(ch,0)+1);\\n        }\\n        // StringBuilder sb=new StringBuilder();\\n        int count=0;\\n        for(int i=0;i<num.length();i++){\\n\\n            if(map.containsKey(i)){\\n                count=map.get(i);\\n            }\\n            else{\\n                count=0;\\n            }\\n          int x=num.charAt(i)-\\'0\\';\\n            if(x!=count){\\n                return false;\\n            }\\n        }\\n      return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n\\n        for(int i=0;i<num.length();i++){\\n            int ch=num.charAt(i)-\\'0\\';\\n            map.put(ch,map.getOrDefault(ch,0)+1);\\n        }\\n        // StringBuilder sb=new StringBuilder();\\n        int count=0;\\n        for(int i=0;i<num.length();i++){\\n\\n            if(map.containsKey(i)){\\n                count=map.get(i);\\n            }\\n            else{\\n                count=0;\\n            }\\n          int x=num.charAt(i)-\\'0\\';\\n            if(x!=count){\\n                return false;\\n            }\\n        }\\n      return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404476,
                "title": "easy-python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        for i in range(len(num)):\\n            if num.count(str(i)) != int(num[i]):\\n                return False\\n        return True \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        for i in range(len(num)):\\n            if num.count(str(i)) != int(num[i]):\\n                return False\\n        return True \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395513,
                "title": "easy-go-solution",
                "content": "```\\nfunc digitCount(num string) bool {\\n        var counters [10]int\\n\\n        for i := 0; i < len(num); i++ {\\n                val := num[i]\\n                counters[int(val-\\'0\\')]++\\n        }\\n\\n        isMatch := true\\n        for i := 0; i < len(num); i++ {\\n                val := num[i]\\n                if counters[i] != int(val-\\'0\\') {\\n                        isMatch = false\\n                        break\\n                }\\n        }\\n\\n        return isMatch\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc digitCount(num string) bool {\\n        var counters [10]int\\n\\n        for i := 0; i < len(num); i++ {\\n                val := num[i]\\n                counters[int(val-\\'0\\')]++\\n        }\\n\\n        isMatch := true\\n        for i := 0; i < len(num); i++ {\\n                val := num[i]\\n                if counters[i] != int(val-\\'0\\') {\\n                        isMatch = false\\n                        break\\n                }\\n        }\\n\\n        return isMatch\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3309058,
                "title": "java-hashmap-frequency-array-easy",
                "content": "## Solution 1: Using HashMap:\\n``` \\nclass Solution {\\n    public boolean digitCount(String num) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (char c : num.toCharArray()) {\\n            int n = c - \\'0\\';\\n            map.put(n, 1 + map.getOrDefault(n, 0));\\n        }\\n\\n        for (int i = 0; i < num.length(); i++) {\\n            int n = num.charAt(i) - \\'0\\';\\n            if (n != map.getOrDefault(i, 0)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\nSize will be at max $$10$$ so its very small.\\n\\n**Time complexity:** $$O(1)$$\\n**Space complexity:** $$O(1)$$\\n\\n---\\n## Solution 2: Using Frequency array:\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] freq = new int[10];\\n        for (char c : num.toCharArray()) {\\n            freq[c - \\'0\\']++;\\n        }\\n\\n        for (int i = 0; i < num.length(); i++) {\\n            int n = num.charAt(i) - \\'0\\';\\n            if (n != freq[i]) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\n\\nSize will be at max $$10$$ so its very small.\\n\\n**Time complexity:** $$O(1)$$\\n**Space complexity:** $$O(1)$$\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "``` \\nclass Solution {\\n    public boolean digitCount(String num) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (char c : num.toCharArray()) {\\n            int n = c - \\'0\\';\\n            map.put(n, 1 + map.getOrDefault(n, 0));\\n        }\\n\\n        for (int i = 0; i < num.length(); i++) {\\n            int n = num.charAt(i) - \\'0\\';\\n            if (n != map.getOrDefault(i, 0)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] freq = new int[10];\\n        for (char c : num.toCharArray()) {\\n            freq[c - \\'0\\']++;\\n        }\\n\\n        for (int i = 0; i < num.length(); i++) {\\n            int n = num.charAt(i) - \\'0\\';\\n            if (n != freq[i]) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096491,
                "title": "python-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->First we have allocated a an empty string for storing the value. Now a loop upto length of the given string is generated and stored the value of that place (count of that place in num string) if the new formed string is equal to the given sting nums, return True else False.\\n# Code\\n```\\nclass Solution(object):\\n    def digitCount(self, num):\\n        \"\"\"\\n        :type num: str\\n        :rtype: bool\\n        \"\"\"\\n        s=\\'\\'\\n        for i in range(len(num)):\\n            s+=str(num.count(str(i)))\\n        if num==s:\\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def digitCount(self, num):\\n        \"\"\"\\n        :type num: str\\n        :rtype: bool\\n        \"\"\"\\n        s=\\'\\'\\n        for i in range(len(num)):\\n            s+=str(num.count(str(i)))\\n        if num==s:\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2918316,
                "title": "c-hashing",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        vector<int>v(10,0);   //to keep track of frequency of each digit\\n        int n=num.size();\\n\\n        for(int i=0;i<n;i++){\\n            int k=num[i]-\\'0\\';  //convert char to int\\n            v[k]++;   //hashing\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            int k=num[i]-\\'0\\';\\n            if(v[i]!=k)return false;  //check if frequency of digit is equal to integer at that index\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        vector<int>v(10,0);   //to keep track of frequency of each digit\\n        int n=num.size();\\n\\n        for(int i=0;i<n;i++){\\n            int k=num[i]-\\'0\\';  //convert char to int\\n            v[k]++;   //hashing\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            int k=num[i]-\\'0\\';\\n            if(v[i]!=k)return false;  //check if frequency of digit is equal to integer at that index\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833980,
                "title": "easy-js-solution-o-n",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nlet digitCount = function(num) {\\n    let map = new Map();\\n\\n    // Set Key:Value To Map\\n    for(let val of num) {\\n        // Covert string to number\\n        let n = Number(val)\\n        map.set(n, map.get(n) + 1 || 1);\\n    }\\n\\n    // Compare\\n    for(let i = 0; i < num.length; i++) {\\n        if(map.get(i) === Number(num[i])) {\\n            continue;\\n        } else if(!map.get(i) && Number(num[i]) === 0) {\\n            continue;\\n        }\\n        return false;\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nlet digitCount = function(num) {\\n    let map = new Map();\\n\\n    // Set Key:Value To Map\\n    for(let val of num) {\\n        // Covert string to number\\n        let n = Number(val)\\n        map.set(n, map.get(n) + 1 || 1);\\n    }\\n\\n    // Compare\\n    for(let i = 0; i < num.length; i++) {\\n        if(map.get(i) === Number(num[i])) {\\n            continue;\\n        } else if(!map.get(i) && Number(num[i]) === 0) {\\n            continue;\\n        }\\n        return false;\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2778905,
                "title": "simple-solution",
                "content": "simple solution in java using hash table\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] freq=new int[10];\\n        for(int i=0;i<num.length();i++)\\n        {\\n            int c=num.charAt(i)-\\'0\\';\\n            freq[c]++;\\n        }\\n        for(int i=0;i<num.length();i++){\\n            int a=num.charAt(i)-\\'0\\';\\n            if(a!=freq[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] freq=new int[10];\\n        for(int i=0;i<num.length();i++)\\n        {\\n            int c=num.charAt(i)-\\'0\\';\\n            freq[c]++;\\n        }\\n        for(int i=0;i<num.length();i++){\\n            int a=num.charAt(i)-\\'0\\';\\n            if(a!=freq[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2778836,
                "title": "java-using-hash-maps",
                "content": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n         Map<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<num.length();i++){\\n            char a=num.charAt(i);\\n            if(map.containsKey(Integer.parseInt(String.valueOf(a))))\\n            {\\n                map.put(Integer.parseInt(String.valueOf(a)),map.get(Integer.parseInt(String.valueOf(a)))+1);\\n            }\\n            else{\\n                map.put(Integer.parseInt(String.valueOf(a)),1);\\n            }\\n        }\\n        \\n        for(int i=0;i<num.length();i++){\\n            if(map.containsKey(i)) {\\n                if (Integer.parseInt(String.valueOf(num.charAt(i))) != map.get(i)) {\\n                    return false;\\n                }\\n            }\\n            else{\\n                if(Integer.parseInt(String.valueOf(num.charAt(i)))!=0)\\n                    return false;\\n            }\\n        }\\n        return true; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n         Map<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<num.length();i++){\\n            char a=num.charAt(i);\\n            if(map.containsKey(Integer.parseInt(String.valueOf(a))))\\n            {\\n                map.put(Integer.parseInt(String.valueOf(a)),map.get(Integer.parseInt(String.valueOf(a)))+1);\\n            }\\n            else{\\n                map.put(Integer.parseInt(String.valueOf(a)),1);\\n            }\\n        }\\n        \\n        for(int i=0;i<num.length();i++){\\n            if(map.containsKey(i)) {\\n                if (Integer.parseInt(String.valueOf(num.charAt(i))) != map.get(i)) {\\n                    return false;\\n                }\\n            }\\n            else{\\n                if(Integer.parseInt(String.valueOf(num.charAt(i)))!=0)\\n                    return false;\\n            }\\n        }\\n        return true; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760627,
                "title": "beats-98-60-in-time",
                "content": "#### Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- convert to char array using `toCharArray()`;\\n- to convert char to int -> `num[i]-\\'0\\'`\\n- can use the opp. approach,  *i.e* int to char -> `num[i]+\\'0\\'`\\n#### Approach\\n<!-- Describe your approach to solving the problem. -->\\nloop through the char array\\nanother loop to count the frequency of each char `num[j] == i`\\nif `num[i] == freq` return true\\nreturn false when loop finishes.\\n##### Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        char[] numx = num.toCharArray();\\n        int freq = 0;\\n        for(int i=0; i<numx.length; i++){\\n            freq = 0;\\n            for(int j=0; j<numx.length; j++){\\n                if(i == (numx[j]-\\'0\\')){\\n                    freq++;\\n                }\\n            }\\n            if((numx[i]-\\'0\\') != freq) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        char[] numx = num.toCharArray();\\n        int freq = 0;\\n        for(int i=0; i<numx.length; i++){\\n            freq = 0;\\n            for(int j=0; j<numx.length; j++){\\n                if(i == (numx[j]-\\'0\\')){\\n                    freq++;\\n                }\\n            }\\n            if((numx[i]-\\'0\\') != freq) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2710543,
                "title": "easty-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- wrost O(N^2)\\n- best O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def digitCount(self, s: str) -> bool:\\n        for i in range(len(s)):\\n            c=s.count(str(i))\\n            if c==int(s[i]):\\n                continue\\n            else:\\n                return False\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, s: str) -> bool:\\n        for i in range(len(s)):\\n            c=s.count(str(i))\\n            if c==int(s[i]):\\n                continue\\n            else:\\n                return False\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2619170,
                "title": "super-easy-c-soln-hash-table",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        vector<int> v(10,0);\\n        for(auto it: num){\\n          v[it-\\'0\\']++;\\n        }\\n        for(int i=0;i<num.length();i++){\\n            if(v[i] != num[i]-\\'0\\') return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        vector<int> v(10,0);\\n        for(auto it: num){\\n          v[it-\\'0\\']++;\\n        }\\n        for(int i=0;i<num.length();i++){\\n            if(v[i] != num[i]-\\'0\\') return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2571171,
                "title": "java-solution-for-beginners-without-hashmap",
                "content": "class Solution {\\n    public boolean digitCount(String num) {\\n        int[] count = new int[num.length()];\\n        for(int i = 0;i<num.length();i++){\\n            for(int j = 0;j<num.length();j++){\\n                if(i == num.charAt(j)-\\'0\\'){\\n                    count[i]++;\\n                }\\n            }\\n        }\\n        boolean bo = true;\\n        for(int i = 0;i<num.length();i++){\\n            if(count[i] == num.charAt(i)-\\'0\\'){\\n                bo = true;\\n            }\\n            else{\\n                bo = false;\\n                break;\\n            }\\n        }\\n        \\n        return bo;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean digitCount(String num) {\\n        int[] count = new int[num.length()];\\n        for(int i = 0;i<num.length();i++){\\n            for(int j = 0;j<num.length();j++){\\n                if(i == num.charAt(j)-\\'0\\'){\\n                    count[i]++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2501744,
                "title": "62-ms-faster-than-99-15-easy-intuitive-js-solution",
                "content": "```\\nvar digitCount = function(num) {\\n    let map = new Map();\\n        \\n    for(let i = 0; i < num.length; i++) {\\n        map.has(num.charAt(i)) ? map.set(num.charAt(i), map.get(num.charAt(i))+1) : map.set(num.charAt(i), 1)\\n    }\\n\\n    let value;\\n    for(let i = 0; i < num.length; i++) {\\n        value = map.has(i.toString()) ? map.get(i.toString()) : 0;\\n        if(value != num.charAt(i)){\\n            return false\\n        }\\n    }\\n    \\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar digitCount = function(num) {\\n    let map = new Map();\\n        \\n    for(let i = 0; i < num.length; i++) {\\n        map.has(num.charAt(i)) ? map.set(num.charAt(i), map.get(num.charAt(i))+1) : map.set(num.charAt(i), 1)\\n    }\\n\\n    let value;\\n    for(let i = 0; i < num.length; i++) {\\n        value = map.has(i.toString()) ? map.get(i.toString()) : 0;\\n        if(value != num.charAt(i)){\\n            return false\\n        }\\n    }\\n    \\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2484276,
                "title": "c-0ms-unordered-map-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) \\n    {\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<num.length();i++)\\n        {\\n            mp[num[i]]++;\\t\\n        }        \\n        for(int i=0;i<num.length();i++)\\n        {\\n            char currnum=i+\\'0\\';\\n            int freq=num[i]-\\'0\\';\\n\\n            if(mp[currnum]!=freq)\\n            {\\n               return false;    \\n            }\\n            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) \\n    {\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<num.length();i++)\\n        {\\n            mp[num[i]]++;\\t\\n        }        \\n        for(int i=0;i<num.length();i++)\\n        {\\n            char currnum=i+\\'0\\';\\n            int freq=num[i]-\\'0\\';\\n\\n            if(mp[currnum]!=freq)\\n            {\\n               return false;    \\n            }\\n            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2332877,
                "title": "python3-o-n-o-n-runtime-47ms-62-83-memory-13-8mb-56-99",
                "content": "```\\nfrom collections import Counter as c\\nclass Solution:\\n#     O(n) || O(n)\\n# Runtime: 47ms 62.83% || Memory: 13.8mb 56.99%\\n    def digitCount(self, num: str) -> bool:\\n        if not num:\\n            return num\\n\\n        numFreq = c(num)\\n\\n        for idx, val in enumerate(num):\\n            if numFreq[f\\'{idx}\\'] != int(val):\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter as c\\nclass Solution:\\n#     O(n) || O(n)\\n# Runtime: 47ms 62.83% || Memory: 13.8mb 56.99%\\n    def digitCount(self, num: str) -> bool:\\n        if not num:\\n            return num\\n\\n        numFreq = c(num)\\n\\n        for idx, val in enumerate(num):\\n            if numFreq[f\\'{idx}\\'] != int(val):\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2320976,
                "title": "java-runtime-1ms-time-o-n-space-n",
                "content": "```\\n/*\\nTo understand the code properly, dry run the code\\nin your notebook for the input:\\nnum = \"1210\"\\n*/\\n\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        HashMap<Character, Integer> map = new HashMap<>() ;\\n        \\n        for (int i = 0; i < num.length(); i++) {\\n            map.put(num.charAt(i), map.getOrDefault(num.charAt(i), 0)+1) ;\\n        }\\n        \\n        for (int i = 0; i < num.length(); i++) {\\n            char ch = (char)(48+i) ;\\n            \\n            if (map.containsKey(ch)) {\\n                if ((int)(num.charAt(i))-48 != map.get(ch)) {\\n                    return false ;\\n                }\\n            }\\n            else if (num.charAt(i) != \\'0\\'){\\n                return false ;\\n            }\\n        }\\n        \\n        return true ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\n/*\\nTo understand the code properly, dry run the code\\nin your notebook for the input:\\nnum = \"1210\"\\n*/\\n\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        HashMap<Character, Integer> map = new HashMap<>() ;\\n        \\n        for (int i = 0; i < num.length(); i++) {\\n            map.put(num.charAt(i), map.getOrDefault(num.charAt(i), 0)+1) ;\\n        }\\n        \\n        for (int i = 0; i < num.length(); i++) {\\n            char ch = (char)(48+i) ;\\n            \\n            if (map.containsKey(ch)) {\\n                if ((int)(num.charAt(i))-48 != map.get(ch)) {\\n                    return false ;\\n                }\\n            }\\n            else if (num.charAt(i) != \\'0\\'){\\n                return false ;\\n            }\\n        }\\n        \\n        return true ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2269284,
                "title": "simple-c-solution",
                "content": "```\\n        int n = num.length();\\n        vector<int> v(10,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            v[num[i]-\\'0\\']++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if((num[i]-\\'0\\') != v[i])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n        int n = num.length();\\n        vector<int> v(10,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            v[num[i]-\\'0\\']++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if((num[i]-\\'0\\') != v[i])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2246289,
                "title": "python-simple-solution-easy-2-liner-faster-than-93-easy-to-understand",
                "content": "```\\nst = \\'\\'\\nfor i in range(len(num)):\\n\\tst = st+str(num.count(str(i)))\\nreturn(st == num)\\n```\\n***Please Do Upvote, if you found my code helpful***",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nst = \\'\\'\\nfor i in range(len(num)):\\n\\tst = st+str(num.count(str(i)))\\nreturn(st == num)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2243800,
                "title": "java",
                "content": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        Hashtable<Integer, Integer> ht = new Hashtable<Integer, Integer>();\\n        for(int i = 0; i<num.length(); i++){\\n            ht.put(i, num.charAt(i)-\\'0\\'); \\n        }\\n        \\n        for(int i = 0; i<num.length(); i++){\\n            if(ht.get(num.charAt(i)-\\'0\\')== null){\\n                return false;\\n            }\\n            ht.replace(num.charAt(i)-\\'0\\', ht.get(num.charAt(i)-\\'0\\')-1);\\n        }\\n        for(int i = 0; i<num.length(); i++){\\n            if(ht.get(i)!=0){\\n                return false;\\n            }\\t\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        Hashtable<Integer, Integer> ht = new Hashtable<Integer, Integer>();\\n        for(int i = 0; i<num.length(); i++){\\n            ht.put(i, num.charAt(i)-\\'0\\'); \\n        }\\n        \\n        for(int i = 0; i<num.length(); i++){\\n            if(ht.get(num.charAt(i)-\\'0\\')== null){\\n                return false;\\n            }\\n            ht.replace(num.charAt(i)-\\'0\\', ht.get(num.charAt(i)-\\'0\\')-1);\\n        }\\n        for(int i = 0; i<num.length(); i++){\\n            if(ht.get(i)!=0){\\n                return false;\\n            }\\t\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2218421,
                "title": "kotlin-1-line",
                "content": "```\\nfun digitCount(s: String) = s.withIndex().all { it.value - \\'0\\' == s.count { c -> c == \\'0\\' + it.index } }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun digitCount(s: String) = s.withIndex().all { it.value - \\'0\\' == s.count { c -> c == \\'0\\' + it.index } }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2195712,
                "title": "java-easiest-solution-with-steps-explained",
                "content": "**STEPS**\\n\\n**Here we are using Frequency Array**\\n\\n**Step 1:** Initialising the Frequency Array with size 10 (**because 1 <= n <= 10 was given in the constraints**)\\n**Step 2:** Take each characters from the string and make it into character array\\n**Step 3:**  Store the frequency of characters in frequency Array.\\n**Step 4:** Now find frequency of each index value and update the frequency array.\\n**Step 5:** Now within a loop check upto constraint value check if frequency is zero or not .If zero then return false otherwise the function will return true.\\n\\n**Code**\\n\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] freqArray = new int[10];\\n        \\n        \\n        for(char ch : num.toCharArray()){\\n            freqArray[ch-\\'0\\']++;\\n        }\\n        \\n        for(int i=0;i<num.length();i++){\\n            int freq = num.charAt(i)-\\'0\\';\\n            freqArray[i] = freqArray[i] - freq; \\n        }\\n        for(int i=0;i<10;i++){\\n            if(freqArray[i]!=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] freqArray = new int[10];\\n        \\n        \\n        for(char ch : num.toCharArray()){\\n            freqArray[ch-\\'0\\']++;\\n        }\\n        \\n        for(int i=0;i<num.length();i++){\\n            int freq = num.charAt(i)-\\'0\\';\\n            freqArray[i] = freqArray[i] - freq; \\n        }\\n        for(int i=0;i<10;i++){\\n            if(freqArray[i]!=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2189195,
                "title": "javascript-using-regex",
                "content": "```\\nvar digitCount = function(num) {    \\n    const res = [...num].filter((element, index) => {\\n        const reg = new RegExp(index, \"g\");\\n        const count = (num.match(reg) || []).length;\\n        \\n        return Number(element) === count\\n    })\\n    \\n    return res.length === num.length    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar digitCount = function(num) {    \\n    const res = [...num].filter((element, index) => {\\n        const reg = new RegExp(index, \"g\");\\n        const count = (num.match(reg) || []).length;\\n        \\n        return Number(element) === count\\n    })\\n    \\n    return res.length === num.length    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2178551,
                "title": "easy-javascript-solution",
                "content": "```\\nvar digitCount = function(num) {\\n    let arr= Array(num.length).fill(0);\\n    for(const char of num){\\n        arr[Number(char)]++;\\n    }\\n    return arr.join(\\'\\') === num;\\n};\\n```\\n\\nRuntime: 113 ms, faster than 31.20% of JavaScript online submissions for Check if Number Has Equal Digit Count and Digit Value.\\nMemory Usage: 43.8 MB, less than 16.45% of JavaScript online submissions for Check if Number Has Equal Digit Count and Digit Value.",
                "solutionTags": [],
                "code": "```\\nvar digitCount = function(num) {\\n    let arr= Array(num.length).fill(0);\\n    for(const char of num){\\n        arr[Number(char)]++;\\n    }\\n    return arr.join(\\'\\') === num;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2171618,
                "title": "easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        map<char,int>mp;\\n        for(int i=0;i<num.size();i++)\\n            mp[num[i]]++;\\n        int n=num.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int temp=num[i]-\\'0\\';\\n           /// cout<<mp[(i+\\'0\\')]<<\" \"<<temp<<endl;\\n            if(mp[(i+\\'0\\')]!=temp)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        map<char,int>mp;\\n        for(int i=0;i<num.size();i++)\\n            mp[num[i]]++;\\n        int n=num.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int temp=num[i]-\\'0\\';\\n           /// cout<<mp[(i+\\'0\\')]<<\" \"<<temp<<endl;\\n            if(mp[(i+\\'0\\')]!=temp)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2124375,
                "title": "java-sol-using-counter-array",
                "content": "Java solution to use counter array because we will only have 10 digits\\n\\n```\\npublic boolean digitCount(String num) {\\n        int[] digit_counter = new int[10];\\n        \\n        for (int i = 0; i < num.length(); i++) {\\n            digit_counter[Character.getNumericValue(num.charAt(i))]++;\\n        }\\n        \\n        for (int i = 0; i < num.length(); i++) {\\n            if (digit_counter[i] != Character.getNumericValue(num.charAt(i)))\\n                return false;\\n        }\\n        \\n        return true;\\n        \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Java solution to use counter array because we will only have 10 digits\\n\\n```\\npublic boolean digitCount(String num) {\\n        int[] digit_counter = new int[10];\\n        \\n        for (int i = 0; i < num.length(); i++) {\\n            digit_counter[Character.getNumericValue(num.charAt(i))]++;\\n        }\\n        \\n        for (int i = 0; i < num.length(); i++) {\\n            if (digit_counter[i] != Character.getNumericValue(num.charAt(i)))\\n                return false;\\n        }\\n        \\n        return true;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2112937,
                "title": "c-solution-without-using-vector-array-map-for-beginners",
                "content": "class Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n        int count=0;\\n        int i=0;\\n        int a=0;\\n        for(int c=0;c<num.size();c++)\\n        {\\n            count=0;\\n            for(i=0;i<num.size();i++)\\n            {\\n                if(num[i]==char(c+48))\\n                {\\n                    count++;\\n                }\\n            }\\n            // cout<<count<<endl;\\n            if(count!=(int)num[a]-48)\\n            {\\n                return false;\\n            }\\n            a++;\\n        }\\n       \\n        \\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n        int count=0;\\n        int i=0;\\n        int a=0;\\n        for(int c=0;c<num.size();c++)\\n        {\\n            count=0;\\n            for(i=0;i<num.size();i++)\\n            {\\n                if(num[i]==char(c+48))\\n                {\\n                    count++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2100275,
                "title": "kotlin-short-easy-solution-264ms-faster-than-50-00",
                "content": "just do what the problem says, along with 1 edge case\\n```\\nclass Solution {\\n    fun digitCount(num: String): Boolean {\\n        val map = num.groupingBy { it }.eachCount()\\n        return num.indices.all {\\n            val count = map[(\\'0\\'..\\'9\\').toList()[it]] ?: 0\\n            count == num[it].toString().toInt()\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun digitCount(num: String): Boolean {\\n        val map = num.groupingBy { it }.eachCount()\\n        return num.indices.all {\\n            val count = map[(\\'0\\'..\\'9\\').toList()[it]] ?: 0\\n            count == num[it].toString().toInt()\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2093748,
                "title": "python-count-and-check-with-explanation-45ms",
                "content": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        \\n        #Find the length\\n        LENGTH = len( num )\\n            \\n        #Count the occurences\\n        counter = Counter( num )\\n\\n        #Go through each number index\\n        for i in range( LENGTH ):\\n            #The index is the current digit\\n            current_digit = i\\n            \\n            #Cast it as a string for comparison\\n            str_current = str( i ) \\n            \\n            #Use the index to find the expected number in num\\n            expected_number = int ( num[ i ] )\\n            \\n            #Use the stringified number to find its occurences in counter\\n            if str_current in counter:\\n                digit_count = int( counter[ str_current ] )\\n                \\n            #If it is not found, the count is zero\\n            else:\\n                digit_count = 0\\n            \\n            #If we don\\'t find the expected number as the count, we return False\\n            if expected_number != digit_count:\\n                return False\\n            \\n        #Otherwise, all that are checked are valid\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        \\n        #Find the length\\n        LENGTH = len( num )\\n            \\n        #Count the occurences\\n        counter = Counter( num )\\n\\n        #Go through each number index\\n        for i in range( LENGTH ):\\n            #The index is the current digit\\n            current_digit = i\\n            \\n            #Cast it as a string for comparison\\n            str_current = str( i ) \\n            \\n            #Use the index to find the expected number in num\\n            expected_number = int ( num[ i ] )\\n            \\n            #Use the stringified number to find its occurences in counter\\n            if str_current in counter:\\n                digit_count = int( counter[ str_current ] )\\n                \\n            #If it is not found, the count is zero\\n            else:\\n                digit_count = 0\\n            \\n            #If we don\\'t find the expected number as the count, we return False\\n            if expected_number != digit_count:\\n                return False\\n            \\n        #Otherwise, all that are checked are valid\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2092793,
                "title": "rust-hashmap-counter-o-n",
                "content": "```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn digit_count(num: String) -> bool {\\n        let mut dc = HashMap::new();\\n        for c in num.chars() {\\n            let d: usize = c.to_digit(10).unwrap_or(88) as usize;\\n            *dc.entry(d).or_insert(0) += 1;\\n        }\\n        \\n        for (i, c) in num.chars().enumerate() {\\n            let cnt: usize = c.to_digit(10).unwrap_or(99) as usize;\\n            if !dc.contains_key(&i) {\\n                if cnt == 0 {\\n                    continue\\n                } else {\\n                    return false;\\n                }\\n            } else if dc[&i] != cnt {\\n                return false;\\n            }\\n        }\\n        true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn digit_count(num: String) -> bool {\\n        let mut dc = HashMap::new();\\n        for c in num.chars() {\\n            let d: usize = c.to_digit(10).unwrap_or(88) as usize;\\n            *dc.entry(d).or_insert(0) += 1;\\n        }\\n        \\n        for (i, c) in num.chars().enumerate() {\\n            let cnt: usize = c.to_digit(10).unwrap_or(99) as usize;\\n            if !dc.contains_key(&i) {\\n                if cnt == 0 {\\n                    continue\\n                } else {\\n                    return false;\\n                }\\n            } else if dc[&i] != cnt {\\n                return false;\\n            }\\n        }\\n        true\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2087358,
                "title": "c-easy-0ms-100-beats-beginner-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        unordered_map<char,int>ans;\\n        for(int i=0; i<num.size(); i++)\\n            ans[num[i]]++;\\n        for(int i=0; i<num.size(); i++){\\n            char c =\\'0\\' + i;\\n            if(num[i] != \\'0\\' + ans[c]){\\n                return false;\\n                \\n\\n            }\\n        }  \\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool digitCount(string num) {\\n        unordered_map<char,int>ans;\\n        for(int i=0; i<num.size(); i++)\\n            ans[num[i]]++;\\n        for(int i=0; i<num.size(); i++){\\n            char c =\\'0\\' + i;\\n            if(num[i] != \\'0\\' + ans[c]){\\n                return false;\\n                \\n\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2086477,
                "title": "javascript-soln",
                "content": "```\\nvar digitCount = function(num) {\\n\\n    const numArray = num.split(\"\");\\n    for(let i=0;i<num.length;i++){\\n      if (!(num[i] == countFreq(numArray,`${i}`))) {\\n          return false;\\n      }\\n    }\\n    return true;\\n};\\n\\nconst countFreq = (arr,index) => {\\n   return( (arr.filter( (n) => {return n===index && n})).length );\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nvar digitCount = function(num) {\\n\\n    const numArray = num.split(\"\");\\n    for(let i=0;i<num.length;i++){\\n      if (!(num[i] == countFreq(numArray,`${i}`))) {\\n          return false;\\n      }\\n    }\\n    return true;\\n};\\n\\nconst countFreq = (arr,index) => {\\n   return( (arr.filter( (n) => {return n===index && n})).length );\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2086252,
                "title": "javascript-solution-using-replace",
                "content": "```\\n    for(let i = 0; i < num.length; i++) {\\n        const temp = num.replace(new RegExp(`${i}`, \"g\"), \"\");\\n        if (num.length - temp.length !== num.charAt(i) - \\'0\\') {\\n            return false;\\n        }\\n    }\\n    \\n    return true;\\n```",
                "solutionTags": [],
                "code": "```\\n    for(let i = 0; i < num.length; i++) {\\n        const temp = num.replace(new RegExp(`${i}`, \"g\"), \"\");\\n        if (num.length - temp.length !== num.charAt(i) - \\'0\\') {\\n            return false;\\n        }\\n    }\\n    \\n    return true;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2085920,
                "title": "cpp-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string nums) {\\n        unordered_map<char,int>m;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m[nums[i]]++;\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            char t=nums[i];\\n            auto it=m.find(i+\\'0\\');\\n            if(it!=m.end())\\n            {\\n                if(it->second!=t-\\'0\\')\\n                {\\n                    return false;\\n                }\\n            }\\n            else if(it==m.end()&&(t)!=\\'0\\')\\n            {\\n                return false;\\n            }\\n            else\\n                continue;\\n            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string nums) {\\n        unordered_map<char,int>m;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m[nums[i]]++;\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            char t=nums[i];\\n            auto it=m.find(i+\\'0\\');\\n            if(it!=m.end())\\n            {\\n                if(it->second!=t-\\'0\\')\\n                {\\n                    return false;\\n                }\\n            }\\n            else if(it==m.end()&&(t)!=\\'0\\')\\n            {\\n                return false;\\n            }\\n            else\\n                continue;\\n            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085579,
                "title": "cpp-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        for(int i = 0  ; i < num.size() ; i++){\\n                int a = count(num.begin() , num.end() , i+\\'0\\'); // Make sure you actually convert those integers to characters by manipulating those ASCII values , here we count the occurances of the i th indice.\\n                if(a!=(num[i]-\\'0\\')) \\n                        return false;\\n        }\\n            return true;\\n    }\\n};\\n```\\n**Please upvote if you find this helpful**",
                "solutionTags": [
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        for(int i = 0  ; i < num.size() ; i++){\\n                int a = count(num.begin() , num.end() , i+\\'0\\'); // Make sure you actually convert those integers to characters by manipulating those ASCII values , here we count the occurances of the i th indice.\\n                if(a!=(num[i]-\\'0\\')) \\n                        return false;\\n        }\\n            return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085435,
                "title": "0-ms-faster-hashmap-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string nums) {\\n        \\n        map<int,int>mp;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]!=\\'0\\') //if any number is occuring zero times then do not add that number into map\\n                mp[i] = nums[i] - \\'0\\';\\n        }\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(mp.find(nums[i]-\\'0\\') == mp.end())\\n                return false;\\n            \\n            mp[nums[i]-\\'0\\']--;\\n            if(mp[nums[i]-\\'0\\']==0) //if value become zero then remove it from the map.\\n                mp.erase(nums[i]-\\'0\\');\\n        }\\n        if(mp.size()==0) // if map is empty then return true.\\n            return true;\\n        else\\n            return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string nums) {\\n        \\n        map<int,int>mp;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]!=\\'0\\') //if any number is occuring zero times then do not add that number into map\\n                mp[i] = nums[i] - \\'0\\';\\n        }\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(mp.find(nums[i]-\\'0\\') == mp.end())\\n                return false;\\n            \\n            mp[nums[i]-\\'0\\']--;\\n            if(mp[nums[i]-\\'0\\']==0) //if value become zero then remove it from the map.\\n                mp.erase(nums[i]-\\'0\\');\\n        }\\n        if(mp.size()==0) // if map is empty then return true.\\n            return true;\\n        else\\n            return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085302,
                "title": "go-golang-solution",
                "content": "```go\\nfunc digitCount(num string) bool {\\n    n := len(num)\\n    var a [10]int\\n    var b [10]int\\n    for i := 0; i < n; i++ {\\n        a[num[i] - \\'0\\']++\\n        b[i] = int(num[i] - \\'0\\')\\n    }\\n    return a == b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc digitCount(num string) bool {\\n    n := len(num)\\n    var a [10]int\\n    var b [10]int\\n    for i := 0; i < n; i++ {\\n        a[num[i] - \\'0\\']++\\n        b[i] = int(num[i] - \\'0\\')\\n    }\\n    return a == b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2085072,
                "title": "hasmap-counting-c-sort-and-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n      map<int,int>mp;\\n        for(auto it:num){\\n            mp[it-\\'0\\']++;\\n        }\\n        for(int i=0;i<num.size();i++){\\n            if(mp[i]!=num[i]-\\'0\\'){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n      map<int,int>mp;\\n        for(auto it:num){\\n            mp[it-\\'0\\']++;\\n        }\\n        for(int i=0;i<num.size();i++){\\n            if(mp[i]!=num[i]-\\'0\\'){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084831,
                "title": "c-array",
                "content": "```\\n    public bool DigitCount(string num)\\n    {\\n        int[] freq = new int[10];\\n        foreach (char n in num)\\n            freq[n - \\'0\\']++;\\n\\n        for (int i = 0; i < num.Length; i++)\\n            if (num[i] - \\'0\\' != freq[i])\\n                return false;\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\n    public bool DigitCount(string num)\\n    {\\n        int[] freq = new int[10];\\n        foreach (char n in num)\\n            freq[n - \\'0\\']++;\\n\\n        for (int i = 0; i < num.Length; i++)\\n            if (num[i] - \\'0\\' != freq[i])\\n                return false;\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2084695,
                "title": "c-solution",
                "content": "**Complexity**\\n- Time: O(n)\\n- Space: O(1)\\n\\n**Implementation**\\n```\\npublic class Solution {\\n    public bool DigitCount(string num) {\\n        \\n        if(string.IsNullOrEmpty(num))\\n            throw new ArgumentException(\"Invalid Input.\");\\n        \\n        int[] freq = new int[10];\\n        foreach(var c in num)\\n            freq[c - \\'0\\']++;\\n        \\n        for(int i = 0; i < num.Length; i++)\\n        {\\n            if(freq[i] != num[i] - \\'0\\')\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool DigitCount(string num) {\\n        \\n        if(string.IsNullOrEmpty(num))\\n            throw new ArgumentException(\"Invalid Input.\");\\n        \\n        int[] freq = new int[10];\\n        foreach(var c in num)\\n            freq[c - \\'0\\']++;\\n        \\n        for(int i = 0; i < num.Length; i++)\\n        {\\n            if(freq[i] != num[i] - \\'0\\')\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084574,
                "title": "python-counter-solution",
                "content": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        counts = Counter(num)\\n        for i in range(len(num)):\\n            if counts[str(i)] != int(num[i]):\\n                return False\\n        return True \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        counts = Counter(num)\\n        for i in range(len(num)):\\n            if counts[str(i)] != int(num[i]):\\n                return False\\n        return True \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084512,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Time Complexity : O(N * N)***\\n\\n* ***Space Complexity : O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n        int n = num.size();\\n        \\n        unordered_map<int, int> mp;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int count = 0;\\n            \\n            for(int j = 0; j < n; j++)\\n            {\\n                if(num[j] - \\'0\\' == i)\\n                {\\n                    count++;\\n                }\\n            }\\n            \\n            mp[i] = count;\\n        }\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(mp[i] != num[i] - \\'0\\')\\n            {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n        int n = num.size();\\n        \\n        unordered_map<int, int> mp;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int count = 0;\\n            \\n            for(int j = 0; j < n; j++)\\n            {\\n                if(num[j] - \\'0\\' == i)\\n                {\\n                    count++;\\n                }\\n            }\\n            \\n            mp[i] = count;\\n        }\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(mp[i] != num[i] - \\'0\\')\\n            {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084315,
                "title": "clean-python-code-using-counter",
                "content": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        d = Counter(num)\\n        for idx, val in enumerate(num):\\n            if int(val) != d[str(idx)]:\\n                return False\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        d = Counter(num)\\n        for idx, val in enumerate(num):\\n            if int(val) != d[str(idx)]:\\n                return False\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084106,
                "title": "c-simple",
                "content": "\\n\\n    class Solution {\\n\\n    public:\\n    bool digitCount(string num) {\\n       vector<int>v(11,0);\\n        for(int i=0;i<num.size();i++){\\n          v[num[i]-\\'0\\']++;\\n            //cout<<v[num[i]-\\'0\\']<<\" \";\\n        }\\n        for(int i=0;i<num.size();i++){\\n            int x=num[i]-\\'0\\';\\n            if(v[i]!=x){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public:\\n    bool digitCount(string num) {\\n       vector<int>v(11,0);\\n        for(int i=0;i<num.size();i++){\\n          v[num[i]-\\'0\\']++;\\n            //cout<<v[num[i]-\\'0\\']<<\" \";\\n        }",
                "codeTag": "C++"
            },
            {
                "id": 2083968,
                "title": "simple-c-using-map-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        unordered_map<int,int> mp;\\n        for(auto x:num) mp[x-\\'0\\']++;\\n        for(int i=0;i<num.size();i++){\\n            if(num[i]-\\'0\\'!=mp[i]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n**If you like this, Do Upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        unordered_map<int,int> mp;\\n        for(auto x:num) mp[x-\\'0\\']++;\\n        for(int i=0;i<num.size();i++){\\n            if(num[i]-\\'0\\'!=mp[i]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083919,
                "title": "easy-short-efficient-solution",
                "content": "```\\nclass Solution {\\n#define ln ListNode\\n#define tn TreeNode\\n    typedef long long ll;\\n    typedef vector<ll> vi;\\n#define endl \\'\\\\n\\'\\n    const ll mod = 1e9;\\npublic:\\n    bool digitCount(string& s) {\\n        vi hash(10);\\n        for (char& ch : s)\\n            ++hash[ch - \\'0\\'];\\n        for (ll i = 0;i < s.length();++i)\\n            if (hash[i] != (s[i] - \\'0\\'))return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n#define ln ListNode\\n#define tn TreeNode\\n    typedef long long ll;\\n    typedef vector<ll> vi;\\n#define endl \\'\\\\n\\'\\n    const ll mod = 1e9;\\npublic:\\n    bool digitCount(string& s) {\\n        vi hash(10);\\n        for (char& ch : s)\\n            ++hash[ch - \\'0\\'];\\n        for (ll i = 0;i < s.length();++i)\\n            if (hash[i] != (s[i] - \\'0\\'))return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083886,
                "title": "solution-using-hash-map-in-python",
                "content": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        leng = len(num)\\n        freq = {}\\n        \\n        for i in range(leng):\\n            freq[str(i)] = 0\\n            \\n        for i in range(leng):\\n            if num[i] in freq:\\n                freq[num[i]] += 1\\n        \\n        for i in range(leng):\\n            if num[i] == str(freq[str(i)]):\\n                continue\\n            else:\\n                return False\\n            \\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        leng = len(num)\\n        freq = {}\\n        \\n        for i in range(leng):\\n            freq[str(i)] = 0\\n            \\n        for i in range(leng):\\n            if num[i] in freq:\\n                freq[num[i]] += 1\\n        \\n        for i in range(leng):\\n            if num[i] == str(freq[str(i)]):\\n                continue\\n            else:\\n                return False\\n            \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083855,
                "title": "c-easy-to-understand-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        map<int,int> mp1,mp2;\\n        int i=0;\\n        for(char ch:num)\\n        {\\n            if(ch!=\\'0\\')\\n            mp1[i]=ch-\\'0\\';\\n                i++;\\n        }\\n        for(char ch:num)\\n        {\\n            mp2[ch-\\'0\\']++;\\n        }\\n        return mp1==mp2;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        map<int,int> mp1,mp2;\\n        int i=0;\\n        for(char ch:num)\\n        {\\n            if(ch!=\\'0\\')\\n            mp1[i]=ch-\\'0\\';\\n                i++;\\n        }\\n        for(char ch:num)\\n        {\\n            mp2[ch-\\'0\\']++;\\n        }\\n        return mp1==mp2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083835,
                "title": "c-easy-with-explanation",
                "content": "```\\n// Easy solution. We\\'ll first populate the array by string elements and then check if they \\n//are equal or not.\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        int n = num.size();\\n        vector<int> arr(10,0);\\n        for(auto &it : num){\\n            arr[it-\\'0\\']++;\\n        }\\n        bool ans = 1;\\n        for(int i = 0;i<n;i++){\\n            if(arr[i] != num[i]-\\'0\\'){\\n                ans = 0;\\n                break;\\n            }\\n        }\\n        if(ans)\\n            return true;\\n        else return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// Easy solution. We\\'ll first populate the array by string elements and then check if they \\n//are equal or not.\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        int n = num.size();\\n        vector<int> arr(10,0);\\n        for(auto &it : num){\\n            arr[it-\\'0\\']++;\\n        }\\n        bool ans = 1;\\n        for(int i = 0;i<n;i++){\\n            if(arr[i] != num[i]-\\'0\\'){\\n                ans = 0;\\n                break;\\n            }\\n        }\\n        if(ans)\\n            return true;\\n        else return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083824,
                "title": "java-do-as-they-ask",
                "content": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] bucket = new int[10];\\n        for (char c : num.toCharArray()) {\\n            bucket[c - \\'0\\']++;\\n        }\\n        int i = 0;\\n        for (; i < num.length(); i++) {\\n            if (bucket[i] != num.charAt(i) - \\'0\\') return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] bucket = new int[10];\\n        for (char c : num.toCharArray()) {\\n            bucket[c - \\'0\\']++;\\n        }\\n        int i = 0;\\n        for (; i < num.length(); i++) {\\n            if (bucket[i] != num.charAt(i) - \\'0\\') return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083772,
                "title": "c-using-10-size-vector",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        int arr[10] = {0};\\n        for(auto it : num){\\n            arr[it-\\'0\\']++;\\n        }\\n        for(int i=0;i<num.size();i++){\\n            if(arr[i]!=(num[i])-\\'0\\') return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        int arr[10] = {0};\\n        for(auto it : num){\\n            arr[it-\\'0\\']++;\\n        }\\n        for(int i=0;i<num.size();i++){\\n            if(arr[i]!=(num[i])-\\'0\\') return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083762,
                "title": "python-java-easy-to-understand",
                "content": "\\tclass Solution:\\n\\t\\tdef digitCount(self, num: str) -> bool:\\n\\t\\t\\tcnt = collections.Counter(num)\\n\\t\\t\\tfor i, digit in enumerate(num):\\n\\t\\t\\t\\tif cnt[str(i)] != int(digit):\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\treturn True\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic boolean digitCount(String num) {\\n\\t\\t\\tint[] cnt = new int[10];\\n\\t\\t\\tfor (char c: num.toCharArray()) {\\n\\t\\t\\t\\tcnt[c - \\'0\\'] += 1;\\n\\t\\t\\t}\\n\\t\\t\\tfor (int i = 0; i < num.length(); i ++) {\\n\\t\\t\\t\\tif (cnt[i] != num.charAt(i) - \\'0\\') {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef digitCount(self, num: str) -> bool:\\n\\t\\t\\tcnt = collections.Counter(num)\\n\\t\\t\\tfor i, digit in enumerate(num):\\n\\t\\t\\t\\tif cnt[str(i)] != int(digit):\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\treturn True\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic boolean digitCount(String num) {\\n\\t\\t\\tint[] cnt = new int[10];\\n\\t\\t\\tfor (char c: num.toCharArray()) {\\n\\t\\t\\t\\tcnt[c - \\'0\\'] += 1;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 4084293,
                "title": "check-if-number-has-equal-digit-count",
                "content": "# Approach\\n1. Split number into an array by converting it into a string and the split methods.\\n2. By default, set all numbers to be true. \\n3. Use a for loop to iterate through the array. \\n4. For each loop, get the length of the filtered array - count. \\n5. Filter the array to find if the string \\'x\\' is equal to stringified index \\'i\\'. \\n6. If count does not equal the value at arr[i], switch isValid to false and break the loop. \\n7. return isValid\\n\\n\\n```\\n/**\\n * @param {string} num\\n * @return {boolean}\\n */\\nvar digitCount = function(num) {\\n    const arr = num.toString().split(\\'\\');\\n    let isValid = true;\\n\\n    for (let i = 0; i < arr.length; i++) {\\n        const count = arr.filter((x) => x === i.toString()).length;\\n        if (count !== parseInt(arr[i])) {\\n            isValid = false;\\n            break;\\n        }\\n    }\\n\\n    return isValid;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} num\\n * @return {boolean}\\n */\\nvar digitCount = function(num) {\\n    const arr = num.toString().split(\\'\\');\\n    let isValid = true;\\n\\n    for (let i = 0; i < arr.length; i++) {\\n        const count = arr.filter((x) => x === i.toString()).length;\\n        if (count !== parseInt(arr[i])) {\\n            isValid = false;\\n            break;\\n        }\\n    }\\n\\n    return isValid;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4079858,
                "title": "python-dictionary-solution-beats-99-in-memory-70-in-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        d = {}\\n        n = list(map(int, num))\\n        for i in n:\\n            if i in d:\\n                d[i] += 1\\n            else:\\n                d[i] = 1\\n        res = True\\n        for i in range(len(n)):\\n            if i in d:\\n                if d[i] != n[i]:\\n                    res = False\\n                    break\\n            elif i not in d:\\n                if n[i] > 0:\\n                    res = False\\n                    break\\n\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        d = {}\\n        n = list(map(int, num))\\n        for i in n:\\n            if i in d:\\n                d[i] += 1\\n            else:\\n                d[i] = 1\\n        res = True\\n        for i in range(len(n)):\\n            if i in d:\\n                if d[i] != n[i]:\\n                    res = False\\n                    break\\n            elif i not in d:\\n                if n[i] > 0:\\n                    res = False\\n                    break\\n\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079441,
                "title": "discuss",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] count = new int[10];\\n\\n        for (final char c : num.toCharArray())\\n        ++count[c - \\'0\\'];\\n\\n        for (int i = 0; i < num.length(); ++i)\\n        if (count[i] != num.charAt(i) - \\'0\\')\\n            return false;\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] count = new int[10];\\n\\n        for (final char c : num.toCharArray())\\n        ++count[c - \\'0\\'];\\n\\n        for (int i = 0; i < num.length(); ++i)\\n        if (count[i] != num.charAt(i) - \\'0\\')\\n            return false;\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078817,
                "title": "c-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nObviously try to avoid n2\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPutting the digits and their associated occurence in the map. You need to go through the num string again and decrease every time you see a digit. If the map holds digits for which the number of occurence left is not 0, than we have a problem.\\nCould be optmized.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) Map has a maximum of 10 entries.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        map<int,int> myMap;\\n\\n        for (int i=0; i<num.size(); i++) {\\n            myMap[i] = (int) num[i] -48; \\n        }\\n\\n        for (int i=0; i<num.size(); i++) { \\n            myMap[(int) num[i] -48]--;\\n        }\\n\\n        for (const auto & [key, value] : myMap)\\n            if (value != 0) return false;\\n\\n        return true;\\n    }\\n};\\n\\n// 0 apparait 1\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        map<int,int> myMap;\\n\\n        for (int i=0; i<num.size(); i++) {\\n            myMap[i] = (int) num[i] -48; \\n        }\\n\\n        for (int i=0; i<num.size(); i++) { \\n            myMap[(int) num[i] -48]--;\\n        }\\n\\n        for (const auto & [key, value] : myMap)\\n            if (value != 0) return false;\\n\\n        return true;\\n    }\\n};\\n\\n// 0 apparait 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078556,
                "title": "two-lines-solution",
                "content": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        cnt = Counter(map(int, num))\\n        return all(cnt[i] == int(n) for i, n in enumerate(num))      \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        cnt = Counter(map(int, num))\\n        return all(cnt[i] == int(n) for i, n in enumerate(num))      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071840,
                "title": "solution-in-java",
                "content": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] freq = new int[10];\\n        for(int i=0;i<num.length();i++){\\n            freq[num.charAt(i)-\\'0\\']++;\\n        }\\n        for(int i=0;i<num.length();i++){\\n            if(num.charAt(i)-\\'0\\' != freq[i]) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] freq = new int[10];\\n        for(int i=0;i<num.length();i++){\\n            freq[num.charAt(i)-\\'0\\']++;\\n        }\\n        for(int i=0;i<num.length();i++){\\n            if(num.charAt(i)-\\'0\\' != freq[i]) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071042,
                "title": "easy-c-solution",
                "content": "# Approach\\n- Build dictionary - cahr and number of occurencies of tthe char\\n- Check if ther condiction holds for each index\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public bool DigitCount(string num)\\n    {\\n        var dictionary = new Dictionary<char, int>();\\n        foreach (var c in num)\\n        {\\n            dictionary[c] = dictionary.GetValueOrDefault(c) + 1;\\n        }\\n\\n        return !num.Where((t, i) => dictionary.GetValueOrDefault((char) (\\'0\\' + i)) != t - \\'0\\').Any();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public bool DigitCount(string num)\\n    {\\n        var dictionary = new Dictionary<char, int>();\\n        foreach (var c in num)\\n        {\\n            dictionary[c] = dictionary.GetValueOrDefault(c) + 1;\\n        }\\n\\n        return !num.Where((t, i) => dictionary.GetValueOrDefault((char) (\\'0\\' + i)) != t - \\'0\\').Any();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058408,
                "title": "c-100-faster-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(|hashTable|)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\tbool digitCount(string num) {\\n\\n\\t\\tint count[10] = {0};\\n\\n\\t\\tint inputSize = num.size();\\n\\n\\t\\tfor (int i = 0; i < inputSize; ++i)\\n\\t\\t{\\n\\t\\t\\tcount[num[i]-48]++;\\n\\t\\t}\\n\\n\\n\\t\\tfor (int i = 0; i < inputSize; ++i)\\n\\t\\t{\\n\\t\\t\\tif( (num[i]-48) !=  count[i]){\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn true;\\n\\n\\t}\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tbool digitCount(string num) {\\n\\n\\t\\tint count[10] = {0};\\n\\n\\t\\tint inputSize = num.size();\\n\\n\\t\\tfor (int i = 0; i < inputSize; ++i)\\n\\t\\t{\\n\\t\\t\\tcount[num[i]-48]++;\\n\\t\\t}\\n\\n\\n\\t\\tfor (int i = 0; i < inputSize; ++i)\\n\\t\\t{\\n\\t\\t\\tif( (num[i]-48) !=  count[i]){\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn true;\\n\\n\\t}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047491,
                "title": "python-o-1-space-complexity-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n\\n        for i in range(len(num)):\\n            if num.count(str(i)) != int(num[i]):\\n                return False\\n        \\n        return True\\n           \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n\\n        for i in range(len(num)):\\n            if num.count(str(i)) != int(num[i]):\\n                return False\\n        \\n        return True\\n           \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046356,
                "title": "easy-and-understandable-code-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n       \\n       vector<int>v;\\n       unordered_map<int,int>mp;\\n\\n       for(auto it:num)\\n       v.push_back(it-48);\\n\\n       for(auto it:v)\\n       mp[it]++;\\n\\n       for(int i=0;i<v.size();i++){\\n           if(mp[i]!=v[i])\\n            return false;\\n       }\\n       return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n       \\n       vector<int>v;\\n       unordered_map<int,int>mp;\\n\\n       for(auto it:num)\\n       v.push_back(it-48);\\n\\n       for(auto it:v)\\n       mp[it]++;\\n\\n       for(int i=0;i<v.size();i++){\\n           if(mp[i]!=v[i])\\n            return false;\\n       }\\n       return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045126,
                "title": "2283-check-if-number-has-equal-digit-count-and-digit-value",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n\\n           HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int number = 0; number < num.length(); number++){\\n            int frequency = Character.getNumericValue(num.charAt(number));\\n            map.put(number,frequency);\\n        }\\n\\n        for(int index = 0; index< num.length(); index++) {\\n\\n            if (Character.getNumericValue(num.charAt(index)) < num.length()) {\\n\\n                int frequency = map.get(Character.getNumericValue(num.charAt(index))) - 1;\\n                map.put(Character.getNumericValue(num.charAt(index)), frequency);\\n            }\\n        }\\n\\n        for (int i = 0; i < num.length(); i++) {\\n            if(map.get(i) !=0){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n\\n           HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int number = 0; number < num.length(); number++){\\n            int frequency = Character.getNumericValue(num.charAt(number));\\n            map.put(number,frequency);\\n        }\\n\\n        for(int index = 0; index< num.length(); index++) {\\n\\n            if (Character.getNumericValue(num.charAt(index)) < num.length()) {\\n\\n                int frequency = map.get(Character.getNumericValue(num.charAt(index))) - 1;\\n                map.put(Character.getNumericValue(num.charAt(index)), frequency);\\n            }\\n        }\\n\\n        for (int i = 0; i < num.length(); i++) {\\n            if(map.get(i) !=0){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042268,
                "title": "easiest-approach-beats-100-c-best-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        unordered_map<char,int> san;\\n        for(auto &x:num)\\n            san[x]++;\\n        int k=0;\\n        int desh=num.size();\\n        while(desh--){\\n            if(san[(char)(k+48)]!=(num[k]-\\'0\\'))\\n                return false;\\n            k++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        unordered_map<char,int> san;\\n        for(auto &x:num)\\n            san[x]++;\\n        int k=0;\\n        int desh=num.size();\\n        while(desh--){\\n            if(san[(char)(k+48)]!=(num[k]-\\'0\\'))\\n                return false;\\n            k++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032741,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code aims to check if a given string num satisfies a specific condition where each digit i must occur exactly i times in the string. If this condition is met for every digit, the function returns true; otherwise, it returns false. The code uses a HashMap to count the occurrences of each digit in the string and compares the counts with the expected values.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Check if the first character of the string is \\'0\\'. If it is, return false because \\'0\\' cannot be the first character if every digit should occur at least once.\\n\\n2. Initialize a HashMap<Integer, Integer> called map to store the counts of each digit.\\n\\n3. Iterate through each character ch in the string num:\\n\\n4. Calculate the numeric value k of the current character by subtracting \\'0\\' from it.\\nUpdate the count of digit k in the map by using map.put(k, map.getOrDefault(k, 0) + 1).\\nIterate through the indices i from 0 to n-1, where n is the length of the string num:\\n\\n5. Calculate the numeric value m of the digit at index i in num.\\nCheck if m is equal to the count of digit i in the map using map.getOrDefault(i, 0).\\nIf m is not equal to the expected count, return false.\\nIf the code reaches this point without returning false, it means that the condition is satisfied for every digit, so return true.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe code iterates through the string num twice, once to count the occurrences of each digit and once to check if the counts match the expected values. Therefore, the time complexity is O(2n), which simplifies to O(n), where n is the length of the input string num.\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe code uses a HashMap to store the counts of digits, which can have a maximum of 10 entries (0 to 9). Therefore, the space complexity is O(10), which simplifies to O(1) as it\\'s a constant space requirement.\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        if (num.charAt(0) == \\'0\\') return false;\\n\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int n = num.length();\\n\\n        for (char ch : num.toCharArray()){\\n            int k = ch - \\'0\\';\\n            map.put(k, map.getOrDefault(k, 0) + 1);\\n        }\\n\\n        for (int i = 0; i < n; i++){\\n            int m = num.charAt(i) - \\'0\\';\\n            if (m != map.getOrDefault(i, 0)){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\n![Frame 76.png](https://assets.leetcode.com/users/images/31fa458e-ca66-4725-8967-2f81fdd2ed8f_1694460428.0372012.png)\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        if (num.charAt(0) == \\'0\\') return false;\\n\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int n = num.length();\\n\\n        for (char ch : num.toCharArray()){\\n            int k = ch - \\'0\\';\\n            map.put(k, map.getOrDefault(k, 0) + 1);\\n        }\\n\\n        for (int i = 0; i < n; i++){\\n            int m = num.charAt(i) - \\'0\\';\\n            if (m != map.getOrDefault(i, 0)){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031271,
                "title": "python3-easy-2-liner-upvote-if-you-like",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        counter = Counter(num)\\n        return all(str(counter.get(str(index), 0)) == digit for index, digit in enumerate(num))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        counter = Counter(num)\\n        return all(str(counter.get(str(index), 0)) == digit for index, digit in enumerate(num))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023967,
                "title": "100-beats-java-solution",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String nums) {\\n\\n\\n        int[] flag = new int[10];\\n\\n\\n        for(int i = 0; i<nums.length(); i++){\\n            flag[nums.charAt(i)-\\'0\\']++;\\n        }\\n\\n\\n        for(int i = 0; i<nums.length(); i++){\\n            if(nums.charAt(i)-\\'0\\'!=flag[i]) return false;\\n        }\\n\\n        return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String nums) {\\n\\n\\n        int[] flag = new int[10];\\n\\n\\n        for(int i = 0; i<nums.length(); i++){\\n            flag[nums.charAt(i)-\\'0\\']++;\\n        }\\n\\n\\n        for(int i = 0; i<nums.length(); i++){\\n            if(nums.charAt(i)-\\'0\\'!=flag[i]) return false;\\n        }\\n\\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021280,
                "title": "check-if-number-has-equal-digit-count-and-digit-value-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        for(int i=0;i<num.length();i++)\\n        {\\n            if(num.charAt(i)-\\'0\\' != Freq(num,(char)(i + \\'0\\')))\\n            return false;\\n        }\\n        return true;\\n    }\\n    public int Freq(String s , char ch)\\n    {\\n        int f=0;\\n        for(int i=0;i<s.length();i++)\\n        if(s.charAt(i)==ch)\\n        f++;\\n        return f;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        for(int i=0;i<num.length();i++)\\n        {\\n            if(num.charAt(i)-\\'0\\' != Freq(num,(char)(i + \\'0\\')))\\n            return false;\\n        }\\n        return true;\\n    }\\n    public int Freq(String s , char ch)\\n    {\\n        int f=0;\\n        for(int i=0;i<s.length();i++)\\n        if(s.charAt(i)==ch)\\n        f++;\\n        return f;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014663,
                "title": "1ms-java-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        for (int i = 0; i < num.length(); i++) {\\n            int digit = num.charAt(i) - \\'0\\'; // Convert the character to an integer digit\\n            int count = 0;\\n\\n            for (int j = 0; j < num.length(); j++) {\\n                int currentDigit = num.charAt(j) - \\'0\\';\\n                if (currentDigit == i) {\\n                    count++;\\n                }\\n            }\\n            if (count != digit) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        for (int i = 0; i < num.length(); i++) {\\n            int digit = num.charAt(i) - \\'0\\'; // Convert the character to an integer digit\\n            int count = 0;\\n\\n            for (int j = 0; j < num.length(); j++) {\\n                int currentDigit = num.charAt(j) - \\'0\\';\\n                if (currentDigit == i) {\\n                    count++;\\n                }\\n            }\\n            if (count != digit) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014504,
                "title": "1ms-easy-code-java-string",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        for (int i = 0; i < num.length(); i++) {\\n            int digit = num.charAt(i) - \\'0\\'; // Convert the character to an integer digit\\n            int count = 0;\\n\\n            for (int j = 0; j < num.length(); j++) {\\n                int currentDigit = num.charAt(j) - \\'0\\';\\n                if (currentDigit == i) {\\n                    count++;\\n                }\\n            }\\n\\n            if (count != digit) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        for (int i = 0; i < num.length(); i++) {\\n            int digit = num.charAt(i) - \\'0\\'; // Convert the character to an integer digit\\n            int count = 0;\\n\\n            for (int j = 0; j < num.length(); j++) {\\n                int currentDigit = num.charAt(j) - \\'0\\';\\n                if (currentDigit == i) {\\n                    count++;\\n                }\\n            }\\n\\n            if (count != digit) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012973,
                "title": "one-line-solution-using-list-comprehensions",
                "content": "# Code\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        return len([x for i, x in enumerate(num) if int(x) == num.count(str(i))]) == len(num)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        return len([x for i, x in enumerate(num) if int(x) == num.count(str(i))]) == len(num)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009684,
                "title": "easy-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n       int n = num.length();\\n        int count[10] = {0};\\n        for (int i = 0; i < n; i++) {\\n            count[num[i] - \\'0\\']++;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (count[i] != num[i] - \\'0\\') {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n       int n = num.length();\\n        int count[10] = {0};\\n        for (int i = 0; i < n; i++) {\\n            count[num[i] - \\'0\\']++;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (count[i] != num[i] - \\'0\\') {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009618,
                "title": "simple-java-solution-0-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int arr[]=new int[num.length()];\\n        int c=0;\\n        for(int i=0;i<num.length();i++)\\n            arr[i]=num.charAt(i)-\\'0\\';\\n        for(int i=0;i<arr.length;i++){\\n            int n=arr[i];\\n            for(int j=0;j<arr.length;j++){\\n                if(arr[j]==i)\\n                    c++;\\n            }\\n            if(c!=n)\\n                return false;\\n            c=0;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int arr[]=new int[num.length()];\\n        int c=0;\\n        for(int i=0;i<num.length();i++)\\n            arr[i]=num.charAt(i)-\\'0\\';\\n        for(int i=0;i<arr.length;i++){\\n            int n=arr[i];\\n            for(int j=0;j<arr.length;j++){\\n                if(arr[j]==i)\\n                    c++;\\n            }\\n            if(c!=n)\\n                return false;\\n            c=0;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007228,
                "title": "beats-82-runtime-and-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} num\\n * @return {boolean}\\n */\\nvar digitCount = function(num) {\\n     let n = new Map();\\n    let numArray = num.split(\\'\\');\\n    for (i = 0; i < numArray.length; i++) {\\n        let val = 0;\\n        let index = Number(numArray[i]);\\n        n.get(index) ? val = n.get(index) + 1 : val = 1\\n        n.set(index, val);\\n    }\\n    for (i = 0; i < num.length; i++) {\\n        const a = Number(n.get(i)) || 0\\n        const b = Number(numArray[i])\\n        if (a !== b) {\\n            return false\\n        }\\n    }\\n    return true\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} num\\n * @return {boolean}\\n */\\nvar digitCount = function(num) {\\n     let n = new Map();\\n    let numArray = num.split(\\'\\');\\n    for (i = 0; i < numArray.length; i++) {\\n        let val = 0;\\n        let index = Number(numArray[i]);\\n        n.get(index) ? val = n.get(index) + 1 : val = 1\\n        n.set(index, val);\\n    }\\n    for (i = 0; i < num.length; i++) {\\n        const a = Number(n.get(i)) || 0\\n        const b = Number(numArray[i])\\n        if (a !== b) {\\n            return false\\n        }\\n    }\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4004424,
                "title": "java-easy-solution-hashing-100-beats",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static boolean digitCount(String num) {\\n        int[] hash = new int[10];\\n        for(int n : num.toCharArray())\\n            hash[n-\\'0\\'-0]++;\\n        for(int i=0; i<num.length(); i++) \\n        \\tif(num.charAt(i)-\\'0\\'-0 != hash[i]) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public static boolean digitCount(String num) {\\n        int[] hash = new int[10];\\n        for(int n : num.toCharArray())\\n            hash[n-\\'0\\'-0]++;\\n        for(int i=0; i<num.length(); i++) \\n        \\tif(num.charAt(i)-\\'0\\'-0 != hash[i]) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001639,
                "title": "runtime-0ms-beats-100-00-of-users-with-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        vector<int> v(10,0);\\n        for (int i=0;i<num.size();i++){\\n            v[num[i]-\\'0\\']++;\\n        }\\n        for (int j=0;j<num.size();j++){\\n            if (v[j]!=(int)num[j]-\\'0\\'){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        vector<int> v(10,0);\\n        for (int i=0;i<num.size();i++){\\n            v[num[i]-\\'0\\']++;\\n        }\\n        for (int j=0;j<num.size();j++){\\n            if (v[j]!=(int)num[j]-\\'0\\'){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999682,
                "title": "python3-just-count-and-compare",
                "content": "# Code\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        N = len(num)\\n        cnts = [0]*10\\n        for n in num:\\n            cnts[int(n)]+=1\\n\\n        for i in range(N):\\n            if cnts[i] != int(num[i]):\\n                return False\\n\\n        return True            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        N = len(num)\\n        cnts = [0]*10\\n        for n in num:\\n            cnts[int(n)]+=1\\n\\n        for i in range(N):\\n            if cnts[i] != int(num[i]):\\n                return False\\n\\n        return True            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994411,
                "title": "typescript-simple-solution-100-speed",
                "content": "![image.png](https://assets.leetcode.com/users/images/63c37f02-c7f7-477b-9b62-9d963e8f500a_1693692919.8918602.png)\\n\\n# Code (100% speed)\\n```ts\\nfunction digitCount(num: string): boolean {\\n    const map = new Map<number, number>() // number, count\\n    const numStr = num + \"\"\\n\\n    for (const each of numStr) {\\n        const eachNum = parseInt(each)\\n        const got = map.get(eachNum) || 0\\n        map.set(eachNum, got + 1)\\n    }\\n\\n    for (let i = 0; i < numStr.length; i++) {\\n        const count = parseInt(numStr[i])\\n        if ((map.get(i) || 0) !== count) return false\\n    }\\n    return true\\n};\\n```\\n\\n# Thank you\\nUpvote if you like \\u2B06\\uFE0F\\nIf you have any questions, please let me know in the comment section.",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```ts\\nfunction digitCount(num: string): boolean {\\n    const map = new Map<number, number>() // number, count\\n    const numStr = num + \"\"\\n\\n    for (const each of numStr) {\\n        const eachNum = parseInt(each)\\n        const got = map.get(eachNum) || 0\\n        map.set(eachNum, got + 1)\\n    }\\n\\n    for (let i = 0; i < numStr.length; i++) {\\n        const count = parseInt(numStr[i])\\n        if ((map.get(i) || 0) !== count) return false\\n    }\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3994410,
                "title": "typescript-simple-solution-100-speed",
                "content": "![image.png](https://assets.leetcode.com/users/images/63c37f02-c7f7-477b-9b62-9d963e8f500a_1693692919.8918602.png)\\n\\n# Code (100% speed)\\n```ts\\nfunction digitCount(num: string): boolean {\\n    const map = new Map<number, number>() // number, count\\n    const numStr = num + \"\"\\n\\n    for (const each of numStr) {\\n        const eachNum = parseInt(each)\\n        const got = map.get(eachNum) || 0\\n        map.set(eachNum, got + 1)\\n    }\\n\\n    for (let i = 0; i < numStr.length; i++) {\\n        const count = parseInt(numStr[i])\\n        if ((map.get(i) || 0) !== count) return false\\n    }\\n    return true\\n};\\n```\\n\\n# Thank you\\nUpvote if you like \\u2B06\\uFE0F\\nIf you have any questions, please let me know in the comment section.",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```ts\\nfunction digitCount(num: string): boolean {\\n    const map = new Map<number, number>() // number, count\\n    const numStr = num + \"\"\\n\\n    for (const each of numStr) {\\n        const eachNum = parseInt(each)\\n        const got = map.get(eachNum) || 0\\n        map.set(eachNum, got + 1)\\n    }\\n\\n    for (let i = 0; i < numStr.length; i++) {\\n        const count = parseInt(numStr[i])\\n        if ((map.get(i) || 0) !== count) return false\\n    }\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3991812,
                "title": "0-ms-beats-100-00-of-users-with-c",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        vector<int> ans; \\n        for(int i=0;i<num.size();i++)\\n        {\\n            int temp=num[i]-48;\\n            ans.push_back(temp);\\n        }\\n        int f=0;\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            cout<<ans[i]<<\" \";\\n        }\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            int c=count(ans.begin(),ans.end(),i);\\n            if(c==ans[i])\\n            {\\n                f=1;\\n            }\\n            else\\n            {\\n                f=0;\\n                break;\\n            }\\n        }\\n        if(f==1)\\n        {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        vector<int> ans; \\n        for(int i=0;i<num.size();i++)\\n        {\\n            int temp=num[i]-48;\\n            ans.push_back(temp);\\n        }\\n        int f=0;\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            cout<<ans[i]<<\" \";\\n        }\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            int c=count(ans.begin(),ans.end(),i);\\n            if(c==ans[i])\\n            {\\n                f=1;\\n            }\\n            else\\n            {\\n                f=0;\\n                break;\\n            }\\n        }\\n        if(f==1)\\n        {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3981858,
                "title": "java-easy-solution-using-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        for(int i=0;i<num.length();i++){\\n            int m=Integer.parseInt(String.valueOf(num.charAt(i)));\\n            int c=0;\\n            for(int j=0;j<num.length();j++){\\n                int n=Integer.parseInt(String.valueOf(num.charAt(j)));\\n                if(n==i){\\n                    c++;\\n                }\\n            }\\n            if(c!=m){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        for(int i=0;i<num.length();i++){\\n            int m=Integer.parseInt(String.valueOf(num.charAt(i)));\\n            int c=0;\\n            for(int j=0;j<num.length();j++){\\n                int n=Integer.parseInt(String.valueOf(num.charAt(j)));\\n                if(n==i){\\n                    c++;\\n                }\\n            }\\n            if(c!=m){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970056,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        vector<int> vec(10,0);\\n        char c;\\n        for(int i=0;i<num.size();i++)\\n        {\\n            c=num[i];\\n            vec[c-\\'0\\']++;\\n        }\\n\\n        for(int i=0;i<num.size();i++)\\n        {\\n            if(num[i]-\\'0\\'!=vec[i])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        vector<int> vec(10,0);\\n        char c;\\n        for(int i=0;i<num.size();i++)\\n        {\\n            c=num[i];\\n            vec[c-\\'0\\']++;\\n        }\\n\\n        for(int i=0;i<num.size();i++)\\n        {\\n            if(num[i]-\\'0\\'!=vec[i])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969137,
                "title": "c-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n        map<int,int> vec;\\n        for(int i=0;i<num.size();i++)\\n        {\\n            vec[num[i]-\\'0\\']++;\\n        }\\n        for(int i=0;i<num.size();i++)\\n        {\\n            if(vec[i]!=num[i]-\\'0\\')\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n        map<int,int> vec;\\n        for(int i=0;i<num.size();i++)\\n        {\\n            vec[num[i]-\\'0\\']++;\\n        }\\n        for(int i=0;i<num.size();i++)\\n        {\\n            if(vec[i]!=num[i]-\\'0\\')\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969134,
                "title": "c-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n        map<int,int> vec;\\n        for(int i=0;i<num.size();i++)\\n        {\\n            vec[num[i]-\\'0\\']++;\\n        }\\n        for(int i=0;i<num.size();i++)\\n        {\\n            if(vec[i]!=num[i]-\\'0\\')\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n        map<int,int> vec;\\n        for(int i=0;i<num.size();i++)\\n        {\\n            vec[num[i]-\\'0\\']++;\\n        }\\n        for(int i=0;i<num.size();i++)\\n        {\\n            if(vec[i]!=num[i]-\\'0\\')\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3965992,
                "title": "beats-easy-beginner-friendly-solution-simple-and-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] c= new int[10];\\n        for(int i=0;i<num.length();i++){\\n            int n=num.charAt(i)-\\'0\\';\\n            c[n]++;\\n        }\\n        for(int i=0;i<num.length();i++){\\n            int n=num.charAt(i)-\\'0\\';\\n            c[i]-=n;\\n        }\\n        for(int i=0;i<10;i++){\\n            if(c[i]!=0) return false;\\n        }\\n        return true;\\n    }\\n\\n\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] c= new int[10];\\n        for(int i=0;i<num.length();i++){\\n            int n=num.charAt(i)-\\'0\\';\\n            c[n]++;\\n        }\\n        for(int i=0;i<num.length();i++){\\n            int n=num.charAt(i)-\\'0\\';\\n            c[i]-=n;\\n        }\\n        for(int i=0;i<10;i++){\\n            if(c[i]!=0) return false;\\n        }\\n        return true;\\n    }\\n\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960239,
                "title": "easy-to-read-python-solution-with-explanation-in-comments",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n\\n        #convert the num into a string\\n\\n        strNum = str(num)\\n\\n        #build a freq map of the digits in the num\\n\\n        digitCounter = Counter()\\n\\n        for digit in strNum:\\n            digitCounter[digit] += 1\\n        \\n        #now start parsing thru the number again\\n        # for each index, check if the frequency of the index\\n        # equal the digit at the index\\n\\n        for i in range(0, len(strNum)):\\n            indexStr = str(i) #converting the index into a str so we can look it up in the dict\\n            digitInt = int(strNum[i]) #converting the digit to an Int so we can compare it to indexStr\\'s frequency\\n            if digitCounter[indexStr] != digitInt:\\n                return False\\n        \\n        #if we come out of the loop, this means that all digits met the condition\\n        # so return true\\n\\n        return True\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n\\n        #convert the num into a string\\n\\n        strNum = str(num)\\n\\n        #build a freq map of the digits in the num\\n\\n        digitCounter = Counter()\\n\\n        for digit in strNum:\\n            digitCounter[digit] += 1\\n        \\n        #now start parsing thru the number again\\n        # for each index, check if the frequency of the index\\n        # equal the digit at the index\\n\\n        for i in range(0, len(strNum)):\\n            indexStr = str(i) #converting the index into a str so we can look it up in the dict\\n            digitInt = int(strNum[i]) #converting the digit to an Int so we can compare it to indexStr\\'s frequency\\n            if digitCounter[indexStr] != digitInt:\\n                return False\\n        \\n        #if we come out of the loop, this means that all digits met the condition\\n        # so return true\\n\\n        return True\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960089,
                "title": "easy-approach",
                "content": "\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nbool digitCount(String num) {\\n for (int i = 0; i < num.length; i++) {\\n    int count = 0;\\n\\n    for (int j = 0; j < num.length; j++) {\\n      if (int.parse(num[j]) == i) {\\n        count++;\\n      }\\n    }\\n\\n    if (count != int.parse(num[i])) {\\n      return false;\\n    }\\n  }\\n\\n  return true;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\nbool digitCount(String num) {\\n for (int i = 0; i < num.length; i++) {\\n    int count = 0;\\n\\n    for (int j = 0; j < num.length; j++) {\\n      if (int.parse(num[j]) == i) {\\n        count++;\\n      }\\n    }\\n\\n    if (count != int.parse(num[i])) {\\n      return false;\\n    }\\n  }\\n\\n  return true;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947496,
                "title": "simple-solution-for-beginners-using-arraylist-java",
                "content": "# Intuition\\nBy understanding the problem one thing is clear that the first index is 0 and therefore for a single digit number input output will always be false as a single digit number has a frequency of one and index is 0. I found a way to separate the digit after checking for the above condition and after separating the digits i just checked remaining conditions.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAfter checking the single digit condition, I used logic of reversal of digit to separate the digits and stored the output in an ArrayList. After that I reversed the ArrayList as our digit was reversed it would have given wrong output if not reversed. Now we have the original number ... we will just use two for loops one for index digit and  another for traversing through the arraylist for the occurences. Then after counting the occurences I just compared it with the actual frequency we must have and after repeating this process if at some point occurrences and the given frequency is not equal we return false and breakout of the loop or return true as default value.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nit has a 2ms runtime and code is bit heavy but as a beginner it was easy for me ....I do admit the hashmap makes this stuff easies and char to int conversion methods can also be used but as I was solving i came up with this solution as a beginner.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        Long k = Long.valueOf(num);\\n        return digitCount(k);\\n    }\\n    private boolean digitCount(long numb){\\n        ArrayList<Long> list1 = new ArrayList<Long>();\\n        boolean res = true;\\n        if(numb>=10){\\n        long temp = numb;\\n        while(temp>0){\\n            list1.add(temp%10);\\n            temp=temp/10;\\n        }\\n        Collections.reverse(list1);\\n        for(int i=0;i<list1.size();i++){\\n            int count = 0;\\n            for(int k=0;k<list1.size();k++)\\n            {\\n                if(i==list1.get(k))\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count==list1.get(i))\\n            {\\n                res = true;\\n            }\\n            else\\n            {\\n                res = false;\\n                break;\\n            }\\n        }\\n        }\\n        else\\n        {\\n         res = false;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        Long k = Long.valueOf(num);\\n        return digitCount(k);\\n    }\\n    private boolean digitCount(long numb){\\n        ArrayList<Long> list1 = new ArrayList<Long>();\\n        boolean res = true;\\n        if(numb>=10){\\n        long temp = numb;\\n        while(temp>0){\\n            list1.add(temp%10);\\n            temp=temp/10;\\n        }\\n        Collections.reverse(list1);\\n        for(int i=0;i<list1.size();i++){\\n            int count = 0;\\n            for(int k=0;k<list1.size();k++)\\n            {\\n                if(i==list1.get(k))\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count==list1.get(i))\\n            {\\n                res = true;\\n            }\\n            else\\n            {\\n                res = false;\\n                break;\\n            }\\n        }\\n        }\\n        else\\n        {\\n         res = false;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942507,
                "title": "python-2-lines",
                "content": "# Approach\\nNot the best option as we need to iterate over all **num** in all cases. Without 2 lines we can return False as soon as one condition is False.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        d = Counter(num)\\n        return all(1 if str(d[str(i)]) == num[i] else 0 for i in range(len(num)))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        d = Counter(num)\\n        return all(1 if str(d[str(i)]) == num[i] else 0 for i in range(len(num)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942332,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] digit = new int[10];\\n        for(char c :num.toCharArray()){\\n            digit[c-\\'0\\']++;\\n        }\\n        for(int i=0;i<num.length();i++){\\n            int n = num.charAt(i) - \\'0\\';\\n            if(n!=digit[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] digit = new int[10];\\n        for(char c :num.toCharArray()){\\n            digit[c-\\'0\\']++;\\n        }\\n        for(int i=0;i<num.length();i++){\\n            int n = num.charAt(i) - \\'0\\';\\n            if(n!=digit[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933004,
                "title": "beats-93-85-of-users-with-javascript-easy-javascript-solution-with-line-by-line-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} num\\n * @return {boolean}\\n */\\nvar digitCount = function (num) {\\n\\n    // initialize function checkCount with parameter index\\n    function checkCount(index) {\\n\\n        // initialize count to zero\\n        let count = 0;\\n\\n        // loop through every character of string num\\n        for (let j = 0; j < num.length; j++) {\\n\\n            // if index is equal to every character of string num then increment count\\n            if (index == num[j]) {\\n\\n                count++;\\n            }\\n        }\\n\\n        // return count\\n        return count;\\n    }\\n\\n    // loop through every character of string num\\n    for (let i = 0; i < num.length; i++) {\\n\\n        // invoke the function checkCount with argument index i\\n        let digitCount = checkCount(i);\\n\\n        // if every character of num is not equal to digitCount then return false\\n        if (num[i] != digitCount) {\\n\\n            return false;\\n        }\\n    }\\n\\n    // return true\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} num\\n * @return {boolean}\\n */\\nvar digitCount = function (num) {\\n\\n    // initialize function checkCount with parameter index\\n    function checkCount(index) {\\n\\n        // initialize count to zero\\n        let count = 0;\\n\\n        // loop through every character of string num\\n        for (let j = 0; j < num.length; j++) {\\n\\n            // if index is equal to every character of string num then increment count\\n            if (index == num[j]) {\\n\\n                count++;\\n            }\\n        }\\n\\n        // return count\\n        return count;\\n    }\\n\\n    // loop through every character of string num\\n    for (let i = 0; i < num.length; i++) {\\n\\n        // invoke the function checkCount with argument index i\\n        let digitCount = checkCount(i);\\n\\n        // if every character of num is not equal to digitCount then return false\\n        if (num[i] != digitCount) {\\n\\n            return false;\\n        }\\n    }\\n\\n    // return true\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3932535,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        map<char,int>m;\\n       for(int i=0;i<num.length();i++){\\n         m[num[i]]+=1;\\n       } \\n       for(auto i:m){\\n           \\n           if(num[i.first-\\'0\\']-\\'0\\' != i.second){\\n               return false;\\n           }\\n       }\\n       return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        map<char,int>m;\\n       for(int i=0;i<num.length();i++){\\n         m[num[i]]+=1;\\n       } \\n       for(auto i:m){\\n           \\n           if(num[i.first-\\'0\\']-\\'0\\' != i.second){\\n               return false;\\n           }\\n       }\\n       return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929865,
                "title": "python-easy-for-loop-solution",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def strCount(self, num, i):\\n        return num.count(i)\\n\\n    def digitCount(self, num):\\n        output = \\'\\'\\n        for i in range(len(num)):\\n            total = self.strCount(num, str(i))\\n            output += str(total)\\n        return output == num\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def strCount(self, num, i):\\n        return num.count(i)\\n\\n    def digitCount(self, num):\\n        output = \\'\\'\\n        for i in range(len(num)):\\n            total = self.strCount(num, str(i))\\n            output += str(total)\\n        return output == num\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924050,
                "title": "python3-solution-with-using-hashmap",
                "content": "# Code\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        d = collections.defaultdict(int)\\n\\n        for char in num:\\n            d[int(char)] += 1\\n\\n        for i in range(len(num)):\\n            if d[i] != int(num[i]): return False\\n        \\n        return True\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        d = collections.defaultdict(int)\\n\\n        for char in num:\\n            d[int(char)] += 1\\n\\n        for i in range(len(num)):\\n            if d[i] != int(num[i]): return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923038,
                "title": "digit-count-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        for i in range(len(num)):\\n            if num.count(str(i))!=int(num[i]):\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        for i in range(len(num)):\\n            if num.count(str(i))!=int(num[i]):\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914807,
                "title": "easy-solution-using-java",
                "content": "\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] arr = new int[10];\\n        for(char c:num.toCharArray()){\\n            arr[c - \\'0\\']++;\\n        }\\n        for(int i = 0; i < num.length(); i++){\\n            if(num.charAt(i) - \\'0\\' != arr[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] arr = new int[10];\\n        for(char c:num.toCharArray()){\\n            arr[c - \\'0\\']++;\\n        }\\n        for(int i = 0; i < num.length(); i++){\\n            if(num.charAt(i) - \\'0\\' != arr[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911698,
                "title": "c-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n) ~ O(1) since n can be max 10\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n        int i,j,l=num.length();\\n        int a[10];\\n        memset(a,0,sizeof(a));\\n        bool b = true;\\n        for(i=0;i<l;++i)\\n        {\\n            int c=int(num[i])-48;\\n            a[c]+=1;\\n        }\\n        for(i=0;i<l;++i)\\n        {\\n            if(int(num[i]-48)!=(a[i]))\\n            b=0;\\n        }\\n        return b;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n        int i,j,l=num.length();\\n        int a[10];\\n        memset(a,0,sizeof(a));\\n        bool b = true;\\n        for(i=0;i<l;++i)\\n        {\\n            int c=int(num[i])-48;\\n            a[c]+=1;\\n        }\\n        for(i=0;i<l;++i)\\n        {\\n            if(int(num[i]-48)!=(a[i]))\\n            b=0;\\n        }\\n        return b;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911306,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nlinear 2n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nbool digitCount(char * num){\\n\\n    int *fre = (int*)calloc(4, 10);\\n\\n    for(int i = 0; i < strlen(num); i++){\\n        fre[num[i] -\\'0\\']++;\\n    }\\n    for(int i = 0; i < strlen(num); i++){\\n        if(fre[i] !=num[i] - \\'0\\'){\\n            return false;\\n        }\\n    }\\n\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool digitCount(char * num){\\n\\n    int *fre = (int*)calloc(4, 10);\\n\\n    for(int i = 0; i < strlen(num); i++){\\n        fre[num[i] -\\'0\\']++;\\n    }\\n    for(int i = 0; i < strlen(num); i++){\\n        if(fre[i] !=num[i] - \\'0\\'){\\n            return false;\\n        }\\n    }\\n\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3906374,
                "title": "easy-solution-5-lines",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        c = Counter(num)\\n        for i in range(len(num)):\\n            if int(num[i]) != c[str(i)]:\\n                return False\\n        return True\\n```\\n\\nPlease let me know if any improvements can be made.\\n\\nThanks",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        c = Counter(num)\\n        for i in range(len(num)):\\n            if int(num[i]) != c[str(i)]:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905020,
                "title": "easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        for i in range (len(num)):\\n            if num.count(str(i))!=int(num[i]):\\n                return False\\n        return True        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        for i in range (len(num)):\\n            if num.count(str(i))!=int(num[i]):\\n                return False\\n        return True        \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1792237,
                "content": [
                    {
                        "username": "narasimhakamath",
                        "content": "Umm...what?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The framing of the problem statement makes it a little tricky which is otherwise an easy problem. "
                    },
                    {
                        "username": "eeveeouo",
                        "content": "For sure"
                    },
                    {
                        "username": "arindamsharma0123",
                        "content": "Make separate function to count char in the string and return it in int type. It will give you O(1) time complexity \\nint count(string num,int c){\\n        char ch;\\n        if(c == 0){\\n            ch = \\'0\\';\\n        }\\n        if(c == 1){\\n            ch = \\'1\\';\\n        }\\n        if(c == 2){\\n            ch = \\'2\\';\\n        }\\n        if(c == 3){\\n            ch = \\'3\\';\\n        }\\n        if(c == 4){\\n            ch = \\'4\\';\\n        }\\n        if(c == 5){\\n            ch = \\'5\\';\\n        }\\n        if(c == 6){\\n            ch = \\'6\\';\\n        }\\n        if(c == 7){\\n            ch = \\'7\\';\\n        }\\n        if(c == 8){\\n            ch = \\'8\\';\\n        }\\n        if(c == 9){\\n            ch = \\'9\\';\\n        }\\n        int ans = 0;\\n        for(int i = 0; num[i] != \\'\\\\0\\'; i++){\\n            if(num[i] == ch){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }."
                    },
                    {
                        "username": "Amit17491",
                        "content": " I am facing issue while solve this question.\n\nnum = '0'\ni am printing my ans = 'false'\noutput = true\nexpected = false"
                    }
                ]
            },
            {
                "id": 1845321,
                "content": [
                    {
                        "username": "narasimhakamath",
                        "content": "Umm...what?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The framing of the problem statement makes it a little tricky which is otherwise an easy problem. "
                    },
                    {
                        "username": "eeveeouo",
                        "content": "For sure"
                    },
                    {
                        "username": "arindamsharma0123",
                        "content": "Make separate function to count char in the string and return it in int type. It will give you O(1) time complexity \\nint count(string num,int c){\\n        char ch;\\n        if(c == 0){\\n            ch = \\'0\\';\\n        }\\n        if(c == 1){\\n            ch = \\'1\\';\\n        }\\n        if(c == 2){\\n            ch = \\'2\\';\\n        }\\n        if(c == 3){\\n            ch = \\'3\\';\\n        }\\n        if(c == 4){\\n            ch = \\'4\\';\\n        }\\n        if(c == 5){\\n            ch = \\'5\\';\\n        }\\n        if(c == 6){\\n            ch = \\'6\\';\\n        }\\n        if(c == 7){\\n            ch = \\'7\\';\\n        }\\n        if(c == 8){\\n            ch = \\'8\\';\\n        }\\n        if(c == 9){\\n            ch = \\'9\\';\\n        }\\n        int ans = 0;\\n        for(int i = 0; num[i] != \\'\\\\0\\'; i++){\\n            if(num[i] == ch){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }."
                    },
                    {
                        "username": "Amit17491",
                        "content": " I am facing issue while solve this question.\n\nnum = '0'\ni am printing my ans = 'false'\noutput = true\nexpected = false"
                    }
                ]
            },
            {
                "id": 2046477,
                "content": [
                    {
                        "username": "narasimhakamath",
                        "content": "Umm...what?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The framing of the problem statement makes it a little tricky which is otherwise an easy problem. "
                    },
                    {
                        "username": "eeveeouo",
                        "content": "For sure"
                    },
                    {
                        "username": "arindamsharma0123",
                        "content": "Make separate function to count char in the string and return it in int type. It will give you O(1) time complexity \\nint count(string num,int c){\\n        char ch;\\n        if(c == 0){\\n            ch = \\'0\\';\\n        }\\n        if(c == 1){\\n            ch = \\'1\\';\\n        }\\n        if(c == 2){\\n            ch = \\'2\\';\\n        }\\n        if(c == 3){\\n            ch = \\'3\\';\\n        }\\n        if(c == 4){\\n            ch = \\'4\\';\\n        }\\n        if(c == 5){\\n            ch = \\'5\\';\\n        }\\n        if(c == 6){\\n            ch = \\'6\\';\\n        }\\n        if(c == 7){\\n            ch = \\'7\\';\\n        }\\n        if(c == 8){\\n            ch = \\'8\\';\\n        }\\n        if(c == 9){\\n            ch = \\'9\\';\\n        }\\n        int ans = 0;\\n        for(int i = 0; num[i] != \\'\\\\0\\'; i++){\\n            if(num[i] == ch){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }."
                    },
                    {
                        "username": "Amit17491",
                        "content": " I am facing issue while solve this question.\n\nnum = '0'\ni am printing my ans = 'false'\noutput = true\nexpected = false"
                    }
                ]
            },
            {
                "id": 2009175,
                "content": [
                    {
                        "username": "narasimhakamath",
                        "content": "Umm...what?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The framing of the problem statement makes it a little tricky which is otherwise an easy problem. "
                    },
                    {
                        "username": "eeveeouo",
                        "content": "For sure"
                    },
                    {
                        "username": "arindamsharma0123",
                        "content": "Make separate function to count char in the string and return it in int type. It will give you O(1) time complexity \\nint count(string num,int c){\\n        char ch;\\n        if(c == 0){\\n            ch = \\'0\\';\\n        }\\n        if(c == 1){\\n            ch = \\'1\\';\\n        }\\n        if(c == 2){\\n            ch = \\'2\\';\\n        }\\n        if(c == 3){\\n            ch = \\'3\\';\\n        }\\n        if(c == 4){\\n            ch = \\'4\\';\\n        }\\n        if(c == 5){\\n            ch = \\'5\\';\\n        }\\n        if(c == 6){\\n            ch = \\'6\\';\\n        }\\n        if(c == 7){\\n            ch = \\'7\\';\\n        }\\n        if(c == 8){\\n            ch = \\'8\\';\\n        }\\n        if(c == 9){\\n            ch = \\'9\\';\\n        }\\n        int ans = 0;\\n        for(int i = 0; num[i] != \\'\\\\0\\'; i++){\\n            if(num[i] == ch){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }."
                    },
                    {
                        "username": "Amit17491",
                        "content": " I am facing issue while solve this question.\n\nnum = '0'\ni am printing my ans = 'false'\noutput = true\nexpected = false"
                    }
                ]
            }
        ]
    },
    {
        "title": "Successful Pairs of Spells and Potions",
        "question_content": "<p>You are given two positive integer arrays <code>spells</code> and <code>potions</code>, of length <code>n</code> and <code>m</code> respectively, where <code>spells[i]</code> represents the strength of the <code>i<sup>th</sup></code> spell and <code>potions[j]</code> represents the strength of the <code>j<sup>th</sup></code> potion.</p>\n\n<p>You are also given an integer <code>success</code>. A spell and potion pair is considered <strong>successful</strong> if the <strong>product</strong> of their strengths is <strong>at least</strong> <code>success</code>.</p>\n\n<p>Return <em>an integer array </em><code>pairs</code><em> of length </em><code>n</code><em> where </em><code>pairs[i]</code><em> is the number of <strong>potions</strong> that will form a successful pair with the </em><code>i<sup>th</sup></code><em> spell.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> spells = [5,1,3], potions = [1,2,3,4,5], success = 7\n<strong>Output:</strong> [4,0,3]\n<strong>Explanation:</strong>\n- 0<sup>th</sup> spell: 5 * [1,2,3,4,5] = [5,<u><strong>10</strong></u>,<u><strong>15</strong></u>,<u><strong>20</strong></u>,<u><strong>25</strong></u>]. 4 pairs are successful.\n- 1<sup>st</sup> spell: 1 * [1,2,3,4,5] = [1,2,3,4,5]. 0 pairs are successful.\n- 2<sup>nd</sup> spell: 3 * [1,2,3,4,5] = [3,6,<u><strong>9</strong></u>,<u><strong>12</strong></u>,<u><strong>15</strong></u>]. 3 pairs are successful.\nThus, [4,0,3] is returned.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> spells = [3,1,2], potions = [8,5,8], success = 16\n<strong>Output:</strong> [2,0,2]\n<strong>Explanation:</strong>\n- 0<sup>th</sup> spell: 3 * [8,5,8] = [<u><strong>24</strong></u>,15,<u><strong>24</strong></u>]. 2 pairs are successful.\n- 1<sup>st</sup> spell: 1 * [8,5,8] = [8,5,8]. 0 pairs are successful. \n- 2<sup>nd</sup> spell: 2 * [8,5,8] = [<strong><u>16</u></strong>,10,<u><strong>16</strong></u>]. 2 pairs are successful. \nThus, [2,0,2] is returned.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == spells.length</code></li>\n\t<li><code>m == potions.length</code></li>\n\t<li><code>1 &lt;= n, m &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= spells[i], potions[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= success &lt;= 10<sup>10</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3367914,
                "title": "easy-solutions-in-java-python-and-c-look-at-once-with-exaplanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor each spell, we need to find the number of potions that can form a successful pair with it. A pair is successful if the product of their strengths is at least the given success value. To find the number of successful pairs for each spell, we can iterate through the potions array and check if the product of the spell strength and the potion strength is greater than or equal to the success value. If it is, we can increment a counter for that spell. We can then return the counters as an array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We start by initializing the output array `pairs` with all zeros, and sorting the `potions` array in ascending order.\\n \\n2. For each `spell` in `spells`, we perform a binary search on the `potions` array to find the number of `potions` that form a successful pair with the current `spell`. We maintain two pointers `left` and `right` that initially point to the first and last indices\\nof the `potions` array, respectively.\\n\\n3. We repeat the binary search until the `left` and `right` pointers meet or cross each other. In each iteration, we compute the product of the current `spell` and the middle `potion` using long integer multiplication to avoid integer overflow. If the product is greater than or equal to the `success` threshold, we move the `right` pointer to the left of the middle index. Otherwise, we move the `left` pointer to the right of the middle index.\\n\\n4. Once the binary search is complete, we set the corresponding element of `pairs` to the number of `potions` that come after the `left` pointer in the sorted `potions` array, which are guaranteed to form a successful pair with the current `spell`.\\n\\n5. Finally, we return the `pairs` array as the result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution is $$O(n log m)$$, where n is the length of `spells` and m is the length of `potions`, due to the binary search. The space complexity is O(1).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is $$O(1)$$, since we only use a constant amount of extra memory to store the `pairs` array and the binary search pointers.\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n\\n# Code\\n``` Java []\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length;\\n        int m = potions.length;\\n        int[] pairs = new int[n];\\n        Arrays.sort(potions);\\n        for (int i = 0; i < n; i++) {\\n            int spell = spells[i];\\n            int left = 0;\\n            int right = m - 1;\\n            while (left <= right) {\\n                int mid = left + (right - left) / 2;\\n                long product = (long) spell * potions[mid];\\n                if (product >= success) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n            pairs[i] = m - left;\\n        }\\n        return pairs;\\n    }\\n}\\n\\n```\\n``` Python []\\nclass Solution(object):\\n    def successfulPairs(self, spells, potions, success):\\n        n = len(spells)\\n        m = len(potions)\\n        pairs = [0] * n\\n        potions.sort()\\n        for i in range(n):\\n            spell = spells[i]\\n            left = 0\\n            right = m - 1\\n            while left <= right:\\n                mid = left + (right - left) // 2\\n                product = spell * potions[mid]\\n                if product >= success:\\n                    right = mid - 1\\n                else:\\n                    left = mid + 1\\n            pairs[i] = m - left\\n        return pairs\\n\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int> pairs(n, 0);\\n        sort(potions.begin(), potions.end());\\n        for (int i = 0; i < n; i++) {\\n            int spell = spells[i];\\n            int left = 0;\\n            int right = m - 1;\\n            while (left <= right) {\\n                int mid = left + (right - left) / 2;\\n                long long product = (long long)spell * (long long)potions[mid];\\n                if (product >= success) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n            pairs[i] = m - left;\\n        }\\n        return pairs;\\n    }\\n};\\n\\n```\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n``` Java []\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length;\\n        int m = potions.length;\\n        int[] pairs = new int[n];\\n        Arrays.sort(potions);\\n        for (int i = 0; i < n; i++) {\\n            int spell = spells[i];\\n            int left = 0;\\n            int right = m - 1;\\n            while (left <= right) {\\n                int mid = left + (right - left) / 2;\\n                long product = (long) spell * potions[mid];\\n                if (product >= success) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n            pairs[i] = m - left;\\n        }\\n        return pairs;\\n    }\\n}\\n\\n```\n``` Python []\\nclass Solution(object):\\n    def successfulPairs(self, spells, potions, success):\\n        n = len(spells)\\n        m = len(potions)\\n        pairs = [0] * n\\n        potions.sort()\\n        for i in range(n):\\n            spell = spells[i]\\n            left = 0\\n            right = m - 1\\n            while left <= right:\\n                mid = left + (right - left) // 2\\n                product = spell * potions[mid]\\n                if product >= success:\\n                    right = mid - 1\\n                else:\\n                    left = mid + 1\\n            pairs[i] = m - left\\n        return pairs\\n\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int> pairs(n, 0);\\n        sort(potions.begin(), potions.end());\\n        for (int i = 0; i < n; i++) {\\n            int spell = spells[i];\\n            int left = 0;\\n            int right = m - 1;\\n            while (left <= right) {\\n                int mid = left + (right - left) / 2;\\n                long long product = (long long)spell * (long long)potions[mid];\\n                if (product >= success) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n            pairs[i] = m - left;\\n        }\\n        return pairs;\\n    }\\n};\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138875,
                "title": "javac-python-straignt-forward-with-explantion",
                "content": "# **Explanation**\\nFor each `spell`,\\nit needs ceil integer of `need = success * 1.0 / spell`.\\n\\nBinary search the `index` of first `potion >= need` in the sorted `potions`.\\nThe number of potions that are successful are `potions.length - index`\\n\\nAccumulate the result `res` and finally return it.\\n<br>\\n\\n# **Complexity**\\nTime `O(mlogm + nlogm)`\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\n```java\\n\\tpublic int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\t\\tArrays.sort(potions);\\n\\t\\tTreeMap<Long, Integer> map = new TreeMap<>();\\n        map.put(Long.MAX_VALUE, potions.length);\\n\\t\\tfor (int i = potions.length - 1; i >= 0; i--) {\\n\\t\\t\\tmap.put((long) potions[i], i);\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < spells.length; i++) {\\n            long need = (success + spells[i] - 1) / spells[i];\\n\\t\\t\\tspells[i] = potions.length - map.ceilingEntry(need).getValue();\\n\\t\\t}\\n\\t\\treturn spells;\\n\\t}\\n```\\n**C++**\\n```cpp\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        vector<int> res;\\n        for (int a: spells) {\\n            long need = (success + a - 1) / a;\\n            auto it = lower_bound(potions.begin(), potions.end(), need);\\n            res.push_back(potions.end() - it);\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def successfulPairs(self, spells, potions, success):\\n        potions.sort()\\n        return [len(potions) - bisect_left(potions, (success + a - 1) // a) for a in spells]\\n```\\n<br>\\n\\n# Solution II: Two Sum\\nSort `spells`\\nSort `potions`\\nNow it\\'s basic two sum question, though it\\'s two mulplication.\\n\\nTime `O(nlogn + mlogm)`\\nSpace `O(n)`\\n\\n**Java**\\n```java\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int[] spells0 = spells.clone();\\n        Arrays.sort(potions);\\n        Arrays.sort(spells);\\n        HashMap<Integer, Integer> count = new HashMap<>();\\n        int n = spells.length, m = potions.length, j = m - 1, res[] = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            while (j >= 0 && 1L * spells[i] * potions[j] >= success)\\n                j--;\\n            count.put(spells[i], m - j - 1);\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            res[i] = count.get(spells0[i]);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n\\tpublic int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\t\\tArrays.sort(potions);\\n\\t\\tTreeMap<Long, Integer> map = new TreeMap<>();\\n        map.put(Long.MAX_VALUE, potions.length);\\n\\t\\tfor (int i = potions.length - 1; i >= 0; i--) {\\n\\t\\t\\tmap.put((long) potions[i], i);\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < spells.length; i++) {\\n            long need = (success + spells[i] - 1) / spells[i];\\n\\t\\t\\tspells[i] = potions.length - map.ceilingEntry(need).getValue();\\n\\t\\t}\\n\\t\\treturn spells;\\n\\t}\\n```\n```cpp\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        vector<int> res;\\n        for (int a: spells) {\\n            long need = (success + a - 1) / a;\\n            auto it = lower_bound(potions.begin(), potions.end(), need);\\n            res.push_back(potions.end() - it);\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def successfulPairs(self, spells, potions, success):\\n        potions.sort()\\n        return [len(potions) - bisect_left(potions, (success + a - 1) // a) for a in spells]\\n```\n```java\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int[] spells0 = spells.clone();\\n        Arrays.sort(potions);\\n        Arrays.sort(spells);\\n        HashMap<Integer, Integer> count = new HashMap<>();\\n        int n = spells.length, m = potions.length, j = m - 1, res[] = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            while (j >= 0 && 1L * spells[i] * potions[j] >= success)\\n                j--;\\n            count.put(spells[i], m - j - 1);\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            res[i] = count.get(spells0[i]);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2139028,
                "title": "c-clean-easy",
                "content": "\\u2764 Please Upvote if you find helpful \\u2764\\n\\n**Explanation (Step by Step)**\\n\\n**Step 1.** \\nThe function starts by initializing the vector `v` with `zeros` and then `sorting` the vector `p` in `non-decreasing` order.\\n\\n**Step 2.** \\nFor each element `s[i]` in vector `s`, a `binary search` is performed on vector `p` to find the index of the `largest` element whose product with `s[i]` is `less than eqaul` to `suc`. The binary search is performed by maintaining two indices `l` and `h` representing the lower and upper bounds of the search range, respectively. The search continues until `l` is `less than equal` to `h`.\\n\\n**Step 3** \\nInside the loop, the middle index `mid` is computed as the average of `l` and `h`. If the product of `s[i]` and `p[mid]` is greater than or equal to suc, the upper bound `h` is adjusted to search the `left half` of the array, otherwise the lower bound `l` is adjusted to search the `right half` of the array.\\n\\n**Step 4**\\nAfter the binary search, the number of successful pairs for the element `s[i]` is calculated by `subtracting` the `index of the last element` found in the search from the `size of p`. This is because all elements in `p` starting from this index `satisfy` the condition for a successful pair.\\n\\n**Step 5**\\nFinally, the vector `v` is returned, containing the number of `successful pairs` for each element in `s`. \\n\\n**FAQ** : `Why binary search is used ?` \\n=> By using binary search, the code avoids the need to compare the current element in s with all elements in p, which would have a time complexity of $$O(n\\xB2)$$. Instead, the binary search algorithm efficiently reduces the search space by dividing it in half at each step, resulting in a much faster search time $$O(nlog(n))$$.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& p, long long suc) {\\n        \\n        vector<int> v(s.size(),0);\\n        sort(p.begin(),p.end());\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            int h=p.size()-1;\\n            int l=0;\\n            int mid;\\n            while(l<=h)\\n            {\\n                mid = l + (h-l)/2;\\n                \\n                if((long long int)s[i]*(long long int)p[mid] >= suc)\\n                    h = mid-1;\\n                \\n                else\\n                    l = mid+1;\\n            }\\n            \\n            v[i] = p.size()-1-h;\\n        }\\n        \\n        return v;\\n    }\\n};\\n```\\n![IMG_20230402_115743.jpg](https://assets.leetcode.com/users/images/4d144a01-19ce-4def-8200-2c2ca9987f29_1680416869.6585193.jpeg)\\n  \\u2227,,,\\u2227\\n(  \\u0333\\u2022 \\xB7 \\u2022 \\u0333)\\n/    \\u3065\\u2661\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& p, long long suc) {\\n        \\n        vector<int> v(s.size(),0);\\n        sort(p.begin(),p.end());\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            int h=p.size()-1;\\n            int l=0;\\n            int mid;\\n            while(l<=h)\\n            {\\n                mid = l + (h-l)/2;\\n                \\n                if((long long int)s[i]*(long long int)p[mid] >= suc)\\n                    h = mid-1;\\n                \\n                else\\n                    l = mid+1;\\n            }\\n            \\n            v[i] = p.size()-1-h;\\n        }\\n        \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367922,
                "title": "image-explanation-binary-search-with-without-inbuild-libraries-c-java-python",
                "content": "# Video Solution (`Aryan Mittal`) - Link in LeetCode Profile\\n`Successful Pairs of Spells and Potions` by `Aryan Mittal`\\n![thumb.png](https://assets.leetcode.com/users/images/5857de7f-4a28-4d73-80e0-117e42178bf3_1680402420.5635715.png)\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/99a332e2-1f9b-42b1-9f38-d328ba555a0d_1680397450.5684943.png)\\n![image.png](https://assets.leetcode.com/users/images/95fd5621-491c-49ec-b02a-b7fb09792299_1680397462.2408035.png)\\n![image.png](https://assets.leetcode.com/users/images/5db5d26c-ddce-4df1-8bac-d09eba7231fa_1680397482.1739225.png)\\n![image.png](https://assets.leetcode.com/users/images/e0c85a7d-6300-4e09-99bc-7501984344ef_1680397494.6180933.png)\\n![image.png](https://assets.leetcode.com/users/images/f420160f-7384-4baf-991b-44f7a5b79dfc_1680397503.9567719.png)\\n![image.png](https://assets.leetcode.com/users/images/fb798d7d-2669-44d6-ac56-3af7fc5eec20_1680397511.739848.png)\\n![image.png](https://assets.leetcode.com/users/images/55723900-7dea-43b9-bbf5-8a183d663fd7_1680397521.3559468.png)\\n![image.png](https://assets.leetcode.com/users/images/39a8bc71-7920-4397-a37a-c6fa82d3b416_1680398553.798697.png)\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        vector<int> res;\\n        for (int spell: spells) {\\n            long potion_needed = (success + spell - 1) / spell;\\n            auto it = lower_bound(potions.begin(), potions.end(), potion_needed);\\n            res.push_back(potions.end() - it);\\n        }\\n        return res;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\t\\tArrays.sort(potions);\\n\\t\\tTreeMap<Long, Integer> map = new TreeMap<>();\\n        map.put(Long.MAX_VALUE, potions.length);\\n        \\n\\t\\tfor (int i = potions.length - 1; i >= 0; i--) {\\n\\t\\t\\tmap.put((long) potions[i], i);\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < spells.length; i++) {\\n            long need = (success + spells[i] - 1) / spells[i];\\n\\t\\t\\tspells[i] = potions.length - map.ceilingEntry(need).getValue();\\n\\t\\t}\\n\\t\\treturn spells;\\n\\t}\\n}\\n```\\n```Python []\\nclass Solution:\\n    def successfulPairs(self, spells, potions, success):\\n        sorted_potions = sorted(potions)\\n        result = []\\n        for a in spells:\\n            count = len(sorted_potions) - bisect_left(sorted_potions, (success + a - 1) // a)\\n            result.append(count)\\n        return result\\n```\\n\\n\\n# Code Without Inbuild Libraries\\nExact same [Generalized Binary Search code](https://leetcode.com/problems/binary-search/solutions/3363888/image-explanation-most-generalized-binary-search-cjavapython/) discussed for C++/Java/Python.\\n```C++ []\\nclass Solution {\\npublic:\\n    int valid_pos(vector<int>& potions, long long success, int spell){\\n        long potion_needed = (success + spell - 1) / spell;\\n\\n        int l=0,r=potions.size();\\n        while(l<r){\\n            int mid = l + (r-l)/2;\\n            if(potions[mid] >= potion_needed)\\n                r = mid;\\n            else\\n                l = mid + 1;\\n        }\\n        return l;\\n    }\\n\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        vector<int> res;\\n        for (int spell: spells) {\\n            res.push_back(potions.size()- valid_pos(potions, success, spell));\\n        }\\n        return res;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int valid_pos(int[] potions, long success, int spell) {\\n        long potion_needed = (success + spell - 1) / spell;\\n        int l = 0, r = potions.length;\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (potions[mid] >= potion_needed)\\n                r = mid;\\n            else\\n                l = mid + 1;\\n        }\\n        return l;\\n    }\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int[] res = new int[spells.length];\\n        for (int i = 0; i < spells.length; i++) {\\n            res[i] = potions.length - valid_pos(potions, success, spells[i]);\\n        }\\n        return res;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def valid_pos(self, potions: List[int], success: int, spell: int) -> int:\\n        potion_needed = (success + spell - 1) // spell\\n        l, r = 0, len(potions)\\n        while l < r:\\n            mid = l + (r - l) // 2\\n            if potions[mid] >= potion_needed:\\n                r = mid\\n            else:\\n                l = mid + 1\\n        return l\\n\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        res = []\\n        for spell in spells:\\n            res.append(len(potions) - self.valid_pos(potions, success, spell))\\n        return res\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        vector<int> res;\\n        for (int spell: spells) {\\n            long potion_needed = (success + spell - 1) / spell;\\n            auto it = lower_bound(potions.begin(), potions.end(), potion_needed);\\n            res.push_back(potions.end() - it);\\n        }\\n        return res;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\t\\tArrays.sort(potions);\\n\\t\\tTreeMap<Long, Integer> map = new TreeMap<>();\\n        map.put(Long.MAX_VALUE, potions.length);\\n        \\n\\t\\tfor (int i = potions.length - 1; i >= 0; i--) {\\n\\t\\t\\tmap.put((long) potions[i], i);\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < spells.length; i++) {\\n            long need = (success + spells[i] - 1) / spells[i];\\n\\t\\t\\tspells[i] = potions.length - map.ceilingEntry(need).getValue();\\n\\t\\t}\\n\\t\\treturn spells;\\n\\t}\\n}\\n```\n```Python []\\nclass Solution:\\n    def successfulPairs(self, spells, potions, success):\\n        sorted_potions = sorted(potions)\\n        result = []\\n        for a in spells:\\n            count = len(sorted_potions) - bisect_left(sorted_potions, (success + a - 1) // a)\\n            result.append(count)\\n        return result\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int valid_pos(vector<int>& potions, long long success, int spell){\\n        long potion_needed = (success + spell - 1) / spell;\\n\\n        int l=0,r=potions.size();\\n        while(l<r){\\n            int mid = l + (r-l)/2;\\n            if(potions[mid] >= potion_needed)\\n                r = mid;\\n            else\\n                l = mid + 1;\\n        }\\n        return l;\\n    }\\n\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        vector<int> res;\\n        for (int spell: spells) {\\n            res.push_back(potions.size()- valid_pos(potions, success, spell));\\n        }\\n        return res;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int valid_pos(int[] potions, long success, int spell) {\\n        long potion_needed = (success + spell - 1) / spell;\\n        int l = 0, r = potions.length;\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (potions[mid] >= potion_needed)\\n                r = mid;\\n            else\\n                l = mid + 1;\\n        }\\n        return l;\\n    }\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int[] res = new int[spells.length];\\n        for (int i = 0; i < spells.length; i++) {\\n            res[i] = potions.length - valid_pos(potions, success, spells[i]);\\n        }\\n        return res;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def valid_pos(self, potions: List[int], success: int, spell: int) -> int:\\n        potion_needed = (success + spell - 1) // spell\\n        l, r = 0, len(potions)\\n        while l < r:\\n            mid = l + (r - l) // 2\\n            if potions[mid] >= potion_needed:\\n                r = mid\\n            else:\\n                l = mid + 1\\n        return l\\n\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        res = []\\n        for spell in spells:\\n            res.append(len(potions) - self.valid_pos(potions, success, spell))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367934,
                "title": "why-and-how-binary-search-intuition-explained",
                "content": "![image](https://assets.leetcode.com/users/images/4bde32d2-e235-415d-8602-368016c3acdb_1680397806.4855666.png)\\n![image](https://assets.leetcode.com/users/images/32b4d538-b79a-414b-b799-5195c4622a93_1680398342.075346.png)\\n\\n```\\nclass Solution {\\npublic:\\n    int getPairCount(vector<int>& potions, int& spell, long long& target)\\n    {\\n        int n = potions.size(), bestIdx = n;\\n        int low = 0, high = n - 1;\\n        //=============================================================\\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            long long product = (long long)spell * potions[mid];\\n            \\n            if (product >= target)\\n            {\\n                bestIdx = mid;\\n                high = mid - 1;\\n            }\\n            else low = mid + 1;\\n        }\\n        //================================================================\\n        return (n - bestIdx);\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success)\\n    {\\n        int n = spells.size();\\n        vector<int>ans(n);\\n        sort(potions.begin(), potions.end());\\n        for (int i = 0; i < n; i++) \\n            ans[i] = getPairCount(potions, spells[i], success);\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getPairCount(vector<int>& potions, int& spell, long long& target)\\n    {\\n        int n = potions.size(), bestIdx = n;\\n        int low = 0, high = n - 1;\\n        //=============================================================\\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            long long product = (long long)spell * potions[mid];\\n            \\n            if (product >= target)\\n            {\\n                bestIdx = mid;\\n                high = mid - 1;\\n            }\\n            else low = mid + 1;\\n        }\\n        //================================================================\\n        return (n - bestIdx);\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success)\\n    {\\n        int n = spells.size();\\n        vector<int>ans(n);\\n        sort(potions.begin(), potions.end());\\n        for (int i = 0; i < n; i++) \\n            ans[i] = getPairCount(potions, spells[i], success);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368203,
                "title": "java-easy-solution-with-detailed-explaination-and-similar-problems-binary-search",
                "content": "# Intuition\\nQuestion reduces to finding no of potions for each spell which have \\n***product greater than success*** where product is (each spell * potions[i])\\n\\nNow decision is whether to keep the potions array sorted or not.\\n\\n- ***NON-SORTED*** Another is to traverse entire array of potions and count no of products(spell * potions[i]) greater than success. But this will take more time as for each spell we will need to traverse entire potions array.\\n\\n- ***SORTED*** Immediate thought to reduce time complexity of above case is to keep potions array sorted, then question reduces to finding the first occurrence of the product( each spell * potions[i]) which is greater than success, so we go with ***Binary search***\\n\\n---\\n\\n\\n# Approach\\n1) Sort potions array.\\n2) For every spell we will find min Index where the product( spell * potion[i]) is greater than success\\n3) Once we find such an index via binary search anser for that spell is \\npotions.length - minIndex\\n4) It is ***important*** how we choose left and right pointers of binary search\\n5) I intialised with left = 0, *right = potion.length and not potion.length-1*, since we can have a case where we donot find any minIndex in that case the minIndex will be potion.length and hence result[i] of such spell[i] = potion.length -minIndex = 0\\n\\n**Similar question[ LC 35 Search and Insert](https://leetcode.com/problems/search-insert-position/) to make you understand point 5 better and how to choose boundaries wisely depending on the question type.**\\n\\n***Generic binary search [understanding](https://leetcode.com/problems/binary-search/solutions/3364223/java-easy-solution-explained-why-leftright-left2-instead-of-leftright2/)***\\n\\n\\n---\\n- Time Complexity\\nO(nlogm): where m is the length of potions array and n of spells array\\n\\n***NOTE***: Reason why 1l is done in ***long product = (1l * spell) * potions[mid];*** because (spell * potions[i]) both being integer will overflow and will result in wrong product value. \\nI wasted a lot of time in this.\\n\\n---\\n\\nHope it is easy to understand.\\nLet me know if there is something unclear and i can fix it.\\n\\nOtherwise, please upvote if you like the solution, it would be encouraging\\n\\n![LCUpvote.png](https://assets.leetcode.com/users/images/0cb8949f-630b-4e16-b2c8-2f4e7d2007fb_1680404247.5368462.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int [] result = new int[spells.length];\\n        int potionsLength = potions.length;\\n        Arrays.sort(potions);\\n\\n        for(int i=0; i<spells.length; i++){\\n            int minIndex = binarySearch(potions, success, spells[i]);\\n            result[i] = potionsLength - minIndex;\\n        }\\n        return result;\\n    }\\n\\n    private int binarySearch(int [] potions, long success, int spell){\\n        int left= 0;\\n        int right= potions.length;\\n        \\n        while(left<right){\\n            int mid = left + (right-left)/2;\\n            long product = (1l * spell) * potions[mid];\\n            if(product<success){\\n                left=mid+1;\\n            }else{\\n                right=mid;\\n            }\\n        }\\n\\n        return left;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int [] result = new int[spells.length];\\n        int potionsLength = potions.length;\\n        Arrays.sort(potions);\\n\\n        for(int i=0; i<spells.length; i++){\\n            int minIndex = binarySearch(potions, success, spells[i]);\\n            result[i] = potionsLength - minIndex;\\n        }\\n        return result;\\n    }\\n\\n    private int binarySearch(int [] potions, long success, int spell){\\n        int left= 0;\\n        int right= potions.length;\\n        \\n        while(left<right){\\n            int mid = left + (right-left)/2;\\n            long product = (1l * spell) * potions[mid];\\n            if(product<success){\\n                left=mid+1;\\n            }else{\\n                right=mid;\\n            }\\n        }\\n\\n        return left;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368209,
                "title": "prefix-postfix-sum-c-99-faster-in-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks us to find out the number of potion values that has product with a specific spell value which is greater than (or equal to) a threshold.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince we have to find the amount of values that is greater than a value, the easiest way is to sort the whole array, then do binary search to find out the position that has the smallest element that satisfy the problem. However, since this approach takes `O(nlogn)` times, which might not be the best idea (in my opinion), for the input with size of 10^5, so I got another idea.\\n\\nMy idea was, couting occurences of all numbers, then add from the end, using postfix sum, so that, `postfix[n]` is the number of numbers that has value greater than or equal to value `n` in `potions`. Then, that would take `O(1)`, instead of `O(log n)` for each time do searching for each spell, and `O(n)` for counting, instead of `O(nlogn)` do sorting.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int postfix[100001] = {0};\\n        for(auto potion: potions) postfix[potion]++;\\n        for(int i=99999; i>=0; --i) postfix[i] += postfix[i+1];\\n\\n        //No need extra space at all for storing final result\\n        for(int i=0; i<spells.size(); ++i){\\n            long long val = success / (long long) spells[i];\\n            if(success % (long long) spells[i] != 0) val++;\\n\\n            spells[i] = val <= 1e5 ? postfix[val] : 0;\\n        }\\n        return spells;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int postfix[100001] = {0};\\n        for(auto potion: potions) postfix[potion]++;\\n        for(int i=99999; i>=0; --i) postfix[i] += postfix[i+1];\\n\\n        //No need extra space at all for storing final result\\n        for(int i=0; i<spells.size(); ++i){\\n            long long val = success / (long long) spells[i];\\n            if(success % (long long) spells[i] != 0) val++;\\n\\n            spells[i] = val <= 1e5 ? postfix[val] : 0;\\n        }\\n        return spells;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138867,
                "title": "binary-search",
                "content": "\\n***If ith potion is successful then all the potions after will be successful.\\n    So find the first potion which is successful using Binary Search.***\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        vector<int> res;\\n        int n(size(potions));\\n        sort(begin(potions), end(potions));\\n        \\n        for (auto& spell : spells) {\\n            int start(0), end(n);\\n            while (start < end) {\\n                int mid = start + (end-start)/2;\\n                ((long long)spell*potions[mid] >= success) ? end = mid : start = mid+1;\\n            }\\n            res.push_back(n-start);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        vector<int> res;\\n        int n(size(potions));\\n        sort(begin(potions), end(potions));\\n        \\n        for (auto& spell : spells) {\\n            int start(0), end(n);\\n            while (start < end) {\\n                int mid = start + (end-start)/2;\\n                ((long long)spell*potions[mid] >= success) ? end = mid : start = mid+1;\\n            }\\n            res.push_back(n-start);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370925,
                "title": "python-simple-solution-easy-to-understand",
                "content": "# Please UPVOTE \\uD83D\\uDC4D\\n\\n**!! BIG ANNOUNCEMENT !!**\\nI am currently Giving away my premium content well-structured assignments and study materials to clear interviews at top companies related to computer science and data science to my current Subscribers this week. I planned to give for next 10,000 Subscribers as well. So **DON\\'T FORGET** to Subscribe\\n\\n**Search \\uD83D\\uDC49`Tech Wired leetcode` on YouTube to Subscribe**\\n# OR \\n**Click the Link in my Leetcode Profile to Subscribe**\\n\\n# Video Solution\\n**Search \\uD83D\\uDC49 `Successful Pairs of Spells and Potions by Tech Wired` on YouTube**\\n\\n![Yellow & Black Earn Money YouTube Thumbnail (7).png](https://assets.leetcode.com/users/images/a66c9634-0226-498d-b8b9-b69647afc108_1680441461.1699626.png)\\n\\n\\nHappy Learning, Cheers Guys \\uD83D\\uDE0A\\n\\n# Approach:\\n\\nThe approach for solving the problem is fairly straightforward. We start by sorting the potions list in non-decreasing order. Next, we loop through each spell strength a in the spells list. For each spell, we calculate the minimum strength required for a successful pair by using the formula (success + a - 1) // a. This formula ensures that the result is rounded up to the nearest integer. Once we have the minimum strength required, we use the bisect_left function to find the index of the first potion in the sorted potions list that has strength greater than or equal to the minimum strength required for a successful pair. Finally, we subtract this index from the length of potions to get the number of potions that can form a successful pair for the given spell strength. We repeat this process for each spell strength and store the counts in the result list. Finally, we return the result list.\\n\\n# Intuition:\\n\\nThe problem requires us to find the number of successful pairs of spells and potions. The key to finding a successful pair is to ensure that the strength of the potion is greater than or equal to the minimum strength required for a successful pair for the given spell strength. This minimum strength is calculated by using the formula (success + a - 1) // a, which ensures that the result is rounded up to the nearest integer. Sorting the potions list in non-decreasing order makes it easier to find the right potion for each spell. We use the bisect_left function to find the index of the first potion in the sorted potions list that has strength greater than or equal to the minimum strength required for a successful pair. The difference between the length of potions and this index gives the number of potions that can form a successful pair for the given spell strength. We repeat this process for each spell strength, and the counts are stored in the result list.\\n\\n```\\nclass Solution:\\n    def successfulPairs(self, spells, potions, success):\\n        sorted_potions = sorted(potions)\\n        result = []\\n        for a in spells:\\n            count = len(sorted_potions) - bisect_left(sorted_potions, (success + a - 1) // a)\\n            result.append(count)\\n        return result\\n\\n\\n```\\n![image.png](https://assets.leetcode.com/users/images/e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png)\\n\\n# Please UPVOTE \\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def successfulPairs(self, spells, potions, success):\\n        sorted_potions = sorted(potions)\\n        result = []\\n        for a in spells:\\n            count = len(sorted_potions) - bisect_left(sorted_potions, (success + a - 1) // a)\\n            result.append(count)\\n        return result\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138921,
                "title": "java-python-3-sort-and-binary-search-w-brief-explanation-and-analysis",
                "content": "**Q & A**\\n\\nQ1: Why and how do we need to compute the factor?\\nA1: \\n1) We need a factor from `potions` to multiply with current `spells[i]` in order to get a product at least `success`. Therefore, computing before hand will obtain a key (the factor) for binary search.\\n2) `(success + s) // s = success / s + 1`, which is not ceiling of `success / s`; In contrast, `success / s <= (success + s - 1) // s < success / s + 1`, and therefore `(success + s - 1) // s` is the ceiling. \\n\\nQ2: Why in Python 3 code do we need to compute the ceiling `(success + s - 1) // s`, not `success / s`?\\nA2: For this problem we can use either. ~~~However, if `potions` is a float array then the ceiling way is a must. `success / s` is a float, which has a limited precision. In extreme case it may cause error; Use the ceiling, an int, will guarantee the correctness of the code.~~~\\n\\n~~~e.g., `success = 10, s = 3`, `potions[i] = 3.3333333333...33` (there are `k + 1` 3\\'s) is in `potions`.~~~\\n\\n~~~If we use float `factor = success / s = 10 / 3 = 3.3333333333...3` (there are `k` 3\\'s), then we will miss the correct `potions[i]` in binary search;~~~\\n~~~In contrast, `(success + s - 1) // s = (10 + 3 - 1) // 3 = 4` will guarantee to obtain correct result.~~~\\n\\n**End of Q & A**\\n\\n----\\n\\n1. Sort `potions` for binary search;\\n2. Traverse `spells`, for each element `s`, compute the ceiling of the quotient of `success / s`, `(success + s - 1) / s`;\\n3. Binary search the corresponding ceiling of each quotient in 2. to find out how many pairs with a product at least `success`.\\n\\n```java\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int[] pairs = new int[spells.length];\\n        for (int i = 0; i < spells.length; ++i) {\\n            if ((success + spells[i] - 1) / spells[i] > 100_000) { // boundary check to avoid int overflow.\\n                int s = spells[i], factor = (int)((success + s - 1) / s);\\n                pairs[i] = potions.length - binarySearch(potions, factor);\\n            } \\n        }\\n        return pairs;\\n    }\\n    private int binarySearch(int[] potions, int key) {\\n        int lo = 0, hi = potions.length; \\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (potions[mid] < key) {\\n                lo = mid + 1;\\n            }else {\\n                hi = mid;\\n            } \\n        }\\n        return lo;\\n    }\\n```\\nWe can modify signature of `binarySearch(int[], int)` to `binarySearch(int[], long)` to avoid int overflow problem.\\n```java\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int[] pairs = new int[spells.length];\\n        for (int i = 0; i < spells.length; ++i) {\\n            long factor = (success + spells[i] - 1) / spells[i];\\n            pairs[i] = potions.length - binarySearch(potions, factor);\\n        }\\n        return pairs;\\n    }\\n    private int binarySearch(int[] potions, long key) {\\n        int lo = 0, hi = potions.length; \\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (potions[mid] < key) {\\n                lo = mid + 1;\\n            }else {\\n                hi = mid;\\n            } \\n        }\\n        return lo;\\n    }\\n```\\n\\n```python\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        pairs = []\\n        for s in spells:\\n            factor = (success + s - 1) // s\\n            pairs.append(len(potions) - bisect.bisect_left(potions, factor))\\n        return pairs\\n```\\n\\nFor Python 3 code, we can use `success / s` as key for binary search:\\n\\n```python\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        return [len(potions) - bisect.bisect_left(potions, success / s) for s in spells]\\n```\\n\\n**Analysis:**\\n\\nTime: `O((m + n)logm)`, space: `O(n + m)` - including sorting space, where `n = spells.length, m = potions.length`.",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```java\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int[] pairs = new int[spells.length];\\n        for (int i = 0; i < spells.length; ++i) {\\n            if ((success + spells[i] - 1) / spells[i] > 100_000) { // boundary check to avoid int overflow.\\n                int s = spells[i], factor = (int)((success + s - 1) / s);\\n                pairs[i] = potions.length - binarySearch(potions, factor);\\n            } \\n        }\\n        return pairs;\\n    }\\n    private int binarySearch(int[] potions, int key) {\\n        int lo = 0, hi = potions.length; \\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (potions[mid] < key) {\\n                lo = mid + 1;\\n            }else {\\n                hi = mid;\\n            } \\n        }\\n        return lo;\\n    }\\n```\n```java\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int[] pairs = new int[spells.length];\\n        for (int i = 0; i < spells.length; ++i) {\\n            long factor = (success + spells[i] - 1) / spells[i];\\n            pairs[i] = potions.length - binarySearch(potions, factor);\\n        }\\n        return pairs;\\n    }\\n    private int binarySearch(int[] potions, long key) {\\n        int lo = 0, hi = potions.length; \\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (potions[mid] < key) {\\n                lo = mid + 1;\\n            }else {\\n                hi = mid;\\n            } \\n        }\\n        return lo;\\n    }\\n```\n```python\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        pairs = []\\n        for s in spells:\\n            factor = (success + s - 1) // s\\n            pairs.append(len(potions) - bisect.bisect_left(potions, factor))\\n        return pairs\\n```\n```python\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        return [len(potions) - bisect.bisect_left(potions, success / s) for s in spells]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2139342,
                "title": "binary-search-vs-two-pointers",
                "content": "In the first approach, we sort `potions`, and use binary search to find the position of the weakest potion that produces a success. All potions to the right would work also.\\n\\nIn the second approach, we sort both `potions` and `spells` (we actually sort indexes `idx` to preserve the order of spells). Then, we use two pointers to track the weakest  `potions[j]` that works for `spells[i]`. Since we process spells from weakest to the strongest, pointer `j` is moved in one direction - from strongest to weakest.\\n\\n#### Binary Search\\n**C++**\\n```cpp\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n    sort(begin(potions), end(potions));\\n    for (int i = 0; i < spells.size(); ++i) {\\n        long long comp = (success + spells[i] - 1) / spells[i];\\n        spells[i] = potions.size() - (lower_bound(begin(potions), end(potions), comp) - begin(potions));\\n    }\\n    return spells;\\n}\\n```\\n#### Two Pointers\\n**C++**\\n```cpp\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n    vector<int> idx(spells.size());\\n    iota(begin(idx), end(idx), 0);\\n    sort(begin(potions), end(potions), greater<int>());\\n    sort(begin(idx), end(idx), [&](int i, int j){ return spells[i] < spells[j]; });\\n    for (int i = 0, j = 0; i < idx.size(); ++i) {\\n        while (j < potions.size() && (long long)potions[j] * spells[idx[i]] >= success)\\n            ++j;\\n        spells[idx[i]] = j;\\n    }\\n    return spells;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n    sort(begin(potions), end(potions));\\n    for (int i = 0; i < spells.size(); ++i) {\\n        long long comp = (success + spells[i] - 1) / spells[i];\\n        spells[i] = potions.size() - (lower_bound(begin(potions), end(potions), comp) - begin(potions));\\n    }\\n    return spells;\\n}\\n```\n```cpp\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n    vector<int> idx(spells.size());\\n    iota(begin(idx), end(idx), 0);\\n    sort(begin(potions), end(potions), greater<int>());\\n    sort(begin(idx), end(idx), [&](int i, int j){ return spells[i] < spells[j]; });\\n    for (int i = 0, j = 0; i < idx.size(); ++i) {\\n        while (j < potions.size() && (long long)potions[j] * spells[idx[i]] >= success)\\n            ++j;\\n        spells[idx[i]] = j;\\n    }\\n    return spells;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3369048,
                "title": "java-sorting-binary-search-approach",
                "content": "```\\n// Approach 2: Sorting  + Binary Search (Lower Bound)\\n\\n// Time complexity: O((m + n) log m)\\n// Space complexity: O(log m)\\n\\npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\tint n = spells.length;\\n\\tint m = potions.length;\\n\\tint[] pairs = new int[n];\\n\\n\\tArrays.sort(potions); // m log m\\n\\n\\tfor (int i = 0; i < n; i++) { // n log m\\n\\t\\tint left = 0, right = m;\\n\\n\\t\\twhile (left < right) {\\n\\t\\t\\tint mid = left + (right - left) / 2;\\n\\n\\t\\t\\tif ((long) spells[i] * (long) potions[mid] >= success)\\n\\t\\t\\t\\tright = mid;\\n\\t\\t\\telse\\n\\t\\t\\t\\tleft = mid + 1;\\n\\t\\t}\\n\\n\\t\\tpairs[i] = m - left;\\n\\t}\\n\\n\\treturn pairs;\\n}\\n```\\n\\n**Please upvote if you find this solution useful. Happy Coding!**",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\n// Approach 2: Sorting  + Binary Search (Lower Bound)\\n\\n// Time complexity: O((m + n) log m)\\n// Space complexity: O(log m)\\n\\npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\tint n = spells.length;\\n\\tint m = potions.length;\\n\\tint[] pairs = new int[n];\\n\\n\\tArrays.sort(potions); // m log m\\n\\n\\tfor (int i = 0; i < n; i++) { // n log m\\n\\t\\tint left = 0, right = m;\\n\\n\\t\\twhile (left < right) {\\n\\t\\t\\tint mid = left + (right - left) / 2;\\n\\n\\t\\t\\tif ((long) spells[i] * (long) potions[mid] >= success)\\n\\t\\t\\t\\tright = mid;\\n\\t\\t\\telse\\n\\t\\t\\t\\tleft = mid + 1;\\n\\t\\t}\\n\\n\\t\\tpairs[i] = m - left;\\n\\t}\\n\\n\\treturn pairs;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3368113,
                "title": "c-beginner-friendly-explanation-brute-force-to-optimized-intuition",
                "content": "# Brute Force [Time Limit Exceeded]\\n\\n## Intuition\\nInitially, it sounds like we can just multiply each `spell` for each `potion`, but this is not fast enough.\\n\\n## Algorithm Design\\n- Loop for each `spell`\\n   - Loop for each `potion`\\n       - Increase count if the product is $$>=$$ `success`\\n\\n## Code\\n```cpp\\nclass Solution {\\npublic:\\n    // T:O(n*m), S:O(1)\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> numPairs(spells.size(), 0);\\n\\n        // Loop through all spells\\n        for(int i = 0; i < spells.size(); i++) { // O(n)\\n            int spell = spells[i];\\n            int count = 0;\\n\\n            // Loop through all potions for each spell\\n            for(int potion: potions) { // O(m)\\n\\n                // Increment count if it exceeds success\\n                long long pair = (long long)potion * (long long)spell;\\n                if(pair >= success) count++;\\n            }\\n            numPairs[i] = count;\\n        }\\n\\n        return numPairs;\\n    }\\n};\\n```\\n\\n## Complexity\\nLet\\'s define `m` as the length of `spells` and `n` as the length of `potions`.\\n\\n- Time Complexity: $$O(n*m)$$\\n- Space Complexity: $$O(1)$$\\n  - The resulting array is not considered as space.\\n\\n# Binary Search [Accepted]\\n\\n## Intuition\\nTo reduce search time, we can almost always use binary search. However, the prequisite is sorting. Here, we only need to sort `potions` and find the minimum potion needed to be $$>=$$ `success`.\\n\\n## Algorithm Design\\n- Sort potions\\n- Loop for each `spell`\\n    - Find index of the minimum potion needed\\n    - Calculate the distance since every greater idx is $$>=$$ `success`\\n\\n## Code\\n```cpp\\nclass Solution {\\npublic:\\n    // T:O(m log m + n log m), S:O(log m)\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> numPairs(spells.size(), 0);\\n\\n        // Sort potions\\n        sort(potions.begin(), potions.end()); // O(m log m)\\n\\n        // Loop through all spells\\n        for(int i = 0; i < spells.size(); i++) { // O(n)\\n            // Find the minimum potion needed for success\\n            long long potionNeeded = ceil(static_cast<double>(success) / spells[i]);\\n\\n            // Find the smallest idx position\\n            auto it = lower_bound(potions.begin(), potions.end(), potionNeeded); // O(log m)\\n            int idx = it - potions.begin();\\n\\n            // Calculate count based on the index\\n            int numPair = potions.size() - (it - potions.begin());\\n            numPairs[i] = max(0, numPair);\\n        }\\n\\n        return numPairs;\\n    }\\n};\\n```\\n\\n## Complexity\\nLet\\'s define `m` as the length of `spells` and `n` as the length of `potions`.\\n\\n- Time Complexity: $$O((m + n)log m)$$\\n- Space Complexity: $$O(log m)$$\\n    - Sorting in C++ takes $$O(log m)$$ space.\\n    - The resulting array is not considered as space.\\n    \\n# Two Pointers [Accepted]\\n\\n## Intuition\\nSince a larger number will always be able to form products $$>=$$ `success` compared to a smaller number, we can use a greedy two pointer approach. \\n\\n#### For example:\\nspells: [1,2,3]\\npotions: [1,2]\\nsuccess: 4\\n\\nIf we take the leftmost `spell` (1) and multiply with rightmost `potion` (2), we get a product of 2. This means any potion of a smaller index will not be possible. If we are able to form a product $$>=$$ `success`, that means any greater `spell` number can form it too.\\n\\n## Algorithm Design\\n- Remember the index of `spells` since we will be sorting\\n- Sort `potions` and `spells`\\n- Initialize two pointers:\\n    - Leftmost of `spells`\\n    - Rightmost of `potions`\\n- While we can form product $$>=$$ `success`, we should decrement `potion` pointer. \\n\\n## Code\\n```cpp\\nclass Solution {\\npublic:\\n    // T:O(n log n + m log m), S:O(n + log m)\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        unordered_map<int, pair<int, int>> pairsMap; // {spells[i], {idx, numPair}}\\n\\n        // Copy spells into numPairs\\n        vector<int> numPairs(spells); // O(n)\\n        \\n        // Add each number into the map\\n        for(int i = 0; i < spells.size(); i++) { // O(n)\\n            pairsMap[spells[i]] = {i, -1};\\n        }\\n\\n        // Sort both spells and potion\\n        sort(spells.begin(), spells.end()); // O(n log n)\\n        sort(potions.begin(), potions.end()); // O(m log m)\\n\\n        // Two pointer approach\\n        // Spell pointer starts from the left\\n        // Potion pointer starts from the right\\n        int potionPtr = potions.size() - 1;\\n        for(int i = 0; i < spells.size(); i++) { // O(m)\\n            int spell = spells[i];\\n            while(potionPtr >= 0 && (long long) spell * potions[potionPtr] >= success) {\\n                potionPtr--;\\n            }\\n            pairsMap[spell] = {pairsMap[spell].first, potions.size() - 1 - potionPtr};\\n        }\\n\\n        // Put data into vector\\n        int idx = 0;\\n        for(int spell: numPairs) { // O(n)\\n            numPairs[idx++] = pairsMap[spell].second;\\n        }\\n\\n        return numPairs;\\n    }\\n};\\n```\\n\\n## Complexity\\nLet\\'s define `m` as the length of `spells` and `n` as the length of `potions`.\\n\\n- Time Complexity: $$O(n log n + m log m)$$\\n- Space Complexity: $$O(n + log m)$$\\n    - Sorting in C++ takes $$O(log n)$$ space.\\n    - The resulting array is not considered as space.",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    // T:O(n*m), S:O(1)\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> numPairs(spells.size(), 0);\\n\\n        // Loop through all spells\\n        for(int i = 0; i < spells.size(); i++) { // O(n)\\n            int spell = spells[i];\\n            int count = 0;\\n\\n            // Loop through all potions for each spell\\n            for(int potion: potions) { // O(m)\\n\\n                // Increment count if it exceeds success\\n                long long pair = (long long)potion * (long long)spell;\\n                if(pair >= success) count++;\\n            }\\n            numPairs[i] = count;\\n        }\\n\\n        return numPairs;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    // T:O(m log m + n log m), S:O(log m)\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> numPairs(spells.size(), 0);\\n\\n        // Sort potions\\n        sort(potions.begin(), potions.end()); // O(m log m)\\n\\n        // Loop through all spells\\n        for(int i = 0; i < spells.size(); i++) { // O(n)\\n            // Find the minimum potion needed for success\\n            long long potionNeeded = ceil(static_cast<double>(success) / spells[i]);\\n\\n            // Find the smallest idx position\\n            auto it = lower_bound(potions.begin(), potions.end(), potionNeeded); // O(log m)\\n            int idx = it - potions.begin();\\n\\n            // Calculate count based on the index\\n            int numPair = potions.size() - (it - potions.begin());\\n            numPairs[i] = max(0, numPair);\\n        }\\n\\n        return numPairs;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    // T:O(n log n + m log m), S:O(n + log m)\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        unordered_map<int, pair<int, int>> pairsMap; // {spells[i], {idx, numPair}}\\n\\n        // Copy spells into numPairs\\n        vector<int> numPairs(spells); // O(n)\\n        \\n        // Add each number into the map\\n        for(int i = 0; i < spells.size(); i++) { // O(n)\\n            pairsMap[spells[i]] = {i, -1};\\n        }\\n\\n        // Sort both spells and potion\\n        sort(spells.begin(), spells.end()); // O(n log n)\\n        sort(potions.begin(), potions.end()); // O(m log m)\\n\\n        // Two pointer approach\\n        // Spell pointer starts from the left\\n        // Potion pointer starts from the right\\n        int potionPtr = potions.size() - 1;\\n        for(int i = 0; i < spells.size(); i++) { // O(m)\\n            int spell = spells[i];\\n            while(potionPtr >= 0 && (long long) spell * potions[potionPtr] >= success) {\\n                potionPtr--;\\n            }\\n            pairsMap[spell] = {pairsMap[spell].first, potions.size() - 1 - potionPtr};\\n        }\\n\\n        // Put data into vector\\n        int idx = 0;\\n        for(int spell: numPairs) { // O(n)\\n            numPairs[idx++] = pairsMap[spell].second;\\n        }\\n\\n        return numPairs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369016,
                "title": "linear-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Find maximum Spell power.\\n2. Create an array `counts` of length `max spell power` filled with zeros.\\n3. For each potion calculate minimum required spell. If required spell <= maximum spell power, increment counts of required Spell.\\n4. Update `counts` , so `counts[i] = sum(counts[0]...counts[i])`. So `counts` now contains total number of \"good\" potions.\\n5. Fill the results, so `results[i] = counts[spells[i]]`. To save some space, we can use spells as results.\\n\\n# Complexity\\n- Time complexity: O(n + m + k)\\n    spells.size() = n\\n    potions.size() = m\\n    max spells power = k\\n\\n    It can be optimized a little bit. `k` could be `max spells power` - `min spells power`\\n\\n- Space complexity: O(k)\\n  We only use additional space for `counts` array. If we consider `results` as additional space, then O(k+n).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int maxSpell = 0;\\n        for(int i=0; i<spells.size(); ++i){  //O(n)\\n            maxSpell = max(maxSpell, spells[i]);\\n        }\\n        vector<int> counts(maxSpell+1, 0);\\n\\n        for(int i=0; i<potions.size(); ++i){ //O(m)\\n            auto index = (success+potions[i]-1)/potions[i]; //minimum required spell power\\n            if(index<counts.size()) counts[index]++;\\n        }\\n\\n        for(int i=1; i<counts.size(); ++i){ //O(k)\\n            counts[i] +=counts[i-1];\\n        }\\n\\n        vector<int> result(spells.size(), 0);\\n        for(int i=0; i<spells.size(); ++i){ //O(n)\\n            result[i] = counts[spells[i]];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int maxSpell = 0;\\n        for(int i=0; i<spells.size(); ++i){  //O(n)\\n            maxSpell = max(maxSpell, spells[i]);\\n        }\\n        vector<int> counts(maxSpell+1, 0);\\n\\n        for(int i=0; i<potions.size(); ++i){ //O(m)\\n            auto index = (success+potions[i]-1)/potions[i]; //minimum required spell power\\n            if(index<counts.size()) counts[index]++;\\n        }\\n\\n        for(int i=1; i<counts.size(); ++i){ //O(k)\\n            counts[i] +=counts[i-1];\\n        }\\n\\n        vector<int> result(spells.size(), 0);\\n        for(int i=0; i<spells.size(); ++i){ //O(n)\\n            result[i] = counts[spells[i]];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367908,
                "title": "day-92-binary-search-easiest-beginner-friendly-sol",
                "content": "**NOTE - PLEASE READ INTUITION AND APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n \\n**NOTE 2 - I WILL HIGHLY RECOMMEND YOU GUYS BEFORE SOLVING THIS PROBLEM PLEASE SOLVE BINARY SEARCH PROBLEM.**\\n\\n**704. Binary Search Problem -** https://leetcode.com/problems/binary-search/\\n**704. Binary Search Solution -** https://leetcode.com/problems/binary-search/solutions/3364016/day-91-binary-search-o-logn-time-easiest-beginner-friendly-sol/\\n\\n# Intuition of this Problem :\\n*The problem is asking to find the number of successful pairings between the spells and potions arrays such that the product of their strengths is at least a given integer \"success\".*\\n\\n***To solve this problem, we can iterate through each spell and for each spell, we can find the index of the first potion whose strength is at least \"success\". This can be done using binary search since the potions array is sorted. Once we have the index, the number of successful pairings can be calculated by subtracting the index from the total number of potions. We can repeat this process for each spell and store the number of successful pairings in an array.***\\n\\n*Finally, we return the array containing the number of successful pairings for each spell.*\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach for this Problem :\\n1. Define a function binarySearch which takes the input integer spell, a vector of integers potions, and a long integer success and returns an integer value.\\n2. Initialize the integer startIndex to 0, lastIndex to potions.size() - 1, and ansIndex to -1.\\n3. Run a while loop until startIndex is less than or equal to lastIndex.\\n4. Within the loop, calculate the midIndex using (startIndex + (lastIndex - startIndex) / 2) to avoid integer overflow.\\n5. If the product of spell and the midIndex element of potions is greater than or equal to success, then set ansIndex to midIndex and update lastIndex to midIndex - 1.\\n6. Else, update startIndex to midIndex + 1.\\n7. Return ansIndex.\\n8. Initialize an integer m to the size of the potions vector and create an empty vector ans.\\n9. Sort the potions vector in ascending order using sort.\\n10. Iterate through each element spell in the spells vector.\\n11. Initialize an integer countPair to 0.\\n12. Call the binarySearch function with spell, potions, and success as arguments and store the result in the index variable.\\n13. If index is equal to -1, then add 0 to countPair, else add m - index to countPair.\\n14. Append countPair to ans.\\n15. Return ans.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code :\\n```C++ []\\n//1st Approach\\n\\nclass Solution {\\npublic:\\n    int binarySearch(int spell, vector<int>& potions, long long success) {\\n        int startIndex = 0; \\n        int lastIndex = potions.size() - 1;\\n        int ansIndex = -1;\\n        while(startIndex <= lastIndex){\\n            //helps to prevent from out of bound\\n            int midIndex = (startIndex + (lastIndex - startIndex) / 2);\\n            if ((long long) spell * potions[midIndex] >= success){\\n                ansIndex = midIndex;\\n                lastIndex = midIndex - 1;\\n            }\\n            else{\\n                startIndex = midIndex + 1;\\n            }\\n        }\\n        return ansIndex;   \\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        int m = potions.size();\\n        vector<int> ans;\\n        for (int spell : spells) {\\n            int countPair = 0;\\n            int index = binarySearch(spell, potions, success);\\n            if (index == -1) \\n                countPair += 0;\\n            else\\n                countPair += (m - index);\\n            ans.push_back(countPair);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```C++ []\\n//2nd Approach\\n\\nclass Solution {\\npublic:\\n    int binarySearch(int spell, vector<int>& potions, long long success) {\\n        int startIndex = 0; \\n        int lastIndex = potions.size() - 1;\\n        while(startIndex <= lastIndex){\\n            //helps to prevent from out of bound\\n            int midIndex = (startIndex + (lastIndex - startIndex) / 2);\\n            if ((long long) spell * potions[midIndex] >= success){\\n                lastIndex = midIndex - 1;\\n            }\\n            else{\\n                startIndex = midIndex + 1;\\n            }\\n        }\\n        return lastIndex + 1;   \\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        int m = potions.size();\\n        vector<int> ans;\\n        for (int spell : spells) {\\n            int index = binarySearch(spell, potions, success);\\n            ans.push_back(m - index);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int binarySearch(int spell, int[] potions, long success) {\\n        int startIndex = 0; \\n        int lastIndex = potions.length - 1;\\n        int ansIndex = -1;\\n        while(startIndex <= lastIndex){\\n            int midIndex = (startIndex + (lastIndex - startIndex) / 2);\\n            if ((long) spell * potions[midIndex] >= success){\\n                ansIndex = midIndex;\\n                lastIndex = midIndex - 1;\\n            }\\n            else{\\n                startIndex = midIndex + 1;\\n            }\\n        }\\n        return ansIndex;   \\n    }\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int m = potions.length;\\n        int[] ans = new int[spells.length];\\n        for (int i = 0; i < spells.length; i++) {\\n            int countPair = 0;\\n            int index = binarySearch(spells[i], potions, success);\\n            if (index == -1) \\n                countPair += 0;\\n            else\\n                countPair += (m - index);\\n            ans[i] = countPair;\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def binarySearch(self, spell: int, potions: List[int], success: int) -> int:\\n        startIndex = 0\\n        lastIndex = len(potions) - 1\\n        ansIndex = -1\\n        while startIndex <= lastIndex:\\n            midIndex = (startIndex + (lastIndex - startIndex) // 2)\\n            if spell * potions[midIndex] >= success:\\n                ansIndex = midIndex\\n                lastIndex = midIndex - 1\\n            else:\\n                startIndex = midIndex + 1\\n        return ansIndex\\n    \\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        m = len(potions)\\n        ans = []\\n        for spell in spells:\\n            countPair = 0\\n            index = self.binarySearch(spell, potions, success)\\n            if index == -1:\\n                countPair += 0\\n            else:\\n                countPair += (m - index)\\n            ans.append(countPair)\\n        return ans\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- **Time Complexity :** **O((n + m) log m)**, where n is the length of the spells vector and m is the length of the potions vector.\\n\\n*The sort function takes O(m log m) time where \\'m\\' is the size of the potions vector.\\nFor each spell, the binarySearch function is called which takes O(log m) time.\\nTherefore, the time complexity of the entire solution is O(n log m + m log m), where \\'n\\' is the size of the spells vector.*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space Complexity :** **O(m + n)**, since we need to store the result in the ans vector.\\n\\n*The space complexity of the solution is O(m) to store the sorted potions vector, and O(n) to store the output vector of size \\'n\\'.\\nTherefore, the total space complexity of the solution is O(m + n).*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```C++ []\\n//1st Approach\\n\\nclass Solution {\\npublic:\\n    int binarySearch(int spell, vector<int>& potions, long long success) {\\n        int startIndex = 0; \\n        int lastIndex = potions.size() - 1;\\n        int ansIndex = -1;\\n        while(startIndex <= lastIndex){\\n            //helps to prevent from out of bound\\n            int midIndex = (startIndex + (lastIndex - startIndex) / 2);\\n            if ((long long) spell * potions[midIndex] >= success){\\n                ansIndex = midIndex;\\n                lastIndex = midIndex - 1;\\n            }\\n            else{\\n                startIndex = midIndex + 1;\\n            }\\n        }\\n        return ansIndex;   \\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        int m = potions.size();\\n        vector<int> ans;\\n        for (int spell : spells) {\\n            int countPair = 0;\\n            int index = binarySearch(spell, potions, success);\\n            if (index == -1) \\n                countPair += 0;\\n            else\\n                countPair += (m - index);\\n            ans.push_back(countPair);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```C++ []\\n//2nd Approach\\n\\nclass Solution {\\npublic:\\n    int binarySearch(int spell, vector<int>& potions, long long success) {\\n        int startIndex = 0; \\n        int lastIndex = potions.size() - 1;\\n        while(startIndex <= lastIndex){\\n            //helps to prevent from out of bound\\n            int midIndex = (startIndex + (lastIndex - startIndex) / 2);\\n            if ((long long) spell * potions[midIndex] >= success){\\n                lastIndex = midIndex - 1;\\n            }\\n            else{\\n                startIndex = midIndex + 1;\\n            }\\n        }\\n        return lastIndex + 1;   \\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        int m = potions.size();\\n        vector<int> ans;\\n        for (int spell : spells) {\\n            int index = binarySearch(spell, potions, success);\\n            ans.push_back(m - index);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int binarySearch(int spell, int[] potions, long success) {\\n        int startIndex = 0; \\n        int lastIndex = potions.length - 1;\\n        int ansIndex = -1;\\n        while(startIndex <= lastIndex){\\n            int midIndex = (startIndex + (lastIndex - startIndex) / 2);\\n            if ((long) spell * potions[midIndex] >= success){\\n                ansIndex = midIndex;\\n                lastIndex = midIndex - 1;\\n            }\\n            else{\\n                startIndex = midIndex + 1;\\n            }\\n        }\\n        return ansIndex;   \\n    }\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int m = potions.length;\\n        int[] ans = new int[spells.length];\\n        for (int i = 0; i < spells.length; i++) {\\n            int countPair = 0;\\n            int index = binarySearch(spells[i], potions, success);\\n            if (index == -1) \\n                countPair += 0;\\n            else\\n                countPair += (m - index);\\n            ans[i] = countPair;\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def binarySearch(self, spell: int, potions: List[int], success: int) -> int:\\n        startIndex = 0\\n        lastIndex = len(potions) - 1\\n        ansIndex = -1\\n        while startIndex <= lastIndex:\\n            midIndex = (startIndex + (lastIndex - startIndex) // 2)\\n            if spell * potions[midIndex] >= success:\\n                ansIndex = midIndex\\n                lastIndex = midIndex - 1\\n            else:\\n                startIndex = midIndex + 1\\n        return ansIndex\\n    \\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        m = len(potions)\\n        ans = []\\n        for spell in spells:\\n            countPair = 0\\n            index = self.binarySearch(spell, potions, success)\\n            if index == -1:\\n                countPair += 0\\n            else:\\n                countPair += (m - index)\\n            ans.append(countPair)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370613,
                "title": "simple-c-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- the approach that is used here is `binary search`.\\n- So first we `sort` the potions.\\n- then we traverse through `every element in spell` and multiply it to the potions.\\n- and because our potions is `sorted` we can apply binary search now.\\n- so by doing that we can get the minimum element in `potions` which has multiplication `>=` to our success.\\n- when we get that element then every element from its right or is bigger than that element is gonna pass.\\n- so we push the `total size of potions - index of minimum success element`.\\n- after doing it for all the elements in `spells`, we return the answer\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: `O(nlog(n+m))` #correct me if i\\'m wrong cause not sure perfectly :)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n`Upvote ! It just takes 1 click :)`\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> ans;\\n        int n= spells.size();\\n        int m = potions.size();\\n        sort(potions.begin(), potions.end());\\n        for (int i=0;i<n;i++){\\n            int spell = spells[i];\\n            int start = 0;\\n            int end = m-1;\\n            while(start<=end){\\n                int mid = start + (end-start)/2;\\n                long long product = (long) spell * potions[mid];\\n                if(product>=success){\\n                    end = mid-1;\\n                } \\n                else{\\n                    start = mid+1;\\n                }\\n            }\\n            ans.push_back(m-start);\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n![Upvote.jpeg](https://assets.leetcode.com/users/images/1b85f3f9-1fb4-466e-8a35-8dd5e22e1a9f_1680437696.0481274.jpeg)",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> ans;\\n        int n= spells.size();\\n        int m = potions.size();\\n        sort(potions.begin(), potions.end());\\n        for (int i=0;i<n;i++){\\n            int spell = spells[i];\\n            int start = 0;\\n            int end = m-1;\\n            while(start<=end){\\n                int mid = start + (end-start)/2;\\n                long long product = (long) spell * potions[mid];\\n                if(product>=success){\\n                    end = mid-1;\\n                } \\n                else{\\n                    start = mid+1;\\n                }\\n            }\\n            ans.push_back(m-start);\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138901,
                "title": "binary-search",
                "content": "```\\npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        for(int i=0;i<spells.length;i++){\\n            int l=0,h=potions.length;\\n            while(l<h){\\n                int mid = (l+h)/2;\\n                if(1L*spells[i]*potions[mid]>=success){\\n                    h=mid;\\n                }else{\\n                    l=mid+1;\\n                }\\n            }\\n            spells[i]=potions.length-l;\\n        }\\n        return spells;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        for(int i=0;i<spells.length;i++){\\n            int l=0,h=potions.length;\\n            while(l<h){\\n                int mid = (l+h)/2;\\n                if(1L*spells[i]*potions[mid]>=success){\\n                    h=mid;\\n                }else{\\n                    l=mid+1;\\n                }\\n            }\\n            spells[i]=potions.length-l;\\n        }\\n        return spells;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3369922,
                "title": "c-easy-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& p, long long c) {\\n        sort(p.begin(),p.end());\\n        vector<int>an;\\n        for(int i=0;i<s.size();i++){\\n            int d=0;\\n            ll g=c/s[i];\\n            if(c%s[i])g++;\\n            int f=lower_bound(p.begin(),p.end(),g)-p.begin();\\n            d += p.size()-f;\\n            an.push_back(d);\\n        }\\n        return an;\\n    }\\n};\\n```\\n![upvote (3).jpg](https://assets.leetcode.com/users/images/c97c664a-5d0e-4880-8c56-ee876fe9d057_1680426069.3153875.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& p, long long c) {\\n        sort(p.begin(),p.end());\\n        vector<int>an;\\n        for(int i=0;i<s.size();i++){\\n            int d=0;\\n            ll g=c/s[i];\\n            if(c%s[i])g++;\\n            int f=lower_bound(p.begin(),p.end(),g)-p.begin();\\n            d += p.size()-f;\\n            an.push_back(d);\\n        }\\n        return an;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369191,
                "title": "c-easy-explanation-beginner-friendly-without-bs",
                "content": "# Intuition\\nWE WILL SORT SPELLS IN DESCENDING ORDER AND POTIONS IN ASCENDING ORDER . SO THAT EVERY TIME I CHECK FOR A GIVEN SPELL ,I DON\\'T HAVE TO TRAVERSE FROM BEGINNING . It will start from some index k .\\n\\nAND ALSO.\\nIF ANY GREATER SPELL IS NOT ABLE TO MAKE SUCCESS FROM POTIONS ,THEN \\nNO SPELL AFTER THAT WILL GIVE ANY SUCCESS . THEREFORE \\n\\n```\\nif(flag==0)break;\\n```\\n\\n# Approach\\nSEE CODE WITH COMMENTS . YOU WILL SURELY GET IT .\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& ss, vector<int>& p, long long suc) {\\n        vector<int>s=ss;// TO MAKE USE OF ITS SORTED(DESCENDING) FORM .\\n        unordered_map<int,int>mpp;// TO STORE SPELL WITH THEIR SUCCESS.\\n        vector<int>ans; // FINAL RESULT WILL BE STORED .\\n\\n        sort(p.begin(),p.end());\\n\\n        sort(s.begin(),s.end(),greater<int>()); // SORTING IN DESCENDING .\\n\\n        int n=s.size();int n2=p.size();\\n // K IS USED FOR NEW INDEX FROM WHERE NEXT SPELL SHOULD CHECK IN POTION FOR THEIR SUCCESS .\\n        int k=0;\\n\\n        for(int i=0;i<n;i++){\\n\\n            bool flag=0;// for check if any spell is making success or not.\\n\\n            for(int j=k;j<n2;j++){\\n                // 1LL for avoiding overflow of int .\\n                if(1LL*s[i]*p[j]>=suc){\\n                    k=j; // storing new index for next spell to traverse.\\n                    flag=1;\\n                    mpp[s[i]]=n2-j;// storing success of current spell.\\n                    break;\\n                }\\n            }\\n            // if spell is not making success ,break;\\n            if(flag==0){  break; } \\n        }\\n\\n        for(int i=0;i<n;i++){\\n            // if spell was making any success .It had stored in mpp.\\n            if(mpp.count(ss[i]))ans.push_back(mpp[ss[i]]);\\n\\n            else ans.push_back(0);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\nCODE BY :) AMAN MAURYA \\nTHANK YOU \\n\\nUPVOTE IF YOU FOUND IT EASY OR DIFFERENT .\\n![UPVOTE.jpeg](https://assets.leetcode.com/users/images/920b2dc1-352a-4f35-a497-d3016f8a562a_1680415841.5855615.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nif(flag==0)break;\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& ss, vector<int>& p, long long suc) {\\n        vector<int>s=ss;// TO MAKE USE OF ITS SORTED(DESCENDING) FORM .\\n        unordered_map<int,int>mpp;// TO STORE SPELL WITH THEIR SUCCESS.\\n        vector<int>ans; // FINAL RESULT WILL BE STORED .\\n\\n        sort(p.begin(),p.end());\\n\\n        sort(s.begin(),s.end(),greater<int>()); // SORTING IN DESCENDING .\\n\\n        int n=s.size();int n2=p.size();\\n // K IS USED FOR NEW INDEX FROM WHERE NEXT SPELL SHOULD CHECK IN POTION FOR THEIR SUCCESS .\\n        int k=0;\\n\\n        for(int i=0;i<n;i++){\\n\\n            bool flag=0;// for check if any spell is making success or not.\\n\\n            for(int j=k;j<n2;j++){\\n                // 1LL for avoiding overflow of int .\\n                if(1LL*s[i]*p[j]>=suc){\\n                    k=j; // storing new index for next spell to traverse.\\n                    flag=1;\\n                    mpp[s[i]]=n2-j;// storing success of current spell.\\n                    break;\\n                }\\n            }\\n            // if spell is not making success ,break;\\n            if(flag==0){  break; } \\n        }\\n\\n        for(int i=0;i<n;i++){\\n            // if spell was making any success .It had stored in mpp.\\n            if(mpp.count(ss[i]))ans.push_back(mpp[ss[i]]);\\n\\n            else ans.push_back(0);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2147091,
                "title": "java-easy-solution-using-binary-search-o-n-logn",
                "content": "**O(n*log(n)) / O(1)**\\n```\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        \\n        for(int i = 0; i < spells.length; i++) {\\n            int l = 0, r = potions.length;\\n            \\n            while(l < r) {\\n                int m = l + (r - l) / 2;\\n                \\n                if((long)spells[i]*potions[m]  >= success)\\n                    r = m;\\n                else\\n                    l = m + 1;\\n            }\\n            \\n            spells[i] = potions.length - l;\\n        }\\n        \\n        return spells;\\n    }\\n```\\n*Comment down, If you have any doubt.*\\n**Upvote^, If you liked it.**",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        \\n        for(int i = 0; i < spells.length; i++) {\\n            int l = 0, r = potions.length;\\n            \\n            while(l < r) {\\n                int m = l + (r - l) / 2;\\n                \\n                if((long)spells[i]*potions[m]  >= success)\\n                    r = m;\\n                else\\n                    l = m + 1;\\n            }\\n            \\n            spells[i] = potions.length - l;\\n        }\\n        \\n        return spells;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2139570,
                "title": "python-solution-explained",
                "content": "\\'\\'\\'\\n\\n    def successfulPairs(self, spells: List[int], potions: List[int], s: int) -> List[int]:\\n        q=[]\\n        potions.sort()                                      #Sort the potion array\\n        a=len(potions)\\n        for i in spells:\\n            count=0\\n            l=0                                   #We have to find a value which is less than (success/i) in sorted array  \\n             r=len(potions)                # binary seach will give index of that point and onwards that index all are \\n            x=s/i                                #greater values \\n            while l<r:\\n                mid=l+(r-l)//2\\n                if potions[mid]>=x:\\n                    r=mid\\n                else:\\n                    l=mid+1\\n            \\n            count=(a-l)                                      #Last - index that came with binary search\\n            q.append(count)\\n        return q\\n\\'\\'\\'",
                "solutionTags": [
                    "Python",
                    "C",
                    "Binary Search",
                    "Tree"
                ],
                "code": "\\'\\'\\'\\n\\n    def successfulPairs(self, spells: List[int], potions: List[int], s: int) -> List[int]:\\n        q=[]\\n        potions.sort()                                      #Sort the potion array\\n        a=len(potions)\\n        for i in spells:\\n            count=0\\n            l=0                                   #We have to find a value which is less than (success/i) in sorted array  \\n             r=len(potions)                # binary seach will give index of that point and onwards that index all are \\n            x=s/i                                #greater values \\n            while l<r:\\n                mid=l+(r-l)//2\\n                if potions[mid]>=x:\\n                    r=mid\\n                else:\\n                    l=mid+1\\n            \\n            count=(a-l)                                      #Last - index that came with binary search\\n            q.append(count)\\n        return q\\n\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 3369205,
                "title": "binary-search-intuition-explained-with-example",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we sort the potions array and find the minimum index where the product is greater than or equal to success, then we can be sure that the rest of the potions array will give product greater than or equal to success only.\\n\\nTo solve this kind of problem, we can use Binary Search. We can search in the range 0 to potions.size() and update the range according to whether the mid-value is enough or not.\\n\\n![image.png](https://assets.leetcode.com/users/images/9b20c1e9-0b07-4d87-9031-9d9a79afb50e_1680414955.5710003.png)\\n\\nThe condition would be:\\n``` \\nspell[i]*potions[j]>=success\\n=> potions[j]>=success/spell[i] (as success can be a large number)\\n```\\nNow we need to find the index where this condition is satisfied for the first time.\\n# Example\\nLet\\'s say we have the following inputs:\\n```\\nspells = [2, 3, 4]\\npotions = [1, 2, 3, 4, 5]\\nsuccess = 5\\n```\\n\\nAfter sorting potions, we have:\\n```\\npotions = [1, 2, 3, 4, 5]\\n```\\n\\nFor num = spell[0] = 2, we call binary search. \\n```\\nsuccess/num = 2.5 \\nThe index of the first element in potions that is >= 2.5 is 2.\\nTherefore, we append size-idx = 5-2 = 3 to the ans vector.\\n```\\nFor num = 3:\\n```\\nsuccess/num = 1.67\\nThe index of the first element in potions that is >= 1.67 is 1.\\nTherefore, we append n-idx = 5-1 = 4 to the ans vector.\\n```\\n\\nFor num = 4:\\n```\\nThe index of the first element in potions that is g>= 1.25 is 0.\\nTherefore, we append n-idx = 5-0 = 5 to the ans vector.\\n```\\nThe final ans vector:\\n```\\n[3, 4, 5]\\nindicating that there are 3 successful pairs for num = 2, \\n4 successful pairs for num = 3, \\nand 5 successful pairs for num = 4.\\n```\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(mlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binarySearch(int num, vector<int>& potions, long long success){\\n        int left=0, right=potions.size()-1;\\n        double curr=(double)success/num; \\n        while(left<right){\\n            int mid=left+(right-left)/2;\\n            if(potions[mid]>=curr){ \\n                right=mid;  // set right to mid to search for lower indices\\n            }\\n            else left=mid+1;  // else set left to mid+1 to search for higher indices\\n        }\\n        if(potions[right]>=curr) return right;  // if any element has product greater than or equal to success\\n        else return -1;  // else potion with success probability not fount\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int>ans;\\n        int n=potions.size();\\n        sort(potions.begin(),potions.end()); \\n        for(int num:spells){\\n            int idx=binarySearch(num,potions,success);  // find index where condition is satisfied for the first time\\n            if(idx==-1) ans.push_back(0);  // if potion with success probability not found, add 0\\n            else  ans.push_back(n-idx);  // else, n-idx would be the number of pairs that satisfy the condition\\n        }\\n        return ans;  \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "``` \\nspell[i]*potions[j]>=success\\n=> potions[j]>=success/spell[i] (as success can be a large number)\\n```\n```\\nspells = [2, 3, 4]\\npotions = [1, 2, 3, 4, 5]\\nsuccess = 5\\n```\n```\\npotions = [1, 2, 3, 4, 5]\\n```\n```\\nsuccess/num = 2.5 \\nThe index of the first element in potions that is >= 2.5 is 2.\\nTherefore, we append size-idx = 5-2 = 3 to the ans vector.\\n```\n```\\nsuccess/num = 1.67\\nThe index of the first element in potions that is >= 1.67 is 1.\\nTherefore, we append n-idx = 5-1 = 4 to the ans vector.\\n```\n```\\nThe index of the first element in potions that is g>= 1.25 is 0.\\nTherefore, we append n-idx = 5-0 = 5 to the ans vector.\\n```\n```\\n[3, 4, 5]\\nindicating that there are 3 successful pairs for num = 2, \\n4 successful pairs for num = 3, \\nand 5 successful pairs for num = 4.\\n```\n```\\nclass Solution {\\npublic:\\n    int binarySearch(int num, vector<int>& potions, long long success){\\n        int left=0, right=potions.size()-1;\\n        double curr=(double)success/num; \\n        while(left<right){\\n            int mid=left+(right-left)/2;\\n            if(potions[mid]>=curr){ \\n                right=mid;  // set right to mid to search for lower indices\\n            }\\n            else left=mid+1;  // else set left to mid+1 to search for higher indices\\n        }\\n        if(potions[right]>=curr) return right;  // if any element has product greater than or equal to success\\n        else return -1;  // else potion with success probability not fount\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int>ans;\\n        int n=potions.size();\\n        sort(potions.begin(),potions.end()); \\n        for(int num:spells){\\n            int idx=binarySearch(num,potions,success);  // find index where condition is satisfied for the first time\\n            if(idx==-1) ans.push_back(0);  // if potion with success probability not found, add 0\\n            else  ans.push_back(n-idx);  // else, n-idx would be the number of pairs that satisfy the condition\\n        }\\n        return ans;  \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367920,
                "title": "java-easy-solution-using-binary-search-beginner-friendly-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    \\n    Map<Integer, int[]> duplicates;\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int[] pairs = new int[spells.length];\\n        Arrays.sort(potions);\\n        int ind = 0;\\n        duplicates = new HashMap<>();\\n        for (int i = 0; i < potions.length; i++) {\\n            if (duplicates.containsKey(potions[i])) {\\n                int[] idx = duplicates.get(potions[i]);\\n                duplicates.put(potions[i], new int[]{idx[0], i});\\n            } else duplicates.put(potions[i], new int[]{i});\\n        }\\n\\n        for (int s : spells) {\\n            int idx = bs(potions, (long) Math.ceil((double) success / s));\\n            if (idx >= 0) {\\n                pairs[ind++] = potions.length - idx;\\n            } else {\\n                pairs[ind++] = 0;\\n            }\\n        }\\n        return pairs;\\n    }\\n\\n    private int bs(int[] potions, long value) {\\n        int l = 0, h = potions.length - 1;\\n        while (l < h) {\\n            int mid = l + (h - l) / 2;\\n            if (value < potions[mid]) {\\n                h = mid;\\n            } else if (value > potions[mid]) {\\n                l = mid + 1;\\n            } else if (value == potions[mid]) {\\n                return duplicates.get(potions[mid])[0];\\n            }\\n        }\\n\\n        return potions[l] < value ? -1 : l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    Map<Integer, int[]> duplicates;\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int[] pairs = new int[spells.length];\\n        Arrays.sort(potions);\\n        int ind = 0;\\n        duplicates = new HashMap<>();\\n        for (int i = 0; i < potions.length; i++) {\\n            if (duplicates.containsKey(potions[i])) {\\n                int[] idx = duplicates.get(potions[i]);\\n                duplicates.put(potions[i], new int[]{idx[0], i});\\n            } else duplicates.put(potions[i], new int[]{i});\\n        }\\n\\n        for (int s : spells) {\\n            int idx = bs(potions, (long) Math.ceil((double) success / s));\\n            if (idx >= 0) {\\n                pairs[ind++] = potions.length - idx;\\n            } else {\\n                pairs[ind++] = 0;\\n            }\\n        }\\n        return pairs;\\n    }\\n\\n    private int bs(int[] potions, long value) {\\n        int l = 0, h = potions.length - 1;\\n        while (l < h) {\\n            int mid = l + (h - l) / 2;\\n            if (value < potions[mid]) {\\n                h = mid;\\n            } else if (value > potions[mid]) {\\n                l = mid + 1;\\n            } else if (value == potions[mid]) {\\n                return duplicates.get(potions[mid])[0];\\n            }\\n        }\\n\\n        return potions[l] < value ? -1 : l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141703,
                "title": "c-use-binary-search-efficient-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) \\n    {\\n        int sn = spells.size();\\n        int pn = potions.size();\\n        vector<int> ans; //stores answer\\n        \\n        sort(potions.begin(), potions.end()); //sort potions for binary search\\n        \\n        for(auto it : spells)\\n        {\\n            int left=0, right=pn-1, mid; //define left, right and mid pointers\\n            \\n            while(left<=right) //iterate until right is lesser than left\\n            {\\n                mid = (left+right)>>1; \\n                \\n                if((long long)it*potions[mid] >= success) right=mid-1;\\n                \\n                else left=mid+1;\\n            }\\n            ans.push_back(pn-left);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n# Please upvote if you like this approach :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) \\n    {\\n        int sn = spells.size();\\n        int pn = potions.size();\\n        vector<int> ans; //stores answer\\n        \\n        sort(potions.begin(), potions.end()); //sort potions for binary search\\n        \\n        for(auto it : spells)\\n        {\\n            int left=0, right=pn-1, mid; //define left, right and mid pointers\\n            \\n            while(left<=right) //iterate until right is lesser than left\\n            {\\n                mid = (left+right)>>1; \\n                \\n                if((long long)it*potions[mid] >= success) right=mid-1;\\n                \\n                else left=mid+1;\\n            }\\n            ans.push_back(pn-left);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139547,
                "title": "python-3-math-binary-search-explanation",
                "content": "### Explanation\\n- The order of `potions` doesn\\'t matter, we just need to find out how many potion can form a *successful* pair with the current *spell*\\n\\t- Thus, we can sort `potions` to make a faster binary search\\n- We can\\'t use spell to multiply each potion, it takes a long time `O(mn)`; \\n\\t- Instead, we can use `success` to divided by the current *spell*, which is a `O(1)` operation\\n- If `success % spell == 0`, then we want to include `success // spell`\\n\\t- Thus, we will use a `bisect_left`\\n- Otherwise, we don\\'t want to include  `success // spell`\\n\\t- Thus, we will use a `bisect_right`\\n- `n - idx` is the number of *successful* potions with the current *spell*\\n- Time: `O(nlgm), n = len(spells), m = len(potions)`\\n### Implementation\\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        ans, n = [], len(potions)\\n        for spell in spells:\\n            val = success // spell\\n            if success % spell == 0:\\n                idx = bisect.bisect_left(potions, val)\\n            else:    \\n                idx = bisect.bisect_right(potions, val)\\n            ans.append(n - idx)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        ans, n = [], len(potions)\\n        for spell in spells:\\n            val = success // spell\\n            if success % spell == 0:\\n                idx = bisect.bisect_left(potions, val)\\n            else:    \\n                idx = bisect.bisect_right(potions, val)\\n            ans.append(n - idx)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3375724,
                "title": "powerful-binary-search-approach",
                "content": "\\n# Time Complexity----->O(NLogN)\\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        list1=[]\\n        potions.sort()\\n        // some test cases are not sorted\\n        for s in spells:\\n            // binary search on left most value i.e greater than success\\n            left,right,index=0,len(potions)-1,len(potions)# index is len(potions) in worst case where no values matches with potions values\\n            while left<=right:\\n                mid=(left+right)//2\\n                if s*potions[mid]>=success:\\n                    right=mid-1\\n                    index=mid\\n                else:\\n                    left=mid+1\\n            // add all possible values by total length -index\\n            list1.append(len(potions)-index)\\n        return list1\\n        \\n```\\n# please upvote me it would encourage me alot\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        list1=[]\\n        potions.sort()\\n        // some test cases are not sorted\\n        for s in spells:\\n            // binary search on left most value i.e greater than success\\n            left,right,index=0,len(potions)-1,len(potions)# index is len(potions) in worst case where no values matches with potions values\\n            while left<=right:\\n                mid=(left+right)//2\\n                if s*potions[mid]>=success:\\n                    right=mid-1\\n                    index=mid\\n                else:\\n                    left=mid+1\\n            // add all possible values by total length -index\\n            list1.append(len(potions)-index)\\n        return list1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372355,
                "title": "python-two-pointers-solution-w-sorting-without-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea is to initially sort both the ```spells``` and ```potions``` array, and then initialize a variable called ```p``` at the last element of ```potions```. ```p``` will only move from right to left, while another pointer, ```s```, will iterate through ```spells``` from left to right. We will check if ``` spells[s]*potions[p] >= success ```. If so, keep on moving the ```p``` pointer to the left until that condition fails. Record the result once that condition fails for each iteration of ```spells```.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Since the order of our ```spells``` array is important in order to return the number of potions that will form a successful pair with each element in ```spell```, we will recreate the ```spells``` list as a nested list that stores each of its elements and its index.\\n```Ex. spells = [5,1,3] -> spells = [[5,0],[1,1],[3,2]]```\\n2. Sort both ```spells``` and ```potions```.\\n3. Initialize ```result``` and ```p``` to ```[0]*len(spells)``` and ```len(potions)-1```, respectively. The ```result``` array will be returned in the end.\\n4. Run a for-loop on ```spells``` and for each iteration, we run a while-loop that checks if ```spells[s][0]*potions[p] >= success```. If so, we decrement the ```p``` pointer until that condition fails. There\\'s no point in checking further since we already found the potion with the least strength that will form a successful pair for the ```spell[s]``` spell.\\n5. Once the while-loop breaks, we can compute the number of potions that will form a successful pair by doing ```len(potions)-p-1``` and replace the element\\'s value in ```result``` on the ```spells[s][1]``` index.\\n\\n# Complexity\\n- Time complexity: **O(nlog(n)+mlog(m)+n)** because we sorted both input lists and iterate through ```spells```\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        spells = [[spells[i],i] for i in range(len(spells))]\\n        spells.sort()\\n        potions.sort()\\n\\n        result = [0]*len(spells)\\n        p = len(potions)-1\\n        for s in range(len(spells)):\\n            while p >= 0 and spells[s][0]*potions[p] >= success:\\n                p -= 1\\n            result[spells[s][1]] = len(potions)-p-1\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Two Pointers",
                    "Sorting",
                    "Counting"
                ],
                "code": "```spells```\n```potions```\n```p```\n```potions```\n```p```\n```s```\n```spells```\n``` spells[s]*potions[p] >= success ```\n```p```\n```spells```\n```spells```\n```spell```\n```spells```\n```Ex. spells = [5,1,3] -> spells = [[5,0],[1,1],[3,2]]```\n```spells```\n```potions```\n```result```\n```p```\n```[0]*len(spells)```\n```len(potions)-1```\n```result```\n```spells```\n```spells[s][0]*potions[p] >= success```\n```p```\n```spell[s]```\n```len(potions)-p-1```\n```result```\n```spells[s][1]```\n```spells```\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        spells = [[spells[i],i] for i in range(len(spells))]\\n        spells.sort()\\n        potions.sort()\\n\\n        result = [0]*len(spells)\\n        p = len(potions)-1\\n        for s in range(len(spells)):\\n            while p >= 0 and spells[s][0]*potions[p] >= success:\\n                p -= 1\\n            result[spells[s][1]] = len(potions)-p-1\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372002,
                "title": "binary-search-for-success",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing Binary Search for suucess.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Sort the array.\\n- Binary Search to locate the dividing element.\\n- Dividing element is where the product is just started to get greater.\\n  For Ex.\\n  spell = 5,\\n  potions = [1,2,3,4,5]\\n  success = 16\\n  then, dividing element = 4 (index = 3);\\n- subtracting the index with the length.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*log(M) + MlogM)\\n*MlogM for Sorting.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n![leetcodeupvotetrick.png](https://assets.leetcode.com/users/images/8b7ef33d-9a39-409f-916e-353e6dd88607_1680463496.6290069.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] arr, int[] arr1, long suc) {\\n        int[] res = new int[arr.length];\\n        Arrays.sort(arr1);\\n        int l, r, mid;\\n        long t;\\n        for (int i = 0; i < arr.length; i++) {\\n            l = 0;\\n            r = arr1.length - 1;\\n            while (l <= r) {\\n                mid = (l + r) / 2;\\n                t = arr[i];\\n                if (arr1[mid] * t >= suc) {\\n                    r = mid - 1;\\n                    if(r==-1){\\n                        res[i] = arr1.length;\\n                    }\\n                } else if (arr1[mid] * t < suc) {\\n                    if (mid + 1 < arr1.length && arr1[mid + 1] * t >= suc) {\\n                        res[i] = arr1.length - (mid + 1);\\n                        break;\\n                    }\\n                    l = mid + 1;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] arr, int[] arr1, long suc) {\\n        int[] res = new int[arr.length];\\n        Arrays.sort(arr1);\\n        int l, r, mid;\\n        long t;\\n        for (int i = 0; i < arr.length; i++) {\\n            l = 0;\\n            r = arr1.length - 1;\\n            while (l <= r) {\\n                mid = (l + r) / 2;\\n                t = arr[i];\\n                if (arr1[mid] * t >= suc) {\\n                    r = mid - 1;\\n                    if(r==-1){\\n                        res[i] = arr1.length;\\n                    }\\n                } else if (arr1[mid] * t < suc) {\\n                    if (mid + 1 < arr1.length && arr1[mid + 1] * t >= suc) {\\n                        res[i] = arr1.length - (mid + 1);\\n                        break;\\n                    }\\n                    l = mid + 1;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371631,
                "title": "javascript-php-beats-100-binary-search-faster-than-other-solutions",
                "content": "\\n# Approach\\nHere is my approach to solving the problem using a binary search:\\n\\n* First, we sort the potions array in ascending order. This ensures that the smallest potions are at the front of the\\n  array.\\n\\n* Then, we iterate over the spells array. For each spell, we perform _a binary search_ on the potions array to find the\\n  first potion that is greater than or equal to the _success_ value.\\n\\n* The number of potions that are greater than or equal to the spell\\'s power is the number of successful pairs that can\\n  be formed with that spell.\\n* We add this number to the pairs result array.\\n* We continue this process until we have iterated over all of the spells.\\n* Finally, we return the pairs array.\\n\\n# Complexity\\n\\nThe **time complexity** of the algorithm is O(n log m), where n is the number of potions, and m is the number of spells.\\nThis is because the algorithm sorts the potions array in O(n log n) time and performs a binary search on the potions\\narray for each spell, which takes O(n*log m) time. => O( (n+m) * log m) => O(n log m)\\n\\nThe **space complexity** of the algorithm is O(1), since the algorithm only requires a constant amount of space to store\\nthe\\npotions array, the spells array, the success value, and the pairs array.\\n\\n```javascript []\\n/**\\n * Binary search approach O((n+m)*log(m))\\n *\\n * @param {number[]} spells\\n * @param {number[]} potions\\n * @param {number} success\\n * @return {number[]}\\n */\\nvar successfulPairs = function (spells, potions, success) {\\n        const pairs = [];\\n        potions.sort((a, b) => a - b);\\n        const spellsLength = spells.length;\\n        const potionsLength = potions.length;\\n\\n        for (let i = 0; i < spellsLength; i++) {\\n            let count = 0;\\n            // binary search\\n            let left = 0;\\n            let right = potionsLength - 1;\\n            while (left <= right) {\\n                // const mid = Math.floor((left + right) / 2);\\n                const mid = (left + right) >> 1;\\n                if (spells[i] * potions[mid] >= success) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n            count = potionsLength - left;\\n            pairs.push(count);\\n        }\\n        return pairs;\\n    };\\n```\\n\\n```php []\\nclass Solution\\n{\\n    /**\\n     * @param Integer[] $spells\\n     * @param Integer[] $potions\\n     * @param Integer $success\\n     * @return Integer[]\\n     */\\n    function successfulPairs(array $spells, array $potions, int $success): array {\\n        $pairsResult = [];\\n        $potionsCount = count($potions);\\n        $spellsCount = count($spells);\\n        sort($potions);\\n        // binary search\\n        for ($i = 0; $i < $spellsCount; $i++) {\\n            $left = 0;\\n            $right = $potionsCount - 1;\\n            while ($left <= $right) {\\n                $mid = ($left + $right) >> 1;\\n                if ($spells[$i] * $potions[$mid] >= $success) {\\n                    $right = $mid - 1;\\n                } else {\\n                    $left = $mid + 1;\\n                }\\n            }\\n            $pairsResult[$i] = $potionsCount - $left;\\n        }\\n        return $pairsResult;\\n    }\\n}\\n```\\n\\n```javascript []\\n/**\\n * Binary search approach with  with small optimization\\n *\\n * @param {number[]} spells\\n * @param {number[]} potions\\n * @param {number} success\\n * @return {number[]}\\n */\\nvar successfulPairs = function (spells, potions, success) {\\n        const pairs = [];\\n        potions.sort((a, b) => a - b);\\n        const spellsLength = spells.length;\\n        const potionsLength = potions.length;\\n\\n        let maxSpellValueWithZeroSuccess = 0; // Optimize -  max value of a spell that will never be successful\\n\\n        for (let i = 0; i < spellsLength; i++) {\\n            let count = 0;\\n            if (spells[i] > maxSpellValueWithZeroSuccess) {\\n                // binary search\\n                let left = 0;\\n                let right = potionsLength - 1;\\n                while (left <= right) {\\n                    const mid = (left + right) >> 1;\\n                    if (spells[i] * potions[mid] >= success) {\\n                        right = mid - 1;\\n                    } else {\\n                        left = mid + 1;\\n                    }\\n                }\\n                count = potionsLength - left;\\n                if (count == 0) maxSpellValueWithZeroSuccess = spells[i];\\n            }\\n            pairs.push(count);\\n        }\\n        return pairs;\\n    };\\n```\\n\\n##### Thanks for reading! If you have any questions or suggestions, please leave a comment below. I would love to hear your thoughts! \\uD83D\\uDE0A\\n### **Please upvote if you found this post helpful! \\uD83D\\uDE4F**",
                "solutionTags": [
                    "JavaScript",
                    "PHP",
                    "Binary Search"
                ],
                "code": "```javascript []\\n/**\\n * Binary search approach O((n+m)*log(m))\\n *\\n * @param {number[]} spells\\n * @param {number[]} potions\\n * @param {number} success\\n * @return {number[]}\\n */\\nvar successfulPairs = function (spells, potions, success) {\\n        const pairs = [];\\n        potions.sort((a, b) => a - b);\\n        const spellsLength = spells.length;\\n        const potionsLength = potions.length;\\n\\n        for (let i = 0; i < spellsLength; i++) {\\n            let count = 0;\\n            // binary search\\n            let left = 0;\\n            let right = potionsLength - 1;\\n            while (left <= right) {\\n                // const mid = Math.floor((left + right) / 2);\\n                const mid = (left + right) >> 1;\\n                if (spells[i] * potions[mid] >= success) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n            count = potionsLength - left;\\n            pairs.push(count);\\n        }\\n        return pairs;\\n    };\\n```\n```php []\\nclass Solution\\n{\\n    /**\\n     * @param Integer[] $spells\\n     * @param Integer[] $potions\\n     * @param Integer $success\\n     * @return Integer[]\\n     */\\n    function successfulPairs(array $spells, array $potions, int $success): array {\\n        $pairsResult = [];\\n        $potionsCount = count($potions);\\n        $spellsCount = count($spells);\\n        sort($potions);\\n        // binary search\\n        for ($i = 0; $i < $spellsCount; $i++) {\\n            $left = 0;\\n            $right = $potionsCount - 1;\\n            while ($left <= $right) {\\n                $mid = ($left + $right) >> 1;\\n                if ($spells[$i] * $potions[$mid] >= $success) {\\n                    $right = $mid - 1;\\n                } else {\\n                    $left = $mid + 1;\\n                }\\n            }\\n            $pairsResult[$i] = $potionsCount - $left;\\n        }\\n        return $pairsResult;\\n    }\\n}\\n```\n```javascript []\\n/**\\n * Binary search approach with  with small optimization\\n *\\n * @param {number[]} spells\\n * @param {number[]} potions\\n * @param {number} success\\n * @return {number[]}\\n */\\nvar successfulPairs = function (spells, potions, success) {\\n        const pairs = [];\\n        potions.sort((a, b) => a - b);\\n        const spellsLength = spells.length;\\n        const potionsLength = potions.length;\\n\\n        let maxSpellValueWithZeroSuccess = 0; // Optimize -  max value of a spell that will never be successful\\n\\n        for (let i = 0; i < spellsLength; i++) {\\n            let count = 0;\\n            if (spells[i] > maxSpellValueWithZeroSuccess) {\\n                // binary search\\n                let left = 0;\\n                let right = potionsLength - 1;\\n                while (left <= right) {\\n                    const mid = (left + right) >> 1;\\n                    if (spells[i] * potions[mid] >= success) {\\n                        right = mid - 1;\\n                    } else {\\n                        left = mid + 1;\\n                    }\\n                }\\n                count = potionsLength - left;\\n                if (count == 0) maxSpellValueWithZeroSuccess = spells[i];\\n            }\\n            pairs.push(count);\\n        }\\n        return pairs;\\n    };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370088,
                "title": "c-prefix-sum-o-m-n-time-o-1-space",
                "content": "# Intuition\\nTo get to ```success``` we need to check if we can compensate potion power with our spell power. So we need to calculate ```neededSpellCost``` for each potion. As it is an integer division we need to add 1 when it can\\'t be divided to satisfy the requirement. After that we can see which spell can be used with which potion to make needed power.\\n\\n# Approach\\n```neededSpellCost``` can be quite big, such that we won\\'t have any possible spell at all, such cases just ignored.\\n\\nDuring the calculation of ```neededSpellCost``` we starting to build up our ```prefixSum```. After the loop on potions we will have ```prefixSum``` sloted with the number of each spell required.\\n\\nBut any ```k``` spell power can also be used to cover any less powerful spell. So we are going through ```prefixSum``` and accumulate it.\\n\\nLast run just goes through potions and sees how many each potion can cover.\\n\\n# Complexity\\n- Time complexity: ```O(m + n + 100000)``` => ```O(m + n)```\\n\\n- Space complexity: ```O(100000)``` => ```O(1)```\\n\\n# Code C#\\n```\\npublic class Solution {\\n    public int[] SuccessfulPairs(int[] spells, int[] potions, long success)\\n        {\\n            var limit = 100001;\\n            var prefixSum = new int[limit];\\n            for (var i = 0; i < potions.Length; i++)\\n            {\\n                var neededSpellCost = success % potions[i] == 0\\n                    ? success / potions[i]\\n                    : success / potions[i] + 1;\\n\\n                if (neededSpellCost < limit)\\n                    prefixSum[neededSpellCost]++;\\n            }\\n\\n            for (var i = 1; i < prefixSum.Length; i++)\\n                prefixSum[i] += prefixSum[i - 1];\\n\\n            var result = new int[spells.Length];\\n            for (var i = 0; i <  spells.Length; i++)\\n                result[i] = prefixSum[spells[i]];\\n\\n            return result;\\n        }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Prefix Sum"
                ],
                "code": "```success```\n```neededSpellCost```\n```neededSpellCost```\n```neededSpellCost```\n```prefixSum```\n```prefixSum```\n```k```\n```prefixSum```\n```O(m + n + 100000)```\n```O(m + n)```\n```O(100000)```\n```O(1)```\n```\\npublic class Solution {\\n    public int[] SuccessfulPairs(int[] spells, int[] potions, long success)\\n        {\\n            var limit = 100001;\\n            var prefixSum = new int[limit];\\n            for (var i = 0; i < potions.Length; i++)\\n            {\\n                var neededSpellCost = success % potions[i] == 0\\n                    ? success / potions[i]\\n                    : success / potions[i] + 1;\\n\\n                if (neededSpellCost < limit)\\n                    prefixSum[neededSpellCost]++;\\n            }\\n\\n            for (var i = 1; i < prefixSum.Length; i++)\\n                prefixSum[i] += prefixSum[i - 1];\\n\\n            var result = new int[spells.Length];\\n            for (var i = 0; i <  spells.Length; i++)\\n                result[i] = prefixSum[spells[i]];\\n\\n            return result;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368509,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        N=len(potions)\\n        ans=[]\\n        for s in spells:\\n            target=(success-1)//s\\n            index=bisect.bisect_right(potions,target)\\n            ans.append(N-index)\\n            \\n        return ans    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        N=len(potions)\\n        ans=[]\\n        for s in spells:\\n            target=(success-1)//s\\n            index=bisect.bisect_right(potions,target)\\n            ans.append(N-index)\\n            \\n        return ans    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367853,
                "title": "daily-leetcoding-challenge-april-day-2",
                "content": "This problem is the Daily LeetCoding Challenge for April, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2140055,
                "title": "c-binary-search-explanation-with-comments",
                "content": "**Please Upvote If It Helps**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) \\n    {\\n        // declare a vector of size spell that will store our ans\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int> ans(n,0);\\n        \\n        // sort the potions fir applying the binary search\\n        sort(potions.begin(),potions.end());\\n        \\n        int i = 0;                    // it will help in storing the ans\\n        \\n        // start iterating over the spells\\n        for(auto& x : spells)\\n        {\\n            int l = 0;\\n            int r = m-1;\\n            int mid;\\n            \\n            // binary search\\n            while(l <= r)\\n            {\\n                mid = (l+r)>>1;\\n                \\n                // if it gives our need then reduce the window to the left side for cheking more \\n                if((long long)x*potions[mid] >= success)\\n                    r = mid-1;\\n                \\n                // if not then check to the right side\\n                else\\n                    l = mid+1;\\n            }\\n            ans[i] = m-l;            // storing the answer (total size - not needed size)\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) \\n    {\\n        // declare a vector of size spell that will store our ans\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int> ans(n,0);\\n        \\n        // sort the potions fir applying the binary search\\n        sort(potions.begin(),potions.end());\\n        \\n        int i = 0;                    // it will help in storing the ans\\n        \\n        // start iterating over the spells\\n        for(auto& x : spells)\\n        {\\n            int l = 0;\\n            int r = m-1;\\n            int mid;\\n            \\n            // binary search\\n            while(l <= r)\\n            {\\n                mid = (l+r)>>1;\\n                \\n                // if it gives our need then reduce the window to the left side for cheking more \\n                if((long long)x*potions[mid] >= success)\\n                    r = mid-1;\\n                \\n                // if not then check to the right side\\n                else\\n                    l = mid+1;\\n            }\\n            ans[i] = m-l;            // storing the answer (total size - not needed size)\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139528,
                "title": "c-binary-search-short-and-simple-logic",
                "content": "For each spell,\\n**need = success * 1.0 / spell**\\nBinary search the index of **first potion >= need** in the sorted potions.\\nThe number of potions that are successful are **potions.length - index**\\n```\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        long long need;\\n        vector<int> ans;\\n        for(int spell:spells){\\n            need=ceil(success*1.0/spell);\\n            ans.push_back(potions.end()-lower_bound(potions.begin(),potions.end(),need));\\n        }\\n        return ans;\\n    }\\n```\\n*-----please upvote-----*",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        long long need;\\n        vector<int> ans;\\n        for(int spell:spells){\\n            need=ceil(success*1.0/spell);\\n            ans.push_back(potions.end()-lower_bound(potions.begin(),potions.end(),need));\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3467543,
                "title": "python-simple-clean-solution-using-binary-search",
                "content": "# Code\\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        ans = []\\n        potions.sort()\\n\\n        n = len(potions)\\n        for s in spells:\\n            ind = bisect_left(potions, success / s)\\n            ans.append(n - ind)\\n        return ans\\n```\\n\\n## Binary Search\\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        ans = []\\n        potions.sort()\\n\\n        n = len(potions)\\n        for s in spells:\\n            l, r = 0, n - 1\\n            while l <= r:\\n                mid = (l + r) >> 1\\n                if potions[mid] * s >= success:\\n                    r = mid - 1\\n                else:\\n                    l = mid + 1\\n            ans.append(n - l)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        ans = []\\n        potions.sort()\\n\\n        n = len(potions)\\n        for s in spells:\\n            ind = bisect_left(potions, success / s)\\n            ans.append(n - ind)\\n        return ans\\n```\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        ans = []\\n        potions.sort()\\n\\n        n = len(potions)\\n        for s in spells:\\n            l, r = 0, n - 1\\n            while l <= r:\\n                mid = (l + r) >> 1\\n                if potions[mid] * s >= success:\\n                    r = mid - 1\\n                else:\\n                    l = mid + 1\\n            ans.append(n - l)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372191,
                "title": "java-binary-search-spells-and-potions",
                "content": "\\n```\\nclass Solution {\\n    public int search(int[] nums, long target, long sel) {\\n        int start = 0;\\n        int finish = nums.length - 1;\\n        int med;\\n        if (target < nums[start] * sel) return start;\\n        if (target > nums[finish] * sel) return nums.length;\\n\\n        while (start < finish && nums[start] < nums[finish])\\n        {\\n            if (target == nums[start] * sel) return start;\\n            med = (start + finish) / 2;\\n            if (target > nums[med] * sel)\\n                start = med + 1;\\n            else\\n                finish = med;\\n\\n        }\\n        if (nums[start] * sel == target) return start;\\n        if (nums[start] * sel < target)\\n            return start + 1;\\n        else\\n            return start;\\n    }\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        HashMap<Integer, Integer> dict = new HashMap<>();\\n        Arrays.sort(potions);\\n        int [] answ = new int[spells.length];\\n        for (int i = 0; i < spells.length; i++) {\\n            if (!dict.containsKey(spells[i]))\\n                dict.put(spells[i], potions.length - search(potions, success, spells[i]));\\n            answ[i] = dict.get(spells[i]);\\n        }\\n        return answ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, long target, long sel) {\\n        int start = 0;\\n        int finish = nums.length - 1;\\n        int med;\\n        if (target < nums[start] * sel) return start;\\n        if (target > nums[finish] * sel) return nums.length;\\n\\n        while (start < finish && nums[start] < nums[finish])\\n        {\\n            if (target == nums[start] * sel) return start;\\n            med = (start + finish) / 2;\\n            if (target > nums[med] * sel)\\n                start = med + 1;\\n            else\\n                finish = med;\\n\\n        }\\n        if (nums[start] * sel == target) return start;\\n        if (nums[start] * sel < target)\\n            return start + 1;\\n        else\\n            return start;\\n    }\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        HashMap<Integer, Integer> dict = new HashMap<>();\\n        Arrays.sort(potions);\\n        int [] answ = new int[spells.length];\\n        for (int i = 0; i < spells.length; i++) {\\n            if (!dict.containsKey(spells[i]))\\n                dict.put(spells[i], potions.length - search(potions, success, spells[i]));\\n            answ[i] = dict.get(spells[i]);\\n        }\\n        return answ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372160,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Binary Search\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N * log M)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = potions.size();\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans;\\n        for(auto x: spells) {\\n            int l = 0, r = n - 1;\\n            while(l <= r) {\\n                int mid = (l + r) / 2;\\n                if(1ll * potions[mid] * x < success) l = mid + 1;\\n                else r = mid - 1;\\n            }\\n            ans.push_back(n - l);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = potions.size();\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans;\\n        for(auto x: spells) {\\n            int l = 0, r = n - 1;\\n            while(l <= r) {\\n                int mid = (l + r) / 2;\\n                if(1ll * potions[mid] * x < success) l = mid + 1;\\n                else r = mid - 1;\\n            }\\n            ans.push_back(n - l);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372059,
                "title": "java-binary-search-clean-code-beats-87",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O((m+n) * log(m))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(log(m))$$ used by the sort algorithm in Java\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n    var n = spells.length;\\n    var m = potions.length;\\n    var pairs = new int[n];\\n    \\n    Arrays.sort(potions);\\n\\n    for (var i=0; i<n; i++) {\\n      var minPotion = (int) Math.ceil((double) success / spells[i]);\\n\\n      if (minPotion > potions[m-1]) continue;\\n\\n      var l = 0;\\n      var r = m-1;\\n\\n      while (l < r) {\\n        var mid = l + (r-l) / 2;\\n\\n        if (potions[mid] < minPotion) l = mid+1;\\n        else r = mid;\\n      }\\n      pairs[i] = m-l;\\n    }\\n    return pairs;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n  public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n    var n = spells.length;\\n    var m = potions.length;\\n    var pairs = new int[n];\\n    \\n    Arrays.sort(potions);\\n\\n    for (var i=0; i<n; i++) {\\n      var minPotion = (int) Math.ceil((double) success / spells[i]);\\n\\n      if (minPotion > potions[m-1]) continue;\\n\\n      var l = 0;\\n      var r = m-1;\\n\\n      while (l < r) {\\n        var mid = l + (r-l) / 2;\\n\\n        if (potions[mid] < minPotion) l = mid+1;\\n        else r = mid;\\n      }\\n      pairs[i] = m-l;\\n    }\\n    return pairs;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371519,
                "title": "c-easy-lower-bound-2023-short-sol-must-watch",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& p, long long t) {\\n        sort(p.begin(),p.end());\\n        vector<int> ans; \\n        int x; long long y;\\n        for(auto &it:s) {\\n            y = t / it;\\n            x = p.end() - lower_bound(p.begin(),p.end(),y * it >= t ? y : y + 1);\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& p, long long t) {\\n        sort(p.begin(),p.end());\\n        vector<int> ans; \\n        int x; long long y;\\n        for(auto &it:s) {\\n            y = t / it;\\n            x = p.end() - lower_bound(p.begin(),p.end(),y * it >= t ? y : y + 1);\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371258,
                "title": "python-3-7-lines-binary-search-t-m-97-70",
                "content": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n\\n        n, ans = len(potions), []\\n        potions.sort()\\n        \\n        for s in spells:\\n            num = success//s + bool(success%s)\\n            idx = bisect_left(potions, num)\\n            ans.append(n-idx)\\n\\n        return ans\\n```\\n[https://leetcode.com/problems/successful-pairs-of-spells-and-potions/submissions/926254122/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*log*N*) and space complexity is *O*(1).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n\\n        n, ans = len(potions), []\\n        potions.sort()\\n        \\n        for s in spells:\\n            num = success//s + bool(success%s)\\n            idx = bisect_left(potions, num)\\n            ans.append(n-idx)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370628,
                "title": "binary-search-c-please-upvote",
                "content": "# Intuition\\nCan be done in binary search.\\n\\n# Approach\\nStarting with the sorting of potions  , After that getting the element till which (spells[i]*potions[mid]) is greater than success and store those elements in pairs[i].\\nThe submission shall be taken care of for long long type casting.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogm)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n=spells.size(),m=potions.size();\\n       \\n       \\n       sort(potions.begin(),potions.end());\\n       vector<int> pairs(n);\\n      for(int i=0;i<n;i++){\\n          int c=0,l=0,r=m-1;\\n        while(l<=r){\\n            \\n            int mid=l+(r-l)/2;\\n            if((long long)spells[i]*(long long)potions[mid]>=success){\\n                r=mid-1;\\n                \\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        pairs[i]=m-1-r;\\n        }\\n\\n        \\n        return pairs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n=spells.size(),m=potions.size();\\n       \\n       \\n       sort(potions.begin(),potions.end());\\n       vector<int> pairs(n);\\n      for(int i=0;i<n;i++){\\n          int c=0,l=0,r=m-1;\\n        while(l<=r){\\n            \\n            int mid=l+(r-l)/2;\\n            if((long long)spells[i]*(long long)potions[mid]>=success){\\n                r=mid-1;\\n                \\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        pairs[i]=m-1-r;\\n        }\\n\\n        \\n        return pairs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370295,
                "title": "simple-14-lines-of-code-in-o-n-logn",
                "content": "# NOTE:\\n**Please go through the Intution and Approach before jumping to the code. You will definitely get it!**\\nSuggested to write things on notebook while reading.\\n\\n# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn the question, we can see a basic pattern that we have to search a value for every element in spell. If we do this searching linearly for all n elements of spell (m times).\\n\\nIt will give us complexity of `O(n*m)`. This complexity can be reduced to  `O(n * logm)`  by using binary search. But before that we have to sort the array potions.\\n```C++ []\\nsort(potions.begin(), potions.end());   // sorting array of potions\\n```\\n\\nNow, it is given in the question that we have to find the number of elements in potions that multiply with spell[i] to give value >= success.\\n\\nIn simple words: \\n$$spells[i] * potions[j]  >=  success$$\\n\\nTaking spells[i] on R.H.S. we get:\\n$$potions[j] >= success / spells[i]$$\\n\\nSo minimum possible value of potion for spells[i] is `success / spells[i]`. Now, it is clear that we have to find **$$lower bound$$** in our already sorted array of potions. And we know,  all the elements after this lower bound in the potions array will be greater (as the array is sorted in increasing order), so we will get the answer by doing m - lower bound.\\n```\\nans[i] = m - lower_bound_ind;\\n```\\nPlease check the code below.\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n logm)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Please Upvote if it was helpfull.!\\uD83D\\uDE03\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size(), m = potions.size();\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans(n);\\n        for (int i{}; i<n; ++i){\\n            long long potion = ceil((double)success/spells[i]);\\n            int lower_bound_ind = lower_bound(potions.begin(), potions.end(), potion) - potions.begin();\\n            ans[i] = m-lower_bound_ind;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Binary Search",
                    "Sort"
                ],
                "code": "```C++ []\\nsort(potions.begin(), potions.end());   // sorting array of potions\\n```\n```\\nans[i] = m - lower_bound_ind;\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size(), m = potions.size();\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans(n);\\n        for (int i{}; i<n; ++i){\\n            long long potion = ceil((double)success/spells[i]);\\n            int lower_bound_ind = lower_bound(potions.begin(), potions.end(), potion) - potions.begin();\\n            ans[i] = m-lower_bound_ind;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370276,
                "title": "easy-java-binary-search-beats-85",
                "content": "# Intuition\\nSolution using basic Binary Search\\n\\n# Approach\\n1. sort the potion array\\n2. now iterate for the spell array\\n3. binary search the index where the multiple of spell*potion>=success\\n4. now from that index onwards rest potions will be surely >=success because they are arranged in increasing order\\n# Complexity\\n- Time complexity:\\nO(NlogM)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] s, int[] p, long sus) {\\n        Arrays.sort(p);\\n        int n = s.length;\\n        int m = p.length;\\n        int[] ans = new int[n];\\n        for(int i=0;i<n;i++){\\n            ans[i] =m-search(p,sus,m,s[i]);\\n        }\\n        return ans;\\n    }\\n\\n    int search(int[] p ,long t ,int size, int given){\\n        int s =0;\\n        int e = size-1;\\n        while(s<=e){\\n            int mid = (s+e)/2;\\n            long mul = (long)given*p[mid];\\n            if(mul>=t){\\n                e = mid-1;\\n            }else{\\n                s = mid+1;\\n            }\\n\\n        }\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] s, int[] p, long sus) {\\n        Arrays.sort(p);\\n        int n = s.length;\\n        int m = p.length;\\n        int[] ans = new int[n];\\n        for(int i=0;i<n;i++){\\n            ans[i] =m-search(p,sus,m,s[i]);\\n        }\\n        return ans;\\n    }\\n\\n    int search(int[] p ,long t ,int size, int given){\\n        int s =0;\\n        int e = size-1;\\n        while(s<=e){\\n            int mid = (s+e)/2;\\n            long mul = (long)given*p[mid];\\n            if(mul>=t){\\n                e = mid-1;\\n            }else{\\n                s = mid+1;\\n            }\\n\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369698,
                "title": "binary-search-approach-java-solution",
                "content": "\\n# Java Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int pairs[] = new int[spells.length];\\n\\n        Arrays.sort(potions);\\n\\n        for(int i = 0; i < spells.length; i++)\\n        {\\n            int start = 0, end = potions.length-1;\\n            while(start <= end)\\n            {\\n                int mid = start + (end - start)/2;\\n                if(potions[mid] * (long)spells[i] >= success)\\n                {\\n                    end = mid - 1;\\n                }\\n                else\\n                {\\n                    start = mid + 1;\\n                }\\n            }\\n            pairs[i] = potions.length - start;\\n        }\\n\\n        return pairs;\\n    }\\n}\\n```\\n\\n# PLEASE UPVOTE \\uD83D\\uDC4D",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int pairs[] = new int[spells.length];\\n\\n        Arrays.sort(potions);\\n\\n        for(int i = 0; i < spells.length; i++)\\n        {\\n            int start = 0, end = potions.length-1;\\n            while(start <= end)\\n            {\\n                int mid = start + (end - start)/2;\\n                if(potions[mid] * (long)spells[i] >= success)\\n                {\\n                    end = mid - 1;\\n                }\\n                else\\n                {\\n                    start = mid + 1;\\n                }\\n            }\\n            pairs[i] = potions.length - start;\\n        }\\n\\n        return pairs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369619,
                "title": "easy-explanation-binary-search-approach",
                "content": "# Approach\\n1. Brute Force approach to solve this problem is to use a **nested loop**, where the outer loop iterates over the \"spells\" vector and the inner loop iterates over the \"potions\" vector. For each pair (s, p), the product s * p is checked against the target. If the product is greater than or equal to the target, then the pair is considered successful and the count is incremented.\\nHowever, this approach has a time complexity of **O(n^2)**, which is inefficient for large values of n.\\n2. A more efficient approach is to first sort the \"potions\" vector in non-decreasing order. This allows us to perform ***binary search*** on the sorted \"potions\" vector to ***find the index of the last element*** that satisfies the condition ***s * p >= target*** for a given s->element.\\n Then, for each element s in the \"spells\" vector, we can use binary search to find the number of elements in the \"potions\" vector that satisfy the condition s * p >= target. This can be done by finding the index of the last element in the \"potions\" vector that satisfies the condition using binary search, and subtracting this index from the total number of elements in the \"potions\" vector.\\n\\n# Complexity\\n- Time complexity:    O(n log n)\\n- Space Complexity:   O(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getPairCount(vector<int>& potions, int& spell, long long& target)\\n    {\\n        int n = potions.size(), bestIdx = n;\\n        int low = 0, high = n - 1;\\n        \\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            long long product = (long long)spell * potions[mid];\\n            \\n            if (product >= target)\\n            {\\n                bestIdx = mid;\\n                high = mid - 1;\\n            }\\n            else low = mid + 1;\\n        }\\n       \\n        return (n - bestIdx);\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success)\\n    {\\n        int n = spells.size();\\n        vector<int>v(n);\\n        sort(potions.begin(), potions.end());\\n        for (int i = 0; i < n; i++) \\n            ans[i] = getPairCount(potions, spells[i], success);\\n        \\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getPairCount(vector<int>& potions, int& spell, long long& target)\\n    {\\n        int n = potions.size(), bestIdx = n;\\n        int low = 0, high = n - 1;\\n        \\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            long long product = (long long)spell * potions[mid];\\n            \\n            if (product >= target)\\n            {\\n                bestIdx = mid;\\n                high = mid - 1;\\n            }\\n            else low = mid + 1;\\n        }\\n       \\n        return (n - bestIdx);\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success)\\n    {\\n        int n = spells.size();\\n        vector<int>v(n);\\n        sort(potions.begin(), potions.end());\\n        for (int i = 0; i < n; i++) \\n            ans[i] = getPairCount(potions, spells[i], success);\\n        \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369587,
                "title": "python3-one-line-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        return potions.sort() or [len(potions) - bisect_left(potions, -(-success // spell)) for spell in spells]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        return potions.sort() or [len(potions) - bisect_left(potions, -(-success // spell)) for spell in spells]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369441,
                "title": "easy-and-fast-c-solution-with-full-explanation",
                "content": "# Intuition\\nsorting the potions array to reduce the number of operations to search(binary search) for the element whose product with ith spell is greater than or equal to the success.\\n\\n# Approach\\n1. sort `potions` array.\\n2. use `binary search` to search for the element whose product with that spell is equal or just greater than `success`.\\n3. count all the elements after that element *(including that element)* in `potions` array as all the elements after this element are greater than it and hence will result in greater product than `success`.\\n4. store that count in an `ans` vector.\\n5. return `ans`.\\n\\n# Complexity\\n- Time complexity:\\n`O(n*logm)`\\n\\n- Space complexity:\\n`O(n)`\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size();\\n        int m = potions.size();\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans;\\n        for(auto &i: spells){\\n            int j = 0;\\n            int k = m-1;\\n            while(j<=k){\\n                int mid = (j+k)/2;\\n                int long x = potions[mid];\\n                if(i*x<success){\\n                    j = mid + 1;\\n                }\\n                else{\\n                    k = mid - 1;\\n                }\\n            }\\n            ans.push_back(m-k-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size();\\n        int m = potions.size();\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans;\\n        for(auto &i: spells){\\n            int j = 0;\\n            int k = m-1;\\n            while(j<=k){\\n                int mid = (j+k)/2;\\n                int long x = potions[mid];\\n                if(i*x<success){\\n                    j = mid + 1;\\n                }\\n                else{\\n                    k = mid - 1;\\n                }\\n            }\\n            ans.push_back(m-k-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368952,
                "title": "c-solution-with-explanation-let-s-code-it",
                "content": "# Upvote if you found this solution helpful\\uD83D\\uDD25\\n\\n# Approach\\nThe first approach which comes to mind after reading the question is to traverse the Potions array for each spell and count the number of pairs which satisfies the given condition, but this method leads to TLE because the time complexity for this will be O(n x m) where both n and m are of order 10^5.\\nSo, the optimized approach is to reduce the number of calculations we are doing for each spell.\\nIf we think for second we can deduce that by sorting the list of potions and using binary search to traverse the list we can reduce our calculations in a significant way.\\n\\nNOTE: Keep in mind to convert the product of spell and potion to LONG LONG before further moving with calculations\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int countPairs(int spell, vector<int> &potions, long long success){\\n        int n = potions.size();\\n        int index = n;\\n        int start = 0;\\n        int end = n-1;\\n\\n        while(start <= end){\\n            int mid = start + (end-start)/2;\\n\\n            //if the product of potion and spell satisfies the condition, move the end pointer to mid-1 because we need to find the first element for which the product of spell and potion is greater than success\\n            if((long long)potions[mid]*spell >= success){\\n                index = mid;\\n                end = mid-1;\\n            }\\n\\n            //if the product is less than the success value move to start pointer to mid+1\\n            if((long long)potions[mid]*spell < success)\\n                start = mid+1;\\n        }\\n\\n        return n-index;\\n    }\\n\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> ans(spells.size());\\n\\n        //sorting the potions list\\n        sort(potions.begin(), potions.end());\\n\\n        //for each spell find the number of potions which can satisfy the condition\\n        for(int i=0; i<spells.size(); i++)\\n            ans[i] = countPairs(spells[i], potions, success);\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int countPairs(int spell, vector<int> &potions, long long success){\\n        int n = potions.size();\\n        int index = n;\\n        int start = 0;\\n        int end = n-1;\\n\\n        while(start <= end){\\n            int mid = start + (end-start)/2;\\n\\n            //if the product of potion and spell satisfies the condition, move the end pointer to mid-1 because we need to find the first element for which the product of spell and potion is greater than success\\n            if((long long)potions[mid]*spell >= success){\\n                index = mid;\\n                end = mid-1;\\n            }\\n\\n            //if the product is less than the success value move to start pointer to mid+1\\n            if((long long)potions[mid]*spell < success)\\n                start = mid+1;\\n        }\\n\\n        return n-index;\\n    }\\n\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> ans(spells.size());\\n\\n        //sorting the potions list\\n        sort(potions.begin(), potions.end());\\n\\n        //for each spell find the number of potions which can satisfy the condition\\n        for(int i=0; i<spells.size(); i++)\\n            ans[i] = countPairs(spells[i], potions, success);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368830,
                "title": "python-short-and-clean-2-liner-functional-programming",
                "content": "# Approach\\n1. Sort `potions` into, say `s_potions`.\\n\\n2. For each `spells`, say `x`, binary-search for insertion index `i` in `s_potions`.\\n\\n3. Return `len(potions) - i`.\\n\\n# Complexity\\n- Time complexity: $$O((m + n) * log(n))$$\\n\\n- Space complexity: $$O(m + n)$$\\n\\nwhere,\\n`m is number of spells`,\\n`n is number of potions`.\\n\\n# Code\\nWIth currying (partial functions):\\n```python\\nclass Solution:\\n    def successfulPairs(self, spells: list[int], potions: list[int], success: int) -> list[int]:\\n        f = partial(bisect.bisect_left, sorted(potions))\\n        return (len(potions) - f(success / x) for x in spells)\\n\\n\\n```\\nWithout using currying (partial functions):\\n```python\\nclass Solution:\\n    def successfulPairs(self, spells: list[int], potions: list[int], success: int) -> list[int]:\\n        s_potions = sorted(potions)\\n        return (len(potions) - bisect.bisect_left(s_potions, success / x) for x in spells)\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```python\\nclass Solution:\\n    def successfulPairs(self, spells: list[int], potions: list[int], success: int) -> list[int]:\\n        f = partial(bisect.bisect_left, sorted(potions))\\n        return (len(potions) - f(success / x) for x in spells)\\n\\n\\n```\n```python\\nclass Solution:\\n    def successfulPairs(self, spells: list[int], potions: list[int], success: int) -> list[int]:\\n        s_potions = sorted(potions)\\n        return (len(potions) - bisect.bisect_left(s_potions, success / x) for x in spells)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368195,
                "title": "clear-c-binary-search-beats-95-4",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAfter sort potions, this problem becomes to: for each spells[i], find the first index in potions that spells[i] * potions[index] >= success. Then the pair that spells[i] can form is potions.Length - index\\n\\nFind the first index match a condition is a typical binary search question.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(mlogm + nlogm)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\npublic class Solution {\\n    public int[] SuccessfulPairs(int[] spells, int[] potions, long success) {\\n             Array.Sort(potions);\\n            int[] retval = new int[spells.Length];\\n            for(int i = 0; i < spells.Length; i++)\\n            {\\n                int l = 0, r = potions.Length - 1;\\n                int leftMostIdx = -1;\\n                while(l <= r)\\n                {\\n                    int m = (l + r) / 2;\\n                    if (((long)spells[i]) * potions[m] >= success)\\n                    {\\n                        leftMostIdx = m;\\n                        r = m - 1;\\n                    }\\n                    else l = m + 1;\\n                }\\n                retval[i] = leftMostIdx == -1 ? 0 : potions.Length - leftMostIdx;\\n            }\\n\\n            return retval;       \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] SuccessfulPairs(int[] spells, int[] potions, long success) {\\n             Array.Sort(potions);\\n            int[] retval = new int[spells.Length];\\n            for(int i = 0; i < spells.Length; i++)\\n            {\\n                int l = 0, r = potions.Length - 1;\\n                int leftMostIdx = -1;\\n                while(l <= r)\\n                {\\n                    int m = (l + r) / 2;\\n                    if (((long)spells[i]) * potions[m] >= success)\\n                    {\\n                        leftMostIdx = m;\\n                        r = m - 1;\\n                    }\\n                    else l = m + 1;\\n                }\\n                retval[i] = leftMostIdx == -1 ? 0 : potions.Length - leftMostIdx;\\n            }\\n\\n            return retval;       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367859,
                "title": "c-sort-and-lower-bound",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& p, long long success) {\\n        int n = s.size(), m = p.size();\\n        sort(p.begin(), p.end());\\n        vector<int> res(n);\\n        for (int i = 0; i < n; i += 1) {\\n            long long x = (success + s[i] - 1) / s[i];\\n            if (x > p.back()) continue;\\n            auto it = lower_bound(p.begin(), p.end(), (int)x);\\n            res[i] = m - (it - p.begin());\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& p, long long success) {\\n        int n = s.size(), m = p.size();\\n        sort(p.begin(), p.end());\\n        vector<int> res(n);\\n        for (int i = 0; i < n; i += 1) {\\n            long long x = (success + s[i] - 1) / s[i];\\n            if (x > p.back()) continue;\\n            auto it = lower_bound(p.begin(), p.end(), (int)x);\\n            res[i] = m - (it - p.begin());\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2750229,
                "title": "easiest-best-solution-in-c-binarysearch",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogm)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n**Please Upvote if u liked my Solution**\\uD83D\\uDE42\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n=spells.size(),m=potions.size();\\n        vector<int> pairs;\\n        sort(potions.begin(),potions.end());\\n        for(int i=0;i<n;i++){\\n            if(spells[i]>=success){\\n                pairs.push_back(m);\\n                continue;\\n            }\\n            int ll=0,ul=m-1,mid;\\n            while(ll<=ul){\\n                mid =ll+(ul-ll)/2;\\n                long long product=(long long)potions[mid]*spells[i];\\n                if(product>=success)\\n                    ul=mid-1;\\n                else\\n                    ll=mid+1;\\n            }\\n            pairs.push_back(m-ll);\\n        }\\n        return pairs;\\n    }\\n};\\n```\\n**Happy LeetCoding\\uD83D\\uDCAF\\nPlease Upvote**",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n=spells.size(),m=potions.size();\\n        vector<int> pairs;\\n        sort(potions.begin(),potions.end());\\n        for(int i=0;i<n;i++){\\n            if(spells[i]>=success){\\n                pairs.push_back(m);\\n                continue;\\n            }\\n            int ll=0,ul=m-1,mid;\\n            while(ll<=ul){\\n                mid =ll+(ul-ll)/2;\\n                long long product=(long long)potions[mid]*spells[i];\\n                if(product>=success)\\n                    ul=mid-1;\\n                else\\n                    ll=mid+1;\\n            }\\n            pairs.push_back(m-ll);\\n        }\\n        return pairs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2444760,
                "title": "js-binary-search-runtime-83-33",
                "content": "```\\nvar successfulPairs = function(spells, potions, success) {\\n\\tlet res = [];\\n\\tpotions.sort((a, b) => a - b);\\n\\tfor (let i = 0; i < spells.length; i++) {\\n\\t\\tlet h = potions.length-1, l = 0, mid;\\n\\t\\twhile (l <= h) {\\n\\t\\t\\tmid = ~~(l + (h-l)/2);\\n\\t\\t\\tif (spells[i] * potions[mid] >= success) h = mid-1;\\n\\t\\t\\telse l = mid+1;\\n\\t\\t}\\n\\t\\tres[i] = potions.length-1 - h;\\n\\t}\\n\\treturn res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\nvar successfulPairs = function(spells, potions, success) {\\n\\tlet res = [];\\n\\tpotions.sort((a, b) => a - b);\\n\\tfor (let i = 0; i < spells.length; i++) {\\n\\t\\tlet h = potions.length-1, l = 0, mid;\\n\\t\\twhile (l <= h) {\\n\\t\\t\\tmid = ~~(l + (h-l)/2);\\n\\t\\t\\tif (spells[i] * potions[mid] >= success) h = mid-1;\\n\\t\\t\\telse l = mid+1;\\n\\t\\t}\\n\\t\\tres[i] = potions.length-1 - h;\\n\\t}\\n\\treturn res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2139975,
                "title": "o-n-m-approach-c-without-binary-search-and-sort-easy-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int maxi = 0;\\n        unordered_map<int,int> dp;\\n        for(int i = 0 ; i<potions.size() ; i++){\\n            dp[potions[i]]++;\\n            maxi = max(potions[i],maxi);\\n        }\\n        \\n        vector<int> refer(maxi+1);\\n        \\n        refer[refer.size()-1] = dp[refer.size()-1];\\n        \\n        for(int i = refer.size()-2 ; i >= 0 ; i--){\\n            refer[i] = refer[i+1] + dp[i];\\n        }\\n        \\n        vector<int> result(spells.size());\\n        \\n        for(int i = 0 ; i < spells.size() ; i++){\\n            double t1 = success;\\n            double t2 = spells[i];\\n            long long temp = ceil(t1/t2);\\n            if(temp > maxi){\\n                result[i] = 0;\\n                continue;\\n            }\\n            result[i]= refer[temp];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int maxi = 0;\\n        unordered_map<int,int> dp;\\n        for(int i = 0 ; i<potions.size() ; i++){\\n            dp[potions[i]]++;\\n            maxi = max(potions[i],maxi);\\n        }\\n        \\n        vector<int> refer(maxi+1);\\n        \\n        refer[refer.size()-1] = dp[refer.size()-1];\\n        \\n        for(int i = refer.size()-2 ; i >= 0 ; i--){\\n            refer[i] = refer[i+1] + dp[i];\\n        }\\n        \\n        vector<int> result(spells.size());\\n        \\n        for(int i = 0 ; i < spells.size() ; i++){\\n            double t1 = success;\\n            double t2 = spells[i];\\n            long long temp = ceil(t1/t2);\\n            if(temp > maxi){\\n                result[i] = 0;\\n                continue;\\n            }\\n            result[i]= refer[temp];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139392,
                "title": "java-clean-code-binary-search",
                "content": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        \\n        Arrays.sort(potions);\\n        int[] res=new int[spells.length];\\n        \\n        for(int i=0;i<spells.length;i++)\\n        {\\n            int count=binarySearch(spells[i],potions,success);\\n            res[i]=count;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public static int binarySearch(int spell, int[] potions, long success)\\n    {\\n        int i=0;\\n        int j=potions.length-1;\\n        int n=potions.length;\\n        \\n        int res=0;\\n        \\n        while(i<=j)\\n        {\\n            int mid=(i+j)/2;\\n            \\n            if((spell*1.0)*potions[mid]>=success)\\n            {\\n                res=n-mid;\\n                j=mid-1;\\n            }\\n            \\n            else\\n            {\\n                i=mid+1;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        \\n        Arrays.sort(potions);\\n        int[] res=new int[spells.length];\\n        \\n        for(int i=0;i<spells.length;i++)\\n        {\\n            int count=binarySearch(spells[i],potions,success);\\n            res[i]=count;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public static int binarySearch(int spell, int[] potions, long success)\\n    {\\n        int i=0;\\n        int j=potions.length-1;\\n        int n=potions.length;\\n        \\n        int res=0;\\n        \\n        while(i<=j)\\n        {\\n            int mid=(i+j)/2;\\n            \\n            if((spell*1.0)*potions[mid]>=success)\\n            {\\n                res=n-mid;\\n                j=mid-1;\\n            }\\n            \\n            else\\n            {\\n                i=mid+1;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139292,
                "title": "python-binary-search-explanation",
                "content": "I Was Also One Of The Person Who Got TLE At The First Attempt\\n\\nThe Straight Forward Approach was to multiply each and every value of potion with the every value of spell and count the values which are greater than success and append to the answer array. This was one of the common solution which every one thinks of..\\n\\nThe Solution For Me Which Got Accepted Was After Using Binary Search With Sorting Array.\\n\\nLet Us See How It Worked For Me..\\n\\nSuppose spell = [5,1,3] potions = [1,2,3,4,5]  success = 7\\n\\nConsider First Element Of Spell - 5  the least number that makes 5 after multiplying results to greater than or equal to  7 that is obviously 2 - So the resultant value will be 4 \\n\\nConsider Second Element Of Spell -1 The Smallest Number That Makes Greater Than or equal to 7 is 7 but it is not in the array so the resultant value will be 0\\n\\nConsider Last Element Of Spell - 3 The Smallest Number That Makes 3 Greater Than Or Equal To 7 is 3 - So the Resultant Value will be 3\\n\\nSimilarly For Every Value in Spell If We Are Able To Find The Smaller Value Which After Multiplying Makes Greater Than Success Value And Then We Had To Find The Left Most Index Which Will Be Suitable For Placing The Obtained Value In The Potions Will Result Us Answer.\\n\\nThis is my following Code For The Problem..\\n\\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        result = self.function(spells,potions,success)\\n        return result\\n    \\n    def function(self,arr1,arr2,success):\\n        n2 = len(arr2)\\n        arr2.sort() #Sorting Enables Us To Do Binary Search\\n        ans = []\\n        for i in arr1:\\n            val = math.ceil(success/i) #Finding the Value Of Portion With Least Strength So That It Can Be Greater Than Success\\n            idx = bisect.bisect_left(arr2,val) #Finding The Left Most Index So That The Value Can Be Inserted\\n            res = n2-idx+1  #Calculating the remaining numbers after finding the suitable index\\n            ans.append(res-1)\\n        return ans\\n```\\n\\nPlease Upvote If You Like The Explanation..\\uD83D\\uDE0A\\n\\n\\nHappy LeetCoding!!!!",
                "solutionTags": [
                    "Python",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        result = self.function(spells,potions,success)\\n        return result\\n    \\n    def function(self,arr1,arr2,success):\\n        n2 = len(arr2)\\n        arr2.sort() #Sorting Enables Us To Do Binary Search\\n        ans = []\\n        for i in arr1:\\n            val = math.ceil(success/i) #Finding the Value Of Portion With Least Strength So That It Can Be Greater Than Success\\n            idx = bisect.bisect_left(arr2,val) #Finding The Left Most Index So That The Value Can Be Inserted\\n            res = n2-idx+1  #Calculating the remaining numbers after finding the suitable index\\n            ans.append(res-1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139016,
                "title": "binary-search-python-easy-to-understand",
                "content": "Idea:\\nThe pretty straightforward solution, sort potions and for each spell find an index of minimal potions that will make success and we know that everything greater will make a success too. \\n\\n\\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        ans = []\\n        for i in spells:\\n            cur = success/i\\n            ans.append(len(potions)-bisect.bisect_left(potions, cur))\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        ans = []\\n        for i in spells:\\n            cur = success/i\\n            ans.append(len(potions)-bisect.bisect_left(potions, cur))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138968,
                "title": "priority-queue-c-max-heap-easy-understanding-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> ans;\\n        priority_queue<int> pq;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<potions.size();i++)\\n            pq.push(potions[i]);\\n        vector<int> spells1=spells;\\n        sort(spells.begin(),spells.end());\\n        int cnt=0;\\n        for(int i=0;i<=spells.size()-1;i++)\\n        {\\n            while(!pq.empty())\\n            {\\n                int x=pq.top();\\n                if((long long) x* (long long) spells[i]>=success) {cnt++; pq.pop();}\\n                else\\n                  break;\\n            }\\n            mp[spells[i]]=cnt;\\n        }\\n        for(int i=0;i<spells.size();i++)\\n        {\\n            ans.push_back(mp[spells1[i]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> ans;\\n        priority_queue<int> pq;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<potions.size();i++)\\n            pq.push(potions[i]);\\n        vector<int> spells1=spells;\\n        sort(spells.begin(),spells.end());\\n        int cnt=0;\\n        for(int i=0;i<=spells.size()-1;i++)\\n        {\\n            while(!pq.empty())\\n            {\\n                int x=pq.top();\\n                if((long long) x* (long long) spells[i]>=success) {cnt++; pq.pop();}\\n                else\\n                  break;\\n            }\\n            mp[spells[i]]=cnt;\\n        }\\n        for(int i=0;i<spells.size();i++)\\n        {\\n            ans.push_back(mp[spells1[i]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138935,
                "title": "sort-potions-and-apply-binary-search-c-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long k) {\\n        sort(potions.begin(),potions.end());\\n        int n = spells.size(), m = potions.size();\\n        int i = 0, j = 0;\\n        vector<int> res;\\n        for(int i=0;i<n;i++){\\n            int l = 0, h = m;\\n            long long c1 = spells[i];\\n            while(l<h){\\n                int mid = (l+h)/2;\\n                long long c2 = potions[mid];\\n                long long cur = c1*c2;\\n                if(cur<k) l = mid+1;\\n                else if(cur>=k) h = mid;\\n            }\\n            res.push_back(m-h);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long k) {\\n        sort(potions.begin(),potions.end());\\n        int n = spells.size(), m = potions.size();\\n        int i = 0, j = 0;\\n        vector<int> res;\\n        for(int i=0;i<n;i++){\\n            int l = 0, h = m;\\n            long long c1 = spells[i];\\n            while(l<h){\\n                int mid = (l+h)/2;\\n                long long c2 = potions[mid];\\n                long long cur = c1*c2;\\n                if(cur<k) l = mid+1;\\n                else if(cur>=k) h = mid;\\n            }\\n            res.push_back(m-h);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138781,
                "title": "ceil-binary-search",
                "content": "\\ttypedef long long ll;\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> successfulPairs(vector<int>& spells, vector<int>& portions, long long success) {\\n\\t\\t\\tsort(begin(portions),end(portions));\\n\\t\\t\\tvector<int>res;\\n\\t\\t\\tint m = portions.size();\\n\\t\\t\\tfor(auto num:spells){\\n\\t\\t\\t\\tif(success/num>=100001){\\n\\t\\t\\t\\t\\tres.push_back(0);\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tint n = success/num + (success%num!=0);\\n\\t\\t\\t\\tint i = lower_bound(begin(portions),end(portions),n)-begin(p);\\n\\t\\t\\t\\tres.push_back(m-i);\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> successfulPairs(vector<int>& spells, vector<int>& portions, long long success) {\\n\\t\\t\\tsort(begin(portions),end(portions));\\n\\t\\t\\tvector<int>res;\\n\\t\\t\\tint m = portions.size();\\n\\t\\t\\tfor(auto num:spells){\\n\\t\\t\\t\\tif(success/num>=100001){\\n\\t\\t\\t\\t\\tres.push_back(0);\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 4012507,
                "title": "successful-pairs-of-spells-and-potions-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n=potions.size();\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans;\\n        for(long it: spells)\\n        {\\n            int start=0;\\n            int end=n-1;\\n            int count=0;\\n            \\n            while(start<=end)\\n            {\\n                int mid=(start+end)/2;\\n                if(it*potions[mid]>=success)\\n                {\\n                    count+=end-mid+1;\\n                    end=mid-1;\\n                }\\n                else\\n                    start=mid+1;\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n=potions.size();\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans;\\n        for(long it: spells)\\n        {\\n            int start=0;\\n            int end=n-1;\\n            int count=0;\\n            \\n            while(start<=end)\\n            {\\n                int mid=(start+end)/2;\\n                if(it*potions[mid]>=success)\\n                {\\n                    count+=end-mid+1;\\n                    end=mid-1;\\n                }\\n                else\\n                    start=mid+1;\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777754,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n=potions.size();\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans;\\n        for(long it: spells)\\n        {\\n            int start=0;\\n            int end=n-1;\\n            int count=0;\\n            \\n            while(start<=end)\\n            {\\n                int mid=(start+end)/2;\\n                if(it*potions[mid]>=success)\\n                {\\n                    count+=end-mid+1;\\n                    end=mid-1;\\n                }\\n                else\\n                    start=mid+1;\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n=potions.size();\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans;\\n        for(long it: spells)\\n        {\\n            int start=0;\\n            int end=n-1;\\n            int count=0;\\n            \\n            while(start<=end)\\n            {\\n                int mid=(start+end)/2;\\n                if(it*potions[mid]>=success)\\n                {\\n                    count+=end-mid+1;\\n                    end=mid-1;\\n                }\\n                else\\n                    start=mid+1;\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3374919,
                "title": "java-solution-binary-search-technique",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis code takes two arrays, spells and potions, and a success value as input. It then sorts the potions array and creates a new integer array pairs with the same length as the spells array.\\n\\nFor each element spells[i] in the spells array, the code performs a binary search on the potions array to find the largest index low such that the product of spells[i] and the potion at index low is less than success. This is done by comparing the product of spells[i] and the middle element of the remaining subarray with success, and narrowing the search space accordingly.\\n\\nOnce the binary search is completed, the code sets pairs[i] to the number of elements in the potions array that are greater than or equal to potions[low]. Since the potions array is sorted in ascending order, this value corresponds to the number of pairs of spells[i] and potions[j] such that their product is greater than or equal to success.\\n\\nThe pairs array is then returned as the result.\\n\\nIn summary, the code computes the number of successful pairs of spells and potions, where a pair is considered successful if the product of the two elements is greater than or equal to a given threshold success.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBinary Search\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int[] pairs = new int[spells.length];\\n        for (int i = 0; i < spells.length; i++) {\\n            int low = 0, high = potions.length - 1;\\n            while (low <= high) {\\n                int mid = (low + high) / 2;\\n                if ((long) spells[i] * potions[mid] >= success) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            }\\n            pairs[i] = potions.length - low;\\n        }\\n        return pairs;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int[] pairs = new int[spells.length];\\n        for (int i = 0; i < spells.length; i++) {\\n            int low = 0, high = potions.length - 1;\\n            while (low <= high) {\\n                int mid = (low + high) / 2;\\n                if ((long) spells[i] * potions[mid] >= success) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            }\\n            pairs[i] = potions.length - low;\\n        }\\n        return pairs;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372258,
                "title": "using-binary-search-in-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf you divide each element of potions from the success, you can get some information about how much the spell should be. Then by sorting the new array and using binary search you can find the number of element which is less than or equal to the spell\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n\\n# If you like, please upvote!\\n\\n# Code\\n```\\n/**\\n * @param {number[]} spells\\n * @param {number[]} potions\\n * @param {number} success\\n * @return {number[]}\\n */\\nvar successfulPairs = function(spells, potions, success) {\\n    let arr = [];\\n    for(let potion of potions) {\\n        arr.push(Math.ceil(success / potion));\\n    }\\n    arr.sort((a,b) => a-b);\\n    const n = arr.length;\\n    console.log(arr);\\n\\n    const res = [];\\n    for(let spell of spells) {\\n        let l=0, r=n-1, M=0;\\n        while(l<=r) {\\n            let m = Math.floor((l+r)/2);\\n            if(arr[m] <= spell) {\\n                l = m+1;\\n                M = l;\\n            } else {\\n                r = m-1;\\n            }\\n        }\\n        res.push(M);\\n    }  \\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} spells\\n * @param {number[]} potions\\n * @param {number} success\\n * @return {number[]}\\n */\\nvar successfulPairs = function(spells, potions, success) {\\n    let arr = [];\\n    for(let potion of potions) {\\n        arr.push(Math.ceil(success / potion));\\n    }\\n    arr.sort((a,b) => a-b);\\n    const n = arr.length;\\n    console.log(arr);\\n\\n    const res = [];\\n    for(let spell of spells) {\\n        let l=0, r=n-1, M=0;\\n        while(l<=r) {\\n            let m = Math.floor((l+r)/2);\\n            if(arr[m] <= spell) {\\n                l = m+1;\\n                M = l;\\n            } else {\\n                r = m-1;\\n            }\\n        }\\n        res.push(M);\\n    }  \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3372158,
                "title": "easy-solutions-in-java-and-c-look-at-once-with-explanation",
                "content": "# Intuition\\nFor each spell, we need to find the number of potions that can form a succesfull pair with it means if we multiple the `spell[i]` with `potions[i]` and the value if `>=` success we can call it successful. We are iterating over all the spells and finding the particular potions from where all the upper potion can be successful and lower than that particular potion rest can\\'t make successful.\\nFor finding that particular point of potions vector we sort it and apply binary search as we can easily trim the search space in every turn.\\n\\n# Approach\\n1. Sort the `potions` in ascending order.\\n2. For each spell `s[i]`, calculate the maximum number of potions that can be paired with it such that their sum is less than or equal to success.\\n- I have created a maxNumber which hold the value of `(spell[i]/success)`, it tells us the minimum number which we should we multiply with `spell[i]` to get the success.\\n- if the `spell[i]` divides the success completely (for eg. 25 is success and we have `spell[i]` with a strength of 5 which mean we need minimum 5 to make success) that\\'s why i did `maxNumber - 1` in the case of `number % success == 0`\\n- else we simply take the ceil of `number / success`\\n- the `low` will has the the index of the number which is just greater than the required number so return `(potions.size() - low)` will gives the count of the number that are greater than it.\\n3. I have used binary search to find the number of potions in `potions` that have a value less than or equal to the maximum number of potions calculated in `step 2`.\\n4. Append the number of potions found in step 3 to the ans vector.\\n\\n# Complexity\\n- Time complexity:-\\nThe time complexity of the `successfulPairs` function is $$O(n log m)$$ where `n` is the length of the spells vector and `m` is the length of the potions vector. The time complexity of the `calculate` function is $$O(log m)$$ where `m` is the length of the potions \\n\\n- Space complexity:-\\nThe space complexity is $$O(1)$$ since they use constant extra space.\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n\\n    int calculate(int number, vector<int>& potions, long long success){\\n    long long maxNumber;\\n    if (success % number == 0){\\n        maxNumber = (success/number)-1;\\n    }\\n    else{\\n        maxNumber = ceil(success/number);\\n    }\\n    int low = 0;\\n    int high = potions.size() - 1;\\n    while(low <= high){\\n        int mid = (high + low) >> 1;\\n        if (potions[mid] <= maxNumber) low = mid+1;\\n        else high = mid - 1;\\n    }\\n    high = potions.size();\\n    return (high - low);\\n    }\\n\\n\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans;\\n        for(int i=0; i<spells.size(); i++){\\n            int pair = calculate(spells[i], potions, success);\\n            ans.push_back(pair);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# Java Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length;\\n        int m = potions.length;\\n        int[] pairs = new int[n];\\n        Arrays.sort(potions);\\n        for (int i = 0; i < n; i++) {\\n            int spell = spells[i];\\n            int left = 0;\\n            int right = m - 1;\\n            while (left <= right) {\\n                int mid = left + (right - left) / 2;\\n                long product = (long) spell * potions[mid];\\n                if (product >= success) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n            pairs[i] = m - left;\\n        }\\n        return pairs;\\n    }\\n}\\n```\\n### Read This \\uD83D\\uDC47\\n\\n**Hope it helps you \\uD83D\\uDE0A Keep Learning**\\n- If you didn\\'t understand anything ask in comment as no-one is perfect.\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int calculate(int number, vector<int>& potions, long long success){\\n    long long maxNumber;\\n    if (success % number == 0){\\n        maxNumber = (success/number)-1;\\n    }\\n    else{\\n        maxNumber = ceil(success/number);\\n    }\\n    int low = 0;\\n    int high = potions.size() - 1;\\n    while(low <= high){\\n        int mid = (high + low) >> 1;\\n        if (potions[mid] <= maxNumber) low = mid+1;\\n        else high = mid - 1;\\n    }\\n    high = potions.size();\\n    return (high - low);\\n    }\\n\\n\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans;\\n        for(int i=0; i<spells.size(); i++){\\n            int pair = calculate(spells[i], potions, success);\\n            ans.push_back(pair);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length;\\n        int m = potions.length;\\n        int[] pairs = new int[n];\\n        Arrays.sort(potions);\\n        for (int i = 0; i < n; i++) {\\n            int spell = spells[i];\\n            int left = 0;\\n            int right = m - 1;\\n            while (left <= right) {\\n                int mid = left + (right - left) / 2;\\n                long product = (long) spell * potions[mid];\\n                if (product >= success) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n            pairs[i] = m - left;\\n        }\\n        return pairs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372127,
                "title": "successful-pairs-of-spells-and-potions-python-solution",
                "content": "# Intuition\\n\\n\\n# Approach\\nBinary Search \\n\\n# Complexity\\n- Time complexity: O(logn)\\n\\n- Space complexity: O(1)\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def successfulPairs(self, spells, potions, success):\\n        n = len(spells)\\n        m = len(potions)\\n        pairs = [None] * n\\n        potions.sort()\\n        for i in range(n):\\n            spell = spells[i]\\n            left = 0\\n            right = m - 1\\n            while left <= right:\\n                mid = left + (right - left) // 2\\n                product = spell * potions[mid]\\n                if product >= success:\\n                    right = mid - 1\\n                else:\\n                    left = mid + 1\\n            pairs[i] = m - left\\n        return pairs\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def successfulPairs(self, spells, potions, success):\\n        n = len(spells)\\n        m = len(potions)\\n        pairs = [None] * n\\n        potions.sort()\\n        for i in range(n):\\n            spell = spells[i]\\n            left = 0\\n            right = m - 1\\n            while left <= right:\\n                mid = left + (right - left) // 2\\n                product = spell * potions[mid]\\n                if product >= success:\\n                    right = mid - 1\\n                else:\\n                    left = mid + 1\\n            pairs[i] = m - left\\n        return pairs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371871,
                "title": "why-this-solution-is-not-accepted",
                "content": "Why This solution is not accepted, I see no TLE\\'s, \\nExactly want to know, why this TC is breaking the logic.\\n\\n\\nAlthough 48 passed out of 56 \\uD83E\\uDD72\\n\\n![Screenshot 2023-04-03 at 12.09.29 AM.png](https://assets.leetcode.com/users/images/caddea78-8146-444a-b0ea-a3215012d623_1680461180.6110756.png)\\n\\nRegards",
                "solutionTags": [
                    "Java"
                ],
                "code": "Why This solution is not accepted, I see no TLE\\'s, \\nExactly want to know, why this TC is breaking the logic.\\n\\n\\nAlthough 48 passed out of 56 \\uD83E\\uDD72\\n\\n![Screenshot 2023-04-03 at 12.09.29 AM.png](https://assets.leetcode.com/users/images/caddea78-8146-444a-b0ea-a3215012d623_1680461180.6110756.png)\\n\\nRegards",
                "codeTag": "Unknown"
            },
            {
                "id": 3371657,
                "title": "easy-cpp-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N LOG M)\\n\\n- Space complexity:\\n- O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& arr, vector<int>& nums, long long success) {\\n        sort(nums.begin(),nums.end());\\n        vector<int> msxans;\\n        for(int i = 0;i<arr.size();i++){\\n            int s = 0;\\n            int e = nums.size()-1;\\n            int ans = -1;\\n            while(s<=e){\\n            int mid = s + (e - s)/2;\\n            long long value = (long)nums[mid]*arr[i] ; \\n                if(value >= success){\\n                    ans = mid;\\n                    e = mid - 1;\\n                }\\n                else s = mid + 1;\\n            }\\n            if(ans != -1) {\\n               msxans.push_back(nums.size()-ans);\\n            }\\n            else msxans.push_back(0);\\n        }\\n        return msxans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& arr, vector<int>& nums, long long success) {\\n        sort(nums.begin(),nums.end());\\n        vector<int> msxans;\\n        for(int i = 0;i<arr.size();i++){\\n            int s = 0;\\n            int e = nums.size()-1;\\n            int ans = -1;\\n            while(s<=e){\\n            int mid = s + (e - s)/2;\\n            long long value = (long)nums[mid]*arr[i] ; \\n                if(value >= success){\\n                    ans = mid;\\n                    e = mid - 1;\\n                }\\n                else s = mid + 1;\\n            }\\n            if(ans != -1) {\\n               msxans.push_back(nums.size()-ans);\\n            }\\n            else msxans.push_back(0);\\n        }\\n        return msxans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370989,
                "title": "day92-binary-search-very-easy-solution",
                "content": "# Intuition and Approach\\nWe have implemented Binary Search to Solve the problem\\n\\nSo, Condition to use binary tree is that array must be sorted\\n\\nSo, we used the inbuilt sort function.\\n\\nNow to solve the problem many of you have already tried to do it in O(n^2) order (Code given below) but it is giving the TLE.\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& po, long long success) {\\n        vector<int> v;\\n        int count=0;\\n\\n        for(int i=0;i<s.size();i++){\\n            for(int j=0;j<po.size();j++){\\n                if(s[i]*po[j] >= success){\\n                    count++;\\n                }\\n            }\\n            v.push_back(count);\\n            count=0;\\n        }\\n        return v;\\n    }\\n};\\n```\\n(In above approach we are simply calulating the product of two array and comparing it to Success)\\nSo, to overcome the TLE we have to think a way to minimize our search space and hence Binary Search came into play\\n\\nThere is an **Observation** for sorted array which is that if a current potion muliplied with current spell and if it greater than Success then all elements ahead of that position will be a satisfiable answer.\\n```\\ne.g. spells=[5,3,1] , potion=[1,2,3,4,5] , Success=7\\nAns: 5*1=5, 5*2=10, 5*3=15, 5*4=20, 5*5=25\\n              |\\n              |--from here, all ahead value will be greater than Success\\nSimilarly, 3*1=3, 3*2=6, 3*3=9...\\n                           |\\n                           |--from here, all value satisfy the Success\\n*Hence, we have to calculate or find the leftmost value which satisfies \\nthe relation.\\n```\\nSo, We are using binary search to find that value by using the condition you can check it in the code.\\n\\n**Upvote If you like.**\\n# Complexity\\n- Time complexity:O(n*log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& po, long long success) {\\n        vector<int> v;\\n        //sorting the potion array\\n        sort(po.begin(),po.end());\\n\\n        for(int i=0;i<s.size();i++){\\n            int count=0;\\n            int l=0,r=po.size()-1;\\n            int mid=l + (r-l)/2;\\n            //Using Binary Search on potion array\\n            while(l<=r){\\n                if(s[i]*1ll*po[mid] >= success){//1LL is securely integer overflow\\n                    count=po.size()-mid;\\n                    r=mid-1;\\n                }\\n                else{\\n                    l=mid+1;\\n                }\\n                mid= l + (r-l)/2;\\n            }\\n            v.push_back(count);\\n        }\\n        \\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& po, long long success) {\\n        vector<int> v;\\n        int count=0;\\n\\n        for(int i=0;i<s.size();i++){\\n            for(int j=0;j<po.size();j++){\\n                if(s[i]*po[j] >= success){\\n                    count++;\\n                }\\n            }\\n            v.push_back(count);\\n            count=0;\\n        }\\n        return v;\\n    }\\n};\\n```\n```\\ne.g. spells=[5,3,1] , potion=[1,2,3,4,5] , Success=7\\nAns: 5*1=5, 5*2=10, 5*3=15, 5*4=20, 5*5=25\\n              |\\n              |--from here, all ahead value will be greater than Success\\nSimilarly, 3*1=3, 3*2=6, 3*3=9...\\n                           |\\n                           |--from here, all value satisfy the Success\\n*Hence, we have to calculate or find the leftmost value which satisfies \\nthe relation.\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& po, long long success) {\\n        vector<int> v;\\n        //sorting the potion array\\n        sort(po.begin(),po.end());\\n\\n        for(int i=0;i<s.size();i++){\\n            int count=0;\\n            int l=0,r=po.size()-1;\\n            int mid=l + (r-l)/2;\\n            //Using Binary Search on potion array\\n            while(l<=r){\\n                if(s[i]*1ll*po[mid] >= success){//1LL is securely integer overflow\\n                    count=po.size()-mid;\\n                    r=mid-1;\\n                }\\n                else{\\n                    l=mid+1;\\n                }\\n                mid= l + (r-l)/2;\\n            }\\n            v.push_back(count);\\n        }\\n        \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370506,
                "title": "binary-search-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& S, vector<int>& P, long long k) {\\n        int n = size(P);\\n        sort(begin(P),end(P));\\n        vector<int> ans;\\n        for(long long&&s: S){\\n            long long req = k%s ? k/s+1 : k/s;\\n            int idx = lower_bound(begin(P),end(P),req) - begin(P);\\n            if(idx < n) ans.push_back(n-idx);\\n            else ans.push_back(0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& S, vector<int>& P, long long k) {\\n        int n = size(P);\\n        sort(begin(P),end(P));\\n        vector<int> ans;\\n        for(long long&&s: S){\\n            long long req = k%s ? k/s+1 : k/s;\\n            int idx = lower_bound(begin(P),end(P),req) - begin(P);\\n            if(idx < n) ans.push_back(n-idx);\\n            else ans.push_back(0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370172,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem.\\n -->\\nOnce you figure it out that if you get the smallest potion value multiply by the spell is greater than equal to success in sorted potion array. Then no need to calculate potion[i]*spell[j] for every index. And you can directly calculate number of potion by potion.length - (index of smallest potion greater than or equal to success)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort the potion array in ascending order\\n2. Iterate orver all the spells value.\\n3. Apply binary search on potion array and find the value of mid such that index of smallest potion greater than or equal to success.\\n4. Caluculate answer for each index as potion.length - l(lower index)\\n5. Store the value in result array and return\\n# Complexity\\n- Time complexity: O(nlogm + mlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n) depending upon sorting algorithm\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public static int bs(int[] potions,int spell, long success){\\n        int l=0;\\n        int r=potions.length-1;\\n\\n        while(l<=r){\\n            int m = l - (l-r)/2;\\n            long mul =(long) potions[m]*spell;\\n            if(mul>=success){\\n                r=m-1;\\n            }\\n            else{\\n                l=m+1;\\n            }\\n        }\\n        return potions.length-l;\\n    }\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int res[] = new int[spells.length];\\n        Arrays.sort(potions);\\n        for(int i=0;i<spells.length;i++){\\n            res[i] = bs(potions,spells[i],success);\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public static int bs(int[] potions,int spell, long success){\\n        int l=0;\\n        int r=potions.length-1;\\n\\n        while(l<=r){\\n            int m = l - (l-r)/2;\\n            long mul =(long) potions[m]*spell;\\n            if(mul>=success){\\n                r=m-1;\\n            }\\n            else{\\n                l=m+1;\\n            }\\n        }\\n        return potions.length-l;\\n    }\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int res[] = new int[spells.length];\\n        Arrays.sort(potions);\\n        for(int i=0;i<spells.length;i++){\\n            res[i] = bs(potions,spells[i],success);\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370155,
                "title": "java-binary-search-explained",
                "content": "# Intuition:\\nA brute force would\\'ve been easy but the constraints don\\'t let us.\\n\\nWe just need the number of elements in `potions` which when multiplied by a particular number (from `spells`) gives the value greater than or equal to `success`.\\n\\nSo if we sort the array `potions`, we can apply a binary search to reach the starting index in `potions` from where onwards all the products yield value >= `success`.\\n\\nThe number of elements that yields product >= `success` is equal to:\\n`length of potions - starting index`\\n\\n---\\n\\n# Code:\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length, m = potions.length;\\n        Arrays.sort(potions);\\n        int[] pairs = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            int startIdx = findStartIndex(spells[i], potions, success);\\n            pairs[i] = m - startIdx;\\n        }\\n        return pairs;\\n    }\\n\\n    private int findStartIndex(int spell, int[] potions, long success) {\\n        int m = potions.length;\\n        int lo = 0, hi = m - 1;\\n        // Initialise the start index as the length of potions array\\n        // because there might be a case when all the potion strengths\\n        // when multiplied by spell strength gave a less product value than success\\n        // so when we do potions.length - startIdx, it will automatically become 0\\n        // because start index will never get updated to a lesser value (mid)\\n        int startIdx = m;\\n        while (lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            long prod = 1L * spell * potions[mid];\\n            // if product is >= success\\n            if (prod >= success) {\\n                // save this potential start index\\n                startIdx = mid;\\n                // look for a lesser potion strength\\n                hi = mid - 1;\\n            } else {\\n                // product was too less\\n                // go for a greater potion strength\\n                lo = mid + 1;\\n            }\\n        }\\n        return startIdx;\\n    }\\n}\\n```\\n---\\n### Clean solution:\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length, m = potions.length;\\n        Arrays.sort(potions);\\n        int[] pairs = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            int startIdx = findStartIndex(spells[i], potions, success);\\n            pairs[i] = m - startIdx;\\n        }\\n        return pairs;\\n    }\\n\\n    private int findStartIndex(int spell, int[] potions, long success) {\\n        int m = potions.length;\\n        int lo = 0, hi = m - 1;\\n        int startIdx = m;\\n        while (lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            long prod = 1L * spell * potions[mid];\\n            if (prod >= success) {\\n                startIdx = mid;\\n                hi = mid - 1;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        return startIdx;\\n    }\\n}\\n```\\n---\\n##### Time complexity: $$O(2.n.logm)$$\\n\\n##### Space complexity: $$O(n)$$",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length, m = potions.length;\\n        Arrays.sort(potions);\\n        int[] pairs = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            int startIdx = findStartIndex(spells[i], potions, success);\\n            pairs[i] = m - startIdx;\\n        }\\n        return pairs;\\n    }\\n\\n    private int findStartIndex(int spell, int[] potions, long success) {\\n        int m = potions.length;\\n        int lo = 0, hi = m - 1;\\n        // Initialise the start index as the length of potions array\\n        // because there might be a case when all the potion strengths\\n        // when multiplied by spell strength gave a less product value than success\\n        // so when we do potions.length - startIdx, it will automatically become 0\\n        // because start index will never get updated to a lesser value (mid)\\n        int startIdx = m;\\n        while (lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            long prod = 1L * spell * potions[mid];\\n            // if product is >= success\\n            if (prod >= success) {\\n                // save this potential start index\\n                startIdx = mid;\\n                // look for a lesser potion strength\\n                hi = mid - 1;\\n            } else {\\n                // product was too less\\n                // go for a greater potion strength\\n                lo = mid + 1;\\n            }\\n        }\\n        return startIdx;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length, m = potions.length;\\n        Arrays.sort(potions);\\n        int[] pairs = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            int startIdx = findStartIndex(spells[i], potions, success);\\n            pairs[i] = m - startIdx;\\n        }\\n        return pairs;\\n    }\\n\\n    private int findStartIndex(int spell, int[] potions, long success) {\\n        int m = potions.length;\\n        int lo = 0, hi = m - 1;\\n        int startIdx = m;\\n        while (lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            long prod = 1L * spell * potions[mid];\\n            if (prod >= success) {\\n                startIdx = mid;\\n                hi = mid - 1;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        return startIdx;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370136,
                "title": "simple-solution-using-sorting-and-lower-bound-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAfter looking at the question the intuition that comes to my mind is to sort the potions vector and corresponding to every spell value will find the index of the minimum value in the potions vector whose value becomes equal to or greater than the success value given to us.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe have to find how many potions are there whose multiplication with that particular spell value is greater than or equal to the success value given to us. \\n\\nThe first thing that comes to mind is to sort that potions vector. Now try to find the index of that minimum value in the potions vector whose multiplication with the particular spell value becomes equal to or surpasses the success value given to us. (Ofcourse the values after that particular index will satisfy the criteria because we already sorted the vector in the first place.)\\n\\nWe will use lower_bound function here, which returns the iterator of that particular value if that particular value is present in the vector. And if that particular value is not present in the vector it will give us the iterator of the value which is greater than that value. We\\'ll then subtract this iterator from the base iterator(potions.begin()) to find the index. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe for loop is running for n times where n = spells.size() and the lower bound function takes logN time where N - potions.size().\\n\\nSo the TOTAL TIME COMPLEXITY IS O(nlogN);\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe are using space to store the ans only. so the space complexity O(n) where n = spells.size()\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n\\n        vector<int> ans;\\n        sort(potions.begin(),potions.end());\\n\\n        \\n        for(int i=0; i<spells.size(); i++){\\n            long long value = ceil(success/(spells[i]*1.0));\\n            auto it = lower_bound(potions.begin(),potions.end(),value);\\n\\n            int res = 0;\\n\\n            if(it!=potions.end()){\\n                int ind = it-potions.begin();\\n                res += potions.size()-ind;\\n                ans.push_back(res);\\n            }\\n            else{\\n                ans.push_back(0);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n\\n        vector<int> ans;\\n        sort(potions.begin(),potions.end());\\n\\n        \\n        for(int i=0; i<spells.size(); i++){\\n            long long value = ceil(success/(spells[i]*1.0));\\n            auto it = lower_bound(potions.begin(),potions.end(),value);\\n\\n            int res = 0;\\n\\n            if(it!=potions.end()){\\n                int ind = it-potions.begin();\\n                res += potions.size()-ind;\\n                ans.push_back(res);\\n            }\\n            else{\\n                ans.push_back(0);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370096,
                "title": "binary-search-beats100-runtime-and-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# **Please upvote the solution if you like it.**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe binSearch function is a recursive binary search algorithm that searches for a given element (the success variable) in a sorted array (the potions vector) based on a comparison between the product of the middle element of the array and a given integer (the pro variable) and the success variable. If the product is greater than or equal to success, the index variable is updated with the current index of the middle element and the algorithm continues the search on the left half of the array. If the product is less than success, the algorithm continues the search on the right half of the array. The function stops when the element is found or when the search range is empty.\\n\\nThe successfulPairs function takes in two vectors of integers, spells and potions, and a success variable of type long long. It first sorts the potions vector. Then, for each element in the spells vector, it calls the binSearch function to find the number of elements in the potions vector that form a successful pair with the current element in the spells vector, i.e., the number of elements in the potions vector whose product with the current element is greater than or equal to success. This number is then stored in the corresponding index of the spells vector. If no such elements exist, the corresponding index in the spells vector is set to 0. Finally, the spells vector is returned.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(mlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int index=-1;\\n    void binSearch(vector<int>& potions,int low,int high,long long success,int pro){\\n        if(low>high){\\n            return;\\n        }\\n        int mid = low+(high-low)/2;\\n        if((long long)potions[mid]*(long long)pro>=success){\\n            index=mid;\\n            binSearch(potions,low,mid-1,success,pro);\\n        }\\n        else{\\n            binSearch(potions,mid+1,high,success,pro);\\n        }\\n    }\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        ios_base::sync_with_stdio(false);\\n        sort(potions.begin(),potions.end());\\n        for(int i=0;i<spells.size();i++){\\n            binSearch(potions,0,potions.size()-1,success,spells[i]);\\n            if(index==-1){\\n                spells[i]=0;\\n            }\\n            else{\\n                spells[i]=potions.size()-index;\\n            }\\n            index=-1;\\n        }\\n        return spells;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int index=-1;\\n    void binSearch(vector<int>& potions,int low,int high,long long success,int pro){\\n        if(low>high){\\n            return;\\n        }\\n        int mid = low+(high-low)/2;\\n        if((long long)potions[mid]*(long long)pro>=success){\\n            index=mid;\\n            binSearch(potions,low,mid-1,success,pro);\\n        }\\n        else{\\n            binSearch(potions,mid+1,high,success,pro);\\n        }\\n    }\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        ios_base::sync_with_stdio(false);\\n        sort(potions.begin(),potions.end());\\n        for(int i=0;i<spells.size();i++){\\n            binSearch(potions,0,potions.size()-1,success,spells[i]);\\n            if(index==-1){\\n                spells[i]=0;\\n            }\\n            else{\\n                spells[i]=potions.size()-index;\\n            }\\n            index=-1;\\n        }\\n        return spells;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370026,
                "title": "simple-commented-c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        // Sort the potions array as we will use binary search here...\\n        sort(potions.begin(),potions.end());\\n        \\n        // Declaring the answer array...\\n        vector<int> ans(spells.size(),0);\\n        \\n        for(int i = 0; i < spells.size(); i++){\\n            long long n = spells[i];\\n            \\n            // the required element can be calculated as follows...\\n            long long int req = (success/n) + (success%n != 0);\\n            \\n            // if the required element is found then all the elements greater than \"req\" will satisfy the condition...\\n            int indx = lower_bound(potions.begin(),potions.end(),req) - potions.begin();\\n            \\n            // taking all elements greater than  and equal to \"req\"...\\n            ans[i] = potions.size() - indx;\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        // Sort the potions array as we will use binary search here...\\n        sort(potions.begin(),potions.end());\\n        \\n        // Declaring the answer array...\\n        vector<int> ans(spells.size(),0);\\n        \\n        for(int i = 0; i < spells.size(); i++){\\n            long long n = spells[i];\\n            \\n            // the required element can be calculated as follows...\\n            long long int req = (success/n) + (success%n != 0);\\n            \\n            // if the required element is found then all the elements greater than \"req\" will satisfy the condition...\\n            int indx = lower_bound(potions.begin(),potions.end(),req) - potions.begin();\\n            \\n            // taking all elements greater than  and equal to \"req\"...\\n            ans[i] = potions.size() - indx;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3369972,
                "title": "easy-python-solution-using-bisect",
                "content": "# Code\\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        lst=[]\\n        potions.sort()\\n        ln=len(potions)\\n        for i in spells:\\n            t = bisect_left(potions, success/i)\\n            lst.append(ln-t)\\n        return lst\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        lst=[]\\n        potions.sort()\\n        ln=len(potions)\\n        for i in spells:\\n            t = bisect_left(potions, success/i)\\n            lst.append(ln-t)\\n        return lst\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369558,
                "title": "java-solution-for-beginners-with-simple-explanation-and-some-additional-tips",
                "content": "# Intuition\\nBinary Search\\n\\n# Approach\\nStep 1 : Sort potions \\nStep 2 : get number of pair of successful potions and spells by using binary search. Try finding smallest element in potions which can give you successful pair by subtracting index of samllest element by length of potions.\\nStep 3 : store all the value in ans[] and return ans.\\n\\n\\n# Tips\\n1. In below code you can store ans[] values into spells[] which can help you reduce space complexity from O(n) to O(1). \\n\\n2. Instead of using function couSuc you can do binary search in for loop instead to save some more time. \\n\\n# Advantages\\n1. This approach gives you consistent result and it is favorable for very large array. \\n\\n2. This code can be done in space complexity of O(1) instead of O(n). which makes it space efficient. \\n\\n# Disadvantages\\n1. It is slower for small array. two Poiner method is favorable for smaler array\\n\\n# Complexity\\n- Time complexity:\\n O(n log n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int ans[] = new int[spells.length];\\n        for(int i=0;i<spells.length;i++){\\n            ans[i]=couSuc(spells[i],potions,success);\\n        }\\n        return ans;\\n    }\\n    private int couSuc(int a, int[] arr, long b){\\n        int start=0,end=arr.length;\\n        while(start<end){\\n            int mid=start+(end-start)/2;\\n            if((long)arr[mid]*a>=b){\\n                end=mid;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return arr.length-start;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int ans[] = new int[spells.length];\\n        for(int i=0;i<spells.length;i++){\\n            ans[i]=couSuc(spells[i],potions,success);\\n        }\\n        return ans;\\n    }\\n    private int couSuc(int a, int[] arr, long b){\\n        int start=0,end=arr.length;\\n        while(start<end){\\n            int mid=start+(end-start)/2;\\n            if((long)arr[mid]*a>=b){\\n                end=mid;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return arr.length-start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369472,
                "title": "easy-approach-sorting-binary-search",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst Sort the potion array and then use the binary search in this array to find the first index whose product with the spells would be equal or grater than than the success.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlogm)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int[] ans = new int[spells.length];\\n        for(int i = 0 ; i < spells.length; i++){\\n            int left = 0;\\n            int right = potions.length-1;\\n            while(left <= right){\\n                int mid = (left+right)/2;\\n                if((long)spells[i]*potions[mid] < success){\\n                    left = mid+1;\\n                }\\n                else{\\n                    right = mid-1;\\n                }\\n            }\\n            ans[i] = potions.length-right-1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int[] ans = new int[spells.length];\\n        for(int i = 0 ; i < spells.length; i++){\\n            int left = 0;\\n            int right = potions.length-1;\\n            while(left <= right){\\n                int mid = (left+right)/2;\\n                if((long)spells[i]*potions[mid] < success){\\n                    left = mid+1;\\n                }\\n                else{\\n                    right = mid-1;\\n                }\\n            }\\n            ans[i] = potions.length-right-1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369463,
                "title": "sorting-binary-search-explaination-easy-java-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSort the potions array and then use binary search on potions array to get the that element whose elements of right part of the array will be greater than or equal to success given because if that particular element excceds success then all element from right will be also excceds.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length;\\n        int m = potions.length;\\n        int ans[] = new int[n];\\n        Arrays.sort(potions);\\n        for(int i = 0 ; i < n; i ++){\\n            int spell = spells[i];\\n            int low = 0;\\n            int high = m - 1;\\n            while(low <= high){\\n                int mid = (high - low)/2 + low;\\n                long product = (long)spell * (long)potions[mid];\\n                if(product >= success){\\n                    high = mid - 1;\\n                }else{\\n                    low = mid + 1;\\n                }\\n            }\\n            ans[i] = m - low;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length;\\n        int m = potions.length;\\n        int ans[] = new int[n];\\n        Arrays.sort(potions);\\n        for(int i = 0 ; i < n; i ++){\\n            int spell = spells[i];\\n            int low = 0;\\n            int high = m - 1;\\n            while(low <= high){\\n                int mid = (high - low)/2 + low;\\n                long product = (long)spell * (long)potions[mid];\\n                if(product >= success){\\n                    high = mid - 1;\\n                }else{\\n                    low = mid + 1;\\n                }\\n            }\\n            ans[i] = m - low;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369207,
                "title": "best-simple-approach-java-solution",
                "content": "# Intuition\\nSort the array. Then apply binary search.\\n\\n# Approach\\nSort the array. Then apply binary search.\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n\\n- Space complexity:O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        //sorting array so that if once we find any value>= success then next values will be automatically >= success\\n        Arrays.sort(potions);\\n        int[] result = new int[spells.length];\\n        for(int i=0;i<spells.length;i++)\\n        {\\n            //we find first value for which multiplication value >= success by binary search for reducing time complexity\\n            //then we store the number of values by calculating length- minimum index for which it satisfies\\n            result[i] = binarySearch(spells,potions,0,potions.length-1,spells[i],success);\\n        }\\n        return result;\\n    }\\n\\n    //binary search function\\n    public  int binarySearch(int[] spells,int potions[], int si, int ei,int val,long target)\\n    {\\n        while(si<=ei)\\n        {\\n            int mid = si + (ei-si)/2;\\n            if((long)val*(long)potions[mid]>=target)\\n            {\\n                if(mid==0)\\n                {\\n                    return potions.length-mid;\\n                }\\n                else if((long)val*(long)potions[mid-1]<target)\\n                {\\n                     return potions.length-mid;\\n                }\\n                else\\n                {\\n                    ei= mid-1;\\n                }\\n            }\\n            else\\n            si= mid+1;\\n        }\\n        return 0;\\n         \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        //sorting array so that if once we find any value>= success then next values will be automatically >= success\\n        Arrays.sort(potions);\\n        int[] result = new int[spells.length];\\n        for(int i=0;i<spells.length;i++)\\n        {\\n            //we find first value for which multiplication value >= success by binary search for reducing time complexity\\n            //then we store the number of values by calculating length- minimum index for which it satisfies\\n            result[i] = binarySearch(spells,potions,0,potions.length-1,spells[i],success);\\n        }\\n        return result;\\n    }\\n\\n    //binary search function\\n    public  int binarySearch(int[] spells,int potions[], int si, int ei,int val,long target)\\n    {\\n        while(si<=ei)\\n        {\\n            int mid = si + (ei-si)/2;\\n            if((long)val*(long)potions[mid]>=target)\\n            {\\n                if(mid==0)\\n                {\\n                    return potions.length-mid;\\n                }\\n                else if((long)val*(long)potions[mid-1]<target)\\n                {\\n                     return potions.length-mid;\\n                }\\n                else\\n                {\\n                    ei= mid-1;\\n                }\\n            }\\n            else\\n            si= mid+1;\\n        }\\n        return 0;\\n         \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369194,
                "title": "c-solution-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMultiply each element of potions with each element of spells  and count number of number which is greater than or equal to success.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNaive approach is using two for loop  that is in O(N*N).  but it will not run as test case is large.\\nso a better approach is using binary search (logN). Run a for loop for spells and apply binary search in potions.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NlogN)\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        sort(potions.begin(),potions.end());\\n        int spells_size=spells.size();\\n        int potions_size=potions.size();\\n        vector<int>ans;\\n        for(int i=0;i<spells_size;i++)\\n        {\\n            int start=0;\\n            int end=potions_size-1;\\n            int max_number=0;\\n            while(start<=end)\\n            {\\n                int mid=(start+end)/2;\\n                if((long long)spells[i]*(long long )potions[mid]>=success)\\n                {\\n                    end=mid-1;\\n                    max_number=max(max_number,(potions_size-mid));\\n                }\\n                else if((long long)spells[i]*(long long )potions[mid]<success)\\n                {\\n                    start=mid+1;\\n                }\\n            }\\n            ans.push_back(max_number);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        sort(potions.begin(),potions.end());\\n        int spells_size=spells.size();\\n        int potions_size=potions.size();\\n        vector<int>ans;\\n        for(int i=0;i<spells_size;i++)\\n        {\\n            int start=0;\\n            int end=potions_size-1;\\n            int max_number=0;\\n            while(start<=end)\\n            {\\n                int mid=(start+end)/2;\\n                if((long long)spells[i]*(long long )potions[mid]>=success)\\n                {\\n                    end=mid-1;\\n                    max_number=max(max_number,(potions_size-mid));\\n                }\\n                else if((long long)spells[i]*(long long )potions[mid]<success)\\n                {\\n                    start=mid+1;\\n                }\\n            }\\n            ans.push_back(max_number);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369022,
                "title": "using-binary-search-problem-of-the-day-april-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to find the minimum element from where the potions element * spell element will be greater than the succes and store the number that is greater than that.\\n \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe Naive approach will be using the two for loop which will eventually give the TLE because of contraint.\\n\\nSo the next approach will be the Binary search, firstly we have to sort the potions array for finding the minimumn potions element from where the spells[i]*potions[ele] >= success. Then by intialising an vector we will store the number of element that will be larger than that element i.e. [potions.size()-start]. Using this the Time Complexity will be: O(nlogn);\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size();\\n        vector<int> ans;\\n\\n        sort(potions.begin(),potions.end());\\n\\n        for(int ele: spells){\\n            // int ele = spells[i];\\n\\n            int start = 0;\\n            int end = potions.size();\\n\\n            while(start<end){\\n                int mid = (start + end) >> 1;\\n\\n                if(static_cast<long long>(ele) * potions[mid] >= success){\\n                    end = mid;\\n                }else{\\n                    start = mid+1;\\n                }\\n            }\\n\\n            ans.push_back(potions.size()-start);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size();\\n        vector<int> ans;\\n\\n        sort(potions.begin(),potions.end());\\n\\n        for(int ele: spells){\\n            // int ele = spells[i];\\n\\n            int start = 0;\\n            int end = potions.size();\\n\\n            while(start<end){\\n                int mid = (start + end) >> 1;\\n\\n                if(static_cast<long long>(ele) * potions[mid] >= success){\\n                    end = mid;\\n                }else{\\n                    start = mid+1;\\n                }\\n            }\\n\\n            ans.push_back(potions.size()-start);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368961,
                "title": "c-fully-commented-simple-intuitive",
                "content": "# Intuition\\nBinary Search\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is explained with the code as comments\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        //firt sort the potions array\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans;    //store the ans here\\n\\n        int n = potions.size();\\n        //iterate over the each spell\\n        for(int i = 0; i<spells.size(); i++){\\n            //check the minimum value for each spell. We are taking the ceil value. \\n            //Because as the question suggest we have to multiply that spell with potions \\n            //such that the multiplication should be greater than success.\\n            long long minLimit = success/spells[i];\\n            if(success%spells[i])\\n                minLimit++;\\n            //now find the starting position of minLimit and \\n            //add the total values larger than minLimit to your ans\\n            int cnt = lower_bound(potions.begin(), potions.end(), minLimit) - potions.begin();\\n            ans.push_back(n-cnt);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        //firt sort the potions array\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans;    //store the ans here\\n\\n        int n = potions.size();\\n        //iterate over the each spell\\n        for(int i = 0; i<spells.size(); i++){\\n            //check the minimum value for each spell. We are taking the ceil value. \\n            //Because as the question suggest we have to multiply that spell with potions \\n            //such that the multiplication should be greater than success.\\n            long long minLimit = success/spells[i];\\n            if(success%spells[i])\\n                minLimit++;\\n            //now find the starting position of minLimit and \\n            //add the total values larger than minLimit to your ans\\n            int cnt = lower_bound(potions.begin(), potions.end(), minLimit) - potions.begin();\\n            ans.push_back(n-cnt);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368926,
                "title": "javascript-java-c-and-python-solution-with-time-complexity-of-o-n-log-m",
                "content": "\\n\\n# Approach\\nSort the potions array in descending order.\\nCreate an empty hash map map to store the results.\\nFor each element in the spells array:\\na. If the element is not in the map, calculate the value of success / spells[i] and find the position of the first element in the sorted potions array that is greater than or equal to this value using a binary search. Store this position in len and add it to the res array. Also store len in the map against spells[i].\\nb. If the element is already in the map, retrieve the value of len from the map and add it to the res array.\\nReturn the res array.\\n\\n# Complexity\\n- Time complexity: O(n log m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m + n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# JavaCsript\\n```\\n/**\\n * @param {number[]} spells\\n * @param {number[]} potions\\n * @param {number} success\\n * @return {number[]}\\n */\\n var successfulPairs = function(spells, potions, success) {\\n    let res = [];\\n    potions.sort((a, b) => b-a);\\n    let map = new Map();\\n    \\n    for(let i=0; i<spells.length; i++){\\n        if(!map.has(spells[i])){\\n            let s = success / spells[i];\\n            let len = search(potions, s);\\n            res.push(len);\\n            map.set(spells[i], len);\\n        }else{\\n            let len = map.get(spells[i]);\\n            res.push(len);\\n        }\\n    }\\n    \\n    return res;\\n};\\n\\nfunction search(potions, target){\\n    let res = 0;\\n    let left = 0;\\n    let right = potions.length-1;\\n    while(left <= right){\\n        let mid = Math.floor((left + right) / 2);\\n        if(potions[mid] < target){\\n            right = mid - 1;\\n        }else{\\n            left = mid + 1;\\n            res = mid + 1;\\n        }\\n    }\\n\\n    return res;\\n}\\n```\\n# Java\\n```\\npublic class SuccessfulPairs {\\n    public static int[] successfulPairs(int[] spells, int[] potions, int success) {\\n        ArrayList<Integer> res = new ArrayList<>();\\n        int[] sortedPotions = potions.clone();\\n        Arrays.sort(sortedPotions);\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        for(int i=0; i<spells.length; i++){\\n            if(!map.containsKey(spells[i])){\\n                int s = success / spells[i];\\n                int len = search(sortedPotions, s);\\n                res.add(len);\\n                map.put(spells[i], len);\\n            }else{\\n                int len = map.get(spells[i]);\\n                res.add(len);\\n            }\\n        }\\n\\n        int[] result = new int[res.size()];\\n        for(int i=0; i<res.size(); i++){\\n            result[i] = res.get(i);\\n        }\\n        return result;\\n    }\\n\\n    public static int search(int[] potions, int target){\\n        int res = 0;\\n        int left = 0;\\n        int right = potions.length-1;\\n        while(left <= right){\\n            int mid = (left + right) / 2;\\n            if(potions[mid] < target){\\n                right = mid - 1;\\n            }else{\\n                left = mid + 1;\\n                res = mid + 1;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```\\n# C\\n```\\n\\n\\nint search(int* potions, int potionsSize, int target){\\n    int res = 0;\\n    int left = 0;\\n    int right = potionsSize-1;\\n    while(left <= right){\\n        int mid = (left + right) / 2;\\n        if(potions[mid] < target){\\n            right = mid - 1;\\n        }else{\\n            left = mid + 1;\\n            res = mid + 1;\\n        }\\n    }\\n\\n    return res;\\n}\\n\\nint* successfulPairs(int* spells, int spellsSize, int* potions, int potionsSize, int success, int* returnSize) {\\n    int* res = malloc(spellsSize * sizeof(int));\\n    int* sortedPotions = malloc(potionsSize * sizeof(int));\\n    memcpy(sortedPotions, potions, potionsSize * sizeof(int));\\n    qsort(sortedPotions, potionsSize, sizeof(int), (const void *)compare);\\n    int* map = calloc(spellsSize, sizeof(int));\\n\\n    for(int i=0; i<spellsSize; i++){\\n        if(map[spells[i]] == 0){\\n            int s = success / spells[i];\\n            int len = search(sortedPotions, potionsSize, s);\\n            res[i] = len;\\n            map[spells[i]] = len;\\n        }else{\\n            int len = map[spells[i]];\\n            res[i] = len;\\n        }\\n    }\\n    \\n    free(map);\\n    free(sortedPotions);\\n    *returnSize = spellsSize;\\n    return res;\\n}\\n\\nint compare(const void * a, const void * b) {\\n   return (*(int*)b - *(int*)a);\\n}\\n```\\n# Python\\n```\\nfrom typing import List\\nimport bisect\\n\\ndef successfulPairs(spells: List[int], potions: List[int], success: int) -> List[int]:\\n    res = []\\n    sortedPotions = sorted(potions, reverse=True)\\n    map = {}\\n\\n    for i in range(len(spells)):\\n        if spells[i] not in map:\\n            s = success / spells[i]\\n            len = bisect.bisect_left(sortedPotions, s)\\n            res.append(len)\\n            map[spells[i]] = len\\n        else:\\n            len = map[spells[i]]\\n            res.append(len)\\n\\n    return res\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} spells\\n * @param {number[]} potions\\n * @param {number} success\\n * @return {number[]}\\n */\\n var successfulPairs = function(spells, potions, success) {\\n    let res = [];\\n    potions.sort((a, b) => b-a);\\n    let map = new Map();\\n    \\n    for(let i=0; i<spells.length; i++){\\n        if(!map.has(spells[i])){\\n            let s = success / spells[i];\\n            let len = search(potions, s);\\n            res.push(len);\\n            map.set(spells[i], len);\\n        }else{\\n            let len = map.get(spells[i]);\\n            res.push(len);\\n        }\\n    }\\n    \\n    return res;\\n};\\n\\nfunction search(potions, target){\\n    let res = 0;\\n    let left = 0;\\n    let right = potions.length-1;\\n    while(left <= right){\\n        let mid = Math.floor((left + right) / 2);\\n        if(potions[mid] < target){\\n            right = mid - 1;\\n        }else{\\n            left = mid + 1;\\n            res = mid + 1;\\n        }\\n    }\\n\\n    return res;\\n}\\n```\n```\\npublic class SuccessfulPairs {\\n    public static int[] successfulPairs(int[] spells, int[] potions, int success) {\\n        ArrayList<Integer> res = new ArrayList<>();\\n        int[] sortedPotions = potions.clone();\\n        Arrays.sort(sortedPotions);\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        for(int i=0; i<spells.length; i++){\\n            if(!map.containsKey(spells[i])){\\n                int s = success / spells[i];\\n                int len = search(sortedPotions, s);\\n                res.add(len);\\n                map.put(spells[i], len);\\n            }else{\\n                int len = map.get(spells[i]);\\n                res.add(len);\\n            }\\n        }\\n\\n        int[] result = new int[res.size()];\\n        for(int i=0; i<res.size(); i++){\\n            result[i] = res.get(i);\\n        }\\n        return result;\\n    }\\n\\n    public static int search(int[] potions, int target){\\n        int res = 0;\\n        int left = 0;\\n        int right = potions.length-1;\\n        while(left <= right){\\n            int mid = (left + right) / 2;\\n            if(potions[mid] < target){\\n                right = mid - 1;\\n            }else{\\n                left = mid + 1;\\n                res = mid + 1;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```\n```\\n\\n\\nint search(int* potions, int potionsSize, int target){\\n    int res = 0;\\n    int left = 0;\\n    int right = potionsSize-1;\\n    while(left <= right){\\n        int mid = (left + right) / 2;\\n        if(potions[mid] < target){\\n            right = mid - 1;\\n        }else{\\n            left = mid + 1;\\n            res = mid + 1;\\n        }\\n    }\\n\\n    return res;\\n}\\n\\nint* successfulPairs(int* spells, int spellsSize, int* potions, int potionsSize, int success, int* returnSize) {\\n    int* res = malloc(spellsSize * sizeof(int));\\n    int* sortedPotions = malloc(potionsSize * sizeof(int));\\n    memcpy(sortedPotions, potions, potionsSize * sizeof(int));\\n    qsort(sortedPotions, potionsSize, sizeof(int), (const void *)compare);\\n    int* map = calloc(spellsSize, sizeof(int));\\n\\n    for(int i=0; i<spellsSize; i++){\\n        if(map[spells[i]] == 0){\\n            int s = success / spells[i];\\n            int len = search(sortedPotions, potionsSize, s);\\n            res[i] = len;\\n            map[spells[i]] = len;\\n        }else{\\n            int len = map[spells[i]];\\n            res[i] = len;\\n        }\\n    }\\n    \\n    free(map);\\n    free(sortedPotions);\\n    *returnSize = spellsSize;\\n    return res;\\n}\\n\\nint compare(const void * a, const void * b) {\\n   return (*(int*)b - *(int*)a);\\n}\\n```\n```\\nfrom typing import List\\nimport bisect\\n\\ndef successfulPairs(spells: List[int], potions: List[int], success: int) -> List[int]:\\n    res = []\\n    sortedPotions = sorted(potions, reverse=True)\\n    map = {}\\n\\n    for i in range(len(spells)):\\n        if spells[i] not in map:\\n            s = success / spells[i]\\n            len = bisect.bisect_left(sortedPotions, s)\\n            res.append(len)\\n            map[spells[i]] = len\\n        else:\\n            len = map[spells[i]]\\n            res.append(len)\\n\\n    return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368832,
                "title": "easy-binary-search-using-constant-extra-space-java-solution-beats-99",
                "content": "# Intuition\\nWe can use binary search to find out which element is exactly greater than or equal to product of ```spells[i]``` and ```potions[i]```.\\n1) we just need to take care of long variable as product maybe go beyond int range.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1) Sort potions array ascending order. So that we can use binary search to find out minimum element that is less than success.\\n2) now we need to check for every element in spells, so let\\'s use a for loop and pass our binary Search.\\n```\\nfor(int i = 0; i < n; i++){\\n    arr[i] = bs(potions, spells[i], success, 0, m - 1);\\n}\\n```\\n3) In binary search if we found ```spells[i] * potions[mid] >= success``` it means there maybe other element in the left side that are maybe greater than or equal to success. So, we use ```end = mid - 1``` else ```start = mid + 1```.\\n4) Now for count all the numbers we just need to subtract ```potion.length - start```.\\n5) We can easily store these count in spells array as we don\\'t need previous values further. So we don\\'t need any extra space\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- $$O(n logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length, m = potions.length;\\n        Arrays.sort(potions);\\n        for(int i = 0; i < n; i++){\\n            spells[i] = bs(potions, spells[i], success, 0, m - 1);\\n        }\\n        return spells;\\n    }\\n    int bs(int[] nums, long t, long succ, int start, int end){\\n        while(start <= end){\\n            int mid = (start + end) >> 1;\\n            if((long)(t * nums[mid]) >= succ){\\n                end = mid - 1;\\n            }\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        return nums.length - start;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```spells[i]```\n```potions[i]```\n```\\nfor(int i = 0; i < n; i++){\\n    arr[i] = bs(potions, spells[i], success, 0, m - 1);\\n}\\n```\n```spells[i] * potions[mid] >= success```\n```end = mid - 1```\n```start = mid + 1```\n```potion.length - start```\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length, m = potions.length;\\n        Arrays.sort(potions);\\n        for(int i = 0; i < n; i++){\\n            spells[i] = bs(potions, spells[i], success, 0, m - 1);\\n        }\\n        return spells;\\n    }\\n    int bs(int[] nums, long t, long succ, int start, int end){\\n        while(start <= end){\\n            int mid = (start + end) >> 1;\\n            if((long)(t * nums[mid]) >= succ){\\n                end = mid - 1;\\n            }\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        return nums.length - start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368719,
                "title": "java-code-simple-explanation",
                "content": "## Brute Force\\n- you can solve this problem using brute force running two loops and get the `counter` and add it into the list or array and return for each element you can do same. \\n\\n## Using Sorting + Binary Search \\n- Idea behind it is simple once we get the min potion which can satisfy the success then all the greater of it will also form it \\n- so the task is to find the minimum potion. Now question is here how we gonna find that min right \\n- So to find that min we need to sort the array of potion why need to sort? - So that we can easily apply binary search and make this algo to `n` to `logn` \\n- once you sorted the array `spells = [5,1,3], potions = [1,2,3,4,5], success = 7` now see for 5 what is the min potion that is required to form success can you see it is 2 at index = 1 \\n- okay now what so can I get it by binary search how? you can do multi of it 1. if it get greater set the right pointer 2. else set the left pointer \\n- Now we get the index of it alright now what is the last or say size of it just substract this index with size and we get how much we can form to make it success. \\n- A case for 0 what is it? right the case for the 0 is simple like if we get the min potion and max postion suppose what will be the max potion the max potion will be the last one after the sorting this elements if we get required min potion greater than max potion.. simple mean we can\\'t make any just add 0 in it. \\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] S, int[] P, long suc) {\\n        int ans=0;\\n        List<Integer> ls = new ArrayList<>();\\n        Arrays.sort(P);\\n        int n = P.length;\\n        int maxpos = P[P.length-1];\\n        // finding first index whose satisfy the condition \\n        for(int i: S){\\n            long minpos = (long)Math.ceil((1.0*suc)/i);\\n            if(minpos>maxpos){\\n                ls.add(0);\\n            }else{\\n                int get = getI(i,P,suc);\\n                 get = n-get;\\n                ls.add(get);\\n            }\\n        }\\n        // converting to array \\n        int[] res = new int[ls.size()];\\n        for(int i=0; i<ls.size(); i++){\\n            res[i] = ls.get(i);\\n        }\\n        // returning the array\\n        return res; \\n    }\\n    public static int getI(int i, int[] P, long suc){\\n        int l = 0;\\n        int r = P.length-1;\\n        while(l<r){\\n            int mid = l+(r-l)/2;\\n            if((long)i*P[mid]>=suc){\\n                r = mid;\\n            }else{\\n                l = mid+1;\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n- you can remove list just simple array of `len(n)` will also work and because of return the Aux space will become $$O(1)$$ constant. \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] S, int[] P, long suc) {\\n        int ans=0;\\n        List<Integer> ls = new ArrayList<>();\\n        Arrays.sort(P);\\n        int n = P.length;\\n        int maxpos = P[P.length-1];\\n        // finding first index whose satisfy the condition \\n        for(int i: S){\\n            long minpos = (long)Math.ceil((1.0*suc)/i);\\n            if(minpos>maxpos){\\n                ls.add(0);\\n            }else{\\n                int get = getI(i,P,suc);\\n                 get = n-get;\\n                ls.add(get);\\n            }\\n        }\\n        // converting to array \\n        int[] res = new int[ls.size()];\\n        for(int i=0; i<ls.size(); i++){\\n            res[i] = ls.get(i);\\n        }\\n        // returning the array\\n        return res; \\n    }\\n    public static int getI(int i, int[] P, long suc){\\n        int l = 0;\\n        int r = P.length-1;\\n        while(l<r){\\n            int mid = l+(r-l)/2;\\n            if((long)i*P[mid]>=suc){\\n                r = mid;\\n            }else{\\n                l = mid+1;\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368500,
                "title": "short-clean-and-optimal-solution-intuition-and-approach-explained",
                "content": "# Intuition\\nThe intuition behind the solution is to sort the potions array and then use binary search to find the index of the first potion whose strength multiplied by the spell\\'s strength is greater than or equal to the success threshold.\\n\\n# Approach\\nWe sort the potions array in non-decreasing order because we want to use binary search to find the index of the first potion that forms a successful pair with the current spell. Binary search can only be used on a sorted array.\\n\\nTo find the index of the first potion whose strength multiplied by the spell\\'s strength is greater than or equal to the success threshold, we divide the success threshold by the spell\\'s strength and round up to the nearest integer. This gives us the minimum potion strength required to form a successful pair with the spell.\\n\\nWe then use binary search to find the index of the first potion whose strength is greater than or equal to the minimum potion strength. All the potions from that index to the end of the array will form successful pairs with the spell.\\n\\nWe repeat this process for each spell in the spells array and add the number of successful pairs to the result vector.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this approach is O(n * log m), where n is the length of the spells array and m is the length of the potions array. Sorting the potions array takes O(m * log m) time, and the binary search for each spell takes O(log m) time.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> result;\\n        sort(potions.begin(), potions.end());\\n        for (int i = 0; i < spells.size(); i++) {\\n            int index = lower_bound(potions.begin(), potions.end(), (success + spells[i] - 1) / spells[i]) - potions.begin();\\n            result.push_back(potions.size() - index);\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> result;\\n        sort(potions.begin(), potions.end());\\n        for (int i = 0; i < spells.size(); i++) {\\n            int index = lower_bound(potions.begin(), potions.end(), (success + spells[i] - 1) / spells[i]) - potions.begin();\\n            result.push_back(potions.size() - index);\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368333,
                "title": "sort-binary-search-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = potions.size();\\n        vector<int> ans;\\n        sort(potions.begin(), potions.end());\\n\\n        for(int i : spells) {\\n            int pos = lower_bound(potions.begin(), potions.end(), ceil((double)success / i)) - potions.begin();\\n            ans.push_back(n - pos);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = potions.size();\\n        vector<int> ans;\\n        sort(potions.begin(), potions.end());\\n\\n        for(int i : spells) {\\n            int pos = lower_bound(potions.begin(), potions.end(), ceil((double)success / i)) - potions.begin();\\n            ans.push_back(n - pos);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368025,
                "title": "day-367-java-c-python-o-1-explained-3-3-ways-one-liner-dry-run",
                "content": "# Please Upvote as it really motivates me\\n# Intuition & Approach\\n##### \\u2022\\tThe problem requires to find the number of successful pairs between spells and potions, where a pair is considered successful if the product of the spell and potion is greater than or equal to a given value called success.\\n##### \\u2022\\tWe can start by finding the maximum value in the potions array, as this will help us in creating an array to count the number of potions available for each value.\\n##### \\u2022\\tWe create an array called potionsCount of size max+1, where max is the maximum value in the potions array. We initialize all elements of potionsCount to 0.\\n##### \\u2022\\tWe iterate through the potions array and increment the count of the corresponding value in potionsCount.\\n##### \\u2022\\tWe then iterate through the potionsCount array from right to left and update each element to the sum of itself and the next element. This gives us the number of potions available for each value and helps us in finding the number of successful pairs.\\n##### \\u2022\\tWe create an array called ret of size n, where n is the length of the spells array. We initialize all elements of ret to 0.\\n##### \\u2022\\tFor each spell, we calculate the minimum value of potion required to form a successful pair. We do this by dividing success by the spell and taking the floor of the result.\\n##### \\u2022\\tWe then iterate through the potionsCount array and find the number of potions available for the minimum value of potion required or any greater value. We store this value in the corresponding element of ret.\\n##### \\u2022\\tWe return the ret array containing the number of successful pairs for each spell.\\n##### \\u2022\\tTo handle the case where the minimum value of potion required is greater than the maximum value in the potions array, we skip the iteration for that spell.\\n##### \\u2022\\tTo handle the case where the product of the spell and the minimum value of potion required is less than success, we increment the minimum value of potion required until the product is greater than or equal to success. We do this only for values less than 100001, as this is the maximum value of success.\\n##### \\u2022\\tOverall, the solution has a time complexity of O(m + n log n), where m is the length of the potions array and n is the length of the spells array. The space complexity of the solution is O(max), where max is the maximum value in the potions array.\\n\\n\\n\\n```PYTHON []\\nclass Solution:\\n def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        n = len(spells)\\n        m = len(potions)\\n\\n        # Find the maximum value in the potions array.\\n        max_val = max(potions)\\n\\n        # Create an array to count the number of potions available for each value.\\n        potions_count = [0] * (max_val + 1)\\n        for x in potions:\\n            potions_count[x] += 1\\n\\n        # Update the potions_count array to store the number of potions available for each value and any greater value.\\n        count = 0\\n        for i in range(max_val, -1, -1):\\n            count += potions_count[i]\\n            potions_count[i] = count\\n\\n        # Create an array to store the number of successful pairs for each spell.\\n        ret = [0] * n\\n\\n        # For each spell, find the minimum value of potion required to form a successful pair and count the number of available potions.\\n        for i in range(n):\\n            target = success // spells[i]\\n            if target > max_val:\\n                continue\\n\\n            # Increment the minimum value of potion required until the product is greater than or equal to success.\\n            while target < 100001 and target * spells[i] < success:\\n                target += 1\\n\\n            if target > max_val:\\n                continue\\n\\n            # Store the number of available potions for the minimum value of potion required or any greater value.\\n            ret[i] = potions_count[target]\\n\\n        return ret\\n```\\n```JAVA []\\nclass Solution{\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length;\\n        int m = potions.length;\\n        \\n        int max = -1;\\n        for (int x : potions)\\n            max = max>x?max:x;\\n        \\n        int[] potionsCount = new int[max + 1];\\n        for (int x : potions)\\n            potionsCount[x]++;\\n        \\n        int count = 0;\\n        for (int i = max; i >= 0; i--) {\\n            count += potionsCount[i];\\n            potionsCount[i] = count;\\n        }\\n        \\n        \\n        int[] ret = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            long target = success / spells[i];\\n            if (target > max)\\n                continue;\\n            \\n            while (target < 100001 && target * spells[i] < success)\\n                target++;\\n            \\n            if (target > max)\\n                continue;\\n            \\n            ret[i] = potionsCount[(int)target];\\n        }\\n        \\n        return ret;\\n    }}\\n\\n```\\n\\n```C++ []\\nclass Solution {\\n:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size();\\n        int m = potions.size();\\n\\n        int max = -1;\\n        for (int x : potions)\\n            max = max>x?max:x;\\n\\n        vector<int> potionsCount(max + 1, 0);\\n        for (int x : potions)\\n            potionsCount[x]++;\\n\\n        int count = 0;\\n        for (int i = max; i >= 0; i--) {\\n            count += potionsCount[i];\\n            potionsCount[i] = count;\\n        }\\n\\n        vector<int> ret(n, 0);\\n        for (int i = 0; i < n; i++) {\\n            long long target = success / spells[i];\\n            if (target > max)\\n                continue;\\n\\n            while (target < 100001 && target * spells[i] < success)\\n                target++;\\n\\n            if (target > max)\\n                continue;\\n\\n            ret[i] = potionsCount[target];\\n        }\\n\\n        return ret;\\n    }\\n};\\n```\\n# 2nd way \\n\\n<!-- Describe your approach to solving the problem. -->\\n##### \\u2022\\tThe problem requires us to find the number of successful pairs between spells and potions, where a pair is considered successful if the product of the spell and potion is greater than or equal to a given value called success.\\n##### \\u2022\\tWe can start by sorting the potions array in increasing order, as this will help us in finding the minimum potion required for a given spell.\\n##### \\u2022\\tFor each spell, we need to find the minimum value of potion whose product with the current spell will be at least success or more. We can calculate this value by dividing success by the spell and taking the ceiling of the result.\\n##### \\u2022\\tIf the minimum potion required is greater than the maximum potion available, then we cannot form any successful pairs for this spell. In this case, we can set the answer for this spell to 0 and move on to the next spell.\\n##### \\u2022\\tIf we have a potion that can be used with the current spell, we need to find the index of the first potion in the sorted array that is greater than or equal to the minimum potion required. We can use binary search to find this index.\\n##### \\u2022\\tOnce we have the index of the first potion that can be used, we can count the number of potions to the right of this index, as all these potions will be greater than or equal to the minimum potion required and can be used to form successful pairs with the current spell.\\n##### \\u2022\\tWe repeat steps 3 to 6 for all spells and return the answer array containing the number of successful pairs for each spell.\\n\\n# Code\\n```java []\\n class Solution {\\n    // Our implementation of lower bound method using binary search.\\n    private int lowerBound(int[] arr, int key) {\\n        int lo = 0;\\n        int hi = arr.length;\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (arr[mid] < key) {\\n                lo = mid + 1;\\n            } else {\\n                hi = mid;\\n            }\\n        }\\n        return lo;\\n    }\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        // Sort the potions array in increasing order.\\n        Arrays.sort(potions);\\n        int[] answer = new int[spells.length];\\n        int m = potions.length;\\n        int maxPotion = potions[m - 1];\\n\\n        for (int i = 0; i < spells.length; i++) {\\n            int spell = spells[i];\\n            // Minimum value of potion whose product with current spell will be at least success or more.\\n            long minPotion = (long) Math.ceil((1.0 * success) / spell);\\n            // Check if we don\\'t have any potion which can be used.\\n            if (minPotion > maxPotion) {\\n                answer[i] = 0;\\n                continue;\\n            }\\n            // We can use the found potion, and all potion in its right (as the right potions are greater than the found potion).\\n            int index = lowerBound(potions, (int) minPotion);\\n            answer[i] = m - index;\\n        }\\n        return answer;\\n    }\\n}\\n```\\n```c++ []\\nclass Solution {\\npublic    // Our implementation of lower bound method using binary search.\\n    int lowerBound(vector<int>& arr, int key) {\\n        int lo = 0;\\n        int hi = arr.size();\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (arr[mid] < key) {\\n                lo = mid + 1;\\n            } else {\\n                hi = mid;\\n            }\\n        }\\n        return lo;\\n    }\\n\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        // Sort the potions array in increasing order.\\n        sort(potions.begin(), potions.end());\\n        vector<int> answer(spells.size());\\n        int m = potions.size();\\n        int maxPotion = potions[m - 1];\\n\\n        for (int i = 0; i < spells.size(); i++) {\\n            int spell = spells[i];\\n            // Minimum value of potion whose product with current spell will be at least success or more.\\n            long long minPotion = ceil((1.0 * success) / spell);\\n            // Check if we don\\'t have any potion which can be used.\\n            if (minPotion > maxPotion) {\\n                answer[i] = 0;\\n                continue;\\n            }\\n            // We can use the found potion, and all potion in its right (as the right potions are greater than the found potion).\\n            int index = lowerBound(potions, (int) minPotion);\\n            answer[i] = m - index;\\n        }\\n        return answer;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    # Our of lower bound method using binary search.\\n    def lowerBound(self, arr: List[int], key: int) -> int:\\n        lo = 0\\n        hi = len(arr)\\n        while lo < hi:\\n            mid = lo + (hi - lo) // 2\\n            if arr[mid] < key:\\n                lo = mid + 1\\n            else:\\n                hi = mid\\n        return lo\\n\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        # Sort the potions array in increasing order.\\n        potions.sort()\\n        answer = [0] * len(spells)\\n        m = len(potions)\\n        maxPotion = potions[m - 1]\\n\\n        for i in range(len(spells)):\\n            spell = spells[i]\\n            # Minimum value of potion whose product with current spell will be at least success or more.\\n            minPotion = math.ceil(success / spell)\\n            # Check if we don\\'t have any potion which can be used.\\n            if minPotion > maxPotion:\\n                answer[i] = 0\\n                continue\\n            # We can use the found potion, and all potion in its right (as the right potions are greater than the found potion).\\n            index = self.lowerBound(potions, minPotion)\\n            answer[i] = m - index\\n        return answer\\n```\\n\\n# in place sp 0(1)\\n```java []\\npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int len = spells.length;\\n        int m= potions.length;\\n        int max=potions[m-1];\\n        for(int i=0;i<len;i++){\\n            int spell =spells[i];\\n            long min= (long)Math.ceil((1.0*success)/spell);\\n            if(min>max){\\n                spells[i]=0;\\n                continue;\\n            }\\n            int ind=lowerBound(potions,(int)min);\\n            spells[i]=m-ind;\\n        }return spells;\\n    }\\n    int lowerBound(int A[],int key){\\n        int lo=0,ri=A.length;\\n        while(lo<ri){\\n            int mid=lo+(ri-lo)/2;\\n            if(A[mid]<key){\\n                lo=mid+1;\\n            }else ri=mid;\\n        }return lo;\\n    }\\n```\\n\\n# Complexity\\n##### \\u2022\\tComplexity:\\n##### \\u2022\\tSorting the potions array takes O(m log m) time, where m is the length of the potions array.\\n##### \\u2022\\tFor each spell, we perform a binary search to find the index of the first potion that can be used. This takes O(log m) time.\\n##### \\u2022\\tTherefore, the total time complexity of the solution is O(n log m), where n is the length of the spells array.\\n##### \\u2022\\tSpace Complexity:\\n##### \\u2022\\tWe use a constant amount of extra space for variables and the answer array. Therefore, the space complexity of the solution is O(1).\\n##### \\u2022\\tOverall, the solution has a time complexity of O(n log m) and a space complexity of O(1).\\n\\n# dry run 1\\n##### \\u2022\\tlet\\'s dry run the given input:\\n##### \\u2022\\tspells = [51,3]\\n##### \\u2022\\tpotions = [1,2,3,4,5]\\n##### \\u2022\\tsuccess = 7\\n##### \\u2022\\tWe need to find the number of successful pairs between spells and potions, where a pair is considered successful if the product of the spell and potion is greater than or equal to 7.\\n##### \\u2022\\tThe maximum value in the potions array is 5.\\n##### \\u2022\\tWe create an array called potionsCount of size 6, where 6 is the maximum value in the potions array plus 1. We initialize all elements of potionsCount to 0.\\n##### \\u2022\\tWe iterate through the potions array and increment the count of the corresponding value in potionsCount. The updated potionsCount array is:\\n1.\\tpotionsCount = [1, 1, 1, 1, 1, 0]\\n##### \\u2022\\tWe then iterate through the potionsCount array from right to left and update each element to the sum of itself and the next element. This gives us the number of potions available for each value and helps us in finding the number of successful pairs. The updated potionsCount array is:\\n1.\\tpotionsCount = [5, 4, 3, 2, 1, 0]\\n##### \\u2022\\tWe create an array called ret of size 3, where 3 is the length of the spells array. We initialize all elements of ret to 0.\\n##### \\u2022\\tFor the first spell, 5, we calculate the minimum value of potion required to form a successful pair. We do this by dividing 7 by 5 and taking the floor of the result, which is 1.\\n##### \\u2022\\tWe then iterate through the potionsCount array and find the number of potions available for the minimum value of potion required or any greater value. We store this value in the corresponding element of ret. The number of available potions is 4.\\n##### \\u2022\\tFor the second spell, 1, the minimum value of potion required is 7. Since 7 is greater than the maximum value in the potions array, we skip the iteration for this spell.\\n##### \\u2022\\tFor the third spell, 3, we calculate the minimum value of potion required to form a successful pair. We do this by dividing 7 by 3 and taking the floor of the result, which is 2.\\n##### \\u2022\\tWe then iterate through the potionsCount array and find the number of potions available for the minimum value of potion required or any greater value. We store this value in the corresponding element of ret. The number of available potions is 3.\\n##### \\u2022\\tThe final ret array is [4, 0, 3], which represents the number of successful pairs for each spell.\\n##### \\u2022\\tTherefore, the output for the given input is [4, 0, 3].\\n\\n[MY POST LINK](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3368025/day-367-java-c-python-o-1-explained-3-3-ways-one-liner-dry-run/?orderBy=most_votes)\\n\\n# dry run 2\\n##### \\u2022\\tlet\\'s dry run the given input:\\n##### \\u2022\\tspells = [,1,2]\\n##### \\u2022\\tpot = [8,5,8]\\n##### \\u2022\\tsuccess = 16\\n##### \\u2022\\tWe need to find the number of successful pairs between spells and potions, where a pair is considered successful if the product of the spell and potion is greater than or equal to 16.\\n##### \\u2022\\tThe maximum value in the potions array is 8.\\n##### \\u2022\\tWe create an array called potionsCount of size 9, where 9 is the maximum value in the potions array plus 1. We initialize all elements of potionsCount to 0.\\n##### \\u2022\\tWe iterate through the potions array and increment the count of the corresponding value in potionsCount. The updated potionsCount array is:\\n1.\\tpotionsCount = [0, 0, 0, 0, 1, 1, 0, 0, 1]\\n##### \\u2022\\tWe then iterate through the potionsCount array from right to left and update each element to the sum of itself and the next element. This gives us the number of potions available for each value and helps us in finding the number of successful pairs. The updated potionsCount array is:\\n1.\\tpotionsCount = [2, 2, 2, 2, 2, 1, 1, 1, 1]\\n##### \\u2022\\tWe create an array called ret of size 3, where 3 is the length of the spells array. We initialize all elements of ret to 0.\\n##### \\u2022\\tFor the first spell, 3, we calculate the minimum value of potion required to form a successful pair. We do this by dividing 16 by 3 and taking the floor of the result, which is 5.\\n##### \\u2022\\tWe then iterate through the potionsCount array and find the number of potions available for the minimum value of potion required or any greater value. We store this value in the corresponding element of ret. The number of available potions is 2.\\n##### \\u2022\\tFor the second spell, 1, the minimum value of potion required is 16. Since 16 is greater than the maximum value in the potions array, we skip the iteration for this spell.\\n##### \\u2022\\tFor the third spell, 2, we calculate the minimum value of potion required to form a successful pair. We do this by dividing 16 by 2 and taking the floor of the result, which is 8.\\n##### \\u2022\\tWe then iterate through the potionsCount array and find the number of potions available for the minimum value of potion required or any greater value. We store this value in the corresponding element of ret. The number of available potions is 2.\\n##### \\u2022\\tThe final ret array is [2, 0, 2], which represents the number of successful pairs for each spell.\\n##### \\u2022\\tTherefore, the output for the given input is [2, 0, 2].\\n\\n# 3rd way one liner\\n```python []\\ndef successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\npotions.sort()\\nreturn (len(potions) - bisect_left(potions, success, key=lambda p: p * s) for s in spells)\\n```\\n```java []\\npublic int[] successfulPairs(int spells, int[] potions, int success) {\\n    Arrays.sort(potions);\\n    int[] result = new int[spells.length];\\n    for (int i = 0; i < spells.length; i++) {\\n        int count = potions.length - Arrays.binarySearch(potions, success, (p) -> p * spells[i]);\\n        result[i] = count;\\n    }\\n    return result;\\n}\\n```\\n```c++ []\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, int success) {\\n    sort(potions.begin(), potions.end());\\n    vector<int> result;\\n    for (int s : spells) {\\n        int count = potions.size() - lower_bound(potions.begin(), potions.end(), success, [&](int p) { return p * s; });\\n        result.push_back(count);\\n    }\\n    return result;\\n}\\n```\\n\\n##### \\u2022\\tPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n##### \\u2022\\tThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\n##### \\u2022\\tPlease give my solution an upvote! \\uD83D\\uDC4D\\n##### \\u2022\\tIt\\'s a simple way to show your appreciation and\\n##### \\u2022\\tkeep me motivated. Thank you! \\uD83D\\uDE0A\\n\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/01e9d1d5-3462-485a-9534-d40a3e78a49a_1680408107.3861706.webp)\\n\\n![meme2.png](https://assets.leetcode.com/users/images/1dba63f5-3703-4778-995f-2561c0a08abb_1680408137.1317718.png)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```PYTHON []\\nclass Solution:\\n def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        n = len(spells)\\n        m = len(potions)\\n\\n        # Find the maximum value in the potions array.\\n        max_val = max(potions)\\n\\n        # Create an array to count the number of potions available for each value.\\n        potions_count = [0] * (max_val + 1)\\n        for x in potions:\\n            potions_count[x] += 1\\n\\n        # Update the potions_count array to store the number of potions available for each value and any greater value.\\n        count = 0\\n        for i in range(max_val, -1, -1):\\n            count += potions_count[i]\\n            potions_count[i] = count\\n\\n        # Create an array to store the number of successful pairs for each spell.\\n        ret = [0] * n\\n\\n        # For each spell, find the minimum value of potion required to form a successful pair and count the number of available potions.\\n        for i in range(n):\\n            target = success // spells[i]\\n            if target > max_val:\\n                continue\\n\\n            # Increment the minimum value of potion required until the product is greater than or equal to success.\\n            while target < 100001 and target * spells[i] < success:\\n                target += 1\\n\\n            if target > max_val:\\n                continue\\n\\n            # Store the number of available potions for the minimum value of potion required or any greater value.\\n            ret[i] = potions_count[target]\\n\\n        return ret\\n```\n```JAVA []\\nclass Solution{\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length;\\n        int m = potions.length;\\n        \\n        int max = -1;\\n        for (int x : potions)\\n            max = max>x?max:x;\\n        \\n        int[] potionsCount = new int[max + 1];\\n        for (int x : potions)\\n            potionsCount[x]++;\\n        \\n        int count = 0;\\n        for (int i = max; i >= 0; i--) {\\n            count += potionsCount[i];\\n            potionsCount[i] = count;\\n        }\\n        \\n        \\n        int[] ret = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            long target = success / spells[i];\\n            if (target > max)\\n                continue;\\n            \\n            while (target < 100001 && target * spells[i] < success)\\n                target++;\\n            \\n            if (target > max)\\n                continue;\\n            \\n            ret[i] = potionsCount[(int)target];\\n        }\\n        \\n        return ret;\\n    }}\\n\\n```\n```C++ []\\nclass Solution {\\n:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size();\\n        int m = potions.size();\\n\\n        int max = -1;\\n        for (int x : potions)\\n            max = max>x?max:x;\\n\\n        vector<int> potionsCount(max + 1, 0);\\n        for (int x : potions)\\n            potionsCount[x]++;\\n\\n        int count = 0;\\n        for (int i = max; i >= 0; i--) {\\n            count += potionsCount[i];\\n            potionsCount[i] = count;\\n        }\\n\\n        vector<int> ret(n, 0);\\n        for (int i = 0; i < n; i++) {\\n            long long target = success / spells[i];\\n            if (target > max)\\n                continue;\\n\\n            while (target < 100001 && target * spells[i] < success)\\n                target++;\\n\\n            if (target > max)\\n                continue;\\n\\n            ret[i] = potionsCount[target];\\n        }\\n\\n        return ret;\\n    }\\n};\\n```\n```java []\\n class Solution {\\n    // Our implementation of lower bound method using binary search.\\n    private int lowerBound(int[] arr, int key) {\\n        int lo = 0;\\n        int hi = arr.length;\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (arr[mid] < key) {\\n                lo = mid + 1;\\n            } else {\\n                hi = mid;\\n            }\\n        }\\n        return lo;\\n    }\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        // Sort the potions array in increasing order.\\n        Arrays.sort(potions);\\n        int[] answer = new int[spells.length];\\n        int m = potions.length;\\n        int maxPotion = potions[m - 1];\\n\\n        for (int i = 0; i < spells.length; i++) {\\n            int spell = spells[i];\\n            // Minimum value of potion whose product with current spell will be at least success or more.\\n            long minPotion = (long) Math.ceil((1.0 * success) / spell);\\n            // Check if we don\\'t have any potion which can be used.\\n            if (minPotion > maxPotion) {\\n                answer[i] = 0;\\n                continue;\\n            }\\n            // We can use the found potion, and all potion in its right (as the right potions are greater than the found potion).\\n            int index = lowerBound(potions, (int) minPotion);\\n            answer[i] = m - index;\\n        }\\n        return answer;\\n    }\\n}\\n```\n```c++ []\\nclass Solution {\\npublic    // Our implementation of lower bound method using binary search.\\n    int lowerBound(vector<int>& arr, int key) {\\n        int lo = 0;\\n        int hi = arr.size();\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (arr[mid] < key) {\\n                lo = mid + 1;\\n            } else {\\n                hi = mid;\\n            }\\n        }\\n        return lo;\\n    }\\n\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        // Sort the potions array in increasing order.\\n        sort(potions.begin(), potions.end());\\n        vector<int> answer(spells.size());\\n        int m = potions.size();\\n        int maxPotion = potions[m - 1];\\n\\n        for (int i = 0; i < spells.size(); i++) {\\n            int spell = spells[i];\\n            // Minimum value of potion whose product with current spell will be at least success or more.\\n            long long minPotion = ceil((1.0 * success) / spell);\\n            // Check if we don\\'t have any potion which can be used.\\n            if (minPotion > maxPotion) {\\n                answer[i] = 0;\\n                continue;\\n            }\\n            // We can use the found potion, and all potion in its right (as the right potions are greater than the found potion).\\n            int index = lowerBound(potions, (int) minPotion);\\n            answer[i] = m - index;\\n        }\\n        return answer;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    # Our of lower bound method using binary search.\\n    def lowerBound(self, arr: List[int], key: int) -> int:\\n        lo = 0\\n        hi = len(arr)\\n        while lo < hi:\\n            mid = lo + (hi - lo) // 2\\n            if arr[mid] < key:\\n                lo = mid + 1\\n            else:\\n                hi = mid\\n        return lo\\n\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        # Sort the potions array in increasing order.\\n        potions.sort()\\n        answer = [0] * len(spells)\\n        m = len(potions)\\n        maxPotion = potions[m - 1]\\n\\n        for i in range(len(spells)):\\n            spell = spells[i]\\n            # Minimum value of potion whose product with current spell will be at least success or more.\\n            minPotion = math.ceil(success / spell)\\n            # Check if we don\\'t have any potion which can be used.\\n            if minPotion > maxPotion:\\n                answer[i] = 0\\n                continue\\n            # We can use the found potion, and all potion in its right (as the right potions are greater than the found potion).\\n            index = self.lowerBound(potions, minPotion)\\n            answer[i] = m - index\\n        return answer\\n```\n```java []\\npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int len = spells.length;\\n        int m= potions.length;\\n        int max=potions[m-1];\\n        for(int i=0;i<len;i++){\\n            int spell =spells[i];\\n            long min= (long)Math.ceil((1.0*success)/spell);\\n            if(min>max){\\n                spells[i]=0;\\n                continue;\\n            }\\n            int ind=lowerBound(potions,(int)min);\\n            spells[i]=m-ind;\\n        }return spells;\\n    }\\n    int lowerBound(int A[],int key){\\n        int lo=0,ri=A.length;\\n        while(lo<ri){\\n            int mid=lo+(ri-lo)/2;\\n            if(A[mid]<key){\\n                lo=mid+1;\\n            }else ri=mid;\\n        }return lo;\\n    }\\n```\n```python []\\ndef successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\npotions.sort()\\nreturn (len(potions) - bisect_left(potions, success, key=lambda p: p * s) for s in spells)\\n```\n```java []\\npublic int[] successfulPairs(int spells, int[] potions, int success) {\\n    Arrays.sort(potions);\\n    int[] result = new int[spells.length];\\n    for (int i = 0; i < spells.length; i++) {\\n        int count = potions.length - Arrays.binarySearch(potions, success, (p) -> p * spells[i]);\\n        result[i] = count;\\n    }\\n    return result;\\n}\\n```\n```c++ []\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, int success) {\\n    sort(potions.begin(), potions.end());\\n    vector<int> result;\\n    for (int s : spells) {\\n        int count = potions.size() - lower_bound(potions.begin(), potions.end(), success, [&](int p) { return p * s; });\\n        result.push_back(count);\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367958,
                "title": "easy-solution-implemented-with-more-one-language",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int BS(int t, vector<int>& p, long long success){\\n        long long l = 0, r = p.size()-1, mid = -1;\\n        while(l<=r){\\n            mid = (l+r)/2;\\n            if( (long long)t*p[mid] < success )\\n                l = mid+1;\\n            else\\n                r = mid-1;\\n        }\\n        return l;\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size(), p = potions.size(), temp;\\n        vector<int> ans(n, 0);\\n        sort(potions.begin(), potions.end());\\n        for(int i=0; i<n; ++i){\\n            temp = BS( spells[i] , potions, success );\\n            ans[i] = (temp == p) ? 0 : p-temp;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Java Code \\n```\\nclass Solution {\\n    public int BS(int t, int[] p, long success){\\n        int l = 0, r = p.length-1, mid;\\n        while(l<=r){\\n            mid = (l+r)/2;\\n            if( (long)t*p[mid] < success )\\n                l = mid+1;\\n            else\\n                r = mid-1;\\n        }\\n        return l;\\n    }\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length, p = potions.length, temp;\\n        int[] ans = new int[n];\\n        Arrays.sort(potions);\\n        for(int i=0; i<n; ++i){\\n            temp = BS(spells[i], potions, success);\\n            ans[i] = (temp == p)? 0 : p - temp;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n# JavaScript Code\\n```\\n/**\\n * @param {number[]} spells\\n * @param {number[]} potions\\n * @param {number} success\\n * @return {number[]}\\n */\\nconst BS = ( t, p, success)=>{\\n    let l = 0, r = p.length-1, mid;\\n    while(l<=r){\\n        mid = parseInt( (l+r)/2 );\\n        if( t*p[mid] < success ){\\n            l = mid+1;\\n        }else{\\n            r = mid-1;\\n        }\\n    }\\n    return l;\\n}\\n\\nvar successfulPairs = function(spells, potions, success) {\\n    let n = spells.length, p = potions.length, temp;\\n    let ans = new Array(n);\\n    potions.sort((a, b)=> a - b);\\n    for(let i=0; i<n; ++i){\\n        temp = BS( spells[i], potions, success);\\n        console.log(temp);\\n        ans[i] = (temp == p)? 0 : p-temp;\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int BS(int t, vector<int>& p, long long success){\\n        long long l = 0, r = p.size()-1, mid = -1;\\n        while(l<=r){\\n            mid = (l+r)/2;\\n            if( (long long)t*p[mid] < success )\\n                l = mid+1;\\n            else\\n                r = mid-1;\\n        }\\n        return l;\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size(), p = potions.size(), temp;\\n        vector<int> ans(n, 0);\\n        sort(potions.begin(), potions.end());\\n        for(int i=0; i<n; ++i){\\n            temp = BS( spells[i] , potions, success );\\n            ans[i] = (temp == p) ? 0 : p-temp;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int BS(int t, int[] p, long success){\\n        int l = 0, r = p.length-1, mid;\\n        while(l<=r){\\n            mid = (l+r)/2;\\n            if( (long)t*p[mid] < success )\\n                l = mid+1;\\n            else\\n                r = mid-1;\\n        }\\n        return l;\\n    }\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length, p = potions.length, temp;\\n        int[] ans = new int[n];\\n        Arrays.sort(potions);\\n        for(int i=0; i<n; ++i){\\n            temp = BS(spells[i], potions, success);\\n            ans[i] = (temp == p)? 0 : p - temp;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\n/**\\n * @param {number[]} spells\\n * @param {number[]} potions\\n * @param {number} success\\n * @return {number[]}\\n */\\nconst BS = ( t, p, success)=>{\\n    let l = 0, r = p.length-1, mid;\\n    while(l<=r){\\n        mid = parseInt( (l+r)/2 );\\n        if( t*p[mid] < success ){\\n            l = mid+1;\\n        }else{\\n            r = mid-1;\\n        }\\n    }\\n    return l;\\n}\\n\\nvar successfulPairs = function(spells, potions, success) {\\n    let n = spells.length, p = potions.length, temp;\\n    let ans = new Array(n);\\n    potions.sort((a, b)=> a - b);\\n    for(let i=0; i<n; ++i){\\n        temp = BS( spells[i], potions, success);\\n        console.log(temp);\\n        ans[i] = (temp == p)? 0 : p-temp;\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367889,
                "title": "js-binary-search-with-comments",
                "content": "# Intuition\\nTo achieve we don\\'t have to calcualate every spell * potion. If we sort potions then have to find the firs potion which satisfies our conditions. All next potions will satisfy as well.\\n\\n# Approach\\n - Sort potions ascending order\\n - for each spell find that minimum number which would be bigger than success after multiplying on it\\n - find the index of the first potion which is equal or more than that number\\n\\n# Complexity\\n- Time complexity: O(n*log(n) + n*log(m))\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} spells\\n * @param {number[]} potions\\n * @param {number} success\\n * @return {number[]}\\n */\\nvar successfulPairs = function(spells, potions, success) {\\n    // Sort potions asc order for binary search\\n    potions.sort((a, b) => a - b);\\n    const ans = [];\\n    for (const spell of spells) {\\n        // this number will help us to find the index of the first potion which is equal or more than that number\\n        const rel = success / spell;\\n        let left = 0, right = potions.length - 1;\\n        // standard binary search\\n        while (left <= right) {\\n            const mid = Math.floor((left + right) / 2);\\n            if (potions[mid] < rel) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        // the answer for this number would be the difference between the potions leng and the index\\n        ans.push(potions.length - left);\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} spells\\n * @param {number[]} potions\\n * @param {number} success\\n * @return {number[]}\\n */\\nvar successfulPairs = function(spells, potions, success) {\\n    // Sort potions asc order for binary search\\n    potions.sort((a, b) => a - b);\\n    const ans = [];\\n    for (const spell of spells) {\\n        // this number will help us to find the index of the first potion which is equal or more than that number\\n        const rel = success / spell;\\n        let left = 0, right = potions.length - 1;\\n        // standard binary search\\n        while (left <= right) {\\n            const mid = Math.floor((left + right) / 2);\\n            if (potions[mid] < rel) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        // the answer for this number would be the difference between the potions leng and the index\\n        ans.push(potions.length - left);\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2976823,
                "title": "ruby-solution-two-methods",
                "content": "### Method 1:  Brute Force (gives TLE)\\nTime Complexity O(m*n)\\n\\n```\\ndef successful_pairs(spells, potions, success)\\n    spells.map { |spell| potions.count { |potion| spell * potion >= success } }\\nend\\n```\\n\\n### Method 2: Binary Search\\nTime Complexity O(n*log(m))\\n\\nProcess:\\n* Sort `potions` so we can use bsearch \\n* Get 1st index in `potions` where: `potion*spell >= success` \\n\\t* or equivalently: `potion >= success/spell`\\n* Return the number of `potions` greater than the successful one found, or 0 if none were found\\n\\n```\\ndef successful_pairs(spells, potions, success)\\n    potions.sort! \\n    spells.map do |spell_str|\\n        min_pot_str = success.fdiv(spell_str)\\n        idx = potions.bsearch_index { |potion| potion >= min_pot_str }\\n        idx.nil? ? 0 : potions.size - idx\\n    end\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Binary Tree"
                ],
                "code": "```\\ndef successful_pairs(spells, potions, success)\\n    spells.map { |spell| potions.count { |potion| spell * potion >= success } }\\nend\\n```\n```\\ndef successful_pairs(spells, potions, success)\\n    potions.sort! \\n    spells.map do |spell_str|\\n        min_pot_str = success.fdiv(spell_str)\\n        idx = potions.bsearch_index { |potion| potion >= min_pot_str }\\n        idx.nil? ? 0 : potions.size - idx\\n    end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2674578,
                "title": "java-binary-search",
                "content": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int n=spells.length,m=potions.length;;\\n        int ans[]=new int[n];\\n       \\n        long prod=0;\\n        for(int i=0;i<n;i++){\\n            int idx=-1,j=0,k=m-1;\\n            while(j<=k){\\n                int mid=(j+k)/2;\\n                if((long)spells[i]*(long)potions[mid]>=success){\\n                    idx=mid;\\n                    k=mid-1;\\n                }\\n                else{\\n                    j=mid+1;\\n                }\\n            }\\n            ans[i]=idx==-1?0:m-idx;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int n=spells.length,m=potions.length;;\\n        int ans[]=new int[n];\\n       \\n        long prod=0;\\n        for(int i=0;i<n;i++){\\n            int idx=-1,j=0,k=m-1;\\n            while(j<=k){\\n                int mid=(j+k)/2;\\n                if((long)spells[i]*(long)potions[mid]>=success){\\n                    idx=mid;\\n                    k=mid-1;\\n                }\\n                else{\\n                    j=mid+1;\\n                }\\n            }\\n            ans[i]=idx==-1?0:m-idx;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2153478,
                "title": "c-lower-bound-easy-and-simple-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int>ans(spells.size());\\n        sort(potions.begin(), potions.end());\\n        \\n        for(int i = 0; i<spells.size(); i++){\\n            long long secondnumber = ceil(success/static_cast<double>(spells[i]));\\n            auto it = lower_bound(potions.begin(), potions.end(), secondnumber);\\n            int indexofit = it-potions.begin();\\n            ans[i] = potions.size()-indexofit;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int>ans(spells.size());\\n        sort(potions.begin(), potions.end());\\n        \\n        for(int i = 0; i<spells.size(); i++){\\n            long long secondnumber = ceil(success/static_cast<double>(spells[i]));\\n            auto it = lower_bound(potions.begin(), potions.end(), secondnumber);\\n            int indexofit = it-potions.begin();\\n            ans[i] = potions.size()-indexofit;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2143378,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} spells\\n * @param {number[]} potions\\n * @param {number} success\\n * @return {number[]}\\n */\\n var successfulPairs = function(spells, potions, success) {\\n    let res = [];\\n    potions.sort((a, b) => b-a);\\n    let map = new Map();\\n    \\n    for(let i=0; i<spells.length; i++){\\n        if(!map.has(spells[i])){\\n            let s = success / spells[i];\\n            let len = search(potions, s);\\n            res.push(len);\\n            map.set(spells[i], len);\\n        }else{\\n            let len = map.get(spells[i]);\\n            res.push(len);\\n        }\\n    }\\n    \\n    return res;\\n};\\n\\nfunction search(potions, target){\\n    let res = 0;\\n    let left = 0;\\n    let right = potions.length-1;\\n    while(left <= right){\\n        let mid = Math.floor((left + right) / 2);\\n        if(potions[mid] < target){\\n            right = mid - 1;\\n        }else{\\n            left = mid + 1;\\n            res = mid + 1;\\n        }\\n    }\\n\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```\\n/**\\n * @param {number[]} spells\\n * @param {number[]} potions\\n * @param {number} success\\n * @return {number[]}\\n */\\n var successfulPairs = function(spells, potions, success) {\\n    let res = [];\\n    potions.sort((a, b) => b-a);\\n    let map = new Map();\\n    \\n    for(let i=0; i<spells.length; i++){\\n        if(!map.has(spells[i])){\\n            let s = success / spells[i];\\n            let len = search(potions, s);\\n            res.push(len);\\n            map.set(spells[i], len);\\n        }else{\\n            let len = map.get(spells[i]);\\n            res.push(len);\\n        }\\n    }\\n    \\n    return res;\\n};\\n\\nfunction search(potions, target){\\n    let res = 0;\\n    let left = 0;\\n    let right = potions.length-1;\\n    while(left <= right){\\n        let mid = Math.floor((left + right) / 2);\\n        if(potions[mid] < target){\\n            right = mid - 1;\\n        }else{\\n            left = mid + 1;\\n            res = mid + 1;\\n        }\\n    }\\n\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2139988,
                "title": "c-solution-explanations-and-examples",
                "content": "**Main idea**\\nBrute force will lead to TLE, thus we may think: use binary search to make `O(N^2)` to `O(NlogN)`.\\nThe core code of a `binary search` is as follows, and for each element in `spells`, we run a binary search on `potions` array, to find the \"edge\\u201C element.\\n**Example**:\\n`spells   `: [5, 1, 3]\\n`potions`: [1, 2, 3, 4, 5]\\n`success`: 7\\n\\nFor `5` in `spells`, the \"edge\" element in `potions` is `2` - index is `1`. When the binary search stops, index `low` will be bigger than index \\'high\\', i.e., `low` = `1`, `high` = `0`. And for `5` in `spells`, the number of potions will be `potions.size() - high - 1 = potions.size() - low` = `4`.\\n\\nFor `3` in `spells`, when binary search finished, index `low` = `2`, `high` = `1`, the number of potions will be `potions.size - high - 1 = potions.size() - low` = `3`\\n* binary search code \"template\"\\n\\t```\\n\\t/* \\n\\t* binary search core code\\n\\t* vec    - array / vector - like \\n\\t* target - represents the target value or target expression\\n\\t*\\n\\t* requirement: vec must be sorted from small to large\\n\\t*/\\n\\n\\n\\t/* search range: [low, high] */\\n\\tint high = vec.size()-1;\\n\\tint low  = 0;\\n\\twhile(low<=high)  /* search range: [low, high] */\\n\\t{\\n\\t  int mid = low + (high-low)/2;  /* equals to (high + low)/2 */ \\n\\t  if(target == vec[mid])return mid;\\n\\t  else if(target < vec[mid])high = mid-1;\\n\\t  else low  = mid+1;\\n\\t}\\n\\n\\n\\t/* search range: [low, high) */\\n\\tint high = vec.size();\\n\\tint low  = 0;\\n\\twhile (low < high)  /* search range: [0, N) */\\n\\t{\\n\\t  int mid = low + (high-low)/2;  /* equals to (high + low)/2 */ \\n\\t  if (target == vec[mid])return mid;\\n\\t  else if (target < vec[mid])high = mid;\\n\\t  else low = mid+1;\\n\\t}\\n\\n\\n\\t/* difference */\\n\\t/*\\n\\t* int high = vec.size()   --   int high = vec.size()-1\\n\\t* while(low<high)         --   while(low<=high)\\n\\t* high = mid              --   high = mid-1\\n\\t*/\\n\\t```\\n* Solution\\n\\t```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n\\n\\t\\t\\tint n = spells.size();\\n\\t\\t\\tint m = potions.size();\\n\\n\\t\\t\\tsort(potions.begin(), potions.end());  /* prepare for binary search */\\n\\n\\t\\t\\tvector<int> ans(n, 0);  /* answer */\\n\\n\\t\\t\\tfor(int i = 0; i < n; ++i)  /* loop through all spells */\\n\\t\\t\\t{                 \\n\\t\\t\\t\\t/* perform binary search on potions array */\\n\\t\\t\\t\\tint high = potions.size()-1;  \\n\\t\\t\\t\\tint low  = 0;\\n\\t\\t\\t\\twhile(low <= high)  /* search range: [low, high] */\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint mid = low + (high-low)/2;\\n\\t\\t\\t\\t\\tlong long p = potions[mid], s = spells[i];\\n\\t\\t\\t\\t\\tif(p * s < success)low = mid+1;\\n\\t\\t\\t\\t\\telse high = mid-1;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tans[i] = m - high - 1;  /* m - high - 1 because when quiting binary search, low > high, can be also written as m - low */\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\t```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\t/* \\n\\t* binary search core code\\n\\t* vec    - array / vector - like \\n\\t* target - represents the target value or target expression\\n\\t*\\n\\t* requirement: vec must be sorted from small to large\\n\\t*/\\n\\n\\n\\t/* search range: [low, high] */\\n\\tint high = vec.size()-1;\\n\\tint low  = 0;\\n\\twhile(low<=high)  /* search range: [low, high] */\\n\\t{\\n\\t  int mid = low + (high-low)/2;  /* equals to (high + low)/2 */ \\n\\t  if(target == vec[mid])return mid;\\n\\t  else if(target < vec[mid])high = mid-1;\\n\\t  else low  = mid+1;\\n\\t}\\n\\n\\n\\t/* search range: [low, high) */\\n\\tint high = vec.size();\\n\\tint low  = 0;\\n\\twhile (low < high)  /* search range: [0, N) */\\n\\t{\\n\\t  int mid = low + (high-low)/2;  /* equals to (high + low)/2 */ \\n\\t  if (target == vec[mid])return mid;\\n\\t  else if (target < vec[mid])high = mid;\\n\\t  else low = mid+1;\\n\\t}\\n\\n\\n\\t/* difference */\\n\\t/*\\n\\t* int high = vec.size()   --   int high = vec.size()-1\\n\\t* while(low<high)         --   while(low<=high)\\n\\t* high = mid              --   high = mid-1\\n\\t*/\\n\\t```\n```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n\\n\\t\\t\\tint n = spells.size();\\n\\t\\t\\tint m = potions.size();\\n\\n\\t\\t\\tsort(potions.begin(), potions.end());  /* prepare for binary search */\\n\\n\\t\\t\\tvector<int> ans(n, 0);  /* answer */\\n\\n\\t\\t\\tfor(int i = 0; i < n; ++i)  /* loop through all spells */\\n\\t\\t\\t{                 \\n\\t\\t\\t\\t/* perform binary search on potions array */\\n\\t\\t\\t\\tint high = potions.size()-1;  \\n\\t\\t\\t\\tint low  = 0;\\n\\t\\t\\t\\twhile(low <= high)  /* search range: [low, high] */\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint mid = low + (high-low)/2;\\n\\t\\t\\t\\t\\tlong long p = potions[mid], s = spells[i];\\n\\t\\t\\t\\t\\tif(p * s < success)low = mid+1;\\n\\t\\t\\t\\t\\telse high = mid-1;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tans[i] = m - high - 1;  /* m - high - 1 because when quiting binary search, low > high, can be also written as m - low */\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2139864,
                "title": "python-simple-binary-search-with-explanation-easy-to-undestand",
                "content": "# Full Explained Solution**\\n```\\nimport math\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        res = [0] * len(spells)\\n        N = len(potions)\\n\\t\\t# sorting potions so we can use binary search on it\\n        potions.sort()\\n        \\n        for i,x in enumerate(spells): # i = index, x = value of spells\\n\\t\\t# req is the minimun value of potion strength, for spell to be successful.\\n\\t\\t# math.ceil(7.1) is 8.    As potion contains only integer, we need celling\\n            req = math.ceil(success/x)\\n            index = N  # assuming last index contains value just bigger than\\n            start, end = 0, N-1 \\n\\t\\t\\t\\n\\t\\t\\t# B.Search left most index, where val of potions is >= to celling in sorted potions.\\n            while start <= end:\\n                mid = start + (end-start)//2\\n                if req <= potions[mid]:\\n\\t\\t\\t\\t# found an index, but tries to find the index in left of the index\\n                    index = mid\\n                    end = mid-1\\n                else:\\n                    start = mid+1\\n\\t\\t\\t# len(potions = N & index = ( \"N\" is nothing found in BS or \"index\" that is found)\\n\\t\\t\\t#  All the values in potions from (index -> N) satisfy \"Success Condition\". append them\\n            res[i] = N - index \\n        return res\\n                \\n```\\nThumbs Up are appericiated\\n\\n\\n# clean code**\\n```\\nimport math\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        N = len(potions)\\n        res = [0] * len(spells)\\n        potions.sort()\\n        \\n        \\n        for i,x in enumerate(spells):\\n            req = math.ceil(success/x)\\n            index = N\\n            start, end = 0, N-1 \\n            while start <= end:\\n                mid = start + (end-start)//2\\n                if req <= potions[mid]:\\n                    index = mid\\n                    end = mid-1\\n                else:\\n                    start = mid+1\\n            res[i] = N - index \\n        return res\\n                \\n  ```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        res = [0] * len(spells)\\n        N = len(potions)\\n\\t\\t# sorting potions so we can use binary search on it\\n        potions.sort()\\n        \\n        for i,x in enumerate(spells): # i = index, x = value of spells\\n\\t\\t# req is the minimun value of potion strength, for spell to be successful.\\n\\t\\t# math.ceil(7.1) is 8.    As potion contains only integer, we need celling\\n            req = math.ceil(success/x)\\n            index = N  # assuming last index contains value just bigger than\\n            start, end = 0, N-1 \\n\\t\\t\\t\\n\\t\\t\\t# B.Search left most index, where val of potions is >= to celling in sorted potions.\\n            while start <= end:\\n                mid = start + (end-start)//2\\n                if req <= potions[mid]:\\n\\t\\t\\t\\t# found an index, but tries to find the index in left of the index\\n                    index = mid\\n                    end = mid-1\\n                else:\\n                    start = mid+1\\n\\t\\t\\t# len(potions = N & index = ( \"N\" is nothing found in BS or \"index\" that is found)\\n\\t\\t\\t#  All the values in potions from (index -> N) satisfy \"Success Condition\". append them\\n            res[i] = N - index \\n        return res\\n                \\n```\n```\\nimport math\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        N = len(potions)\\n        res = [0] * len(spells)\\n        potions.sort()\\n        \\n        \\n        for i,x in enumerate(spells):\\n            req = math.ceil(success/x)\\n            index = N\\n            start, end = 0, N-1 \\n            while start <= end:\\n                mid = start + (end-start)//2\\n                if req <= potions[mid]:\\n                    index = mid\\n                    end = mid-1\\n                else:\\n                    start = mid+1\\n            res[i] = N - index \\n        return res\\n                \\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 2139661,
                "title": "c-using-binary-search",
                "content": "**Approach:** we can sort potions so that if we find a minimal point j in potions where we get success for a spell[i] then j and every greter value than j will give us success, so n-j will be total pairs. And to find this minimal point we will use Binary Search.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        vector<int> res;\\n        int n = potions.size();\\n        sort(potions.begin(), potions.end());\\n        \\n        for (auto& spell : spells) {\\n            int start = 0, end= n-1;\\n            int mid;\\n            while (start <= end) {\\n                mid = (start + end)>>1;\\n                if((long long)spell*potions[mid] >= success)\\n                    end = mid-1;\\n                else\\n                    start = mid+1;\\n            }\\n            \\n            res.push_back(n-start);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**Please do upvote if you like the solution:)**",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        vector<int> res;\\n        int n = potions.size();\\n        sort(potions.begin(), potions.end());\\n        \\n        for (auto& spell : spells) {\\n            int start = 0, end= n-1;\\n            int mid;\\n            while (start <= end) {\\n                mid = (start + end)>>1;\\n                if((long long)spell*potions[mid] >= success)\\n                    end = mid-1;\\n                else\\n                    start = mid+1;\\n            }\\n            \\n            res.push_back(n-start);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139468,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> ans(spells.size());\\n        \\n        sort(begin(potions),end(potions));\\n        \\n        for(int i=0;i<spells.size();i++)\\n        {\\n\\t\\t\\tlong long val = (success + spells[i] - 1)/(spells[i]*1ll);  //take ceil value during division\\n            \\n            int idx = lower_bound(begin(potions),end(potions),val) - begin(potions);\\n            \\n            ans[i] = max((int)potions.size() - idx,0);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> ans(spells.size());\\n        \\n        sort(begin(potions),end(potions));\\n        \\n        for(int i=0;i<spells.size();i++)\\n        {\\n\\t\\t\\tlong long val = (success + spells[i] - 1)/(spells[i]*1ll);  //take ceil value during division\\n            \\n            int idx = lower_bound(begin(potions),end(potions),val) - begin(potions);\\n            \\n            ans[i] = max((int)potions.size() - idx,0);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139411,
                "title": "rust-native-binary-search-solution",
                "content": "```rust\\nuse std::cmp::Ordering;\\n\\nimpl Solution {\\n    pub fn successful_pairs(spells: Vec<i32>, mut potions: Vec<i32>, success: i64) -> Vec<i32> {\\n        let num_potions = potions.len() as i32;\\n        potions.sort_unstable();\\n\\n        let mut result = vec![0; spells.len()];\\n\\n        for (i, spell) in spells.into_iter().enumerate() {\\n            let left = potions\\n                .binary_search_by(|&potion| match (potion as i64 * spell as i64).cmp(&success) {\\n                    Ordering::Less => Ordering::Less,\\n                    // treat equal element as greater so that the BS will always terminate with\\n                    // Error() containing the index of element that is greater or equal to one we\\n                    // searched for\\n                    Ordering::Equal => Ordering::Greater,\\n                    Ordering::Greater => Ordering::Greater,\\n                })\\n                .unwrap_err() as i32;\\n\\n            result[i] = (num_potions - left) as i32;\\n        }\\n\\n        result\\n    }\\n}\\n```\\n\\nBinary search example:\\n\\n```rust\\n#[test]\\nfn test6() {\\n\\t// 4 is missing\\n\\tlet sample = vec![1, 2, 3, 5, 6, 7, 7];\\n\\tlet left = sample\\n\\t\\t.binary_search_by(|&potion| match potion.cmp(&4) {\\n\\t\\t\\tOrdering::Less => Ordering::Less,\\n\\t\\t\\tOrdering::Equal => Ordering::Greater,\\n\\t\\t\\tOrdering::Greater => Ordering::Greater,\\n\\t\\t})\\n\\t\\t.unwrap_err();\\n\\tassert_eq!(sample[left], 5);\\n\\n\\tlet left = sample\\n\\t\\t.binary_search_by(|&potion| match potion.cmp(&3) {\\n\\t\\t\\tOrdering::Less => Ordering::Less,\\n\\t\\t\\tOrdering::Equal => Ordering::Greater,\\n\\t\\t\\tOrdering::Greater => Ordering::Greater,\\n\\t\\t})\\n\\t\\t.unwrap_err();\\n\\tassert_eq!(sample[left], 3);\\n}\\n```\\n\\nEquivalent for:\\n\\n```rust\\nimpl Solution {\\n    pub fn successful_pairs(spells: Vec<i32>, mut potions: Vec<i32>, success: i64) -> Vec<i32> {\\n        let num_potions = potions.len();\\n        potions.sort_unstable();\\n\\n        let mut result = vec![0; spells.len()];\\n\\n        for (i, spell) in spells.into_iter().enumerate() {\\n            let mut left = 0;\\n            let mut right = num_potions;\\n\\n            while left < right {\\n                let mid = left + (right - left) / 2;\\n                if spell as i64 * potions[mid] as i64 >= success {\\n                    right = mid;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n\\n            result[i] = (num_potions - left) as i32;\\n        }\\n\\n        result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Binary Tree"
                ],
                "code": "```rust\\nuse std::cmp::Ordering;\\n\\nimpl Solution {\\n    pub fn successful_pairs(spells: Vec<i32>, mut potions: Vec<i32>, success: i64) -> Vec<i32> {\\n        let num_potions = potions.len() as i32;\\n        potions.sort_unstable();\\n\\n        let mut result = vec![0; spells.len()];\\n\\n        for (i, spell) in spells.into_iter().enumerate() {\\n            let left = potions\\n                .binary_search_by(|&potion| match (potion as i64 * spell as i64).cmp(&success) {\\n                    Ordering::Less => Ordering::Less,\\n                    // treat equal element as greater so that the BS will always terminate with\\n                    // Error() containing the index of element that is greater or equal to one we\\n                    // searched for\\n                    Ordering::Equal => Ordering::Greater,\\n                    Ordering::Greater => Ordering::Greater,\\n                })\\n                .unwrap_err() as i32;\\n\\n            result[i] = (num_potions - left) as i32;\\n        }\\n\\n        result\\n    }\\n}\\n```\n```rust\\n#[test]\\nfn test6() {\\n\\t// 4 is missing\\n\\tlet sample = vec![1, 2, 3, 5, 6, 7, 7];\\n\\tlet left = sample\\n\\t\\t.binary_search_by(|&potion| match potion.cmp(&4) {\\n\\t\\t\\tOrdering::Less => Ordering::Less,\\n\\t\\t\\tOrdering::Equal => Ordering::Greater,\\n\\t\\t\\tOrdering::Greater => Ordering::Greater,\\n\\t\\t})\\n\\t\\t.unwrap_err();\\n\\tassert_eq!(sample[left], 5);\\n\\n\\tlet left = sample\\n\\t\\t.binary_search_by(|&potion| match potion.cmp(&3) {\\n\\t\\t\\tOrdering::Less => Ordering::Less,\\n\\t\\t\\tOrdering::Equal => Ordering::Greater,\\n\\t\\t\\tOrdering::Greater => Ordering::Greater,\\n\\t\\t})\\n\\t\\t.unwrap_err();\\n\\tassert_eq!(sample[left], 3);\\n}\\n```\n```rust\\nimpl Solution {\\n    pub fn successful_pairs(spells: Vec<i32>, mut potions: Vec<i32>, success: i64) -> Vec<i32> {\\n        let num_potions = potions.len();\\n        potions.sort_unstable();\\n\\n        let mut result = vec![0; spells.len()];\\n\\n        for (i, spell) in spells.into_iter().enumerate() {\\n            let mut left = 0;\\n            let mut right = num_potions;\\n\\n            while left < right {\\n                let mid = left + (right - left) / 2;\\n                if spell as i64 * potions[mid] as i64 >= success {\\n                    right = mid;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n\\n            result[i] = (num_potions - left) as i32;\\n        }\\n\\n        result\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2139358,
                "title": "successful-pairs-of-spells-and-potions",
                "content": "**Easy approach Binary search --**\\n**Please Upvote**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& p, long long ss) {\\n           sort(p.begin() , p.end());\\n          vector<long long> res(s.size());\\n          for(int i = 0 ; i< s.size() ; ++i){\\n              res[i] = (ss/s[i]);\\n          }\\n        \\n        vector<int> ans;\\n        for(int i = 0 ;  i < s.size() ; ++i){\\n            \\n            if(ss <= 1LL*res[i]*s[i] ){\\n                 int ind = lower_bound(p.begin() , p.end() , res[i])  - p.begin() ;   \\n                ans.push_back(p.size() - ind);\\n            }else{\\n                 int ind = upper_bound(p.begin() , p.end() , res[i])  - p.begin() ;\\n                      \\n                ans.push_back(p.size() - ind);\\n            }                   \\n           \\n        }\\n           \\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& p, long long ss) {\\n           sort(p.begin() , p.end());\\n          vector<long long> res(s.size());\\n          for(int i = 0 ; i< s.size() ; ++i){\\n              res[i] = (ss/s[i]);\\n          }\\n        \\n        vector<int> ans;\\n        for(int i = 0 ;  i < s.size() ; ++i){\\n            \\n            if(ss <= 1LL*res[i]*s[i] ){\\n                 int ind = lower_bound(p.begin() , p.end() , res[i])  - p.begin() ;   \\n                ans.push_back(p.size() - ind);\\n            }else{\\n                 int ind = upper_bound(p.begin() , p.end() , res[i])  - p.begin() ;\\n                      \\n                ans.push_back(p.size() - ind);\\n            }                   \\n           \\n        }\\n           \\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139299,
                "title": "java-binary-search-sorting",
                "content": "First we sort the potions array, so ,for each spells[i] , we just have to find the smallest index of sorted potions array for which the product is greater than \\'success\\' ... then we can subtract this index from \\'potions\\' array length ... since all the indices after \\'this\\' ( we just found)  index will also provide product greater than success ( since the array is sorted )  \\n\\n\\n\\n\\n```\\n\\n\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int[] potions1 = new int[potions.length];\\n        for(int i=0;i<potions.length;i++){\\n            potions1[i] = potions[i];\\n        }\\n        Arrays.sort(potions1);\\n        int[] arr = new int[spells.length];\\n        \\n        for(int i=0;i<spells.length;i++){\\n            int m = -1;\\n            int n = potions1.length;\\n            long count = 0;\\n            while(n>m+1){\\n                int mid = (m+n)/2;\\n                long mul = (long)spells[i]*(long)potions1[mid];\\n                if(mul >= success){\\n                    n = mid;\\n                }else{\\n                    m = mid;\\n                }\\n            }\\n            \\n            arr[i] = Math.max(arr[i] ,potions1.length - n);\\n            \\n            \\n        }\\n        return arr;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\n\\n\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int[] potions1 = new int[potions.length];\\n        for(int i=0;i<potions.length;i++){\\n            potions1[i] = potions[i];\\n        }\\n        Arrays.sort(potions1);\\n        int[] arr = new int[spells.length];\\n        \\n        for(int i=0;i<spells.length;i++){\\n            int m = -1;\\n            int n = potions1.length;\\n            long count = 0;\\n            while(n>m+1){\\n                int mid = (m+n)/2;\\n                long mul = (long)spells[i]*(long)potions1[mid];\\n                if(mul >= success){\\n                    n = mid;\\n                }else{\\n                    m = mid;\\n                }\\n            }\\n            \\n            arr[i] = Math.max(arr[i] ,potions1.length - n);\\n            \\n            \\n        }\\n        return arr;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139262,
                "title": "easy-to-understand",
                "content": "```\\n public int[] successfulPairs(int[] spells, int[] positions, long suc) {\\n        Arrays.sort(positions);\\n        int []res = new int[spells.length];\\n         for(int i = 0; i<spells.length ;i++){\\n             \\n             int l = 0 , r = positions.length-1;\\n             int num = 0;\\n             while(l<= r){\\n                 \\n                 int m = (r+l)/2;\\n                 long prod = ((long)spells[i]*positions[m]);\\n                 if(prod >=suc){\\n                     r = m-1;\\n                     num = positions.length-m;\\n                 }else{\\n                     l = m+1;\\n                 }\\n             }\\n             res[i] = num;\\n         }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\n public int[] successfulPairs(int[] spells, int[] positions, long suc) {\\n        Arrays.sort(positions);\\n        int []res = new int[spells.length];\\n         for(int i = 0; i<spells.length ;i++){\\n             \\n             int l = 0 , r = positions.length-1;\\n             int num = 0;\\n             while(l<= r){\\n                 \\n                 int m = (r+l)/2;\\n                 long prod = ((long)spells[i]*positions[m]);\\n                 if(prod >=suc){\\n                     r = m-1;\\n                     num = positions.length-m;\\n                 }else{\\n                     l = m+1;\\n                 }\\n             }\\n             res[i] = num;\\n         }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2139243,
                "title": "c-solution-using-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int find(vector<int>&nums,long long val,long long max_val)\\n    {\\n        int l=0;\\n        int r=nums.size()-1;\\n        int ans=0;\\n        int n=nums.size();\\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            if((1ll)*nums[mid]*val>=max_val)\\n            {\\n                ans=n-mid;\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& nums, long long success) \\n    {\\n        int n=s.size();\\n        vector<int>ans;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++)\\n        {\\n            int val=find(nums,s[i],success);\\n            ans.push_back(val);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(vector<int>&nums,long long val,long long max_val)\\n    {\\n        int l=0;\\n        int r=nums.size()-1;\\n        int ans=0;\\n        int n=nums.size();\\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            if((1ll)*nums[mid]*val>=max_val)\\n            {\\n                ans=n-mid;\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& nums, long long success) \\n    {\\n        int n=s.size();\\n        vector<int>ans;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++)\\n        {\\n            int val=find(nums,s[i],success);\\n            ans.push_back(val);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139108,
                "title": "c-simple-code-with-binary-search-o-n-logn",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& p, int i, long long success){\\n        long l = 0, h = p.size()-1;\\n        \\n        while(l <= h){\\n            long mid = l + (h-l)/2;\\n            \\n            if((long long)p[mid]*i >= success){\\n                h = mid-1;\\n            }\\n            else{\\n                l = mid+1;\\n            }\\n        }\\n        \\n        return p.size() - l;\\n    }\\n    \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans;\\n        \\n        for(int i : spells){\\n            int count = solve(potions, i, success);\\n        \\n            if(count < 0)\\n                ans.push_back(0);\\n            else\\n                ans.push_back(count);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& p, int i, long long success){\\n        long l = 0, h = p.size()-1;\\n        \\n        while(l <= h){\\n            long mid = l + (h-l)/2;\\n            \\n            if((long long)p[mid]*i >= success){\\n                h = mid-1;\\n            }\\n            else{\\n                l = mid+1;\\n            }\\n        }\\n        \\n        return p.size() - l;\\n    }\\n    \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans;\\n        \\n        for(int i : spells){\\n            int count = solve(potions, i, success);\\n        \\n            if(count < 0)\\n                ans.push_back(0);\\n            else\\n                ans.push_back(count);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139038,
                "title": "c-o-n-log-m-using-sorting-and-binary-search-code-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    // Sorting and Binary Search\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size(), m = potions.size();\\n        sort(potions.begin(), potions.end()); // Sorting potions so that we can binary search on it\\n        vector<int> ans;\\n        for(int i = 0; i < n; i++) { // For every spell, binary search on the number of potions that can be used such that spells[i] * potions[j] >= success\\n            int l = 0, r = m - 1, c = m;\\n            while(l <= r) {\\n                int mid = l + (r - l) / 2;\\n                if((((long long)potions[mid]) * ((long long)spells[i])) >= success) { // If this particular potion satisfies the condition, then we know that all the potions from potions[mid] to potions[m - 1] should satisfy the condition as well. Hence, we now store this index in \\'c\\' and proceed to find if any lower index in potions satisfy the condition or not\\n                    c = mid;\\n                    r = mid - 1;\\n                } else { // Condition is not satisfied. Hence, we proceed to a higher index to see if the condition is satisfied for any index\\n                    l = mid + 1;\\n                }\\n            }\\n            ans.push_back(m - c); // Since all potions from potions[c] to potions[m - 1] satisfy the condition, we have \\'m - c\\' pairs for this particular spell\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Sorting and Binary Search\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size(), m = potions.size();\\n        sort(potions.begin(), potions.end()); // Sorting potions so that we can binary search on it\\n        vector<int> ans;\\n        for(int i = 0; i < n; i++) { // For every spell, binary search on the number of potions that can be used such that spells[i] * potions[j] >= success\\n            int l = 0, r = m - 1, c = m;\\n            while(l <= r) {\\n                int mid = l + (r - l) / 2;\\n                if((((long long)potions[mid]) * ((long long)spells[i])) >= success) { // If this particular potion satisfies the condition, then we know that all the potions from potions[mid] to potions[m - 1] should satisfy the condition as well. Hence, we now store this index in \\'c\\' and proceed to find if any lower index in potions satisfy the condition or not\\n                    c = mid;\\n                    r = mid - 1;\\n                } else { // Condition is not satisfied. Hence, we proceed to a higher index to see if the condition is satisfied for any index\\n                    l = mid + 1;\\n                }\\n            }\\n            ans.push_back(m - c); // Since all potions from potions[c] to potions[m - 1] satisfy the condition, we have \\'m - c\\' pairs for this particular spell\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139019,
                "title": "c-easy-to-understand-ultimate-binary-search-solution",
                "content": "```\\n#define ll long long int\\n#define ld long double\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& p, long long success) {\\n        sort(p.begin(),p.end());\\n        ll n=p.size();\\n\\n        vector<int> ans;\\n        for(int x:spells)\\n        {\\n            ll up=ceil((success)/(1.0*x));\\n            ll idx=lower_bound(p.begin(),p.end(),up)-p.begin();\\n            if(idx==n)\\n            {\\n                ans.push_back(0);\\n            }\\n            else\\n            ans.push_back(n-idx);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\n#define ld long double\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& p, long long success) {\\n        sort(p.begin(),p.end());\\n        ll n=p.size();\\n\\n        vector<int> ans;\\n        for(int x:spells)\\n        {\\n            ll up=ceil((success)/(1.0*x));\\n            ll idx=lower_bound(p.begin(),p.end(),up)-p.begin();\\n            if(idx==n)\\n            {\\n                ans.push_back(0);\\n            }\\n            else\\n            ans.push_back(n-idx);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138991,
                "title": "beginner-friendly-solution-with-explanation",
                "content": "we are sorting the array potion and performing binary search for each element of array spell and finding the highest index such that spell[i]*poition[i] < success. and storing answer in answer vector\\ntime complexity O(nlogm)\\n\\n```\\nclass Solution {\\npublic:\\n    int find(vector<int>&potions, long long num1, long long success){\\n        int l = 0, r = potions.size()-1;\\n        while(l <= r){\\n            int mid = l+(r-l)/2;\\n            long long num2 = potions[mid];\\n            if(num1*num2 < success){\\n                l = mid+1;\\n            }else{\\n                r = mid-1;\\n            }\\n        }\\n        return l;\\n    }\\n    \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        int n = spells.size();\\n        vector<int>ans;\\n        int m = potions.size();\\n        for(int i=0; i<n; i++){\\n            int idx=find(potions, spells[i], success);\\n            if(idx >= m){\\n                ans.push_back(0);\\n                continue;\\n            }\\n            ans.push_back(m-idx);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(vector<int>&potions, long long num1, long long success){\\n        int l = 0, r = potions.size()-1;\\n        while(l <= r){\\n            int mid = l+(r-l)/2;\\n            long long num2 = potions[mid];\\n            if(num1*num2 < success){\\n                l = mid+1;\\n            }else{\\n                r = mid-1;\\n            }\\n        }\\n        return l;\\n    }\\n    \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        int n = spells.size();\\n        vector<int>ans;\\n        int m = potions.size();\\n        for(int i=0; i<n; i++){\\n            int idx=find(potions, spells[i], success);\\n            if(idx >= m){\\n                ans.push_back(0);\\n                continue;\\n            }\\n            ans.push_back(m-idx);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138908,
                "title": "binary-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        int n=potions.size();\\n        for(int i=0;i<spells.size();i++){\\n            int l=0;\\n            int r=potions.size()-1;\\n            //Binary Search to track from where product is greater than success\\n            while(r>=l){\\n                int mid=l+(r-l)/2;\\n                long long temp = ((long long)(potions[mid])*spells[i]);\\n                if(temp>=success)\\n                    r=mid-1;\\n                else\\n                    l=mid+1;\\n            }\\n            \\n            ans.push_back(n-l);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        int n=potions.size();\\n        for(int i=0;i<spells.size();i++){\\n            int l=0;\\n            int r=potions.size()-1;\\n            //Binary Search to track from where product is greater than success\\n            while(r>=l){\\n                int mid=l+(r-l)/2;\\n                long long temp = ((long long)(potions[mid])*spells[i]);\\n                if(temp>=success)\\n                    r=mid-1;\\n                else\\n                    l=mid+1;\\n            }\\n            \\n            ans.push_back(n-l);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138904,
                "title": "binary-search-python",
                "content": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        ans = []\\n        potions.sort()\\n        m = len(potions)\\n        for s in spells:\\n            l, r = 0, m-1\\n            while l<r:\\n                mid = (r-l)//2+l\\n                if s*potions[mid]>=success:\\n                    r=mid\\n                else:\\n                    l =mid+1\\n            if l==m-1 and s*potions[l]<success:\\n                ans.append(0)\\n            else:\\n                ans.append(m-l)\\n        return ans\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        ans = []\\n        potions.sort()\\n        m = len(potions)\\n        for s in spells:\\n            l, r = 0, m-1\\n            while l<r:\\n                mid = (r-l)//2+l\\n                if s*potions[mid]>=success:\\n                    r=mid\\n                else:\\n                    l =mid+1\\n            if l==m-1 and s*potions[l]<success:\\n                ans.append(0)\\n            else:\\n                ans.append(m-l)\\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 2138871,
                "title": "easy-math-ratio-solution-binary-search-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        int n = spells.size(),m = potions.size();\\n        vector<int> ans;\\n        for(int i = 0; i < n; i++){\\n            double ratio = (double)success / spells[i];\\n            long long mnfind = ceil(ratio);\\n            vector<int>::iterator lower = lower_bound(potions.begin(), potions.end(), mnfind);\\n            int x = lower - potions.begin();\\n            ans.push_back(m - x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        int n = spells.size(),m = potions.size();\\n        vector<int> ans;\\n        for(int i = 0; i < n; i++){\\n            double ratio = (double)success / spells[i];\\n            long long mnfind = ceil(ratio);\\n            vector<int>::iterator lower = lower_bound(potions.begin(), potions.end(), mnfind);\\n            int x = lower - potions.begin();\\n            ans.push_back(m - x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138844,
                "title": "binary-search-o-1-space-comment-s",
                "content": "```\\nclass Solution {\\npublic:\\n    // simple binary search\\n    int bs(vector<int> &num,int &x,long long &success){\\n        int l=0,r=num.size()-1;\\n        while(l<=r){\\n            int mid = l + (r-l)/2;\\n            long long m = (long long)x*num[mid];\\n            if(m>=success){\\n                r=mid-1;\\n            }else{\\n                l=mid+1;\\n            }\\n        }\\n        return l;\\n    }\\n    \\n    vector<int> successfulPairs(vector<int>& s, vector<int>& p, long long success) {\\n        // here we will not use any extra space just update answer to spell array\\n        // sort poision array\\n        sort(p.begin(),p.end());\\n        // iterate over spell array\\n        for(int i=0;i<s.size();i++){\\n            // pass poision vector , spell[i] and success to binary search\\n            // subtract it from poision size \\n            // because we will get number of small multiplication\\n            s[i] = p.size()-bs(p,s[i],success);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // simple binary search\\n    int bs(vector<int> &num,int &x,long long &success){\\n        int l=0,r=num.size()-1;\\n        while(l<=r){\\n            int mid = l + (r-l)/2;\\n            long long m = (long long)x*num[mid];\\n            if(m>=success){\\n                r=mid-1;\\n            }else{\\n                l=mid+1;\\n            }\\n        }\\n        return l;\\n    }\\n    \\n    vector<int> successfulPairs(vector<int>& s, vector<int>& p, long long success) {\\n        // here we will not use any extra space just update answer to spell array\\n        // sort poision array\\n        sort(p.begin(),p.end());\\n        // iterate over spell array\\n        for(int i=0;i<s.size();i++){\\n            // pass poision vector , spell[i] and success to binary search\\n            // subtract it from poision size \\n            // because we will get number of small multiplication\\n            s[i] = p.size()-bs(p,s[i],success);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3895036,
                "title": "easy-c-solution-beats-100-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe need to find the minimum possible element in potions which can be an answer all  the numbers greter to it will be a solution.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst we will  sort the potions array. iterate through the spells array to find the answer for each spell. using binary search we find the minimum element which can be an answer. all the numbers inpotions greater than potions[mid] will also be an answer as will make the product bigger than befor. so we consider potions.size() - mid elements as our answer.\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long s) {\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        for(int i = 0; i < spells.size(); i++){\\n            int l = 0;\\n            int r = potions.size()-1;\\n            int temp = 0;\\n            while(l <= r){\\n                int mid = (l + r)/2;\\n                if((long long)spells[i] * (long long)potions[mid] < s){\\n                    l = mid + 1;\\n                }\\n                else{\\n                    temp = potions.size() - mid;\\n                    r = mid - 1;\\n                }\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long s) {\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        for(int i = 0; i < spells.size(); i++){\\n            int l = 0;\\n            int r = potions.size()-1;\\n            int temp = 0;\\n            while(l <= r){\\n                int mid = (l + r)/2;\\n                if((long long)spells[i] * (long long)potions[mid] < s){\\n                    l = mid + 1;\\n                }\\n                else{\\n                    temp = potions.size() - mid;\\n                    r = mid - 1;\\n                }\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796607,
                "title": "python",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def successfulPairs(\\n        self, spells: List[int], potions: List[int], success: int\\n    ) -> List[int]:\\n        potions.sort()\\n        m = len(potions)\\n        return [m - bisect_left(potions, success / v) for v in spells]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def successfulPairs(\\n        self, spells: List[int], potions: List[int], success: int\\n    ) -> List[int]:\\n        potions.sort()\\n        m = len(potions)\\n        return [m - bisect_left(potions, success / v) for v in spells]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738801,
                "title": "sorting-mlogm-and-traverse-binary-serach-nlogm-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        int n=spells.size();\\n        vector<int>pairs(n,0);\\n        int m=potions.size();\\n        for(int i=0;i<n;i++){\\n            int l=0,r=m-1;\\n            while(l<=r){\\n                int mid=l+(r-l)/2;\\n                if(1LL*potions[mid]*spells[i]>=success){\\n                     r=mid-1;\\n\\n                }\\n                else{\\n                    l=mid+1;\\n                }\\n            }\\n            pairs[i]=m-l;\\n\\n        }\\n        return pairs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        int n=spells.size();\\n        vector<int>pairs(n,0);\\n        int m=potions.size();\\n        for(int i=0;i<n;i++){\\n            int l=0,r=m-1;\\n            while(l<=r){\\n                int mid=l+(r-l)/2;\\n                if(1LL*potions[mid]*spells[i]>=success){\\n                     r=mid-1;\\n\\n                }\\n                else{\\n                    l=mid+1;\\n                }\\n            }\\n            pairs[i]=m-l;\\n\\n        }\\n        return pairs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717671,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n\\n        int n = spells.size();\\n        int m = potions.size();\\n\\n        vector<int>ans;\\n\\n        sort(potions.begin(),potions.end());\\n        \\n        for(auto& x: spells){\\n            int s=0;\\n            int e = m-1;\\n            while(s<=e){\\n\\n                int mid = s+(e-s)/2;\\n                long long a = ceil((1.0 * success)/x);\\n                if(potions[mid]>=a){\\n                    e=mid-1;\\n                }\\n                else{\\n                    s=mid+1;\\n                }\\n            }\\n\\n            ans.push_back(m-s);\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n\\n        int n = spells.size();\\n        int m = potions.size();\\n\\n        vector<int>ans;\\n\\n        sort(potions.begin(),potions.end());\\n        \\n        for(auto& x: spells){\\n            int s=0;\\n            int e = m-1;\\n            while(s<=e){\\n\\n                int mid = s+(e-s)/2;\\n                long long a = ceil((1.0 * success)/x);\\n                if(potions[mid]>=a){\\n                    e=mid-1;\\n                }\\n                else{\\n                    s=mid+1;\\n                }\\n            }\\n\\n            ans.push_back(m-s);\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626556,
                "title": "c-sorting-lower-bound-easy-solution",
                "content": "# Approach\\n- Sort the portions array in ascending order.\\n- Iterate over the spells array and for each spells[i], find the minimum required potion for it. \\n- Check for the index of potion in potions array using binary search to find the number of potions greter than required.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> ans;\\n        int n=potions.size();\\n        sort(potions.begin(),potions.end());\\n        for(int i=0;i<spells.size();i++){\\n            long long req = ceil(1.0 * success/spells[i]);\\n            if(req>potions[potions.size()-1]){\\n                ans.push_back(0);\\n                continue;\\n            }\\n            auto idx= lower_bound(potions.begin(),potions.end(),req) - potions.begin();\\n            ans.push_back(n-idx);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> ans;\\n        int n=potions.size();\\n        sort(potions.begin(),potions.end());\\n        for(int i=0;i<spells.size();i++){\\n            long long req = ceil(1.0 * success/spells[i]);\\n            if(req>potions[potions.size()-1]){\\n                ans.push_back(0);\\n                continue;\\n            }\\n            auto idx= lower_bound(potions.begin(),potions.end(),req) - potions.begin();\\n            ans.push_back(n-idx);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565630,
                "title": "99-90-beats-c-o-n-m-k-0ms",
                "content": "\\n# Complexity\\n- Time complexity: O(n+m+k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(maxSpell)\\nwhere, maxSpell is the maximum value in the spells vector. The counts vector is created with a size of maxSpell+1, which contributes to the space complexity.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) \\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        int maxSpell = 0;\\n        for(int i=0; i<spells.size(); ++i){  //O(n)\\n            maxSpell = max(maxSpell, spells[i]);\\n        }\\n        vector<int> counts(maxSpell+1, 0);\\n\\n        for(int i=0; i<potions.size(); ++i){ //O(m)\\n            auto index = (success+potions[i]-1)/potions[i]; //minimum required spell power\\n            if(index<counts.size()) counts[index]++;\\n        }\\n\\n        for(int i=1; i<counts.size(); ++i){ //O(k)\\n            counts[i] +=counts[i-1];\\n        }\\n\\n        vector<int> result(spells.size(), 0);\\n        for(int i=0; i<spells.size(); ++i){ //O(n)\\n            result[i] = counts[spells[i]];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) \\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        int maxSpell = 0;\\n        for(int i=0; i<spells.size(); ++i){  //O(n)\\n            maxSpell = max(maxSpell, spells[i]);\\n        }\\n        vector<int> counts(maxSpell+1, 0);\\n\\n        for(int i=0; i<potions.size(); ++i){ //O(m)\\n            auto index = (success+potions[i]-1)/potions[i]; //minimum required spell power\\n            if(index<counts.size()) counts[index]++;\\n        }\\n\\n        for(int i=1; i<counts.size(); ++i){ //O(k)\\n            counts[i] +=counts[i-1];\\n        }\\n\\n        vector<int> result(spells.size(), 0);\\n        for(int i=0; i<spells.size(); ++i){ //O(n)\\n            result[i] = counts[spells[i]];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395355,
                "title": "python-simple-solution-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n\\n        potions.sort()\\n        n=len(potions)\\n        arr=[]\\n        for i in spells:\\n            if(i*potions[n-1]<success):\\n                arr.append(0)\\n            else:\\n                num=math.ceil(success/i)\\n                start=0\\n                end=n\\n                flag=0\\n                while(start<=end):\\n                    mid=(start+end)//2\\n                    if(mid<n and potions[mid]>=num and potions[mid-1]<num):\\n                        arr.append(n-mid)\\n                        flag=1\\n                        break\\n                    elif(mid<n and potions[mid]<num):\\n                        start=mid+1\\n                    else:\\n                        end=mid-1\\n                if(flag==0):\\n                    arr.append(n-mid)\\n        return arr\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n\\n        potions.sort()\\n        n=len(potions)\\n        arr=[]\\n        for i in spells:\\n            if(i*potions[n-1]<success):\\n                arr.append(0)\\n            else:\\n                num=math.ceil(success/i)\\n                start=0\\n                end=n\\n                flag=0\\n                while(start<=end):\\n                    mid=(start+end)//2\\n                    if(mid<n and potions[mid]>=num and potions[mid-1]<num):\\n                        arr.append(n-mid)\\n                        flag=1\\n                        break\\n                    elif(mid<n and potions[mid]<num):\\n                        start=mid+1\\n                    else:\\n                        end=mid-1\\n                if(flag==0):\\n                    arr.append(n-mid)\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376030,
                "title": "simple-solution",
                "content": "\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] SuccessfulPairs(int[] spells, int[] potions, long success) {\\n        \\n        Array.Sort(potions);\\n        List<int> res = new List<int>();\\n\\n        foreach (int spell in spells) {\\n            int l = 0;\\n            int r = potions.Length - 1;\\n            int index = potions.Length;\\n\\n            while (l <= r) {\\n                int m = (l + r) / 2;\\n\\n                if (((long)spell * potions[m]) >= success) {\\n                    r = m - 1;\\n                    index = m;\\n                } else {\\n                    l = m + 1;\\n                }\\n            }\\n\\n            res.Add(potions.Length - index);\\n        }\\n\\n        return res.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] SuccessfulPairs(int[] spells, int[] potions, long success) {\\n        \\n        Array.Sort(potions);\\n        List<int> res = new List<int>();\\n\\n        foreach (int spell in spells) {\\n            int l = 0;\\n            int r = potions.Length - 1;\\n            int index = potions.Length;\\n\\n            while (l <= r) {\\n                int m = (l + r) / 2;\\n\\n                if (((long)spell * potions[m]) >= success) {\\n                    r = m - 1;\\n                    index = m;\\n                } else {\\n                    l = m + 1;\\n                }\\n            }\\n\\n            res.Add(potions.Length - index);\\n        }\\n\\n        return res.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3374581,
                "title": "simple-java-1ms-beats-100-easy-to-understand-look-at-once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach: simple binary search approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n         Arrays.sort(potions);\\n        int[] count = new int[spells.length];\\n       \\n        for (int i = 0; i < spells.length; i++) {\\n            int spell = spells[i];\\n            int low = 0;\\n            int high = potions.length - 1;\\n            while (low <= high) {\\n                int mid = low + (high - low) / 2;\\n                long product = (long) spell * potions[mid];\\n                if (product >= success) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            }\\n            count[i] = potions.length - low;\\n        }\\n        return count;\\n    }\\n}\\n```\\n# If this solution helped you, give it an up-vote to help others![download.jfif](https://assets.leetcode.com/users/images/3b0f35ff-0fad-47ea-809c-46a596b73c5f_1680525047.0606627.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n         Arrays.sort(potions);\\n        int[] count = new int[spells.length];\\n       \\n        for (int i = 0; i < spells.length; i++) {\\n            int spell = spells[i];\\n            int low = 0;\\n            int high = potions.length - 1;\\n            while (low <= high) {\\n                int mid = low + (high - low) / 2;\\n                long product = (long) spell * potions[mid];\\n                if (product >= success) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            }\\n            count[i] = potions.length - low;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373247,
                "title": "c-solution-easy-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& p, long long success) {\\n        \\n        vector<int> pairs(s.size(),0);\\n        sort(p.begin(),p.end());\\n        \\n        for(int i=0;i<s.size();i++){\\n            int beg=0,end=p.size()-1;\\n            while(beg<=end){\\n                int mid = (beg + end) / 2;\\n                if( (long long int)s[i] * (long long int)p[mid] >= success){\\n                    end = mid - 1;\\n                }\\n                else{\\n                    beg = mid + 1;\\n                }\\n            }\\n            pairs[i] = p.size() - beg;\\n        }\\n\\n        return pairs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& p, long long success) {\\n        \\n        vector<int> pairs(s.size(),0);\\n        sort(p.begin(),p.end());\\n        \\n        for(int i=0;i<s.size();i++){\\n            int beg=0,end=p.size()-1;\\n            while(beg<=end){\\n                int mid = (beg + end) / 2;\\n                if( (long long int)s[i] * (long long int)p[mid] >= success){\\n                    end = mid - 1;\\n                }\\n                else{\\n                    beg = mid + 1;\\n                }\\n            }\\n            pairs[i] = p.size() - beg;\\n        }\\n\\n        return pairs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372302,
                "title": "python-simple-binary-search-dictionary",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition and solution behind this problem is derived from 35.Search Insert position (easy). Check out my profile to view the solution of 35, and know why binary search on this , works.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Use same code from search insert position, with slight modifications. \\n- Use a hashtable to store first occurence of each index, and later refer it (for duplicates).\\n- Find the insert/position of ceil(success/spells[i])\\n\\n\\n# Complexity\\n- Time complexity: O(m * logn) + O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        #Sort\\n        #Find lower bound for spell[i]\\n        #len-lowerBound =n\\n        #output[i]=n\\n        potions.sort()\\n        final=[]\\n        print(potions)\\n        d={}\\n        for i in range(len(potions)):\\n            try:\\n                d[potions[i]]=d[potions[i]]\\n            except:\\n                d[potions[i]]=i\\n        for i in spells:\\n            j=0\\n            target=ceil(success/i)\\n            #----------------Search insert position solution--------------------\\n            first=0\\n            last=len(potions)-1\\n            mid=(first+last)//2\\n            while(first<=last):\\n                mid=(first+last)//2\\n                if(potions[mid]==target):\\n                    break\\n                elif(potions[mid]<target):\\n                    first=mid+1\\n                else:\\n                    last=mid-1\\n            if(potions[mid]<target):\\n                mid+=1\\n            #---------------------------------------------------------------------\\n            if(mid>=0 and mid<len(potions)):\\n                mid=d[potions[mid]]\\n            n=len(potions)-mid\\n            final.append(n)\\n        return final\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        #Sort\\n        #Find lower bound for spell[i]\\n        #len-lowerBound =n\\n        #output[i]=n\\n        potions.sort()\\n        final=[]\\n        print(potions)\\n        d={}\\n        for i in range(len(potions)):\\n            try:\\n                d[potions[i]]=d[potions[i]]\\n            except:\\n                d[potions[i]]=i\\n        for i in spells:\\n            j=0\\n            target=ceil(success/i)\\n            #----------------Search insert position solution--------------------\\n            first=0\\n            last=len(potions)-1\\n            mid=(first+last)//2\\n            while(first<=last):\\n                mid=(first+last)//2\\n                if(potions[mid]==target):\\n                    break\\n                elif(potions[mid]<target):\\n                    first=mid+1\\n                else:\\n                    last=mid-1\\n            if(potions[mid]<target):\\n                mid+=1\\n            #---------------------------------------------------------------------\\n            if(mid>=0 and mid<len(potions)):\\n                mid=d[potions[mid]]\\n            n=len(potions)-mid\\n            final.append(n)\\n        return final\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372284,
                "title": "two-pointer-approach-leetcode-daily-c-explained-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    //T: O(m log m + n log n), S:O(n + log m)\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {   \\n        unordered_map<int, pair<int,int>> m; //{index,numpair}\\n        //Now creating a copy of spells vector\\n        vector<int> numspair(spells);\\n        //Now storing the spells and mapping its index onto the map\\n        for(int i=0;i<spells.size();i++){ // O(m)\\n            m[spells[i]]={i,-1};\\n        }\\n        //Now sorting both the vectors\\n        //Considering the length m of spells\\n        sort(spells.begin(),spells.end()); // O(m log m)\\n        //Considering the length n of potions\\n        sort(potions.begin(),potions.end());// O(n log n)\\n        \\n        int potionptr=potions.size()-1;\\n        \\n        // Two Pointer Approach\\n        //Starting spell pointer from left\\n        // And potion pointer from right\\n        for(int i=0;i<spells.size();i++){  //O(m)\\n            int spell=spells[i];\\n            while(potionptr>=0 && (long long) spell*potions[potionptr]>=success){\\n                potionptr--;\\n            }\\n            m[spell]={m[spell].first,potions.size()-1-potionptr};\\n           /*cout<<\"Value:\"<<spell<<\"-->\"<<\"Index:\"<<m[spell].first<<\"-->\"<<\"count:\"<<m[spell].second<<endl;------>this shows how count is being stored for every index and the index\\'s value*/\\n        }\\n        int index=0;\\n        for(int spell: numspair){ // O(m)\\n            numspair[index++]=m[spell].second;\\n        }\\n        return numspair;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    //T: O(m log m + n log n), S:O(n + log m)\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {   \\n        unordered_map<int, pair<int,int>> m; //{index,numpair}\\n        //Now creating a copy of spells vector\\n        vector<int> numspair(spells);\\n        //Now storing the spells and mapping its index onto the map\\n        for(int i=0;i<spells.size();i++){ // O(m)\\n            m[spells[i]]={i,-1};\\n        }\\n        //Now sorting both the vectors\\n        //Considering the length m of spells\\n        sort(spells.begin(),spells.end()); // O(m log m)\\n        //Considering the length n of potions\\n        sort(potions.begin(),potions.end());// O(n log n)\\n        \\n        int potionptr=potions.size()-1;\\n        \\n        // Two Pointer Approach\\n        //Starting spell pointer from left\\n        // And potion pointer from right\\n        for(int i=0;i<spells.size();i++){  //O(m)\\n            int spell=spells[i];\\n            while(potionptr>=0 && (long long) spell*potions[potionptr]>=success){\\n                potionptr--;\\n            }\\n            m[spell]={m[spell].first,potions.size()-1-potionptr};\\n           /*cout<<\"Value:\"<<spell<<\"-->\"<<\"Index:\"<<m[spell].first<<\"-->\"<<\"count:\"<<m[spell].second<<endl;------>this shows how count is being stored for every index and the index\\'s value*/\\n        }\\n        int index=0;\\n        for(int spell: numspair){ // O(m)\\n            numspair[index++]=m[spell].second;\\n        }\\n        return numspair;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3372205,
                "title": "2300-successful-pairs-of-spells-and-potions",
                "content": "\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& port, long long success) {\\n        \\nvector<int>res;\\n    sort(port.begin(),port.end());\\n\\n      for(auto spell:spells)\\n      {\\n\\n             long port_need = (success + spell -1 )/ spell;\\n\\n             auto it = lower_bound(port.begin(),port.end(),port_need); // store a number \\n             res.push_back(port.end()-it);\\n\\n      }\\n      return res;\\n\\n    }\\n};\\n\\n\\n```\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& port, long long success) {\\n        \\nvector<int>res;\\n    sort(port.begin(),port.end());\\n\\n      for(auto spell:spells)\\n      {\\n\\n             long port_need = (success + spell -1 )/ spell;\\n\\n             auto it = lower_bound(port.begin(),port.end(),port_need); // store a number \\n             res.push_back(port.end()-it);\\n\\n      }\\n      return res;\\n\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372000,
                "title": "easiest-4-line-solution-c-95-memory-o-n-log-m",
                "content": "# Intuition\\nThe minimum potion strength required for each spell to succeed can be calculated as ceil((double)success/spells[i])\\n\\n# Approach\\nFirst, we sort the potions array in ascending order. Now we can apply binary search to search the index of the minimum potion strength required for each spell. This operation will take O(log(m)) time. Once we have the index, we can find the total number of potions that can succeed with that spell, since all the potions after the index can also be used with that spell to succeed (the strengths of potion after that index will always be greater than or equal to the potion strength at that index since potions array is sorted). Finally, we store the answer in spell array itself to save memory.\\n\\n# Complexity\\n- Time complexity:\\nO(n*log(m))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n    sort (potions.begin(),potions.end());\\n    for (int i=0;i<spells.size();i++){\\n        spells[i]= potions.size() - (lower_bound(potions.begin(),potions.end(),ceil((double)success/spells[i]))-potions.begin());\\n    }\\n    return spells;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n    sort (potions.begin(),potions.end());\\n    for (int i=0;i<spells.size();i++){\\n        spells[i]= potions.size() - (lower_bound(potions.begin(),potions.end(),ceil((double)success/spells[i]))-potions.begin());\\n    }\\n    return spells;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371999,
                "title": "simple-binary-search-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsort the portion array since we only need a count from them \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& p, long long s) {\\n\\n\\n        vector<int>ans(spells.size(),0);\\n        int n=spells.size();\\n        int m=p.size();\\n        sort(p.begin(),p.end());\\n        for(int i=0;i<spells.size();i++){\\n        int low=0;\\n        int high=p.size()-1;\\n\\n            long long  cs=spells[i];\\n            int cr=-1;\\n            while(low<=high){\\n                int mid=low+(high-low)/2;\\n                if(cs*p[mid]<s){\\n                    low=mid+1;\\n                }else if(cs*p[mid]>=s){\\n                    high=mid-1;\\n                    cr=mid;\\n                }\\n            }\\n            if(cr!=-1){\\n                ans[i]=p.size()-cr;\\n            }\\n            \\n\\n\\n        }\\n           \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& p, long long s) {\\n\\n\\n        vector<int>ans(spells.size(),0);\\n        int n=spells.size();\\n        int m=p.size();\\n        sort(p.begin(),p.end());\\n        for(int i=0;i<spells.size();i++){\\n        int low=0;\\n        int high=p.size()-1;\\n\\n            long long  cs=spells[i];\\n            int cr=-1;\\n            while(low<=high){\\n                int mid=low+(high-low)/2;\\n                if(cs*p[mid]<s){\\n                    low=mid+1;\\n                }else if(cs*p[mid]>=s){\\n                    high=mid-1;\\n                    cr=mid;\\n                }\\n            }\\n            if(cr!=-1){\\n                ans[i]=p.size()-cr;\\n            }\\n            \\n\\n\\n        }\\n           \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371980,
                "title": "java-self-explanatory",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int[] arr = new int[spells.length];\\n        Arrays.sort(potions);\\n        for(int i=0;i<spells.length;i++){\\n            arr[i] = getPairs(spells[i],potions,success);\\n        }\\n        return arr;\\n    }\\n\\n    private int getPairs(int x, int[] potions,long success){\\n        int low = 0;\\n        int high = potions.length-1;\\n        while(low <= high){\\n            int mid = low +(high-low)/2;\\n            if((long)potions[mid]*x >= success){\\n                high = mid-1;\\n            }\\n            else\\n                low = mid+1;\\n        }\\n\\n        return potions.length - low;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int[] arr = new int[spells.length];\\n        Arrays.sort(potions);\\n        for(int i=0;i<spells.length;i++){\\n            arr[i] = getPairs(spells[i],potions,success);\\n        }\\n        return arr;\\n    }\\n\\n    private int getPairs(int x, int[] potions,long success){\\n        int low = 0;\\n        int high = potions.length-1;\\n        while(low <= high){\\n            int mid = low +(high-low)/2;\\n            if((long)potions[mid]*x >= success){\\n                high = mid-1;\\n            }\\n            else\\n                low = mid+1;\\n        }\\n\\n        return potions.length - low;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371966,
                "title": "binary-search-c-very-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n#define ll long long\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int>ans;\\n         sort(potions.begin(),potions.end());\\n       for(int i=0;i<spells.size();i++){\\n           int spell=spells[i];\\n           int low=0;\\n           int high=potions.size()-1;\\n           while(low<=high){\\n               int mid=low+(high-low)/2;\\n               long long pair_val=((ll)spell * (ll)potions[mid]);\\n               if(pair_val>=success){\\n                   high=mid-1;\\n               }\\n               else{\\n                     low=mid+1;\\n               }\\n           }\\n           ans.push_back(potions.size()-low);\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n#define ll long long\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int>ans;\\n         sort(potions.begin(),potions.end());\\n       for(int i=0;i<spells.size();i++){\\n           int spell=spells[i];\\n           int low=0;\\n           int high=potions.size()-1;\\n           while(low<=high){\\n               int mid=low+(high-low)/2;\\n               long long pair_val=((ll)spell * (ll)potions[mid]);\\n               if(pair_val>=success){\\n                   high=mid-1;\\n               }\\n               else{\\n                     low=mid+1;\\n               }\\n           }\\n           ans.push_back(potions.size()-low);\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371958,
                "title": "easy-to-understand-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogm)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int>pairs;\\n        sort(potions.begin(),potions.end());\\n        for(int i=0;i<n;i++){\\n           int low = 0;\\n           int high = m-1;\\n           int cnt =0;\\n           while(low<=high){\\n               long long mid = low+(high-low)/2;\\n               if((long)spells[i]*(long)potions[mid]>=success){\\n                    cnt += high-mid+1;\\n                    high = mid-1;\\n               }\\n               else if((long)spells[i]*(long)potions[mid]<success){\\n                   low = mid+1;\\n               }\\n           }\\n          pairs.push_back(cnt);\\n        }\\n        return pairs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int>pairs;\\n        sort(potions.begin(),potions.end());\\n        for(int i=0;i<n;i++){\\n           int low = 0;\\n           int high = m-1;\\n           int cnt =0;\\n           while(low<=high){\\n               long long mid = low+(high-low)/2;\\n               if((long)spells[i]*(long)potions[mid]>=success){\\n                    cnt += high-mid+1;\\n                    high = mid-1;\\n               }\\n               else if((long)spells[i]*(long)potions[mid]<success){\\n                   low = mid+1;\\n               }\\n           }\\n          pairs.push_back(cnt);\\n        }\\n        return pairs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371863,
                "title": "simple-java-solution-with-detailed-steps-easy-to-understand-intuitive-solution-binary-search",
                "content": "# Intuition\\nFind the potion indices which on multiplication with spell result  atleast success.\\n\\n# Approach\\n**Brute Force Approach:** Iterate over spellls array and compare with each potion value if multiplication is more than or equals to success.\\n***Time complexity:*** As we are multiplying each potion with each spell, TC for this approach will be O(M*N).\\n***Space complexity:***: We are not using any additional space as part of our algorightm. We are creating an result array which is required as part of ans so we will consider it into our space complexity as its required for the answer.\\n\\n---\\n\\n**Optimized approach:** Let\\'s sort the potion array in ascending order. Now if somehow we can find the starting index which on multiplication with spell results into success then all the indices on it\\'s right will also results in success (potion array is sorted in ascending order). So we don\\'t need to check for each and every potion indices for success, we only need to find the starting index.\\nAs we have sorted the potion array, finding the starting index can be done using binary search. This will reduce our time complexity to find the starting index from O(N) to O(logN). \\nIf we have a valid starting index which means there are some potion values which will result into success so all the indices on it\\'s right will also results in success (So simply store the potion length - starting index as count for that spell). If didn\\'t find a valid potion which results into success then simply store 0 for that spell.\\n   \\n***Time complexity:***  Sorting the potion array will take O(N*logN). Iterating over spell array will result in O(M) TC and finding the starting index using binary search will take O(logN) so resultant Time Complexity will be O(Max(M, N) * logN)).\\n***Space complexity:***: We are not using any additional space as part of our algorightm. We are creating an result array which is required as part of ans so we will consider it into our space complexity as its required for the answer.\\n\\n# Kindly upvote if you liked the solution \\n![upvote.png](https://assets.leetcode.com/users/images/fc02b3ed-fbd5-4f2a-8065-67160bf2fe0e_1680460909.0296853.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        \\n        //Sort the array so that we can apply binary search on the array\\n        Arrays.sort(potions);\\n        int pLen = potions.length, startIndex = -1;\\n        int[] ans = new int[spells.length];\\n       \\n        //Iterate over spells and find starting potion index for each spell which will give success\\n        for(int s = 0; s < spells.length; s++){\\n            \\n            //using binary search find the starting index which results into success \\n            startIndex = getStartSuccessIndex(potions, spells[s], success);\\n\\n            //If a valid index is found then all the indices to it\\'s right will also result in success\\n            if(startIndex >= 0){\\n                ans[s] = pLen - startIndex;\\n            }else{\\n                //If no valid index is found then 0 results will be formed\\n                ans[s] = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private int getStartSuccessIndex(int[] potions, long spell, long success){\\n        int ans = -1, p = potions.length;\\n        int left = 0, right = p-1, mid = (right+left)/2;\\n        while(left <= right){\\n            mid = (left+right)/2;\\n            //If product of mid potion value with spll is >= success then this mighte be our ans so store it into ans variable and look for smaller index on the left side. \\n            if(potions[mid] * spell >= success){\\n                ans = mid;\\n                right = mid -1;\\n            }else {\\n                left = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        \\n        //Sort the array so that we can apply binary search on the array\\n        Arrays.sort(potions);\\n        int pLen = potions.length, startIndex = -1;\\n        int[] ans = new int[spells.length];\\n       \\n        //Iterate over spells and find starting potion index for each spell which will give success\\n        for(int s = 0; s < spells.length; s++){\\n            \\n            //using binary search find the starting index which results into success \\n            startIndex = getStartSuccessIndex(potions, spells[s], success);\\n\\n            //If a valid index is found then all the indices to it\\'s right will also result in success\\n            if(startIndex >= 0){\\n                ans[s] = pLen - startIndex;\\n            }else{\\n                //If no valid index is found then 0 results will be formed\\n                ans[s] = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private int getStartSuccessIndex(int[] potions, long spell, long success){\\n        int ans = -1, p = potions.length;\\n        int left = 0, right = p-1, mid = (right+left)/2;\\n        while(left <= right){\\n            mid = (left+right)/2;\\n            //If product of mid potion value with spll is >= success then this mighte be our ans so store it into ans variable and look for smaller index on the left side. \\n            if(potions[mid] * spell >= success){\\n                ans = mid;\\n                right = mid -1;\\n            }else {\\n                left = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371825,
                "title": "binary-search-approach",
                "content": "# Intuition\\nTo find index of success value in sorted list if it is present in list else to find the insertion index of success value in sorted list.\\n\\n# Approach\\n\\nBinary Search\\n\\n# Complexity\\n- Time complexity:O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        s = []\\n        for i in spells:\\n            left = 0\\n            right = len(potions)\\n            while left < right:\\n                mid = (left + right) // 2\\n                if i * potions[mid] >= success:\\n                    right = mid\\n                else:\\n                    left = mid + 1\\n            s.append(len(potions) - left)\\n\\n        return s\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        s = []\\n        for i in spells:\\n            left = 0\\n            right = len(potions)\\n            while left < right:\\n                mid = (left + right) // 2\\n                if i * potions[mid] >= success:\\n                    right = mid\\n                else:\\n                    left = mid + 1\\n            s.append(len(potions) - left)\\n\\n        return s\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371813,
                "title": "c-soln-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n  n -> size of spells array and\\n  m -> size of potions array\\n\\n- Time complexity: O(nlog(m))\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        int m=potions.size(), n=spells.size();\\n        vector<int> ans;\\n\\n        for(int i=0; i<n; i++){\\n            int left=0, right=m-1;\\n            while(left<=right){\\n                int mid=(left+right)/2;\\n                long long temp = (long long)potions[mid]*spells[i];\\n                if(temp<success)\\n                  left=mid+1;\\n                else right=mid-1;\\n            }\\n            ans.push_back(m-left);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        int m=potions.size(), n=spells.size();\\n        vector<int> ans;\\n\\n        for(int i=0; i<n; i++){\\n            int left=0, right=m-1;\\n            while(left<=right){\\n                int mid=(left+right)/2;\\n                long long temp = (long long)potions[mid]*spells[i];\\n                if(temp<success)\\n                  left=mid+1;\\n                else right=mid-1;\\n            }\\n            ans.push_back(m-left);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371808,
                "title": "simple-binary-search-sorting-c",
                "content": "Sort both the arrays. Now for each spell find the min index in 2nd array such that it\\'s product with currect element of 1st array is greater than success value . Now all the elements after this index will surely have product greater than required success value.\\n\\nTime Complexity -> O(nlogn)\\n\\n```\\ntypedef long long int ll ;\\nstruct data {\\n    int index, count, a ;\\n};\\nbool comp(struct data A, struct data B){\\n    return A.a < B.a;\\n}\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size(), m = potions.size();\\n        vector<struct data>v(n);\\n        for(int i = 0 ; i< n; i++){\\n            v[i].a = spells[i];\\n            v[i].index = i;\\n            v[i].count = 0 ;\\n        }\\n        sort(v.begin(), v.end(), comp);\\n        sort(potions.begin(), potions.end());\\n        for(int i = 0 ; i < n; i++){\\n            ll reqd = success/v[i].a ;\\n            if(success%v[i].a != 0)\\n                reqd ++ ;\\n            int ind = lower_bound(potions.begin(), potions.end(), reqd) - potions.begin();\\n            if(ind == m)\\n                v[i].count = 0 ;\\n            else\\n                v[i].count = m-ind;\\n        }\\n        vector<int>ans(n) ;\\n        for(auto it: v)\\n            ans[it.index] = it.count;\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\ntypedef long long int ll ;\\nstruct data {\\n    int index, count, a ;\\n};\\nbool comp(struct data A, struct data B){\\n    return A.a < B.a;\\n}\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size(), m = potions.size();\\n        vector<struct data>v(n);\\n        for(int i = 0 ; i< n; i++){\\n            v[i].a = spells[i];\\n            v[i].index = i;\\n            v[i].count = 0 ;\\n        }\\n        sort(v.begin(), v.end(), comp);\\n        sort(potions.begin(), potions.end());\\n        for(int i = 0 ; i < n; i++){\\n            ll reqd = success/v[i].a ;\\n            if(success%v[i].a != 0)\\n                reqd ++ ;\\n            int ind = lower_bound(potions.begin(), potions.end(), reqd) - potions.begin();\\n            if(ind == m)\\n                v[i].count = 0 ;\\n            else\\n                v[i].count = m-ind;\\n        }\\n        vector<int>ans(n) ;\\n        for(auto it: v)\\n            ans[it.index] = it.count;\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371786,
                "title": "eeeee",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int [] result = new int[spells.length];\\n        int potionsLength = potions.length;\\n        Arrays.sort(potions);\\n\\n        for(int i=0; i<spells.length; i++){\\n            int minIndex = binarySearch(potions, success, spells[i]);\\n            result[i] = potionsLength - minIndex;\\n        }\\n        return result;\\n    }\\n\\n    private int binarySearch(int [] potions, long success, int spell){\\n        int left= 0;\\n        int right= potions.length;\\n        while(left<right){\\n            int mid = left + (right-left)/2;\\n            long product = (1l * spell) * potions[mid];\\n                if(product<success)\\n                    left=mid+1;\\n                else\\n                    right=mid;\\n            }\\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int [] result = new int[spells.length];\\n        int potionsLength = potions.length;\\n        Arrays.sort(potions);\\n\\n        for(int i=0; i<spells.length; i++){\\n            int minIndex = binarySearch(potions, success, spells[i]);\\n            result[i] = potionsLength - minIndex;\\n        }\\n        return result;\\n    }\\n\\n    private int binarySearch(int [] potions, long success, int spell){\\n        int left= 0;\\n        int right= potions.length;\\n        while(left<right){\\n            int mid = left + (right-left)/2;\\n            long product = (1l * spell) * potions[mid];\\n                if(product<success)\\n                    left=mid+1;\\n                else\\n                    right=mid;\\n            }\\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371778,
                "title": "c-very-easy-solution-beginner-friendly-easy-to-understand-loaded-with-comments",
                "content": "# Intuition\\nLet us commence with the brute-force approach and progressively optimize it. Initially, we can write a brute-force algorithm using two loops: one for spells and another for potions. During each iteration, we will verify whether \"spells\\\\[i]\\\\*potions\\\\[i]>=success\". However, since the maximum size of m and n is 10e5 and this approach is quadratic, it will result in \"Time Limit Exceeded(TLE)\". This is due to the fact that in a second, the maximum operation which we can perform is approximately 1e8-1e9, whereas here it can be 1e10 at max.\\n\\nOptimization No:-1: Firstly, we will sort the potions vector. Since, as per the condition, we have to find the count satisfying \"spells\\\\[i]*potions\\\\[i]>=success\", using simple mathematics, we can convert it to \"potions\\\\[i]>=success/spells\\\\[i]\". However, there is a catch - in C++, if we divide without typecasting, it will round off to the nearest integer, but we want the answer to be calculated in floating-point, and then we will take the ceil of the number. Let me illustrate the problem we face without using typecasting and taking ceil of the result. Suppose success=16, spells\\\\[i]=3, then potions\\\\[i]>=16/3 in order to satisfy \"spells\\\\[i]*potions\\\\[i]>=success\". Therefore, 16/3 will be 5, and when we multiply 5 with 3, it comes out to be 15<16. So, to avoid this, if we typecast division, then (1.0*16)/3 would be 5.33..., and if we take ceil of that, we will end up getting 6, and that will satisfy our condition as 3*6=18>=16. Using the lower\\\\_bound function, we can calculate the index of the number >=potions\\\\[i] we have calculated just aforehead. So, the answer for that spells\\\\[i]=n-index. Here, n is the size of the potions vector.\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\n- Brute Force: O(m*n);\\n- optimised Code:O(nlogn+mlogm);\\n-  Space complexity:\\n   - O(n)\\n\\n# Code\\n```\\n// BRUTE FORCE APPROACH and it will give TLE \\n//AS (N*M<=10e10 operations and that can\\'t pass within a second)\\n\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n      vector<int>v;\\n      for(int i=0;i<spells.size();i++){\\n          int count=0;\\n          int x =spells[i];\\n          for(int j=0;j<potions.size();j++){\\n              long long result= (1LL*x*potions[j]);\\n              if(result>=success){\\n                count++;\\n              } \\n          }\\n      v.push_back(count);\\n      }\\n      return v;\\n    }\\n};\\n\\n// Optimised no :1 Here we are using STL\\n\\n// Let\\'s write the optimised version\\n// Still here we are using the stl function to find lower_bound which internally implements binary search but interviewer in some case might not allow to use STL so in that case we will have to write lower_bound using bs internally by ourself.\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n    int m = spells.size();\\n    int n =potions.size();\\n    sort(begin(potions),end(potions));\\n    int maxPotionValue=potions[n-1];\\n    vector<int>ans;\\n    for(int i=0;i<m;i++){\\n        int spell=spells[i];\\n        // spell*potions[i]>=success \\n        long long minPotion=ceil((1.0*success)/spell);\\n        if(minPotion>maxPotionValue) {\\n            ans.emplace_back(0);\\n            continue;\\n        }\\n        int index=lower_bound(begin(potions),end(potions),minPotion)-begin(potions);\\n        int count=n-index;\\n        ans.emplace_back(count);\\n    } \\n    return ans ;  \\n    }\\n};\\n // Optimised Code :2 Here We are writing lower_bound by ourself\\n\\n// Let\\'s write the most optimised version\\nclass Solution {\\npublic:\\nint apnaLowerBound(int l , int r , int target,vector<int>& potions ){\\n    int ans=0;\\n    int mid=0;\\n    while(l<=r){\\n        mid=l+(r-l)/2;\\n        if(potions[mid]>=target){\\n            ans=mid;\\n            r=mid-1;\\n        }\\n        else{\\n            l=mid+1;\\n        }\\n    }\\n    return ans ;\\n}\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n    int m = spells.size();\\n    int n =potions.size();\\n    sort(begin(potions),end(potions));\\n    int maxPotionValue=potions[n-1];\\n    vector<int>ans;\\n    for(int i=0;i<m;i++){\\n        int spell=spells[i];\\n        // spell*potions[i]>=success \\n        long long minPotion=ceil((1.0*success)/spell);\\n        if(minPotion>maxPotionValue) {\\n            ans.emplace_back(0);\\n            continue;\\n        }\\n        // int index=lower_bound(begin(potions),end(potions),minPotion)-begin(potions);\\n        // We will calculate index now using our own function \\n        int index=apnaLowerBound(0,n-1,minPotion,potions);\\n        int count=n-index;\\n        ans.emplace_back(count);\\n    } \\n    return ans ;  \\n    }\\n};\\n\\n\\n\\n\\n\\n```\\nCAN I GET AN UPVOTE PLS , IT TOOK LOTS OF EFFORT TO PEN THIS DOWN \\uD83D\\uDE07\\uD83D\\uDE4F\\uD83D\\uDE4F",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\n// BRUTE FORCE APPROACH and it will give TLE \\n//AS (N*M<=10e10 operations and that can\\'t pass within a second)\\n\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n      vector<int>v;\\n      for(int i=0;i<spells.size();i++){\\n          int count=0;\\n          int x =spells[i];\\n          for(int j=0;j<potions.size();j++){\\n              long long result= (1LL*x*potions[j]);\\n              if(result>=success){\\n                count++;\\n              } \\n          }\\n      v.push_back(count);\\n      }\\n      return v;\\n    }\\n};\\n\\n// Optimised no :1 Here we are using STL\\n\\n// Let\\'s write the optimised version\\n// Still here we are using the stl function to find lower_bound which internally implements binary search but interviewer in some case might not allow to use STL so in that case we will have to write lower_bound using bs internally by ourself.\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n    int m = spells.size();\\n    int n =potions.size();\\n    sort(begin(potions),end(potions));\\n    int maxPotionValue=potions[n-1];\\n    vector<int>ans;\\n    for(int i=0;i<m;i++){\\n        int spell=spells[i];\\n        // spell*potions[i]>=success \\n        long long minPotion=ceil((1.0*success)/spell);\\n        if(minPotion>maxPotionValue) {\\n            ans.emplace_back(0);\\n            continue;\\n        }\\n        int index=lower_bound(begin(potions),end(potions),minPotion)-begin(potions);\\n        int count=n-index;\\n        ans.emplace_back(count);\\n    } \\n    return ans ;  \\n    }\\n};\\n // Optimised Code :2 Here We are writing lower_bound by ourself\\n\\n// Let\\'s write the most optimised version\\nclass Solution {\\npublic:\\nint apnaLowerBound(int l , int r , int target,vector<int>& potions ){\\n    int ans=0;\\n    int mid=0;\\n    while(l<=r){\\n        mid=l+(r-l)/2;\\n        if(potions[mid]>=target){\\n            ans=mid;\\n            r=mid-1;\\n        }\\n        else{\\n            l=mid+1;\\n        }\\n    }\\n    return ans ;\\n}\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n    int m = spells.size();\\n    int n =potions.size();\\n    sort(begin(potions),end(potions));\\n    int maxPotionValue=potions[n-1];\\n    vector<int>ans;\\n    for(int i=0;i<m;i++){\\n        int spell=spells[i];\\n        // spell*potions[i]>=success \\n        long long minPotion=ceil((1.0*success)/spell);\\n        if(minPotion>maxPotionValue) {\\n            ans.emplace_back(0);\\n            continue;\\n        }\\n        // int index=lower_bound(begin(potions),end(potions),minPotion)-begin(potions);\\n        // We will calculate index now using our own function \\n        int index=apnaLowerBound(0,n-1,minPotion,potions);\\n        int count=n-index;\\n        ans.emplace_back(count);\\n    } \\n    return ans ;  \\n    }\\n};\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371574,
                "title": "c-binary-search-easiest-beginner-friendly-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo reduce the time complexity, you could sort the \"potions\" vector and use binary search to find the number of successful pairs for each spell. This would reduce the time complexity to O(n log n).\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> pass;\\n        sort(potions.begin(), potions.end());\\n        for (int i = 0; i < spells.size(); i++)\\n        {\\n            int lo = 0, hi = potions.size() - 1;\\n            while (lo <= hi)\\n            {\\n                int mid = lo + (hi - lo) / 2;\\n                if ((long long)spells[i] * potions[mid] >= success)\\n                    hi = mid - 1;\\n                else\\n                    lo = mid + 1;\\n            }\\n            pass.push_back(potions.size() - lo);\\n        }\\n        return pass;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> pass;\\n        sort(potions.begin(), potions.end());\\n        for (int i = 0; i < spells.size(); i++)\\n        {\\n            int lo = 0, hi = potions.size() - 1;\\n            while (lo <= hi)\\n            {\\n                int mid = lo + (hi - lo) / 2;\\n                if ((long long)spells[i] * potions[mid] >= success)\\n                    hi = mid - 1;\\n                else\\n                    lo = mid + 1;\\n            }\\n            pass.push_back(potions.size() - lo);\\n        }\\n        return pass;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371475,
                "title": "simple-python-code-binary-search",
                "content": "# Approach: `Binary Search`\\n\\n# Complexity\\n- Time complexity: `O(N LogN)`\\n\\n- Space complexity: ` O(N) `\\n\\n# Code\\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        x = []\\n        for i in spells:\\n            l,r,ans = 0,len(potions)-1,0\\n            while l<=r:\\n                m = (l+r)//2\\n                if (potions[m]*i)>=success:\\n                    ans+=(r-m+1)\\n                    r=m-1\\n                else: l=m+1\\n            x.append(ans);\\n        return x\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        x = []\\n        for i in spells:\\n            l,r,ans = 0,len(potions)-1,0\\n            while l<=r:\\n                m = (l+r)//2\\n                if (potions[m]*i)>=success:\\n                    ans+=(r-m+1)\\n                    r=m-1\\n                else: l=m+1\\n            x.append(ans);\\n        return x\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371469,
                "title": "2-approach-easy-c-solution-brute-force-and-optimized-approach-binary-search",
                "content": "# Approach 1: Brute Force Approach\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n\\n- Space complexity: O(1)\\n\\nwhere n == spells.length and m == potions.length\\n\\n# Code\\n```\\n// Brute Force Approach\\n// Time complexity -> O(n*m) and Space -> O(1)\\n// where n == spells.length and m == potions.length\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> ans;\\n        for(int i=0;i<spells.size();i++)\\n        {\\n            int pairCount=0;\\n            for(int j=0;j<potions.size();j++)\\n            {\\n                long long check=(long long)(potions[j])*(long long)(spells[i]);\\n                if(check>=success)\\n                {\\n                    pairCount++;\\n                }\\n            }\\n            ans.push_back(pairCount);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nAbove code \\u274C give time limit Exceeded due to high complexity O(n*m)\\n\\n# Approach 2: Optimized Approach\\n\\n# Complexity\\n- Time complexity: O((n+m)log(m))\\n\\n- Space complexity: O(logm)\\n\\nwhere n == spells.length and m == potions.length\\n\\n# Code\\n```\\n// Optimized Approach [Binary Search]\\n// Time complexity -> O((n+m)log(m)) and Space -> O(logm)\\n// where n == spells.length and m == potions.length\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n=spells.size();\\n        int m=potions.size();\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        int maxPotionValue=potions[m-1];\\n        for(int i=0;i<n;i++)\\n        {\\n            int spell=spells[i];\\n            // minPotion*spell>=success\\n            long long minPotion=ceil((1.0*success)/spell);\\n            if(minPotion>maxPotionValue)\\n            {\\n                ans.push_back(0);\\n                continue;\\n            }\\n            int index=lower_bound(potions.begin(),potions.end(),minPotion)-potions.begin();\\n\\n            int count=m-index;\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n**OR**\\n\\n```\\nclass Solution {\\nprivate:\\n    int LowerBound(int l, int r,vector<int> &potions,int minPotion)\\n    {\\n        int possibleIndex=-1;\\n        while(l<=r)\\n        {\\n            int mid=l+(r-l)/2;\\n            if(potions[mid]>=minPotion)\\n            {\\n                possibleIndex=mid;\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return possibleIndex;\\n    }\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n=spells.size();\\n        int m=potions.size();\\n        sort(potions.begin(),potions.end()); // O(mlogm)\\n        vector<int> ans;\\n        int maxPotionValue=potions[m-1];\\n        for(int i=0;i<n;i++) // O(n*logm)\\n        {\\n            int spell=spells[i];\\n            // minPotion*spell>=success\\n            long long minPotion=ceil((1.0*success)/spell);\\n            if(minPotion>maxPotionValue)\\n            {\\n                ans.push_back(0);\\n                continue;\\n            }\\n            int index=LowerBound(0,m-1,potions,minPotion);\\n            int count=m-index;\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n**Explanation**\\n\\n![WhatsApp Image 2023-04-02 at 22.15.27.jpg](https://assets.leetcode.com/users/images/067ebdc3-350c-4847-866d-6bf25d838ec1_1680454005.8449535.jpeg)\\n\\n![WhatsApp Image 2023-04-02 at 22.15.28.jpg](https://assets.leetcode.com/users/images/5b991ac6-dca3-40e1-b392-ae6ea9056f73_1680454019.0853117.jpeg)\\n\\n![WhatsApp Image 2023-04-02 at 22.15.28.jpg](https://assets.leetcode.com/users/images/59d30d22-48ca-4928-b1ff-5d553d83d28f_1680454031.2301693.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\n// Brute Force Approach\\n// Time complexity -> O(n*m) and Space -> O(1)\\n// where n == spells.length and m == potions.length\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> ans;\\n        for(int i=0;i<spells.size();i++)\\n        {\\n            int pairCount=0;\\n            for(int j=0;j<potions.size();j++)\\n            {\\n                long long check=(long long)(potions[j])*(long long)(spells[i]);\\n                if(check>=success)\\n                {\\n                    pairCount++;\\n                }\\n            }\\n            ans.push_back(pairCount);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n// Optimized Approach [Binary Search]\\n// Time complexity -> O((n+m)log(m)) and Space -> O(logm)\\n// where n == spells.length and m == potions.length\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n=spells.size();\\n        int m=potions.size();\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        int maxPotionValue=potions[m-1];\\n        for(int i=0;i<n;i++)\\n        {\\n            int spell=spells[i];\\n            // minPotion*spell>=success\\n            long long minPotion=ceil((1.0*success)/spell);\\n            if(minPotion>maxPotionValue)\\n            {\\n                ans.push_back(0);\\n                continue;\\n            }\\n            int index=lower_bound(potions.begin(),potions.end(),minPotion)-potions.begin();\\n\\n            int count=m-index;\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\nprivate:\\n    int LowerBound(int l, int r,vector<int> &potions,int minPotion)\\n    {\\n        int possibleIndex=-1;\\n        while(l<=r)\\n        {\\n            int mid=l+(r-l)/2;\\n            if(potions[mid]>=minPotion)\\n            {\\n                possibleIndex=mid;\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return possibleIndex;\\n    }\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n=spells.size();\\n        int m=potions.size();\\n        sort(potions.begin(),potions.end()); // O(mlogm)\\n        vector<int> ans;\\n        int maxPotionValue=potions[m-1];\\n        for(int i=0;i<n;i++) // O(n*logm)\\n        {\\n            int spell=spells[i];\\n            // minPotion*spell>=success\\n            long long minPotion=ceil((1.0*success)/spell);\\n            if(minPotion>maxPotionValue)\\n            {\\n                ans.push_back(0);\\n                continue;\\n            }\\n            int index=LowerBound(0,m-1,potions,minPotion);\\n            int count=m-index;\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371463,
                "title": "accepted-time-complexity-o-n-log-n",
                "content": "# Complexity\\n- Time complexity:\\nO(nlog(n))\\n\\n# Code\\n```\\nclass Solution {\\n    func successfulPairs(_ spells: [Int], _ potions: [Int], _ success: Int) -> [Int] {\\n        var potions = potions\\n        potions.sort()\\n        var returnArr = [Int]()\\n\\n        for spell in spells {\\n            var i = 0 \\n            var j = potions.count-1\\n            if potions[j]*spell < success {\\n                returnArr.append(0)\\n                continue\\n            }\\n             if potions[0]*spell >= success {\\n                returnArr.append(potions.count)\\n                continue\\n            }\\n\\n            while i<=j {\\n                let mid = (i+j)/2\\n                if potions[mid]*spell >= success && potions[mid-1]*spell < success {\\n                    returnArr.append(potions.count-mid)\\n                    break\\n                } else if potions[mid]*spell >= success {\\n                    j = mid-1\\n                } else {\\n                    i = mid+1\\n                }\\n            }\\n        }\\n        return returnArr\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func successfulPairs(_ spells: [Int], _ potions: [Int], _ success: Int) -> [Int] {\\n        var potions = potions\\n        potions.sort()\\n        var returnArr = [Int]()\\n\\n        for spell in spells {\\n            var i = 0 \\n            var j = potions.count-1\\n            if potions[j]*spell < success {\\n                returnArr.append(0)\\n                continue\\n            }\\n             if potions[0]*spell >= success {\\n                returnArr.append(potions.count)\\n                continue\\n            }\\n\\n            while i<=j {\\n                let mid = (i+j)/2\\n                if potions[mid]*spell >= success && potions[mid-1]*spell < success {\\n                    returnArr.append(potions.count-mid)\\n                    break\\n                } else if potions[mid]*spell >= success {\\n                    j = mid-1\\n                } else {\\n                    i = mid+1\\n                }\\n            }\\n        }\\n        return returnArr\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371458,
                "title": "c-accepted-time-complexity-o-n-log-n",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(nlog(n))\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n         vector<int> ans;\\n         sort(potions.begin(),potions.end());\\n        for(int i=0;i<spells.size();i++){\\n            int count=0;\\n            int start=0;\\n            int end=potions.size();\\n            while(start<end){\\n\\n                int mid = (start+end)/2;\\n\\n                if(potions[mid]*1ll*spells[i]>=success){\\n                  end = mid;\\n                }\\n                else{\\n                   start=mid+1;\\n                }\\n                    \\n                \\n            }\\n            \\n           count+=potions.size()-end;\\n\\n\\n            ans.push_back(count);\\n        }\\n\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n         vector<int> ans;\\n         sort(potions.begin(),potions.end());\\n        for(int i=0;i<spells.size();i++){\\n            int count=0;\\n            int start=0;\\n            int end=potions.size();\\n            while(start<end){\\n\\n                int mid = (start+end)/2;\\n\\n                if(potions[mid]*1ll*spells[i]>=success){\\n                  end = mid;\\n                }\\n                else{\\n                   start=mid+1;\\n                }\\n                    \\n                \\n            }\\n            \\n           count+=potions.size()-end;\\n\\n\\n            ans.push_back(count);\\n        }\\n\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371435,
                "title": "simplest-approach-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity  \\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spell, vector<int>& potion, long long success) {\\n      vector<int>v;\\n      sort(potion.begin(),potion.end());\\n      for(int i=0;i<spell.size();i++){\\n          int l=0;\\n          int h=potion.size()-1;\\n          int count=0;\\n          bool f=false;\\n          int mid;\\n          while(l<=h){\\n            mid=(l+h)/2;\\n          long long res=(long long)spell[i]*(long long)potion[mid];\\n          if(res>=success){\\n          count=mid;\\n          h=mid-1;\\n          f=true;\\n          }\\n          else\\n          l=mid+1;\\n      }\\n       if(f)\\n          v.push_back(potion.size()-count);  \\n       else \\n          v.push_back(0);\\n        }\\n        return v;       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spell, vector<int>& potion, long long success) {\\n      vector<int>v;\\n      sort(potion.begin(),potion.end());\\n      for(int i=0;i<spell.size();i++){\\n          int l=0;\\n          int h=potion.size()-1;\\n          int count=0;\\n          bool f=false;\\n          int mid;\\n          while(l<=h){\\n            mid=(l+h)/2;\\n          long long res=(long long)spell[i]*(long long)potion[mid];\\n          if(res>=success){\\n          count=mid;\\n          h=mid-1;\\n          f=true;\\n          }\\n          else\\n          l=mid+1;\\n      }\\n       if(f)\\n          v.push_back(potion.size()-count);  \\n       else \\n          v.push_back(0);\\n        }\\n        return v;       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371395,
                "title": "c-binary-search-simple-easy-solution",
                "content": "# Complexity\\n- Time complexity:`O(n log n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:`O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int getSuccess(int spell , vector<int>& potions , long long success){\\n\\n        int n = potions.size();\\n        int lo = 0 , hi = n -  1;\\n        int successfull_Pairs = 0;\\n\\n        while(lo <= hi){\\n\\n            int mid = lo + (hi - lo) / 2;\\n            long long product = (long long)spell * (long long)potions[mid];\\n\\n            if(product >= success){\\n                successfull_Pairs = n - mid;\\n                hi = mid - 1;\\n            }\\n            else{\\n                lo = mid + 1;\\n            }\\n\\n        }\\n\\n        return successfull_Pairs;\\n    }\\n\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        sort(potions.begin(),potions.end());\\n\\n        int n = spells.size();\\n        vector<int>result;\\n\\n        for(int i=0;i<n;i++){\\n\\n            int pairs = getSuccess(spells[i],potions,success);\\n            result.push_back(pairs);\\n\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int getSuccess(int spell , vector<int>& potions , long long success){\\n\\n        int n = potions.size();\\n        int lo = 0 , hi = n -  1;\\n        int successfull_Pairs = 0;\\n\\n        while(lo <= hi){\\n\\n            int mid = lo + (hi - lo) / 2;\\n            long long product = (long long)spell * (long long)potions[mid];\\n\\n            if(product >= success){\\n                successfull_Pairs = n - mid;\\n                hi = mid - 1;\\n            }\\n            else{\\n                lo = mid + 1;\\n            }\\n\\n        }\\n\\n        return successfull_Pairs;\\n    }\\n\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        sort(potions.begin(),potions.end());\\n\\n        int n = spells.size();\\n        vector<int>result;\\n\\n        for(int i=0;i<n;i++){\\n\\n            int pairs = getSuccess(spells[i],potions,success);\\n            result.push_back(pairs);\\n\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371306,
                "title": "java-binary-search-solution",
                "content": "# Intuition \\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe brute force will result in O(n^2) time complexity so to minimise it we apply binary search within the outer loop to search for start of the element where the target or the success is achieved.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the array first to apply the binary search since we only need the count. And then search for the element idx for each spell where after which the success is achieved in the array. Now simply add the count in the ans array and return it.\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long target) {\\n        int[] ans = new int[spells.length];\\n        Arrays.sort(potions);\\n        for(int i = 0; i < spells.length; i++){\\n            int ele = spells[i];\\n            int st = 0;\\n            int end = potions.length-1;\\n            int idx = -1;\\n            while(st <= end){\\n                int mid = (st+end)/2;\\n                if((long)potions[mid]*ele > target){\\n                    end = mid-1;\\n                }else if((long)potions[mid]*ele < target){\\n                    st = mid+1;\\n                }else{\\n                    idx = mid;\\n                    end = mid-1;\\n                }\\n            }\\n            if(idx == -1){\\n                idx = st;\\n            }\\n            ans[i] = potions.length-idx;\\n        }\\n        return ans;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long target) {\\n        int[] ans = new int[spells.length];\\n        Arrays.sort(potions);\\n        for(int i = 0; i < spells.length; i++){\\n            int ele = spells[i];\\n            int st = 0;\\n            int end = potions.length-1;\\n            int idx = -1;\\n            while(st <= end){\\n                int mid = (st+end)/2;\\n                if((long)potions[mid]*ele > target){\\n                    end = mid-1;\\n                }else if((long)potions[mid]*ele < target){\\n                    st = mid+1;\\n                }else{\\n                    idx = mid;\\n                    end = mid-1;\\n                }\\n            }\\n            if(idx == -1){\\n                idx = st;\\n            }\\n            ans[i] = potions.length-idx;\\n        }\\n        return ans;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371267,
                "title": "2300-successful-pairs-of-spells-and-potions",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length;\\n        int m = potions.length;\\n        int[] pairs = new int[n];\\n        Arrays.sort(potions);\\n        for (int i = 0; i < n; i++) {\\n            int spell = spells[i];\\n            int left = 0;\\n            int right = m - 1;\\n            while (left <= right) {\\n                int mid = left + (right - left) / 2;\\n                long product = (long) spell * potions[mid];\\n                if (product >= success) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n            pairs[i] = m - left;\\n        }\\n        return pairs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length;\\n        int m = potions.length;\\n        int[] pairs = new int[n];\\n        Arrays.sort(potions);\\n        for (int i = 0; i < n; i++) {\\n            int spell = spells[i];\\n            int left = 0;\\n            int right = m - 1;\\n            while (left <= right) {\\n                int mid = left + (right - left) / 2;\\n                long product = (long) spell * potions[mid];\\n                if (product >= success) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n            pairs[i] = m - left;\\n        }\\n        return pairs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371199,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) \\n    {\\n        vector<int>ans;\\n        int m=spells.size();\\n        int n=potions.size();\\n        sort(potions.begin(),potions.end());\\n        for(int i=0;i<m;i++)\\n        {\\n            long long pro=spells[i];\\n            int l=0;\\n            int r=n-1;\\n            int count=0;\\n            while(l<=r){\\n                long long mid=l+(r-l)/2;\\n                if(success<=(pro*potions[mid]))\\n                {\\n                    count=n-mid;\\n                    r=mid-1;\\n                }\\n                else\\n                {\\n                    l=mid+1;\\n                }\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) \\n    {\\n        vector<int>ans;\\n        int m=spells.size();\\n        int n=potions.size();\\n        sort(potions.begin(),potions.end());\\n        for(int i=0;i<m;i++)\\n        {\\n            long long pro=spells[i];\\n            int l=0;\\n            int r=n-1;\\n            int count=0;\\n            while(l<=r){\\n                long long mid=l+(r-l)/2;\\n                if(success<=(pro*potions[mid]))\\n                {\\n                    count=n-mid;\\n                    r=mid-1;\\n                }\\n                else\\n                {\\n                    l=mid+1;\\n                }\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371116,
                "title": "sort-binary-search-in-c-with-explanation",
                "content": "# Approach\\nSort and apply binary search on the potions\\n\\n# Complexity\\n- Time complexity:\\n$$O(mlogm) + O(nlogm)$$ mlogm is for sorting and nlogm is for binary search\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n\\n    int bsearch(vector<int>& arr, long long target, int mul) {\\n        int sz = arr.size();\\n        if( (arr[0]*1LL) *mul  > target)\\n            return 0;\\n        if( (arr[sz-1]*1LL) *mul  < target)\\n            return sz;\\n        int st = 0, ed = sz-1, idx = sz-1;\\n        while(st <= ed) {\\n            int mid = (st + ed)/2;\\n            if(target <= (arr[mid]*1LL) *mul) {\\n                idx = mid;\\n                ed = mid - 1;\\n            }\\n            else\\n                st = mid + 1;\\n        }\\n        return idx;\\n    }\\n\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> ans;\\n        sort(potions.begin(),potions.end());\\n        int n = spells.size();\\n        int m = potions.size();\\n        for(int i=0;i<n;i++) {\\n            ans.push_back(m - bsearch(potions, success, spells[i]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n\\n    int bsearch(vector<int>& arr, long long target, int mul) {\\n        int sz = arr.size();\\n        if( (arr[0]*1LL) *mul  > target)\\n            return 0;\\n        if( (arr[sz-1]*1LL) *mul  < target)\\n            return sz;\\n        int st = 0, ed = sz-1, idx = sz-1;\\n        while(st <= ed) {\\n            int mid = (st + ed)/2;\\n            if(target <= (arr[mid]*1LL) *mul) {\\n                idx = mid;\\n                ed = mid - 1;\\n            }\\n            else\\n                st = mid + 1;\\n        }\\n        return idx;\\n    }\\n\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> ans;\\n        sort(potions.begin(),potions.end());\\n        int n = spells.size();\\n        int m = potions.size();\\n        for(int i=0;i<n;i++) {\\n            ans.push_back(m - bsearch(potions, success, spells[i]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371111,
                "title": "master-the-art-of-spell-and-potion-pairing-a-typescript-binary-search-approach-100-87-50",
                "content": "# Intuition\\nGiven two arrays representing the strengths of spells and potions, our task is to find the number of successful pairs for each spell. A pair is considered successful if the product of the strengths of the spell and the potion is at least equal to a given `success` value. To solve this problem efficiently, we can take advantage of a binary search algorithm on the sorted potions array for each spell.\\n\\n# Approach\\n1. **Sort the potions array:** First, we sort the potions array in ascending order. This enables us to perform binary search on the array later in the process. Sorting takes $$O(m * log(m))$$ time, where m is the length of the potions array.\\n2. **Define a binary search function:** We create a binary search function that takes an array and a target value as inputs. The function iterates over the array and finds the index where the target value should be inserted while maintaining the sorted order of the array. This function has a time complexity of $$O(log(m))$$ as it is applied to the sorted potions array.\\n3. **Iterate over spells:** For each spell in the spells array, we calculate the minimum potion strength required to form a successful pair. To do this, we divide the `success` value by the strength of the current spell and round up to the nearest integer. This gives us the minimum potion strength that, when multiplied by the current spell strength, will produce a product greater than or equal to the `success` value. We then use the binary search function to find the index where this minimum potion strength should be inserted in the sorted potions array.\\n4. **Calculate the number of successful pairs:** The number of successful pairs for a given spell is the difference between the length of the potions array and the index found using binary search. This is because all the potions at the index and to the right of it in the sorted array have a strength greater than or equal to the minimum potion strength required for a successful pair with the current spell.\\n5. **Return an array with the results:** Finally, we return an array with the number of successful pairs for each spell by mapping over the spells array and performing the above steps for each element. The returned array has the same length as the input spells array.\\n\\n# Complexity\\nTime complexity: $$O(n\\u2217log(m))$$, where n is the length of the spells array and m is the length of the potions array. This complexity is due to sorting the potions array in $$O(m * log(m))$$ time and performing binary search on the potions array for each spell in $$O(n * log(m))$$ time.\\nSpace complexity: $$O(1)$$, as we only use a constant amount of additional memory for temporary variables.\\n\\n# Code\\n```\\n/**\\n * Performs binary search on a sorted array to find the index where the target value should be inserted.\\n * \\n * @param arr - A sorted array of numbers.\\n * @param target - The target number to be searched for.\\n * @returns The index where the target value should be inserted to maintain the sorted order.\\n */\\nfunction binarySearch(arr: number[], target: number): number {\\n  let left = 0;\\n  let right = arr.length - 1;\\n\\n  // Iterate until the left and right pointers converge.\\n  while (left <= right) {\\n    const mid = left + Math.floor((right - left) / 2);\\n\\n    if (arr[mid] < target) {\\n      left = mid + 1;\\n    } else {\\n      right = mid - 1;\\n    }\\n  }\\n\\n  // Return the index where the target value should be inserted.\\n  return left;\\n}\\n\\n/**\\n * Calculates the number of successful pairs of spells and potions.\\n * A spell and potion pair is considered successful if the product of their strengths is at least `success`.\\n *\\n * @param spells - An array of integers representing the strengths of the spells.\\n * @param potions - An array of integers representing the strengths of the potions.\\n * @param success - An integer representing the minimum product of spell and potion strengths required for success.\\n * @returns An array of integers representing the number of potions that will form a successful pair with each spell.\\n */\\nfunction successfulPairs(spells: number[], potions: number[], success: number): number[] {\\n  // Sort the potions list in ascending order to allow for efficient binary search.\\n  potions.sort((a, b) => a - b);\\n\\n  // Iterate over each spell in the spells list and use binary search to find the index of the first potion\\n  // that forms a successful pair, then calculate the number of successful pairs for each spell.\\n  // The map function creates a new array with the results of calling the provided function on every element in the original spells array.\\n  return spells.map(\\n    // Calculate the minimum potion strength required to form a successful pair\\n    // with the current spell, and use binary search to find the index where the target value should be inserted.\\n    (spell) => potions.length - binarySearch(potions, Math.ceil(success / spell))\\n  );\\n}\\n```\\n![2300. Successful Pairs of Spells and Potions.PNG](https://assets.leetcode.com/users/images/e1438d97-4336-441e-bc1c-810381166d23_1680447034.2240133.png)\\n",
                "solutionTags": [
                    "TypeScript",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * Performs binary search on a sorted array to find the index where the target value should be inserted.\\n * \\n * @param arr - A sorted array of numbers.\\n * @param target - The target number to be searched for.\\n * @returns The index where the target value should be inserted to maintain the sorted order.\\n */\\nfunction binarySearch(arr: number[], target: number): number {\\n  let left = 0;\\n  let right = arr.length - 1;\\n\\n  // Iterate until the left and right pointers converge.\\n  while (left <= right) {\\n    const mid = left + Math.floor((right - left) / 2);\\n\\n    if (arr[mid] < target) {\\n      left = mid + 1;\\n    } else {\\n      right = mid - 1;\\n    }\\n  }\\n\\n  // Return the index where the target value should be inserted.\\n  return left;\\n}\\n\\n/**\\n * Calculates the number of successful pairs of spells and potions.\\n * A spell and potion pair is considered successful if the product of their strengths is at least `success`.\\n *\\n * @param spells - An array of integers representing the strengths of the spells.\\n * @param potions - An array of integers representing the strengths of the potions.\\n * @param success - An integer representing the minimum product of spell and potion strengths required for success.\\n * @returns An array of integers representing the number of potions that will form a successful pair with each spell.\\n */\\nfunction successfulPairs(spells: number[], potions: number[], success: number): number[] {\\n  // Sort the potions list in ascending order to allow for efficient binary search.\\n  potions.sort((a, b) => a - b);\\n\\n  // Iterate over each spell in the spells list and use binary search to find the index of the first potion\\n  // that forms a successful pair, then calculate the number of successful pairs for each spell.\\n  // The map function creates a new array with the results of calling the provided function on every element in the original spells array.\\n  return spells.map(\\n    // Calculate the minimum potion strength required to form a successful pair\\n    // with the current spell, and use binary search to find the index where the target value should be inserted.\\n    (spell) => potions.length - binarySearch(potions, Math.ceil(success / spell))\\n  );\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3371091,
                "title": "easy-c-approach-with-explanation",
                "content": "# Intuition\\nAs answer should follow the of spells so we can\\'t change that array.\\nbut if we read question properly then we can see that we only need to count values in potions by which if we product the spells index value which give product atleast success. \\n\\n# Approach\\nAs we have to find number of products which will give product with specific index atleast success.\\nSo if we see potion index we can easily see that we if we somehow sort that and find minimum value which gives product atleast success then rest falling ownwards will be greater. so which whill give result easily\\nSteps\\n1. sort potion array.\\n2. traverse spell array.\\n3. apply binary search to find minimum value giving product >= success.\\n4. add potion size - index to result.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n) for result vector\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        vector<int> result;\\n        for(auto x: spells)\\n        {\\n            int low = 0, high = potions.size() - 1;\\n            while(low <= high)\\n            {\\n                int mid = low + (high - low) / 2;\\n                long long pro = long(potions[mid]) * (long)(x);\\n                if(pro >= success)\\n                    high = mid - 1;\\n                else \\n                    low = mid +1;\\n            }\\n            result.push_back(potions.size() - low);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        vector<int> result;\\n        for(auto x: spells)\\n        {\\n            int low = 0, high = potions.size() - 1;\\n            while(low <= high)\\n            {\\n                int mid = low + (high - low) / 2;\\n                long long pro = long(potions[mid]) * (long)(x);\\n                if(pro >= success)\\n                    high = mid - 1;\\n                else \\n                    low = mid +1;\\n            }\\n            result.push_back(potions.size() - low);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371074,
                "title": "easy-java-solution-binary-search-memory-98-faster",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        for(int i = 0; i < spells.length; i++){\\n            long target = (success + spells[i] - 1) / spells[i];\\n            int left = 0;\\n            int right = potions.length - 1;\\n\\n            while(left < right) {\\n                int mid = (right + left) / 2;\\n                if(potions[mid] < target) left = mid + 1;\\n                else right = mid;\\n            }\\n\\n            if(potions[left] < target) left++;\\n            spells[i] = potions.length - left;\\n        }\\n\\n        return spells;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        for(int i = 0; i < spells.length; i++){\\n            long target = (success + spells[i] - 1) / spells[i];\\n            int left = 0;\\n            int right = potions.length - 1;\\n\\n            while(left < right) {\\n                int mid = (right + left) / 2;\\n                if(potions[mid] < target) left = mid + 1;\\n                else right = mid;\\n            }\\n\\n            if(potions[left] < target) left++;\\n            spells[i] = potions.length - left;\\n        }\\n\\n        return spells;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1850766,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1850841,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1851177,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1850860,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1850810,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1851027,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1851208,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1794344,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1851644,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1851426,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1850766,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1850841,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1851177,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1850860,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1850810,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1851027,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1851208,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1794344,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1851644,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1851426,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1851643,
                "content": [
                    {
                        "username": "AshutoshPatel028",
                        "content": "I Know Binary Search but I don\\'t How to twist and use it according to problem!! \\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "iamshub07",
                        "content": "If your  code is failing for large test cases...\\ntry\\n`long x = (long)spell*arr[mid];`\\ni.e cast spell in long as by default it is int."
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "One strange thing happened to me. When I build a function for binary search it shows memory limit exceeded but when I do it in the main function itself it runs???\\n"
                    },
                    {
                        "username": "mennaabdelrahman6",
                        "content": "I have an interview in 5 min, I don\\'t know why the hack I am doing in this section"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "DO not do the double \"for loop\" method you will get TLE at 51 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "If a spell's strength is greater than or equal to success, potions of any strength will do."
                    },
                    {
                        "username": "trpaslik",
                        "content": "If you wonder how to do ceil(x/y) faster using only int division:\\n`ceil(x/y) = (x + y - 1) // y`\\nIn python, it is indeed much faster."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A shorter alternative is -(-x//y) if you are in a language (like Python) that always truncates down instead of truncating towards  zero."
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "use binary search same as lower bound but have to modified according to mid according to spells without modifing whole array"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Solve\\n35. Search insert position to get a better understanding at this!"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "sort the potions arrray for reducing the time complexity otherwise use two for loops "
                    },
                    {
                        "username": "user5400vw",
                        "content": "if test suite allowed for O(N^2) solutions, the problem would warrant an easy tag ."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "two for loops -> TLE"
                    }
                ]
            },
            {
                "id": 1851600,
                "content": [
                    {
                        "username": "AshutoshPatel028",
                        "content": "I Know Binary Search but I don\\'t How to twist and use it according to problem!! \\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "iamshub07",
                        "content": "If your  code is failing for large test cases...\\ntry\\n`long x = (long)spell*arr[mid];`\\ni.e cast spell in long as by default it is int."
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "One strange thing happened to me. When I build a function for binary search it shows memory limit exceeded but when I do it in the main function itself it runs???\\n"
                    },
                    {
                        "username": "mennaabdelrahman6",
                        "content": "I have an interview in 5 min, I don\\'t know why the hack I am doing in this section"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "DO not do the double \"for loop\" method you will get TLE at 51 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "If a spell's strength is greater than or equal to success, potions of any strength will do."
                    },
                    {
                        "username": "trpaslik",
                        "content": "If you wonder how to do ceil(x/y) faster using only int division:\\n`ceil(x/y) = (x + y - 1) // y`\\nIn python, it is indeed much faster."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A shorter alternative is -(-x//y) if you are in a language (like Python) that always truncates down instead of truncating towards  zero."
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "use binary search same as lower bound but have to modified according to mid according to spells without modifing whole array"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Solve\\n35. Search insert position to get a better understanding at this!"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "sort the potions arrray for reducing the time complexity otherwise use two for loops "
                    },
                    {
                        "username": "user5400vw",
                        "content": "if test suite allowed for O(N^2) solutions, the problem would warrant an easy tag ."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "two for loops -> TLE"
                    }
                ]
            },
            {
                "id": 1936167,
                "content": [
                    {
                        "username": "AshutoshPatel028",
                        "content": "I Know Binary Search but I don\\'t How to twist and use it according to problem!! \\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "iamshub07",
                        "content": "If your  code is failing for large test cases...\\ntry\\n`long x = (long)spell*arr[mid];`\\ni.e cast spell in long as by default it is int."
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "One strange thing happened to me. When I build a function for binary search it shows memory limit exceeded but when I do it in the main function itself it runs???\\n"
                    },
                    {
                        "username": "mennaabdelrahman6",
                        "content": "I have an interview in 5 min, I don\\'t know why the hack I am doing in this section"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "DO not do the double \"for loop\" method you will get TLE at 51 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "If a spell's strength is greater than or equal to success, potions of any strength will do."
                    },
                    {
                        "username": "trpaslik",
                        "content": "If you wonder how to do ceil(x/y) faster using only int division:\\n`ceil(x/y) = (x + y - 1) // y`\\nIn python, it is indeed much faster."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A shorter alternative is -(-x//y) if you are in a language (like Python) that always truncates down instead of truncating towards  zero."
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "use binary search same as lower bound but have to modified according to mid according to spells without modifing whole array"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Solve\\n35. Search insert position to get a better understanding at this!"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "sort the potions arrray for reducing the time complexity otherwise use two for loops "
                    },
                    {
                        "username": "user5400vw",
                        "content": "if test suite allowed for O(N^2) solutions, the problem would warrant an easy tag ."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "two for loops -> TLE"
                    }
                ]
            },
            {
                "id": 1905055,
                "content": [
                    {
                        "username": "AshutoshPatel028",
                        "content": "I Know Binary Search but I don\\'t How to twist and use it according to problem!! \\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "iamshub07",
                        "content": "If your  code is failing for large test cases...\\ntry\\n`long x = (long)spell*arr[mid];`\\ni.e cast spell in long as by default it is int."
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "One strange thing happened to me. When I build a function for binary search it shows memory limit exceeded but when I do it in the main function itself it runs???\\n"
                    },
                    {
                        "username": "mennaabdelrahman6",
                        "content": "I have an interview in 5 min, I don\\'t know why the hack I am doing in this section"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "DO not do the double \"for loop\" method you will get TLE at 51 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "If a spell's strength is greater than or equal to success, potions of any strength will do."
                    },
                    {
                        "username": "trpaslik",
                        "content": "If you wonder how to do ceil(x/y) faster using only int division:\\n`ceil(x/y) = (x + y - 1) // y`\\nIn python, it is indeed much faster."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A shorter alternative is -(-x//y) if you are in a language (like Python) that always truncates down instead of truncating towards  zero."
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "use binary search same as lower bound but have to modified according to mid according to spells without modifing whole array"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Solve\\n35. Search insert position to get a better understanding at this!"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "sort the potions arrray for reducing the time complexity otherwise use two for loops "
                    },
                    {
                        "username": "user5400vw",
                        "content": "if test suite allowed for O(N^2) solutions, the problem would warrant an easy tag ."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "two for loops -> TLE"
                    }
                ]
            },
            {
                "id": 1859454,
                "content": [
                    {
                        "username": "AshutoshPatel028",
                        "content": "I Know Binary Search but I don\\'t How to twist and use it according to problem!! \\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "iamshub07",
                        "content": "If your  code is failing for large test cases...\\ntry\\n`long x = (long)spell*arr[mid];`\\ni.e cast spell in long as by default it is int."
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "One strange thing happened to me. When I build a function for binary search it shows memory limit exceeded but when I do it in the main function itself it runs???\\n"
                    },
                    {
                        "username": "mennaabdelrahman6",
                        "content": "I have an interview in 5 min, I don\\'t know why the hack I am doing in this section"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "DO not do the double \"for loop\" method you will get TLE at 51 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "If a spell's strength is greater than or equal to success, potions of any strength will do."
                    },
                    {
                        "username": "trpaslik",
                        "content": "If you wonder how to do ceil(x/y) faster using only int division:\\n`ceil(x/y) = (x + y - 1) // y`\\nIn python, it is indeed much faster."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A shorter alternative is -(-x//y) if you are in a language (like Python) that always truncates down instead of truncating towards  zero."
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "use binary search same as lower bound but have to modified according to mid according to spells without modifing whole array"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Solve\\n35. Search insert position to get a better understanding at this!"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "sort the potions arrray for reducing the time complexity otherwise use two for loops "
                    },
                    {
                        "username": "user5400vw",
                        "content": "if test suite allowed for O(N^2) solutions, the problem would warrant an easy tag ."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "two for loops -> TLE"
                    }
                ]
            },
            {
                "id": 1851734,
                "content": [
                    {
                        "username": "AshutoshPatel028",
                        "content": "I Know Binary Search but I don\\'t How to twist and use it according to problem!! \\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "iamshub07",
                        "content": "If your  code is failing for large test cases...\\ntry\\n`long x = (long)spell*arr[mid];`\\ni.e cast spell in long as by default it is int."
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "One strange thing happened to me. When I build a function for binary search it shows memory limit exceeded but when I do it in the main function itself it runs???\\n"
                    },
                    {
                        "username": "mennaabdelrahman6",
                        "content": "I have an interview in 5 min, I don\\'t know why the hack I am doing in this section"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "DO not do the double \"for loop\" method you will get TLE at 51 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "If a spell's strength is greater than or equal to success, potions of any strength will do."
                    },
                    {
                        "username": "trpaslik",
                        "content": "If you wonder how to do ceil(x/y) faster using only int division:\\n`ceil(x/y) = (x + y - 1) // y`\\nIn python, it is indeed much faster."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A shorter alternative is -(-x//y) if you are in a language (like Python) that always truncates down instead of truncating towards  zero."
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "use binary search same as lower bound but have to modified according to mid according to spells without modifing whole array"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Solve\\n35. Search insert position to get a better understanding at this!"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "sort the potions arrray for reducing the time complexity otherwise use two for loops "
                    },
                    {
                        "username": "user5400vw",
                        "content": "if test suite allowed for O(N^2) solutions, the problem would warrant an easy tag ."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "two for loops -> TLE"
                    }
                ]
            },
            {
                "id": 1851456,
                "content": [
                    {
                        "username": "AshutoshPatel028",
                        "content": "I Know Binary Search but I don\\'t How to twist and use it according to problem!! \\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "iamshub07",
                        "content": "If your  code is failing for large test cases...\\ntry\\n`long x = (long)spell*arr[mid];`\\ni.e cast spell in long as by default it is int."
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "One strange thing happened to me. When I build a function for binary search it shows memory limit exceeded but when I do it in the main function itself it runs???\\n"
                    },
                    {
                        "username": "mennaabdelrahman6",
                        "content": "I have an interview in 5 min, I don\\'t know why the hack I am doing in this section"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "DO not do the double \"for loop\" method you will get TLE at 51 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "If a spell's strength is greater than or equal to success, potions of any strength will do."
                    },
                    {
                        "username": "trpaslik",
                        "content": "If you wonder how to do ceil(x/y) faster using only int division:\\n`ceil(x/y) = (x + y - 1) // y`\\nIn python, it is indeed much faster."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A shorter alternative is -(-x//y) if you are in a language (like Python) that always truncates down instead of truncating towards  zero."
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "use binary search same as lower bound but have to modified according to mid according to spells without modifing whole array"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Solve\\n35. Search insert position to get a better understanding at this!"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "sort the potions arrray for reducing the time complexity otherwise use two for loops "
                    },
                    {
                        "username": "user5400vw",
                        "content": "if test suite allowed for O(N^2) solutions, the problem would warrant an easy tag ."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "two for loops -> TLE"
                    }
                ]
            },
            {
                "id": 1851401,
                "content": [
                    {
                        "username": "AshutoshPatel028",
                        "content": "I Know Binary Search but I don\\'t How to twist and use it according to problem!! \\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "iamshub07",
                        "content": "If your  code is failing for large test cases...\\ntry\\n`long x = (long)spell*arr[mid];`\\ni.e cast spell in long as by default it is int."
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "One strange thing happened to me. When I build a function for binary search it shows memory limit exceeded but when I do it in the main function itself it runs???\\n"
                    },
                    {
                        "username": "mennaabdelrahman6",
                        "content": "I have an interview in 5 min, I don\\'t know why the hack I am doing in this section"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "DO not do the double \"for loop\" method you will get TLE at 51 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "If a spell's strength is greater than or equal to success, potions of any strength will do."
                    },
                    {
                        "username": "trpaslik",
                        "content": "If you wonder how to do ceil(x/y) faster using only int division:\\n`ceil(x/y) = (x + y - 1) // y`\\nIn python, it is indeed much faster."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A shorter alternative is -(-x//y) if you are in a language (like Python) that always truncates down instead of truncating towards  zero."
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "use binary search same as lower bound but have to modified according to mid according to spells without modifing whole array"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Solve\\n35. Search insert position to get a better understanding at this!"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "sort the potions arrray for reducing the time complexity otherwise use two for loops "
                    },
                    {
                        "username": "user5400vw",
                        "content": "if test suite allowed for O(N^2) solutions, the problem would warrant an easy tag ."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "two for loops -> TLE"
                    }
                ]
            },
            {
                "id": 1851396,
                "content": [
                    {
                        "username": "AshutoshPatel028",
                        "content": "I Know Binary Search but I don\\'t How to twist and use it according to problem!! \\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "iamshub07",
                        "content": "If your  code is failing for large test cases...\\ntry\\n`long x = (long)spell*arr[mid];`\\ni.e cast spell in long as by default it is int."
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "One strange thing happened to me. When I build a function for binary search it shows memory limit exceeded but when I do it in the main function itself it runs???\\n"
                    },
                    {
                        "username": "mennaabdelrahman6",
                        "content": "I have an interview in 5 min, I don\\'t know why the hack I am doing in this section"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "DO not do the double \"for loop\" method you will get TLE at 51 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "If a spell's strength is greater than or equal to success, potions of any strength will do."
                    },
                    {
                        "username": "trpaslik",
                        "content": "If you wonder how to do ceil(x/y) faster using only int division:\\n`ceil(x/y) = (x + y - 1) // y`\\nIn python, it is indeed much faster."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A shorter alternative is -(-x//y) if you are in a language (like Python) that always truncates down instead of truncating towards  zero."
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "use binary search same as lower bound but have to modified according to mid according to spells without modifing whole array"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Solve\\n35. Search insert position to get a better understanding at this!"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "sort the potions arrray for reducing the time complexity otherwise use two for loops "
                    },
                    {
                        "username": "user5400vw",
                        "content": "if test suite allowed for O(N^2) solutions, the problem would warrant an easy tag ."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "two for loops -> TLE"
                    }
                ]
            },
            {
                "id": 1851357,
                "content": [
                    {
                        "username": "AshutoshPatel028",
                        "content": "I Know Binary Search but I don\\'t How to twist and use it according to problem!! \\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "iamshub07",
                        "content": "If your  code is failing for large test cases...\\ntry\\n`long x = (long)spell*arr[mid];`\\ni.e cast spell in long as by default it is int."
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "One strange thing happened to me. When I build a function for binary search it shows memory limit exceeded but when I do it in the main function itself it runs???\\n"
                    },
                    {
                        "username": "mennaabdelrahman6",
                        "content": "I have an interview in 5 min, I don\\'t know why the hack I am doing in this section"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "DO not do the double \"for loop\" method you will get TLE at 51 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "If a spell's strength is greater than or equal to success, potions of any strength will do."
                    },
                    {
                        "username": "trpaslik",
                        "content": "If you wonder how to do ceil(x/y) faster using only int division:\\n`ceil(x/y) = (x + y - 1) // y`\\nIn python, it is indeed much faster."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A shorter alternative is -(-x//y) if you are in a language (like Python) that always truncates down instead of truncating towards  zero."
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "use binary search same as lower bound but have to modified according to mid according to spells without modifing whole array"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Solve\\n35. Search insert position to get a better understanding at this!"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "sort the potions arrray for reducing the time complexity otherwise use two for loops "
                    },
                    {
                        "username": "user5400vw",
                        "content": "if test suite allowed for O(N^2) solutions, the problem would warrant an easy tag ."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "two for loops -> TLE"
                    }
                ]
            },
            {
                "id": 1850771,
                "content": [
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "\\ncan anyone explain why my recursive son got TLE and iterative passed all test cases (recursion uses stack space of log n but what\\'s role in time complexity?)\\nclass Solution {\\npublic:\\n/* int bin_search(vector<int>p,int l,int r,int i,long long s)\\n{\\n    if(l>r)\\n    {\\n        return 0;\\n    }\\n    long long int mid = l+(r-l)/2;\\n    long long cmp = (long long)p[mid]*i;\\n    int ct=0;\\n    if(cmp<s)\\n    {\\n        ct+=bin_search(p,mid+1,r,i,s);\\n    }\\n    else\\n    {\\n        ct+=r-mid+1+bin_search(p,l,mid-1,i,s);\\n    }\\n    return ct;\\n}\\n*/\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        int l=0;\\n        int r=potions.size()-1;\\n        for(int i=0;i<spells.size();i++)\\n        {\\n            int ct=0;\\n            int l=0;\\n            int r=potions.size()-1;\\n            while(l<=r)\\n            {\\n              long long int mid = l+(r-l)/2;\\n              long long cmp = (long long)potions[mid]*spells[i];\\n              if(cmp<success)\\n              {\\n                  l=mid+1;\\n              }\\n              else\\n              {\\n                  ct+=r-mid+1;\\n                  r=mid-1;\\n              }\\n            }\\n            ans.push_back(ct);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "anish_patro",
                        "content": "55/56 passed\\ncan someone please explain this ?\\n\\n\\nclass Solution {\\npublic:   \\nint mod=1e9+7; \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> v;\\n        int sn=spells.size();\\n        int pn=potions.size();\\n       for(int i=0;i<pn;++i){\\n           if(success%potions[i]!=0)\\n           potions[i]=success/potions[i] +1;\\n           else\\n           potions[i]=success/potions[i];\\n       }\\n       sort(potions.begin(),potions.end());\\n        for(int i=0;i<sn;++i){\\n             long long low=0;\\n             long long high=pn-1;\\n           int ans=-1;\\n            while(low<=high){\\n            int mid=(low+(high-low)/2)%mod;\\n            if(potions[mid]<=spells[i])\\n           { ans=mid%mod;\\n            low=mid+1;}\\n            else\\n            high=mid-1;   \\n        }\\n        v.push_back(ans+1);\\n        }\\n       return v;\\n    }\\n};"
                    },
                    {
                        "username": "llamasheep",
                        "content": "[@shivansh961](/shivansh961) The above code assumes that success/potions[i] fits in int, but it could overflow. I also made a similar mistake"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I made the same mistake, used lower bound instead.\\nDon\\'t know what\\'s the mistake.\\nIf you understood, the please do tell"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide1.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide3.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide4.PNG)"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "[@namandt](/namandt) By sorting the array, I think we can just scan the specific portion instead of validating all the elements. So, saving the amount of time."
                    },
                    {
                        "username": "x-ider",
                        "content": "[@namandt](/namandt) it\\'s an alternative solution without binary search"
                    },
                    {
                        "username": "namandt",
                        "content": "why do we need to sort the spells array?"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "bs giving tle at 49th/56 tc.\\uD83E\\uDD28"
                    },
                    {
                        "username": "Applethal",
                        "content": "`class Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        return [sum(1 for potion in potions if spell * potion >= success) for spell in spells]`\\n\\nMade it to 51/56"
                    },
                    {
                        "username": "vamshikiranm",
                        "content": "Learning of > 1ll\nTo prevent overflow, you can use the ll suffix to explicitly specify that you want the literals to be treated as long long:\n\n\n ` long long k = spells[i]*1ll*potions[mid];`"
                    },
                    {
                        "username": "reactdevsourav",
                        "content": "Hi everyone I have solved the problem but I have once question:- \\nHere is my current solution which works\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n     if (potions[mid] * spells[i] >= success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n```\\nBut  my this solution gives me wrong answer, could anybody explain why?\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n      if (potions[mid] * spells[i] === success) {\\n        validMid = mid;\\n        break;\\n      } else if (potions[mid] * spells[i] > success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "you\\'re on the right track if you think you have to do X amount of binary searches\\n\\nU can also sort the arrays since the runtime of sorting and X binary searches is the same\\n\\nNow decide whether or not both arrays should be sorted or just one.\\n\\nOnce you answer that question, ask yourself if the weakest position is success...doesn\\'t that mean all the potions stronger than it is also success\\n\\ngood luck "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Some edge cases in binary search are frustrating."
                    },
                    {
                        "username": "7_aditi",
                        "content": "I am getting this error: \\nLine 15: Char 46: runtime error: signed integer overflow: 2 * -1094795586 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:24:46\\n\\nmy code was:\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        int n=spells.size(), m=potions.size();\\n        vector<int> pair;\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int left=0,right=m;\\n            int  mid;\\n            while(left<=right)\\n            {\\n               mid=(left+right)/2;\\n               long long prod = spells[i]*potions[mid];\\n               if(prod<success)\\n               left=mid+1;\\n               else\\n               right=mid-1; \\n            }\\n            long long prod = spells[i]*potions[mid];\\n            if(prod<success)\\n            mid=mid+1;\\n            if(mid<m)\\n            pair.push_back(m-mid);\\n            else\\n            pair.push_back(0);\\n        }\\n        return pair;\\n    }\\n};\\n\\nplease can anyone tell me how to resolve it and why m I getting this error?"
                    }
                ]
            },
            {
                "id": 1834821,
                "content": [
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "\\ncan anyone explain why my recursive son got TLE and iterative passed all test cases (recursion uses stack space of log n but what\\'s role in time complexity?)\\nclass Solution {\\npublic:\\n/* int bin_search(vector<int>p,int l,int r,int i,long long s)\\n{\\n    if(l>r)\\n    {\\n        return 0;\\n    }\\n    long long int mid = l+(r-l)/2;\\n    long long cmp = (long long)p[mid]*i;\\n    int ct=0;\\n    if(cmp<s)\\n    {\\n        ct+=bin_search(p,mid+1,r,i,s);\\n    }\\n    else\\n    {\\n        ct+=r-mid+1+bin_search(p,l,mid-1,i,s);\\n    }\\n    return ct;\\n}\\n*/\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        int l=0;\\n        int r=potions.size()-1;\\n        for(int i=0;i<spells.size();i++)\\n        {\\n            int ct=0;\\n            int l=0;\\n            int r=potions.size()-1;\\n            while(l<=r)\\n            {\\n              long long int mid = l+(r-l)/2;\\n              long long cmp = (long long)potions[mid]*spells[i];\\n              if(cmp<success)\\n              {\\n                  l=mid+1;\\n              }\\n              else\\n              {\\n                  ct+=r-mid+1;\\n                  r=mid-1;\\n              }\\n            }\\n            ans.push_back(ct);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "anish_patro",
                        "content": "55/56 passed\\ncan someone please explain this ?\\n\\n\\nclass Solution {\\npublic:   \\nint mod=1e9+7; \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> v;\\n        int sn=spells.size();\\n        int pn=potions.size();\\n       for(int i=0;i<pn;++i){\\n           if(success%potions[i]!=0)\\n           potions[i]=success/potions[i] +1;\\n           else\\n           potions[i]=success/potions[i];\\n       }\\n       sort(potions.begin(),potions.end());\\n        for(int i=0;i<sn;++i){\\n             long long low=0;\\n             long long high=pn-1;\\n           int ans=-1;\\n            while(low<=high){\\n            int mid=(low+(high-low)/2)%mod;\\n            if(potions[mid]<=spells[i])\\n           { ans=mid%mod;\\n            low=mid+1;}\\n            else\\n            high=mid-1;   \\n        }\\n        v.push_back(ans+1);\\n        }\\n       return v;\\n    }\\n};"
                    },
                    {
                        "username": "llamasheep",
                        "content": "[@shivansh961](/shivansh961) The above code assumes that success/potions[i] fits in int, but it could overflow. I also made a similar mistake"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I made the same mistake, used lower bound instead.\\nDon\\'t know what\\'s the mistake.\\nIf you understood, the please do tell"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide1.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide3.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide4.PNG)"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "[@namandt](/namandt) By sorting the array, I think we can just scan the specific portion instead of validating all the elements. So, saving the amount of time."
                    },
                    {
                        "username": "x-ider",
                        "content": "[@namandt](/namandt) it\\'s an alternative solution without binary search"
                    },
                    {
                        "username": "namandt",
                        "content": "why do we need to sort the spells array?"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "bs giving tle at 49th/56 tc.\\uD83E\\uDD28"
                    },
                    {
                        "username": "Applethal",
                        "content": "`class Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        return [sum(1 for potion in potions if spell * potion >= success) for spell in spells]`\\n\\nMade it to 51/56"
                    },
                    {
                        "username": "vamshikiranm",
                        "content": "Learning of > 1ll\nTo prevent overflow, you can use the ll suffix to explicitly specify that you want the literals to be treated as long long:\n\n\n ` long long k = spells[i]*1ll*potions[mid];`"
                    },
                    {
                        "username": "reactdevsourav",
                        "content": "Hi everyone I have solved the problem but I have once question:- \\nHere is my current solution which works\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n     if (potions[mid] * spells[i] >= success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n```\\nBut  my this solution gives me wrong answer, could anybody explain why?\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n      if (potions[mid] * spells[i] === success) {\\n        validMid = mid;\\n        break;\\n      } else if (potions[mid] * spells[i] > success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "you\\'re on the right track if you think you have to do X amount of binary searches\\n\\nU can also sort the arrays since the runtime of sorting and X binary searches is the same\\n\\nNow decide whether or not both arrays should be sorted or just one.\\n\\nOnce you answer that question, ask yourself if the weakest position is success...doesn\\'t that mean all the potions stronger than it is also success\\n\\ngood luck "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Some edge cases in binary search are frustrating."
                    },
                    {
                        "username": "7_aditi",
                        "content": "I am getting this error: \\nLine 15: Char 46: runtime error: signed integer overflow: 2 * -1094795586 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:24:46\\n\\nmy code was:\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        int n=spells.size(), m=potions.size();\\n        vector<int> pair;\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int left=0,right=m;\\n            int  mid;\\n            while(left<=right)\\n            {\\n               mid=(left+right)/2;\\n               long long prod = spells[i]*potions[mid];\\n               if(prod<success)\\n               left=mid+1;\\n               else\\n               right=mid-1; \\n            }\\n            long long prod = spells[i]*potions[mid];\\n            if(prod<success)\\n            mid=mid+1;\\n            if(mid<m)\\n            pair.push_back(m-mid);\\n            else\\n            pair.push_back(0);\\n        }\\n        return pair;\\n    }\\n};\\n\\nplease can anyone tell me how to resolve it and why m I getting this error?"
                    }
                ]
            },
            {
                "id": 1850764,
                "content": [
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "\\ncan anyone explain why my recursive son got TLE and iterative passed all test cases (recursion uses stack space of log n but what\\'s role in time complexity?)\\nclass Solution {\\npublic:\\n/* int bin_search(vector<int>p,int l,int r,int i,long long s)\\n{\\n    if(l>r)\\n    {\\n        return 0;\\n    }\\n    long long int mid = l+(r-l)/2;\\n    long long cmp = (long long)p[mid]*i;\\n    int ct=0;\\n    if(cmp<s)\\n    {\\n        ct+=bin_search(p,mid+1,r,i,s);\\n    }\\n    else\\n    {\\n        ct+=r-mid+1+bin_search(p,l,mid-1,i,s);\\n    }\\n    return ct;\\n}\\n*/\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        int l=0;\\n        int r=potions.size()-1;\\n        for(int i=0;i<spells.size();i++)\\n        {\\n            int ct=0;\\n            int l=0;\\n            int r=potions.size()-1;\\n            while(l<=r)\\n            {\\n              long long int mid = l+(r-l)/2;\\n              long long cmp = (long long)potions[mid]*spells[i];\\n              if(cmp<success)\\n              {\\n                  l=mid+1;\\n              }\\n              else\\n              {\\n                  ct+=r-mid+1;\\n                  r=mid-1;\\n              }\\n            }\\n            ans.push_back(ct);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "anish_patro",
                        "content": "55/56 passed\\ncan someone please explain this ?\\n\\n\\nclass Solution {\\npublic:   \\nint mod=1e9+7; \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> v;\\n        int sn=spells.size();\\n        int pn=potions.size();\\n       for(int i=0;i<pn;++i){\\n           if(success%potions[i]!=0)\\n           potions[i]=success/potions[i] +1;\\n           else\\n           potions[i]=success/potions[i];\\n       }\\n       sort(potions.begin(),potions.end());\\n        for(int i=0;i<sn;++i){\\n             long long low=0;\\n             long long high=pn-1;\\n           int ans=-1;\\n            while(low<=high){\\n            int mid=(low+(high-low)/2)%mod;\\n            if(potions[mid]<=spells[i])\\n           { ans=mid%mod;\\n            low=mid+1;}\\n            else\\n            high=mid-1;   \\n        }\\n        v.push_back(ans+1);\\n        }\\n       return v;\\n    }\\n};"
                    },
                    {
                        "username": "llamasheep",
                        "content": "[@shivansh961](/shivansh961) The above code assumes that success/potions[i] fits in int, but it could overflow. I also made a similar mistake"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I made the same mistake, used lower bound instead.\\nDon\\'t know what\\'s the mistake.\\nIf you understood, the please do tell"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide1.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide3.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide4.PNG)"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "[@namandt](/namandt) By sorting the array, I think we can just scan the specific portion instead of validating all the elements. So, saving the amount of time."
                    },
                    {
                        "username": "x-ider",
                        "content": "[@namandt](/namandt) it\\'s an alternative solution without binary search"
                    },
                    {
                        "username": "namandt",
                        "content": "why do we need to sort the spells array?"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "bs giving tle at 49th/56 tc.\\uD83E\\uDD28"
                    },
                    {
                        "username": "Applethal",
                        "content": "`class Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        return [sum(1 for potion in potions if spell * potion >= success) for spell in spells]`\\n\\nMade it to 51/56"
                    },
                    {
                        "username": "vamshikiranm",
                        "content": "Learning of > 1ll\nTo prevent overflow, you can use the ll suffix to explicitly specify that you want the literals to be treated as long long:\n\n\n ` long long k = spells[i]*1ll*potions[mid];`"
                    },
                    {
                        "username": "reactdevsourav",
                        "content": "Hi everyone I have solved the problem but I have once question:- \\nHere is my current solution which works\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n     if (potions[mid] * spells[i] >= success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n```\\nBut  my this solution gives me wrong answer, could anybody explain why?\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n      if (potions[mid] * spells[i] === success) {\\n        validMid = mid;\\n        break;\\n      } else if (potions[mid] * spells[i] > success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "you\\'re on the right track if you think you have to do X amount of binary searches\\n\\nU can also sort the arrays since the runtime of sorting and X binary searches is the same\\n\\nNow decide whether or not both arrays should be sorted or just one.\\n\\nOnce you answer that question, ask yourself if the weakest position is success...doesn\\'t that mean all the potions stronger than it is also success\\n\\ngood luck "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Some edge cases in binary search are frustrating."
                    },
                    {
                        "username": "7_aditi",
                        "content": "I am getting this error: \\nLine 15: Char 46: runtime error: signed integer overflow: 2 * -1094795586 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:24:46\\n\\nmy code was:\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        int n=spells.size(), m=potions.size();\\n        vector<int> pair;\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int left=0,right=m;\\n            int  mid;\\n            while(left<=right)\\n            {\\n               mid=(left+right)/2;\\n               long long prod = spells[i]*potions[mid];\\n               if(prod<success)\\n               left=mid+1;\\n               else\\n               right=mid-1; \\n            }\\n            long long prod = spells[i]*potions[mid];\\n            if(prod<success)\\n            mid=mid+1;\\n            if(mid<m)\\n            pair.push_back(m-mid);\\n            else\\n            pair.push_back(0);\\n        }\\n        return pair;\\n    }\\n};\\n\\nplease can anyone tell me how to resolve it and why m I getting this error?"
                    }
                ]
            },
            {
                "id": 2062725,
                "content": [
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "\\ncan anyone explain why my recursive son got TLE and iterative passed all test cases (recursion uses stack space of log n but what\\'s role in time complexity?)\\nclass Solution {\\npublic:\\n/* int bin_search(vector<int>p,int l,int r,int i,long long s)\\n{\\n    if(l>r)\\n    {\\n        return 0;\\n    }\\n    long long int mid = l+(r-l)/2;\\n    long long cmp = (long long)p[mid]*i;\\n    int ct=0;\\n    if(cmp<s)\\n    {\\n        ct+=bin_search(p,mid+1,r,i,s);\\n    }\\n    else\\n    {\\n        ct+=r-mid+1+bin_search(p,l,mid-1,i,s);\\n    }\\n    return ct;\\n}\\n*/\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        int l=0;\\n        int r=potions.size()-1;\\n        for(int i=0;i<spells.size();i++)\\n        {\\n            int ct=0;\\n            int l=0;\\n            int r=potions.size()-1;\\n            while(l<=r)\\n            {\\n              long long int mid = l+(r-l)/2;\\n              long long cmp = (long long)potions[mid]*spells[i];\\n              if(cmp<success)\\n              {\\n                  l=mid+1;\\n              }\\n              else\\n              {\\n                  ct+=r-mid+1;\\n                  r=mid-1;\\n              }\\n            }\\n            ans.push_back(ct);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "anish_patro",
                        "content": "55/56 passed\\ncan someone please explain this ?\\n\\n\\nclass Solution {\\npublic:   \\nint mod=1e9+7; \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> v;\\n        int sn=spells.size();\\n        int pn=potions.size();\\n       for(int i=0;i<pn;++i){\\n           if(success%potions[i]!=0)\\n           potions[i]=success/potions[i] +1;\\n           else\\n           potions[i]=success/potions[i];\\n       }\\n       sort(potions.begin(),potions.end());\\n        for(int i=0;i<sn;++i){\\n             long long low=0;\\n             long long high=pn-1;\\n           int ans=-1;\\n            while(low<=high){\\n            int mid=(low+(high-low)/2)%mod;\\n            if(potions[mid]<=spells[i])\\n           { ans=mid%mod;\\n            low=mid+1;}\\n            else\\n            high=mid-1;   \\n        }\\n        v.push_back(ans+1);\\n        }\\n       return v;\\n    }\\n};"
                    },
                    {
                        "username": "llamasheep",
                        "content": "[@shivansh961](/shivansh961) The above code assumes that success/potions[i] fits in int, but it could overflow. I also made a similar mistake"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I made the same mistake, used lower bound instead.\\nDon\\'t know what\\'s the mistake.\\nIf you understood, the please do tell"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide1.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide3.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide4.PNG)"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "[@namandt](/namandt) By sorting the array, I think we can just scan the specific portion instead of validating all the elements. So, saving the amount of time."
                    },
                    {
                        "username": "x-ider",
                        "content": "[@namandt](/namandt) it\\'s an alternative solution without binary search"
                    },
                    {
                        "username": "namandt",
                        "content": "why do we need to sort the spells array?"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "bs giving tle at 49th/56 tc.\\uD83E\\uDD28"
                    },
                    {
                        "username": "Applethal",
                        "content": "`class Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        return [sum(1 for potion in potions if spell * potion >= success) for spell in spells]`\\n\\nMade it to 51/56"
                    },
                    {
                        "username": "vamshikiranm",
                        "content": "Learning of > 1ll\nTo prevent overflow, you can use the ll suffix to explicitly specify that you want the literals to be treated as long long:\n\n\n ` long long k = spells[i]*1ll*potions[mid];`"
                    },
                    {
                        "username": "reactdevsourav",
                        "content": "Hi everyone I have solved the problem but I have once question:- \\nHere is my current solution which works\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n     if (potions[mid] * spells[i] >= success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n```\\nBut  my this solution gives me wrong answer, could anybody explain why?\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n      if (potions[mid] * spells[i] === success) {\\n        validMid = mid;\\n        break;\\n      } else if (potions[mid] * spells[i] > success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "you\\'re on the right track if you think you have to do X amount of binary searches\\n\\nU can also sort the arrays since the runtime of sorting and X binary searches is the same\\n\\nNow decide whether or not both arrays should be sorted or just one.\\n\\nOnce you answer that question, ask yourself if the weakest position is success...doesn\\'t that mean all the potions stronger than it is also success\\n\\ngood luck "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Some edge cases in binary search are frustrating."
                    },
                    {
                        "username": "7_aditi",
                        "content": "I am getting this error: \\nLine 15: Char 46: runtime error: signed integer overflow: 2 * -1094795586 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:24:46\\n\\nmy code was:\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        int n=spells.size(), m=potions.size();\\n        vector<int> pair;\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int left=0,right=m;\\n            int  mid;\\n            while(left<=right)\\n            {\\n               mid=(left+right)/2;\\n               long long prod = spells[i]*potions[mid];\\n               if(prod<success)\\n               left=mid+1;\\n               else\\n               right=mid-1; \\n            }\\n            long long prod = spells[i]*potions[mid];\\n            if(prod<success)\\n            mid=mid+1;\\n            if(mid<m)\\n            pair.push_back(m-mid);\\n            else\\n            pair.push_back(0);\\n        }\\n        return pair;\\n    }\\n};\\n\\nplease can anyone tell me how to resolve it and why m I getting this error?"
                    }
                ]
            },
            {
                "id": 2053397,
                "content": [
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "\\ncan anyone explain why my recursive son got TLE and iterative passed all test cases (recursion uses stack space of log n but what\\'s role in time complexity?)\\nclass Solution {\\npublic:\\n/* int bin_search(vector<int>p,int l,int r,int i,long long s)\\n{\\n    if(l>r)\\n    {\\n        return 0;\\n    }\\n    long long int mid = l+(r-l)/2;\\n    long long cmp = (long long)p[mid]*i;\\n    int ct=0;\\n    if(cmp<s)\\n    {\\n        ct+=bin_search(p,mid+1,r,i,s);\\n    }\\n    else\\n    {\\n        ct+=r-mid+1+bin_search(p,l,mid-1,i,s);\\n    }\\n    return ct;\\n}\\n*/\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        int l=0;\\n        int r=potions.size()-1;\\n        for(int i=0;i<spells.size();i++)\\n        {\\n            int ct=0;\\n            int l=0;\\n            int r=potions.size()-1;\\n            while(l<=r)\\n            {\\n              long long int mid = l+(r-l)/2;\\n              long long cmp = (long long)potions[mid]*spells[i];\\n              if(cmp<success)\\n              {\\n                  l=mid+1;\\n              }\\n              else\\n              {\\n                  ct+=r-mid+1;\\n                  r=mid-1;\\n              }\\n            }\\n            ans.push_back(ct);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "anish_patro",
                        "content": "55/56 passed\\ncan someone please explain this ?\\n\\n\\nclass Solution {\\npublic:   \\nint mod=1e9+7; \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> v;\\n        int sn=spells.size();\\n        int pn=potions.size();\\n       for(int i=0;i<pn;++i){\\n           if(success%potions[i]!=0)\\n           potions[i]=success/potions[i] +1;\\n           else\\n           potions[i]=success/potions[i];\\n       }\\n       sort(potions.begin(),potions.end());\\n        for(int i=0;i<sn;++i){\\n             long long low=0;\\n             long long high=pn-1;\\n           int ans=-1;\\n            while(low<=high){\\n            int mid=(low+(high-low)/2)%mod;\\n            if(potions[mid]<=spells[i])\\n           { ans=mid%mod;\\n            low=mid+1;}\\n            else\\n            high=mid-1;   \\n        }\\n        v.push_back(ans+1);\\n        }\\n       return v;\\n    }\\n};"
                    },
                    {
                        "username": "llamasheep",
                        "content": "[@shivansh961](/shivansh961) The above code assumes that success/potions[i] fits in int, but it could overflow. I also made a similar mistake"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I made the same mistake, used lower bound instead.\\nDon\\'t know what\\'s the mistake.\\nIf you understood, the please do tell"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide1.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide3.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide4.PNG)"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "[@namandt](/namandt) By sorting the array, I think we can just scan the specific portion instead of validating all the elements. So, saving the amount of time."
                    },
                    {
                        "username": "x-ider",
                        "content": "[@namandt](/namandt) it\\'s an alternative solution without binary search"
                    },
                    {
                        "username": "namandt",
                        "content": "why do we need to sort the spells array?"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "bs giving tle at 49th/56 tc.\\uD83E\\uDD28"
                    },
                    {
                        "username": "Applethal",
                        "content": "`class Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        return [sum(1 for potion in potions if spell * potion >= success) for spell in spells]`\\n\\nMade it to 51/56"
                    },
                    {
                        "username": "vamshikiranm",
                        "content": "Learning of > 1ll\nTo prevent overflow, you can use the ll suffix to explicitly specify that you want the literals to be treated as long long:\n\n\n ` long long k = spells[i]*1ll*potions[mid];`"
                    },
                    {
                        "username": "reactdevsourav",
                        "content": "Hi everyone I have solved the problem but I have once question:- \\nHere is my current solution which works\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n     if (potions[mid] * spells[i] >= success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n```\\nBut  my this solution gives me wrong answer, could anybody explain why?\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n      if (potions[mid] * spells[i] === success) {\\n        validMid = mid;\\n        break;\\n      } else if (potions[mid] * spells[i] > success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "you\\'re on the right track if you think you have to do X amount of binary searches\\n\\nU can also sort the arrays since the runtime of sorting and X binary searches is the same\\n\\nNow decide whether or not both arrays should be sorted or just one.\\n\\nOnce you answer that question, ask yourself if the weakest position is success...doesn\\'t that mean all the potions stronger than it is also success\\n\\ngood luck "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Some edge cases in binary search are frustrating."
                    },
                    {
                        "username": "7_aditi",
                        "content": "I am getting this error: \\nLine 15: Char 46: runtime error: signed integer overflow: 2 * -1094795586 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:24:46\\n\\nmy code was:\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        int n=spells.size(), m=potions.size();\\n        vector<int> pair;\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int left=0,right=m;\\n            int  mid;\\n            while(left<=right)\\n            {\\n               mid=(left+right)/2;\\n               long long prod = spells[i]*potions[mid];\\n               if(prod<success)\\n               left=mid+1;\\n               else\\n               right=mid-1; \\n            }\\n            long long prod = spells[i]*potions[mid];\\n            if(prod<success)\\n            mid=mid+1;\\n            if(mid<m)\\n            pair.push_back(m-mid);\\n            else\\n            pair.push_back(0);\\n        }\\n        return pair;\\n    }\\n};\\n\\nplease can anyone tell me how to resolve it and why m I getting this error?"
                    }
                ]
            },
            {
                "id": 2036657,
                "content": [
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "\\ncan anyone explain why my recursive son got TLE and iterative passed all test cases (recursion uses stack space of log n but what\\'s role in time complexity?)\\nclass Solution {\\npublic:\\n/* int bin_search(vector<int>p,int l,int r,int i,long long s)\\n{\\n    if(l>r)\\n    {\\n        return 0;\\n    }\\n    long long int mid = l+(r-l)/2;\\n    long long cmp = (long long)p[mid]*i;\\n    int ct=0;\\n    if(cmp<s)\\n    {\\n        ct+=bin_search(p,mid+1,r,i,s);\\n    }\\n    else\\n    {\\n        ct+=r-mid+1+bin_search(p,l,mid-1,i,s);\\n    }\\n    return ct;\\n}\\n*/\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        int l=0;\\n        int r=potions.size()-1;\\n        for(int i=0;i<spells.size();i++)\\n        {\\n            int ct=0;\\n            int l=0;\\n            int r=potions.size()-1;\\n            while(l<=r)\\n            {\\n              long long int mid = l+(r-l)/2;\\n              long long cmp = (long long)potions[mid]*spells[i];\\n              if(cmp<success)\\n              {\\n                  l=mid+1;\\n              }\\n              else\\n              {\\n                  ct+=r-mid+1;\\n                  r=mid-1;\\n              }\\n            }\\n            ans.push_back(ct);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "anish_patro",
                        "content": "55/56 passed\\ncan someone please explain this ?\\n\\n\\nclass Solution {\\npublic:   \\nint mod=1e9+7; \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> v;\\n        int sn=spells.size();\\n        int pn=potions.size();\\n       for(int i=0;i<pn;++i){\\n           if(success%potions[i]!=0)\\n           potions[i]=success/potions[i] +1;\\n           else\\n           potions[i]=success/potions[i];\\n       }\\n       sort(potions.begin(),potions.end());\\n        for(int i=0;i<sn;++i){\\n             long long low=0;\\n             long long high=pn-1;\\n           int ans=-1;\\n            while(low<=high){\\n            int mid=(low+(high-low)/2)%mod;\\n            if(potions[mid]<=spells[i])\\n           { ans=mid%mod;\\n            low=mid+1;}\\n            else\\n            high=mid-1;   \\n        }\\n        v.push_back(ans+1);\\n        }\\n       return v;\\n    }\\n};"
                    },
                    {
                        "username": "llamasheep",
                        "content": "[@shivansh961](/shivansh961) The above code assumes that success/potions[i] fits in int, but it could overflow. I also made a similar mistake"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I made the same mistake, used lower bound instead.\\nDon\\'t know what\\'s the mistake.\\nIf you understood, the please do tell"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide1.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide3.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide4.PNG)"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "[@namandt](/namandt) By sorting the array, I think we can just scan the specific portion instead of validating all the elements. So, saving the amount of time."
                    },
                    {
                        "username": "x-ider",
                        "content": "[@namandt](/namandt) it\\'s an alternative solution without binary search"
                    },
                    {
                        "username": "namandt",
                        "content": "why do we need to sort the spells array?"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "bs giving tle at 49th/56 tc.\\uD83E\\uDD28"
                    },
                    {
                        "username": "Applethal",
                        "content": "`class Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        return [sum(1 for potion in potions if spell * potion >= success) for spell in spells]`\\n\\nMade it to 51/56"
                    },
                    {
                        "username": "vamshikiranm",
                        "content": "Learning of > 1ll\nTo prevent overflow, you can use the ll suffix to explicitly specify that you want the literals to be treated as long long:\n\n\n ` long long k = spells[i]*1ll*potions[mid];`"
                    },
                    {
                        "username": "reactdevsourav",
                        "content": "Hi everyone I have solved the problem but I have once question:- \\nHere is my current solution which works\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n     if (potions[mid] * spells[i] >= success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n```\\nBut  my this solution gives me wrong answer, could anybody explain why?\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n      if (potions[mid] * spells[i] === success) {\\n        validMid = mid;\\n        break;\\n      } else if (potions[mid] * spells[i] > success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "you\\'re on the right track if you think you have to do X amount of binary searches\\n\\nU can also sort the arrays since the runtime of sorting and X binary searches is the same\\n\\nNow decide whether or not both arrays should be sorted or just one.\\n\\nOnce you answer that question, ask yourself if the weakest position is success...doesn\\'t that mean all the potions stronger than it is also success\\n\\ngood luck "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Some edge cases in binary search are frustrating."
                    },
                    {
                        "username": "7_aditi",
                        "content": "I am getting this error: \\nLine 15: Char 46: runtime error: signed integer overflow: 2 * -1094795586 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:24:46\\n\\nmy code was:\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        int n=spells.size(), m=potions.size();\\n        vector<int> pair;\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int left=0,right=m;\\n            int  mid;\\n            while(left<=right)\\n            {\\n               mid=(left+right)/2;\\n               long long prod = spells[i]*potions[mid];\\n               if(prod<success)\\n               left=mid+1;\\n               else\\n               right=mid-1; \\n            }\\n            long long prod = spells[i]*potions[mid];\\n            if(prod<success)\\n            mid=mid+1;\\n            if(mid<m)\\n            pair.push_back(m-mid);\\n            else\\n            pair.push_back(0);\\n        }\\n        return pair;\\n    }\\n};\\n\\nplease can anyone tell me how to resolve it and why m I getting this error?"
                    }
                ]
            },
            {
                "id": 2024872,
                "content": [
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "\\ncan anyone explain why my recursive son got TLE and iterative passed all test cases (recursion uses stack space of log n but what\\'s role in time complexity?)\\nclass Solution {\\npublic:\\n/* int bin_search(vector<int>p,int l,int r,int i,long long s)\\n{\\n    if(l>r)\\n    {\\n        return 0;\\n    }\\n    long long int mid = l+(r-l)/2;\\n    long long cmp = (long long)p[mid]*i;\\n    int ct=0;\\n    if(cmp<s)\\n    {\\n        ct+=bin_search(p,mid+1,r,i,s);\\n    }\\n    else\\n    {\\n        ct+=r-mid+1+bin_search(p,l,mid-1,i,s);\\n    }\\n    return ct;\\n}\\n*/\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        int l=0;\\n        int r=potions.size()-1;\\n        for(int i=0;i<spells.size();i++)\\n        {\\n            int ct=0;\\n            int l=0;\\n            int r=potions.size()-1;\\n            while(l<=r)\\n            {\\n              long long int mid = l+(r-l)/2;\\n              long long cmp = (long long)potions[mid]*spells[i];\\n              if(cmp<success)\\n              {\\n                  l=mid+1;\\n              }\\n              else\\n              {\\n                  ct+=r-mid+1;\\n                  r=mid-1;\\n              }\\n            }\\n            ans.push_back(ct);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "anish_patro",
                        "content": "55/56 passed\\ncan someone please explain this ?\\n\\n\\nclass Solution {\\npublic:   \\nint mod=1e9+7; \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> v;\\n        int sn=spells.size();\\n        int pn=potions.size();\\n       for(int i=0;i<pn;++i){\\n           if(success%potions[i]!=0)\\n           potions[i]=success/potions[i] +1;\\n           else\\n           potions[i]=success/potions[i];\\n       }\\n       sort(potions.begin(),potions.end());\\n        for(int i=0;i<sn;++i){\\n             long long low=0;\\n             long long high=pn-1;\\n           int ans=-1;\\n            while(low<=high){\\n            int mid=(low+(high-low)/2)%mod;\\n            if(potions[mid]<=spells[i])\\n           { ans=mid%mod;\\n            low=mid+1;}\\n            else\\n            high=mid-1;   \\n        }\\n        v.push_back(ans+1);\\n        }\\n       return v;\\n    }\\n};"
                    },
                    {
                        "username": "llamasheep",
                        "content": "[@shivansh961](/shivansh961) The above code assumes that success/potions[i] fits in int, but it could overflow. I also made a similar mistake"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I made the same mistake, used lower bound instead.\\nDon\\'t know what\\'s the mistake.\\nIf you understood, the please do tell"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide1.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide3.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide4.PNG)"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "[@namandt](/namandt) By sorting the array, I think we can just scan the specific portion instead of validating all the elements. So, saving the amount of time."
                    },
                    {
                        "username": "x-ider",
                        "content": "[@namandt](/namandt) it\\'s an alternative solution without binary search"
                    },
                    {
                        "username": "namandt",
                        "content": "why do we need to sort the spells array?"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "bs giving tle at 49th/56 tc.\\uD83E\\uDD28"
                    },
                    {
                        "username": "Applethal",
                        "content": "`class Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        return [sum(1 for potion in potions if spell * potion >= success) for spell in spells]`\\n\\nMade it to 51/56"
                    },
                    {
                        "username": "vamshikiranm",
                        "content": "Learning of > 1ll\nTo prevent overflow, you can use the ll suffix to explicitly specify that you want the literals to be treated as long long:\n\n\n ` long long k = spells[i]*1ll*potions[mid];`"
                    },
                    {
                        "username": "reactdevsourav",
                        "content": "Hi everyone I have solved the problem but I have once question:- \\nHere is my current solution which works\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n     if (potions[mid] * spells[i] >= success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n```\\nBut  my this solution gives me wrong answer, could anybody explain why?\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n      if (potions[mid] * spells[i] === success) {\\n        validMid = mid;\\n        break;\\n      } else if (potions[mid] * spells[i] > success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "you\\'re on the right track if you think you have to do X amount of binary searches\\n\\nU can also sort the arrays since the runtime of sorting and X binary searches is the same\\n\\nNow decide whether or not both arrays should be sorted or just one.\\n\\nOnce you answer that question, ask yourself if the weakest position is success...doesn\\'t that mean all the potions stronger than it is also success\\n\\ngood luck "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Some edge cases in binary search are frustrating."
                    },
                    {
                        "username": "7_aditi",
                        "content": "I am getting this error: \\nLine 15: Char 46: runtime error: signed integer overflow: 2 * -1094795586 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:24:46\\n\\nmy code was:\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        int n=spells.size(), m=potions.size();\\n        vector<int> pair;\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int left=0,right=m;\\n            int  mid;\\n            while(left<=right)\\n            {\\n               mid=(left+right)/2;\\n               long long prod = spells[i]*potions[mid];\\n               if(prod<success)\\n               left=mid+1;\\n               else\\n               right=mid-1; \\n            }\\n            long long prod = spells[i]*potions[mid];\\n            if(prod<success)\\n            mid=mid+1;\\n            if(mid<m)\\n            pair.push_back(m-mid);\\n            else\\n            pair.push_back(0);\\n        }\\n        return pair;\\n    }\\n};\\n\\nplease can anyone tell me how to resolve it and why m I getting this error?"
                    }
                ]
            },
            {
                "id": 1943749,
                "content": [
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "\\ncan anyone explain why my recursive son got TLE and iterative passed all test cases (recursion uses stack space of log n but what\\'s role in time complexity?)\\nclass Solution {\\npublic:\\n/* int bin_search(vector<int>p,int l,int r,int i,long long s)\\n{\\n    if(l>r)\\n    {\\n        return 0;\\n    }\\n    long long int mid = l+(r-l)/2;\\n    long long cmp = (long long)p[mid]*i;\\n    int ct=0;\\n    if(cmp<s)\\n    {\\n        ct+=bin_search(p,mid+1,r,i,s);\\n    }\\n    else\\n    {\\n        ct+=r-mid+1+bin_search(p,l,mid-1,i,s);\\n    }\\n    return ct;\\n}\\n*/\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        int l=0;\\n        int r=potions.size()-1;\\n        for(int i=0;i<spells.size();i++)\\n        {\\n            int ct=0;\\n            int l=0;\\n            int r=potions.size()-1;\\n            while(l<=r)\\n            {\\n              long long int mid = l+(r-l)/2;\\n              long long cmp = (long long)potions[mid]*spells[i];\\n              if(cmp<success)\\n              {\\n                  l=mid+1;\\n              }\\n              else\\n              {\\n                  ct+=r-mid+1;\\n                  r=mid-1;\\n              }\\n            }\\n            ans.push_back(ct);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "anish_patro",
                        "content": "55/56 passed\\ncan someone please explain this ?\\n\\n\\nclass Solution {\\npublic:   \\nint mod=1e9+7; \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> v;\\n        int sn=spells.size();\\n        int pn=potions.size();\\n       for(int i=0;i<pn;++i){\\n           if(success%potions[i]!=0)\\n           potions[i]=success/potions[i] +1;\\n           else\\n           potions[i]=success/potions[i];\\n       }\\n       sort(potions.begin(),potions.end());\\n        for(int i=0;i<sn;++i){\\n             long long low=0;\\n             long long high=pn-1;\\n           int ans=-1;\\n            while(low<=high){\\n            int mid=(low+(high-low)/2)%mod;\\n            if(potions[mid]<=spells[i])\\n           { ans=mid%mod;\\n            low=mid+1;}\\n            else\\n            high=mid-1;   \\n        }\\n        v.push_back(ans+1);\\n        }\\n       return v;\\n    }\\n};"
                    },
                    {
                        "username": "llamasheep",
                        "content": "[@shivansh961](/shivansh961) The above code assumes that success/potions[i] fits in int, but it could overflow. I also made a similar mistake"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I made the same mistake, used lower bound instead.\\nDon\\'t know what\\'s the mistake.\\nIf you understood, the please do tell"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide1.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide3.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide4.PNG)"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "[@namandt](/namandt) By sorting the array, I think we can just scan the specific portion instead of validating all the elements. So, saving the amount of time."
                    },
                    {
                        "username": "x-ider",
                        "content": "[@namandt](/namandt) it\\'s an alternative solution without binary search"
                    },
                    {
                        "username": "namandt",
                        "content": "why do we need to sort the spells array?"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "bs giving tle at 49th/56 tc.\\uD83E\\uDD28"
                    },
                    {
                        "username": "Applethal",
                        "content": "`class Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        return [sum(1 for potion in potions if spell * potion >= success) for spell in spells]`\\n\\nMade it to 51/56"
                    },
                    {
                        "username": "vamshikiranm",
                        "content": "Learning of > 1ll\nTo prevent overflow, you can use the ll suffix to explicitly specify that you want the literals to be treated as long long:\n\n\n ` long long k = spells[i]*1ll*potions[mid];`"
                    },
                    {
                        "username": "reactdevsourav",
                        "content": "Hi everyone I have solved the problem but I have once question:- \\nHere is my current solution which works\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n     if (potions[mid] * spells[i] >= success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n```\\nBut  my this solution gives me wrong answer, could anybody explain why?\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n      if (potions[mid] * spells[i] === success) {\\n        validMid = mid;\\n        break;\\n      } else if (potions[mid] * spells[i] > success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "you\\'re on the right track if you think you have to do X amount of binary searches\\n\\nU can also sort the arrays since the runtime of sorting and X binary searches is the same\\n\\nNow decide whether or not both arrays should be sorted or just one.\\n\\nOnce you answer that question, ask yourself if the weakest position is success...doesn\\'t that mean all the potions stronger than it is also success\\n\\ngood luck "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Some edge cases in binary search are frustrating."
                    },
                    {
                        "username": "7_aditi",
                        "content": "I am getting this error: \\nLine 15: Char 46: runtime error: signed integer overflow: 2 * -1094795586 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:24:46\\n\\nmy code was:\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        int n=spells.size(), m=potions.size();\\n        vector<int> pair;\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int left=0,right=m;\\n            int  mid;\\n            while(left<=right)\\n            {\\n               mid=(left+right)/2;\\n               long long prod = spells[i]*potions[mid];\\n               if(prod<success)\\n               left=mid+1;\\n               else\\n               right=mid-1; \\n            }\\n            long long prod = spells[i]*potions[mid];\\n            if(prod<success)\\n            mid=mid+1;\\n            if(mid<m)\\n            pair.push_back(m-mid);\\n            else\\n            pair.push_back(0);\\n        }\\n        return pair;\\n    }\\n};\\n\\nplease can anyone tell me how to resolve it and why m I getting this error?"
                    }
                ]
            },
            {
                "id": 1862876,
                "content": [
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "\\ncan anyone explain why my recursive son got TLE and iterative passed all test cases (recursion uses stack space of log n but what\\'s role in time complexity?)\\nclass Solution {\\npublic:\\n/* int bin_search(vector<int>p,int l,int r,int i,long long s)\\n{\\n    if(l>r)\\n    {\\n        return 0;\\n    }\\n    long long int mid = l+(r-l)/2;\\n    long long cmp = (long long)p[mid]*i;\\n    int ct=0;\\n    if(cmp<s)\\n    {\\n        ct+=bin_search(p,mid+1,r,i,s);\\n    }\\n    else\\n    {\\n        ct+=r-mid+1+bin_search(p,l,mid-1,i,s);\\n    }\\n    return ct;\\n}\\n*/\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        int l=0;\\n        int r=potions.size()-1;\\n        for(int i=0;i<spells.size();i++)\\n        {\\n            int ct=0;\\n            int l=0;\\n            int r=potions.size()-1;\\n            while(l<=r)\\n            {\\n              long long int mid = l+(r-l)/2;\\n              long long cmp = (long long)potions[mid]*spells[i];\\n              if(cmp<success)\\n              {\\n                  l=mid+1;\\n              }\\n              else\\n              {\\n                  ct+=r-mid+1;\\n                  r=mid-1;\\n              }\\n            }\\n            ans.push_back(ct);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "anish_patro",
                        "content": "55/56 passed\\ncan someone please explain this ?\\n\\n\\nclass Solution {\\npublic:   \\nint mod=1e9+7; \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> v;\\n        int sn=spells.size();\\n        int pn=potions.size();\\n       for(int i=0;i<pn;++i){\\n           if(success%potions[i]!=0)\\n           potions[i]=success/potions[i] +1;\\n           else\\n           potions[i]=success/potions[i];\\n       }\\n       sort(potions.begin(),potions.end());\\n        for(int i=0;i<sn;++i){\\n             long long low=0;\\n             long long high=pn-1;\\n           int ans=-1;\\n            while(low<=high){\\n            int mid=(low+(high-low)/2)%mod;\\n            if(potions[mid]<=spells[i])\\n           { ans=mid%mod;\\n            low=mid+1;}\\n            else\\n            high=mid-1;   \\n        }\\n        v.push_back(ans+1);\\n        }\\n       return v;\\n    }\\n};"
                    },
                    {
                        "username": "llamasheep",
                        "content": "[@shivansh961](/shivansh961) The above code assumes that success/potions[i] fits in int, but it could overflow. I also made a similar mistake"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I made the same mistake, used lower bound instead.\\nDon\\'t know what\\'s the mistake.\\nIf you understood, the please do tell"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide1.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide3.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide4.PNG)"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "[@namandt](/namandt) By sorting the array, I think we can just scan the specific portion instead of validating all the elements. So, saving the amount of time."
                    },
                    {
                        "username": "x-ider",
                        "content": "[@namandt](/namandt) it\\'s an alternative solution without binary search"
                    },
                    {
                        "username": "namandt",
                        "content": "why do we need to sort the spells array?"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "bs giving tle at 49th/56 tc.\\uD83E\\uDD28"
                    },
                    {
                        "username": "Applethal",
                        "content": "`class Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        return [sum(1 for potion in potions if spell * potion >= success) for spell in spells]`\\n\\nMade it to 51/56"
                    },
                    {
                        "username": "vamshikiranm",
                        "content": "Learning of > 1ll\nTo prevent overflow, you can use the ll suffix to explicitly specify that you want the literals to be treated as long long:\n\n\n ` long long k = spells[i]*1ll*potions[mid];`"
                    },
                    {
                        "username": "reactdevsourav",
                        "content": "Hi everyone I have solved the problem but I have once question:- \\nHere is my current solution which works\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n     if (potions[mid] * spells[i] >= success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n```\\nBut  my this solution gives me wrong answer, could anybody explain why?\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n      if (potions[mid] * spells[i] === success) {\\n        validMid = mid;\\n        break;\\n      } else if (potions[mid] * spells[i] > success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "you\\'re on the right track if you think you have to do X amount of binary searches\\n\\nU can also sort the arrays since the runtime of sorting and X binary searches is the same\\n\\nNow decide whether or not both arrays should be sorted or just one.\\n\\nOnce you answer that question, ask yourself if the weakest position is success...doesn\\'t that mean all the potions stronger than it is also success\\n\\ngood luck "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Some edge cases in binary search are frustrating."
                    },
                    {
                        "username": "7_aditi",
                        "content": "I am getting this error: \\nLine 15: Char 46: runtime error: signed integer overflow: 2 * -1094795586 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:24:46\\n\\nmy code was:\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        int n=spells.size(), m=potions.size();\\n        vector<int> pair;\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int left=0,right=m;\\n            int  mid;\\n            while(left<=right)\\n            {\\n               mid=(left+right)/2;\\n               long long prod = spells[i]*potions[mid];\\n               if(prod<success)\\n               left=mid+1;\\n               else\\n               right=mid-1; \\n            }\\n            long long prod = spells[i]*potions[mid];\\n            if(prod<success)\\n            mid=mid+1;\\n            if(mid<m)\\n            pair.push_back(m-mid);\\n            else\\n            pair.push_back(0);\\n        }\\n        return pair;\\n    }\\n};\\n\\nplease can anyone tell me how to resolve it and why m I getting this error?"
                    }
                ]
            },
            {
                "id": 1859621,
                "content": [
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "\\ncan anyone explain why my recursive son got TLE and iterative passed all test cases (recursion uses stack space of log n but what\\'s role in time complexity?)\\nclass Solution {\\npublic:\\n/* int bin_search(vector<int>p,int l,int r,int i,long long s)\\n{\\n    if(l>r)\\n    {\\n        return 0;\\n    }\\n    long long int mid = l+(r-l)/2;\\n    long long cmp = (long long)p[mid]*i;\\n    int ct=0;\\n    if(cmp<s)\\n    {\\n        ct+=bin_search(p,mid+1,r,i,s);\\n    }\\n    else\\n    {\\n        ct+=r-mid+1+bin_search(p,l,mid-1,i,s);\\n    }\\n    return ct;\\n}\\n*/\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        int l=0;\\n        int r=potions.size()-1;\\n        for(int i=0;i<spells.size();i++)\\n        {\\n            int ct=0;\\n            int l=0;\\n            int r=potions.size()-1;\\n            while(l<=r)\\n            {\\n              long long int mid = l+(r-l)/2;\\n              long long cmp = (long long)potions[mid]*spells[i];\\n              if(cmp<success)\\n              {\\n                  l=mid+1;\\n              }\\n              else\\n              {\\n                  ct+=r-mid+1;\\n                  r=mid-1;\\n              }\\n            }\\n            ans.push_back(ct);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "anish_patro",
                        "content": "55/56 passed\\ncan someone please explain this ?\\n\\n\\nclass Solution {\\npublic:   \\nint mod=1e9+7; \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> v;\\n        int sn=spells.size();\\n        int pn=potions.size();\\n       for(int i=0;i<pn;++i){\\n           if(success%potions[i]!=0)\\n           potions[i]=success/potions[i] +1;\\n           else\\n           potions[i]=success/potions[i];\\n       }\\n       sort(potions.begin(),potions.end());\\n        for(int i=0;i<sn;++i){\\n             long long low=0;\\n             long long high=pn-1;\\n           int ans=-1;\\n            while(low<=high){\\n            int mid=(low+(high-low)/2)%mod;\\n            if(potions[mid]<=spells[i])\\n           { ans=mid%mod;\\n            low=mid+1;}\\n            else\\n            high=mid-1;   \\n        }\\n        v.push_back(ans+1);\\n        }\\n       return v;\\n    }\\n};"
                    },
                    {
                        "username": "llamasheep",
                        "content": "[@shivansh961](/shivansh961) The above code assumes that success/potions[i] fits in int, but it could overflow. I also made a similar mistake"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I made the same mistake, used lower bound instead.\\nDon\\'t know what\\'s the mistake.\\nIf you understood, the please do tell"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide1.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide3.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide4.PNG)"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "[@namandt](/namandt) By sorting the array, I think we can just scan the specific portion instead of validating all the elements. So, saving the amount of time."
                    },
                    {
                        "username": "x-ider",
                        "content": "[@namandt](/namandt) it\\'s an alternative solution without binary search"
                    },
                    {
                        "username": "namandt",
                        "content": "why do we need to sort the spells array?"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "bs giving tle at 49th/56 tc.\\uD83E\\uDD28"
                    },
                    {
                        "username": "Applethal",
                        "content": "`class Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        return [sum(1 for potion in potions if spell * potion >= success) for spell in spells]`\\n\\nMade it to 51/56"
                    },
                    {
                        "username": "vamshikiranm",
                        "content": "Learning of > 1ll\nTo prevent overflow, you can use the ll suffix to explicitly specify that you want the literals to be treated as long long:\n\n\n ` long long k = spells[i]*1ll*potions[mid];`"
                    },
                    {
                        "username": "reactdevsourav",
                        "content": "Hi everyone I have solved the problem but I have once question:- \\nHere is my current solution which works\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n     if (potions[mid] * spells[i] >= success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n```\\nBut  my this solution gives me wrong answer, could anybody explain why?\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n      if (potions[mid] * spells[i] === success) {\\n        validMid = mid;\\n        break;\\n      } else if (potions[mid] * spells[i] > success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "you\\'re on the right track if you think you have to do X amount of binary searches\\n\\nU can also sort the arrays since the runtime of sorting and X binary searches is the same\\n\\nNow decide whether or not both arrays should be sorted or just one.\\n\\nOnce you answer that question, ask yourself if the weakest position is success...doesn\\'t that mean all the potions stronger than it is also success\\n\\ngood luck "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Some edge cases in binary search are frustrating."
                    },
                    {
                        "username": "7_aditi",
                        "content": "I am getting this error: \\nLine 15: Char 46: runtime error: signed integer overflow: 2 * -1094795586 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:24:46\\n\\nmy code was:\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        int n=spells.size(), m=potions.size();\\n        vector<int> pair;\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int left=0,right=m;\\n            int  mid;\\n            while(left<=right)\\n            {\\n               mid=(left+right)/2;\\n               long long prod = spells[i]*potions[mid];\\n               if(prod<success)\\n               left=mid+1;\\n               else\\n               right=mid-1; \\n            }\\n            long long prod = spells[i]*potions[mid];\\n            if(prod<success)\\n            mid=mid+1;\\n            if(mid<m)\\n            pair.push_back(m-mid);\\n            else\\n            pair.push_back(0);\\n        }\\n        return pair;\\n    }\\n};\\n\\nplease can anyone tell me how to resolve it and why m I getting this error?"
                    }
                ]
            },
            {
                "id": 1857730,
                "content": [
                    {
                        "username": "WarrenSanchez",
                        "content": "I think the last case is broken"
                    },
                    {
                        "username": "Elora24",
                        "content": "I\\'m getting error at 54th test case. Couldn\\'t figure this out but assuming success/spells[i] be the reason though this won\\'t cross the limit of integer. Can anyone pls explain what\\'s wrong with it?\\n \\nCode :\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin() , potions.end());\\n\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int> result;\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            int keep = success/spells[i];\\n            if(success%spells[i])\\n                ++keep;\\n\\n\\n            int l=0 ,r=m-1 , mid;\\n            while(l<=r)\\n            {\\n                mid = l+((r-l)/2);\\n                if(potions[mid]>=keep)\\n                    r=mid-1;\\n                else\\n                    l=mid+1;\\n            }\\n\\n            result.push_back(m-l);\\n        }\\n\\n        return result;\\n    }"
                    },
                    {
                        "username": "Poopiboi",
                        "content": "These test cases are give me aneurism"
                    },
                    {
                        "username": "ramansehgal174",
                        "content": "Can anyone help me with my code, Test Case-51 is passing when provided input but i get TLE when running the solution ? Time Complexity -O(nlogn)\\n `\\n#define pb push_back\\n#define ll long long\\nclass Solution {\\npublic:\\n    int ceil(vector<int> arr, ll t){\\n        int M=arr.size();\\n        int ans = M;\\n        int low,mid,high;\\n        low = 0;\\n        high = arr.size() - 1;\\n        while(low <= high){\\n            mid = (low + high)/2;\\n            if(arr[mid] >= t){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return M - ans;\\n    }\\n    int getCeil(vector<int> arr, ll t){\\n        int M = arr.size();\\n        if(arr[0] >= t)\\n            return M;\\n        if(arr[M-1] < t)\\n            return 0;\\n        return ceil(arr,t);\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        int i;\\n        int N=spells.size();\\n        vector<int> pair;\\n        sort(potions.begin(),potions.end()); \\n        for(i=0;i<N;i++){\\n            ll target = success/spells[i] + (success%spells[i]?1:0);\\n            //cout << success << \" \" << spells[i] << \" = \" << target << endl;\\n            int ele = getCeil(potions,target);\\n            //cout << i << \" \" << target << \" \" << ele << endl;\\n            pair.pb(ele);\\n        }\\n        return pair;\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Uhhh ! This problem is just same as yesterdays\\' Binary Search Problem.\\uD83D\\uDE0E "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Sort the array in descending order, for easy work"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "I\\'ve got this working after giving up of a recursive binary search. Just a casual while loop with left/middle/right indexing made me complete the worst case scenario without hitting RTL."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Please tell me what is the mistake in my code?\nIt's not working from 49th testcase.\nExplaination:\n        1. Sorted the potion array\n        2. Find the minimum potion that is successful from potion array.\n        3. And answer is length of potion array - the minimum potion that is successful (i.e. step 2 ).\nCode: \npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\n        Arrays.sort(potions);\n        int[] arr = new int[spells.length];\n        for (int i = 0; i < spells.length; i++)\n        {\n            int s = 0, e = potions.length-1;\n            while (s < e) {\n                int mid = (s+e)/2;\n                if ((potions[mid] * spells[i]) >= success) {\n                    e = mid;\n                }\n                else if ((potions[mid] * spells[i]) < success) {\n                    s = mid+1;\n                }\n            }\n            if (e == -1) {\n                arr[i] = potions.length;\n            }\n            else if ((spells[i] * potions[e]) < success) {\n                arr[i] = (potions.length - e) - 1;\n            }\n            else {\n                arr[i] = potions.length - e;\n            }\n        }\n        return arr;\n    }"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "did you take care of duplicates in potions? eg in <14 14 14 14 14> binary search ends up with mid 14 rather than the first 14"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Leetcode, plis dont gib me hope \\uD83E\\uDD7A"
                    },
                    {
                        "username": "josh10187",
                        "content": "What is algorithm used here?"
                    }
                ]
            },
            {
                "id": 1857050,
                "content": [
                    {
                        "username": "WarrenSanchez",
                        "content": "I think the last case is broken"
                    },
                    {
                        "username": "Elora24",
                        "content": "I\\'m getting error at 54th test case. Couldn\\'t figure this out but assuming success/spells[i] be the reason though this won\\'t cross the limit of integer. Can anyone pls explain what\\'s wrong with it?\\n \\nCode :\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin() , potions.end());\\n\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int> result;\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            int keep = success/spells[i];\\n            if(success%spells[i])\\n                ++keep;\\n\\n\\n            int l=0 ,r=m-1 , mid;\\n            while(l<=r)\\n            {\\n                mid = l+((r-l)/2);\\n                if(potions[mid]>=keep)\\n                    r=mid-1;\\n                else\\n                    l=mid+1;\\n            }\\n\\n            result.push_back(m-l);\\n        }\\n\\n        return result;\\n    }"
                    },
                    {
                        "username": "Poopiboi",
                        "content": "These test cases are give me aneurism"
                    },
                    {
                        "username": "ramansehgal174",
                        "content": "Can anyone help me with my code, Test Case-51 is passing when provided input but i get TLE when running the solution ? Time Complexity -O(nlogn)\\n `\\n#define pb push_back\\n#define ll long long\\nclass Solution {\\npublic:\\n    int ceil(vector<int> arr, ll t){\\n        int M=arr.size();\\n        int ans = M;\\n        int low,mid,high;\\n        low = 0;\\n        high = arr.size() - 1;\\n        while(low <= high){\\n            mid = (low + high)/2;\\n            if(arr[mid] >= t){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return M - ans;\\n    }\\n    int getCeil(vector<int> arr, ll t){\\n        int M = arr.size();\\n        if(arr[0] >= t)\\n            return M;\\n        if(arr[M-1] < t)\\n            return 0;\\n        return ceil(arr,t);\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        int i;\\n        int N=spells.size();\\n        vector<int> pair;\\n        sort(potions.begin(),potions.end()); \\n        for(i=0;i<N;i++){\\n            ll target = success/spells[i] + (success%spells[i]?1:0);\\n            //cout << success << \" \" << spells[i] << \" = \" << target << endl;\\n            int ele = getCeil(potions,target);\\n            //cout << i << \" \" << target << \" \" << ele << endl;\\n            pair.pb(ele);\\n        }\\n        return pair;\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Uhhh ! This problem is just same as yesterdays\\' Binary Search Problem.\\uD83D\\uDE0E "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Sort the array in descending order, for easy work"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "I\\'ve got this working after giving up of a recursive binary search. Just a casual while loop with left/middle/right indexing made me complete the worst case scenario without hitting RTL."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Please tell me what is the mistake in my code?\nIt's not working from 49th testcase.\nExplaination:\n        1. Sorted the potion array\n        2. Find the minimum potion that is successful from potion array.\n        3. And answer is length of potion array - the minimum potion that is successful (i.e. step 2 ).\nCode: \npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\n        Arrays.sort(potions);\n        int[] arr = new int[spells.length];\n        for (int i = 0; i < spells.length; i++)\n        {\n            int s = 0, e = potions.length-1;\n            while (s < e) {\n                int mid = (s+e)/2;\n                if ((potions[mid] * spells[i]) >= success) {\n                    e = mid;\n                }\n                else if ((potions[mid] * spells[i]) < success) {\n                    s = mid+1;\n                }\n            }\n            if (e == -1) {\n                arr[i] = potions.length;\n            }\n            else if ((spells[i] * potions[e]) < success) {\n                arr[i] = (potions.length - e) - 1;\n            }\n            else {\n                arr[i] = potions.length - e;\n            }\n        }\n        return arr;\n    }"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "did you take care of duplicates in potions? eg in <14 14 14 14 14> binary search ends up with mid 14 rather than the first 14"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Leetcode, plis dont gib me hope \\uD83E\\uDD7A"
                    },
                    {
                        "username": "josh10187",
                        "content": "What is algorithm used here?"
                    }
                ]
            },
            {
                "id": 1853506,
                "content": [
                    {
                        "username": "WarrenSanchez",
                        "content": "I think the last case is broken"
                    },
                    {
                        "username": "Elora24",
                        "content": "I\\'m getting error at 54th test case. Couldn\\'t figure this out but assuming success/spells[i] be the reason though this won\\'t cross the limit of integer. Can anyone pls explain what\\'s wrong with it?\\n \\nCode :\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin() , potions.end());\\n\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int> result;\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            int keep = success/spells[i];\\n            if(success%spells[i])\\n                ++keep;\\n\\n\\n            int l=0 ,r=m-1 , mid;\\n            while(l<=r)\\n            {\\n                mid = l+((r-l)/2);\\n                if(potions[mid]>=keep)\\n                    r=mid-1;\\n                else\\n                    l=mid+1;\\n            }\\n\\n            result.push_back(m-l);\\n        }\\n\\n        return result;\\n    }"
                    },
                    {
                        "username": "Poopiboi",
                        "content": "These test cases are give me aneurism"
                    },
                    {
                        "username": "ramansehgal174",
                        "content": "Can anyone help me with my code, Test Case-51 is passing when provided input but i get TLE when running the solution ? Time Complexity -O(nlogn)\\n `\\n#define pb push_back\\n#define ll long long\\nclass Solution {\\npublic:\\n    int ceil(vector<int> arr, ll t){\\n        int M=arr.size();\\n        int ans = M;\\n        int low,mid,high;\\n        low = 0;\\n        high = arr.size() - 1;\\n        while(low <= high){\\n            mid = (low + high)/2;\\n            if(arr[mid] >= t){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return M - ans;\\n    }\\n    int getCeil(vector<int> arr, ll t){\\n        int M = arr.size();\\n        if(arr[0] >= t)\\n            return M;\\n        if(arr[M-1] < t)\\n            return 0;\\n        return ceil(arr,t);\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        int i;\\n        int N=spells.size();\\n        vector<int> pair;\\n        sort(potions.begin(),potions.end()); \\n        for(i=0;i<N;i++){\\n            ll target = success/spells[i] + (success%spells[i]?1:0);\\n            //cout << success << \" \" << spells[i] << \" = \" << target << endl;\\n            int ele = getCeil(potions,target);\\n            //cout << i << \" \" << target << \" \" << ele << endl;\\n            pair.pb(ele);\\n        }\\n        return pair;\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Uhhh ! This problem is just same as yesterdays\\' Binary Search Problem.\\uD83D\\uDE0E "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Sort the array in descending order, for easy work"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "I\\'ve got this working after giving up of a recursive binary search. Just a casual while loop with left/middle/right indexing made me complete the worst case scenario without hitting RTL."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Please tell me what is the mistake in my code?\nIt's not working from 49th testcase.\nExplaination:\n        1. Sorted the potion array\n        2. Find the minimum potion that is successful from potion array.\n        3. And answer is length of potion array - the minimum potion that is successful (i.e. step 2 ).\nCode: \npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\n        Arrays.sort(potions);\n        int[] arr = new int[spells.length];\n        for (int i = 0; i < spells.length; i++)\n        {\n            int s = 0, e = potions.length-1;\n            while (s < e) {\n                int mid = (s+e)/2;\n                if ((potions[mid] * spells[i]) >= success) {\n                    e = mid;\n                }\n                else if ((potions[mid] * spells[i]) < success) {\n                    s = mid+1;\n                }\n            }\n            if (e == -1) {\n                arr[i] = potions.length;\n            }\n            else if ((spells[i] * potions[e]) < success) {\n                arr[i] = (potions.length - e) - 1;\n            }\n            else {\n                arr[i] = potions.length - e;\n            }\n        }\n        return arr;\n    }"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "did you take care of duplicates in potions? eg in <14 14 14 14 14> binary search ends up with mid 14 rather than the first 14"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Leetcode, plis dont gib me hope \\uD83E\\uDD7A"
                    },
                    {
                        "username": "josh10187",
                        "content": "What is algorithm used here?"
                    }
                ]
            },
            {
                "id": 1852403,
                "content": [
                    {
                        "username": "WarrenSanchez",
                        "content": "I think the last case is broken"
                    },
                    {
                        "username": "Elora24",
                        "content": "I\\'m getting error at 54th test case. Couldn\\'t figure this out but assuming success/spells[i] be the reason though this won\\'t cross the limit of integer. Can anyone pls explain what\\'s wrong with it?\\n \\nCode :\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin() , potions.end());\\n\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int> result;\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            int keep = success/spells[i];\\n            if(success%spells[i])\\n                ++keep;\\n\\n\\n            int l=0 ,r=m-1 , mid;\\n            while(l<=r)\\n            {\\n                mid = l+((r-l)/2);\\n                if(potions[mid]>=keep)\\n                    r=mid-1;\\n                else\\n                    l=mid+1;\\n            }\\n\\n            result.push_back(m-l);\\n        }\\n\\n        return result;\\n    }"
                    },
                    {
                        "username": "Poopiboi",
                        "content": "These test cases are give me aneurism"
                    },
                    {
                        "username": "ramansehgal174",
                        "content": "Can anyone help me with my code, Test Case-51 is passing when provided input but i get TLE when running the solution ? Time Complexity -O(nlogn)\\n `\\n#define pb push_back\\n#define ll long long\\nclass Solution {\\npublic:\\n    int ceil(vector<int> arr, ll t){\\n        int M=arr.size();\\n        int ans = M;\\n        int low,mid,high;\\n        low = 0;\\n        high = arr.size() - 1;\\n        while(low <= high){\\n            mid = (low + high)/2;\\n            if(arr[mid] >= t){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return M - ans;\\n    }\\n    int getCeil(vector<int> arr, ll t){\\n        int M = arr.size();\\n        if(arr[0] >= t)\\n            return M;\\n        if(arr[M-1] < t)\\n            return 0;\\n        return ceil(arr,t);\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        int i;\\n        int N=spells.size();\\n        vector<int> pair;\\n        sort(potions.begin(),potions.end()); \\n        for(i=0;i<N;i++){\\n            ll target = success/spells[i] + (success%spells[i]?1:0);\\n            //cout << success << \" \" << spells[i] << \" = \" << target << endl;\\n            int ele = getCeil(potions,target);\\n            //cout << i << \" \" << target << \" \" << ele << endl;\\n            pair.pb(ele);\\n        }\\n        return pair;\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Uhhh ! This problem is just same as yesterdays\\' Binary Search Problem.\\uD83D\\uDE0E "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Sort the array in descending order, for easy work"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "I\\'ve got this working after giving up of a recursive binary search. Just a casual while loop with left/middle/right indexing made me complete the worst case scenario without hitting RTL."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Please tell me what is the mistake in my code?\nIt's not working from 49th testcase.\nExplaination:\n        1. Sorted the potion array\n        2. Find the minimum potion that is successful from potion array.\n        3. And answer is length of potion array - the minimum potion that is successful (i.e. step 2 ).\nCode: \npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\n        Arrays.sort(potions);\n        int[] arr = new int[spells.length];\n        for (int i = 0; i < spells.length; i++)\n        {\n            int s = 0, e = potions.length-1;\n            while (s < e) {\n                int mid = (s+e)/2;\n                if ((potions[mid] * spells[i]) >= success) {\n                    e = mid;\n                }\n                else if ((potions[mid] * spells[i]) < success) {\n                    s = mid+1;\n                }\n            }\n            if (e == -1) {\n                arr[i] = potions.length;\n            }\n            else if ((spells[i] * potions[e]) < success) {\n                arr[i] = (potions.length - e) - 1;\n            }\n            else {\n                arr[i] = potions.length - e;\n            }\n        }\n        return arr;\n    }"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "did you take care of duplicates in potions? eg in <14 14 14 14 14> binary search ends up with mid 14 rather than the first 14"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Leetcode, plis dont gib me hope \\uD83E\\uDD7A"
                    },
                    {
                        "username": "josh10187",
                        "content": "What is algorithm used here?"
                    }
                ]
            },
            {
                "id": 1851983,
                "content": [
                    {
                        "username": "WarrenSanchez",
                        "content": "I think the last case is broken"
                    },
                    {
                        "username": "Elora24",
                        "content": "I\\'m getting error at 54th test case. Couldn\\'t figure this out but assuming success/spells[i] be the reason though this won\\'t cross the limit of integer. Can anyone pls explain what\\'s wrong with it?\\n \\nCode :\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin() , potions.end());\\n\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int> result;\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            int keep = success/spells[i];\\n            if(success%spells[i])\\n                ++keep;\\n\\n\\n            int l=0 ,r=m-1 , mid;\\n            while(l<=r)\\n            {\\n                mid = l+((r-l)/2);\\n                if(potions[mid]>=keep)\\n                    r=mid-1;\\n                else\\n                    l=mid+1;\\n            }\\n\\n            result.push_back(m-l);\\n        }\\n\\n        return result;\\n    }"
                    },
                    {
                        "username": "Poopiboi",
                        "content": "These test cases are give me aneurism"
                    },
                    {
                        "username": "ramansehgal174",
                        "content": "Can anyone help me with my code, Test Case-51 is passing when provided input but i get TLE when running the solution ? Time Complexity -O(nlogn)\\n `\\n#define pb push_back\\n#define ll long long\\nclass Solution {\\npublic:\\n    int ceil(vector<int> arr, ll t){\\n        int M=arr.size();\\n        int ans = M;\\n        int low,mid,high;\\n        low = 0;\\n        high = arr.size() - 1;\\n        while(low <= high){\\n            mid = (low + high)/2;\\n            if(arr[mid] >= t){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return M - ans;\\n    }\\n    int getCeil(vector<int> arr, ll t){\\n        int M = arr.size();\\n        if(arr[0] >= t)\\n            return M;\\n        if(arr[M-1] < t)\\n            return 0;\\n        return ceil(arr,t);\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        int i;\\n        int N=spells.size();\\n        vector<int> pair;\\n        sort(potions.begin(),potions.end()); \\n        for(i=0;i<N;i++){\\n            ll target = success/spells[i] + (success%spells[i]?1:0);\\n            //cout << success << \" \" << spells[i] << \" = \" << target << endl;\\n            int ele = getCeil(potions,target);\\n            //cout << i << \" \" << target << \" \" << ele << endl;\\n            pair.pb(ele);\\n        }\\n        return pair;\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Uhhh ! This problem is just same as yesterdays\\' Binary Search Problem.\\uD83D\\uDE0E "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Sort the array in descending order, for easy work"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "I\\'ve got this working after giving up of a recursive binary search. Just a casual while loop with left/middle/right indexing made me complete the worst case scenario without hitting RTL."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Please tell me what is the mistake in my code?\nIt's not working from 49th testcase.\nExplaination:\n        1. Sorted the potion array\n        2. Find the minimum potion that is successful from potion array.\n        3. And answer is length of potion array - the minimum potion that is successful (i.e. step 2 ).\nCode: \npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\n        Arrays.sort(potions);\n        int[] arr = new int[spells.length];\n        for (int i = 0; i < spells.length; i++)\n        {\n            int s = 0, e = potions.length-1;\n            while (s < e) {\n                int mid = (s+e)/2;\n                if ((potions[mid] * spells[i]) >= success) {\n                    e = mid;\n                }\n                else if ((potions[mid] * spells[i]) < success) {\n                    s = mid+1;\n                }\n            }\n            if (e == -1) {\n                arr[i] = potions.length;\n            }\n            else if ((spells[i] * potions[e]) < success) {\n                arr[i] = (potions.length - e) - 1;\n            }\n            else {\n                arr[i] = potions.length - e;\n            }\n        }\n        return arr;\n    }"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "did you take care of duplicates in potions? eg in <14 14 14 14 14> binary search ends up with mid 14 rather than the first 14"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Leetcode, plis dont gib me hope \\uD83E\\uDD7A"
                    },
                    {
                        "username": "josh10187",
                        "content": "What is algorithm used here?"
                    }
                ]
            },
            {
                "id": 1851950,
                "content": [
                    {
                        "username": "WarrenSanchez",
                        "content": "I think the last case is broken"
                    },
                    {
                        "username": "Elora24",
                        "content": "I\\'m getting error at 54th test case. Couldn\\'t figure this out but assuming success/spells[i] be the reason though this won\\'t cross the limit of integer. Can anyone pls explain what\\'s wrong with it?\\n \\nCode :\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin() , potions.end());\\n\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int> result;\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            int keep = success/spells[i];\\n            if(success%spells[i])\\n                ++keep;\\n\\n\\n            int l=0 ,r=m-1 , mid;\\n            while(l<=r)\\n            {\\n                mid = l+((r-l)/2);\\n                if(potions[mid]>=keep)\\n                    r=mid-1;\\n                else\\n                    l=mid+1;\\n            }\\n\\n            result.push_back(m-l);\\n        }\\n\\n        return result;\\n    }"
                    },
                    {
                        "username": "Poopiboi",
                        "content": "These test cases are give me aneurism"
                    },
                    {
                        "username": "ramansehgal174",
                        "content": "Can anyone help me with my code, Test Case-51 is passing when provided input but i get TLE when running the solution ? Time Complexity -O(nlogn)\\n `\\n#define pb push_back\\n#define ll long long\\nclass Solution {\\npublic:\\n    int ceil(vector<int> arr, ll t){\\n        int M=arr.size();\\n        int ans = M;\\n        int low,mid,high;\\n        low = 0;\\n        high = arr.size() - 1;\\n        while(low <= high){\\n            mid = (low + high)/2;\\n            if(arr[mid] >= t){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return M - ans;\\n    }\\n    int getCeil(vector<int> arr, ll t){\\n        int M = arr.size();\\n        if(arr[0] >= t)\\n            return M;\\n        if(arr[M-1] < t)\\n            return 0;\\n        return ceil(arr,t);\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        int i;\\n        int N=spells.size();\\n        vector<int> pair;\\n        sort(potions.begin(),potions.end()); \\n        for(i=0;i<N;i++){\\n            ll target = success/spells[i] + (success%spells[i]?1:0);\\n            //cout << success << \" \" << spells[i] << \" = \" << target << endl;\\n            int ele = getCeil(potions,target);\\n            //cout << i << \" \" << target << \" \" << ele << endl;\\n            pair.pb(ele);\\n        }\\n        return pair;\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Uhhh ! This problem is just same as yesterdays\\' Binary Search Problem.\\uD83D\\uDE0E "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Sort the array in descending order, for easy work"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "I\\'ve got this working after giving up of a recursive binary search. Just a casual while loop with left/middle/right indexing made me complete the worst case scenario without hitting RTL."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Please tell me what is the mistake in my code?\nIt's not working from 49th testcase.\nExplaination:\n        1. Sorted the potion array\n        2. Find the minimum potion that is successful from potion array.\n        3. And answer is length of potion array - the minimum potion that is successful (i.e. step 2 ).\nCode: \npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\n        Arrays.sort(potions);\n        int[] arr = new int[spells.length];\n        for (int i = 0; i < spells.length; i++)\n        {\n            int s = 0, e = potions.length-1;\n            while (s < e) {\n                int mid = (s+e)/2;\n                if ((potions[mid] * spells[i]) >= success) {\n                    e = mid;\n                }\n                else if ((potions[mid] * spells[i]) < success) {\n                    s = mid+1;\n                }\n            }\n            if (e == -1) {\n                arr[i] = potions.length;\n            }\n            else if ((spells[i] * potions[e]) < success) {\n                arr[i] = (potions.length - e) - 1;\n            }\n            else {\n                arr[i] = potions.length - e;\n            }\n        }\n        return arr;\n    }"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "did you take care of duplicates in potions? eg in <14 14 14 14 14> binary search ends up with mid 14 rather than the first 14"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Leetcode, plis dont gib me hope \\uD83E\\uDD7A"
                    },
                    {
                        "username": "josh10187",
                        "content": "What is algorithm used here?"
                    }
                ]
            },
            {
                "id": 1851905,
                "content": [
                    {
                        "username": "WarrenSanchez",
                        "content": "I think the last case is broken"
                    },
                    {
                        "username": "Elora24",
                        "content": "I\\'m getting error at 54th test case. Couldn\\'t figure this out but assuming success/spells[i] be the reason though this won\\'t cross the limit of integer. Can anyone pls explain what\\'s wrong with it?\\n \\nCode :\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin() , potions.end());\\n\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int> result;\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            int keep = success/spells[i];\\n            if(success%spells[i])\\n                ++keep;\\n\\n\\n            int l=0 ,r=m-1 , mid;\\n            while(l<=r)\\n            {\\n                mid = l+((r-l)/2);\\n                if(potions[mid]>=keep)\\n                    r=mid-1;\\n                else\\n                    l=mid+1;\\n            }\\n\\n            result.push_back(m-l);\\n        }\\n\\n        return result;\\n    }"
                    },
                    {
                        "username": "Poopiboi",
                        "content": "These test cases are give me aneurism"
                    },
                    {
                        "username": "ramansehgal174",
                        "content": "Can anyone help me with my code, Test Case-51 is passing when provided input but i get TLE when running the solution ? Time Complexity -O(nlogn)\\n `\\n#define pb push_back\\n#define ll long long\\nclass Solution {\\npublic:\\n    int ceil(vector<int> arr, ll t){\\n        int M=arr.size();\\n        int ans = M;\\n        int low,mid,high;\\n        low = 0;\\n        high = arr.size() - 1;\\n        while(low <= high){\\n            mid = (low + high)/2;\\n            if(arr[mid] >= t){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return M - ans;\\n    }\\n    int getCeil(vector<int> arr, ll t){\\n        int M = arr.size();\\n        if(arr[0] >= t)\\n            return M;\\n        if(arr[M-1] < t)\\n            return 0;\\n        return ceil(arr,t);\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        int i;\\n        int N=spells.size();\\n        vector<int> pair;\\n        sort(potions.begin(),potions.end()); \\n        for(i=0;i<N;i++){\\n            ll target = success/spells[i] + (success%spells[i]?1:0);\\n            //cout << success << \" \" << spells[i] << \" = \" << target << endl;\\n            int ele = getCeil(potions,target);\\n            //cout << i << \" \" << target << \" \" << ele << endl;\\n            pair.pb(ele);\\n        }\\n        return pair;\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Uhhh ! This problem is just same as yesterdays\\' Binary Search Problem.\\uD83D\\uDE0E "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Sort the array in descending order, for easy work"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "I\\'ve got this working after giving up of a recursive binary search. Just a casual while loop with left/middle/right indexing made me complete the worst case scenario without hitting RTL."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Please tell me what is the mistake in my code?\nIt's not working from 49th testcase.\nExplaination:\n        1. Sorted the potion array\n        2. Find the minimum potion that is successful from potion array.\n        3. And answer is length of potion array - the minimum potion that is successful (i.e. step 2 ).\nCode: \npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\n        Arrays.sort(potions);\n        int[] arr = new int[spells.length];\n        for (int i = 0; i < spells.length; i++)\n        {\n            int s = 0, e = potions.length-1;\n            while (s < e) {\n                int mid = (s+e)/2;\n                if ((potions[mid] * spells[i]) >= success) {\n                    e = mid;\n                }\n                else if ((potions[mid] * spells[i]) < success) {\n                    s = mid+1;\n                }\n            }\n            if (e == -1) {\n                arr[i] = potions.length;\n            }\n            else if ((spells[i] * potions[e]) < success) {\n                arr[i] = (potions.length - e) - 1;\n            }\n            else {\n                arr[i] = potions.length - e;\n            }\n        }\n        return arr;\n    }"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "did you take care of duplicates in potions? eg in <14 14 14 14 14> binary search ends up with mid 14 rather than the first 14"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Leetcode, plis dont gib me hope \\uD83E\\uDD7A"
                    },
                    {
                        "username": "josh10187",
                        "content": "What is algorithm used here?"
                    }
                ]
            },
            {
                "id": 1851803,
                "content": [
                    {
                        "username": "WarrenSanchez",
                        "content": "I think the last case is broken"
                    },
                    {
                        "username": "Elora24",
                        "content": "I\\'m getting error at 54th test case. Couldn\\'t figure this out but assuming success/spells[i] be the reason though this won\\'t cross the limit of integer. Can anyone pls explain what\\'s wrong with it?\\n \\nCode :\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin() , potions.end());\\n\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int> result;\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            int keep = success/spells[i];\\n            if(success%spells[i])\\n                ++keep;\\n\\n\\n            int l=0 ,r=m-1 , mid;\\n            while(l<=r)\\n            {\\n                mid = l+((r-l)/2);\\n                if(potions[mid]>=keep)\\n                    r=mid-1;\\n                else\\n                    l=mid+1;\\n            }\\n\\n            result.push_back(m-l);\\n        }\\n\\n        return result;\\n    }"
                    },
                    {
                        "username": "Poopiboi",
                        "content": "These test cases are give me aneurism"
                    },
                    {
                        "username": "ramansehgal174",
                        "content": "Can anyone help me with my code, Test Case-51 is passing when provided input but i get TLE when running the solution ? Time Complexity -O(nlogn)\\n `\\n#define pb push_back\\n#define ll long long\\nclass Solution {\\npublic:\\n    int ceil(vector<int> arr, ll t){\\n        int M=arr.size();\\n        int ans = M;\\n        int low,mid,high;\\n        low = 0;\\n        high = arr.size() - 1;\\n        while(low <= high){\\n            mid = (low + high)/2;\\n            if(arr[mid] >= t){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return M - ans;\\n    }\\n    int getCeil(vector<int> arr, ll t){\\n        int M = arr.size();\\n        if(arr[0] >= t)\\n            return M;\\n        if(arr[M-1] < t)\\n            return 0;\\n        return ceil(arr,t);\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        int i;\\n        int N=spells.size();\\n        vector<int> pair;\\n        sort(potions.begin(),potions.end()); \\n        for(i=0;i<N;i++){\\n            ll target = success/spells[i] + (success%spells[i]?1:0);\\n            //cout << success << \" \" << spells[i] << \" = \" << target << endl;\\n            int ele = getCeil(potions,target);\\n            //cout << i << \" \" << target << \" \" << ele << endl;\\n            pair.pb(ele);\\n        }\\n        return pair;\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Uhhh ! This problem is just same as yesterdays\\' Binary Search Problem.\\uD83D\\uDE0E "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Sort the array in descending order, for easy work"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "I\\'ve got this working after giving up of a recursive binary search. Just a casual while loop with left/middle/right indexing made me complete the worst case scenario without hitting RTL."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Please tell me what is the mistake in my code?\nIt's not working from 49th testcase.\nExplaination:\n        1. Sorted the potion array\n        2. Find the minimum potion that is successful from potion array.\n        3. And answer is length of potion array - the minimum potion that is successful (i.e. step 2 ).\nCode: \npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\n        Arrays.sort(potions);\n        int[] arr = new int[spells.length];\n        for (int i = 0; i < spells.length; i++)\n        {\n            int s = 0, e = potions.length-1;\n            while (s < e) {\n                int mid = (s+e)/2;\n                if ((potions[mid] * spells[i]) >= success) {\n                    e = mid;\n                }\n                else if ((potions[mid] * spells[i]) < success) {\n                    s = mid+1;\n                }\n            }\n            if (e == -1) {\n                arr[i] = potions.length;\n            }\n            else if ((spells[i] * potions[e]) < success) {\n                arr[i] = (potions.length - e) - 1;\n            }\n            else {\n                arr[i] = potions.length - e;\n            }\n        }\n        return arr;\n    }"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "did you take care of duplicates in potions? eg in <14 14 14 14 14> binary search ends up with mid 14 rather than the first 14"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Leetcode, plis dont gib me hope \\uD83E\\uDD7A"
                    },
                    {
                        "username": "josh10187",
                        "content": "What is algorithm used here?"
                    }
                ]
            },
            {
                "id": 1851800,
                "content": [
                    {
                        "username": "WarrenSanchez",
                        "content": "I think the last case is broken"
                    },
                    {
                        "username": "Elora24",
                        "content": "I\\'m getting error at 54th test case. Couldn\\'t figure this out but assuming success/spells[i] be the reason though this won\\'t cross the limit of integer. Can anyone pls explain what\\'s wrong with it?\\n \\nCode :\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin() , potions.end());\\n\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int> result;\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            int keep = success/spells[i];\\n            if(success%spells[i])\\n                ++keep;\\n\\n\\n            int l=0 ,r=m-1 , mid;\\n            while(l<=r)\\n            {\\n                mid = l+((r-l)/2);\\n                if(potions[mid]>=keep)\\n                    r=mid-1;\\n                else\\n                    l=mid+1;\\n            }\\n\\n            result.push_back(m-l);\\n        }\\n\\n        return result;\\n    }"
                    },
                    {
                        "username": "Poopiboi",
                        "content": "These test cases are give me aneurism"
                    },
                    {
                        "username": "ramansehgal174",
                        "content": "Can anyone help me with my code, Test Case-51 is passing when provided input but i get TLE when running the solution ? Time Complexity -O(nlogn)\\n `\\n#define pb push_back\\n#define ll long long\\nclass Solution {\\npublic:\\n    int ceil(vector<int> arr, ll t){\\n        int M=arr.size();\\n        int ans = M;\\n        int low,mid,high;\\n        low = 0;\\n        high = arr.size() - 1;\\n        while(low <= high){\\n            mid = (low + high)/2;\\n            if(arr[mid] >= t){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return M - ans;\\n    }\\n    int getCeil(vector<int> arr, ll t){\\n        int M = arr.size();\\n        if(arr[0] >= t)\\n            return M;\\n        if(arr[M-1] < t)\\n            return 0;\\n        return ceil(arr,t);\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        int i;\\n        int N=spells.size();\\n        vector<int> pair;\\n        sort(potions.begin(),potions.end()); \\n        for(i=0;i<N;i++){\\n            ll target = success/spells[i] + (success%spells[i]?1:0);\\n            //cout << success << \" \" << spells[i] << \" = \" << target << endl;\\n            int ele = getCeil(potions,target);\\n            //cout << i << \" \" << target << \" \" << ele << endl;\\n            pair.pb(ele);\\n        }\\n        return pair;\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Uhhh ! This problem is just same as yesterdays\\' Binary Search Problem.\\uD83D\\uDE0E "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Sort the array in descending order, for easy work"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "I\\'ve got this working after giving up of a recursive binary search. Just a casual while loop with left/middle/right indexing made me complete the worst case scenario without hitting RTL."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Please tell me what is the mistake in my code?\nIt's not working from 49th testcase.\nExplaination:\n        1. Sorted the potion array\n        2. Find the minimum potion that is successful from potion array.\n        3. And answer is length of potion array - the minimum potion that is successful (i.e. step 2 ).\nCode: \npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\n        Arrays.sort(potions);\n        int[] arr = new int[spells.length];\n        for (int i = 0; i < spells.length; i++)\n        {\n            int s = 0, e = potions.length-1;\n            while (s < e) {\n                int mid = (s+e)/2;\n                if ((potions[mid] * spells[i]) >= success) {\n                    e = mid;\n                }\n                else if ((potions[mid] * spells[i]) < success) {\n                    s = mid+1;\n                }\n            }\n            if (e == -1) {\n                arr[i] = potions.length;\n            }\n            else if ((spells[i] * potions[e]) < success) {\n                arr[i] = (potions.length - e) - 1;\n            }\n            else {\n                arr[i] = potions.length - e;\n            }\n        }\n        return arr;\n    }"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "did you take care of duplicates in potions? eg in <14 14 14 14 14> binary search ends up with mid 14 rather than the first 14"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Leetcode, plis dont gib me hope \\uD83E\\uDD7A"
                    },
                    {
                        "username": "josh10187",
                        "content": "What is algorithm used here?"
                    }
                ]
            },
            {
                "id": 1851796,
                "content": [
                    {
                        "username": "WarrenSanchez",
                        "content": "I think the last case is broken"
                    },
                    {
                        "username": "Elora24",
                        "content": "I\\'m getting error at 54th test case. Couldn\\'t figure this out but assuming success/spells[i] be the reason though this won\\'t cross the limit of integer. Can anyone pls explain what\\'s wrong with it?\\n \\nCode :\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin() , potions.end());\\n\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int> result;\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            int keep = success/spells[i];\\n            if(success%spells[i])\\n                ++keep;\\n\\n\\n            int l=0 ,r=m-1 , mid;\\n            while(l<=r)\\n            {\\n                mid = l+((r-l)/2);\\n                if(potions[mid]>=keep)\\n                    r=mid-1;\\n                else\\n                    l=mid+1;\\n            }\\n\\n            result.push_back(m-l);\\n        }\\n\\n        return result;\\n    }"
                    },
                    {
                        "username": "Poopiboi",
                        "content": "These test cases are give me aneurism"
                    },
                    {
                        "username": "ramansehgal174",
                        "content": "Can anyone help me with my code, Test Case-51 is passing when provided input but i get TLE when running the solution ? Time Complexity -O(nlogn)\\n `\\n#define pb push_back\\n#define ll long long\\nclass Solution {\\npublic:\\n    int ceil(vector<int> arr, ll t){\\n        int M=arr.size();\\n        int ans = M;\\n        int low,mid,high;\\n        low = 0;\\n        high = arr.size() - 1;\\n        while(low <= high){\\n            mid = (low + high)/2;\\n            if(arr[mid] >= t){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return M - ans;\\n    }\\n    int getCeil(vector<int> arr, ll t){\\n        int M = arr.size();\\n        if(arr[0] >= t)\\n            return M;\\n        if(arr[M-1] < t)\\n            return 0;\\n        return ceil(arr,t);\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        int i;\\n        int N=spells.size();\\n        vector<int> pair;\\n        sort(potions.begin(),potions.end()); \\n        for(i=0;i<N;i++){\\n            ll target = success/spells[i] + (success%spells[i]?1:0);\\n            //cout << success << \" \" << spells[i] << \" = \" << target << endl;\\n            int ele = getCeil(potions,target);\\n            //cout << i << \" \" << target << \" \" << ele << endl;\\n            pair.pb(ele);\\n        }\\n        return pair;\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Uhhh ! This problem is just same as yesterdays\\' Binary Search Problem.\\uD83D\\uDE0E "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Sort the array in descending order, for easy work"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "I\\'ve got this working after giving up of a recursive binary search. Just a casual while loop with left/middle/right indexing made me complete the worst case scenario without hitting RTL."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Please tell me what is the mistake in my code?\nIt's not working from 49th testcase.\nExplaination:\n        1. Sorted the potion array\n        2. Find the minimum potion that is successful from potion array.\n        3. And answer is length of potion array - the minimum potion that is successful (i.e. step 2 ).\nCode: \npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\n        Arrays.sort(potions);\n        int[] arr = new int[spells.length];\n        for (int i = 0; i < spells.length; i++)\n        {\n            int s = 0, e = potions.length-1;\n            while (s < e) {\n                int mid = (s+e)/2;\n                if ((potions[mid] * spells[i]) >= success) {\n                    e = mid;\n                }\n                else if ((potions[mid] * spells[i]) < success) {\n                    s = mid+1;\n                }\n            }\n            if (e == -1) {\n                arr[i] = potions.length;\n            }\n            else if ((spells[i] * potions[e]) < success) {\n                arr[i] = (potions.length - e) - 1;\n            }\n            else {\n                arr[i] = potions.length - e;\n            }\n        }\n        return arr;\n    }"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "did you take care of duplicates in potions? eg in <14 14 14 14 14> binary search ends up with mid 14 rather than the first 14"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Leetcode, plis dont gib me hope \\uD83E\\uDD7A"
                    },
                    {
                        "username": "josh10187",
                        "content": "What is algorithm used here?"
                    }
                ]
            },
            {
                "id": 1851763,
                "content": [
                    {
                        "username": "dashingboy110035",
                        "content": "`for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                temp = (long)spells[i]*potions[j];\\n                if(temp >= success){\\n                    cnt++;\\n                }\\n                temp=0;\\n            }\\n            ans.push_back(cnt);\\n            cnt=0;\\n        }\\n        return ans;`\\n\\n51/56 demn constraints."
                    },
                    {
                        "username": "samsondanielcaps",
                        "content": "Passed 54/56 and got time limit exceeded is there any way i can improve the code:\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        // Arrays.sort(spells);\\n        for(int i=0;i<spells.length;i++)\\n        {\\n            int c=0;\\n            for(int j=potions.length-1;j>=0;j--)\\n            {\\n                long n=(long)spells[i]*potions[j];\\n                if(n<success)\\n                {\\n                    break;\\n                }\\n                else{\\n                    c++;\\n                }\\n            }\\n            spells[i]=c;\\n        }    \\n        return spells;\\n    }\\n}"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Try to write in code format or use proper indents, very hard to read\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "55 / 56 testcases passed\\n\\uD83D\\uDE29"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "I\\'m solving this problem in brute froce approach plzz tell me what I did wrong here in this question .\\n\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int arr2[]= new int[spells.length];\\n        for(int i = 0 ;i<spells.length;i++)\\n        {\\n            int arr1[]= Multiplication(spells[i],potions);\\n            arr2[i] = counting(arr1, success);\\n        }        \\n        return arr2;\\n\\n    }\\n    public static int counting (int arr[],long success)\\n    {\\n        int count =0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]>=success)\\n            {\\n                count++;\\n            }\\n        }\\n        return count ;\\n    } \\n    public static int[] Multiplication(int a , int potions[])\\n    {\\n        int arr[]= new int[potions.length];\\n        for(int i=0;i<potions.length;i++)\\n        {\\n            arr[i]= a*potions[i];\\n        }\\n\\n        return arr;\\n    } \\n}"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "my solution fail in 48th test case \\n"
                    },
                    {
                        "username": "crysqrlkys",
                        "content": "shadow wizard money gang\\nwe love casting spells"
                    },
                    {
                        "username": "jemuel90880",
                        "content": "Did somebody solve this is C lang? man I cant seem to past the 48/56 testcases. help..."
                    },
                    {
                        "username": "user2871e",
                        "content": "faced similar issue in java, solved it with by multiplying 1L (1 long) with potions[mid]*spells[i]"
                    },
                    {
                        "username": "user1160Ov",
                        "content": "I went through 2 arrays (spells and potions) using for loops. Gave a if condition to check if the product(spells[i]*potions[j]) can be greater then success and had a counter for every pair. basically the na\\xEFve approach. But it didn\\'t work for a certain test case(48th one). help me\\n\\nclass Solution {\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\n        int n = spells.length;\\n        int m = potions.length;\\n\\n        int pairs[] = new int[n];\\n\\n        for(int i = 0; i<n; i++) {\\n            int successful = 0;\\n            for(int j = 0; j<m; j++) {\\n                int prod = spells[i]*potions[j];\\n                if(prod >= (int)success) {\\n                    successful++;\\n                }\\n            }\\n            pairs[i] = successful;\\n        }\\n\\n    return pairs;\\n\\n    }\\n}"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "Yes, if you approach that way, you will definitely get Time Limit Exceeded Error. Use binary search algorithms or sort the two arrays and scan only the specific portions."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why ceil function misbehaved in c++\\ni tried \\n\\n```\\nlong div =ceil ((float)success/(float)i);\\n```\\nbut for a testcase it failed for a single value\\n```\\nlong div = success/i;\\n            if(success%i) div++;\\n```\\nbut this passed why?\\n"
                    },
                    {
                        "username": "vetor",
                        "content": "Dont use ```Long.valueOf(potions[mid] * spell) < success``` instead use \\n\\n```1L * potions[mid] * spell``` for elevation of int The 1L literal promotes the result of potions[mid] * spell to a long primitive before the multiplication is performed, ensuring that the result is a long primitive with the correct value and precision. \\n\\nhope this may help"
                    },
                    {
                        "username": "devildecoder",
                        "content": "This ques  is quiet easy but due to the integer overflow, runtime  error occurs so keep in this mind..."
                    }
                ]
            },
            {
                "id": 1851756,
                "content": [
                    {
                        "username": "dashingboy110035",
                        "content": "`for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                temp = (long)spells[i]*potions[j];\\n                if(temp >= success){\\n                    cnt++;\\n                }\\n                temp=0;\\n            }\\n            ans.push_back(cnt);\\n            cnt=0;\\n        }\\n        return ans;`\\n\\n51/56 demn constraints."
                    },
                    {
                        "username": "samsondanielcaps",
                        "content": "Passed 54/56 and got time limit exceeded is there any way i can improve the code:\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        // Arrays.sort(spells);\\n        for(int i=0;i<spells.length;i++)\\n        {\\n            int c=0;\\n            for(int j=potions.length-1;j>=0;j--)\\n            {\\n                long n=(long)spells[i]*potions[j];\\n                if(n<success)\\n                {\\n                    break;\\n                }\\n                else{\\n                    c++;\\n                }\\n            }\\n            spells[i]=c;\\n        }    \\n        return spells;\\n    }\\n}"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Try to write in code format or use proper indents, very hard to read\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "55 / 56 testcases passed\\n\\uD83D\\uDE29"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "I\\'m solving this problem in brute froce approach plzz tell me what I did wrong here in this question .\\n\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int arr2[]= new int[spells.length];\\n        for(int i = 0 ;i<spells.length;i++)\\n        {\\n            int arr1[]= Multiplication(spells[i],potions);\\n            arr2[i] = counting(arr1, success);\\n        }        \\n        return arr2;\\n\\n    }\\n    public static int counting (int arr[],long success)\\n    {\\n        int count =0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]>=success)\\n            {\\n                count++;\\n            }\\n        }\\n        return count ;\\n    } \\n    public static int[] Multiplication(int a , int potions[])\\n    {\\n        int arr[]= new int[potions.length];\\n        for(int i=0;i<potions.length;i++)\\n        {\\n            arr[i]= a*potions[i];\\n        }\\n\\n        return arr;\\n    } \\n}"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "my solution fail in 48th test case \\n"
                    },
                    {
                        "username": "crysqrlkys",
                        "content": "shadow wizard money gang\\nwe love casting spells"
                    },
                    {
                        "username": "jemuel90880",
                        "content": "Did somebody solve this is C lang? man I cant seem to past the 48/56 testcases. help..."
                    },
                    {
                        "username": "user2871e",
                        "content": "faced similar issue in java, solved it with by multiplying 1L (1 long) with potions[mid]*spells[i]"
                    },
                    {
                        "username": "user1160Ov",
                        "content": "I went through 2 arrays (spells and potions) using for loops. Gave a if condition to check if the product(spells[i]*potions[j]) can be greater then success and had a counter for every pair. basically the na\\xEFve approach. But it didn\\'t work for a certain test case(48th one). help me\\n\\nclass Solution {\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\n        int n = spells.length;\\n        int m = potions.length;\\n\\n        int pairs[] = new int[n];\\n\\n        for(int i = 0; i<n; i++) {\\n            int successful = 0;\\n            for(int j = 0; j<m; j++) {\\n                int prod = spells[i]*potions[j];\\n                if(prod >= (int)success) {\\n                    successful++;\\n                }\\n            }\\n            pairs[i] = successful;\\n        }\\n\\n    return pairs;\\n\\n    }\\n}"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "Yes, if you approach that way, you will definitely get Time Limit Exceeded Error. Use binary search algorithms or sort the two arrays and scan only the specific portions."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why ceil function misbehaved in c++\\ni tried \\n\\n```\\nlong div =ceil ((float)success/(float)i);\\n```\\nbut for a testcase it failed for a single value\\n```\\nlong div = success/i;\\n            if(success%i) div++;\\n```\\nbut this passed why?\\n"
                    },
                    {
                        "username": "vetor",
                        "content": "Dont use ```Long.valueOf(potions[mid] * spell) < success``` instead use \\n\\n```1L * potions[mid] * spell``` for elevation of int The 1L literal promotes the result of potions[mid] * spell to a long primitive before the multiplication is performed, ensuring that the result is a long primitive with the correct value and precision. \\n\\nhope this may help"
                    },
                    {
                        "username": "devildecoder",
                        "content": "This ques  is quiet easy but due to the integer overflow, runtime  error occurs so keep in this mind..."
                    }
                ]
            },
            {
                "id": 1851749,
                "content": [
                    {
                        "username": "dashingboy110035",
                        "content": "`for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                temp = (long)spells[i]*potions[j];\\n                if(temp >= success){\\n                    cnt++;\\n                }\\n                temp=0;\\n            }\\n            ans.push_back(cnt);\\n            cnt=0;\\n        }\\n        return ans;`\\n\\n51/56 demn constraints."
                    },
                    {
                        "username": "samsondanielcaps",
                        "content": "Passed 54/56 and got time limit exceeded is there any way i can improve the code:\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        // Arrays.sort(spells);\\n        for(int i=0;i<spells.length;i++)\\n        {\\n            int c=0;\\n            for(int j=potions.length-1;j>=0;j--)\\n            {\\n                long n=(long)spells[i]*potions[j];\\n                if(n<success)\\n                {\\n                    break;\\n                }\\n                else{\\n                    c++;\\n                }\\n            }\\n            spells[i]=c;\\n        }    \\n        return spells;\\n    }\\n}"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Try to write in code format or use proper indents, very hard to read\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "55 / 56 testcases passed\\n\\uD83D\\uDE29"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "I\\'m solving this problem in brute froce approach plzz tell me what I did wrong here in this question .\\n\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int arr2[]= new int[spells.length];\\n        for(int i = 0 ;i<spells.length;i++)\\n        {\\n            int arr1[]= Multiplication(spells[i],potions);\\n            arr2[i] = counting(arr1, success);\\n        }        \\n        return arr2;\\n\\n    }\\n    public static int counting (int arr[],long success)\\n    {\\n        int count =0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]>=success)\\n            {\\n                count++;\\n            }\\n        }\\n        return count ;\\n    } \\n    public static int[] Multiplication(int a , int potions[])\\n    {\\n        int arr[]= new int[potions.length];\\n        for(int i=0;i<potions.length;i++)\\n        {\\n            arr[i]= a*potions[i];\\n        }\\n\\n        return arr;\\n    } \\n}"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "my solution fail in 48th test case \\n"
                    },
                    {
                        "username": "crysqrlkys",
                        "content": "shadow wizard money gang\\nwe love casting spells"
                    },
                    {
                        "username": "jemuel90880",
                        "content": "Did somebody solve this is C lang? man I cant seem to past the 48/56 testcases. help..."
                    },
                    {
                        "username": "user2871e",
                        "content": "faced similar issue in java, solved it with by multiplying 1L (1 long) with potions[mid]*spells[i]"
                    },
                    {
                        "username": "user1160Ov",
                        "content": "I went through 2 arrays (spells and potions) using for loops. Gave a if condition to check if the product(spells[i]*potions[j]) can be greater then success and had a counter for every pair. basically the na\\xEFve approach. But it didn\\'t work for a certain test case(48th one). help me\\n\\nclass Solution {\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\n        int n = spells.length;\\n        int m = potions.length;\\n\\n        int pairs[] = new int[n];\\n\\n        for(int i = 0; i<n; i++) {\\n            int successful = 0;\\n            for(int j = 0; j<m; j++) {\\n                int prod = spells[i]*potions[j];\\n                if(prod >= (int)success) {\\n                    successful++;\\n                }\\n            }\\n            pairs[i] = successful;\\n        }\\n\\n    return pairs;\\n\\n    }\\n}"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "Yes, if you approach that way, you will definitely get Time Limit Exceeded Error. Use binary search algorithms or sort the two arrays and scan only the specific portions."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why ceil function misbehaved in c++\\ni tried \\n\\n```\\nlong div =ceil ((float)success/(float)i);\\n```\\nbut for a testcase it failed for a single value\\n```\\nlong div = success/i;\\n            if(success%i) div++;\\n```\\nbut this passed why?\\n"
                    },
                    {
                        "username": "vetor",
                        "content": "Dont use ```Long.valueOf(potions[mid] * spell) < success``` instead use \\n\\n```1L * potions[mid] * spell``` for elevation of int The 1L literal promotes the result of potions[mid] * spell to a long primitive before the multiplication is performed, ensuring that the result is a long primitive with the correct value and precision. \\n\\nhope this may help"
                    },
                    {
                        "username": "devildecoder",
                        "content": "This ques  is quiet easy but due to the integer overflow, runtime  error occurs so keep in this mind..."
                    }
                ]
            },
            {
                "id": 1851718,
                "content": [
                    {
                        "username": "dashingboy110035",
                        "content": "`for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                temp = (long)spells[i]*potions[j];\\n                if(temp >= success){\\n                    cnt++;\\n                }\\n                temp=0;\\n            }\\n            ans.push_back(cnt);\\n            cnt=0;\\n        }\\n        return ans;`\\n\\n51/56 demn constraints."
                    },
                    {
                        "username": "samsondanielcaps",
                        "content": "Passed 54/56 and got time limit exceeded is there any way i can improve the code:\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        // Arrays.sort(spells);\\n        for(int i=0;i<spells.length;i++)\\n        {\\n            int c=0;\\n            for(int j=potions.length-1;j>=0;j--)\\n            {\\n                long n=(long)spells[i]*potions[j];\\n                if(n<success)\\n                {\\n                    break;\\n                }\\n                else{\\n                    c++;\\n                }\\n            }\\n            spells[i]=c;\\n        }    \\n        return spells;\\n    }\\n}"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Try to write in code format or use proper indents, very hard to read\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "55 / 56 testcases passed\\n\\uD83D\\uDE29"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "I\\'m solving this problem in brute froce approach plzz tell me what I did wrong here in this question .\\n\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int arr2[]= new int[spells.length];\\n        for(int i = 0 ;i<spells.length;i++)\\n        {\\n            int arr1[]= Multiplication(spells[i],potions);\\n            arr2[i] = counting(arr1, success);\\n        }        \\n        return arr2;\\n\\n    }\\n    public static int counting (int arr[],long success)\\n    {\\n        int count =0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]>=success)\\n            {\\n                count++;\\n            }\\n        }\\n        return count ;\\n    } \\n    public static int[] Multiplication(int a , int potions[])\\n    {\\n        int arr[]= new int[potions.length];\\n        for(int i=0;i<potions.length;i++)\\n        {\\n            arr[i]= a*potions[i];\\n        }\\n\\n        return arr;\\n    } \\n}"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "my solution fail in 48th test case \\n"
                    },
                    {
                        "username": "crysqrlkys",
                        "content": "shadow wizard money gang\\nwe love casting spells"
                    },
                    {
                        "username": "jemuel90880",
                        "content": "Did somebody solve this is C lang? man I cant seem to past the 48/56 testcases. help..."
                    },
                    {
                        "username": "user2871e",
                        "content": "faced similar issue in java, solved it with by multiplying 1L (1 long) with potions[mid]*spells[i]"
                    },
                    {
                        "username": "user1160Ov",
                        "content": "I went through 2 arrays (spells and potions) using for loops. Gave a if condition to check if the product(spells[i]*potions[j]) can be greater then success and had a counter for every pair. basically the na\\xEFve approach. But it didn\\'t work for a certain test case(48th one). help me\\n\\nclass Solution {\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\n        int n = spells.length;\\n        int m = potions.length;\\n\\n        int pairs[] = new int[n];\\n\\n        for(int i = 0; i<n; i++) {\\n            int successful = 0;\\n            for(int j = 0; j<m; j++) {\\n                int prod = spells[i]*potions[j];\\n                if(prod >= (int)success) {\\n                    successful++;\\n                }\\n            }\\n            pairs[i] = successful;\\n        }\\n\\n    return pairs;\\n\\n    }\\n}"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "Yes, if you approach that way, you will definitely get Time Limit Exceeded Error. Use binary search algorithms or sort the two arrays and scan only the specific portions."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why ceil function misbehaved in c++\\ni tried \\n\\n```\\nlong div =ceil ((float)success/(float)i);\\n```\\nbut for a testcase it failed for a single value\\n```\\nlong div = success/i;\\n            if(success%i) div++;\\n```\\nbut this passed why?\\n"
                    },
                    {
                        "username": "vetor",
                        "content": "Dont use ```Long.valueOf(potions[mid] * spell) < success``` instead use \\n\\n```1L * potions[mid] * spell``` for elevation of int The 1L literal promotes the result of potions[mid] * spell to a long primitive before the multiplication is performed, ensuring that the result is a long primitive with the correct value and precision. \\n\\nhope this may help"
                    },
                    {
                        "username": "devildecoder",
                        "content": "This ques  is quiet easy but due to the integer overflow, runtime  error occurs so keep in this mind..."
                    }
                ]
            },
            {
                "id": 1851549,
                "content": [
                    {
                        "username": "dashingboy110035",
                        "content": "`for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                temp = (long)spells[i]*potions[j];\\n                if(temp >= success){\\n                    cnt++;\\n                }\\n                temp=0;\\n            }\\n            ans.push_back(cnt);\\n            cnt=0;\\n        }\\n        return ans;`\\n\\n51/56 demn constraints."
                    },
                    {
                        "username": "samsondanielcaps",
                        "content": "Passed 54/56 and got time limit exceeded is there any way i can improve the code:\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        // Arrays.sort(spells);\\n        for(int i=0;i<spells.length;i++)\\n        {\\n            int c=0;\\n            for(int j=potions.length-1;j>=0;j--)\\n            {\\n                long n=(long)spells[i]*potions[j];\\n                if(n<success)\\n                {\\n                    break;\\n                }\\n                else{\\n                    c++;\\n                }\\n            }\\n            spells[i]=c;\\n        }    \\n        return spells;\\n    }\\n}"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Try to write in code format or use proper indents, very hard to read\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "55 / 56 testcases passed\\n\\uD83D\\uDE29"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "I\\'m solving this problem in brute froce approach plzz tell me what I did wrong here in this question .\\n\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int arr2[]= new int[spells.length];\\n        for(int i = 0 ;i<spells.length;i++)\\n        {\\n            int arr1[]= Multiplication(spells[i],potions);\\n            arr2[i] = counting(arr1, success);\\n        }        \\n        return arr2;\\n\\n    }\\n    public static int counting (int arr[],long success)\\n    {\\n        int count =0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]>=success)\\n            {\\n                count++;\\n            }\\n        }\\n        return count ;\\n    } \\n    public static int[] Multiplication(int a , int potions[])\\n    {\\n        int arr[]= new int[potions.length];\\n        for(int i=0;i<potions.length;i++)\\n        {\\n            arr[i]= a*potions[i];\\n        }\\n\\n        return arr;\\n    } \\n}"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "my solution fail in 48th test case \\n"
                    },
                    {
                        "username": "crysqrlkys",
                        "content": "shadow wizard money gang\\nwe love casting spells"
                    },
                    {
                        "username": "jemuel90880",
                        "content": "Did somebody solve this is C lang? man I cant seem to past the 48/56 testcases. help..."
                    },
                    {
                        "username": "user2871e",
                        "content": "faced similar issue in java, solved it with by multiplying 1L (1 long) with potions[mid]*spells[i]"
                    },
                    {
                        "username": "user1160Ov",
                        "content": "I went through 2 arrays (spells and potions) using for loops. Gave a if condition to check if the product(spells[i]*potions[j]) can be greater then success and had a counter for every pair. basically the na\\xEFve approach. But it didn\\'t work for a certain test case(48th one). help me\\n\\nclass Solution {\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\n        int n = spells.length;\\n        int m = potions.length;\\n\\n        int pairs[] = new int[n];\\n\\n        for(int i = 0; i<n; i++) {\\n            int successful = 0;\\n            for(int j = 0; j<m; j++) {\\n                int prod = spells[i]*potions[j];\\n                if(prod >= (int)success) {\\n                    successful++;\\n                }\\n            }\\n            pairs[i] = successful;\\n        }\\n\\n    return pairs;\\n\\n    }\\n}"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "Yes, if you approach that way, you will definitely get Time Limit Exceeded Error. Use binary search algorithms or sort the two arrays and scan only the specific portions."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why ceil function misbehaved in c++\\ni tried \\n\\n```\\nlong div =ceil ((float)success/(float)i);\\n```\\nbut for a testcase it failed for a single value\\n```\\nlong div = success/i;\\n            if(success%i) div++;\\n```\\nbut this passed why?\\n"
                    },
                    {
                        "username": "vetor",
                        "content": "Dont use ```Long.valueOf(potions[mid] * spell) < success``` instead use \\n\\n```1L * potions[mid] * spell``` for elevation of int The 1L literal promotes the result of potions[mid] * spell to a long primitive before the multiplication is performed, ensuring that the result is a long primitive with the correct value and precision. \\n\\nhope this may help"
                    },
                    {
                        "username": "devildecoder",
                        "content": "This ques  is quiet easy but due to the integer overflow, runtime  error occurs so keep in this mind..."
                    }
                ]
            },
            {
                "id": 1851535,
                "content": [
                    {
                        "username": "dashingboy110035",
                        "content": "`for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                temp = (long)spells[i]*potions[j];\\n                if(temp >= success){\\n                    cnt++;\\n                }\\n                temp=0;\\n            }\\n            ans.push_back(cnt);\\n            cnt=0;\\n        }\\n        return ans;`\\n\\n51/56 demn constraints."
                    },
                    {
                        "username": "samsondanielcaps",
                        "content": "Passed 54/56 and got time limit exceeded is there any way i can improve the code:\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        // Arrays.sort(spells);\\n        for(int i=0;i<spells.length;i++)\\n        {\\n            int c=0;\\n            for(int j=potions.length-1;j>=0;j--)\\n            {\\n                long n=(long)spells[i]*potions[j];\\n                if(n<success)\\n                {\\n                    break;\\n                }\\n                else{\\n                    c++;\\n                }\\n            }\\n            spells[i]=c;\\n        }    \\n        return spells;\\n    }\\n}"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Try to write in code format or use proper indents, very hard to read\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "55 / 56 testcases passed\\n\\uD83D\\uDE29"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "I\\'m solving this problem in brute froce approach plzz tell me what I did wrong here in this question .\\n\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int arr2[]= new int[spells.length];\\n        for(int i = 0 ;i<spells.length;i++)\\n        {\\n            int arr1[]= Multiplication(spells[i],potions);\\n            arr2[i] = counting(arr1, success);\\n        }        \\n        return arr2;\\n\\n    }\\n    public static int counting (int arr[],long success)\\n    {\\n        int count =0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]>=success)\\n            {\\n                count++;\\n            }\\n        }\\n        return count ;\\n    } \\n    public static int[] Multiplication(int a , int potions[])\\n    {\\n        int arr[]= new int[potions.length];\\n        for(int i=0;i<potions.length;i++)\\n        {\\n            arr[i]= a*potions[i];\\n        }\\n\\n        return arr;\\n    } \\n}"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "my solution fail in 48th test case \\n"
                    },
                    {
                        "username": "crysqrlkys",
                        "content": "shadow wizard money gang\\nwe love casting spells"
                    },
                    {
                        "username": "jemuel90880",
                        "content": "Did somebody solve this is C lang? man I cant seem to past the 48/56 testcases. help..."
                    },
                    {
                        "username": "user2871e",
                        "content": "faced similar issue in java, solved it with by multiplying 1L (1 long) with potions[mid]*spells[i]"
                    },
                    {
                        "username": "user1160Ov",
                        "content": "I went through 2 arrays (spells and potions) using for loops. Gave a if condition to check if the product(spells[i]*potions[j]) can be greater then success and had a counter for every pair. basically the na\\xEFve approach. But it didn\\'t work for a certain test case(48th one). help me\\n\\nclass Solution {\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\n        int n = spells.length;\\n        int m = potions.length;\\n\\n        int pairs[] = new int[n];\\n\\n        for(int i = 0; i<n; i++) {\\n            int successful = 0;\\n            for(int j = 0; j<m; j++) {\\n                int prod = spells[i]*potions[j];\\n                if(prod >= (int)success) {\\n                    successful++;\\n                }\\n            }\\n            pairs[i] = successful;\\n        }\\n\\n    return pairs;\\n\\n    }\\n}"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "Yes, if you approach that way, you will definitely get Time Limit Exceeded Error. Use binary search algorithms or sort the two arrays and scan only the specific portions."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why ceil function misbehaved in c++\\ni tried \\n\\n```\\nlong div =ceil ((float)success/(float)i);\\n```\\nbut for a testcase it failed for a single value\\n```\\nlong div = success/i;\\n            if(success%i) div++;\\n```\\nbut this passed why?\\n"
                    },
                    {
                        "username": "vetor",
                        "content": "Dont use ```Long.valueOf(potions[mid] * spell) < success``` instead use \\n\\n```1L * potions[mid] * spell``` for elevation of int The 1L literal promotes the result of potions[mid] * spell to a long primitive before the multiplication is performed, ensuring that the result is a long primitive with the correct value and precision. \\n\\nhope this may help"
                    },
                    {
                        "username": "devildecoder",
                        "content": "This ques  is quiet easy but due to the integer overflow, runtime  error occurs so keep in this mind..."
                    }
                ]
            },
            {
                "id": 1851496,
                "content": [
                    {
                        "username": "dashingboy110035",
                        "content": "`for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                temp = (long)spells[i]*potions[j];\\n                if(temp >= success){\\n                    cnt++;\\n                }\\n                temp=0;\\n            }\\n            ans.push_back(cnt);\\n            cnt=0;\\n        }\\n        return ans;`\\n\\n51/56 demn constraints."
                    },
                    {
                        "username": "samsondanielcaps",
                        "content": "Passed 54/56 and got time limit exceeded is there any way i can improve the code:\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        // Arrays.sort(spells);\\n        for(int i=0;i<spells.length;i++)\\n        {\\n            int c=0;\\n            for(int j=potions.length-1;j>=0;j--)\\n            {\\n                long n=(long)spells[i]*potions[j];\\n                if(n<success)\\n                {\\n                    break;\\n                }\\n                else{\\n                    c++;\\n                }\\n            }\\n            spells[i]=c;\\n        }    \\n        return spells;\\n    }\\n}"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Try to write in code format or use proper indents, very hard to read\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "55 / 56 testcases passed\\n\\uD83D\\uDE29"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "I\\'m solving this problem in brute froce approach plzz tell me what I did wrong here in this question .\\n\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int arr2[]= new int[spells.length];\\n        for(int i = 0 ;i<spells.length;i++)\\n        {\\n            int arr1[]= Multiplication(spells[i],potions);\\n            arr2[i] = counting(arr1, success);\\n        }        \\n        return arr2;\\n\\n    }\\n    public static int counting (int arr[],long success)\\n    {\\n        int count =0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]>=success)\\n            {\\n                count++;\\n            }\\n        }\\n        return count ;\\n    } \\n    public static int[] Multiplication(int a , int potions[])\\n    {\\n        int arr[]= new int[potions.length];\\n        for(int i=0;i<potions.length;i++)\\n        {\\n            arr[i]= a*potions[i];\\n        }\\n\\n        return arr;\\n    } \\n}"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "my solution fail in 48th test case \\n"
                    },
                    {
                        "username": "crysqrlkys",
                        "content": "shadow wizard money gang\\nwe love casting spells"
                    },
                    {
                        "username": "jemuel90880",
                        "content": "Did somebody solve this is C lang? man I cant seem to past the 48/56 testcases. help..."
                    },
                    {
                        "username": "user2871e",
                        "content": "faced similar issue in java, solved it with by multiplying 1L (1 long) with potions[mid]*spells[i]"
                    },
                    {
                        "username": "user1160Ov",
                        "content": "I went through 2 arrays (spells and potions) using for loops. Gave a if condition to check if the product(spells[i]*potions[j]) can be greater then success and had a counter for every pair. basically the na\\xEFve approach. But it didn\\'t work for a certain test case(48th one). help me\\n\\nclass Solution {\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\n        int n = spells.length;\\n        int m = potions.length;\\n\\n        int pairs[] = new int[n];\\n\\n        for(int i = 0; i<n; i++) {\\n            int successful = 0;\\n            for(int j = 0; j<m; j++) {\\n                int prod = spells[i]*potions[j];\\n                if(prod >= (int)success) {\\n                    successful++;\\n                }\\n            }\\n            pairs[i] = successful;\\n        }\\n\\n    return pairs;\\n\\n    }\\n}"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "Yes, if you approach that way, you will definitely get Time Limit Exceeded Error. Use binary search algorithms or sort the two arrays and scan only the specific portions."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why ceil function misbehaved in c++\\ni tried \\n\\n```\\nlong div =ceil ((float)success/(float)i);\\n```\\nbut for a testcase it failed for a single value\\n```\\nlong div = success/i;\\n            if(success%i) div++;\\n```\\nbut this passed why?\\n"
                    },
                    {
                        "username": "vetor",
                        "content": "Dont use ```Long.valueOf(potions[mid] * spell) < success``` instead use \\n\\n```1L * potions[mid] * spell``` for elevation of int The 1L literal promotes the result of potions[mid] * spell to a long primitive before the multiplication is performed, ensuring that the result is a long primitive with the correct value and precision. \\n\\nhope this may help"
                    },
                    {
                        "username": "devildecoder",
                        "content": "This ques  is quiet easy but due to the integer overflow, runtime  error occurs so keep in this mind..."
                    }
                ]
            },
            {
                "id": 1851491,
                "content": [
                    {
                        "username": "dashingboy110035",
                        "content": "`for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                temp = (long)spells[i]*potions[j];\\n                if(temp >= success){\\n                    cnt++;\\n                }\\n                temp=0;\\n            }\\n            ans.push_back(cnt);\\n            cnt=0;\\n        }\\n        return ans;`\\n\\n51/56 demn constraints."
                    },
                    {
                        "username": "samsondanielcaps",
                        "content": "Passed 54/56 and got time limit exceeded is there any way i can improve the code:\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        // Arrays.sort(spells);\\n        for(int i=0;i<spells.length;i++)\\n        {\\n            int c=0;\\n            for(int j=potions.length-1;j>=0;j--)\\n            {\\n                long n=(long)spells[i]*potions[j];\\n                if(n<success)\\n                {\\n                    break;\\n                }\\n                else{\\n                    c++;\\n                }\\n            }\\n            spells[i]=c;\\n        }    \\n        return spells;\\n    }\\n}"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Try to write in code format or use proper indents, very hard to read\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "55 / 56 testcases passed\\n\\uD83D\\uDE29"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "I\\'m solving this problem in brute froce approach plzz tell me what I did wrong here in this question .\\n\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int arr2[]= new int[spells.length];\\n        for(int i = 0 ;i<spells.length;i++)\\n        {\\n            int arr1[]= Multiplication(spells[i],potions);\\n            arr2[i] = counting(arr1, success);\\n        }        \\n        return arr2;\\n\\n    }\\n    public static int counting (int arr[],long success)\\n    {\\n        int count =0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]>=success)\\n            {\\n                count++;\\n            }\\n        }\\n        return count ;\\n    } \\n    public static int[] Multiplication(int a , int potions[])\\n    {\\n        int arr[]= new int[potions.length];\\n        for(int i=0;i<potions.length;i++)\\n        {\\n            arr[i]= a*potions[i];\\n        }\\n\\n        return arr;\\n    } \\n}"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "my solution fail in 48th test case \\n"
                    },
                    {
                        "username": "crysqrlkys",
                        "content": "shadow wizard money gang\\nwe love casting spells"
                    },
                    {
                        "username": "jemuel90880",
                        "content": "Did somebody solve this is C lang? man I cant seem to past the 48/56 testcases. help..."
                    },
                    {
                        "username": "user2871e",
                        "content": "faced similar issue in java, solved it with by multiplying 1L (1 long) with potions[mid]*spells[i]"
                    },
                    {
                        "username": "user1160Ov",
                        "content": "I went through 2 arrays (spells and potions) using for loops. Gave a if condition to check if the product(spells[i]*potions[j]) can be greater then success and had a counter for every pair. basically the na\\xEFve approach. But it didn\\'t work for a certain test case(48th one). help me\\n\\nclass Solution {\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\n        int n = spells.length;\\n        int m = potions.length;\\n\\n        int pairs[] = new int[n];\\n\\n        for(int i = 0; i<n; i++) {\\n            int successful = 0;\\n            for(int j = 0; j<m; j++) {\\n                int prod = spells[i]*potions[j];\\n                if(prod >= (int)success) {\\n                    successful++;\\n                }\\n            }\\n            pairs[i] = successful;\\n        }\\n\\n    return pairs;\\n\\n    }\\n}"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "Yes, if you approach that way, you will definitely get Time Limit Exceeded Error. Use binary search algorithms or sort the two arrays and scan only the specific portions."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why ceil function misbehaved in c++\\ni tried \\n\\n```\\nlong div =ceil ((float)success/(float)i);\\n```\\nbut for a testcase it failed for a single value\\n```\\nlong div = success/i;\\n            if(success%i) div++;\\n```\\nbut this passed why?\\n"
                    },
                    {
                        "username": "vetor",
                        "content": "Dont use ```Long.valueOf(potions[mid] * spell) < success``` instead use \\n\\n```1L * potions[mid] * spell``` for elevation of int The 1L literal promotes the result of potions[mid] * spell to a long primitive before the multiplication is performed, ensuring that the result is a long primitive with the correct value and precision. \\n\\nhope this may help"
                    },
                    {
                        "username": "devildecoder",
                        "content": "This ques  is quiet easy but due to the integer overflow, runtime  error occurs so keep in this mind..."
                    }
                ]
            },
            {
                "id": 1851478,
                "content": [
                    {
                        "username": "dashingboy110035",
                        "content": "`for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                temp = (long)spells[i]*potions[j];\\n                if(temp >= success){\\n                    cnt++;\\n                }\\n                temp=0;\\n            }\\n            ans.push_back(cnt);\\n            cnt=0;\\n        }\\n        return ans;`\\n\\n51/56 demn constraints."
                    },
                    {
                        "username": "samsondanielcaps",
                        "content": "Passed 54/56 and got time limit exceeded is there any way i can improve the code:\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        // Arrays.sort(spells);\\n        for(int i=0;i<spells.length;i++)\\n        {\\n            int c=0;\\n            for(int j=potions.length-1;j>=0;j--)\\n            {\\n                long n=(long)spells[i]*potions[j];\\n                if(n<success)\\n                {\\n                    break;\\n                }\\n                else{\\n                    c++;\\n                }\\n            }\\n            spells[i]=c;\\n        }    \\n        return spells;\\n    }\\n}"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Try to write in code format or use proper indents, very hard to read\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "55 / 56 testcases passed\\n\\uD83D\\uDE29"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "I\\'m solving this problem in brute froce approach plzz tell me what I did wrong here in this question .\\n\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int arr2[]= new int[spells.length];\\n        for(int i = 0 ;i<spells.length;i++)\\n        {\\n            int arr1[]= Multiplication(spells[i],potions);\\n            arr2[i] = counting(arr1, success);\\n        }        \\n        return arr2;\\n\\n    }\\n    public static int counting (int arr[],long success)\\n    {\\n        int count =0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]>=success)\\n            {\\n                count++;\\n            }\\n        }\\n        return count ;\\n    } \\n    public static int[] Multiplication(int a , int potions[])\\n    {\\n        int arr[]= new int[potions.length];\\n        for(int i=0;i<potions.length;i++)\\n        {\\n            arr[i]= a*potions[i];\\n        }\\n\\n        return arr;\\n    } \\n}"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "my solution fail in 48th test case \\n"
                    },
                    {
                        "username": "crysqrlkys",
                        "content": "shadow wizard money gang\\nwe love casting spells"
                    },
                    {
                        "username": "jemuel90880",
                        "content": "Did somebody solve this is C lang? man I cant seem to past the 48/56 testcases. help..."
                    },
                    {
                        "username": "user2871e",
                        "content": "faced similar issue in java, solved it with by multiplying 1L (1 long) with potions[mid]*spells[i]"
                    },
                    {
                        "username": "user1160Ov",
                        "content": "I went through 2 arrays (spells and potions) using for loops. Gave a if condition to check if the product(spells[i]*potions[j]) can be greater then success and had a counter for every pair. basically the na\\xEFve approach. But it didn\\'t work for a certain test case(48th one). help me\\n\\nclass Solution {\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\n        int n = spells.length;\\n        int m = potions.length;\\n\\n        int pairs[] = new int[n];\\n\\n        for(int i = 0; i<n; i++) {\\n            int successful = 0;\\n            for(int j = 0; j<m; j++) {\\n                int prod = spells[i]*potions[j];\\n                if(prod >= (int)success) {\\n                    successful++;\\n                }\\n            }\\n            pairs[i] = successful;\\n        }\\n\\n    return pairs;\\n\\n    }\\n}"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "Yes, if you approach that way, you will definitely get Time Limit Exceeded Error. Use binary search algorithms or sort the two arrays and scan only the specific portions."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why ceil function misbehaved in c++\\ni tried \\n\\n```\\nlong div =ceil ((float)success/(float)i);\\n```\\nbut for a testcase it failed for a single value\\n```\\nlong div = success/i;\\n            if(success%i) div++;\\n```\\nbut this passed why?\\n"
                    },
                    {
                        "username": "vetor",
                        "content": "Dont use ```Long.valueOf(potions[mid] * spell) < success``` instead use \\n\\n```1L * potions[mid] * spell``` for elevation of int The 1L literal promotes the result of potions[mid] * spell to a long primitive before the multiplication is performed, ensuring that the result is a long primitive with the correct value and precision. \\n\\nhope this may help"
                    },
                    {
                        "username": "devildecoder",
                        "content": "This ques  is quiet easy but due to the integer overflow, runtime  error occurs so keep in this mind..."
                    }
                ]
            },
            {
                "id": 1851457,
                "content": [
                    {
                        "username": "dashingboy110035",
                        "content": "`for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                temp = (long)spells[i]*potions[j];\\n                if(temp >= success){\\n                    cnt++;\\n                }\\n                temp=0;\\n            }\\n            ans.push_back(cnt);\\n            cnt=0;\\n        }\\n        return ans;`\\n\\n51/56 demn constraints."
                    },
                    {
                        "username": "samsondanielcaps",
                        "content": "Passed 54/56 and got time limit exceeded is there any way i can improve the code:\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        // Arrays.sort(spells);\\n        for(int i=0;i<spells.length;i++)\\n        {\\n            int c=0;\\n            for(int j=potions.length-1;j>=0;j--)\\n            {\\n                long n=(long)spells[i]*potions[j];\\n                if(n<success)\\n                {\\n                    break;\\n                }\\n                else{\\n                    c++;\\n                }\\n            }\\n            spells[i]=c;\\n        }    \\n        return spells;\\n    }\\n}"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Try to write in code format or use proper indents, very hard to read\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "55 / 56 testcases passed\\n\\uD83D\\uDE29"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "I\\'m solving this problem in brute froce approach plzz tell me what I did wrong here in this question .\\n\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int arr2[]= new int[spells.length];\\n        for(int i = 0 ;i<spells.length;i++)\\n        {\\n            int arr1[]= Multiplication(spells[i],potions);\\n            arr2[i] = counting(arr1, success);\\n        }        \\n        return arr2;\\n\\n    }\\n    public static int counting (int arr[],long success)\\n    {\\n        int count =0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]>=success)\\n            {\\n                count++;\\n            }\\n        }\\n        return count ;\\n    } \\n    public static int[] Multiplication(int a , int potions[])\\n    {\\n        int arr[]= new int[potions.length];\\n        for(int i=0;i<potions.length;i++)\\n        {\\n            arr[i]= a*potions[i];\\n        }\\n\\n        return arr;\\n    } \\n}"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "my solution fail in 48th test case \\n"
                    },
                    {
                        "username": "crysqrlkys",
                        "content": "shadow wizard money gang\\nwe love casting spells"
                    },
                    {
                        "username": "jemuel90880",
                        "content": "Did somebody solve this is C lang? man I cant seem to past the 48/56 testcases. help..."
                    },
                    {
                        "username": "user2871e",
                        "content": "faced similar issue in java, solved it with by multiplying 1L (1 long) with potions[mid]*spells[i]"
                    },
                    {
                        "username": "user1160Ov",
                        "content": "I went through 2 arrays (spells and potions) using for loops. Gave a if condition to check if the product(spells[i]*potions[j]) can be greater then success and had a counter for every pair. basically the na\\xEFve approach. But it didn\\'t work for a certain test case(48th one). help me\\n\\nclass Solution {\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\n        int n = spells.length;\\n        int m = potions.length;\\n\\n        int pairs[] = new int[n];\\n\\n        for(int i = 0; i<n; i++) {\\n            int successful = 0;\\n            for(int j = 0; j<m; j++) {\\n                int prod = spells[i]*potions[j];\\n                if(prod >= (int)success) {\\n                    successful++;\\n                }\\n            }\\n            pairs[i] = successful;\\n        }\\n\\n    return pairs;\\n\\n    }\\n}"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "Yes, if you approach that way, you will definitely get Time Limit Exceeded Error. Use binary search algorithms or sort the two arrays and scan only the specific portions."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why ceil function misbehaved in c++\\ni tried \\n\\n```\\nlong div =ceil ((float)success/(float)i);\\n```\\nbut for a testcase it failed for a single value\\n```\\nlong div = success/i;\\n            if(success%i) div++;\\n```\\nbut this passed why?\\n"
                    },
                    {
                        "username": "vetor",
                        "content": "Dont use ```Long.valueOf(potions[mid] * spell) < success``` instead use \\n\\n```1L * potions[mid] * spell``` for elevation of int The 1L literal promotes the result of potions[mid] * spell to a long primitive before the multiplication is performed, ensuring that the result is a long primitive with the correct value and precision. \\n\\nhope this may help"
                    },
                    {
                        "username": "devildecoder",
                        "content": "This ques  is quiet easy but due to the integer overflow, runtime  error occurs so keep in this mind..."
                    }
                ]
            }
        ]
    }
]