[
    {
        "title": "Squares of a Sorted Array",
        "question_content": "Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.\n&nbsp;\nExample 1:\n\nInput: nums = [-4,-1,0,3,10]\nOutput: [0,1,9,16,100]\nExplanation: After squaring, the array becomes [16,1,0,9,100].\nAfter sorting, it becomes [0,1,9,16,100].\n\nExample 2:\n\nInput: nums = [-7,-3,2,3,11]\nOutput: [4,9,9,49,121]\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 104\n\t-104 <= nums[i] <= 104\n\tnums is sorted in non-decreasing order.\n\n&nbsp;\nFollow up: Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach?",
        "solutions": [
            {
                "id": 221922,
                "title": "java-two-pointers-o-n",
                "content": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] A) {\\n        int n = A.length;\\n        int[] result = new int[n];\\n        int i = 0, j = n - 1;\\n        for (int p = n - 1; p >= 0; p--) {\\n            if (Math.abs(A[i]) > Math.abs(A[j])) {\\n                result[p] = A[i] * A[i];\\n                i++;\\n            } else {\\n                result[p] = A[j] * A[j];\\n                j--;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] A) {\\n        int n = A.length;\\n        int[] result = new int[n];\\n        int i = 0, j = n - 1;\\n        for (int p = n - 1; p >= 0; p--) {\\n            if (Math.abs(A[i]) > Math.abs(A[j])) {\\n                result[p] = A[i] * A[i];\\n                i++;\\n            } else {\\n                result[p] = A[j] * A[j];\\n                j--;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 495394,
                "title": "c-simplest-one-pass-two-pointers",
                "content": "Based on [original post by yukuairoy](https://leetcode.com/problems/squares-of-a-sorted-array/discuss/283978/Python-Two-Pointers).\\n\\nLet\\'s take example with negative and positive numbers, like:\\n```\\n[-4, -2, 0, 1, 3]\\n```\\nSince we need to put squeres in result array, we can consider that all numbers are positive (since: `-4**2 = 4**2 = 16`). Now our array looks like it sorted from middle to outside on both sides:\\n```\\n[4, 2, 0, 1, 3]\\n```\\nNow, we can have two pointers `l` to left most element, `r` to most right element.\\nCreate `res` result array same size as `A`.\\nMove from right to left in `res` and past `max(abs(A[l]), abs(A[r]))`, move correspondingly `l++` or `r--`.\\n\\n![image](https://assets.leetcode.com/users/andnik/image_1580828708.png)\\n\\nSame works for example with all negative and all positive numbers.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& A) {\\n        vector<int> res(A.size());\\n        int l = 0, r = A.size() - 1;\\n        for (int k = A.size() - 1; k >= 0; k--) {\\n            if (abs(A[r]) > abs(A[l])) res[k] = A[r] * A[r--];\\n            else res[k] = A[l] * A[l++];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n[-4, -2, 0, 1, 3]\\n```\n```\\n[4, 2, 0, 1, 3]\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& A) {\\n        vector<int> res(A.size());\\n        int l = 0, r = A.size() - 1;\\n        for (int k = A.size() - 1; k >= 0; k--) {\\n            if (abs(A[r]) > abs(A[l])) res[k] = A[r] * A[r--];\\n            else res[k] = A[l] * A[l++];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 310865,
                "title": "python-a-comparison-of-lots-of-approaches-sorting-two-pointers-deque-iterator-generator",
                "content": "This question is a cool one in that there is lots of different approaches, each with its own pros and cons. And then there\\'s also different ways of implementing them, depending on whether you are after raw performance or beautiful code.\\n\\nSomething slightly irritating is that leetcode isn\\'t testing with big enough test cases to push the time complexity of the O(n-log-n) approaches below the O(n) ones. It goes to show, sometimes what \"wins\" at the notoriously inaccurate Leetcode time/ space percentiles isn\\'t always the best in practice, or even in an interview.\\n\\n# Approach #1: Using built in sort.\\nThere are a few similar approaches we can take here, each with its own subtle differences. All are of an ```O(n-log-n)``` time complexity due to using the inbuilt sort, although they differ in their space complexity.\\n\\n## a) Overwriting input:\\n\\n```\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        for i in range(len(A)):\\n            A[i] *= A[i]\\n        A.sort()\\n        return A\\n```\\n\\nThis approach uses ```O(1)``` memory beyond the input array, and is truely **in-place**. *However*, it is not always a good idea to overwrite inputs. Remember that because we passed it by reference, the original is actually lost. Often functions like this are a part of an API, and in a lot of cases, nobody wants an API that clobbers their input.\\n\\nI think it\\'s best to ask your interviewer if they want something done **in-place** or not. It is a common misconception that we should *always* be trying to do things in-place, overwriting the inputs.\\n\\n## b) Making a new array, not in place, O(n) auxillary space.\\n\\n```\\ndef sortedSquares(self, A: List[int]) -> List[int]:\\n        return sorted([v**2 for v in A])\\n```\\n\\nAhhhh, our good \\'ol clever Python one-liner. There is a suble space inefficiency in it though. For a brief moment, we\\'re using 3n memory, not 2n. The one line has 2 not-in-place operations in it; the list comprehension creates a new list, and so does sorted. The list comprehension list is promptly garbage collected upon function return, *but* because it was briefly there, the max memory usage was ultimately 3n. With lots of memory, this is totally fine, and the pythonic nature of it makes it a great solution. But we do need to be aware of it.\\n\\n## c) Making a new array, not in place, O(1) auxillary space.\\n\\nMaking a new array, in place.\\n\\n```\\ndef sortedSquares(self, A: List[int]) -> List[int]:\\n        return_array = [v**2 for v in A]\\n\\t\\treturn_array.sort() # This is in place!\\n\\t\\treturn return_array\\n```\\n\\nSo, is this ```O(1)``` space or ```O(n)``` space? Arguments can be made either way, sometimes people say to count the output data stucture in the calculation, and sometimes they don\\'t. If we\\'re talking about *auxillary* space, we generally don\\'t count the output data structure, which would make it ```O(1)```. I think this is a more accurate way of putting it -- we are trying to measure what the algorithm itself is using, not just what the inevitable size of the output is. But it\\'s important to be clear in interviews what you are and aren\\'t counting.\\n\\n## Overall thoughts on these approaches\\nYou won\\'t be coding any of these approaches in an interview (in my own very, very limited experience though!). By all means your interviewer will want to hear that you could do it this way, but there is 3 big problems if they are the only approaches you can come up with.\\n1) We shouldn\\'t need to use an O(n-log-n) sort operation on data that for the most part is already sorted. There\\'s something not right with that. If this is the approach the interviewer wanted, they wouldn\\'t have given you the numbers in a sorted list in the first place.\\n2) Following on from that, there are O(n) solutions.\\n3) Why would they be asking you to code something so trivial? Let\\'s be honest. They want to see you writing some meaty code. \\n\\nThe remaining approaches exploit the existing sorting. If we were to go down the list squaring each number, we\\'d have a \"v\" sorted list, in that the squares of the negatives decrease, and then the squares of the positives increase, i.e.\\n```[-4, -2, -1, 0, 1, 2, 3, 5] -> [16, 4, 1, 0, 1, 4, 9, 25]```\\n\\nWe can get this into a sorted list in ```O(n)``` time.\\n# Approach 2: Raw pointers\\nIn terms of performance, you can\\'t beat this (well, if leetcode actually tested on massive test cases...). It\\'s O(n) time, and O(1) auxillary space.\\n\\n```\\nclass Solution:\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        return_array = [0] * len(A)\\n        write_pointer = len(A) - 1\\n        left_read_pointer = 0\\n        right_read_pointer = len(A) - 1\\n        left_square = A[left_read_pointer] ** 2\\n        right_square = A[right_read_pointer] ** 2\\n        while write_pointer >= 0:\\n            if left_square > right_square:\\n                return_array[write_pointer] = left_square\\n                left_read_pointer += 1\\n                left_square = A[left_read_pointer] ** 2\\n            else:\\n                return_array[write_pointer] = right_square\\n                right_read_pointer -= 1\\n                right_square = A[right_read_pointer] ** 2\\n            write_pointer -= 1\\n        return return_array\\n```\\n\\n# Approach 3: Using a deque \\nThis approach is the first of the trading-off-some-raw-performance-for-beauty=and-elegance approaches. It remains as ```O(n)``` *time complexity* like approach 2, but the heavy-weight nature of it will slow it down by a constant amount. If this doesn\\'t matter though (and in a lot of cases it doesn\\'t), then the elegance will reduce the risk of bugs and lead to more readable and maintable code. It is also important to note that it does use ```O(n)``` *auxillary space*.\\n\\n```\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        number_deque = collections.deque(A)\\n        reverse_sorted_squares = []\\n        while number_deque:\\n            left_square = number_deque[0] ** 2\\n            right_square = number_deque[-1] ** 2\\n            if left_square > right_square:\\n                reverse_sorted_squares.append(left_square)\\n                number_deque.popleft()\\n            else:\\n                reverse_sorted_squares.append(right_square)\\n                number_deque.pop()\\n        return reverse_sorted_squares[::-1]\\n```\\n\\n# Approach 4: The iterator pattern\\nThis is one of my favourites. While it suffers from the same constant time slowdown as the previous approach, its auxillary space usage remains at ```O(1)```. The iterator pattern is a great way of splitting up code into more testable units. It seperates the problem of getting the squares in a sorted order from the problem of writing them into an array.\\n\\nThere are 2 subapproaches. One that returns the squares in reversed order, and one that puts them around the right way. The latter is more complex to code, but it means that the code dealing with the writing doesn\\'t have to reverse them, and it is still a time complexity of ```O(n)``` and an auxillary space usage of ```O(1)```.\\n\\n## a) Iterator returning from largest -> smallest\\n\\n```\\nclass SquaresIterator(object):\\n    def __init__(self, sorted_array):\\n        self.sorted_array = sorted_array\\n        self.left_pointer = 0\\n        self.right_pointer = len(sorted_array) - 1\\n    \\n    def __iter__(self):\\n        return self\\n    \\n    def __next__(self):\\n        if self.left_pointer > self.right_pointer:\\n            raise StopIteration\\n        left_square = self.sorted_array[self.left_pointer] ** 2\\n        right_square = self.sorted_array[self.right_pointer] ** 2\\n        if left_square > right_square:\\n            self.left_pointer += 1\\n            return left_square\\n        else:\\n            self.right_pointer -= 1\\n            return right_square\\n     \\n\\nclass Solution:\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        return_array = [0] * len(A)\\n        write_pointer = len(A) - 1\\n        for square in SquaresIterator(A):\\n            return_array[write_pointer] = square\\n            write_pointer -= 1\\n        return return_array\\n```\\n\\n## b) Iterator returning from smallest -> largest\\n\\nThis one uses a binary search to set the left and right pointers in the middle of the array to begin with. This way, the items are returned in the correct order. We don\\'t even need explicit write code here!\\n\\n```\\nclass SquaresIterator(object):\\n    \\n    def __init__(self, sorted_array):\\n        self.sorted_array = sorted_array\\n        self.left_pointer, self.right_pointer = self._get_pointers()\\n    \\n    def __iter__(self):\\n        return self\\n    \\n    def __next__(self):\\n        \\n        # If there\\'s no values remaining.\\n        if self.left_pointer < 0 and self.right_pointer >= len(self.sorted_array):\\n            raise StopIteration\\n        \\n        # If there\\'s no values remaining on the left end.\\n        if self.left_pointer < 0:\\n            self.right_pointer += 1\\n            return self.sorted_array[self.right_pointer - 1] ** 2\\n        \\n        # If there\\'s no values remaining on the right end.\\n        if self.right_pointer >= len(self.sorted_array):\\n            self.left_pointer -= 1\\n            return self.sorted_array[self.left_pointer + 1] ** 2\\n        \\n        # If there\\'s values remaining on both ends.\\n        left_square = self.sorted_array[self.left_pointer] ** 2\\n        right_square = self.sorted_array[self.right_pointer] ** 2\\n        if left_square < right_square:\\n            self.left_pointer -= 1\\n            return left_square\\n        else:\\n            self.right_pointer += 1\\n            return right_square\\n    \\n    \\n    def _get_pointers(self):\\n        low = 0\\n        high = len(self.sorted_array)\\n        while high - low > 1:\\n            mid = low + (high - low) // 2\\n            if self.sorted_array[mid] > 0:\\n                high = mid\\n            else:\\n                low = mid\\n        return low, high\\n        \\n    \\nclass Solution:\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        return list(SquaresIterator(A))\\n```\\n\\n# Approach 5: Generators\\nWhy are we using iterators for such a simple task? We can use a generator function instead!\\n\\nAgain, it\\'s O(n) time with O(1) auxillary space.\\n\\n```\\nclass Solution:\\n    \\n    def generate_sorted_squares(self, nums):\\n        \\n        # Start by doing our binary search to find where\\n        # to place the pointers.\\n        left = 0\\n        right = len(nums)\\n        while right - left > 1:\\n            mid = left + (right - left) // 2\\n            if nums[mid] > 0:\\n                right = mid\\n            else:\\n                left = mid\\n        \\n        # And now the main generator loop. The condition is the negation\\n        # of the StopIteration condition for the iterator approach.\\n        while left >= 0 or right < len(nums):\\n            if left < 0:\\n                right += 1\\n                yield nums[right - 1] ** 2\\n            elif right >= len(nums):\\n                left -= 1\\n                yield nums[left + 1] ** 2\\n            else:\\n                left_square = nums[left] ** 2\\n                right_square = nums[right] ** 2\\n                if left_square < right_square:\\n                    left -= 1\\n                    yield left_square\\n                else:\\n                    right += 1\\n                    yield right_square\\n        \\n    \\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        return list(self.generate_sorted_squares(A))\\n```\\n\\n# In conclusion\\nI\\'m sure there are many more approaches. Another would be to combine the 2 pointer technique with the binary search. \\n\\nI\\'m interested in thoughts people have on which is best in an interview!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Queue",
                    "Sorting",
                    "Iterator"
                ],
                "code": "```O(n-log-n)```\n```\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        for i in range(len(A)):\\n            A[i] *= A[i]\\n        A.sort()\\n        return A\\n```\n```O(1)```\n```\\ndef sortedSquares(self, A: List[int]) -> List[int]:\\n        return sorted([v**2 for v in A])\\n```\n```\\ndef sortedSquares(self, A: List[int]) -> List[int]:\\n        return_array = [v**2 for v in A]\\n\\t\\treturn_array.sort() # This is in place!\\n\\t\\treturn return_array\\n```\n```O(1)```\n```O(n)```\n```O(1)```\n```[-4, -2, -1, 0, 1, 2, 3, 5] -> [16, 4, 1, 0, 1, 4, 9, 25]```\n```O(n)```\n```\\nclass Solution:\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        return_array = [0] * len(A)\\n        write_pointer = len(A) - 1\\n        left_read_pointer = 0\\n        right_read_pointer = len(A) - 1\\n        left_square = A[left_read_pointer] ** 2\\n        right_square = A[right_read_pointer] ** 2\\n        while write_pointer >= 0:\\n            if left_square > right_square:\\n                return_array[write_pointer] = left_square\\n                left_read_pointer += 1\\n                left_square = A[left_read_pointer] ** 2\\n            else:\\n                return_array[write_pointer] = right_square\\n                right_read_pointer -= 1\\n                right_square = A[right_read_pointer] ** 2\\n            write_pointer -= 1\\n        return return_array\\n```\n```O(n)```\n```O(n)```\n```\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        number_deque = collections.deque(A)\\n        reverse_sorted_squares = []\\n        while number_deque:\\n            left_square = number_deque[0] ** 2\\n            right_square = number_deque[-1] ** 2\\n            if left_square > right_square:\\n                reverse_sorted_squares.append(left_square)\\n                number_deque.popleft()\\n            else:\\n                reverse_sorted_squares.append(right_square)\\n                number_deque.pop()\\n        return reverse_sorted_squares[::-1]\\n```\n```O(1)```\n```O(n)```\n```O(1)```\n```\\nclass SquaresIterator(object):\\n    def __init__(self, sorted_array):\\n        self.sorted_array = sorted_array\\n        self.left_pointer = 0\\n        self.right_pointer = len(sorted_array) - 1\\n    \\n    def __iter__(self):\\n        return self\\n    \\n    def __next__(self):\\n        if self.left_pointer > self.right_pointer:\\n            raise StopIteration\\n        left_square = self.sorted_array[self.left_pointer] ** 2\\n        right_square = self.sorted_array[self.right_pointer] ** 2\\n        if left_square > right_square:\\n            self.left_pointer += 1\\n            return left_square\\n        else:\\n            self.right_pointer -= 1\\n            return right_square\\n     \\n\\nclass Solution:\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        return_array = [0] * len(A)\\n        write_pointer = len(A) - 1\\n        for square in SquaresIterator(A):\\n            return_array[write_pointer] = square\\n            write_pointer -= 1\\n        return return_array\\n```\n```\\nclass SquaresIterator(object):\\n    \\n    def __init__(self, sorted_array):\\n        self.sorted_array = sorted_array\\n        self.left_pointer, self.right_pointer = self._get_pointers()\\n    \\n    def __iter__(self):\\n        return self\\n    \\n    def __next__(self):\\n        \\n        # If there\\'s no values remaining.\\n        if self.left_pointer < 0 and self.right_pointer >= len(self.sorted_array):\\n            raise StopIteration\\n        \\n        # If there\\'s no values remaining on the left end.\\n        if self.left_pointer < 0:\\n            self.right_pointer += 1\\n            return self.sorted_array[self.right_pointer - 1] ** 2\\n        \\n        # If there\\'s no values remaining on the right end.\\n        if self.right_pointer >= len(self.sorted_array):\\n            self.left_pointer -= 1\\n            return self.sorted_array[self.left_pointer + 1] ** 2\\n        \\n        # If there\\'s values remaining on both ends.\\n        left_square = self.sorted_array[self.left_pointer] ** 2\\n        right_square = self.sorted_array[self.right_pointer] ** 2\\n        if left_square < right_square:\\n            self.left_pointer -= 1\\n            return left_square\\n        else:\\n            self.right_pointer += 1\\n            return right_square\\n    \\n    \\n    def _get_pointers(self):\\n        low = 0\\n        high = len(self.sorted_array)\\n        while high - low > 1:\\n            mid = low + (high - low) // 2\\n            if self.sorted_array[mid] > 0:\\n                high = mid\\n            else:\\n                low = mid\\n        return low, high\\n        \\n    \\nclass Solution:\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        return list(SquaresIterator(A))\\n```\n```\\nclass Solution:\\n    \\n    def generate_sorted_squares(self, nums):\\n        \\n        # Start by doing our binary search to find where\\n        # to place the pointers.\\n        left = 0\\n        right = len(nums)\\n        while right - left > 1:\\n            mid = left + (right - left) // 2\\n            if nums[mid] > 0:\\n                right = mid\\n            else:\\n                left = mid\\n        \\n        # And now the main generator loop. The condition is the negation\\n        # of the StopIteration condition for the iterator approach.\\n        while left >= 0 or right < len(nums):\\n            if left < 0:\\n                right += 1\\n                yield nums[right - 1] ** 2\\n            elif right >= len(nums):\\n                left -= 1\\n                yield nums[left + 1] ** 2\\n            else:\\n                left_square = nums[left] ** 2\\n                right_square = nums[right] ** 2\\n                if left_square < right_square:\\n                    left -= 1\\n                    yield left_square\\n                else:\\n                    right += 1\\n                    yield right_square\\n        \\n    \\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        return list(self.generate_sorted_squares(A))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 222079,
                "title": "python-o-n-10-lines-two-solutions-explained-beats-100",
                "content": "```python\\ndef sortedSquares(self, A):\\n    answer = collections.deque()\\n    l, r = 0, len(A) - 1\\n    while l <= r:\\n        left, right = abs(A[l]), abs(A[r])\\n        if left > right:\\n            answer.appendleft(left * left)\\n            l += 1\\n        else:\\n            answer.appendleft(right * right)\\n            r -= 1\\n    return list(answer)\\n```\\nThe question boils down to understanding that if we look at the magnitude of the elements in the array, `A`, both ends \"slide down\" and converge towards the center of the array. With that understanding, we can use two pointers, one at each end, to iteratively collect the larger square to a list. However, collecting the larger square in a list with `list`\\'s `append`, results in elements sorted in descending order. To circumvent this, we need to append to the left of the list. Using a `collections.deque()` allows us to append elements to the left of `answer` in O(1) time, maintaining the required increasing order.\\n\\n**Alternative without deque or list reversal**\\n```python\\ndef sortedSquares(self, A):\\n    answer = [0] * len(A)\\n    l, r = 0, len(A) - 1\\n    while l <= r:\\n        left, right = abs(A[l]), abs(A[r])\\n        if left > right:\\n            answer[r - l] = left * left\\n            l += 1\\n        else:\\n            answer[r - l] = right * right\\n            r -= 1\\n    return answer\\n```\\nWe first declare a list of length, `len(A)` then add the larger square from the back of the list, denoted by the index `r - l`.\\n\\n**Shorter, terribly unreadable version - 6 lines**\\n```python\\ndef sortedSquares(self, A):\\n    l, r, answer = 0, len(A) - 1, [0] * len(A)\\n    while l <= r:\\n        left, right = abs(A[l]), abs(A[r])\\n        answer[r - l] = max(left, right) ** 2\\n        l, r = l + (left > right), r - (left <= right)\\n    return answer\\n```\\n",
                "solutionTags": [],
                "code": "```python\\ndef sortedSquares(self, A):\\n    answer = collections.deque()\\n    l, r = 0, len(A) - 1\\n    while l <= r:\\n        left, right = abs(A[l]), abs(A[r])\\n        if left > right:\\n            answer.appendleft(left * left)\\n            l += 1\\n        else:\\n            answer.appendleft(right * right)\\n            r -= 1\\n    return list(answer)\\n```\n```python\\ndef sortedSquares(self, A):\\n    answer = [0] * len(A)\\n    l, r = 0, len(A) - 1\\n    while l <= r:\\n        left, right = abs(A[l]), abs(A[r])\\n        if left > right:\\n            answer[r - l] = left * left\\n            l += 1\\n        else:\\n            answer[r - l] = right * right\\n            r -= 1\\n    return answer\\n```\n```python\\ndef sortedSquares(self, A):\\n    l, r, answer = 0, len(A) - 1, [0] * len(A)\\n    while l <= r:\\n        left, right = abs(A[l]), abs(A[r])\\n        answer[r - l] = max(left, right) ** 2\\n        l, r = l + (left > right), r - (left <= right)\\n    return answer\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 973576,
                "title": "a-good-interview-problem-interview-explanation-c",
                "content": "I really like these problems when the right solutions are not that trivial to come by and the solutions actually require some explanation analysis for the advantages and disadvantages.\\n\\nThe obvious/simplest solution would be just using **built in sort** (or code one yourself) and you can say it would work O(NlogN) time / O(1) space. (some python people can say built in works for O(N), but w/e)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& a) {\\n        for (auto &x : a) x *= x;\\n        sort(a.begin(), a.end());\\n        return a;\\n    }\\n};\\n```\\n\\nThe interviewer may easily ask if you could do better time wise ... and well, here, time to think a bit xD\\n\\nOne can do **counting sort** with the constraints of NUM_MAX <= 10^4 are not that big for numbers themselves and scale same as the N <= 10^4 so it would be a good idea. Just need to make every number absolute and count them. O(N) time, O(NUM_MAX <= 10^4) extra space.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& a) {\\n        int j = 0, m = 0;\\n        for (auto &x : a) x = abs(x), m = max(m, x);\\n        vector <int> c(m + 1, 0);\\n        for (auto &x : a) c[x]++; \\n        for (int i = 0; i <= m; i++) \\n            while (c[i]--) \\n                a[j++] = i * i;\\n        return a;\\n    }\\n};\\n```\\n\\n\\nFor people who are here on leetcode for sometime they would come to an idea of two pointers pretty fast, however, with some caveat. \\n\\nFirst why two pointers? Well, after a bit of thinking you may notice that after squaring numbers, all negative numbers are big ... they go down, meet at zero with positive numbers ... and then all those positive numbers are squared. So natural solution of merging two sorted lists from the middle will do. Just use two pointers that go from the middle outwards.\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& a) {\\n        int m = 0, n = a.size(), k = 0;\\n        vector <int> ret(n, 0);\\n        while (m < n && a[m] < 0) m++;\\n        for (auto &x : a) x *= x;\\n        int i = m - 1, j = m;\\n        while (i >= 0 && j < n) {\\n            if (a[i] < a[j]) ret[k++] = a[i--];\\n            else ret[k++] = a[j++];\\n        }\\n        while (i >= 0) ret[k++] = a[i--];\\n        while (j <  n) ret[k++] = a[j++];\\n        return ret;\\n    }\\n};\\n```\\nCleaner implementation of the two pointers is to go from the both ends of the list as the biggest numbers are there and meet in the middle instead. This solution is way nicer to code, but needs a bit of **reverse** thinking ;) \\nO(N) time, O(N) space.\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& a) {\\n        int i = 0, j = a.size() - 1, k = j;\\n        vector <int> ret(k + 1, 0);\\n        while (k >= 0) {\\n            if (abs(a[i]) > abs(a[j])) ret[k--] = a[i] * a[i++];\\n            else ret[k--] = a[j] * a[j--];\\n        }\\n        return ret;\\n    }\\n};\\n```\\n\\nI believe the most important part is to be able to **thoroughly argue**. One must be very thorough in the opinions and not leave anything unanswered as the interviewer will notice some inaccuracies in the explanation right away. It is usually the giveaway if the person has analytical skills to understand problems completely, what those problems would entail, and how different solutions address those problems. \\n\\nTry to argue when would each of the solutions above do great, and when not so great. What if we change contraints (increase, decrease), which solutions would fail, which will thrive? One example is to say that counting sort is actually better when numbers are all NUM_MAX < N, cause that defines extra space and well that would make it a solution that uses less space with the same O(N) time, or if we increase N < 10^7 e.g. \\n\\nI hope that helps everyone to prepare for the coding interview, just give it a thought for every other problem that makes a huge difference :)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sorting",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& a) {\\n        for (auto &x : a) x *= x;\\n        sort(a.begin(), a.end());\\n        return a;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& a) {\\n        int j = 0, m = 0;\\n        for (auto &x : a) x = abs(x), m = max(m, x);\\n        vector <int> c(m + 1, 0);\\n        for (auto &x : a) c[x]++; \\n        for (int i = 0; i <= m; i++) \\n            while (c[i]--) \\n                a[j++] = i * i;\\n        return a;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& a) {\\n        int m = 0, n = a.size(), k = 0;\\n        vector <int> ret(n, 0);\\n        while (m < n && a[m] < 0) m++;\\n        for (auto &x : a) x *= x;\\n        int i = m - 1, j = m;\\n        while (i >= 0 && j < n) {\\n            if (a[i] < a[j]) ret[k++] = a[i--];\\n            else ret[k++] = a[j++];\\n        }\\n        while (i >= 0) ret[k++] = a[i--];\\n        while (j <  n) ret[k++] = a[j++];\\n        return ret;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& a) {\\n        int i = 0, j = a.size() - 1, k = j;\\n        vector <int> ret(k + 1, 0);\\n        while (k >= 0) {\\n            if (abs(a[i]) > abs(a[j])) ret[k--] = a[i] * a[i++];\\n            else ret[k--] = a[j] * a[j--];\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1463098,
                "title": "o-n-detailed-aproach",
                "content": "**Brute Force Approach**\\nSquares of sorted array seems like the easiest problem, if you try to solve it in **O(nlogn) **approach\\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        for(int i = 0;i<nums.length;i++)\\n        {\\n            nums[i] *= nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;\\n    }\\n}\\n```\\n**Optimized Approach**\\nBut if you want to solve the problem in **O(n)** then it needs brainstorming to find the approach.\\nInput: nums = [-7,-3,2,3,11]\\nIf we see the elements with their absolute value then will get to know the element at the start and the last can be the highest value.\\nSo we use this approach to find our solution, by using the two pointer solution\\nTaking one pointer at the start of the array and then another pointer at the last of the array, and then compare these values\\n{7,-3,0,3,9,11}\\nMath.abs(-7) < Math.abs(11)\\n\\n{ , , , ,121} in the resultant array\\n\\nby this we will get the last element of the last array and we can store that value to the resultant array\\n\\nrepeat the same method until left\\u2264right.\\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int left = 0;\\n        int right = nums.length -1;\\n        int index = nums.length- 1;\\n        int result[] = new int [nums.length];\\n        while(left<=right)\\n        {\\n            if(Math.abs(nums[left])>Math.abs(nums[right]))\\n            {\\n                result[index] = nums[left] * nums[left];\\n                left++;\\n            }\\n            else\\n            {\\n                result[index] = nums[right] * nums[right];\\n                right--;\\n            }\\n            index--;\\n        }\\n        return result;\\n    }\\n}``\\n```\\n\\n**DO UPVOTE IF YOU LIKE THE SOLUTION**",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        for(int i = 0;i<nums.length;i++)\\n        {\\n            nums[i] *= nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int left = 0;\\n        int right = nums.length -1;\\n        int index = nums.length- 1;\\n        int result[] = new int [nums.length];\\n        while(left<=right)\\n        {\\n            if(Math.abs(nums[left])>Math.abs(nums[right]))\\n            {\\n                result[index] = nums[left] * nums[left];\\n                left++;\\n            }\\n            else\\n            {\\n                result[index] = nums[right] * nums[right];\\n                right--;\\n            }\\n            index--;\\n        }\\n        return result;\\n    }\\n}``\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283978,
                "title": "python-two-pointers",
                "content": "```\\nclass Solution:\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        result = [None for _ in A]\\n        left, right = 0, len(A) - 1\\n        for index in range(len(A)-1, -1, -1):\\n            if abs(A[left]) > abs(A[right]):\\n                result[index] = A[left] ** 2\\n                left += 1\\n            else:\\n                result[index] = A[right] ** 2\\n                right -= 1\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        result = [None for _ in A]\\n        left, right = 0, len(A) - 1\\n        for index in range(len(A)-1, -1, -1):\\n            if abs(A[left]) > abs(A[right]):\\n                result[index] = A[left] ** 2\\n                left += 1\\n            else:\\n                result[index] = A[right] ** 2\\n                right -= 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 410331,
                "title": "java-o-n-two-pointer-w-comments-beats-100",
                "content": "```java\\npublic int[] sortedSquares(int[] A) {\\n\\t//result array\\n\\tint[] res = new int[A.length];\\n\\t//pointers for left and right\\n\\tint lo = 0; int hi = A.length - 1;\\n\\t//iterate from n to 0\\n\\tfor (int i = A.length - 1; i >= 0; i--) {\\n\\t\\t//check if abs left is less than or equal to abs right\\n\\t\\tif (Math.abs(A[lo]) >= Math.abs(A[hi])) {\\n\\t\\t\\t//add left squared to result array\\n\\t\\t\\tres[i] = A[lo] * A[lo];\\n\\t\\t\\t//increment left pointer\\n\\t\\t\\tlo++;\\n\\t\\t} else {\\n\\t\\t\\t//add right squared to result array\\n\\t\\t\\tres[i] = A[hi] * A[hi];\\n\\t\\t\\t//decrement right pointer\\n\\t\\t\\thi--;\\n\\t\\t}\\n\\t}\\n\\t//result\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```java\\npublic int[] sortedSquares(int[] A) {\\n\\t//result array\\n\\tint[] res = new int[A.length];\\n\\t//pointers for left and right\\n\\tint lo = 0; int hi = A.length - 1;\\n\\t//iterate from n to 0\\n\\tfor (int i = A.length - 1; i >= 0; i--) {\\n\\t\\t//check if abs left is less than or equal to abs right\\n\\t\\tif (Math.abs(A[lo]) >= Math.abs(A[hi])) {\\n\\t\\t\\t//add left squared to result array\\n\\t\\t\\tres[i] = A[lo] * A[lo];\\n\\t\\t\\t//increment left pointer\\n\\t\\t\\tlo++;\\n\\t\\t} else {\\n\\t\\t\\t//add right squared to result array\\n\\t\\t\\tres[i] = A[hi] * A[hi];\\n\\t\\t\\t//decrement right pointer\\n\\t\\t\\thi--;\\n\\t\\t}\\n\\t}\\n\\t//result\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 221924,
                "title": "c-java-4-lines-o-n-inside-out-or-outside-in",
                "content": "We find the first non-negative element in the array. From there, we move \\'negative\\' pointer (```np```) towards zero, and \\'positive\\' pointer (```pp```) towards the end of the array, selecting the next square.\\n```\\nvector<int> sortedSquares(vector<int>& A) {\\n  vector<int> res;\\n  int pvt = lower_bound(begin(A), end(A), 0) - begin(A);\\n  for (int pp = pvt, pn = pvt - 1; pp < A.size() || pn >= 0;) {\\n    if (abs(pn >= 0 ? A[pn] : INT_MAX) < abs(pp < A.size() ? A[pp] : INT_MAX))\\n      res.push_back(pow(A[pn--], 2));\\n    else res.push_back(pow(A[pp++], 2));\\n  }\\n  return res;\\n}\\n```\\nIn a way, we are going *inside out* and filling our result vector from the beginning. Alternativelly, we can go *outside in* and fill the result in the reverse order:\\n```\\nvector<int> sortedSquares(vector<int>& A) {\\n  vector<int> res(A.size());\\n  for (int pn = 0, pp = A.size() - 1, pos = A.size() - 1; pn <= pp; --pos)\\n    res[pos] = pow(abs(A[pn]) < abs(A[pp]) ? A[pp--] : A[pn++], 2);\\n  return res;\\n}  \\n```\\nJava version:\\n```\\npublic int[] sortedSquares(int[] A) {\\n  int[] res = new int[A.length];\\n  for (int pn = 0, pp = A.length - 1, pos = A.length - 1; pn <= pp; --pos)\\n    res[pos] = (int)Math.pow(Math.abs(A[pn]) < Math.abs(A[pp]) ? A[pp--] : A[pn++], 2);\\n  return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```np```\n```pp```\n```\\nvector<int> sortedSquares(vector<int>& A) {\\n  vector<int> res;\\n  int pvt = lower_bound(begin(A), end(A), 0) - begin(A);\\n  for (int pp = pvt, pn = pvt - 1; pp < A.size() || pn >= 0;) {\\n    if (abs(pn >= 0 ? A[pn] : INT_MAX) < abs(pp < A.size() ? A[pp] : INT_MAX))\\n      res.push_back(pow(A[pn--], 2));\\n    else res.push_back(pow(A[pp++], 2));\\n  }\\n  return res;\\n}\\n```\n```\\nvector<int> sortedSquares(vector<int>& A) {\\n  vector<int> res(A.size());\\n  for (int pn = 0, pp = A.size() - 1, pos = A.size() - 1; pn <= pp; --pos)\\n    res[pos] = pow(abs(A[pn]) < abs(A[pp]) ? A[pp--] : A[pn++], 2);\\n  return res;\\n}  \\n```\n```\\npublic int[] sortedSquares(int[] A) {\\n  int[] res = new int[A.length];\\n  for (int pn = 0, pp = A.length - 1, pos = A.length - 1; pn <= pp; --pos)\\n    res[pos] = (int)Math.pow(Math.abs(A[pn]) < Math.abs(A[pp]) ? A[pp--] : A[pn++], 2);\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 285251,
                "title": "javascript-two-pointers-solution",
                "content": "Since we know that the source array is sorted, it is obvious that the largest numbers (by absolute value) are at the edges of the array, gradually decreasing towards the middle. So two pointers technique is ideal here.\\n\\n```\\n/**\\n * @param {number[]} A\\n * @return {number[]}\\n */\\nvar sortedSquares = function(A) {\\n    let result = [];\\n    let l = 0;\\n    let r = A.length - 1;\\n    let p = r;\\n\\n    while (l <= r) {\\n        if (A[l] ** 2 > A[r] ** 2) {\\n            result[p--] = A[l++] ** 2;\\n        } else {\\n            result[p--] = A[r--] ** 2;\\n        }\\n    }\\n    \\n    return result;\\n};\\n```\\nTime complexity: `O(n)`\\nSpace complexity: `O(n)`",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * @param {number[]} A\\n * @return {number[]}\\n */\\nvar sortedSquares = function(A) {\\n    let result = [];\\n    let l = 0;\\n    let r = A.length - 1;\\n    let p = r;\\n\\n    while (l <= r) {\\n        if (A[l] ** 2 > A[r] ** 2) {\\n            result[p--] = A[l++] ** 2;\\n        } else {\\n            result[p--] = A[r--] ** 2;\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1102204,
                "title": "javascript-two-pointers-o-n",
                "content": "```\\nvar sortedSquares = function(nums) {\\n    // use two pointers\\n    // create a new array\\n    const result = new Array(nums.length);\\n    let left = 0, \\n        right = nums.length - 1;\\n    \\n\\t// don\\'t want to rearrange the array, so iterating the array in descending order \\n    for (let i = nums.length - 1; i >= 0; i--) {\\n        if (Math.abs(nums[left]) < Math.abs(nums[right])) {\\n            result[i] = nums[right] ** 2\\n            right--;\\n        } else {\\n            result[i] = nums[left] ** 2\\n            left++;\\n        }\\n    }\\n    \\n    return result;\\n};\\n```\\n\\nRuntime: 96 ms, faster than 99.97% of JavaScript online submissions for Squares of a Sorted Array.\\nMemory Usage: 45.6 MB, less than 21.94% of JavaScript online submissions for Squares of a Sorted Array.\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers",
                    "Iterator"
                ],
                "code": "```\\nvar sortedSquares = function(nums) {\\n    // use two pointers\\n    // create a new array\\n    const result = new Array(nums.length);\\n    let left = 0, \\n        right = nums.length - 1;\\n    \\n\\t// don\\'t want to rearrange the array, so iterating the array in descending order \\n    for (let i = nums.length - 1; i >= 0; i--) {\\n        if (Math.abs(nums[left]) < Math.abs(nums[right])) {\\n            result[i] = nums[right] ** 2\\n            right--;\\n        } else {\\n            result[i] = nums[left] ** 2\\n            left++;\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2672974,
                "title": "js-two-pointers-85-with-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/92e8f912-6d40-492d-8d31-fa705da87411_1665151374.3462088.png)\\n\\nTwo pointers is the use of two different pointers (usually to keep track of array or string indexes) to solve a problem with specified indexes in order to save time and space.\\n\\nIn solving this problem, we alternately compare the values by indexes of pointers, and depending on whether one or another value is greater than another, we shift the pointers until we go through the entire array. To create a new sorted array, we also create an additional index variable so as not to affect the already added (sorted values).\\n\\n![image](https://assets.leetcode.com/users/images/5df0d2ab-6066-4948-90b9-e47ac2c572f0_1665156031.6328247.png)\\n\\n\\n```\\nvar sortedSquares = function(nums) {\\n    let start = 0;\\n    let end = nums.length - 1;\\n    let idx = end;\\n    let sortPowArr = [];\\n\\n    while (idx > -1) {\\n        if (Math.abs(nums[start]) > Math.abs(nums[end])) {\\n            sortPowArr[idx--] = nums[start] * nums[start];\\n            start++;\\n        } else {\\n            sortPowArr[idx--] = nums[end] * nums[end];\\n            end--;\\n        }\\n    }\\n    return sortPowArr;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nvar sortedSquares = function(nums) {\\n    let start = 0;\\n    let end = nums.length - 1;\\n    let idx = end;\\n    let sortPowArr = [];\\n\\n    while (idx > -1) {\\n        if (Math.abs(nums[start]) > Math.abs(nums[end])) {\\n            sortPowArr[idx--] = nums[start] * nums[start];\\n            start++;\\n        } else {\\n            sortPowArr[idx--] = nums[end] * nums[end];\\n            end--;\\n        }\\n    }\\n    return sortPowArr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1759948,
                "title": "c-efficient-two-pointers-tc-o-n-sc-o-n-with-explanation",
                "content": "##### If you understand the approach please please upvote!!!\\uD83D\\uDC4D\\n***Thanks :)***\\n\\n* Since we need to put squeres in result array, we can consider that all numbers are positive\\n* Let\\'s take example with negative and positive numbers, like: `[-4, -2, 0, 1, 3]` => `[4, 2, 0, 1, 3]`\\n* Now, we can have two pointers `low` to left most element, `high` to most right element.\\n* Create `v` result array/vector same size as ` nums `.\\n* Move from right to left in resutl array `v`  whit the help of `k` , and put squares  of` max(abs(nums[low]), abs(nums[high]) ),` move correspondingly`low++` or `high--`\\n\\n*Time Complexity: O (n)\\nSpace Complexity: O (n)*\\n#### C++ code:\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int n=nums.size();\\n        int low=0;\\n        int high=n-1;\\n        \\n        vector<int>v(n);//resutl vector\\n        int k=n-1;//start traversing for the end of v till 0   \\n        \\n        while(low<=high){\\n            if(abs(nums[low]) > abs(nums[high])){\\n                v[k--]=nums[low] * nums[low];\\n                low++;\\n            }else{\\n                v[k--]=nums[high] * nums[high];\\n                high--;\\n            }\\n        }\\n        return v; \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int n=nums.size();\\n        int low=0;\\n        int high=n-1;\\n        \\n        vector<int>v(n);//resutl vector\\n        int k=n-1;//start traversing for the end of v till 0   \\n        \\n        while(low<=high){\\n            if(abs(nums[low]) > abs(nums[high])){\\n                v[k--]=nums[low] * nums[low];\\n                low++;\\n            }else{\\n                v[k--]=nums[high] * nums[high];\\n                high--;\\n            }\\n        }\\n        return v; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336381,
                "title": "one-liner-two-pointer-explanation-python",
                "content": "One Liner:\\nThis is probably what comes first to your mind. Why not just find all squares and sort them. Simple right? But this will give you an `O(n*logn)` solution. Which is good but we can do better than this.\\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        return sorted([num ** 2 for num in nums])\\n```\\n\\nTwo Pointer Solution:\\nWe know our input is always sorted. So the largest squared values are on left and right sides of the input. So we can use 2 pointers `(l, r)` to compared the left and right most values and insert the larger ones to the resultant list.\\nBut when we add larger ones first, we have a list that\\'s in descending order. We want the result to be in ascending order. We can simply reverse the resultant list to get that.\\nThis 2 pointer approach will give us a `O(n)` solutions.\\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        l, r = 0, len(nums) - 1 # Initialise 2 pointers\\n        res = [] # initialise the result list\\n\\n        while l <= r: # continue the loop untill we go through all values, either with left pointer or with right pointer\\n            if abs(nums[l]) > abs(nums[r]):\\n\\t\\t\\t\\t# If the absolute value at left pointer is bigger, we know the square of left value will be bigger than the right one\\n                res.append(nums[l]**2)\\n                l += 1 # increment pointer because we can now look at the next value\\n            else:\\n\\t\\t\\t\\t# If left is not bigger, it\\'s either equal or right value is bigger. In both cases, we can add right value to the result.\\n                res.append(nums[r]**2)\\n                r -= 1 # decrement pointer to go to the previous value\\n        return res[::-1]\\n```\\n\\nMinor optimisation:\\nIn the above algorithm, we reverse the output which is a `O(n)` operation. Which can be avoided by creating a result list of the same length with dummy values (I\\'m taking 0s here but this doesn\\'t actually matter). The thing to keep in mind is that, we\\'re finding the largest values one by one. So we have to fill the result from the right end, or the starting index will be `len(nums) - 1`. We keep decrementing this value as we add more values to the result.\\n\\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        l, r = 0, len(nums) - 1\\n        res = [0] * len(nums) # create a result list with dummy values\\n        i = len(nums) - 1 # index on which we will fill the result\\n\\n        while l <= r:\\n            if abs(nums[l]) > abs(nums[r]):\\n                res[i] = nums[l]**2\\n                l += 1\\n            else:\\n                res[i] = nums[r]**2\\n                r -= 1\\n            i -= 1 # we have filled the result on this index, now we go to the index one lesser than this\\n        return res\\n```\\n\\nPlease upvote if you found this useful!",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        return sorted([num ** 2 for num in nums])\\n```\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        l, r = 0, len(nums) - 1 # Initialise 2 pointers\\n        res = [] # initialise the result list\\n\\n        while l <= r: # continue the loop untill we go through all values, either with left pointer or with right pointer\\n            if abs(nums[l]) > abs(nums[r]):\\n\\t\\t\\t\\t# If the absolute value at left pointer is bigger, we know the square of left value will be bigger than the right one\\n                res.append(nums[l]**2)\\n                l += 1 # increment pointer because we can now look at the next value\\n            else:\\n\\t\\t\\t\\t# If left is not bigger, it\\'s either equal or right value is bigger. In both cases, we can add right value to the result.\\n                res.append(nums[r]**2)\\n                r -= 1 # decrement pointer to go to the previous value\\n        return res[::-1]\\n```\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        l, r = 0, len(nums) - 1\\n        res = [0] * len(nums) # create a result list with dummy values\\n        i = len(nums) - 1 # index on which we will fill the result\\n\\n        while l <= r:\\n            if abs(nums[l]) > abs(nums[r]):\\n                res[i] = nums[l]**2\\n                l += 1\\n            else:\\n                res[i] = nums[r]**2\\n                r -= 1\\n            i -= 1 # we have filled the result on this index, now we go to the index one lesser than this\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1181063,
                "title": "java-clean-concise-code-two-pointer-technique-100-optimal-faster-solution",
                "content": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        \\n        int[] answer = new int[nums.length];\\n        int i = 0, j = nums.length - 1, k = nums.length - 1;\\n        \\n        while (k >= 0) {\\n            if (Math.abs (nums[i]) > Math.abs (nums[j])) {\\n                answer[k--] = nums[i] * nums[i++];\\n            }\\n            else {\\n                answer[k--] = nums[j] * nums[j--];\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n\\n**LOVE CODING :)\\nHAPPY CODING :)\\nHAPPY LEARNING :)**",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        \\n        int[] answer = new int[nums.length];\\n        int i = 0, j = nums.length - 1, k = nums.length - 1;\\n        \\n        while (k >= 0) {\\n            if (Math.abs (nums[i]) > Math.abs (nums[j])) {\\n                answer[k--] = nums[i] * nums[i++];\\n            }\\n            else {\\n                answer[k--] = nums[j] * nums[j--];\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3110139,
                "title": "beats-100-c-two-pinter-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIdea is array is already sorted so no need to first take all the elemnts and then sort and also making tc  nlogn either we will do two pointer appraoch and check absolute value form start and last where they can be placed .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTwo Pointer Appraoch :\\n- Keep two pinters and check if (magnitude wise i,e take abs) $$arr[i]>arr[j] $$push $$arr[i]^2 $$else push $$arr[j]^2$$\\n# Complexity\\n- Time complexity:$$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int>ans(n);\\n        int i=0,j=n-1,k=n-1;\\n        while(i<=j){\\n            if(abs(arr[i])>abs(arr[j])){\\n                ans[k--]=(arr[i]*arr[i]),i++;\\n            }\\n            else ans[k--]=(arr[j]*arr[j]),j--;\\n        }\\n        //reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int>ans(n);\\n        int i=0,j=n-1,k=n-1;\\n        while(i<=j){\\n            if(abs(arr[i])>abs(arr[j])){\\n                ans[k--]=(arr[i]*arr[i]),i++;\\n            }\\n            else ans[k--]=(arr[j]*arr[j]),j--;\\n        }\\n        //reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 251088,
                "title": "c-solution",
                "content": "```C\\nint *sortedSquares(int *A, int ASize, int *returnSize) {\\n    int *result = malloc(sizeof(int) * (*returnSize = ASize)), *p = A, *q = A + ASize - 1;\\n    int index = ASize - 1;\\n    while (p <= q) {\\n        *p = *p > 0 ? *p : *p * -1;\\n        *q = *q > 0 ? *q : *q * -1;\\n        if (*p >= *q) {\\n            result[index--] = *p * (*p);\\n            p++;\\n        } else {\\n            result[index--] = *q * (*q);\\n            q--;\\n        }\\n    }\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C\\nint *sortedSquares(int *A, int ASize, int *returnSize) {\\n    int *result = malloc(sizeof(int) * (*returnSize = ASize)), *p = A, *q = A + ASize - 1;\\n    int index = ASize - 1;\\n    while (p <= q) {\\n        *p = *p > 0 ? *p : *p * -1;\\n        *q = *q > 0 ? *q : *q * -1;\\n        if (*p >= *q) {\\n            result[index--] = *p * (*p);\\n            p++;\\n        } else {\\n            result[index--] = *q * (*q);\\n            q--;\\n        }\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3189378,
                "title": "python-two-pointer-clean-simple-o-n-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere, We are having many solutions but here i am showing you just 2. \\n1. We are having a **Two Pointer** approach which should work well.\\n    - Here we had one pointer $$i$$ at $$start$$ index, second pointer $$j$$ at $$end$$ index , a list $$ans$$ of size n, and a $$k$$ pointer to update value in $$ans$$ list.\\n    - Then, we start comapring absolute value in nums where pointers are pointing.\\n    - ` if abs(nums[l]) > nums[r]:`\\n    - So, we update value at $$k$$ position in ans with ` nums[l] * nums[l]`.\\n    - ` else:`\\n    - Update value at $$k$$ position in ans with ` nums[r] * nums[r]`.\\n2. **List Comprehension + Sorting:** \\n    - Here, we are making a list with square of nums using list comprehension and making it sort and directly returning it.\\n\\n# Code\\n## 1. Two Pointer Approach :\\n\\n### Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        \\n        # Two Pointer Approach\\n        n = len(nums)\\n        l, r = 0, n - 1\\n        k = n - 1\\n        ans = [0] * n\\n        while k >= 0:\\n            if abs(nums[l]) > nums[r]:\\n                ans[k] = nums[l] * nums[l]\\n                l += 1\\n            else:\\n                ans[k] = nums[r] * nums[r]\\n                r -= 1\\n            k -= 1\\n        return ans\\n\\n```\\n## 2. List Comprehension + Sorting :\\n\\n### Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        \\n        # One Liner\\n        return sorted([num * num for num in nums])\\n        \\n```\\n- Here I personally felt **List Comprehension + Sorting** isn\\'t fast but this approach give me fast runtime in submission.\\n- So, don\\'t know what\\'s wrong with leetcode runtime checking algorithm.\\n- If anyone have suggestion please comment it.\\n- If you found it helpful please upvote, it helps to create such a more content.",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        \\n        # Two Pointer Approach\\n        n = len(nums)\\n        l, r = 0, n - 1\\n        k = n - 1\\n        ans = [0] * n\\n        while k >= 0:\\n            if abs(nums[l]) > nums[r]:\\n                ans[k] = nums[l] * nums[l]\\n                l += 1\\n            else:\\n                ans[k] = nums[r] * nums[r]\\n                r -= 1\\n            k -= 1\\n        return ans\\n\\n```\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        \\n        # One Liner\\n        return sorted([num * num for num in nums])\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2943161,
                "title": "full-description-on-how-to-solve-using-two-pointers-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will use two pointers approach to solve this problem. The given array is **sorted** means the **square** of the elements present at either the **leftmost side** and the **rightmost side** is the greatest.\\n\\nExample:-\\n$$nums = [-14,-1,0,3,10]$$ \\nSquare of -14 is the greatest of all sqaures.\\n\\n$$nums = [-7,-3,2,3,11]$$\\nSquare of 11 is the greatest of all sqaures, followed by square of -7.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe have taken two pointers: `left` and `right`.\\n\\n`left` initially points to first element of the given array whereas `right` points to last element of the given array.\\n\\nNow,lets run a `while()`loop with the condition`left<=right`. The condition means that we will perform particular operations till `left` pointer is either before, or at the same position as the `right` pointer.\\n\\ni.e.: \\n![My First Board.jpg](https://assets.leetcode.com/users/images/f2e94a4b-3268-4299-98b3-dff8d7e2550f_1671818204.6543193.jpeg)\\n\\n*left pointer cannot go ahead of right pointer but both can be at same position therefore \\'=\\' sign is also used in the condition.*\\n\\n---\\n\\nNow, lets understand the body of the while loop, which is the main algorithm of our code.\\n\\n**Firstly :-** We compare the abs values pointed by the `left` and `right` pointers and store it in the `max` variable. We will use ternary operator for this task. \\n\\n***Moving the pointers***\\n We also need to move the pointers so we check which pointer\\'s value `max` is storing. So we use an `if()`loop here with the condition `max==nums[right]`, if the condition is *true*, it means abs value pointed by `right` is greater than the abs value pointed by `left`, so we move right pointer by one position i.e., `right--`. If the condition is false, we move the left pointer.\\n\\n**Lastly :-** We store the square of the greater value i.e., `max*max` and store it in `ans[k]`. `K` is a variable used for the resultant array, initially pointing to last index of the `ans`. After storing the value, we decrement the value of k.\\n\\n---\\n\\n\\n\\n\\n\\n**Variables and their use in the code:**\\n- `left` : left pointer, initial value = 0, points to 1st element of the array.\\n- `right`: right pointer, initial value = `nums.length-1` i.e., points to the last value of the array.\\n- `k`: used to store values in the new array `ans`. Initial value of `nums.length-1` i.e. points to last position in the resultant array as we will eneter elements from right to left.\\n- `max`: used to store the greater of the two number pointed by `left` and `right`.\\n\\n**Java Code**\\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int left=0, right=nums.length-1;\\n        int ans[]= new int[nums.length];\\n        int k=nums.length-1;\\n        while(left<=right){\\n            int max=(Math.abs(nums[left])<Math.abs(nums[right])? nums[right]: nums[left]);\\n            if(max==nums[right])\\n                right--;\\n                else \\n                    left++;\\n            ans[k]=max*max;\\n            k--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int left=0, right=nums.length-1;\\n        int ans[]= new int[nums.length];\\n        int k=nums.length-1;\\n        while(left<=right){\\n            int max=(Math.abs(nums[left])<Math.abs(nums[right])? nums[right]: nums[left]);\\n            if(max==nums[right])\\n                right--;\\n                else \\n                    left++;\\n            ans[k]=max*max;\\n            k--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783139,
                "title": "c-concise-o-n-solution",
                "content": "C# doesn\\'t get enough love here, but here\\'s a fairly simple/intuitive example of a concise one pass solution using C#\\n\\n```\\n    public int[] SortedSquares(int[] nums) {\\n        var arr = new int[nums.Length];\\n        int begIndex = 0;\\n        int endIndex = nums.Length-1;\\n        int end = endIndex;\\n        while (begIndex <= endIndex)\\n            arr[end--] = Math.Abs(nums[endIndex]) > Math.Abs(nums[begIndex])\\n                ? nums[endIndex] * nums[endIndex--]\\n                : nums[begIndex] * nums[begIndex++];\\n        return arr;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "C#"
                ],
                "code": "```\\n    public int[] SortedSquares(int[] nums) {\\n        var arr = new int[nums.Length];\\n        int begIndex = 0;\\n        int endIndex = nums.Length-1;\\n        int end = endIndex;\\n        while (begIndex <= endIndex)\\n            arr[end--] = Math.Abs(nums[endIndex]) > Math.Abs(nums[begIndex])\\n                ? nums[endIndex] * nums[endIndex--]\\n                : nums[begIndex] * nums[begIndex++];\\n        return arr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1467196,
                "title": "intuition-java-two-pointer-plots-visualization",
                "content": "**If you guys are thinking about the intuition behind this two pointer algorithm , This article is for you!!**\\n\\nConsider , \\nInput:  nums = [-4,-1,0,3,10]\\nafter squaring we will get [16,1,0,9,100]\\nif we plot this points as (0,16), (1,1), (2,0), (3,9), (4,100)\\nwe will get the following plots\\n![image](https://assets.leetcode.com/users/images/d4dd8182-3262-4df3-aa1e-571c7386451f_1631786175.9753773.png)\\nOur goal is to find squares of sorted array , So by seeing the plot we can make out the maximum value is 100. Here, max value is on extreme right.\\n\\nNow, we can similarly think about these two plots\\n\\n![image](https://assets.leetcode.com/users/images/c4528640-9431-4a9a-95d3-aac7586ef67c_1631786259.1755123.png)\\n Here, max value is on extreme left.\\n \\n![image](https://assets.leetcode.com/users/images/2820deda-263c-4f87-9455-c27b6679285d_1631786303.2714875.png)\\n Here, max value is present on extreme left as well as extreme right.\\n \\n \\n Till here, we have understood that to get max value in entire array we have to check for extreme left and right, hence we fill our answer array in reverse manner.\\n So we keep two pointers at extreme ends and check which square is greatest among them and finally place it in answer array, similarly we will do for all elements.\\n \\n \\n \\n ```\\n \\n public int[] sortedSquares(int[] nums) {\\n        \\n        int i = 0; //pointer at extreme left\\n        int j = nums.length-1;//pointer at extreme right\\n        int k = nums.length-1;//used for filling answer array in reverse\\n        \\n        int[]ans = new int[nums.length];\\n        \\n        while(i<=j)\\n        {\\n            int v1 = nums[i];\\n            int v2 = nums[j];\\n            int sq1 = v1*v1;\\n            int sq2 = v2*v2;\\n            if( sq1 < sq2)\\n            {\\n                ans[k--] = sq2;\\n                j--;\\n            }\\n            else\\n            {\\n                ans[k--] = sq1;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n ```\\n \\n \\n Time Complexity: O(N)\\n Auxillary Space: O(1) \\n\\n**NOTE : since the function itself is expecting from us to return answer in an array , it is not considered in auxiliary space.**\\n\\n\\n# YOU ALL CAN BUY ME A COFFEE AT \\uD83D\\uDC47\\n https://www.buymeacoffee.com/deepakgupta",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n \\n public int[] sortedSquares(int[] nums) {\\n        \\n        int i = 0; //pointer at extreme left\\n        int j = nums.length-1;//pointer at extreme right\\n        int k = nums.length-1;//used for filling answer array in reverse\\n        \\n        int[]ans = new int[nums.length];\\n        \\n        while(i<=j)\\n        {\\n            int v1 = nums[i];\\n            int v2 = nums[j];\\n            int sq1 = v1*v1;\\n            int sq2 = v2*v2;\\n            if( sq1 < sq2)\\n            {\\n                ans[k--] = sq2;\\n                j--;\\n            }\\n            else\\n            {\\n                ans[k--] = sq1;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1477544,
                "title": "go-o-n-solution-with-explanation",
                "content": "**Explanation - Code at bottom**\\nWe know that a non-decreasing array means that the numbers will be sorted from the smallest to the largest - with the lowest negative number on the far left, and the greatest positive number on the far right.\\n\\nTake a look at example 1 from the problem: nums = [-4, -1, 0, 3, 10].\\n\\nLet\\'s explore those numbers in the array to see if we can identify a pattern. \\n\\nIf we square every number in the list we arrive at [16, 1, 0, 9, 100]. We can see that squared negative numbers results in a positive integer - so whether we square the negatives or we square the absolute values, we arrive at the same result.\\n\\nSquaring the absolute values [4, 1, 0, 3, 10] gives us a new array of [16, 1, 0, 9, 100].\\nSquaring the negative values [-4, -1, 0, 3, 10] gives us a new array of [16, 1, 0, 9, 100]\\n\\nAgain, because the given array is in non-decreasing order we know that the largest value will always be either the absolute value of the first number of the given array or the absolute value of the last number of the given array.\\n\\nKnowing this, we can start off by comparing the absolute values of the first and last indices of the given array to determine which is larger. We can then append the largest of the two to the last index of our new array.\\n\\nSo, is the absolute value of -4 less than the absolute value of 10? Yes, because 16 is less than 100. So we can add the square of 10 to the last index in our new array.\\n\\n[null, null, null, null, 100]\\n\\nNow that we have added the last index of the given array, we can ignore that index from here on out. \\n\\n[-4, -1, 0, 3]\\n\\nThe largest absolute value on the right is now 3. Let\\'s compare the squared absolute value of 3 to the outermost index on the left - again, this is -4.\\n\\n(abs(-4))^2 = 16\\n(abs(93))^2 = 9\\n\\n16 is greater than 9, so the next number to be added to our new array is 16.\\n\\n[null, null, null, 16, 100]\\n\\nWe now ignore the initial first index, as it\\'s square has already been placed in our new array, and focus on the remaining given array. \\n\\n[-1, 0, 3]\\n\\nAgain, we know the next largest squared number will come from one of the two outside numbers. So let\\'s find it.\\n\\n(abs(-1))^2 = 1\\n(abs(3))^2 = 9\\n\\n9 is greater than 1 so let\\'s add it to our new array.\\n\\n[null, null, 9, 16, 100]\\n\\nThat means our given array is now\\n\\n[-1, 0]\\n\\nAgain, we are going to compare the left-most and right-most indices.\\n\\n(abs(-1))^2 = 1\\n(abs(0))^2 - 0\\n\\n1 is greater than 0 so let\\'s add it to our new array.\\n\\n[null, 1, 9, 16, 100]\\n\\nWe have one remaining index from our given array so let\\'s add it.\\n\\n[0, 1, 9, 16, 100]\\n\\nWe have taken each index from the given array, squared it, then placed it sorted within a new array.\\n\\n*Of note, we can square the numbers before or after the comparison and get the same result.*\\n\\nabsolute(-4) < absolute(10) and (absolute(-4))^2 < (absolute(10))^2\\n\\n**Let\\'s code this algorithm in Go.**\\n\\nStart by getting the length of whatever the input array is.\\n\\n`n := len(nums)`\\n\\nNext, create our new slice, of type int and size n, that will contain the sorted squares. We can call it result. \\n\\n`result := make([]int, n)`\\n\\nWe can now create our left and right pointers.\\n\\n`left, right := 0, n - 1`\\n\\n*Note: We are using n - 1 here because there are n items in the array, starting at 1, but the index always starts with 0. So the final index of the array is n - 1.*\\n\\nWe can now start filling in our new array from the last index to the start. So, from n - 1 to 0.\\n\\nLet\\'s declare a square variable.\\n\\n`square := 0`\\n\\nNow we need to compare the absolute values. We can use the math package, but I will just create our own function that returns the absolute value:\\n\\n```\\n// function to get the absolute value\\nfunc Abs(x int) int {\\n    if x < 0 {\\n        return -x\\n    }\\n    \\n    return x\\n}\\n```\\n\\nWithin our for loop iterating over our new slice in reverse, let\\'s compare the absolute values of each pointer and set square to the largest one and adjust the pointer at that value.\\n\\n```\\nfor i := n - 1; i >= 0; i-- {\\n        square := 0\\n        \\n        if Abs(nums[left]) < Abs(nums[right]) {\\n            square = nums[right]\\n            right--\\n        } else {\\n            square = nums[left]\\n            left ++\\n        }\\n    }\\n```\\n\\n**Here is the final code with comments:**\\n\\n```\\n// function to get the absolute value\\nfunc Abs(x int) int {\\n    if x < 0 {\\n        return -x\\n    }\\n    \\n    return x\\n}\\n\\n// main function to get the sorted squares array\\nfunc sortedSquares(nums []int) []int {\\n    \\n    n := len(nums) // get the length of the given array\\n    result := make([]int, n) // create a new slice of type int that can hold n values\\n    \\n    // left and right pointers\\n    left, right := 0, n - 1\\n    \\n    // iterate through our new slice (result) in reverse as we will be adding numbers from largest to smallest\\n    for i := n - 1; i >= 0; i-- {\\n        square := 0 // the variable that will store the largest absolute value of the two pointers\\n        \\n        // if the absolute value of the left pointer is less than the absolute value of the right pointer, \\n        // set square to the larger number from the right pointer and move the right pointer one left.\\n        // Else set square to the larger number from the left pointer and move the left pointer one right.\\n        if Abs(nums[left]) < Abs(nums[right]) {\\n            square = nums[right]\\n            right--\\n        } else {\\n            square = nums[left]\\n            left ++\\n        }\\n        \\n        // square the value and add it to the appropriate index\\n        result[i] = square * square\\n    }\\n    \\n    // return the sorted array with the squared values\\n    return result\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Two Pointers"
                ],
                "code": "```\\n// function to get the absolute value\\nfunc Abs(x int) int {\\n    if x < 0 {\\n        return -x\\n    }\\n    \\n    return x\\n}\\n```\n```\\nfor i := n - 1; i >= 0; i-- {\\n        square := 0\\n        \\n        if Abs(nums[left]) < Abs(nums[right]) {\\n            square = nums[right]\\n            right--\\n        } else {\\n            square = nums[left]\\n            left ++\\n        }\\n    }\\n```\n```\\n// function to get the absolute value\\nfunc Abs(x int) int {\\n    if x < 0 {\\n        return -x\\n    }\\n    \\n    return x\\n}\\n\\n// main function to get the sorted squares array\\nfunc sortedSquares(nums []int) []int {\\n    \\n    n := len(nums) // get the length of the given array\\n    result := make([]int, n) // create a new slice of type int that can hold n values\\n    \\n    // left and right pointers\\n    left, right := 0, n - 1\\n    \\n    // iterate through our new slice (result) in reverse as we will be adding numbers from largest to smallest\\n    for i := n - 1; i >= 0; i-- {\\n        square := 0 // the variable that will store the largest absolute value of the two pointers\\n        \\n        // if the absolute value of the left pointer is less than the absolute value of the right pointer, \\n        // set square to the larger number from the right pointer and move the right pointer one left.\\n        // Else set square to the larger number from the left pointer and move the left pointer one right.\\n        if Abs(nums[left]) < Abs(nums[right]) {\\n            square = nums[right]\\n            right--\\n        } else {\\n            square = nums[left]\\n            left ++\\n        }\\n        \\n        // square the value and add it to the appropriate index\\n        result[i] = square * square\\n    }\\n    \\n    // return the sorted array with the squared values\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2748647,
                "title": "java-runtime-1ms-faster-than-100-memory-usage-less-than-95-87",
                "content": "```\\nclass Solution {\\n    public  int[] sortedSquares(int[] nums) {\\n        int length = nums.length;\\n        if (length == 0) return new int[0];\\n        \\n        int[] result = new int[length];\\n        int l = 0, r = length - 1;\\n        for (int i = length - 1; i >= 0; i--) {\\n            int start = nums[l] * nums[l];\\n            int end = nums[r] * nums[r];\\n            if (start > end) {\\n                result[i] = start;\\n                l++;\\n            } else {\\n                result[i] = end;\\n                r--;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/55988ba5-1e00-4f70-9aff-5b34e26e9cbe_1666863577.579867.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public  int[] sortedSquares(int[] nums) {\\n        int length = nums.length;\\n        if (length == 0) return new int[0];\\n        \\n        int[] result = new int[length];\\n        int l = 0, r = length - 1;\\n        for (int i = length - 1; i >= 0; i--) {\\n            int start = nums[l] * nums[l];\\n            int end = nums[r] * nums[r];\\n            if (start > end) {\\n                result[i] = start;\\n                l++;\\n            } else {\\n                result[i] = end;\\n                r--;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 302304,
                "title": "js-faster-than-99-simple-solution",
                "content": "```\\nvar sortedSquares = function(A) {\\n  const result = [];\\n  let head = 0;\\n  let tail = A.length - 1;\\n\\n  while (head <= tail) {\\n    if (A[head] ** 2 > A[tail] ** 2) result.push(A[head++] ** 2);\\n    else result.push(A[tail--] ** 2);\\n  }\\n\\n  return result.reverse();\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nvar sortedSquares = function(A) {\\n  const result = [];\\n  let head = 0;\\n  let tail = A.length - 1;\\n\\n  while (head <= tail) {\\n    if (A[head] ** 2 > A[tail] ** 2) result.push(A[head++] ** 2);\\n    else result.push(A[tail--] ** 2);\\n  }\\n\\n  return result.reverse();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 243791,
                "title": "java-1-line-solution-using-streams",
                "content": "Java one liner\\n```\\nreturn Arrays.stream(A).map(a -> a*a).sorted().toArray();\\n```",
                "solutionTags": [],
                "code": "```\\nreturn Arrays.stream(A).map(a -> a*a).sorted().toArray();\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1666085,
                "title": "c-easy-solution-with-explanations",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Simple approach: convert squares of every elements & then sort them.\\n- **Time complexity:** O(nlogn).\\n\\n### Solution 02\\n\\n- 2 pointer approach.\\n- Take a separate array of size n.\\n- Take 2 pointers: l & r.\\n- Compare square of l & r indexed elements & put the max element to last of ans array.\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int n= nums.size();\\n        for(int i=0; i<n; i++){\\n            nums[i] = nums[i]*nums[i];\\n        }\\n        sort(nums.begin(), nums.end());\\n        return nums;\\n    }\\n};**\\n\\n//Solution 02:\\n**class Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int n=nums.size()-1;\\n        int l=0, r=n;\\n        vector<int> ans(nums.begin(), nums.end());\\n        \\n        while(n>=0){\\n            if(nums[l]*nums[l] > nums[r]*nums[r]){\\n                ans[n] = nums[l]*nums[l];\\n                l++; n--;\\n            }\\n            else{\\n                ans[n] = nums[r]*nums[r];\\n                r--; n--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};**\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int n= nums.size();\\n        for(int i=0; i<n; i++){\\n            nums[i] = nums[i]*nums[i];\\n        }\\n        sort(nums.begin(), nums.end());\\n        return nums;\\n    }\\n};**\\n\\n//Solution 02:\\n**class Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int n=nums.size()-1;\\n        int l=0, r=n;\\n        vector<int> ans(nums.begin(), nums.end());\\n        \\n        while(n>=0){\\n            if(nums[l]*nums[l] > nums[r]*nums[r]){\\n                ans[n] = nums[l]*nums[l];\\n                l++; n--;\\n            }\\n            else{\\n                ans[n] = nums[r]*nums[r];\\n                r--; n--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461322,
                "title": "python-one-line-solution",
                "content": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        return sorted([i * i for i in nums])\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        return sorted([i * i for i in nums])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1299085,
                "title": "3-solutions-2-pointer-and-sort-explained",
                "content": "**Solution 1**\\n- uses 2 pointers. \\n- **Start both pointers from opposite directions**. When working with sorted arrays, ask yourself it makes sense to start pointers from opposite ends. In this problem, starting from opposite ends is a good strategy. This visualization may help. \\n![image](https://assets.leetcode.com/users/images/a93e2573-233a-4e5e-85bf-98eb792f854e_1624738522.3515596.png)\\n- If we start from opposite ends, we know that both ends will give us the respective highest squares, especially when working with negative numbers.\\n- Next, we make a comparison, and grab the highest value and insert it into the results array.\\n\\n```\\n[-4, -3,  0, 3, 5]\\n```\\n\\neven if we don\\'t have negative numbers this strategy works nicely.\\n\\n```\\n[ 0, 3, 5, 7]\\n```\\n\\n```\\nvar sortedSquares = function (nums) {\\n    const results = new Array(nums.length);\\n    let left_idx = 0;\\n    let right_idx = nums.length-1;\\n    let next_highest_square_index = nums.length-1; // keep track where our next insert position will be in the results array\\n\\n    while(left_idx <= right_idx){\\n        const left_el = Math.pow(nums[left_idx],2)\\n        const right_el = Math.pow(nums[right_idx],2)\\n        if(left_el > right_el){\\n            results[next_highest_square_index] = left_el\\n            next_highest_square_index -=1;\\n            left_idx +=1\\n        }\\n        else {\\n            results[next_highest_square_index] = right_el;\\n\\t\\t\\tnext_highest_square_index -= 1;\\n            right_idx -= 1\\n        }\\n    }\\n    return results\\n};\\n```\\n\\n\\n**Solution 2**\\n- 2 pointer, start pointers close to each other\\n- start right index at the first positive number index\\n- start left index and the first positive number index - 1;\\n![image](https://assets.leetcode.com/users/images/4b11ad63-5b29-4c86-b289-4fe7d637925d_1624739338.4962318.png)\\n\\nSolution 2, requires **aloooot of edge case handling**, so the first solution is definetly better, I think. Again, with sorted inputs, its always good idea to ask yourself if starting pointers from the opposite direction is better/simpler\\n\\n\\n**Solution 3 (brute force)**\\n- loop over each element, square it. Before returning sort the list\\n- downside, compared to solution 1 is that we are sorting which adds `n log n` complexity \\n\\n```\\nvar sortedSquares = function(nums) {\\n    return nums\\n            .map(num => Math.pow(num, 2))\\n            .sort((a,b) => a-b); // sort ascending\\n};\\n```\\n\\n\\nAdditonal resource readings\\n- https://emre.me/coding-patterns/two-pointers/",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\n[-4, -3,  0, 3, 5]\\n```\n```\\n[ 0, 3, 5, 7]\\n```\n```\\nvar sortedSquares = function (nums) {\\n    const results = new Array(nums.length);\\n    let left_idx = 0;\\n    let right_idx = nums.length-1;\\n    let next_highest_square_index = nums.length-1; // keep track where our next insert position will be in the results array\\n\\n    while(left_idx <= right_idx){\\n        const left_el = Math.pow(nums[left_idx],2)\\n        const right_el = Math.pow(nums[right_idx],2)\\n        if(left_el > right_el){\\n            results[next_highest_square_index] = left_el\\n            next_highest_square_index -=1;\\n            left_idx +=1\\n        }\\n        else {\\n            results[next_highest_square_index] = right_el;\\n\\t\\t\\tnext_highest_square_index -= 1;\\n            right_idx -= 1\\n        }\\n    }\\n    return results\\n};\\n```\n```\\nvar sortedSquares = function(nums) {\\n    return nums\\n            .map(num => Math.pow(num, 2))\\n            .sort((a,b) => a-b); // sort ascending\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 514315,
                "title": "javascript-two-pointers-o-n-solution",
                "content": "```javascript\\n/**\\n * @param {number[]} A\\n * @return {number[]}\\n */\\nvar sortedSquares = function(A) {\\n  const res = [];\\n  let i = 0;\\n  while (A[i] < 0) i++;\\n  let j = i - 1;\\n  while (j >= 0 || i < A.length) {\\n    if (i >= A.length || -A[j] <= A[i]) {\\n      res.push(A[j--] ** 2);\\n    } else {\\n      res.push(A[i++] ** 2);\\n    }\\n  }\\n  return res;\\n};\\n```\\n\\n* 132/132 cases passed (92 ms)\\n* Your runtime beats 99.09 % of javascript submissions\\n* Your memory usage beats 88.89 % of javascript submissions (42.6 MB)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} A\\n * @return {number[]}\\n */\\nvar sortedSquares = function(A) {\\n  const res = [];\\n  let i = 0;\\n  while (A[i] < 0) i++;\\n  let j = i - 1;\\n  while (j >= 0 || i < A.length) {\\n    if (i >= A.length || -A[j] <= A[i]) {\\n      res.push(A[j--] ** 2);\\n    } else {\\n      res.push(A[i++] ** 2);\\n    }\\n  }\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1873182,
                "title": "c-easy-solution-100-o-n",
                "content": "```\\nint* sortedSquares(int* nums, int numsSize, int* returnSize)\\n{\\n    int *res = malloc(sizeof(nums[0]) * numsSize);\\n    int start = 0;\\n    int end = numsSize - 1;\\n    for (int i = numsSize - 1; start <= end; i--) {\\n        int a = nums[start] * nums[start];\\n        int b = nums[end] * nums[end];\\n        if (a > b) {\\n            res[i] = a;\\n            start++;\\n        } else {\\n            res[i] = b;\\n            end--;\\n        }\\n    }\\n    *returnSize = numsSize;\\n    return res;\\n}\\n```\\n\\n**If this was helpful, don\\'t hesitate to upvote! :)**\\nHave a nice day!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint* sortedSquares(int* nums, int numsSize, int* returnSize)\\n{\\n    int *res = malloc(sizeof(nums[0]) * numsSize);\\n    int start = 0;\\n    int end = numsSize - 1;\\n    for (int i = numsSize - 1; start <= end; i--) {\\n        int a = nums[start] * nums[start];\\n        int b = nums[end] * nums[end];\\n        if (a > b) {\\n            res[i] = a;\\n            start++;\\n        } else {\\n            res[i] = b;\\n            end--;\\n        }\\n    }\\n    *returnSize = numsSize;\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1419437,
                "title": "python-two-pointers-solution-o-n",
                "content": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        \\n        i = 0\\n        n = len(nums)\\n        j = n - 1\\n        \\n        new = [0] * n\\n        k = n - 1\\n        \\n        while i <= j:\\n            if abs(nums[i]) < abs(nums[j]):\\n                new[k] = nums[j] ** 2\\n                j -= 1\\n                \\n            else:\\n                new[k] = nums[i] ** 2\\n                i += 1\\n            k -= 1\\n            \\n        return new",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        \\n        i = 0\\n        n = len(nums)\\n        j = n - 1\\n        \\n        new = [0] * n\\n        k = n - 1\\n        \\n        while i <= j:\\n            if abs(nums[i]) < abs(nums[j]):\\n                new[k] = nums[j] ** 2\\n                j -= 1\\n                \\n            else:\\n                new[k] = nums[i] ** 2\\n                i += 1\\n            k -= 1\\n            \\n        return new",
                "codeTag": "Java"
            },
            {
                "id": 2230684,
                "title": "simple-o-n-solution-not-o-nlogn",
                "content": "```\\n   vector<int> sortedSquares(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        int l = 0 , r = n-1;\\n        for(int i = n-1 ; i>=0 ; i--){\\n            if(abs(nums[l]) > abs(nums[r])){\\n                \\n            \\n                ans[i] = nums[l]*nums[l];\\n                l++;\\n            }\\n            else{\\n                ans[i] = nums[r]*nums[r];\\n                r--;\\n            }\\n        }\\n        return ans;   \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n   vector<int> sortedSquares(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        int l = 0 , r = n-1;\\n        for(int i = n-1 ; i>=0 ; i--){\\n            if(abs(nums[l]) > abs(nums[r])){\\n                \\n            \\n                ans[i] = nums[l]*nums[l];\\n                l++;\\n            }\\n            else{\\n                ans[i] = nums[r]*nums[r];\\n                r--;\\n            }\\n        }\\n        return ans;   \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 764051,
                "title": "c-o-n-sol",
                "content": "```\\nint* sortedSquares(int* A, int ASize, int* returnSize){\\n    int* arr = malloc(sizeof(int)*ASize);\\n    *returnSize = ASize;\\n    int end = ASize-1, start = 0, ptr = ASize-1;\\n    while ((start <= end) && (ptr>=0))\\n    {\\n        if (pow(A[end],2) >= pow(A[start],2))\\n        {\\n            arr[ptr] = pow(A[end--],2);\\n        }\\n        else\\n        {\\n            arr[ptr] = pow(A[start++],2);\\n        }\\n        ptr--;\\n    }\\n    return arr;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint* sortedSquares(int* A, int ASize, int* returnSize){\\n    int* arr = malloc(sizeof(int)*ASize);\\n    *returnSize = ASize;\\n    int end = ASize-1, start = 0, ptr = ASize-1;\\n    while ((start <= end) && (ptr>=0))\\n    {\\n        if (pow(A[end],2) >= pow(A[start],2))\\n        {\\n            arr[ptr] = pow(A[end--],2);\\n        }\\n        else\\n        {\\n            arr[ptr] = pow(A[start++],2);\\n        }\\n        ptr--;\\n    }\\n    return arr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 410492,
                "title": "c-with-two-indices-explained",
                "content": "So at first we look at sorting as nlogn and we know we need to have this solution, \\nthe naive solution here is just multiply everything and sort again.\\n\\nlet\\'s try better than that.\\n\\nwe need to understand that the only thing we know of absolute value is the fact is says how far are we from zero. meaning if we compare two numbers in their absulote values we know which one is bigger, so when we will raise them by power of 2 they will be positives as well. \\nso this is the main idea here how do we utilize Math.Abs in order to sort our array.\\n\\nso the tricky part is to understand how to fill the array. well ...\\n\\nso we need to understand which Math.Abs is bigger in order to put it....last...\\nbecause we are sorting.\\n\\nwho can be the biggest? the last value or the first value (which is negative in the example.)\\n\\nso we have start and end index and we compare \\nMath.Abs(A[start]) > Math.Abs(A[end)\\n\\nwhoever is bigger goes to the end;\\n\\nso we need to start the iteration from the end as well.\\n\\n```\\n  public int[] SortedSquares(int[] A) {\\n        int[] res=new int[A.Length];\\n        int start = 0;\\n        int end = A.Length-1;\\n        for(int i=A.Length-1;i>=0; i--)\\n        {\\n            if(Math.Abs(A[start]) > Math.Abs(A[end]))\\n            {\\n                res[i]  = A[start] * A[start];\\n                start++;\\n            }\\n            else{\\n                res[i] = A[end]*A[end];\\n                end--;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  public int[] SortedSquares(int[] A) {\\n        int[] res=new int[A.Length];\\n        int start = 0;\\n        int end = A.Length-1;\\n        for(int i=A.Length-1;i>=0; i--)\\n        {\\n            if(Math.Abs(A[start]) > Math.Abs(A[end]))\\n            {\\n                res[i]  = A[start] * A[start];\\n                start++;\\n            }\\n            else{\\n                res[i] = A[end]*A[end];\\n                end--;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 366635,
                "title": "94-faster-than-all-the-submission-o-n-time-solution-with-detailed-explantnation",
                "content": "**First Aproach :**\\n* \\t Iterate through the vector and square the elements.\\n* \\t Use built in sort function to sort the vector.\\n* \\t this solution is slow and take O(n log n).\\n\\t\\n```\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\tvector<int> sortedSquares(vector<int>& A) {\\n        for(int i=0;i<A.size();i++){\\n            A[i]*=A[i];\\n        }\\n     \\n        sort(A.begin(),A.end());\\n        \\n        return A;\\n    }\\n```\\n\\n**Second Aproach :**\\n\\n Since we are given with ***sorted array*** we can iterate through the vector and get the first positive number, which will divide the array in two halfs.\\n* \\tThese two halfs are sorted and there squares will also be sorted.\\n* \\tNow merge the sorted arrays as we do it in merge sort.\\n* \\tThis approach will yeild a O(n) solution.\\n```\\nclass Solution {\\n\\npublic:    \\n    vector<int> sortedSquares(vector<int>& A) {  \\n        \\n        int l=A.size(),j=l-1;\\n        \\n        vector<int> result;\\n        \\n        //geting the index of first non negative number\\n        for(int m=0;m<l;m++){\\n            if(A[m]>=0){\\n                j=m;break;\\n            }\\n        }\\n              \\n        //squaring the elements.\\n        for(int i=0;i<l;i++)\\n        {\\n            A[i]*=A[i];\\n            \\n        }\\n        int k=j,i=j-1;\\n        //merging the elements such that they are increasing order.\\n           while(i>=0 && k<l){\\n               if(A[i]<A[k]){\\n                   result.push_back(A[i]);\\n                   i--;\\n               }\\n               else{\\n                   result.push_back(A[k]);\\n                   k++;\\n               }\\n           }\\n            //copy rest of elemets to result\\n            while(i>=0){\\n                result.push_back(A[i]);i--;\\n            }\\n            while(k<l){\\n                result.push_back(A[k]);k++;\\n            }\\n            return result ;\\n    }\\n};\\n```\\n\\n Please do comment and let me know if i am wrong anywhere or if you have any better approach.\\n Thanks",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\tvector<int> sortedSquares(vector<int>& A) {\\n        for(int i=0;i<A.size();i++){\\n            A[i]*=A[i];\\n        }\\n     \\n        sort(A.begin(),A.end());\\n        \\n        return A;\\n    }\\n```\n```\\nclass Solution {\\n\\npublic:    \\n    vector<int> sortedSquares(vector<int>& A) {  \\n        \\n        int l=A.size(),j=l-1;\\n        \\n        vector<int> result;\\n        \\n        //geting the index of first non negative number\\n        for(int m=0;m<l;m++){\\n            if(A[m]>=0){\\n                j=m;break;\\n            }\\n        }\\n              \\n        //squaring the elements.\\n        for(int i=0;i<l;i++)\\n        {\\n            A[i]*=A[i];\\n            \\n        }\\n        int k=j,i=j-1;\\n        //merging the elements such that they are increasing order.\\n           while(i>=0 && k<l){\\n               if(A[i]<A[k]){\\n                   result.push_back(A[i]);\\n                   i--;\\n               }\\n               else{\\n                   result.push_back(A[k]);\\n                   k++;\\n               }\\n           }\\n            //copy rest of elemets to result\\n            while(i>=0){\\n                result.push_back(A[i]);i--;\\n            }\\n            while(k<l){\\n                result.push_back(A[k]);k++;\\n            }\\n            return result ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569679,
                "title": "c-using-two-pointer-method-easy-solution-95-25-faster",
                "content": "```\\nvector<int> sortedSquares(vector<int>& nums) {\\n        //Two Pointer\\n        int n = nums.size();\\n        int left = 0, right = n-1;\\n        vector<int>v(n,0);\\n        for(int i = n-1;i>=0;i--){\\n            if(abs(nums[left])>nums[right]){\\n                v[i] = nums[left]*nums[left];\\n                left++;\\n            }\\n            else{\\n                v[i] = nums[right]*nums[right];\\n                right--;\\n            }\\n        }\\n        return v;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nvector<int> sortedSquares(vector<int>& nums) {\\n        //Two Pointer\\n        int n = nums.size();\\n        int left = 0, right = n-1;\\n        vector<int>v(n,0);\\n        for(int i = n-1;i>=0;i--){\\n            if(abs(nums[left])>nums[right]){\\n                v[i] = nums[left]*nums[left];\\n                left++;\\n            }\\n            else{\\n                v[i] = nums[right]*nums[right];\\n                right--;\\n            }\\n        }\\n        return v;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1884640,
                "title": "95-faster-one-pass-solution-two-pointers",
                "content": "***Please Upvote to keep me motivated*** \\u270C\\n\\n**Intution :-** Maintain the two pointers in start and in the end and check the absolute values in array.\\nWhichever is largest, push its square into the result array. Reverse the result array and return it.\\nWe are not maintaining the smaller values in result array because we may get more smaller values by moving ahead in the nums array.\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> res;\\n        int l = 0;\\n        int h = n - 1;\\n        while(l <= h){\\n           if(abs(nums[l]) > abs(nums[h])){\\n               res.push_back(nums[l] * nums[l]);\\n               l++;\\n           } \\n           else{\\n                res.push_back(nums[h] * nums[h]);\\n                 h--;\\n           }\\n        }\\n        reverse(res.begin() , res.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> res;\\n        int l = 0;\\n        int h = n - 1;\\n        while(l <= h){\\n           if(abs(nums[l]) > abs(nums[h])){\\n               res.push_back(nums[l] * nums[l]);\\n               l++;\\n           } \\n           else{\\n                res.push_back(nums[h] * nums[h]);\\n                 h--;\\n           }\\n        }\\n        reverse(res.begin() , res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1517010,
                "title": "reading-the-question-carefully-is-very-important-java-easy",
                "content": "+ A classic 2 pointer solution, s is pointer1 and e is pointer 2.\\n+ s starts from the begenning and e from end.\\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int l = nums.length;\\n        int[] f = new int[l];\\n        int s=0, e=l-1, i=l-1,a,b;\\n        while(s<=e){\\n            a= nums[s]*nums[s]; b= nums[e]*nums[e];\\n            if(a>b){\\n                f[i]=a;\\n                s++;\\n            }else{\\n                f[i]=b;\\n                e--;\\n            }\\n            i--;\\n        }\\n        return f;\\n}}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int l = nums.length;\\n        int[] f = new int[l];\\n        int s=0, e=l-1, i=l-1,a,b;\\n        while(s<=e){\\n            a= nums[s]*nums[s]; b= nums[e]*nums[e];\\n            if(a>b){\\n                f[i]=a;\\n                s++;\\n            }else{\\n                f[i]=b;\\n                e--;\\n            }\\n            i--;\\n        }\\n        return f;\\n}}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 973045,
                "title": "c-c-short-and-simple-o-n-solution",
                "content": "```\\nint* sortedSquares(int* A, int ASize, int* returnSize){\\n    int* arr = malloc(sizeof(int)*ASize);\\n    *returnSize = ASize;\\n    int end = ASize-1, start = 0, ptr = ASize-1;\\n    while ((start <= end) && (ptr>=0))\\n    {\\n        if (pow(A[end],2) >= pow(A[start],2))\\n            arr[ptr] = pow(A[end--],2);\\n        else\\n            arr[ptr] = pow(A[start++],2);\\n        \\n        ptr--;\\n    }\\n    return arr;\\n}\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint* sortedSquares(int* A, int ASize, int* returnSize){\\n    int* arr = malloc(sizeof(int)*ASize);\\n    *returnSize = ASize;\\n    int end = ASize-1, start = 0, ptr = ASize-1;\\n    while ((start <= end) && (ptr>=0))\\n    {\\n        if (pow(A[end],2) >= pow(A[start],2))\\n            arr[ptr] = pow(A[end--],2);\\n        else\\n            arr[ptr] = pow(A[start++],2);\\n        \\n        ptr--;\\n    }\\n    return arr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 678147,
                "title": "c-two-pointer-solution",
                "content": "```\\n/*\\n    Time: O(n) where n is the size of input array\\n    Space: O(n) due to the output array\\n*/\\npublic class Solution {\\n    public int[] SortedSquares(int[] A) {\\n        \\n        int[] res = new int[A.Length];       \\n        int left = 0, right = A.Length - 1;        \\n        \\n        for(int i = A.Length - 1; i >= 0; i--)\\n        {\\n            if(Math.Abs(A[left]) >= Math.Abs(A[right]))\\n            {\\n                res[i] = A[left] * A[left];\\n                left++;\\n            }\\n            else\\n            {\\n                res[i] = A[right] * A[right];\\n                right--;\\n            }           \\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    Time: O(n) where n is the size of input array\\n    Space: O(n) due to the output array\\n*/\\npublic class Solution {\\n    public int[] SortedSquares(int[] A) {\\n        \\n        int[] res = new int[A.Length];       \\n        int left = 0, right = A.Length - 1;        \\n        \\n        for(int i = A.Length - 1; i >= 0; i--)\\n        {\\n            if(Math.Abs(A[left]) >= Math.Abs(A[right]))\\n            {\\n                res[i] = A[left] * A[left];\\n                left++;\\n            }\\n            else\\n            {\\n                res[i] = A[right] * A[right];\\n                right--;\\n            }           \\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2074042,
                "title": "ruby-solution-using-pointers-instead-of-built-in-ruby-sort-method",
                "content": "**O(nlogn) Solution**\\nYes, we all know that Ruby is awesome and this problem can be solved with a simple one-liner:\\n```Ruby\\ndef sorted_squares(nums)\\n  nums.map { |n| n**2 }.sort\\nend\\n```\\nBut, there are a couple issues with this solution. Most notably, this is NOT the most optimal solution. Ruby\\'s `sort` method uses quicksort internally, thus the complexity for this solution will end up being `O(nlogn)`. The other issue with this solution is that it doesn\\'t really honor the spirit of LeetCode (IE, coming up with your own clever algorithm to solve a given problem). In a real world interview your interviewer likely wouldn\\'t accept this as a \"final\" solution. Maybe a first stab. And first stabs aren\\'t bad! But we can do better.\\n\\n**O(n) Solution**\\nUsing simple pointers, we can come up with an `O(n)` solution. The basic principle: We know the `nums` array is already sorted, but the trick here is that it may contain some negative values. This means that when we square those negative values they\\'ll end up at some new index location in our final squared and sorted array. Luckily, we do know that they are already sorted ... just sorted in a more-or-less *backwards* order. Using this knowledge, we take two pointers - one for the left side of the nums array and one on the right side - and slowly increase the left pointer while simultaneously decreasing the right pointer, comparing the results of each squared number at each iteration. **Think of the array as two parts: a left array sorted from left to right and a right array sorted from right to left.** We move our left pointer along the \"left\" array and the right pointer along the \"right\" array, from largest to smallest in each case. We then stick the larger of the two at the end of our final array and move on to compare the next two left and right values by decreasing the left or right index by one each step. Our comparison window will slowly shrink until the left and right pointers meet and we have compared all values in the array one at a time. At this point we will have inserted each squared value *in sorted order* into our final array, and we\\'re done. Bim bam boom.\\n\\nHere\\'s my implmentation:\\n```ruby\\ndef sorted_squares(nums)\\n  arr = [] # Initialize an empty array to store squared values\\n  l = 0 # Initialize the left pointer to zero (IE, the LARGEST value of the \"left\" array)\\n  r = nums.size - 1 # Initialize the right pointer to the size of nums (IE, the LARGEST value for the \"right\" array)\\n  i = r # Initialize our \"insert index\". Because we are starting with the largest values and working our way inward, we will insert each value into the array starting at the end (IE, the largest index in nums)\\n  \\n  until i < 0 # Loop until we\\'ve exhausted all nums\\n    left = nums[l]**2 # Square the left side value\\n    right = nums[r]**2 # Square the right side value\\n    \\n    if left > right\\n\\t  # If the left value is larger store it in our array at the current index and increment the left pointer\\n      arr[i] = left\\n      l += 1\\n    else\\n\\t  # Otherwise the right value is larger, store it at the current index and decrement the right pointer\\n      arr[i] = right\\n      r -= 1\\n    end\\n    \\n    i -= 1 # We inserted one squared value into our final array, decrement the current index\\n  end\\n     \\n  arr # Return the final array\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Sorting"
                ],
                "code": "```Ruby\\ndef sorted_squares(nums)\\n  nums.map { |n| n**2 }.sort\\nend\\n```\n```ruby\\ndef sorted_squares(nums)\\n  arr = [] # Initialize an empty array to store squared values\\n  l = 0 # Initialize the left pointer to zero (IE, the LARGEST value of the \"left\" array)\\n  r = nums.size - 1 # Initialize the right pointer to the size of nums (IE, the LARGEST value for the \"right\" array)\\n  i = r # Initialize our \"insert index\". Because we are starting with the largest values and working our way inward, we will insert each value into the array starting at the end (IE, the largest index in nums)\\n  \\n  until i < 0 # Loop until we\\'ve exhausted all nums\\n    left = nums[l]**2 # Square the left side value\\n    right = nums[r]**2 # Square the right side value\\n    \\n    if left > right\\n\\t  # If the left value is larger store it in our array at the current index and increment the left pointer\\n      arr[i] = left\\n      l += 1\\n    else\\n\\t  # Otherwise the right value is larger, store it at the current index and decrement the right pointer\\n      arr[i] = right\\n      r -= 1\\n    end\\n    \\n    i -= 1 # We inserted one squared value into our final array, decrement the current index\\n  end\\n     \\n  arr # Return the final array\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1695344,
                "title": "java-two-pointers-o-n",
                "content": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int n=nums.length;\\n        int[] res=new int[n];\\n        int left=0;\\n        int right=n-1;\\n        for(int i=n-1;i>=0;i--){\\n            if(Math.abs(nums[left])>=Math.abs(nums[right])){\\n                res[i]=nums[left]*nums[left];\\n                left++;\\n            }\\n            else{\\n                res[i]=nums[right]*nums[right];\\n                right--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n\\n**Do upvote if you find this useful**",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int n=nums.length;\\n        int[] res=new int[n];\\n        int left=0;\\n        int right=n-1;\\n        for(int i=n-1;i>=0;i--){\\n            if(Math.abs(nums[left])>=Math.abs(nums[right])){\\n                res[i]=nums[left]*nums[left];\\n                left++;\\n            }\\n            else{\\n                res[i]=nums[right]*nums[right];\\n                right--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 234202,
                "title": "swift-no-brainer",
                "content": "```\\nclass Solution {\\n    func sortedSquares(_ A: [Int]) -> [Int] {\\n        return A.map{ $0 * $0 }.sorted()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func sortedSquares(_ A: [Int]) -> [Int] {\\n        return A.map{ $0 * $0 }.sorted()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531964,
                "title": "java-two-pointers",
                "content": "![IMG_20230516_220315.jpg](https://assets.leetcode.com/users/images/a8e537ec-9c2f-4402-95b0-5db8601d2d16_1684263908.2499745.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int n = nums.length;\\n        int[] result = new int[n];\\n        int left = 0;\\n        int right = n - 1;\\n        int i = n - 1;\\n\\n        while (left <= right) {\\n            int leftSquare = nums[left] * nums[left];\\n            int rightSquare = nums[right] * nums[right];\\n\\n            if (leftSquare > rightSquare) {\\n                result[i] = leftSquare;\\n                left++;\\n            } else {\\n                result[i] = rightSquare;\\n                right--;\\n            }\\n\\n            i--;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Go",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int n = nums.length;\\n        int[] result = new int[n];\\n        int left = 0;\\n        int right = n - 1;\\n        int i = n - 1;\\n\\n        while (left <= right) {\\n            int leftSquare = nums[left] * nums[left];\\n            int rightSquare = nums[right] * nums[right];\\n\\n            if (leftSquare > rightSquare) {\\n                result[i] = leftSquare;\\n                left++;\\n            } else {\\n                result[i] = rightSquare;\\n                right--;\\n            }\\n\\n            i--;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3062168,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int i=0, n=nums.size();\\n        while(i<n-1 && abs(nums[i+1])<=abs(nums[i]))\\n        i++;\\n        i++;\\n        int j=i-1;\\n        vector<int> ans;\\n        while(j>=0 && i<n)\\n        {\\n            if(abs(nums[j])<abs(nums[i]))\\n            {\\n                ans.push_back(nums[j]*nums[j]);\\n                j--;\\n            }\\n            else\\n            {\\n                ans.push_back(nums[i]*nums[i]);\\n                i++;\\n            }\\n        }\\n        while(j>=0)\\n        {\\n            ans.push_back(nums[j]*nums[j]);\\n            j--;\\n        }\\n        while(i<n)\\n        {\\n            ans.push_back(nums[i]*nums[i]);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int i=0, n=nums.size();\\n        while(i<n-1 && abs(nums[i+1])<=abs(nums[i]))\\n        i++;\\n        i++;\\n        int j=i-1;\\n        vector<int> ans;\\n        while(j>=0 && i<n)\\n        {\\n            if(abs(nums[j])<abs(nums[i]))\\n            {\\n                ans.push_back(nums[j]*nums[j]);\\n                j--;\\n            }\\n            else\\n            {\\n                ans.push_back(nums[i]*nums[i]);\\n                i++;\\n            }\\n        }\\n        while(j>=0)\\n        {\\n            ans.push_back(nums[j]*nums[j]);\\n            j--;\\n        }\\n        while(i<n)\\n        {\\n            ans.push_back(nums[i]*nums[i]);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1480790,
                "title": "shortest-possible-java-solution-only-4-lines-of-code-beats-100",
                "content": "Before showing the solution I suggest having a look at the [Merge Sorted Array](https://leetcode.com/problems/merge-sorted-array/) problem if you didn\\'t, and you can see how I solved it [here](https://leetcode.com/problems/merge-sorted-array/discuss/1480686/shortest-java-solution-only-6-lines-of-code-beats-100).\\n\\nBy using the same logic, our approuch is to have two pointers starting at the beginning and end of the array and select whichever is higher and continuously fills out our new array from end to start with the selected element.\\n\\n\\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int[] temp = new int[nums.length];\\n        \\n        for (int i = 0, j = nums.length - 1, current = j; current >= 0; ) {\\n            temp[current--] = Math.abs(nums[i]) >= Math.abs(nums[j]) ? nums[i] * nums[i++] : nums[j] * nums[j--];\\n        }\\n        return temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int[] temp = new int[nums.length];\\n        \\n        for (int i = 0, j = nums.length - 1, current = j; current >= 0; ) {\\n            temp[current--] = Math.abs(nums[i]) >= Math.abs(nums[j]) ? nums[i] * nums[i++] : nums[j] * nums[j--];\\n        }\\n        return temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 972954,
                "title": "python-oneliner-o-n-explained",
                "content": "Note, that our numbers will look like this: first we have some negative numbers in increasing order (may be `0` of them) and then we have some positive numbers in increasing order (again may be `0` of them). \\n\\n1. Note, that if we have negative number in increasing order, then their squares will be in decreasing order, so we need to invert this part.\\n2. If we have positive increasing numbers, then their squares also increasing numbers.\\n3. Now we have two lists with increasing numbers and we need to creaty one list with increasing numbers, how we can do it? We can use **merge** sort and do it by hands. However it happens, that if we run the code as it is it will be `O(n)`. Why? Because python uses so-called **Timsort** https://en.wikipedia.org/wiki/Timsort which will look for sorted patterns in data.\\n\\n**Complexity**: time and space complexity is `O(n)`.\\n\\n```\\nclass Solution:\\n    def sortedSquares(self, nums):\\n        return sorted([i**2 for i in nums if i > 0][::-1] + [i**2 for i in nums if i <= 0])\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums):\\n        return sorted([i**2 for i in nums if i > 0][::-1] + [i**2 for i in nums if i <= 0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 483503,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        return sorted([x**2 for x in A])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        return sorted([x**2 for x in A])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 230731,
                "title": "c-well-commented-solution-with-explanation-using-double-ended-queue",
                "content": "```\\n/* Idea ---- \\n1) Store the array in a double ended queue  \\n2) Now the element with the largest magnitude would be at the front or at the back\\n3) Moreover, the element with the largest magnitude would have the largest square value\\n4) So, Pop it and similarly get the second largest in magnitude\\n5) Finally, Reverse the answer to sort in non_decreasing order\\n*/\\n\\nclass Solution\\n{\\npublic:\\n    vector<int> sortedSquares(vector<int>& myVector);\\n};\\n\\n/* Returns the vector of sorted square */\\nvector<int> Solution :: sortedSquares(vector<int>& myVector)\\n{\\n    // Declare the deque and the container to hold the answer\\n    vector<int> answer;\\n    deque<int> dq;\\n    \\n    // Fill all elements in the deque\\n    for(auto ele: myVector)\\n        dq.push_back(ele);\\n    \\n    // Keep extracting the element with the highest magnitude\\n    while(!dq.empty())\\n    {\\n        // Get a copy\\n        int front = dq.front();\\n        int back = dq.back();\\n        \\n        // If the largest magnitude occurs at the front, pop it and append it\\n        if(abs(front) > abs(back))\\n        {\\n            dq.pop_front();\\n            answer.push_back(front*front);\\n        }\\n        \\n        // Else pop the back and append it to answer\\n        else\\n        {\\n            dq.pop_back();\\n            answer.push_back(back*back);\\n        }\\n    }\\n    \\n    // Fianlly Reverse the answer to sort in non decreasing order\\n    reverse(answer.begin(), answer.end());\\n    \\n    // Return the new answer\\n    return answer;\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/* Idea ---- \\n1) Store the array in a double ended queue  \\n2) Now the element with the largest magnitude would be at the front or at the back\\n3) Moreover, the element with the largest magnitude would have the largest square value\\n4) So, Pop it and similarly get the second largest in magnitude\\n5) Finally, Reverse the answer to sort in non_decreasing order\\n*/\\n\\nclass Solution\\n{\\npublic:\\n    vector<int> sortedSquares(vector<int>& myVector);\\n};\\n\\n/* Returns the vector of sorted square */\\nvector<int> Solution :: sortedSquares(vector<int>& myVector)\\n{\\n    // Declare the deque and the container to hold the answer\\n    vector<int> answer;\\n    deque<int> dq;\\n    \\n    // Fill all elements in the deque\\n    for(auto ele: myVector)\\n        dq.push_back(ele);\\n    \\n    // Keep extracting the element with the highest magnitude\\n    while(!dq.empty())\\n    {\\n        // Get a copy\\n        int front = dq.front();\\n        int back = dq.back();\\n        \\n        // If the largest magnitude occurs at the front, pop it and append it\\n        if(abs(front) > abs(back))\\n        {\\n            dq.pop_front();\\n            answer.push_back(front*front);\\n        }\\n        \\n        // Else pop the back and append it to answer\\n        else\\n        {\\n            dq.pop_back();\\n            answer.push_back(back*back);\\n        }\\n    }\\n    \\n    // Fianlly Reverse the answer to sort in non decreasing order\\n    reverse(answer.begin(), answer.end());\\n    \\n    // Return the new answer\\n    return answer;\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2806619,
                "title": "simple-python-solution-by-queue",
                "content": "![image.png](https://assets.leetcode.com/users/images/37ab4945-e4fe-414d-aec6-72e248e4217d_1668256343.9517837.png)\\n\\n\\n# Intuition\\nusing Queue\\n\\n# Approach\\n1. compare square of left most element and square of right most element, assign pop the max element from queue\\n2. Repeat this until the deque contains element.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        res = []\\n        num_deque = collections.deque(nums)\\n\\n        while num_deque:\\n            left = num_deque[0] ** 2\\n            right = num_deque[-1] ** 2\\n\\n            if left > right:\\n                res.append(left)\\n                num_deque.popleft()\\n            else:\\n                res.append(right)\\n                num_deque.pop()\\n        \\n        return res[::-1]\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        res = []\\n        num_deque = collections.deque(nums)\\n\\n        while num_deque:\\n            left = num_deque[0] ** 2\\n            right = num_deque[-1] ** 2\\n\\n            if left > right:\\n                res.append(left)\\n                num_deque.popleft()\\n            else:\\n                res.append(right)\\n                num_deque.pop()\\n        \\n        return res[::-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2238816,
                "title": "python-two-pointers-o-n-runtime-71-43",
                "content": "### Solution\\nFirstly, we initialize left and right pointers at the beginning and the end of the array. Then, we check the absolute values of the ends and populate the array in decreasing order.\\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        left, right, new_arr = 0, len(nums)-1, []\\n        \\n        while left <= right:\\n            if abs(nums[left]) <= abs(nums[right]):\\n                new_arr.append(nums[right]**2)\\n                right -= 1\\n            else:\\n                new_arr.append(nums[left]**2)\\n                left += 1\\n            \\n        return(new_arr[::-1])\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        left, right, new_arr = 0, len(nums)-1, []\\n        \\n        while left <= right:\\n            if abs(nums[left]) <= abs(nums[right]):\\n                new_arr.append(nums[right]**2)\\n                right -= 1\\n            else:\\n                new_arr.append(nums[left]**2)\\n                left += 1\\n            \\n        return(new_arr[::-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2126752,
                "title": "java-two-approaches-o-n-concise-solution-one-pass-with-well-explained-code",
                "content": "```\\n/*\\n     * BruteForce Approach.\\n     * (1) Square all the elements of array.\\n     * (2) Sort the squared array.\\n     * Time Complexity = O(n*logn) for sorting.\\n     * Space Complexity = O(1) no extra space is used.\\n     */\\n\\n    static int[] sortedSquares(int[] nums) {\\n        for (int i = 0; i < nums.length; i++) {\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;\\n    }\\n\\n    /*\\n     * Better Approach.\\n     * (1) Create new array & start filling it from behind.\\n     * (2) Make two pointers that points starting & ending index of original array\\n     * respectively.\\n     * Time Complexity = O(n) for traversing.\\n     * Space Complexity = O(n) extra space for answer array.\\n     */\\n\\n    static int[] sortedSquares(int[] nums) {\\n        int[] ans = new int[nums.length];\\n        int start = 0, end = nums.length - 1;\\n\\n        int ansIdx = nums.length - 1;\\n        while (start <= end) {\\n            if (nums[start] * nums[start] > nums[end] * nums[end]) {\\n                ans[ansIdx--] = nums[start] * nums[start];\\n                start++;\\n            } else {\\n                ans[ansIdx--] = nums[end] * nums[end];\\n                end--;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n\\tPlease Upvote if you like this :)\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\n/*\\n     * BruteForce Approach.\\n     * (1) Square all the elements of array.\\n     * (2) Sort the squared array.\\n     * Time Complexity = O(n*logn) for sorting.\\n     * Space Complexity = O(1) no extra space is used.\\n     */\\n\\n    static int[] sortedSquares(int[] nums) {\\n        for (int i = 0; i < nums.length; i++) {\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;\\n    }\\n\\n    /*\\n     * Better Approach.\\n     * (1) Create new array & start filling it from behind.\\n     * (2) Make two pointers that points starting & ending index of original array\\n     * respectively.\\n     * Time Complexity = O(n) for traversing.\\n     * Space Complexity = O(n) extra space for answer array.\\n     */\\n\\n    static int[] sortedSquares(int[] nums) {\\n        int[] ans = new int[nums.length];\\n        int start = 0, end = nums.length - 1;\\n\\n        int ansIdx = nums.length - 1;\\n        while (start <= end) {\\n            if (nums[start] * nums[start] > nums[end] * nums[end]) {\\n                ans[ansIdx--] = nums[start] * nums[start];\\n                start++;\\n            } else {\\n                ans[ansIdx--] = nums[end] * nums[end];\\n                end--;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n\\tPlease Upvote if you like this :)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1109072,
                "title": "java-two-pointers-o-n-with-interview-tips",
                "content": "Before proceeding to solution ask clarification question. for eg:\\n 1. can the values in the array be negative.\\n 2. can square of values can exceed Integer.MAX_VALUE.\\n 3. values are in long or Integer.\\n 4. is given array sorted.(even if the example are sorted) this helped me in google interview interviewer told me that this is nice question. (I was not asked this question but a question where sample cases where sorted )\\n \\n now move to solution :\\nSolution 1: Square all the values of the array and now sort the array . \\n                    Time :O(nlogn) and space O(1) \\n\\t\\t\\t\\t\\task then sir/mam that this is one kind of solution should i need to improve time complexity                      or are you fine with it. (if they told to improve then go to O(n) soln)\\n\\t\\t\\t\\t\\t\\nSolution 2: \\t\\t\\t\\t\\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] A) {\\n        \\n        \\n        int i=0;\\n        int j=A.length-1;\\n        int k=A.length-1;\\n        int[] ans=new int[A.length];\\n        \\n        while(i<=j){\\n            int val1=Math.abs(A[i]);\\n            int val2=Math.abs(A[j]);\\n             \\n            if(val2>val1){\\n                val2=val2*val2;\\n                ans[k]=val2;\\n                k--;\\n                j--;\\n            }else{\\n                val1=val1*val1;\\n                ans[k]=val1;\\n                k--;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\nPlease upvote if find it helpful love to hear some feedback or any doubt you have in solution.",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] A) {\\n        \\n        \\n        int i=0;\\n        int j=A.length-1;\\n        int k=A.length-1;\\n        int[] ans=new int[A.length];\\n        \\n        while(i<=j){\\n            int val1=Math.abs(A[i]);\\n            int val2=Math.abs(A[j]);\\n             \\n            if(val2>val1){\\n                val2=val2*val2;\\n                ans[k]=val2;\\n                k--;\\n                j--;\\n            }else{\\n                val1=val1*val1;\\n                ans[k]=val1;\\n                k--;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 325435,
                "title": "short-java-solution-1ms-beat-100-40-3mb",
                "content": "```\\n    public int[] sortedSquares(int[] A) {\\n        int res[] = new int[A.length];\\n        int i = 0;\\n        int k = A.length - 1;\\n        int z = A.length - 1;\\n        while(z >= 0){ \\n            res[z--] = Math.abs(A[i]) > Math.abs(A[k]) ? A[i] * A[i++] : A[k] * A[k--];\\n        }\\n        return res;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int[] sortedSquares(int[] A) {\\n        int res[] = new int[A.length];\\n        int i = 0;\\n        int k = A.length - 1;\\n        int z = A.length - 1;\\n        while(z >= 0){ \\n            res[z--] = Math.abs(A[i]) > Math.abs(A[k]) ? A[i] * A[i++] : A[k] * A[k--];\\n        }\\n        return res;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 286050,
                "title": "java-100-rt",
                "content": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] A) {\\n        int i = 0, j = A.length -1, k=j;\\n        int[] B = new int[A.length];\\n        while(k>=0){\\n            int x = A[i]*A[i], y = A[j]*A[j];\\n            if(x >= y){\\n                B[k] = x;\\n                i++;\\n            } else{\\n                B[k] = y;\\n                j--;\\n            }\\n\\t\\t\\tk--;\\n        }\\n        return B;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] A) {\\n        int i = 0, j = A.length -1, k=j;\\n        int[] B = new int[A.length];\\n        while(k>=0){\\n            int x = A[i]*A[i], y = A[j]*A[j];\\n            if(x >= y){\\n                B[k] = x;\\n                i++;\\n            } else{\\n                B[k] = y;\\n                j--;\\n            }\\n\\t\\t\\tk--;\\n        }\\n        return B;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 226530,
                "title": "javascript-o-n-solution-w-explanation-11-lines-no-arrays-sort",
                "content": "```Given an array of integers A sorted in non-decreasing order, return an array of the squares of each number, also in sorted non-decreasing order.```\\n\\nUsing the given, we know that the array is already in sorted order. \\nThis tells us:\\n1. The next largest square will be on either end of the array.\\n2. We can use two pointers starting on each end to find the largest square then append it to our result. We move the pointer that held the larger square.\\n3. Once our pointers have crossed we have covered every value in the original array and can return our result array.\\n\\nNote: *Instead of using the unshift() function I have decided to use push and then reversing the whole array because unshift is a costly function that has to move all of the elements of the array.*\\n\\n```\\nvar sortedSquares = function(A) {\\n    let res = [];\\n    let up = 0, down = A.length-1;\\n    \\n    let a = A[up]*A[up];\\n    let b = A[down]*A[down];\\n    \\n    while (up <= down) {\\n        if (a > b) {\\n            res.push(a);\\n            up++;\\n            a = A[up]*A[up];\\n        } else {\\n            res.push(b);\\n            down--;\\n            b = A[down]*A[down];\\n        }\\n    }\\n    \\n    return res.reverse();\\n};",
                "solutionTags": [],
                "code": "```Given an array of integers A sorted in non-decreasing order, return an array of the squares of each number, also in sorted non-decreasing order.```",
                "codeTag": "Unknown"
            },
            {
                "id": 1663563,
                "title": "2-javascript-solutions-with-explanations",
                "content": "There\\'s at least 2 ways which we can solve this problem:\\n\\n1. As the question suggests, it\\'s easy to map through our input, square each number and then sort the output.\\n\\n```\\nreturn nums\\n        .map(num => Math.pow(num, 2))\\n        .sort((numOne, numTwo) => numOne - numTwo);\\n```\\n\\nThis would result in an algorithm that is `O(n log n)` due to the underlying quicksort and requires constant `O(log n)` space.\\n\\n2. We could instead take advantage of the property of the array being sorted and instead create an output array and 2 pointers that will increment/decrement depending on the result of the squaring of each and comparing them.\\n\\n```\\nconst sortedSquares = nums => {\\n    const sorted = new Array(nums.length);\\n    \\n    let start = 0;\\n    let end = sorted.length - 1;\\n    \\n    for (let insert = end; insert >= 0; insert--) {\\n        const squaredStart = Math.pow(nums[start], 2);\\n        const squaredEnd = Math.pow(nums[end], 2);\\n        \\n        if (squaredStart > squaredEnd) {\\n            sorted[insert] = squaredStart;\\n            start++;\\n        } else {\\n            sorted[insert] = squaredEnd;\\n            end--;\\n        }\\n    }\\n    \\n    return sorted;\\n};\\n```\\n\\nThis results in an algorithm that requires `O(n)` time as traverse our entire input array and `O(n)` space as our created array is dependent on the size of our input.\\n\\nHappy coding :)",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nreturn nums\\n        .map(num => Math.pow(num, 2))\\n        .sort((numOne, numTwo) => numOne - numTwo);\\n```\n```\\nconst sortedSquares = nums => {\\n    const sorted = new Array(nums.length);\\n    \\n    let start = 0;\\n    let end = sorted.length - 1;\\n    \\n    for (let insert = end; insert >= 0; insert--) {\\n        const squaredStart = Math.pow(nums[start], 2);\\n        const squaredEnd = Math.pow(nums[end], 2);\\n        \\n        if (squaredStart > squaredEnd) {\\n            sorted[insert] = squaredStart;\\n            start++;\\n        } else {\\n            sorted[insert] = squaredEnd;\\n            end--;\\n        }\\n    }\\n    \\n    return sorted;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1596760,
                "title": "easy-c-solution-o-n-time-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        \\n        vector<int> res(nums.size());\\n        int l = 0, r = nums.size() - 1;\\n        \\n        for (int k = nums.size() - 1; k >= 0; k--) {\\n            \\n            if (abs(nums[r]) > abs(nums[l])) \\n                res[k] = nums[r] * nums[r--];\\n            else \\n                res[k] = nums[l] * nums[l++];\\n            \\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nIf you like the solution then please upvote. Open to queries.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        \\n        vector<int> res(nums.size());\\n        int l = 0, r = nums.size() - 1;\\n        \\n        for (int k = nums.size() - 1; k >= 0; k--) {\\n            \\n            if (abs(nums[r]) > abs(nums[l])) \\n                res[k] = nums[r] * nums[r--];\\n            else \\n                res[k] = nums[l] * nums[l++];\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472964,
                "title": "commented-rust-o-n-beats-99",
                "content": "```\\nimpl Solution {\\n    pub fn sorted_squares(nums: Vec<i32>) -> Vec<i32> {\\n        // The code works without this, but it removes a\\n        // lot of useless allocations for a base case\\n        if nums.len() == 1 {\\n            return vec![i32::pow(nums[0], 2)];\\n        }\\n        \\n        // We\\'ll use this for inserting later\\n        let mut location = nums.len();\\n        \\n        // Pre-allocate so we can start indexing from the end\\n        let mut output = vec![0; location];\\n        \\n        // These are our markers for the 2 ends of the array\\n        let mut left = 0 as usize;\\n        let mut right = nums.len() - 1;\\n        \\n        // We\\'re only going to compute each value once\\n        let mut computed_left = i32::pow(nums[left], 2);\\n        let mut computed_right = i32::pow(nums[right], 2);\\n        \\n        while left != right {\\n            // Every loop we\\'re moving one spot further to the left\\n            location-=1;\\n            // Every loop iteration we check which value is larger and\\n            // put that at the end of the output vector that we pre-allocated\\n            if computed_left > computed_right {\\n                output[location] = computed_left;\\n                left+=1;\\n                computed_left = i32::pow(nums[left], 2);\\n            } else {\\n                output[location] = computed_right;\\n                right-=1;\\n                computed_right = i32::pow(nums[right], 2);\\n            }\\n        }\\n        // Could do either one, because at this point they should be the\\n        // same index / value\\n        output[0] = computed_right;\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Two Pointers"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn sorted_squares(nums: Vec<i32>) -> Vec<i32> {\\n        // The code works without this, but it removes a\\n        // lot of useless allocations for a base case\\n        if nums.len() == 1 {\\n            return vec![i32::pow(nums[0], 2)];\\n        }\\n        \\n        // We\\'ll use this for inserting later\\n        let mut location = nums.len();\\n        \\n        // Pre-allocate so we can start indexing from the end\\n        let mut output = vec![0; location];\\n        \\n        // These are our markers for the 2 ends of the array\\n        let mut left = 0 as usize;\\n        let mut right = nums.len() - 1;\\n        \\n        // We\\'re only going to compute each value once\\n        let mut computed_left = i32::pow(nums[left], 2);\\n        let mut computed_right = i32::pow(nums[right], 2);\\n        \\n        while left != right {\\n            // Every loop we\\'re moving one spot further to the left\\n            location-=1;\\n            // Every loop iteration we check which value is larger and\\n            // put that at the end of the output vector that we pre-allocated\\n            if computed_left > computed_right {\\n                output[location] = computed_left;\\n                left+=1;\\n                computed_left = i32::pow(nums[left], 2);\\n            } else {\\n                output[location] = computed_right;\\n                right-=1;\\n                computed_right = i32::pow(nums[right], 2);\\n            }\\n        }\\n        // Could do either one, because at this point they should be the\\n        // same index / value\\n        output[0] = computed_right;\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1217913,
                "title": "c-two-pointers",
                "content": "\\n**1st approach :** 1) Take the squares of each element and store it.\\n                                2) Then finally sort the vector and return it.\\n                                3) T.C - O(NlogN)\\n **2 approach :** Take two pointers at either ends of array.\\n                              Check abs value of both the elements and fill \\n\\t\\t\\t\\t\\t\\t\\t  the array backwards bcoz largest value will be at last\\n\\n\\n\\t\\tvector<int> sortedSquares(vector<int>& nums) {\\n\\t\\t\\t\\t\\t\\t\\tvector<int>ans(nums.size());\\n\\t\\t\\t\\t\\t\\t\\tint i=0;\\n\\t\\t\\t\\t\\t\\t\\tint j=nums.size()-1;\\n\\t\\t\\t\\t\\t\\t\\tfor(int k=nums.size()-1;k>=0;k--)\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tif(abs(nums[i]) < abs(nums[j]))\\n\\t\\t\\t\\t\\t\\t\\t\\t   {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   ans[k] = nums[j]*nums[j];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   j--;\\n\\t\\t\\t\\t\\t\\t\\t\\t   }\\n\\t\\t\\t\\t\\t\\t\\t\\t   else\\n\\t\\t\\t\\t\\t\\t\\t\\t   {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   ans[k] = nums[i]*nums[i];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   i++;\\n\\t\\t\\t\\t\\t\\t\\t\\t   }\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t   return ans;\\n\\t\\t\\t\\t\\t\\t}",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "\\n**1st approach :** 1) Take the squares of each element and store it.\\n                                2) Then finally sort the vector and return it.\\n                                3) T.C - O(NlogN)\\n **2 approach :** Take two pointers at either ends of array.\\n                              Check abs value of both the elements and fill \\n\\t\\t\\t\\t\\t\\t\\t  the array backwards bcoz largest value will be at last\\n\\n\\n\\t\\tvector<int> sortedSquares(vector<int>& nums) {\\n\\t\\t\\t\\t\\t\\t\\tvector<int>ans(nums.size());\\n\\t\\t\\t\\t\\t\\t\\tint i=0;\\n\\t\\t\\t\\t\\t\\t\\tint j=nums.size()-1;\\n\\t\\t\\t\\t\\t\\t\\tfor(int k=nums.size()-1;k>=0;k--)\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tif(abs(nums[i]) < abs(nums[j]))\\n\\t\\t\\t\\t\\t\\t\\t\\t   {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   ans[k] = nums[j]*nums[j];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   j--;\\n\\t\\t\\t\\t\\t\\t\\t\\t   }\\n\\t\\t\\t\\t\\t\\t\\t\\t   else\\n\\t\\t\\t\\t\\t\\t\\t\\t   {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   ans[k] = nums[i]*nums[i];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   i++;\\n\\t\\t\\t\\t\\t\\t\\t\\t   }\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t   return ans;\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3834119,
                "title": "most-optimal-code-clean-code-explanation-c",
                "content": "# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- The problem which can be solved using inbuilt sorting function, but we need to execute this in O(n).\\n- We\\'ll be dealing with two pointers with NO DOUBT.\\n- Let\\'s point to end and and start.\\n- The one which is greater put at the end.\\n- And decrement the pointer of ans vector.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int i=0,j=nums.size()-1, k=nums.size()-1;\\n        vector<int>v(nums.size(),0);\\n        while(i<=j)\\n        {\\n            if(abs(nums[i])>=abs(nums[j]))\\n             v[k--]=(pow(nums[i++],2));\\n            \\n            else v[k--]=(pow(nums[j--],2));\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int i=0,j=nums.size()-1, k=nums.size()-1;\\n        vector<int>v(nums.size(),0);\\n        while(i<=j)\\n        {\\n            if(abs(nums[i])>=abs(nums[j]))\\n             v[k--]=(pow(nums[i++],2));\\n            \\n            else v[k--]=(pow(nums[j--],2));\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3123725,
                "title": "c-3-line-sol-must-watch-2023-method",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& v) {\\n        for_each(v.begin(),v.end(),[](int &x){x*=x;});\\n        sort(v.begin(),v.end());\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& v) {\\n        for_each(v.begin(),v.end(),[](int &x){x*=x;});\\n        sort(v.begin(),v.end());\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1868051,
                "title": "java-optimized-easy",
                "content": "## **Please Upvote if you understood this** (\\uFF5E\\uFFE3\\u25BD\\uFFE3)\\uFF5E\\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n//         for(int i=0;i<nums.length;i++) nums[i]*=nums[i];\\n//         Arrays.sort(nums);\\n//         return nums;\\n        int start = 0;\\n        int end = nums.length - 1;\\n        int index = end;\\n        int[] res = new int[nums.length];\\n        while(start<=end){\\n            if(Math.abs(nums[start])>Math.abs(nums[end])){\\n                res[index--]=nums[start]*nums[start];\\n                start++;\\n            }\\n            else{\\n                res[index--]=nums[end]*nums[end];\\n                end--;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n//         for(int i=0;i<nums.length;i++) nums[i]*=nums[i];\\n//         Arrays.sort(nums);\\n//         return nums;\\n        int start = 0;\\n        int end = nums.length - 1;\\n        int index = end;\\n        int[] res = new int[nums.length];\\n        while(start<=end){\\n            if(Math.abs(nums[start])>Math.abs(nums[end])){\\n                res[index--]=nums[start]*nums[start];\\n                start++;\\n            }\\n            else{\\n                res[index--]=nums[end]*nums[end];\\n                end--;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1763243,
                "title": "java-without-sorting-one-pass-solution-o-n",
                "content": "```\\nclass Solution \\n{\\n    public int[] sortedSquares(int[] nums) \\n    {\\n        int n=nums.length,i=0,j,x=0;\\n        int a[] = new int[n];     \\n        while(i<n && nums[i]<0)\\n            i++;\\n        j=i-1;\\n        while(j>=0 && i<n)\\n        {\\n            if(nums[i] < -nums[j])\\n                a[x++]=nums[i]*nums[i++];\\n            else\\n                a[x++]=nums[j]*nums[j--];\\n        }\\n        while(j>=0)\\n            a[x++]=nums[j]*nums[j--];\\n        while(i<n)\\n            a[x++]=nums[i]*nums[i++];\\n        //Arrays.sort(nums);\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int[] sortedSquares(int[] nums) \\n    {\\n        int n=nums.length,i=0,j,x=0;\\n        int a[] = new int[n];     \\n        while(i<n && nums[i]<0)\\n            i++;\\n        j=i-1;\\n        while(j>=0 && i<n)\\n        {\\n            if(nums[i] < -nums[j])\\n                a[x++]=nums[i]*nums[i++];\\n            else\\n                a[x++]=nums[j]*nums[j--];\\n        }\\n        while(j>=0)\\n            a[x++]=nums[j]*nums[j--];\\n        while(i<n)\\n            a[x++]=nums[i]*nums[i++];\\n        //Arrays.sort(nums);\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1681614,
                "title": "swift-two-pointers-o-n",
                "content": "```swift\\nfunc sortedSquares(_ nums: [Int]) -> [Int] {\\n    var right = nums.count - 1\\n    var left = 0\\n    \\n    var result = nums\\n    var index = right\\n    while index >= 0 {\\n        if abs(nums[left]) < abs(nums[right]) {\\n            result[index] = nums[right] * nums[right]\\n            right -= 1\\n        } else {\\n            result[index] = nums[left] * nums[left]\\n            left += 1\\n        }\\n        index -= 1\\n    }\\n    return result\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```swift\\nfunc sortedSquares(_ nums: [Int]) -> [Int] {\\n    var right = nums.count - 1\\n    var left = 0\\n    \\n    var result = nums\\n    var index = right\\n    while index >= 0 {\\n        if abs(nums[left]) < abs(nums[right]) {\\n            result[index] = nums[right] * nums[right]\\n            right -= 1\\n        } else {\\n            result[index] = nums[left] * nums[left]\\n            left += 1\\n        }\\n        index -= 1\\n    }\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1592437,
                "title": "python-two-pointer-approach",
                "content": "```\\n# Two pointer approach\\nclass Solution(object):\\n    def sortedsquares(self, nums):\\n        result = [None for _ in nums]\\n        left, right = 0, len(nums)-1\\n        for i in range(len(nums)-1,-1,-1):\\n            if abs(nums[left]) > abs(nums[right]):\\n                result[i] = nums[left] ** 2\\n                left += 1\\n            else:\\n                result[i] = nums[right] ** 2\\n                right -= 1\\n        return result\\n```\\n\\n\\n```\\n# one liner solution:\\nclass Solution(object):\\n    def sortedSquares(self, nums):\\n        return sorted ([i*i for i in nums])\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\n# Two pointer approach\\nclass Solution(object):\\n    def sortedsquares(self, nums):\\n        result = [None for _ in nums]\\n        left, right = 0, len(nums)-1\\n        for i in range(len(nums)-1,-1,-1):\\n            if abs(nums[left]) > abs(nums[right]):\\n                result[i] = nums[left] ** 2\\n                left += 1\\n            else:\\n                result[i] = nums[right] ** 2\\n                right -= 1\\n        return result\\n```\n```\\n# one liner solution:\\nclass Solution(object):\\n    def sortedSquares(self, nums):\\n        return sorted ([i*i for i in nums])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1422991,
                "title": "java-two-pointer-approach-o-n-faster-than-100",
                "content": "``` class Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        \\n        if (nums == null || nums.length == 0) return nums;\\n        \\n        int len = nums.length;\\n        \\n        int result[] = new int[len];\\n        int firstPtr = 0, lastPtr = len-1;\\n        int k = len - 1;\\n        while (k >= 0) {\\n            int firstSq = nums[firstPtr] * nums[firstPtr];\\n            int lastSq = nums[lastPtr] * nums[lastPtr];\\n            \\n            if (firstSq >= lastSq) {\\n                result[k] = firstSq;\\n                firstPtr++;\\n            } else {\\n                result[k] = lastSq;\\n                lastPtr--;\\n            }\\n            \\n            k--;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "``` class Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        \\n        if (nums == null || nums.length == 0) return nums;\\n        \\n        int len = nums.length;\\n        \\n        int result[] = new int[len];\\n        int firstPtr = 0, lastPtr = len-1;\\n        int k = len - 1;\\n        while (k >= 0) {\\n            int firstSq = nums[firstPtr] * nums[firstPtr];\\n            int lastSq = nums[lastPtr] * nums[lastPtr];\\n            \\n            if (firstSq >= lastSq) {\\n                result[k] = firstSq;\\n                firstPtr++;\\n            } else {\\n                result[k] = lastSq;\\n                lastPtr--;\\n            }\\n            \\n            k--;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763982,
                "title": "c-o-n-solution",
                "content": "```\\nint* sortedSquares(int* A, int ASize, int* returnSize)\\n{\\n    int* res = (int *)malloc(sizeof(int) * ASize);\\n    *returnSize = ASize;\\n    int *pos = A + ASize - 1, *neg = A, k = ASize - 1;\\n    while (pos != neg - 1)\\n    {\\n        if (*pos >= abs(*neg))\\n        {\\n            res[k] = (*pos) * (*pos);\\n            k--;\\n            pos--;\\n        }\\n        else\\n        {\\n            res[k] = (*neg) * (*neg);\\n            k--;\\n            neg++;\\n        }\\n    }\\n    return res;\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nint* sortedSquares(int* A, int ASize, int* returnSize)\\n{\\n    int* res = (int *)malloc(sizeof(int) * ASize);\\n    *returnSize = ASize;\\n    int *pos = A + ASize - 1, *neg = A, k = ASize - 1;\\n    while (pos != neg - 1)\\n    {\\n        if (*pos >= abs(*neg))\\n        {\\n            res[k] = (*pos) * (*pos);\\n            k--;\\n            pos--;\\n        }\\n        else\\n        {\\n            res[k] = (*neg) * (*neg);\\n            k--;\\n            neg++;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 235219,
                "title": "runtime-error",
                "content": "When I execute the code follows, the error info showed like this.\\nFinished in N/A\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==29==ERROR: AddressSanitizer: SEGV on unknown address 0x180a7fff8012 (pc 0x0000004121a3 bp 0x7ffdc83ec450 sp 0x7ffdc83ec080 T0)\\n==29==The signal is caused by a READ memory access.\\n    #3 0x7fccfd9322e0 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x202e0)\\n\\nAddressSanitizer can not provide additional info.\\n==29==ABORTING\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& A) {\\n        int left = 0;\\n        int right = A.size()-1;\\n        vector <int> ans;\\n        for(int j=A.size()-1;j>=0;j--){\\n            if(A[left]*A[left]>A[right]*A[right]){\\n                ans.insert(A.begin()+j,A[left]*A[left]);\\n                left++;\\n            }\\n            else{\\n                ans.insert(A.begin()+j,A[right]*A[right]);\\n                right--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& A) {\\n        int left = 0;\\n        int right = A.size()-1;\\n        vector <int> ans;\\n        for(int j=A.size()-1;j>=0;j--){\\n            if(A[left]*A[left]>A[right]*A[right]){\\n                ans.insert(A.begin()+j,A[left]*A[left]);\\n                left++;\\n            }\\n            else{\\n                ans.insert(A.begin()+j,A[right]*A[right]);\\n                right--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 222278,
                "title": "java-3-lines-o-n-time",
                "content": "```\\n    public int[] sortedSquares(int[] A) {\\n        int[] r = new int[A.length];\\n        for(int d=A.length-1,u=0,i=d; i>=0; i--) r[i] = -A[u]>A[d] ? A[u]*A[u++] : A[d]*A[d--];\\n        return r;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] sortedSquares(int[] A) {\\n        int[] r = new int[A.length];\\n        for(int d=A.length-1,u=0,i=d; i>=0; i--) r[i] = -A[u]>A[d] ? A[u]*A[u++] : A[d]*A[d--];\\n        return r;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3101079,
                "title": "1ms-java-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int[] array = new int[nums.length];\\n        int i = 0;\\n        int j = nums.length-1;\\n        int k = nums.length-1;\\n        while(i<=j){\\n            int val1 = nums[i]*nums[i];\\n            int val2 = nums[j]*nums[j];\\n            if(val1 > val2){\\n                array[k] = val1;\\n                i++;\\n            }else{\\n                array[k] = val2;\\n                j--;\\n            }\\n            k--;\\n        }\\n        return array;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int[] array = new int[nums.length];\\n        int i = 0;\\n        int j = nums.length-1;\\n        int k = nums.length-1;\\n        while(i<=j){\\n            int val1 = nums[i]*nums[i];\\n            int val2 = nums[j]*nums[j];\\n            if(val1 > val2){\\n                array[k] = val1;\\n                i++;\\n            }else{\\n                array[k] = val2;\\n                j--;\\n            }\\n            k--;\\n        }\\n        return array;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2796230,
                "title": "2ms-solution-fully-explained-two-pointers-o-n-java",
                "content": "# Approach : Two Pointers Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity : O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Request \\uD83D\\uDE4F\\uD83D\\uDE4F:\\n- If you find this solution easy to understand and helpful.\\nThen please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n\\n# Code (Explained in comments below \\uD83D\\uDC47\\uD83D\\uDC47)\\n```\\nclass Solution \\n{\\n    public int[] sortedSquares(int[] nums) \\n    {\\n        int i=0;//pointer 1\\n        int j=nums.length-1;//pointer 2\\n        int[] arr=new int[nums.length];//new array to store sorted squares\\n        int l=nums.length-1;//index variable\\n        while(i<=j)// Create a loop until i is less than j\\n        {\\n            int sq1=nums[i]*nums[i];//square of pointer 1\\n            int sq2=nums[j]*nums[j];//square of pointer 2\\n            if(sq1<sq2)//if 1st element is smaller than last element\\n            {\\n                arr[l--]=sq2;//storing maximum value at last index\\n                j--;\\n            }\\n            else//if 1st element is greater than last element\\n            {\\n                arr[l--]=sq1;//storing minimum value at first index\\n                i++;\\n            }\\n\\n        }return arr;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int[] sortedSquares(int[] nums) \\n    {\\n        int i=0;//pointer 1\\n        int j=nums.length-1;//pointer 2\\n        int[] arr=new int[nums.length];//new array to store sorted squares\\n        int l=nums.length-1;//index variable\\n        while(i<=j)// Create a loop until i is less than j\\n        {\\n            int sq1=nums[i]*nums[i];//square of pointer 1\\n            int sq2=nums[j]*nums[j];//square of pointer 2\\n            if(sq1<sq2)//if 1st element is smaller than last element\\n            {\\n                arr[l--]=sq2;//storing maximum value at last index\\n                j--;\\n            }\\n            else//if 1st element is greater than last element\\n            {\\n                arr[l--]=sq1;//storing minimum value at first index\\n                i++;\\n            }\\n\\n        }return arr;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720654,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] A) {\\n        int n = A.length;\\n        int[] result = new int[n];\\n        int i = 0, j = n - 1;\\n        for (int p = n - 1; p >= 0; p--) {\\n            if (Math.abs(A[i]) > Math.abs(A[j])) {\\n                result[p] = A[i] * A[i];\\n                i++;\\n            } else {\\n                result[p] = A[j] * A[j];\\n                j--;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] A) {\\n        int n = A.length;\\n        int[] result = new int[n];\\n        int i = 0, j = n - 1;\\n        for (int p = n - 1; p >= 0; p--) {\\n            if (Math.abs(A[i]) > Math.abs(A[j])) {\\n                result[p] = A[i] * A[i];\\n                i++;\\n            } else {\\n                result[p] = A[j] * A[j];\\n                j--;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2254389,
                "title": "3-approaches-clean-and-concise-code-two-pointers-c",
                "content": "Here, I will be discussing 3 approaches to this problem.\\n\\n**Approach 1: Using Sorting**\\n\\nThe simplest solution would be just using built-in sort function and you can say it would work by squaring the elements in-place (over-writing) them and finally sorting it.\\n\\n```\\n\\t\\tint n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i]=pow(nums[i],2);\\n        }\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n```\\n\\n**Time Complexity: O(nlogn)**\\n**Space Complexity: O(1)**\\n\\n\\n**Approach 2: Two Pointers - 1**\\n\\nLet\\'s take an example with negative and positive numbers, like:\\n\\n[-4, -2, 0, 1, 3]\\n\\nSince, we need to put squares in result array, we can consider that all numbers are positive (since: -4 ** 2 = 4 ** 2 = 16). Now our array looks like it sorted from middle to outside on both sides:\\n\\n[4, 2, 0, 1, 3]\\n\\nNow, we can have two pointers \"left\" to left most element, \"right\" to the right most element.\\nCreate \"res\" result array with the same size as A.\\nMove from right to left in res and check max(abs(A[l]), abs(A[r])), then correspondingly move left++ or right--.\\n\\n\\n```\\n\\t\\tint n=nums.size();\\n        vector<int> res(n);\\n        int left=0;\\n        int right=n-1;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(abs(nums[left])>abs(nums[right])) res[i]=nums[left]*nums[left++];\\n            else res[i]=nums[right]*nums[right--];\\n        }\\n        return res;\\n```\\n\\n**Time Complexity: O(n)**\\n**Space Complexity: O(n)**\\n\\n**Approach 3: Two Pointers - 2**\\nFirstly, why another two pointers approach? \\n\\nWell, after a bit of thinking you may notice that after squaring numbers, firstly, all negative numbers which are big would go further away from zero and negative numbers smaller relatively would meet at zero with the positive numbers.\\n\\nNow, the same goes with the case of positive numbers squared. Thus, it is a natural solution of merging two sorted lists from the middle will do. Just use two pointers that go from the middle outwards. This is intutitive and really easy to undertsand.\\n\\n```\\n\\t\\t//Two Pointers-2\\n        int n=nums.size();\\n        vector<int> res(n);\\n        int p=0;\\n        while(p<n && nums[p]<0) p++;\\n        int neg=p-1;\\n        int i;\\n        for(i=0;neg>=0 && p<n;i++)\\n        {\\n            if(nums[neg]*nums[neg]<nums[p]*nums[p]) res[i]=nums[neg]*nums[neg--];\\n            else res[i]=nums[p]*nums[p++];\\n        }\\n\\t\\t//For leftover positive elements\\n        for(;p<n;i++)\\n            res[i]=nums[p]*nums[p++];\\n\\t\\t\\n\\t\\t//For leftover negative elements\\n        for(;neg>=0;i++)\\n            res[i]=nums[neg]*nums[neg--];\\n        \\n\\t\\treturn res;\\n\\n```\\n**Time Complexity: O(n)**\\n**Space Complexity: O(n)**\\n\\n**Please upvote this solution if you liked it! \\uD83D\\uDE00\\u270C\\uFE0F**",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\n\\t\\tint n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i]=pow(nums[i],2);\\n        }\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n```\n```\\n\\t\\tint n=nums.size();\\n        vector<int> res(n);\\n        int left=0;\\n        int right=n-1;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(abs(nums[left])>abs(nums[right])) res[i]=nums[left]*nums[left++];\\n            else res[i]=nums[right]*nums[right--];\\n        }\\n        return res;\\n```\n```\\n\\t\\t//Two Pointers-2\\n        int n=nums.size();\\n        vector<int> res(n);\\n        int p=0;\\n        while(p<n && nums[p]<0) p++;\\n        int neg=p-1;\\n        int i;\\n        for(i=0;neg>=0 && p<n;i++)\\n        {\\n            if(nums[neg]*nums[neg]<nums[p]*nums[p]) res[i]=nums[neg]*nums[neg--];\\n            else res[i]=nums[p]*nums[p++];\\n        }\\n\\t\\t//For leftover positive elements\\n        for(;p<n;i++)\\n            res[i]=nums[p]*nums[p++];\\n\\t\\t\\n\\t\\t//For leftover negative elements\\n        for(;neg>=0;i++)\\n            res[i]=nums[neg]*nums[neg--];\\n        \\n\\t\\treturn res;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2013937,
                "title": "two-pointers-and-one-liner-approach-python",
                "content": "**One Liner Approach**\\n```\\nreturn sorted(i*i for i in nums)\\n```\\n\\n**Two Pointers Approach**\\n```\\n        n = len(nums)\\n        result = [0] * n\\n        left = 0\\n        right = n - 1\\n        for i in range(n - 1, -1, -1):\\n            if abs(nums[left]) < abs(nums[right]):\\n                square = nums[right]\\n                right -= 1\\n            else:\\n                square = nums[left]\\n                left += 1\\n            result[i] = square * square\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nreturn sorted(i*i for i in nums)\\n```\n```\\n        n = len(nums)\\n        result = [0] * n\\n        left = 0\\n        right = n - 1\\n        for i in range(n - 1, -1, -1):\\n            if abs(nums[left]) < abs(nums[right]):\\n                square = nums[right]\\n                right -= 1\\n            else:\\n                square = nums[left]\\n                left += 1\\n            result[i] = square * square\\n        return result\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1791585,
                "title": "python-solution",
                "content": "Here\\'s my solution:\\n```\\n# Runtime: 329 ms, faster than 46.92% of Python3 online submissions for Squares of a Sorted Array.\\n# Memory Usage: 16.3 MB, less than 40.77% of Python3 online submissions for Squares of a Sorted Array.\\nclass Solution:\\n    def sortedSquares(self, nums):\\n        i, j, n = 0, len(nums)-1, len(nums)-1\\n        result = [0 for _ in range(len(nums))]\\n        while n>=0:\\n            if abs(nums[i])>abs(nums[j]):\\n                result[n] = nums[i]**2\\n                i += 1\\n            else:\\n                result[n] = nums[j]**2\\n                j -= 1\\n            n -= 1\\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Runtime: 329 ms, faster than 46.92% of Python3 online submissions for Squares of a Sorted Array.\\n# Memory Usage: 16.3 MB, less than 40.77% of Python3 online submissions for Squares of a Sorted Array.\\nclass Solution:\\n    def sortedSquares(self, nums):\\n        i, j, n = 0, len(nums)-1, len(nums)-1\\n        result = [0 for _ in range(len(nums))]\\n        while n>=0:\\n            if abs(nums[i])>abs(nums[j]):\\n                result[n] = nums[i]**2\\n                i += 1\\n            else:\\n                result[n] = nums[j]**2\\n                j -= 1\\n            n -= 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1701883,
                "title": "easy-to-understand-solution-with-comments-explaination",
                "content": "If this solution helps please consider upvoting\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n//         This takes O(N) time\\n//         declare a new vector\\n        vector<int> res(nums.size());\\n//         two pointer taken for sorting\\n        int left=0,right=nums.size()-1;\\n//         start from the last \\n        for(int i =nums.size()-1;i>=0;i--){\\n//             used abs because we know array is sorted to all negative numbers will be on the left\\n            if(abs(nums[left])>nums[right]){\\n                res[i]=nums[left]*nums[left];\\n                left++;\\n            }\\n//             else we add the last element\\n            else{\\n                res[i]=nums[right]*nums[right];\\n                right--;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n//         This takes O(N) time\\n//         declare a new vector\\n        vector<int> res(nums.size());\\n//         two pointer taken for sorting\\n        int left=0,right=nums.size()-1;\\n//         start from the last \\n        for(int i =nums.size()-1;i>=0;i--){\\n//             used abs because we know array is sorted to all negative numbers will be on the left\\n            if(abs(nums[left])>nums[right]){\\n                res[i]=nums[left]*nums[left];\\n                left++;\\n            }\\n//             else we add the last element\\n            else{\\n                res[i]=nums[right]*nums[right];\\n                right--;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678024,
                "title": "python-o-n-solution",
                "content": "```\\ndef sortedSquares(self, nums: List[int]) -> List[int]:\\n        lowIndex=0\\n        highIndex=len(nums)-1\\n        Index=len(nums)-1\\n        a=[0]*len(nums)\\n        while(lowIndex<=highIndex):\\n            if(abs(nums[lowIndex])>=abs(nums[highIndex])):\\n                a[Index]=nums[lowIndex]*nums[lowIndex]\\n                lowIndex+=1\\n            else:\\n                a[Index]=nums[highIndex]*nums[highIndex]\\n                highIndex-=1\\n            Index-=1\\n        return a\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\ndef sortedSquares(self, nums: List[int]) -> List[int]:\\n        lowIndex=0\\n        highIndex=len(nums)-1\\n        Index=len(nums)-1\\n        a=[0]*len(nums)\\n        while(lowIndex<=highIndex):\\n            if(abs(nums[lowIndex])>=abs(nums[highIndex])):\\n                a[Index]=nums[lowIndex]*nums[lowIndex]\\n                lowIndex+=1\\n            else:\\n                a[Index]=nums[highIndex]*nums[highIndex]\\n                highIndex-=1\\n            Index-=1\\n        return a\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1627809,
                "title": "simple-java-solution-o-n-time",
                "content": "**Upvote if you Got It** \\uD83D\\uDE42\\nclass Solution {\\n\\n    public int[] sortedSquares(int[] nums) {\\n        int l=0,r=nums.length-1,k=r;\\n        int[] res = new int[nums.length];\\n        while(l<=r){\\n            if(Math.abs(nums[l])>Math.abs(nums[r])){\\n                res[k]=nums[l]*nums[l];\\n                l++;\\n            }\\n            else{\\n                res[k]=nums[r]*nums[r];\\n                r--;\\n            }\\n            k--;\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n\\n    public int[] sortedSquares(int[] nums) {\\n        int l=0,r=nums.length-1,k=r;\\n        int[] res = new int[nums.length];\\n        while(l<=r){\\n            if(Math.abs(nums[l])>Math.abs(nums[r])){\\n                res[k]=nums[l]*nums[l];\\n                l++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1413346,
                "title": "java-solution-from-pratik",
                "content": "**Solution 1: Sorting Approach**\\n\\n**Algorithm**:\\n1. Create an array of the squares of each element\\n1. Sort the array of squares.\\n\\n**Time Complexity**: `O(N log N)`, where `N` is the length of input array.\\n**Space complexity**: `O(log N)` In Java, the Arrays.sort() is implemented as a variant of quicksort algorithm whose space complexity is `O(log N)`.\\n\\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] A) {\\n        int[] result = new int[A.length];\\n        \\n        for (int i = 0; i < A.length; i++) {\\n            result[i] = A[i] * A[i];\\n        }\\n        \\n        Arrays.sort(result);\\n        return result;\\n    }\\n}\\n```\\n\\n**Solution 2: Two Pointer Approach**\\n\\n**Intuition**:\\n- Since the array `A` is sorted, loosely speaking it has some negative elements with squares in decreasing order, then some positive elements with squares in increasing order.\\n- For example, with `[-3, -2, -1, 4, 5, 6]`, we have the negative part `[-3, -2, -1]` with squares `[9, 4, 1]`, and the positive part `[4, 5, 6]` with squares `[16, 25, 36]`\\n- Now, this is a variant of merging two sorted arrays.\\n\\n**Algorithm**:\\n1. We can use two pointers, one at each end, to iteratively collect the larger square to the result array.\\n\\n**Time Complexity**: `O(N)`, where `N` is the length of input array.\\n**Space Complexity**: `O(N)` if we consider the space required for result array and `O(1)` otherwise.\\n\\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] A) {\\n        int[] result = new int[A.length];\\n        int start = 0;\\n        int end = A.length - 1;\\n\\n        for (int i = A.length - 1; i >= 0; i--) {\\n            if (Math.abs(A[start]) < Math.abs(A[end])) {\\n                result[i] = A[end] * A[end];\\n                end--;\\n            } else {\\n                result[i] = A[start] * A[start];\\n                start++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] A) {\\n        int[] result = new int[A.length];\\n        \\n        for (int i = 0; i < A.length; i++) {\\n            result[i] = A[i] * A[i];\\n        }\\n        \\n        Arrays.sort(result);\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] A) {\\n        int[] result = new int[A.length];\\n        int start = 0;\\n        int end = A.length - 1;\\n\\n        for (int i = A.length - 1; i >= 0; i--) {\\n            if (Math.abs(A[start]) < Math.abs(A[end])) {\\n                result[i] = A[end] * A[end];\\n                end--;\\n            } else {\\n                result[i] = A[start] * A[start];\\n                start++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1160450,
                "title": "python-stack-o-n-memory-o-n",
                "content": "Traverse the array nums once.\\nFor elements which are negative, just append them to the stack, and once you start encountering non-negative elements, start clearing the stack by comparing current element to last value in stack and then appending the squared value to output accordingly. \\nFinally, if all elements have been seen in nums, start clearing stack by appending squared value to output. \\n\\n```\\nclass Solution(object):\\n    def sortedSquares(self, nums):\\n        stack = []\\n        output = []\\n        for i in range(len(nums)):\\n            if nums[i] < 0:\\n                stack.append(-nums[i])\\n            else:\\n                while stack and stack[-1] < nums[i]:\\n                    output.append(stack.pop() ** 2)\\n                output.append(nums[i] ** 2)\\n        while stack:\\n            output.append(stack.pop() ** 2)\\n        return output\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution(object):\\n    def sortedSquares(self, nums):\\n        stack = []\\n        output = []\\n        for i in range(len(nums)):\\n            if nums[i] < 0:\\n                stack.append(-nums[i])\\n            else:\\n                while stack and stack[-1] < nums[i]:\\n                    output.append(stack.pop() ** 2)\\n                output.append(nums[i] ** 2)\\n        while stack:\\n            output.append(stack.pop() ** 2)\\n        return output\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1088214,
                "title": "kotlin-simple",
                "content": "Two pointers approach:\\n```\\n    fun sortedSquares(nums: IntArray): IntArray {\\n        val arr = IntArray(nums.size)\\n        var l = 0\\n        var r = nums.lastIndex\\n        var i = arr.lastIndex\\n        while (l <= r) {\\n            if (nums[l] * nums[l] > nums[r] * nums[r]) {\\n                arr[i] = nums[l] * nums[l]\\n                l++\\n            } else {\\n                arr[i] = nums[r] * nums[r]\\n                r--\\n            }\\n            i--\\n        }\\n        arr[0] = nums[l] * nums[l]\\n\\n        return arr\\n    }\\n```\\n\\nNaive approach:\\n```\\nfun sortedSquares(nums: IntArray) = nums.map { it * it }.sorted().toIntArray()\\n```\\n",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n    fun sortedSquares(nums: IntArray): IntArray {\\n        val arr = IntArray(nums.size)\\n        var l = 0\\n        var r = nums.lastIndex\\n        var i = arr.lastIndex\\n        while (l <= r) {\\n            if (nums[l] * nums[l] > nums[r] * nums[r]) {\\n                arr[i] = nums[l] * nums[l]\\n                l++\\n            } else {\\n                arr[i] = nums[r] * nums[r]\\n                r--\\n            }\\n            i--\\n        }\\n        arr[0] = nums[l] * nums[l]\\n\\n        return arr\\n    }\\n```\n```\\nfun sortedSquares(nums: IntArray) = nums.map { it * it }.sorted().toIntArray()\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 973317,
                "title": "c-two-pointers-moving-from-both-ends",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        const int n = nums.size();\\n        vector<int> ans(n);\\n        int l = 0, r = n - 1, idx = n - 1;\\n        while(l<=r){\\n            if(nums[l]*nums[l] < nums[r] * nums[r]){\\n                ans[idx--] = nums[r] * nums[r];\\n                r--;\\n            }else{\\n                ans[idx--] = nums[l] * nums[l];\\n                l++;\\n            }\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        const int n = nums.size();\\n        vector<int> ans(n);\\n        int l = 0, r = n - 1, idx = n - 1;\\n        while(l<=r){\\n            if(nums[l]*nums[l] < nums[r] * nums[r]){\\n                ans[idx--] = nums[r] * nums[r];\\n                r--;\\n            }else{\\n                ans[idx--] = nums[l] * nums[l];\\n                l++;\\n            }\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 972966,
                "title": "squares-of-a-sorted-array-java-o-n-two-pointer-solution",
                "content": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int n = nums.length, i= 0, j = n-1, idx = n-1;\\n        \\n        int[] ans = new int[n];\\n        \\n        while(idx >= 0){\\n            if(Math.abs(nums[i]) > Math.abs(nums[j])){\\n                ans[idx] = nums[i]*nums[i];\\n                i++;\\n            }else{\\n                ans[idx] = nums[j]*nums[j];\\n                j--;\\n            } \\n            idx--;\\n        }\\n        \\n        return ans;   \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int n = nums.length, i= 0, j = n-1, idx = n-1;\\n        \\n        int[] ans = new int[n];\\n        \\n        while(idx >= 0){\\n            if(Math.abs(nums[i]) > Math.abs(nums[j])){\\n                ans[idx] = nums[i]*nums[i];\\n                i++;\\n            }else{\\n                ans[idx] = nums[j]*nums[j];\\n                j--;\\n            } \\n            idx--;\\n        }\\n        \\n        return ans;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763999,
                "title": "c-solution",
                "content": "\\n```\\nclass Solution \\n{\\npublic:\\n    vector<int> sortedSquares(vector<int>& A)\\n\\t{\\n        vector<int> res;\\n        int i_negative, i_positive;\\n        \\n        for (i_positive = 0; i_positive < A.size() && A[i_positive] < 0; i_positive++);\\n        i_negative = i_positive - 1;\\n        \\n        while (i_negative >= 0 && i_positive < A.size()) \\n\\t\\t{\\n            if (-A[i_negative] <= A[i_positive])\\n                res.push_back(pow(A[i_negative--], 2));\\n            else\\n                res.push_back(pow(A[i_positive++], 2));\\n        }\\n        \\n        if (res.size() < A.size()) \\n\\t\\t{\\n            while (i_negative >= 0)\\n                res.push_back(pow(A[i_negative--], 2));\\n            while (i_positive < A.size())\\n                res.push_back(pow(A[i_positive++], 2));\\n        }\\n        return res;\\n    }\\n};\\n\\nstatic auto _______ = []()\\n{\\n    // turn off sync\\n    std::ios::sync_with_stdio(false);\\n    // untie in/out streams\\n    std::cin.tie(nullptr);\\n    return 0;\\n}();\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> sortedSquares(vector<int>& A)\\n\\t{\\n        vector<int> res;\\n        int i_negative, i_positive;\\n        \\n        for (i_positive = 0; i_positive < A.size() && A[i_positive] < 0; i_positive++);\\n        i_negative = i_positive - 1;\\n        \\n        while (i_negative >= 0 && i_positive < A.size()) \\n\\t\\t{\\n            if (-A[i_negative] <= A[i_positive])\\n                res.push_back(pow(A[i_negative--], 2));\\n            else\\n                res.push_back(pow(A[i_positive++], 2));\\n        }\\n        \\n        if (res.size() < A.size()) \\n\\t\\t{\\n            while (i_negative >= 0)\\n                res.push_back(pow(A[i_negative--], 2));\\n            while (i_positive < A.size())\\n                res.push_back(pow(A[i_positive++], 2));\\n        }\\n        return res;\\n    }\\n};\\n\\nstatic auto _______ = []()\\n{\\n    // turn off sync\\n    std::ios::sync_with_stdio(false);\\n    // untie in/out streams\\n    std::cin.tie(nullptr);\\n    return 0;\\n}();\\n```",
                "codeTag": "Java"
            },
            {
                "id": 557344,
                "title": "kotlin-o-n-95-time-100-space",
                "content": "```kotlin\\nclass Solution {\\n    fun sortedSquares(A: IntArray): IntArray {\\n        \\n        // Create markers to use to navigate inward since we know that\\n        // the polar ends are (possibly, but not always) the largest\\n        var leftMarker = 0\\n        var rightMarker = A.size - 1\\n        \\n        // Create a marker to track insertions into the new array\\n        var resultIndex = A.size - 1\\n        val result = IntArray(A.size)\\n        \\n        // Iterate over the items until the markers reach each other.\\n        // Its likely a little faster to consider the case where the left\\n        // marker is no longer producing elements that are less than zero.\\n        while (leftMarker <= rightMarker) {\\n            // Grab the absolute values of the elements at the respective\\n            // markers so they can be compared and inserted into the right\\n            // index.\\n            val left = Math.abs(A[leftMarker])\\n            val right = Math.abs(A[rightMarker])\\n            \\n            // Do checks to decide which item to insert next.\\n            result[resultIndex] = if (right > left) {\\n                rightMarker--\\n                right * right\\n            } else {\\n                leftMarker++\\n                left * left\\n            }\\n            \\n            // Once the item is inserted we can update the index we want\\n            // to insert at next.\\n            resultIndex--\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```kotlin\\nclass Solution {\\n    fun sortedSquares(A: IntArray): IntArray {\\n        \\n        // Create markers to use to navigate inward since we know that\\n        // the polar ends are (possibly, but not always) the largest\\n        var leftMarker = 0\\n        var rightMarker = A.size - 1\\n        \\n        // Create a marker to track insertions into the new array\\n        var resultIndex = A.size - 1\\n        val result = IntArray(A.size)\\n        \\n        // Iterate over the items until the markers reach each other.\\n        // Its likely a little faster to consider the case where the left\\n        // marker is no longer producing elements that are less than zero.\\n        while (leftMarker <= rightMarker) {\\n            // Grab the absolute values of the elements at the respective\\n            // markers so they can be compared and inserted into the right\\n            // index.\\n            val left = Math.abs(A[leftMarker])\\n            val right = Math.abs(A[rightMarker])\\n            \\n            // Do checks to decide which item to insert next.\\n            result[resultIndex] = if (right > left) {\\n                rightMarker--\\n                right * right\\n            } else {\\n                leftMarker++\\n                left * left\\n            }\\n            \\n            // Once the item is inserted we can update the index we want\\n            // to insert at next.\\n            resultIndex--\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 520334,
                "title": "javascript-two-pointers-o-n",
                "content": "```\\n/**\\n * @param {number[]} A\\n * @return {number[]}\\n */\\nvar sortedSquares = function(A) {\\n    if (A.length < 2) // Early exit if the array only has less than two element.\\n        return [ Math.pow(A[0], 2) ];\\n    \\n    const newArray = [];\\n    let i = 0;\\n    let j = A.length - 1;\\n    \\n    while (i <= j) {\\n        const left = Math.pow(A[i], 2); // Square the number to obtain positive value. e.g. -2**2 = 4\\n        const right = Math.pow(A[j], 2); // Square the number to obtain positive value. e.g. 4**2 = 16\\n         \\n        if (left >= right) { // If left is bigger or equal than the right add that as the first position of the array\\n            newArray.unshift(left);\\n            i++;\\n        } else { // If the right is bigger than the left add that as the first position of the array\\n            newArray.unshift(right);\\n            j--;\\n        }\\n    } // It will traverse the array only once, since if you combine i and j the two pointers will meet in a middle point,\\n    \\n    return newArray;\\n    \\n    /**\\n    * Use two pointers to compare each end since we know that they are the highest numbers when squared.\\n    * Time Complexity: O(n)\\n    * Space Complexity: O(n)\\n    **/\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * @param {number[]} A\\n * @return {number[]}\\n */\\nvar sortedSquares = function(A) {\\n    if (A.length < 2) // Early exit if the array only has less than two element.\\n        return [ Math.pow(A[0], 2) ];\\n    \\n    const newArray = [];\\n    let i = 0;\\n    let j = A.length - 1;\\n    \\n    while (i <= j) {\\n        const left = Math.pow(A[i], 2); // Square the number to obtain positive value. e.g. -2**2 = 4\\n        const right = Math.pow(A[j], 2); // Square the number to obtain positive value. e.g. 4**2 = 16\\n         \\n        if (left >= right) { // If left is bigger or equal than the right add that as the first position of the array\\n            newArray.unshift(left);\\n            i++;\\n        } else { // If the right is bigger than the left add that as the first position of the array\\n            newArray.unshift(right);\\n            j--;\\n        }\\n    } // It will traverse the array only once, since if you combine i and j the two pointers will meet in a middle point,\\n    \\n    return newArray;\\n    \\n    /**\\n    * Use two pointers to compare each end since we know that they are the highest numbers when squared.\\n    * Time Complexity: O(n)\\n    * Space Complexity: O(n)\\n    **/\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 359123,
                "title": "golang-solution",
                "content": "when see sorted   we usually thought two pointer\\n```\\nfunc sortedSquares(A []int) []int {\\n\\tret := make([]int, len(A))\\n\\tleft, right := 0, len(A)-1\\n\\tfor i := len(A)-1; i >= 0; i-- {\\n        if math.Abs(float64(A[left])) < math.Abs(float64(A[right])) {\\n\\t\\t\\tret[i] = A[right] * A[right]\\n            right--\\n\\t\\t} else {\\n\\t\\t\\tret[i] = A[left] * A[left]\\n            left++\\n\\t\\t}\\n\\t}\\n\\n\\treturn ret\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc sortedSquares(A []int) []int {\\n\\tret := make([]int, len(A))\\n\\tleft, right := 0, len(A)-1\\n\\tfor i := len(A)-1; i >= 0; i-- {\\n        if math.Abs(float64(A[left])) < math.Abs(float64(A[right])) {\\n\\t\\t\\tret[i] = A[right] * A[right]\\n            right--\\n\\t\\t} else {\\n\\t\\t\\tret[i] = A[left] * A[left]\\n            left++\\n\\t\\t}\\n\\t}\\n\\n\\treturn ret\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 226469,
                "title": "go-two-pointers-without-finding-first-positive-number",
                "content": "The idea is than we can go down from both ends and collecting result array in descending order.\\n\\n```go\\nfunc sortedSquares(A []int) []int {\\n    length := len(A)\\n    res := make([]int, length)\\n    i, j := 0, length - 1\\n    \\n    for z := length - 1; z >= 0; z-- {\\n        sq1, sq2 := A[i]*A[i], A[j]* A[j]\\n        \\n        if sq1 > sq2 {\\n            res[z] = sq1\\n            i++\\n        } else {\\n            res[z] = sq2\\n            j--\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc sortedSquares(A []int) []int {\\n    length := len(A)\\n    res := make([]int, length)\\n    i, j := 0, length - 1\\n    \\n    for z := length - 1; z >= 0; z-- {\\n        sq1, sq2 := A[i]*A[i], A[j]* A[j]\\n        \\n        if sq1 > sq2 {\\n            res[z] = sq1\\n            i++\\n        } else {\\n            res[z] = sq2\\n            j--\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 224554,
                "title": "c-1-line",
                "content": "```\\npublic class Solution {\\n    public int[] SortedSquares(int[] A) {\\n        return A.Select(a => a * a).OrderBy(b => b).ToArray();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] SortedSquares(int[] A) {\\n        return A.Select(a => a * a).OrderBy(b => b).ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3243882,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        for(int i=0;i<nums.length;i++){\\n            nums[i] = nums[i]*nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        for(int i=0;i<nums.length;i++){\\n            nums[i] = nums[i]*nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3129573,
                "title": "tc-o-n-sc-o-1-two-pointer-approach-easy-understanding-beats-90-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->Only focusing on Mangnitude for -ve numbers\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        vector<int> ans;\\n       int i=-1,j=0;\\n       for(int k=0;k<nums.size();k++){\\n           if(nums[k]<0) i=k;\\n       }\\n       j=i+1;\\n        \\n        while(i>=0 && j<nums.size()){\\n            if(-1*nums[i]>=nums[j]){\\n                ans.push_back(nums[j]*nums[j]); j++;\\n            }\\n            else {\\n                ans.push_back(nums[i]*nums[i]); i--;\\n            }\\n        }\\n        while(j<nums.size()){\\n            ans.push_back(nums[j]*nums[j]); j++;\\n        }\\n        while(i>=0){\\n            ans.push_back(nums[i]*nums[i]); i--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        vector<int> ans;\\n       int i=-1,j=0;\\n       for(int k=0;k<nums.size();k++){\\n           if(nums[k]<0) i=k;\\n       }\\n       j=i+1;\\n        \\n        while(i>=0 && j<nums.size()){\\n            if(-1*nums[i]>=nums[j]){\\n                ans.push_back(nums[j]*nums[j]); j++;\\n            }\\n            else {\\n                ans.push_back(nums[i]*nums[i]); i--;\\n            }\\n        }\\n        while(j<nums.size()){\\n            ans.push_back(nums[j]*nums[j]); j++;\\n        }\\n        while(i>=0){\\n            ans.push_back(nums[i]*nums[i]); i--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2905692,
                "title": "simple-python3-two-pointer-easy-to-understand-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse two pointers to start from edges of sorted list. Since 0 is the smallest value and we have the potential to have negative and positive numbers that need to be interwoven, we can take advantage of the sorted list by having a left and right (l, r) pointers. Then we can see if the element at l or r has a larger absolute value (which implies larger square value) and fill in res so that it descends in squared value. The idea is to start from the wings of the nums list and center down to 0, which would thus give you a sorted decreasing list of squares. Then since the problem asks for increasing, just reverse the list at the end. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$ where $$N$$ is the length of nums. \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$ where $$N$$ is the length of nums. \\n\\n# Code\\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        l, r = 0, len(nums)-1\\n        res = []\\n\\n        while l <= r:\\n            if abs(nums[l]) >= abs(nums[r]):\\n                res.append(nums[l] ** 2)\\n                l += 1\\n            else:\\n                res.append(nums[r] ** 2)\\n                r -= 1\\n        return reversed(res)\\n\\n```\\n\\nThanks for taking a look at my solution, and feel free to let me know if I can improve anything :)",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        l, r = 0, len(nums)-1\\n        res = []\\n\\n        while l <= r:\\n            if abs(nums[l]) >= abs(nums[r]):\\n                res.append(nums[l] ** 2)\\n                l += 1\\n            else:\\n                res.append(nums[r] ** 2)\\n                r -= 1\\n        return reversed(res)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2319821,
                "title": "python-o-n-solution-explained",
                "content": "#### **Final Code:**\\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        result = []        \\n        left, right = 0, len(nums) - 1\\n        \\n        while left <= right:\\n            \\n            if nums[left] ** 2 < nums[right] ** 2:\\n                result.append(nums[right] ** 2)\\n                right -= 1\\n                \\n            else:\\n                result.append(nums[left] ** 2)\\n                left += 1\\n            \\n        return result[::-1]\\n```\\n\\n#### **Steps:**\\n* **Step1:**  \\nCreate an empty array to store the squared values.\\n```result = []```\\n\\n* **Step2:**  \\nInitialize our 2 pointers: left and right, and set them equal to the first and last index\\n                      positions of the array.\\n```left, right = 0, len(nums) - 1```\\n\\n* **Step3:** \\nWe can run a while loop and continue till our left pointer is greater than the right pointer.\\nmeaning till they cross each other in the array\\n```while left <= right:```\\n\\n* **Step4:**  \\nIf the square of the number on the right is greater than the square of the left number then\\nappend it to the result array and **decrease** the right pointer \\nOr\\nappend the left square and **increase** the left pointer.\\n```\\n            if nums[left] ** 2 < nums[right] ** 2:\\n                result.append(nums[right] ** 2)\\n                right -= 1\\n                \\n            else:\\n                result.append(nums[left] ** 2)\\n                left += 1\\n```\\n* **Step5:**  \\nAfter this we will end up with the result array but it is in descending order.\\nTo make it in ascending order we can just reverse it like:\\n```return result[::-1]```\\n\\n**And we have conquered this problem: Squares of Sorted Array \\uD83E\\uDD13**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        result = []        \\n        left, right = 0, len(nums) - 1\\n        \\n        while left <= right:\\n            \\n            if nums[left] ** 2 < nums[right] ** 2:\\n                result.append(nums[right] ** 2)\\n                right -= 1\\n                \\n            else:\\n                result.append(nums[left] ** 2)\\n                left += 1\\n            \\n        return result[::-1]\\n```\n```result = []```\n```left, right = 0, len(nums) - 1```\n```while left <= right:```\n```\\n            if nums[left] ** 2 < nums[right] ** 2:\\n                result.append(nums[right] ** 2)\\n                right -= 1\\n                \\n            else:\\n                result.append(nums[left] ** 2)\\n                left += 1\\n```\n```return result[::-1]```",
                "codeTag": "Java"
            },
            {
                "id": 2123293,
                "title": "c-using-stack",
                "content": "**Using stack :** We are pushing squared (sq) values of elements in stack , push the current sq value if stack top is greater then sq else pop from stack till stack top is greater then the sq and simultaneously put that sq in result (vector). \\n\\n```\\n vector<int> sortedSquares(vector<int>& nums) {\\n        stack<int> st;\\n        vector<int> res;\\n        \\n        for(int i=0 ; i<nums.size() ; i++){\\n            int sq = nums[i] * nums[i];\\n\\t\\t\\t\\n\\t\\t\\t// if sq is less then the top of stack then push sq in the stack\\n            if(st.size() == 0 || st.top() >= sq ){\\n                st.push(sq);\\n            }\\n\\t\\t\\t// else store the top of stack in res and pop from the stack till stack top is greater then the sq\\n            else{\\n                while(st.size() > 0 && st.top() < sq){\\n                    res.push_back(st.top());\\n                    st.pop();     \\n                }\\n                st.push(sq);\\n            }\\n        }\\n\\t\\t// if stack is not empty push all elements in res\\n        while(st.size() > 0){\\n            res.push_back(st.top());\\n            st.pop(); \\n        }\\n        return res;\\n    }\\n\\t\\n```\\t\\nIf you like the solution , do **UPVOTE**.\\nFeel free to ask any doubts in the comment section.",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\n vector<int> sortedSquares(vector<int>& nums) {\\n        stack<int> st;\\n        vector<int> res;\\n        \\n        for(int i=0 ; i<nums.size() ; i++){\\n            int sq = nums[i] * nums[i];\\n\\t\\t\\t\\n\\t\\t\\t// if sq is less then the top of stack then push sq in the stack\\n            if(st.size() == 0 || st.top() >= sq ){\\n                st.push(sq);\\n            }\\n\\t\\t\\t// else store the top of stack in res and pop from the stack till stack top is greater then the sq\\n            else{\\n                while(st.size() > 0 && st.top() < sq){\\n                    res.push_back(st.top());\\n                    st.pop();     \\n                }\\n                st.push(sq);\\n            }\\n        }\\n\\t\\t// if stack is not empty push all elements in res\\n        while(st.size() > 0){\\n            res.push_back(st.top());\\n            st.pop(); \\n        }\\n        return res;\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2112476,
                "title": "python3-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        \\n        l, r = 0, n - 1\\n        res = []\\n        while l <= r:\\n            if abs(nums[r]) > abs(nums[l]):\\n                res.append(nums[r] * nums[r])\\n                r -= 1\\n            else:\\n                res.append(nums[l] * nums[l])\\n                l += 1\\n                \\n        return res[::-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        \\n        l, r = 0, n - 1\\n        res = []\\n        while l <= r:\\n            if abs(nums[r]) > abs(nums[l]):\\n                res.append(nums[r] * nums[r])\\n                r -= 1\\n            else:\\n                res.append(nums[l] * nums[l])\\n                l += 1\\n                \\n        return res[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083247,
                "title": "java-two-pointers",
                "content": "\\'\\'\\'\\n\\n\\t\\tint i=0,j=nums.length-1;\\n        int[] ans=new int[nums.length];\\n        for(int k=nums.length-1;k>=0;k--)\\n        {\\n            if(Math.abs(nums[i])>Math.abs(nums[j]))\\n            {\\n                ans[k]=(int)Math.pow(nums[i],2);\\n                i++;\\n            }\\n            else\\n            {\\n                ans[k]=(int)Math.pow(nums[j],2);\\n                j--;\\n            }\\n        }\\n        return ans;\\n\\t\\t\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "\\'\\'\\'\\n\\n\\t\\tint i=0,j=nums.length-1;\\n        int[] ans=new int[nums.length];\\n        for(int k=nums.length-1;k>=0;k--)\\n        {\\n            if(Math.abs(nums[i])>Math.abs(nums[j]))\\n            {\\n                ans[k]=(int)Math.pow(nums[i],2);\\n                i++;\\n            }\\n            else\\n            {\\n                ans[k]=(int)Math.pow(nums[j],2);\\n                j--;\\n            }\\n        }\\n        return ans;\\n\\t\\t\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1934797,
                "title": "my-java-o-n-solution-beats-100-submissions",
                "content": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int[] sol = new int[nums.length];\\n        int i=0,j=nums.length-1;\\n        for (int k=sol.length-1;k>=0;k--){\\n            if (Math.abs(nums[i])>Math.abs(nums[j])){\\n                sol[k] = nums[i]*nums[i];\\n                i++;\\n            }else {\\n                sol[k] = nums[j]*nums[j];\\n                j--;\\n            }\\n        }\\n        return sol;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int[] sol = new int[nums.length];\\n        int i=0,j=nums.length-1;\\n        for (int k=sol.length-1;k>=0;k--){\\n            if (Math.abs(nums[i])>Math.abs(nums[j])){\\n                sol[k] = nums[i]*nums[i];\\n                i++;\\n            }else {\\n                sol[k] = nums[j]*nums[j];\\n                j--;\\n            }\\n        }\\n        return sol;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1882625,
                "title": "python3-two-pointer-approach",
                "content": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        start,end = 0, len(nums)-1\\n        result  = [0] * (end+1)\\n        index = end\\n        while index>=0:\\n            startElementSquare, endElementSquare = nums[start]**2, nums[end]**2\\n            if(endElementSquare > startElementSquare):\\n                result[index] = endElementSquare\\n                end -= 1\\n            else:\\n                result[index] = startElementSquare\\n                start+=1\\n            index-=1\\n        return result\\n                \\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        start,end = 0, len(nums)-1\\n        result  = [0] * (end+1)\\n        index = end\\n        while index>=0:\\n            startElementSquare, endElementSquare = nums[start]**2, nums[end]**2\\n            if(endElementSquare > startElementSquare):\\n                result[index] = endElementSquare\\n                end -= 1\\n            else:\\n                result[index] = startElementSquare\\n                start+=1\\n            index-=1\\n        return result\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1877413,
                "title": "javascript-two-pointers-clean-and-simple",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar sortedSquares = function(nums) {\\n    const squreSorted = new Array(nums.length); // define empty array\\n \\n    \\n    let leftIndx = 0; // left pointer\\n    let rightIndx = nums.length - 1; // right pointer\\n    \\n    let pointer = nums.length; // point to last empty squreSorted index\\n    \\n    while(pointer){\\n        pointer--;\\n        \\n        let leftValue = nums[leftIndx] ** 2;\\n        let rightValue = nums[rightIndx] ** 2;\\n        \\n        if(leftValue > rightValue) \\n        {\\n            squreSorted[pointer] = leftValue;\\n            leftIndx++;\\n        }\\n        else{ \\n            squreSorted[pointer] = rightValue;\\n            rightIndx--;\\n        }\\n    }\\n    \\n    return squreSorted\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar sortedSquares = function(nums) {\\n    const squreSorted = new Array(nums.length); // define empty array\\n \\n    \\n    let leftIndx = 0; // left pointer\\n    let rightIndx = nums.length - 1; // right pointer\\n    \\n    let pointer = nums.length; // point to last empty squreSorted index\\n    \\n    while(pointer){\\n        pointer--;\\n        \\n        let leftValue = nums[leftIndx] ** 2;\\n        let rightValue = nums[rightIndx] ** 2;\\n        \\n        if(leftValue > rightValue) \\n        {\\n            squreSorted[pointer] = leftValue;\\n            leftIndx++;\\n        }\\n        else{ \\n            squreSorted[pointer] = rightValue;\\n            rightIndx--;\\n        }\\n    }\\n    \\n    return squreSorted\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1850495,
                "title": "javascript-solution",
                "content": "Runtime: 88 ms, faster than 99.30% of JavaScript online submissions for Squares of a Sorted Array.\\nMemory Usage: 49.3 MB, less than 10.82% of JavaScript online submissions for Squares of a Sorted Array.\\n```\\nvar sortedSquares = function(nums) {\\n    let arr = [];\\n    let start = 0;\\n    let end = nums.length -1;\\n    \\n    while(start <= end){\\n        if(nums[start] **2 > nums[end] **2){\\n            arr.push(nums[start] **2);\\n            start++;\\n        } else {\\n            arr.push(nums[end] **2);\\n            end--;\\n        }\\n    }\\n    return arr.reverse();\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar sortedSquares = function(nums) {\\n    let arr = [];\\n    let start = 0;\\n    let end = nums.length -1;\\n    \\n    while(start <= end){\\n        if(nums[start] **2 > nums[end] **2){\\n            arr.push(nums[start] **2);\\n            start++;\\n        } else {\\n            arr.push(nums[end] **2);\\n            end--;\\n        }\\n    }\\n    return arr.reverse();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1781273,
                "title": "java-brute-o-nlogn-better-o-n-both-explained",
                "content": "**1. First approach is to iterate and update with its square. And then Sort the array and return.**\\n\\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=nums[i]*nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;\\n    }\\n}\\n```\\n\\n**2. Second approach is to use of two pointer and take whichever (abs) is greater and update it in new array. Iterate until new array become updated.**\\n\\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int arr[]=new int[nums.length];\\n        int i=0,j=nums.length-1,k=nums.length-1;\\n        while(k>=0){\\n            if(Math.abs(nums[i])>=Math.abs(nums[j])){\\n                arr[k]=nums[i]*nums[i];\\n                i++;\\n            }\\n            else{\\n                arr[k]=nums[j]*nums[j];\\n                j--;\\n            }\\n            k--;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=nums[i]*nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int arr[]=new int[nums.length];\\n        int i=0,j=nums.length-1,k=nums.length-1;\\n        while(k>=0){\\n            if(Math.abs(nums[i])>=Math.abs(nums[j])){\\n                arr[k]=nums[i]*nums[i];\\n                i++;\\n            }\\n            else{\\n                arr[k]=nums[j]*nums[j];\\n                j--;\\n            }\\n            k--;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1708128,
                "title": "javascript-radix-sort-o-n-time-o-1-space",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\n\\nfunction getDigit(number, place) {\\n    return Math.floor(Math.abs(number) / Math.pow(10, place)) % 10;\\n}\\n\\nfunction getDigitCount(number) {\\n    return number === 0\\n        ? number\\n        : Math.floor(Math.log10(Math.abs(number))) + 1;\\n}\\n\\nfunction getHighestDigitCount(numbers) {\\n    return Math.max(...numbers.map(n => getDigitCount(n)));\\n}\\n\\nfunction radixSort(numbers) {\\n    const maxDigitCount = getHighestDigitCount(numbers);\\n\\n    let numArr = [];\\n\\n    for(let i = 0; i < maxDigitCount; i++) {\\n\\n        for(let j = 0; j < numbers.length; j++) {\\n            let digit = getDigit(numbers[j], i);\\n            if(numArr[digit] === undefined) {\\n                numArr[digit] = [numbers[j]];\\n            } else {\\n                numArr[digit].push(numbers[j]);\\n            }\\n        }\\n\\n        numbers = numArr.flat(1);\\n        numArr = [];\\n    }\\n\\n    return numbers;\\n}\\n\\nvar sortedSquares = function(nums) {\\n    for(let i = 0; i < nums.length; i++) {\\n        nums[i] = Math.abs(nums[i] ** 2);\\n    }\\n    return radixSort(nums);\\n};\\n```\\n\\nThis solution is using radix sort which has a time complexity of O(kN). However, there are specific applications where if k is small enough that Radix Sort will exhibit linear-time performance in practice. Counting sort should also exhibit O(n) time complexity for the same reasons.\\n\\nIt is also using O(1) space complexity.\\n\\nYou can learn more about Radix sort here: http://en.wikipedia.org/wiki/Radix_sort",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\n\\nfunction getDigit(number, place) {\\n    return Math.floor(Math.abs(number) / Math.pow(10, place)) % 10;\\n}\\n\\nfunction getDigitCount(number) {\\n    return number === 0\\n        ? number\\n        : Math.floor(Math.log10(Math.abs(number))) + 1;\\n}\\n\\nfunction getHighestDigitCount(numbers) {\\n    return Math.max(...numbers.map(n => getDigitCount(n)));\\n}\\n\\nfunction radixSort(numbers) {\\n    const maxDigitCount = getHighestDigitCount(numbers);\\n\\n    let numArr = [];\\n\\n    for(let i = 0; i < maxDigitCount; i++) {\\n\\n        for(let j = 0; j < numbers.length; j++) {\\n            let digit = getDigit(numbers[j], i);\\n            if(numArr[digit] === undefined) {\\n                numArr[digit] = [numbers[j]];\\n            } else {\\n                numArr[digit].push(numbers[j]);\\n            }\\n        }\\n\\n        numbers = numArr.flat(1);\\n        numArr = [];\\n    }\\n\\n    return numbers;\\n}\\n\\nvar sortedSquares = function(nums) {\\n    for(let i = 0; i < nums.length; i++) {\\n        nums[i] = Math.abs(nums[i] ** 2);\\n    }\\n    return radixSort(nums);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1707363,
                "title": "c-cpp-different-stl-implementation",
                "content": "Tried this to make this solution nearly 100% fast, Ended up 95% Faster\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        for_each(nums.begin(),nums.end(),[](int& a){a=a*a;});\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        for_each(nums.begin(),nums.end(),[](int& a){a=a*a;});\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1670332,
                "title": "java-with-explanation-two-pointers-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int start = 0;\\n        int end = nums.length - 1;\\n        int[] squares = new int[nums.length];\\n\\t\\t\\n        int j = nums.length - 1;\\n        \\n        while (start <= end) {\\n            if (Math.abs(nums[start]) > Math.abs(nums[end])) {\\n                squares[j] = nums[start] * nums[start];\\n                start++;\\n            } else {\\n                squares[j] = nums[end] * nums[end];\\n                end--;\\n            }\\n            j--;\\n        }\\n        \\n        return squares;\\n    }\\n}\\n```\\n\\n# Explanation \\n\\nWhen squaring an integer, its sign doesn\\'t matter: the answer is always the same. This means that in our array of negative and positive integers, the largest squares are located towards both ends of the array. \\n\\nThe idea behind my code is getting the bigger number from either ends of the array using what\\'s called the **two-pointer** technique. \\n\\n### Code run-through: \\n\\n1. Initiliaze your variables. \\n\\ta. `start` points to the first index of your array while `end` is the last.\\n\\tb. `squares` is where you would store your sorted squares. \\n\\tc. `j` is used populate your `squares` array; it starts from the end of the array (`nums.length - 1`) since you\\'d be populating it with the biggest elements first. \\n```\\nint start = 0;\\nint end = nums.length - 1;\\nint[] squares = new int[nums.length];\\n\\nint j = nums.length - 1;\\n```\\n\\n2. The next part is the meat of the code. \\n\\ta. The `while-loop` goes through all the elements in `nums` until the `start <= end` (you\\'ll see why). \\n\\tb. The `if-else` statement checks which of the either indices has the bigger **absolute** value. \\n\\tc. If `nums[start]` is bigger than `nums[end]`, then we set `squares[j]` to the square of`nums[start]`; then increment `start` by 1. \\n\\t\\td. Else, we set we set `squares[j]` to the square of`nums[end]`; then decrement `end` by 1.\\n\\t\\te. Finally, decrement `j` by 1. \\n```\\nwhile (start <= end) {\\n\\tif (Math.abs(nums[start]) > Math.abs(nums[end])) {\\n\\t\\tsquares[j] = nums[start] * nums[start];\\n\\t\\tstart++;\\n\\t} else {\\n\\t\\tsquares[j] = nums[end] * nums[end];\\n\\t\\tend--;\\n\\t}\\n\\tj--;\\n}\\n```\\n\\n### Run-time Analysis:\\n\\nSince we only loop through the array once, we have a linear runtime O(n). \\n\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int start = 0;\\n        int end = nums.length - 1;\\n        int[] squares = new int[nums.length];\\n\\t\\t\\n        int j = nums.length - 1;\\n        \\n        while (start <= end) {\\n            if (Math.abs(nums[start]) > Math.abs(nums[end])) {\\n                squares[j] = nums[start] * nums[start];\\n                start++;\\n            } else {\\n                squares[j] = nums[end] * nums[end];\\n                end--;\\n            }\\n            j--;\\n        }\\n        \\n        return squares;\\n    }\\n}\\n```\n```\\nint start = 0;\\nint end = nums.length - 1;\\nint[] squares = new int[nums.length];\\n\\nint j = nums.length - 1;\\n```\n```\\nwhile (start <= end) {\\n\\tif (Math.abs(nums[start]) > Math.abs(nums[end])) {\\n\\t\\tsquares[j] = nums[start] * nums[start];\\n\\t\\tstart++;\\n\\t} else {\\n\\t\\tsquares[j] = nums[end] * nums[end];\\n\\t\\tend--;\\n\\t}\\n\\tj--;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1594612,
                "title": "java-o-n-time-complexity-easy-solution",
                "content": "Kindly upvote, if it helps you!\\n```\\nBrute force Approach\\nTime Complexity - O(n + nlogn)\\nSpace Complexity - O(n)\\npublic int[] sortedSquares(int[] nums) {\\n        int[] result = new int[nums.length];\\n        int i = 0;\\n        for(int num: nums){\\n            result[i++] = num*num;\\n        }\\n        Arrays.sort(result);\\n        return result;\\n    }\\n\\nApproach no. 2\\nTime Complexity - O(n)\\nSpace Complexity - O(n)\\npublic int[] sortedSquares(int[] nums) {\\n        int[] result = new int[nums.length];\\n        int i = 0, j= nums.length-1, k = nums.length-1;\\n        while(i<=j && k>=0){\\n            if(nums[i]*nums[i] < nums[j]*nums[j]){\\n                result[k] = nums[j]*nums[j];\\n                j--;\\n            }else{\\n                result[k] = nums[i]*nums[i];\\n                i++;\\n            }\\n            k--;\\n        }\\n        return result;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Kindly upvote, if it helps you!\\n```\\nBrute force Approach\\nTime Complexity - O(n + nlogn)\\nSpace Complexity - O(n)\\npublic int[] sortedSquares(int[] nums) {\\n        int[] result = new int[nums.length];\\n        int i = 0;\\n        for(int num: nums){\\n            result[i++] = num*num;\\n        }\\n        Arrays.sort(result);\\n        return result;\\n    }\\n\\nApproach no. 2\\nTime Complexity - O(n)\\nSpace Complexity - O(n)\\npublic int[] sortedSquares(int[] nums) {\\n        int[] result = new int[nums.length];\\n        int i = 0, j= nums.length-1, k = nums.length-1;\\n        while(i<=j && k>=0){\\n            if(nums[i]*nums[i] < nums[j]*nums[j]){\\n                result[k] = nums[j]*nums[j];\\n                j--;\\n            }else{\\n                result[k] = nums[i]*nums[i];\\n                i++;\\n            }\\n            k--;\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1498777,
                "title": "java-solution-2ms",
                "content": "\\tclass Solution {\\n\\t\\tpublic int[] sortedSquares(int[] nums) {\\n \\n\\t\\t\\tint[] square = new int[nums.length];\\n\\t\\t\\tint pcur = 0 ;\\n\\t\\t\\tint ncur = nums.length-1;\\n\\n\\t\\t\\tfor(int i = nums.length-1; i >= 0; i--){\\n\\t\\t\\t\\tif(nums[pcur]* nums[pcur] > nums[ncur] * nums[ncur]){\\n\\t\\t\\t\\t\\t\\tsquare[i] = nums[pcur] * nums[pcur];\\n\\t\\t\\t\\t\\t\\tpcur++;\\n\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\tsquare[i] = nums[ncur] * nums[ncur];\\n\\t\\t\\t\\t\\t\\tncur--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t\\treturn square;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int[] sortedSquares(int[] nums) {\\n \\n\\t\\t\\tint[] square = new int[nums.length];\\n\\t\\t\\tint pcur = 0 ;\\n\\t\\t\\tint ncur = nums.length-1;\\n\\n\\t\\t\\tfor(int i = nums.length-1; i >= 0; i--){\\n\\t\\t\\t\\tif(nums[pcur]* nums[pcur] > nums[ncur] * nums[ncur]){\\n\\t\\t\\t\\t\\t\\tsquare[i] = nums[pcur] * nums[pcur];\\n\\t\\t\\t\\t\\t\\tpcur++;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1483326,
                "title": "c-no-sorting-simple-solution",
                "content": "**Please Upvote if it helped You !!!\\nHappy Coding :)**\\n```\\nvector<int> sortedSquares(vector<int>& nums) \\n    {\\n        vector<int> answer(nums.size());\\n        int left=0;\\n        int right=nums.size()-1;\\n        for(int i=right;i>=0;i--)\\n        {\\n            if(abs(nums[right]) > abs(nums[left]))\\n            {\\n                answer[i]=nums[right] * nums[right];\\n                right--;\\n            }\\n            else \\n            {\\n                answer[i]=nums[left] * nums[left];\\n                left++;\\n            }\\n        }\\n        return answer;\\n    }\\n```\\t",
                "solutionTags": [],
                "code": "```\\nvector<int> sortedSquares(vector<int>& nums) \\n    {\\n        vector<int> answer(nums.size());\\n        int left=0;\\n        int right=nums.size()-1;\\n        for(int i=right;i>=0;i--)\\n        {\\n            if(abs(nums[right]) > abs(nums[left]))\\n            {\\n                answer[i]=nums[right] * nums[right];\\n                right--;\\n            }\\n            else \\n            {\\n                answer[i]=nums[left] * nums[left];\\n                left++;\\n            }\\n        }\\n        return answer;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1439593,
                "title": "javascript-o-n-time-o-1-space-simple-easy-to-understand-solution",
                "content": "```\\n// ! O(1) space complexity when not considering the result array as extra space, otherwise O(n) space complexity\\n\\nvar sortedSquares = function(nums) {\\n  let li = 0, ri = nums.length - 1, result = [];\\n\\n  for (let i = nums.length - 1; i >= 0; i--) {\\n    let left = Math.abs(nums[li]), right = Math.abs(nums[ri]);\\n\\n    if (left <= right) { result[i] = right * right; ri--; }\\n    else if (left > right) { result[i] = left * left; li++; }\\n  }\\n\\n  return result;\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\n// ! O(1) space complexity when not considering the result array as extra space, otherwise O(n) space complexity\\n\\nvar sortedSquares = function(nums) {\\n  let li = 0, ri = nums.length - 1, result = [];\\n\\n  for (let i = nums.length - 1; i >= 0; i--) {\\n    let left = Math.abs(nums[li]), right = Math.abs(nums[ri]);\\n\\n    if (left <= right) { result[i] = right * right; ri--; }\\n    else if (left > right) { result[i] = left * left; li++; }\\n  }\\n\\n  return result;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1411602,
                "title": "two-pointers-c-simple-solution-o-n",
                "content": "***Please upvote if you find this useful***\\n\\nWe take another vector ```result``` of the same size as vector ```nums``` to store the new array, containing the sqaures in sorted order.\\n\\nWe then take two pointers ```start``` and ```end``` pointing to the first and last index of the ```nums``` vector. \\nWe also take another pointer ```i``` which points at last index of our new vector ```result```\\n\\nThen, we compare that whether, the squared value of the first index or the squared value of last index is higher. Whichever is higher, we put that value in the last index of our ```result``` vector. We run the loop and traverse ```nums``` till ```start``` pointer is less than or equal to ```end``` pointer. \\n\\n*Intuition: * If you carefully notice, you will see that the first element and the last element of the ```nums``` vector has the potential of giving the largest squared number. \\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int start = 0;\\n        int end = nums.size()-1;\\n        vector<int> result(nums.size()) ;\\n        int i = result.size()-1;\\n        \\n        while(start<=end)\\n        {\\n            if(nums[start]*nums[start] > nums[end]*nums[end])\\n            {\\n                result[i] = nums[start]*nums[start]; \\n                start++;\\n            }\\n               \\n        \\n        else{\\n            result[i] = nums[end]*nums[end];\\n            end--;\\n        }\\n           i--; \\n            \\n        }  \\n        return result;\\n            \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```result```\n```nums```\n```start```\n```end```\n```nums```\n```i```\n```result```\n```result```\n```nums```\n```start```\n```end```\n```nums```",
                "codeTag": "Unknown"
            },
            {
                "id": 1252319,
                "title": "c-two-pointers-o-n-no-sorting-required",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& a) {\\n        \\n        int n=a.size();\\n        vector<int>ans(n);\\n        int i=0;\\n        int j=n-1;\\n        int k=n-1;\\n        \\n        while(i<=j)\\n        {\\n            if(abs(a[i])>=abs(a[j]))\\n            {\\n                ans[k] = a[i]*a[i];\\n                i++;\\n            }\\n            else\\n            {\\n                ans[k] = a[j]*a[j];\\n                j--;\\n            }\\n            k--;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& a) {\\n        \\n        int n=a.size();\\n        vector<int>ans(n);\\n        int i=0;\\n        int j=n-1;\\n        int k=n-1;\\n        \\n        while(i<=j)\\n        {\\n            if(abs(a[i])>=abs(a[j]))\\n            {\\n                ans[k] = a[i]*a[i];\\n                i++;\\n            }\\n            else\\n            {\\n                ans[k] = a[j]*a[j];\\n                j--;\\n            }\\n            k--;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1167055,
                "title": "c-o-n-99-99-faster",
                "content": "\\n    vector<int> sortedSquares(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        vector<int> res(n);\\n        int s = 0, e = n - 1, idx = n - 1;\\n        \\n        while(s <= e)\\n        {\\n            if(abs(nums[s]) < abs(nums[e]))\\n            {\\n                res[idx--] = nums[e] * nums[e];\\n                e--;\\n            }\\n            else\\n            {\\n                res[idx--] = nums[s] * nums[s];\\n                s++;\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "\\n    vector<int> sortedSquares(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        vector<int> res(n);\\n        int s = 0, e = n - 1, idx = n - 1;\\n        \\n        while(s <= e)\\n        {\\n            if(abs(nums[s]) < abs(nums[e]))\\n            {\\n                res[idx--] = nums[e] * nums[e];\\n                e--;\\n            }\\n            else\\n            {\\n                res[idx--] = nums[s] * nums[s];\\n                s++;\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1164759,
                "title": "java-single-while-loop-approach-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n\\t\\tint[] res = new int[nums.length];\\n\\t\\tint i = 0;\\n\\t\\tint j = nums.length - 1;\\n\\t\\tint counter = nums.length - 1;\\n\\t\\twhile (counter >= 0) {\\n\\t\\t\\tint iSquare = nums[i] * nums[i];\\n\\t\\t\\tint jSquare = nums[j] * nums[j];\\n\\t\\t\\tif (iSquare > jSquare) {\\n\\t\\t\\t\\tres[counter] = iSquare;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tres[counter] = jSquare;\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t\\tcounter--;\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n\\t\\tint[] res = new int[nums.length];\\n\\t\\tint i = 0;\\n\\t\\tint j = nums.length - 1;\\n\\t\\tint counter = nums.length - 1;\\n\\t\\twhile (counter >= 0) {\\n\\t\\t\\tint iSquare = nums[i] * nums[i];\\n\\t\\t\\tint jSquare = nums[j] * nums[j];\\n\\t\\t\\tif (iSquare > jSquare) {\\n\\t\\t\\t\\tres[counter] = iSquare;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tres[counter] = jSquare;\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t\\tcounter--;\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1062638,
                "title": "java-o-n-1ms",
                "content": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int n = nums.length;\\n        int arr[] = new int [n];\\n        int start =0, end = n-1;\\n        for(int i =n-1;i>=0;i--){\\n            int square =Math.abs(nums[start])<Math.abs(nums[end])?nums[end--]:nums[start++];\\n            arr[i] = square*square;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int n = nums.length;\\n        int arr[] = new int [n];\\n        int start =0, end = n-1;\\n        for(int i =n-1;i>=0;i--){\\n            int square =Math.abs(nums[start])<Math.abs(nums[end])?nums[end--]:nums[start++];\\n            arr[i] = square*square;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 941592,
                "title": "c-two-approach-solution",
                "content": "**1. Using in-built sort function (NlogN time complexity)**\\nRuntime: 100 ms, faster than 54.72% of C++ online submissions for Squares of a Sorted Array.\\n\\n\\t\\tclass Solution {\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tvector<int> sortedSquares(vector<int>& A) {\\n\\n\\t\\t\\t\\t\\tfor(int i=0;i<A.size();i++) A[i] *= A[i];\\n\\n\\t\\t\\t\\t\\tsort(A.begin(),A.end());\\n\\n\\t\\t\\t\\t\\treturn A;\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\n**2. Using two pointers (O(N) time complexity)**\\nRuntime: 20 ms, faster than 97.93% of C++ online submissions for Squares of a Sorted Array.\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> sortedSquares(vector<int>& nums) {\\n\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tvector<int> res(n);\\n\\n\\t\\t\\tint i = 0; //pointing on \\'nums\\' vector\\n\\t\\t\\tint j = n-1; //pointing on \\'nums\\' vector\\n\\t\\t\\tint idx = n-1; //pointing on \\'res\\' vector\\n\\n\\t\\t\\twhile(i <= j){\\n\\t\\t\\t\\tint v1 = nums[i] * nums[i];\\n\\t\\t\\t\\tint v2 = nums[j] * nums[j];;\\n\\n\\t\\t\\t\\tif(v1 > v2){\\n\\t\\t\\t\\t\\tres[idx] = v1;\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tres[idx] = v2;\\n\\t\\t\\t\\t\\tj--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tidx--;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tvector<int> sortedSquares(vector<int>& A) {\\n\\n\\t\\t\\t\\t\\tfor(int i=0;i<A.size();i++) A[i] *= A[i];\\n\\n\\t\\t\\t\\t\\tsort(A.begin(),A.end());\\n\\n\\t\\t\\t\\t\\treturn A;\\n\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 659371,
                "title": "simple-and-straightforward-python-solution-o-n",
                "content": "```\\n        res = []\\n        \\n        i = 0\\n        j = len(A) - 1\\n        \\n        while i <= j:\\n            \\n            if abs(A[i]) < abs(A[j]):\\n                res.append(A[j]**2)\\n                j-=1\\n            else:\\n                res.append(A[i]**2)\\n                i+=1\\n                \\n                \\n        return res[::-1]\\n```\\n\\ntwo pointer approach",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\n        res = []\\n        \\n        i = 0\\n        j = len(A) - 1\\n        \\n        while i <= j:\\n            \\n            if abs(A[i]) < abs(A[j]):\\n                res.append(A[j]**2)\\n                j-=1\\n            else:\\n                res.append(A[i]**2)\\n                i+=1\\n                \\n                \\n        return res[::-1]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 576683,
                "title": "swift",
                "content": "```\\n    func sortedSquares(_ A: [Int]) -> [Int] {\\n        var res = [Int](repeating: 0, count: A.count)\\n        var index = A.count - 1\\n        var left = 0\\n        var right = A.count - 1\\n        while left <= right {\\n            var a = A[left] * A[left]\\n            var b = A[right] * A[right]\\n            if a > b {\\n                res[index] = a\\n                index -= 1\\n                left += 1\\n            } else {\\n                res[index] = b\\n                index -= 1\\n                right -= 1\\n            }\\n        }\\n        return res\\n    }",
                "solutionTags": [],
                "code": "```\\n    func sortedSquares(_ A: [Int]) -> [Int] {\\n        var res = [Int](repeating: 0, count: A.count)\\n        var index = A.count - 1\\n        var left = 0\\n        var right = A.count - 1\\n        while left <= right {\\n            var a = A[left] * A[left]\\n            var b = A[right] * A[right]\\n            if a > b {\\n                res[index] = a\\n                index -= 1\\n                left += 1\\n            } else {\\n                res[index] = b\\n                index -= 1\\n                right -= 1\\n            }\\n        }\\n        return res\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 504370,
                "title": "python-explained-without-using-sorted",
                "content": "The intuition is that the first and last bits of the originally sorted array will be the two candidates to append to the squares array back to front. \\n\\nFor example, in: `[-9,-3,-2,0,3,4]` the two largest possible are -9^2 and 4^2. If it\\'s the left, increment left and append it to the back of the result array. \\n\\n```\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        l, r, ptr = 0, len(A) - 1, len(A) - 1\\n        fin = [None] * len(A)\\n        while l <= r:\\n            lS, rS = A[l] ** 2, A[r] ** 2\\n            if lS >= rS: \\n                fin[ptr], l = lS, l + 1\\n            else:\\n                fin[ptr], r = rS, r - 1\\n            ptr -= 1\\n        return fin\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        l, r, ptr = 0, len(A) - 1, len(A) - 1\\n        fin = [None] * len(A)\\n        while l <= r:\\n            lS, rS = A[l] ** 2, A[r] ** 2\\n            if lS >= rS: \\n                fin[ptr], l = lS, l + 1\\n            else:\\n                fin[ptr], r = rS, r - 1\\n            ptr -= 1\\n        return fin\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 391005,
                "title": "two-pointers-c-one-pass-o-n-detailed-explanation",
                "content": "Note that the given array is already sorted, so in terms of sqaure values, it can be considered as at most two sorted arrays connected somewhere in the middle. Then we could use the same idea to merge two sorted arrays.\\n\\n```cpp\\n    vector<int> sortedSquares(vector<int>& a) {        \\n        int n = a.size();\\n        int L = 0; // read position from left a[]\\n        int R = n-1; // read position from right a[]\\n        int w = n-1; // write position in res[]\\n        \\n        vector<int> res(n);\\n        \\n        while (w >= 0) // pick large one in asb\\n            res[w--] = (abs(a[L]) >= abs(a[R]))? a[L]*a[L++] : a[R]*a[R--];\\n\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```cpp\\n    vector<int> sortedSquares(vector<int>& a) {        \\n        int n = a.size();\\n        int L = 0; // read position from left a[]\\n        int R = n-1; // read position from right a[]\\n        int w = n-1; // write position in res[]\\n        \\n        vector<int> res(n);\\n        \\n        while (w >= 0) // pick large one in asb\\n            res[w--] = (abs(a[L]) >= abs(a[R]))? a[L]*a[L++] : a[R]*a[R--];\\n\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 332449,
                "title": "swift-o-n-solution",
                "content": "```swift\\nclass Solution {\\n    func sortedSquares(_ A: [Int]) -> [Int] {\\n        let n = A.count\\n        var outputs = Array(repeating: 0, count: n)\\n        \\n        var i = 0, j = n - 1\\n        \\n        for p in (0 ..< n).reversed() {\\n            if abs(A[i]) > abs(A[j]) {\\n                outputs[p] = A[i] * A[i]\\n                i += 1\\n            } else {\\n                outputs[p] = A[j] * A[j]\\n                j -= 1\\n            }\\n        }\\n        \\n        return outputs\\n    }\\n}\\n\\xB7\\xB7\\xB7",
                "solutionTags": [
                    "Swift"
                ],
                "code": "class Solution {\\n    func sortedSquares(_ A: [Int]) -> [Int] {\\n        let n = A.count\\n        var outputs = Array(repeating: 0, count: n)\\n        \\n        var i = 0, j = n - 1\\n        \\n        for p in (0 ..< n).reversed() {\\n            if abs(A[i]) > abs(A[j]) {\\n                outputs[p] = A[i] * A[i]\\n                i += 1\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 239305,
                "title": "c-solution",
                "content": "```\\nint* sortedSquares(int* A, int ASize, int* returnSize) {\\n    int* ans = calloc(ASize, sizeof(int));\\n    *returnSize = ASize;\\n    int i = 0, j = ASize - 1, index = ASize - 1;\\n    while(i <= j)\\n    {\\n        if(-A[i] > A[j])\\n        {\\n            ans[index--] = A[i] * A[i];\\n            i++;\\n        }\\n        else\\n        {\\n            ans[index--] = A[j] * A[j];\\n            j--;\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint* sortedSquares(int* A, int ASize, int* returnSize) {\\n    int* ans = calloc(ASize, sizeof(int));\\n    *returnSize = ASize;\\n    int i = 0, j = ASize - 1, index = ASize - 1;\\n    while(i <= j)\\n    {\\n        if(-A[i] > A[j])\\n        {\\n            ans[index--] = A[i] * A[i];\\n            i++;\\n        }\\n        else\\n        {\\n            ans[index--] = A[j] * A[j];\\n            j--;\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3697662,
                "title": "easy-solution-two-pointers-beats-97-facebook",
                "content": "``` C++ []\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int left=0, right=nums.size()-1;\\n        vector<int> arr(nums.size());\\n        int i=arr.size()-1;\\n        while(left<=right){\\n            int temp=max(nums[left]*nums[left],nums[right]*nums[right]);\\n            arr[i--]=temp;\\n            if(abs(nums[left])<abs(nums[right])){\\n                right--;\\n            }\\n            else{\\n                left++;\\n            }\\n        }\\n        return arr;\\n    }\\n};\\n```\\n- The code aims to square each element in the given input array nums, sort the squared values in non-decreasing order, and return the sorted result.\\n- It uses two pointers, left and right, to track the left and right ends of the input array.\\n- The algorithm initializes an empty result array of the same size as nums.\\n- Starting from the ends of the array, the algorithm compares the absolute values of the elements at the left and right pointers.\\n- It squares the larger absolute value and assigns it to the end of the result array.\\n- The pointer of the assigned value is then decremented.\\n- The algorithm moves the pointer that corresponds to the element with the smaller absolute value.\\n- This process continues until the pointers meet or cross each other.\\n- Finally, the algorithm returns the sorted result array.\\n- The time complexity is O(n) linear because the algorithm iterates through the input array only once. \\n- The space complexity is also O(n) linear because it requires space to store the result array of the same size as the input array.\\n\\n```\\nI hope this helps ^_^\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int left=0, right=nums.size()-1;\\n        vector<int> arr(nums.size());\\n        int i=arr.size()-1;\\n        while(left<=right){\\n            int temp=max(nums[left]*nums[left],nums[right]*nums[right]);\\n            arr[i--]=temp;\\n            if(abs(nums[left])<abs(nums[right])){\\n                right--;\\n            }\\n            else{\\n                left++;\\n            }\\n        }\\n        return arr;\\n    }\\n};\\n```\n```\\nI hope this helps ^_^\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391656,
                "title": "easy-clean-js-solution",
                "content": "\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nconst sortedSquares = function(nums) {\\n  const arr =  nums.map(value => Math.pow(value,2));\\n  return arr.sort((a,b)=> a-b);\\n  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nconst sortedSquares = function(nums) {\\n  const arr =  nums.map(value => Math.pow(value,2));\\n  return arr.sort((a,b)=> a-b);\\n  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3196486,
                "title": "simple-two-pointer-solution-tc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGiven an integer array sorted in non-decreasing order, we need to return an array of the squares of each number sorted in non-decreasing order. Since the given array is sorted, the squares of $$negative$$ numbers will be in $$decreasing$$ order and the squares of $$positive$$ numbers will be in $$increasing$$ order. We can merge these two arrays of squares using a $$two-pointer$$ approach.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We will start with two pointers, $$left$$ and $$right$$, both at the two ends of the given array. We will also create an empty result array called $$\\'res\\'$$.\\n- We will loop until the $$left$$ pointer is less than or equal to the $$right$$ pointer.\\n- If the element pointed by the $$left$$ pointer is negative, we will compare its $$absolute$$ value with the element pointed by the $$right$$ pointer. \\n- If the absolute value of the $$left$$ element is greater than or equal to the $$right$$ element, we will add the square of the $$left$$ element to the $$\\'res\\'$$ array and move the $$left$$ pointer one position to the right.\\n- Otherwise, we will add the square of the right element to the $$\\'res\\'$$ array and move the $$right$$ pointer one position to the left.\\n- If the element pointed by the $$left$$ pointer is non-negative, we will $$break$$ out of the loop since all remaining elements will also be non-negative and their squares will be in $$increasing$$ order.\\n- We will loop through the remaining elements in the array from the $$right$$ pointer to the $$left$$ pointer and append their squares to the $$\\'res\\'$$ array.\\n- Since we appended the squares of the remaining elements from right to left, we need to reverse the $$\\'res\\'$$ array to get the squares in $$non-decreasing$$ order.\\n- We will return the $$\\'res\\'$$ array.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n```\\nThe given array is iterated twice - once using the two-pointer\\napproach and once to loop through the remaining elements. \\nTherefore, the time complexity of this algorithm is O(n), where \\'n\\'\\nis the length of the given array.\\n```\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nWe are creating an empty array to store the result. Therefore, \\nthe space complexity of this algorithm is O(n), where \\'n\\' is \\nthe length of the given array.\\n```\\n# Code\\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        res = []  # to store the result\\n        left, right = 0, len(nums)-1  # initialize left and right pointers to the two ends of the array\\n        \\n        # loop until left pointer is less than or equal to right pointer\\n        while left <= right:\\n            if nums[left] < 0:  \\n                # if the element pointed by left pointer is negative\\n                # compare absolute value of left element with the right element\\n                if abs(nums[left]) >= nums[right]:\\n                    res.append(nums[left]**2)  \\n                    # if absolute value of left element is greater than or equal\\n                    # to right element, add square of left element to the result array\\n                    left += 1  # move left pointer one position to the right\\n                else:\\n                    res.append(nums[right]**2)  \\n                    # if absolute value of left element is less than right element, add square of right\\n                    # element to the result array\\n                    right -= 1  # move right pointer one position to the left\\n            else:  \\n                # if the element pointed by left pointer is non-negative, break out of the loop\\n                break\\n        \\n        # loop through the remaining elements from right pointer to left pointer and \\n        # append their squares to the result array\\n        for i in range(right, left-1, -1):\\n            res.append(nums[i]**2)\\n        \\n        res.reverse()  # reverse the result array to get the squares in non-decreasing order\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nThe given array is iterated twice - once using the two-pointer\\napproach and once to loop through the remaining elements. \\nTherefore, the time complexity of this algorithm is O(n), where \\'n\\'\\nis the length of the given array.\\n```\n```\\nWe are creating an empty array to store the result. Therefore, \\nthe space complexity of this algorithm is O(n), where \\'n\\' is \\nthe length of the given array.\\n```\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        res = []  # to store the result\\n        left, right = 0, len(nums)-1  # initialize left and right pointers to the two ends of the array\\n        \\n        # loop until left pointer is less than or equal to right pointer\\n        while left <= right:\\n            if nums[left] < 0:  \\n                # if the element pointed by left pointer is negative\\n                # compare absolute value of left element with the right element\\n                if abs(nums[left]) >= nums[right]:\\n                    res.append(nums[left]**2)  \\n                    # if absolute value of left element is greater than or equal\\n                    # to right element, add square of left element to the result array\\n                    left += 1  # move left pointer one position to the right\\n                else:\\n                    res.append(nums[right]**2)  \\n                    # if absolute value of left element is less than right element, add square of right\\n                    # element to the result array\\n                    right -= 1  # move right pointer one position to the left\\n            else:  \\n                # if the element pointed by left pointer is non-negative, break out of the loop\\n                break\\n        \\n        # loop through the remaining elements from right pointer to left pointer and \\n        # append their squares to the result array\\n        for i in range(right, left-1, -1):\\n            res.append(nums[i]**2)\\n        \\n        res.reverse()  # reverse the result array to get the squares in non-decreasing order\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144443,
                "title": "one-line",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        return sorted([i*i for i in nums])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        return sorted([i*i for i in nums])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3114237,
                "title": "basic-code-begginer-friendly",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n//Please Upvote if you like the approach \\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            int temp=nums[i]*nums[i];\\n            ans.push_back(temp);\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//Please Upvote if you like the approach \\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            int temp=nums[i]*nums[i];\\n            ans.push_back(temp);\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066994,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMultiplicatio of two elements at same index.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn this problem i just simply multiply elements at same index and after that i just simply sort the array.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlog(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            nums[i]=nums[i]*nums[i];\\n        }\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n    }\\n};\\nPlease UPVOTE if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            nums[i]=nums[i]*nums[i];\\n        }\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n    }\\n};\\nPlease UPVOTE if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838888,
                "title": "c-best-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++){\\n            nums[i]=(nums[i]*nums[i]);\\n        }\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++){\\n            nums[i]=(nums[i]*nums[i]);\\n        }\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2797840,
                "title": "kotlin-one-liner-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    fun sortedSquares(nums: IntArray): IntArray {\\n        return nums.map { it * it }.sorted().toIntArray()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun sortedSquares(nums: IntArray): IntArray {\\n        return nums.map { it * it }.sorted().toIntArray()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792303,
                "title": "python-two-pointers-99-45-faster-o-n-solution",
                "content": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        c,n=0,len(nums)\\n        if n==1:\\n            nums[0]*=nums[0]\\n            return nums\\n        for i in range(n):\\n            if nums[i]>=0: #it will give us the index of the first postive number\\n                break\\n            c+=1\\n        for i in range(n):\\n            nums[i]*=nums[i]\\n        if c==n:\\n            return nums[-1::-1]\\n        i,j=c,c-1\\n        ans=[]\\n        while i<n and j>=0:\\n            if nums[i]<nums[j]:\\n                ans.append(nums[i])\\n                i+=1\\n            else:\\n                ans.append(nums[j])\\n                j-=1\\n# Here wer are running these two loops to check that if there is any element left or not\\n        for ind in range(i,n):\\n            ans.append(nums[ind]) \\n        for ind in range(j,-1,-1):\\n            ans.append(nums[ind])\\n        return ans\\n```\\n\\n**Please upvote if you like the solution**\\n                \\n        \\n",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        c,n=0,len(nums)\\n        if n==1:\\n            nums[0]*=nums[0]\\n            return nums\\n        for i in range(n):\\n            if nums[i]>=0: #it will give us the index of the first postive number\\n                break\\n            c+=1\\n        for i in range(n):\\n            nums[i]*=nums[i]\\n        if c==n:\\n            return nums[-1::-1]\\n        i,j=c,c-1\\n        ans=[]\\n        while i<n and j>=0:\\n            if nums[i]<nums[j]:\\n                ans.append(nums[i])\\n                i+=1\\n            else:\\n                ans.append(nums[j])\\n                j-=1\\n# Here wer are running these two loops to check that if there is any element left or not\\n        for ind in range(i,n):\\n            ans.append(nums[ind]) \\n        for ind in range(j,-1,-1):\\n            ans.append(nums[ind])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784534,
                "title": "python-easy",
                "content": "**2 Pointer Approch**\\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        i = 0 \\n        j = len(nums) - 1\\n        lst = []\\n        while(i<=j):\\n            if(nums[i]<0):\\n                nums[i] *= -1\\n            if(nums[j]<0):\\n                nums[j] = nums[j]*(-1)\\n            if(nums[i]>nums[j]):\\n                    lst.append(nums[i]*nums[i])\\n                    i+=1\\n            else:\\n                    lst.append(nums[j]*nums[j])\\n                    j-=1\\n        return lst[::-1]\\n```\\n**OverWriting Method**\\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        lst = []\\n        for i in nums:\\n            lst.append(i*i)\\n        return sorted(lst)\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        i = 0 \\n        j = len(nums) - 1\\n        lst = []\\n        while(i<=j):\\n            if(nums[i]<0):\\n                nums[i] *= -1\\n            if(nums[j]<0):\\n                nums[j] = nums[j]*(-1)\\n            if(nums[i]>nums[j]):\\n                    lst.append(nums[i]*nums[i])\\n                    i+=1\\n            else:\\n                    lst.append(nums[j]*nums[j])\\n                    j-=1\\n        return lst[::-1]\\n```\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        lst = []\\n        for i in nums:\\n            lst.append(i*i)\\n        return sorted(lst)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2676939,
                "title": "clean-0ms-runtime-faster-than-100-submission",
                "content": "Time Complexity - O(N)\\nSpace Complexity - O(N)\\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n         if(nums.length==0)\\n            return nums; \\n\\t\\t\\t\\n//naive Approach\\n//         for(int i=0;i<nums.length;i++)\\n//             nums[i]*=nums[i];\\n//         Arrays.sort(nums);\\n       \\n            \\n        int ans[]= new int[nums.length];\\n            \\n        int l=0;\\n        int r = ans.length-1;\\n        int index = nums.length-1;\\n        \\n        while(l<=r)\\n        {\\n            int val1 = nums[l]*nums[l];\\n            int val2 = nums[r]*nums[r];\\n            if(val1>val2)\\n            {\\n                ans[index] = val1;\\n                l++;\\n            }\\n            else\\n            {\\n                ans[index] = val2;\\n                r--;\\n            }\\n            index--;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n         if(nums.length==0)\\n            return nums; \\n\\t\\t\\t\\n//naive Approach\\n//         for(int i=0;i<nums.length;i++)\\n//             nums[i]*=nums[i];\\n//         Arrays.sort(nums);\\n       \\n            \\n        int ans[]= new int[nums.length];\\n            \\n        int l=0;\\n        int r = ans.length-1;\\n        int index = nums.length-1;\\n        \\n        while(l<=r)\\n        {\\n            int val1 = nums[l]*nums[l];\\n            int val2 = nums[r]*nums[r];\\n            if(val1>val2)\\n            {\\n                ans[index] = val1;\\n                l++;\\n            }\\n            else\\n            {\\n                ans[index] = val2;\\n                r--;\\n            }\\n            index--;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2598384,
                "title": "c-solution-two-pointers",
                "content": "class Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        \\n        int left = 0;\\n        int right = nums.size()-1;\\n        vector<int>ans(nums.size(),0);\\n        \\n        for(int i = nums.size()-1; i>=0; i--){\\n            \\n            if(abs(nums[left]) > nums[right]){\\n                ans[i] = nums[left]*nums[left];\\n                left++;\\n            }\\n            else{\\n                ans[i] = nums[right]*nums[right];\\n                right--;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        \\n        int left = 0;\\n        int right = nums.size()-1;\\n        vector<int>ans(nums.size(),0);\\n        \\n        for(int i = nums.size()-1; i>=0; i--){\\n            \\n            if(abs(nums[left]) > nums[right]){\\n                ans[i] = nums[left]*nums[left];\\n                left++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2429646,
                "title": "java-easiest-solution-beginner-friendly-approach-8ms-runtime-faster-than-50-submission",
                "content": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        for(int i=0;i<nums.length;i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        for(int i=0;i<nums.length;i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2406220,
                "title": "2-pointers-fully-explained-python-3-o-n-79-29-faster",
                "content": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        \\n        # Solution with 2 Pointers\\n        # Time Complexity: O(n)  Space Complexity: O(n)\\n        \\n        \"\"\"\\n        \\n        1. Initialize two pointers: lowValue = 0; highValue = len(nums) - 1\\n        2. Create a list with same length as nums to  store squared values arranged in non decreasing order\\n        3. Loop through the nums array \"Backwards\" (last index to 0) \\n        \\n            For each i, compare the absolute values of given list at the lowValue and highValue indexes\\n            \\n            3a. If absolute value of element at index lowValue >= absolute value of element at index highValue:\\n                \\n                - Element of index i of new list = square (element at index lowValue)\\n                - lowValue += l (Increment lowValue)\\n                \\n            3b. Else if absolute value of element at index lowValue < absolute value of element at index highValue:\\n                \\n                - Element of index i of new list = square (element at index highValue)\\n                - highValue -= l (Decrement highValue)\\n             \\n        \"\"\"\\n                \\n        # Step 1.\\n        \\n        lowValue = 0\\n        highValue = len(nums) - 1\\n        \\n        # Step 2.\\n        nums_square = [None] * int(len(nums))\\n        \\n        # Step 3.\\n        for i in range(len(nums) - 1, -1, -1):\\n            \\n            # Step 3a.\\n            if abs(nums[lowValue]) >= abs(nums[highValue]):\\n                \\n                nums_square[i] = nums[lowValue] * nums[lowValue]\\n                lowValue+=1\\n            \\n            # Step 3b\\n            else:\\n                nums_square[i] = nums[highValue] * nums[highValue]\\n                highValue-=1\\n                \\n        return nums_square\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        \\n        # Solution with 2 Pointers\\n        # Time Complexity: O(n)  Space Complexity: O(n)\\n        \\n        \"\"\"\\n        \\n        1. Initialize two pointers: lowValue = 0; highValue = len(nums) - 1\\n        2. Create a list with same length as nums to  store squared values arranged in non decreasing order\\n        3. Loop through the nums array \"Backwards\" (last index to 0) \\n        \\n            For each i, compare the absolute values of given list at the lowValue and highValue indexes\\n            \\n            3a. If absolute value of element at index lowValue >= absolute value of element at index highValue:\\n                \\n                - Element of index i of new list = square (element at index lowValue)\\n                - lowValue += l (Increment lowValue)\\n                \\n            3b. Else if absolute value of element at index lowValue < absolute value of element at index highValue:\\n                \\n                - Element of index i of new list = square (element at index highValue)\\n                - highValue -= l (Decrement highValue)\\n             \\n        \"\"\"\\n                \\n        # Step 1.\\n        \\n        lowValue = 0\\n        highValue = len(nums) - 1\\n        \\n        # Step 2.\\n        nums_square = [None] * int(len(nums))\\n        \\n        # Step 3.\\n        for i in range(len(nums) - 1, -1, -1):\\n            \\n            # Step 3a.\\n            if abs(nums[lowValue]) >= abs(nums[highValue]):\\n                \\n                nums_square[i] = nums[lowValue] * nums[lowValue]\\n                lowValue+=1\\n            \\n            # Step 3b\\n            else:\\n                nums_square[i] = nums[highValue] * nums[highValue]\\n                highValue-=1\\n                \\n        return nums_square\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2284502,
                "title": "simple-python-solution-optimized-two-pointer-approach-with-comments",
                "content": "```\\n# Two Pointer Approach\\n\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        left, right, new_arr = 0, len(nums)-1, []\\n        \\n        while left <= right:\\n            if abs(nums[left]) <= abs(nums[right]): # if the absolute value of left pointer value is less than or equal to right pointer\\n                new_arr.append(nums[right]**2) # Since we need non decreasing order sorted array, append the square of the value of right pointer to nums.\\n                right -= 1\\n            else:\\n                new_arr.append(nums[left]**2) # append left pointer value to nums\\n                left += 1\\n            \\n        return(new_arr[::-1]) # since we need non decreasing order, we reverse the nums array\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\n# Two Pointer Approach\\n\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        left, right, new_arr = 0, len(nums)-1, []\\n        \\n        while left <= right:\\n            if abs(nums[left]) <= abs(nums[right]): # if the absolute value of left pointer value is less than or equal to right pointer\\n                new_arr.append(nums[right]**2) # Since we need non decreasing order sorted array, append the square of the value of right pointer to nums.\\n                right -= 1\\n            else:\\n                new_arr.append(nums[left]**2) # append left pointer value to nums\\n                left += 1\\n            \\n        return(new_arr[::-1]) # since we need non decreasing order, we reverse the nums array\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 2280333,
                "title": "c-solution-3-lines-code-better-than-94-square-then-sort",
                "content": "```\\nvector<int> sortedSquares(vector<int>& nums) {\\n        for(auto &i: nums)\\n\\t\\t\\ti = i*i;\\n        sort(nums.begin(), nums.end());\\n        return nums;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nvector<int> sortedSquares(vector<int>& nums) {\\n        for(auto &i: nums)\\n\\t\\t\\ti = i*i;\\n        sort(nums.begin(), nums.end());\\n        return nums;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2267875,
                "title": "c-easy-clean-and-fastest-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        vector<int>res(nums.size());\\n        int l=0,r=nums.size()-1;\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            if(abs(nums[r])>abs(nums[l]))\\n            {\\n                res[i]=nums[r]*nums[r];\\n                r--;\\n            }\\n            else\\n            {\\n                res[i]=nums[l]*nums[l];\\n                l++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\nUpvote if you find it useful. \\uD83D\\uDE4C",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        vector<int>res(nums.size());\\n        int l=0,r=nums.size()-1;\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            if(abs(nums[r])>abs(nums[l]))\\n            {\\n                res[i]=nums[r]*nums[r];\\n                r--;\\n            }\\n            else\\n            {\\n                res[i]=nums[l]*nums[l];\\n                l++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2076517,
                "title": "easiest-java-soln-using-two-pointer-approach",
                "content": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int n=nums.length;\\n        int ans[]=new int [n];\\n        int a=0,b=n-1,x,y,i=n-1;\\n            while(a<=b)\\n            {\\n                x=nums[a]*nums[a];\\n                y=nums[b]*nums[b];\\n                if(x>y)\\n                {\\n                    ans[i--]=x;\\n                    a++;\\n                }\\n                else\\n                {\\n                    ans[i--]=y;\\n                    b--;\\n                }\\n            }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int n=nums.length;\\n        int ans[]=new int [n];\\n        int a=0,b=n-1,x,y,i=n-1;\\n            while(a<=b)\\n            {\\n                x=nums[a]*nums[a];\\n                y=nums[b]*nums[b];\\n                if(x>y)\\n                {\\n                    ans[i--]=x;\\n                    a++;\\n                }\\n                else\\n                {\\n                    ans[i--]=y;\\n                    b--;\\n                }\\n            }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2042618,
                "title": "o-n-solution-in-javascript",
                "content": "```javascript\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar sortedSquares = function(nums) {\\n    let result = Array(nums.length).fill(0);\\n    let left = 0;\\n    let right = nums.length - 1;\\n    for (let i = nums.length - 1; i >= 0; --i) {\\n        if (Math.abs(nums[left]) > Math.abs(nums[right])) {\\n            result[i] = nums[left] ** 2;\\n            left += 1;\\n        } else {\\n            result[i] = nums[right] ** 2;\\n            right -= 1;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar sortedSquares = function(nums) {\\n    let result = Array(nums.length).fill(0);\\n    let left = 0;\\n    let right = nums.length - 1;\\n    for (let i = nums.length - 1; i >= 0; --i) {\\n        if (Math.abs(nums[left]) > Math.abs(nums[right])) {\\n            result[i] = nums[left] ** 2;\\n            left += 1;\\n        } else {\\n            result[i] = nums[right] ** 2;\\n            right -= 1;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1966872,
                "title": "squares-of-a-sorted-array-java-easy-o-n-2-pointers-fastest-soln",
                "content": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        \\n        //Naive Approach\\n        \\n//         int n=nums.length;\\n//         int []arr=new int[n];\\n        \\n//         for(int i=0;i<n;i++){\\n//             arr[i]=nums[i]*nums[i];\\n//         }\\n        \\n//         Arrays.sort(arr);\\n        \\n//         return arr;\\n        \\n        \\n        int n=nums.length;\\n        \\n        int i=0;\\n        int j=n-1;\\n        \\n        int []res=new int[n];\\n        \\n        for(int k=n-1;k>=0;k--){\\n            if(Math.abs(nums[i])>Math.abs(nums[j])){\\n                res[k]=nums[i]*nums[i];\\n                i++;\\n            }else{\\n                res[k]=nums[j]*nums[j];\\n                j--;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        \\n        //Naive Approach\\n        \\n//         int n=nums.length;\\n//         int []arr=new int[n];\\n        \\n//         for(int i=0;i<n;i++){\\n//             arr[i]=nums[i]*nums[i];\\n//         }\\n        \\n//         Arrays.sort(arr);\\n        \\n//         return arr;\\n        \\n        \\n        int n=nums.length;\\n        \\n        int i=0;\\n        int j=n-1;\\n        \\n        int []res=new int[n];\\n        \\n        for(int k=n-1;k>=0;k--){\\n            if(Math.abs(nums[i])>Math.abs(nums[j])){\\n                res[k]=nums[i]*nums[i];\\n                i++;\\n            }else{\\n                res[k]=nums[j]*nums[j];\\n                j--;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938824,
                "title": "very-easy-and-straight-forward-solution",
                "content": "```\\n\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        \\n        for(int i=0;i<nums.length;i++){\\n            \\n            nums[i]=nums[i]*nums[i];\\n        }\\n        \\n        Arrays.sort(nums);\\n        \\n        return nums;\\n        \\n    }\\n}\\n\\n```\\n\\nStep-1: Traverse the array\\nStep-2: At each traversal simply multiply the two numbers and store it at the \\'i-th\\' place.\\nStep-3: Sort the array and return its value.",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        \\n        for(int i=0;i<nums.length;i++){\\n            \\n            nums[i]=nums[i]*nums[i];\\n        }\\n        \\n        Arrays.sort(nums);\\n        \\n        return nums;\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1903311,
                "title": "most-efficient-python-solution-using-two-pointers-approach",
                "content": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        l=0\\n        r=len(nums)-1\\n        ans=[0]*len(nums)\\n        for i in range(len(nums)-1,-1,-1):\\n            if nums[l]**2<nums[r]**2:\\n                ans[i]=nums[r]**2\\n                r-=1\\n            else:\\n                ans[i]=nums[l]**2\\n                l+=1\\n        return ans\\n```\\n**Complexity Analysis**\\n\\nTime Complexity: O(n) [Linear]\\nSpace complexity: O(n)\\n\\n**PLEASE UPVOTE FOR MOTIVATING ME TO CONTINUE COMMUNITY SUPPORT**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        l=0\\n        r=len(nums)-1\\n        ans=[0]*len(nums)\\n        for i in range(len(nums)-1,-1,-1):\\n            if nums[l]**2<nums[r]**2:\\n                ans[i]=nums[r]**2\\n                r-=1\\n            else:\\n                ans[i]=nums[l]**2\\n                l+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1874940,
                "title": "python3-two-pointers-approach",
                "content": "In the two pointer approach you have to use two pointers to move around the array an do the stuff that you need.\\n\\nSo in this case, we have a pointer to the start of the array and another pointer in the end of the array. We compare the absolute value of the two values and get the bigger one, square the value and put at the end of the new array, and increment or decrement the pointer depending on which value is bigger.\\n\\nContinue on the loop till the start pointer is == to the end pointer and you will have the new array ordened with the squared values.\\n\\nPlease, if you have a better solution using the two pointers approach let me know!!! :D\\n\\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        length = len(nums)\\n        start, end = 0, length - 1\\n        res = [0]*length\\n        index = -1\\n\\n        while start <= end:\\n            if abs(nums[start]) > abs(nums[end]):\\n                res[index] = nums[start] * nums[start]\\n                start += 1\\n            else:\\n                res[index] = nums[end] * nums[end]\\n                end -= 1\\n            index -= 1\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        length = len(nums)\\n        start, end = 0, length - 1\\n        res = [0]*length\\n        index = -1\\n\\n        while start <= end:\\n            if abs(nums[start]) > abs(nums[end]):\\n                res[index] = nums[start] * nums[start]\\n                start += 1\\n            else:\\n                res[index] = nums[end] * nums[end]\\n                end -= 1\\n            index -= 1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1792436,
                "title": "python-two-pointer-98-less-space",
                "content": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        left = 0\\n        right = len(nums) - 1\\n        \\n        while left <= right:\\n            l_sq = nums[left]**2\\n            r_sq = nums[right]**2\\n            \\n            if l_sq > r_sq:\\n                nums.insert(right + 1, l_sq)\\n                nums.pop(left)\\n            else:\\n                nums[right] = r_sq\\n            \\n            right -= 1\\n                \\n        return nums\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        left = 0\\n        right = len(nums) - 1\\n        \\n        while left <= right:\\n            l_sq = nums[left]**2\\n            r_sq = nums[right]**2\\n            \\n            if l_sq > r_sq:\\n                nums.insert(right + 1, l_sq)\\n                nums.pop(left)\\n            else:\\n                nums[right] = r_sq\\n            \\n            right -= 1\\n                \\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1759471,
                "title": "go-two-solutions-sort-o-nlogn-and-two-pointers-o-n",
                "content": "Hello Gophers!\\n\\n## Without the constraint O(n)\\n\\n### Solution 1 - Sort O(nlogn)\\n\\n```go\\nfunc sortedSquares(nums []int) []int {\\n    for idx, num := range nums {\\n        num *= num\\n        nums[idx] = num\\n    }\\n    sort.Ints(nums) // This is the reason why it\\'s O(nlogn)\\n    return nums\\n}\\n```\\n\\n## With the constraint O(n)\\n\\n> Constraint: Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach?\\n\\n### Solution 2 - Two Pointers O(n)\\n\\nInstead of sorting, we use two pointers.\\nWe square all the nums, we add the numbers to the result slice (array)\\nfrom the smallest to the biggest, from middle of the array to the extemities (begin/end).\\n\\n```go\\nfunc sortedSquares(nums []int) []int {\\n    // STEP 1\\n\\t// First, we square all the nums\\n    for idx, num := range nums {\\n        num *= num\\n        nums[idx] = num\\n    }\\n    \\n    if len(nums) <= 1 {\\n        return nums\\n    }\\n    \\n\\t// STEP 2\\n\\t// After this, we move our two pointers where the smallest number is found\\n\\t// (near center, could be beginning or end)\\n    var ptr1, ptr2 int = 0, 1\\n    for ptr2 < len(nums)-1 && nums[ptr1] >= nums[ptr1+1] && nums[ptr2] >= nums[ptr2+1] {\\n        ptr1++\\n        ptr2++\\n    }\\n    \\n\\t// STEP 3\\n\\t// We add the smallest number to the result slice (array)\\n\\t//\\n\\t// If we add the value of the first pointer `ptr1`, we move it to left\\n\\t// Else if we add the value of the second pointer `ptr2`, we move it to the right\\n\\t// \\n\\t// If we are done with one pointer, to add values of the other pointers.\\n\\t// And we do this until we can\\'t.\\n    result := make([]int, 0)\\n    for {\\n        if ptr1 < 0 && ptr2 >= len(nums) {\\n            return result\\n        } else if ptr1 < 0 {\\n            result = append(result, nums[ptr2])\\n            ptr2++\\n        } else if ptr2 >= len(nums) {\\n            result = append(result, nums[ptr1])\\n            ptr1--\\n        } else if nums[ptr1] <= nums[ptr2] {\\n            result = append(result, nums[ptr1])\\n            ptr1--\\n        } else {\\n            result = append(result, nums[ptr2])\\n            ptr2++\\n        }\\n    }\\n    \\n    return result\\n}\\n```\\n\\n### Solution 3 - Two Pointers improved O(n)\\n\\nInspired by [this great solution](https://leetcode.com/problems/squares-of-a-sorted-array/discuss/495394/C%2B%2B%3A-Simplest-one-pass-two-pointers) (please, go like his post if you liked mine because of this solution):  \\ndo the same as the second solution, but\\n- we don\\'t square the values (step 1) before the construction of our result slice (step 3)\\n- we add the numbers to the result slice (array) from the biggest to the smallest, from the extemities (begin/end) of the array to the middle (no need of step 2)\\n\\n```go\\nfunc sortedSquares(nums []int) []int {\\n    var ptr1, ptr2 int = 0, len(nums)-1\\n    var currentIndex int = len(nums)-1\\n    result := make([]int, len(nums))\\n    for ptr2 >= ptr1 {    \\n        val1, val2 := nums[ptr1], nums[ptr2]\\n        sqr1, sqr2 := val1*val1, val2*val2\\n        if sqr1 >= sqr2 {\\n            result[currentIndex] = sqr1\\n            ptr1++\\n        } else /* if sqr1 < sqr2 */ {\\n            result[currentIndex] = sqr2\\n            ptr2--\\n        }\\n        currentIndex--\\n    }\\n    return result\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Two Pointers"
                ],
                "code": "```go\\nfunc sortedSquares(nums []int) []int {\\n    for idx, num := range nums {\\n        num *= num\\n        nums[idx] = num\\n    }\\n    sort.Ints(nums) // This is the reason why it\\'s O(nlogn)\\n    return nums\\n}\\n```\n```go\\nfunc sortedSquares(nums []int) []int {\\n    // STEP 1\\n\\t// First, we square all the nums\\n    for idx, num := range nums {\\n        num *= num\\n        nums[idx] = num\\n    }\\n    \\n    if len(nums) <= 1 {\\n        return nums\\n    }\\n    \\n\\t// STEP 2\\n\\t// After this, we move our two pointers where the smallest number is found\\n\\t// (near center, could be beginning or end)\\n    var ptr1, ptr2 int = 0, 1\\n    for ptr2 < len(nums)-1 && nums[ptr1] >= nums[ptr1+1] && nums[ptr2] >= nums[ptr2+1] {\\n        ptr1++\\n        ptr2++\\n    }\\n    \\n\\t// STEP 3\\n\\t// We add the smallest number to the result slice (array)\\n\\t//\\n\\t// If we add the value of the first pointer `ptr1`, we move it to left\\n\\t// Else if we add the value of the second pointer `ptr2`, we move it to the right\\n\\t// \\n\\t// If we are done with one pointer, to add values of the other pointers.\\n\\t// And we do this until we can\\'t.\\n    result := make([]int, 0)\\n    for {\\n        if ptr1 < 0 && ptr2 >= len(nums) {\\n            return result\\n        } else if ptr1 < 0 {\\n            result = append(result, nums[ptr2])\\n            ptr2++\\n        } else if ptr2 >= len(nums) {\\n            result = append(result, nums[ptr1])\\n            ptr1--\\n        } else if nums[ptr1] <= nums[ptr2] {\\n            result = append(result, nums[ptr1])\\n            ptr1--\\n        } else {\\n            result = append(result, nums[ptr2])\\n            ptr2++\\n        }\\n    }\\n    \\n    return result\\n}\\n```\n```go\\nfunc sortedSquares(nums []int) []int {\\n    var ptr1, ptr2 int = 0, len(nums)-1\\n    var currentIndex int = len(nums)-1\\n    result := make([]int, len(nums))\\n    for ptr2 >= ptr1 {    \\n        val1, val2 := nums[ptr1], nums[ptr2]\\n        sqr1, sqr2 := val1*val1, val2*val2\\n        if sqr1 >= sqr2 {\\n            result[currentIndex] = sqr1\\n            ptr1++\\n        } else /* if sqr1 < sqr2 */ {\\n            result[currentIndex] = sqr2\\n            ptr2--\\n        }\\n        currentIndex--\\n    }\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1683558,
                "title": "python-2-approaches",
                "content": "### Approach 1: \\n*  **Using Python Bisect to find the position to keep the element, so that the array remains sorted.**\\n \\n```\\nclass Solution(object):\\n    def sortedSquares(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        negativeList = []\\n        positiveList = []\\n        \\n        if len(nums) == 1:\\n            return [nums[0]**2]\\n        \\n        for i in nums:\\n            if i<0:\\n                negativeList.append(i)\\n            else:\\n                positiveList.append(i)\\n                \\n        negativeList = [abs(i) for i in negativeList]\\n\\n        for  i in negativeList:\\n            x = bisect.bisect(positiveList, i)\\n            positiveList.insert(x,i)\\n        \\n        res = [i*i for i in positiveList]\\n        return res\\n```       \\n\\n   ### Approach 2:\\n*    **Using two pointers technique**\\n*   **Took less time than the first approach**\\n\\n   ```\\n   class Solution(object):\\n    def sortedSquares(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        left = 0\\n        right = len(nums) - 1\\n        answer = [None]*len(nums)\\n        for i in range(len(nums)-1,-1,-1):\\n            if abs(nums[left]) > abs(nums[right]):\\n                answer[i] = nums[left]**2\\n                left += 1\\n                \\n            else:\\n                answer[i] = nums[right]**2\\n                right-=1\\n        return answer\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution(object):\\n    def sortedSquares(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        negativeList = []\\n        positiveList = []\\n        \\n        if len(nums) == 1:\\n            return [nums[0]**2]\\n        \\n        for i in nums:\\n            if i<0:\\n                negativeList.append(i)\\n            else:\\n                positiveList.append(i)\\n                \\n        negativeList = [abs(i) for i in negativeList]\\n\\n        for  i in negativeList:\\n            x = bisect.bisect(positiveList, i)\\n            positiveList.insert(x,i)\\n        \\n        res = [i*i for i in positiveList]\\n        return res\\n```\n```\\n   class Solution(object):\\n    def sortedSquares(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        left = 0\\n        right = len(nums) - 1\\n        answer = [None]*len(nums)\\n        for i in range(len(nums)-1,-1,-1):\\n            if abs(nums[left]) > abs(nums[right]):\\n                answer[i] = nums[left]**2\\n                left += 1\\n                \\n            else:\\n                answer[i] = nums[right]**2\\n                right-=1\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1658950,
                "title": "c-naive-vs-linear-time-constant-space-2-pointer-solution-100-time-90-space",
                "content": "First of all, the naive approach, which is trivially transforming the array and then sorting it, in place:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& A) {\\n        std::transform(begin(A), end(A), begin(A), [](int a){ return a * a; });\\n        sort(begin(A), end(A));\\n        return A;\\n    }\\n};\\n```\\n\\nPlus another variant of it I wrote [here](https://leetcode.com/problems/squares-of-a-sorted-array/discuss/793033/C%2B%2B-In-Place-3-Lines-Solution-Explained-~60-Time-~90-Space) a while ago.\\n\\nStill decent start in an interview setting, but odds are is that we will be asked the follow up question of this problem soon, so how can we solve it in linear time, even if it requires us to sort the elements following a new criterium?\\n\\nWell, turns out that we are not really left on our own device on this point, since we are provided an array that is *initially* already sorted and that is no small advantage at all!\\n\\nThe trick will be for us to pinpoint there the negative numbers end and when the positive ones star, with two separate points - at that point, we will pick the lesser one in absolute value and insert it into our result variable and so on.\\n\\nIn order to proceed, we will first of all declare a few support variables:\\n* `len` will store the length of our initial input, which also happens to be the length of our result variable;\\n* `i` will be the pointer set at the beginning of all the non-negative numbers (ie: `0` included, for convenience, not that it would change much if you were to put it under the other pointer); since `nums` is given to us as sorted, we can find this place in logn time, with built-in binary search (just be ready to explain how it works in an interview!);\\n* `j`, specularly, will point to the last (and thus lesser, since `nums` is sorted) negative number, right before `i`;\\n* `r` will point to where in `res` we will go writing;\\n* `n` is a support variable we will use soon;\\n* `res` is our accumulator variable, initially set to be of size `len` to avoid reallocations (and that is also why we have to use `r` to write in it).\\n\\nWe will then have a first loop that will proceed as long both `i` and `j` are within the boundaries of `nums` and that will:\\n* check if the absolute value of the element pointed by `j` is smaller than the one pointed by `i`, in which case we will:\\n\\t* store `nums[j]` into `n`;\\n\\t* decrease `j`;\\n\\t* write `n * n` in `res` at position `r`;\\n\\t* increase `r`;\\n* alternatively, we will:\\n\\t* store `nums[i]` into `n`;\\n\\t* increase `i`;\\n\\t* write `n * n` in `res` at position `r`;\\n\\t* increase `r`;\\n\\nFor the sake of efficiency, once either of this conditions is no longer `true`, we will then run two separate loops to do what we did in the first or second case, until even the second pointer is out of boundaries (ie: we are done writing into `res`); a bit of duplicated code, I concede, but still rather good to avoid looping with one extra unnecessary condition.\\n\\nOnce done, we can return `res` :)\\n\\nThe code (which varies crazily in performance when you run it, sometimes logging more than 4X the best time, my guess is because the test cases were not really well balanced across different runs):\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int len = nums.size(), i = lower_bound(begin(nums), end(nums), 0) - begin(nums),\\n            j = i - 1, r = 0, n;\\n        vector<int> res(len);\\n        while (j > -1 && i < len) {\\n            // first case: negative number with smaller absolute value\\n            if (-nums[j] < nums[i]) {\\n                n = nums[j--];\\n                res[r++] = n * n;\\n            }\\n            // second case: positive number with smaller absolute value\\n            else {\\n                n = nums[i++];\\n                res[r++] = n * n;\\n            }\\n        }\\n        // dealing with leftover negative numbers, if any\\n        while (j > -1) {\\n            n = nums[j--];\\n            res[r++] = n * n;\\n        }\\n        // dealing with leftover positive numbers, if any\\n        while (i < len) {\\n            n = nums[i++];\\n            res[r++] = n * n;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nBut, hey: since `lower_bound` gives us iterators, can\\'t we just use them? Turns out we of course can and they also perform better, at least running the code a few times for comparison:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int len = nums.size(), r = 0;\\n        auto start = begin(nums), ed = end(nums), i = lower_bound(start, ed, 0), j = i - 1;\\n        vector<int> res(len);\\n        while (j >= start && i != ed) {\\n            // first case: negative number with smaller absolute value\\n            if (-*j < *i) res[r++] = *j * *j--;\\n            // second case: positive number with smaller absolute value\\n            else res[r++] = *i * *i++;\\n        }\\n        // dealing with leftover negative numbers, if any\\n        while (j >= start) {\\n            res[r++] = *j * *j--;\\n        }\\n        // dealing with leftover positive numbers, if any\\n        while (i != ed) {\\n            res[r++] = *i * *i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Sorting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& A) {\\n        std::transform(begin(A), end(A), begin(A), [](int a){ return a * a; });\\n        sort(begin(A), end(A));\\n        return A;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int len = nums.size(), i = lower_bound(begin(nums), end(nums), 0) - begin(nums),\\n            j = i - 1, r = 0, n;\\n        vector<int> res(len);\\n        while (j > -1 && i < len) {\\n            // first case: negative number with smaller absolute value\\n            if (-nums[j] < nums[i]) {\\n                n = nums[j--];\\n                res[r++] = n * n;\\n            }\\n            // second case: positive number with smaller absolute value\\n            else {\\n                n = nums[i++];\\n                res[r++] = n * n;\\n            }\\n        }\\n        // dealing with leftover negative numbers, if any\\n        while (j > -1) {\\n            n = nums[j--];\\n            res[r++] = n * n;\\n        }\\n        // dealing with leftover positive numbers, if any\\n        while (i < len) {\\n            n = nums[i++];\\n            res[r++] = n * n;\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int len = nums.size(), r = 0;\\n        auto start = begin(nums), ed = end(nums), i = lower_bound(start, ed, 0), j = i - 1;\\n        vector<int> res(len);\\n        while (j >= start && i != ed) {\\n            // first case: negative number with smaller absolute value\\n            if (-*j < *i) res[r++] = *j * *j--;\\n            // second case: positive number with smaller absolute value\\n            else res[r++] = *i * *i++;\\n        }\\n        // dealing with leftover negative numbers, if any\\n        while (j >= start) {\\n            res[r++] = *j * *j--;\\n        }\\n        // dealing with leftover positive numbers, if any\\n        while (i != ed) {\\n            res[r++] = *i * *i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1627416,
                "title": "easy-c-solution-with-two-pointers",
                "content": "```\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        vector <int> arr(nums.size());\\n\\t\\t// q and p are pointers, k is needed to push highest elements at the end of a new array\\n        int q=0, p=nums.size()-1, k=nums.size()-1;\\n        \\n        while(q<=p){\\n            if(nums[q]*nums[q]>nums[p]*nums[p]){\\n                arr[k--]=nums[q]*nums[q]; // Here we push at the end\\n                q++;\\n            }\\n            else{\\n                arr[k--]=nums[p]*nums[p];\\n                p--;\\n            }\\n        }\\n        return arr;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        vector <int> arr(nums.size());\\n\\t\\t// q and p are pointers, k is needed to push highest elements at the end of a new array\\n        int q=0, p=nums.size()-1, k=nums.size()-1;\\n        \\n        while(q<=p){\\n            if(nums[q]*nums[q]>nums[p]*nums[p]){\\n                arr[k--]=nums[q]*nums[q]; // Here we push at the end\\n                q++;\\n            }\\n            else{\\n                arr[k--]=nums[p]*nums[p];\\n                p--;\\n            }\\n        }\\n        return arr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1577468,
                "title": "java-linear-time-solution",
                "content": "class Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        \\n        int n= nums.length;\\n        int left=0;\\n        int right=n-1;\\n        int[] answer = new int[n];\\n        \\n        for( int i=n-1;i>=0;i--)\\n        {\\n            int square =0;\\n            // We take a reverse approach for negative numbers\\n            if(Math.abs(nums[left])< Math.abs(nums[right]))\\n            {\\n                square= nums[right];\\n                right--;\\n            }\\n            else\\n            {\\n                square = nums[left];\\n                left++;  \\n            }\\n                \\n            answer[i]= square*square;\\n        }\\n        return answer;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        \\n        int n= nums.length;\\n        int left=0;\\n        int right=n-1;\\n        int[] answer = new int[n];\\n        \\n        for( int i=n-1;i>=0;i--)\\n        {\\n            int square =0;\\n            // We take a reverse approach for negative numbers\\n            if(Math.abs(nums[left])< Math.abs(nums[right]))\\n            {\\n                square= nums[right];\\n                right--;\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1576438,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1565880,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1564797,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1570583,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1570076,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1575767,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1573931,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1573757,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1969402,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1575297,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1576438,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1565880,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1564797,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1570583,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1570076,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1575767,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1573931,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1573757,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1969402,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1575297,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1573930,
                "content": [
                    {
                        "username": "nikash",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "satwik95",
                        "content": "\\tvar sortedSquares = function(A) {\\n\\t\\treturn A.map(function(item){return item*item;}).sort(function(a, b){return a-b;});\\n\\t};"
                    },
                    {
                        "username": "dmc8686",
                        "content": "O(nlogn) seems to be the faster one than O(n). Testcases aren\\'t big enough I think."
                    },
                    {
                        "username": "talk2ritaj",
                        "content": "for i in range(len(nums)):\\n\\t nums[i]=nums[i]**2\\nreturn sorted(nums)"
                    },
                    {
                        "username": "_Ivan_Vigorito_",
                        "content": "If you like it, Upvote ;) \\n\\n\\n#### Solution\\nreturn sorted(map(lambda x: (x)**2, nums))"
                    },
                    {
                        "username": "zxak",
                        "content": "solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/squares-of-sorted-array.html"
                    },
                    {
                        "username": "kunalchitkara",
                        "content": "`var sortedSquares = A => A.sort((x,y) => Math.abs(x) - Math.abs(y)).map(x => x*x);`"
                    },
                    {
                        "username": "tushartiwari25",
                        "content": "Can anyone explain how a two pointer solution in one of binary search...."
                    },
                    {
                        "username": "__buruno",
                        "content": "it maybe a very dumb question but i\\'ll ask anyway... can anybody explain to me why do i need to do *returnsize = numsSize?"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "after putting this constraint: \"Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach\", it doesn\\'t remain easy anymore"
                    }
                ]
            },
            {
                "id": 1572727,
                "content": [
                    {
                        "username": "nikash",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "satwik95",
                        "content": "\\tvar sortedSquares = function(A) {\\n\\t\\treturn A.map(function(item){return item*item;}).sort(function(a, b){return a-b;});\\n\\t};"
                    },
                    {
                        "username": "dmc8686",
                        "content": "O(nlogn) seems to be the faster one than O(n). Testcases aren\\'t big enough I think."
                    },
                    {
                        "username": "talk2ritaj",
                        "content": "for i in range(len(nums)):\\n\\t nums[i]=nums[i]**2\\nreturn sorted(nums)"
                    },
                    {
                        "username": "_Ivan_Vigorito_",
                        "content": "If you like it, Upvote ;) \\n\\n\\n#### Solution\\nreturn sorted(map(lambda x: (x)**2, nums))"
                    },
                    {
                        "username": "zxak",
                        "content": "solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/squares-of-sorted-array.html"
                    },
                    {
                        "username": "kunalchitkara",
                        "content": "`var sortedSquares = A => A.sort((x,y) => Math.abs(x) - Math.abs(y)).map(x => x*x);`"
                    },
                    {
                        "username": "tushartiwari25",
                        "content": "Can anyone explain how a two pointer solution in one of binary search...."
                    },
                    {
                        "username": "__buruno",
                        "content": "it maybe a very dumb question but i\\'ll ask anyway... can anybody explain to me why do i need to do *returnsize = numsSize?"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "after putting this constraint: \"Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach\", it doesn\\'t remain easy anymore"
                    }
                ]
            },
            {
                "id": 1572541,
                "content": [
                    {
                        "username": "nikash",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "satwik95",
                        "content": "\\tvar sortedSquares = function(A) {\\n\\t\\treturn A.map(function(item){return item*item;}).sort(function(a, b){return a-b;});\\n\\t};"
                    },
                    {
                        "username": "dmc8686",
                        "content": "O(nlogn) seems to be the faster one than O(n). Testcases aren\\'t big enough I think."
                    },
                    {
                        "username": "talk2ritaj",
                        "content": "for i in range(len(nums)):\\n\\t nums[i]=nums[i]**2\\nreturn sorted(nums)"
                    },
                    {
                        "username": "_Ivan_Vigorito_",
                        "content": "If you like it, Upvote ;) \\n\\n\\n#### Solution\\nreturn sorted(map(lambda x: (x)**2, nums))"
                    },
                    {
                        "username": "zxak",
                        "content": "solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/squares-of-sorted-array.html"
                    },
                    {
                        "username": "kunalchitkara",
                        "content": "`var sortedSquares = A => A.sort((x,y) => Math.abs(x) - Math.abs(y)).map(x => x*x);`"
                    },
                    {
                        "username": "tushartiwari25",
                        "content": "Can anyone explain how a two pointer solution in one of binary search...."
                    },
                    {
                        "username": "__buruno",
                        "content": "it maybe a very dumb question but i\\'ll ask anyway... can anybody explain to me why do i need to do *returnsize = numsSize?"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "after putting this constraint: \"Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach\", it doesn\\'t remain easy anymore"
                    }
                ]
            },
            {
                "id": 1576328,
                "content": [
                    {
                        "username": "nikash",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "satwik95",
                        "content": "\\tvar sortedSquares = function(A) {\\n\\t\\treturn A.map(function(item){return item*item;}).sort(function(a, b){return a-b;});\\n\\t};"
                    },
                    {
                        "username": "dmc8686",
                        "content": "O(nlogn) seems to be the faster one than O(n). Testcases aren\\'t big enough I think."
                    },
                    {
                        "username": "talk2ritaj",
                        "content": "for i in range(len(nums)):\\n\\t nums[i]=nums[i]**2\\nreturn sorted(nums)"
                    },
                    {
                        "username": "_Ivan_Vigorito_",
                        "content": "If you like it, Upvote ;) \\n\\n\\n#### Solution\\nreturn sorted(map(lambda x: (x)**2, nums))"
                    },
                    {
                        "username": "zxak",
                        "content": "solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/squares-of-sorted-array.html"
                    },
                    {
                        "username": "kunalchitkara",
                        "content": "`var sortedSquares = A => A.sort((x,y) => Math.abs(x) - Math.abs(y)).map(x => x*x);`"
                    },
                    {
                        "username": "tushartiwari25",
                        "content": "Can anyone explain how a two pointer solution in one of binary search...."
                    },
                    {
                        "username": "__buruno",
                        "content": "it maybe a very dumb question but i\\'ll ask anyway... can anybody explain to me why do i need to do *returnsize = numsSize?"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "after putting this constraint: \"Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach\", it doesn\\'t remain easy anymore"
                    }
                ]
            },
            {
                "id": 1576715,
                "content": [
                    {
                        "username": "nikash",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "satwik95",
                        "content": "\\tvar sortedSquares = function(A) {\\n\\t\\treturn A.map(function(item){return item*item;}).sort(function(a, b){return a-b;});\\n\\t};"
                    },
                    {
                        "username": "dmc8686",
                        "content": "O(nlogn) seems to be the faster one than O(n). Testcases aren\\'t big enough I think."
                    },
                    {
                        "username": "talk2ritaj",
                        "content": "for i in range(len(nums)):\\n\\t nums[i]=nums[i]**2\\nreturn sorted(nums)"
                    },
                    {
                        "username": "_Ivan_Vigorito_",
                        "content": "If you like it, Upvote ;) \\n\\n\\n#### Solution\\nreturn sorted(map(lambda x: (x)**2, nums))"
                    },
                    {
                        "username": "zxak",
                        "content": "solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/squares-of-sorted-array.html"
                    },
                    {
                        "username": "kunalchitkara",
                        "content": "`var sortedSquares = A => A.sort((x,y) => Math.abs(x) - Math.abs(y)).map(x => x*x);`"
                    },
                    {
                        "username": "tushartiwari25",
                        "content": "Can anyone explain how a two pointer solution in one of binary search...."
                    },
                    {
                        "username": "__buruno",
                        "content": "it maybe a very dumb question but i\\'ll ask anyway... can anybody explain to me why do i need to do *returnsize = numsSize?"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "after putting this constraint: \"Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach\", it doesn\\'t remain easy anymore"
                    }
                ]
            },
            {
                "id": 1574693,
                "content": [
                    {
                        "username": "nikash",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "satwik95",
                        "content": "\\tvar sortedSquares = function(A) {\\n\\t\\treturn A.map(function(item){return item*item;}).sort(function(a, b){return a-b;});\\n\\t};"
                    },
                    {
                        "username": "dmc8686",
                        "content": "O(nlogn) seems to be the faster one than O(n). Testcases aren\\'t big enough I think."
                    },
                    {
                        "username": "talk2ritaj",
                        "content": "for i in range(len(nums)):\\n\\t nums[i]=nums[i]**2\\nreturn sorted(nums)"
                    },
                    {
                        "username": "_Ivan_Vigorito_",
                        "content": "If you like it, Upvote ;) \\n\\n\\n#### Solution\\nreturn sorted(map(lambda x: (x)**2, nums))"
                    },
                    {
                        "username": "zxak",
                        "content": "solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/squares-of-sorted-array.html"
                    },
                    {
                        "username": "kunalchitkara",
                        "content": "`var sortedSquares = A => A.sort((x,y) => Math.abs(x) - Math.abs(y)).map(x => x*x);`"
                    },
                    {
                        "username": "tushartiwari25",
                        "content": "Can anyone explain how a two pointer solution in one of binary search...."
                    },
                    {
                        "username": "__buruno",
                        "content": "it maybe a very dumb question but i\\'ll ask anyway... can anybody explain to me why do i need to do *returnsize = numsSize?"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "after putting this constraint: \"Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach\", it doesn\\'t remain easy anymore"
                    }
                ]
            },
            {
                "id": 1573915,
                "content": [
                    {
                        "username": "nikash",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "satwik95",
                        "content": "\\tvar sortedSquares = function(A) {\\n\\t\\treturn A.map(function(item){return item*item;}).sort(function(a, b){return a-b;});\\n\\t};"
                    },
                    {
                        "username": "dmc8686",
                        "content": "O(nlogn) seems to be the faster one than O(n). Testcases aren\\'t big enough I think."
                    },
                    {
                        "username": "talk2ritaj",
                        "content": "for i in range(len(nums)):\\n\\t nums[i]=nums[i]**2\\nreturn sorted(nums)"
                    },
                    {
                        "username": "_Ivan_Vigorito_",
                        "content": "If you like it, Upvote ;) \\n\\n\\n#### Solution\\nreturn sorted(map(lambda x: (x)**2, nums))"
                    },
                    {
                        "username": "zxak",
                        "content": "solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/squares-of-sorted-array.html"
                    },
                    {
                        "username": "kunalchitkara",
                        "content": "`var sortedSquares = A => A.sort((x,y) => Math.abs(x) - Math.abs(y)).map(x => x*x);`"
                    },
                    {
                        "username": "tushartiwari25",
                        "content": "Can anyone explain how a two pointer solution in one of binary search...."
                    },
                    {
                        "username": "__buruno",
                        "content": "it maybe a very dumb question but i\\'ll ask anyway... can anybody explain to me why do i need to do *returnsize = numsSize?"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "after putting this constraint: \"Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach\", it doesn\\'t remain easy anymore"
                    }
                ]
            },
            {
                "id": 2073126,
                "content": [
                    {
                        "username": "nikash",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "satwik95",
                        "content": "\\tvar sortedSquares = function(A) {\\n\\t\\treturn A.map(function(item){return item*item;}).sort(function(a, b){return a-b;});\\n\\t};"
                    },
                    {
                        "username": "dmc8686",
                        "content": "O(nlogn) seems to be the faster one than O(n). Testcases aren\\'t big enough I think."
                    },
                    {
                        "username": "talk2ritaj",
                        "content": "for i in range(len(nums)):\\n\\t nums[i]=nums[i]**2\\nreturn sorted(nums)"
                    },
                    {
                        "username": "_Ivan_Vigorito_",
                        "content": "If you like it, Upvote ;) \\n\\n\\n#### Solution\\nreturn sorted(map(lambda x: (x)**2, nums))"
                    },
                    {
                        "username": "zxak",
                        "content": "solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/squares-of-sorted-array.html"
                    },
                    {
                        "username": "kunalchitkara",
                        "content": "`var sortedSquares = A => A.sort((x,y) => Math.abs(x) - Math.abs(y)).map(x => x*x);`"
                    },
                    {
                        "username": "tushartiwari25",
                        "content": "Can anyone explain how a two pointer solution in one of binary search...."
                    },
                    {
                        "username": "__buruno",
                        "content": "it maybe a very dumb question but i\\'ll ask anyway... can anybody explain to me why do i need to do *returnsize = numsSize?"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "after putting this constraint: \"Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach\", it doesn\\'t remain easy anymore"
                    }
                ]
            },
            {
                "id": 1929284,
                "content": [
                    {
                        "username": "nikash",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "satwik95",
                        "content": "\\tvar sortedSquares = function(A) {\\n\\t\\treturn A.map(function(item){return item*item;}).sort(function(a, b){return a-b;});\\n\\t};"
                    },
                    {
                        "username": "dmc8686",
                        "content": "O(nlogn) seems to be the faster one than O(n). Testcases aren\\'t big enough I think."
                    },
                    {
                        "username": "talk2ritaj",
                        "content": "for i in range(len(nums)):\\n\\t nums[i]=nums[i]**2\\nreturn sorted(nums)"
                    },
                    {
                        "username": "_Ivan_Vigorito_",
                        "content": "If you like it, Upvote ;) \\n\\n\\n#### Solution\\nreturn sorted(map(lambda x: (x)**2, nums))"
                    },
                    {
                        "username": "zxak",
                        "content": "solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/squares-of-sorted-array.html"
                    },
                    {
                        "username": "kunalchitkara",
                        "content": "`var sortedSquares = A => A.sort((x,y) => Math.abs(x) - Math.abs(y)).map(x => x*x);`"
                    },
                    {
                        "username": "tushartiwari25",
                        "content": "Can anyone explain how a two pointer solution in one of binary search...."
                    },
                    {
                        "username": "__buruno",
                        "content": "it maybe a very dumb question but i\\'ll ask anyway... can anybody explain to me why do i need to do *returnsize = numsSize?"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "after putting this constraint: \"Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach\", it doesn\\'t remain easy anymore"
                    }
                ]
            },
            {
                "id": 1915592,
                "content": [
                    {
                        "username": "nikash",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "satwik95",
                        "content": "\\tvar sortedSquares = function(A) {\\n\\t\\treturn A.map(function(item){return item*item;}).sort(function(a, b){return a-b;});\\n\\t};"
                    },
                    {
                        "username": "dmc8686",
                        "content": "O(nlogn) seems to be the faster one than O(n). Testcases aren\\'t big enough I think."
                    },
                    {
                        "username": "talk2ritaj",
                        "content": "for i in range(len(nums)):\\n\\t nums[i]=nums[i]**2\\nreturn sorted(nums)"
                    },
                    {
                        "username": "_Ivan_Vigorito_",
                        "content": "If you like it, Upvote ;) \\n\\n\\n#### Solution\\nreturn sorted(map(lambda x: (x)**2, nums))"
                    },
                    {
                        "username": "zxak",
                        "content": "solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/squares-of-sorted-array.html"
                    },
                    {
                        "username": "kunalchitkara",
                        "content": "`var sortedSquares = A => A.sort((x,y) => Math.abs(x) - Math.abs(y)).map(x => x*x);`"
                    },
                    {
                        "username": "tushartiwari25",
                        "content": "Can anyone explain how a two pointer solution in one of binary search...."
                    },
                    {
                        "username": "__buruno",
                        "content": "it maybe a very dumb question but i\\'ll ask anyway... can anybody explain to me why do i need to do *returnsize = numsSize?"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "after putting this constraint: \"Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach\", it doesn\\'t remain easy anymore"
                    }
                ]
            },
            {
                "id": 1888341,
                "content": [
                    {
                        "username": "ansarnitp",
                        "content": "Is it possible to solve in O(n) time and O(k) space ?\\nLike in two pointer method, we use an extra array to store the values. But I don\\'t want to use any extra array and sort the squared result in the same array itself."
                    },
                    {
                        "username": "manojjha",
                        "content": "Hello guys for my below solution my testcases are passing when I run the code but when I submit it then I get error \"Time Limit Exceeded\". In submission it 128/137 testcases passed \\n\"\"\"class Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        SquareList=[]\\n        SquareList = [num**2 for num in nums]\\n        for i in range(len(SquareList)):\\n            for j in range(len(SquareList)):\\n                if SquareList[i]<SquareList[j]:\\n                    SquareList[j], SquareList[i] = SquareList[i],SquareList[j]\\n        return SquareList\"\"\"\\nWhat is wrong I am doing in this?\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Hope you aren\\'t gonna do sorting :)"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "Further follow-up. Is there a solution of O(N) time complexity and at the same time sort the array in-place? \\n\\nIn the \"merge two sorted array\" approach, I can only think of copying the negatives to a new array and fill back into the original nums array. Can we avoid the \"copying\" into a new array part?"
                    },
                    {
                        "username": "chubbycccc",
                        "content": "Hello guys, would you like to help me to solve this error?  I have no idea why the error showed that\"list assignment index out of range\" for the \"result[k]=result[j]*result[j].\\nThanks a lot !\\n\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n          result=[]\\n          n=len(nums)\\n          k,j=n-1,n-1\\n          i=0\\n         while i<=j:\\n            if nums[i]*nums[i]>nums[j]*nums[j]:\\n                result[k]=nums[i]*nums[i]\\n                i+=1\\n            else:\\n                result[k]=nums[j]*nums[j]\\n                j-=1\\n            k-=1\\n        \\n        return result\\n"
                    },
                    {
                        "username": "payalraman0",
                        "content": "if you want to solve it in O(n) time ,it can be converted in merge two sorted arrays but you need extra space O(n) . I don\\'t know how to do it in TC: O(n), SC :O(1) "
                    },
                    {
                        "username": "payalraman0",
                        "content": "[@linuscodes56](/linuscodes56) you don\\'t need to reverse the array"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "amanjaiman890",
                        "content": "I Solved this question by 1ms O(n), you guys have any idea/solution that we can solve by 0ms :)"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "are you sure bro?.Seems confusing"
                    },
                    {
                        "username": "payalraman0",
                        "content": "Can you tell me how you have done in O(N)"
                    },
                    {
                        "username": "Ayu_0308958",
                        "content": " for(int i=0;i<nums.size();i++){\\n        nums[i] =(nums[i]*nums[i]);}\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n"
                    },
                    {
                        "username": "Bhavyaa_Arora_08",
                        "content": "Is an O(1) space or inplace solution possible for this question ?"
                    },
                    {
                        "username": "fireship_2004",
                        "content": "[@linuscodes56](/linuscodes56) stop spamming dude. you just said to push the values^2 in decreasing order in a new array then how come your solution stays in O(1) space complexity?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@linuscodes56](/linuscodes56) if you are using additional space then how it will be o(1).That will be o(n)"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "harshmishra3263",
                        "content": "I have solved this question using bubble sort and in this it is showing that you have passed 137 out of 137 test cases but above it is displaying time limit exceeded.\\n"
                    }
                ]
            },
            {
                "id": 1880457,
                "content": [
                    {
                        "username": "ansarnitp",
                        "content": "Is it possible to solve in O(n) time and O(k) space ?\\nLike in two pointer method, we use an extra array to store the values. But I don\\'t want to use any extra array and sort the squared result in the same array itself."
                    },
                    {
                        "username": "manojjha",
                        "content": "Hello guys for my below solution my testcases are passing when I run the code but when I submit it then I get error \"Time Limit Exceeded\". In submission it 128/137 testcases passed \\n\"\"\"class Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        SquareList=[]\\n        SquareList = [num**2 for num in nums]\\n        for i in range(len(SquareList)):\\n            for j in range(len(SquareList)):\\n                if SquareList[i]<SquareList[j]:\\n                    SquareList[j], SquareList[i] = SquareList[i],SquareList[j]\\n        return SquareList\"\"\"\\nWhat is wrong I am doing in this?\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Hope you aren\\'t gonna do sorting :)"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "Further follow-up. Is there a solution of O(N) time complexity and at the same time sort the array in-place? \\n\\nIn the \"merge two sorted array\" approach, I can only think of copying the negatives to a new array and fill back into the original nums array. Can we avoid the \"copying\" into a new array part?"
                    },
                    {
                        "username": "chubbycccc",
                        "content": "Hello guys, would you like to help me to solve this error?  I have no idea why the error showed that\"list assignment index out of range\" for the \"result[k]=result[j]*result[j].\\nThanks a lot !\\n\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n          result=[]\\n          n=len(nums)\\n          k,j=n-1,n-1\\n          i=0\\n         while i<=j:\\n            if nums[i]*nums[i]>nums[j]*nums[j]:\\n                result[k]=nums[i]*nums[i]\\n                i+=1\\n            else:\\n                result[k]=nums[j]*nums[j]\\n                j-=1\\n            k-=1\\n        \\n        return result\\n"
                    },
                    {
                        "username": "payalraman0",
                        "content": "if you want to solve it in O(n) time ,it can be converted in merge two sorted arrays but you need extra space O(n) . I don\\'t know how to do it in TC: O(n), SC :O(1) "
                    },
                    {
                        "username": "payalraman0",
                        "content": "[@linuscodes56](/linuscodes56) you don\\'t need to reverse the array"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "amanjaiman890",
                        "content": "I Solved this question by 1ms O(n), you guys have any idea/solution that we can solve by 0ms :)"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "are you sure bro?.Seems confusing"
                    },
                    {
                        "username": "payalraman0",
                        "content": "Can you tell me how you have done in O(N)"
                    },
                    {
                        "username": "Ayu_0308958",
                        "content": " for(int i=0;i<nums.size();i++){\\n        nums[i] =(nums[i]*nums[i]);}\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n"
                    },
                    {
                        "username": "Bhavyaa_Arora_08",
                        "content": "Is an O(1) space or inplace solution possible for this question ?"
                    },
                    {
                        "username": "fireship_2004",
                        "content": "[@linuscodes56](/linuscodes56) stop spamming dude. you just said to push the values^2 in decreasing order in a new array then how come your solution stays in O(1) space complexity?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@linuscodes56](/linuscodes56) if you are using additional space then how it will be o(1).That will be o(n)"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "harshmishra3263",
                        "content": "I have solved this question using bubble sort and in this it is showing that you have passed 137 out of 137 test cases but above it is displaying time limit exceeded.\\n"
                    }
                ]
            },
            {
                "id": 1856876,
                "content": [
                    {
                        "username": "ansarnitp",
                        "content": "Is it possible to solve in O(n) time and O(k) space ?\\nLike in two pointer method, we use an extra array to store the values. But I don\\'t want to use any extra array and sort the squared result in the same array itself."
                    },
                    {
                        "username": "manojjha",
                        "content": "Hello guys for my below solution my testcases are passing when I run the code but when I submit it then I get error \"Time Limit Exceeded\". In submission it 128/137 testcases passed \\n\"\"\"class Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        SquareList=[]\\n        SquareList = [num**2 for num in nums]\\n        for i in range(len(SquareList)):\\n            for j in range(len(SquareList)):\\n                if SquareList[i]<SquareList[j]:\\n                    SquareList[j], SquareList[i] = SquareList[i],SquareList[j]\\n        return SquareList\"\"\"\\nWhat is wrong I am doing in this?\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Hope you aren\\'t gonna do sorting :)"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "Further follow-up. Is there a solution of O(N) time complexity and at the same time sort the array in-place? \\n\\nIn the \"merge two sorted array\" approach, I can only think of copying the negatives to a new array and fill back into the original nums array. Can we avoid the \"copying\" into a new array part?"
                    },
                    {
                        "username": "chubbycccc",
                        "content": "Hello guys, would you like to help me to solve this error?  I have no idea why the error showed that\"list assignment index out of range\" for the \"result[k]=result[j]*result[j].\\nThanks a lot !\\n\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n          result=[]\\n          n=len(nums)\\n          k,j=n-1,n-1\\n          i=0\\n         while i<=j:\\n            if nums[i]*nums[i]>nums[j]*nums[j]:\\n                result[k]=nums[i]*nums[i]\\n                i+=1\\n            else:\\n                result[k]=nums[j]*nums[j]\\n                j-=1\\n            k-=1\\n        \\n        return result\\n"
                    },
                    {
                        "username": "payalraman0",
                        "content": "if you want to solve it in O(n) time ,it can be converted in merge two sorted arrays but you need extra space O(n) . I don\\'t know how to do it in TC: O(n), SC :O(1) "
                    },
                    {
                        "username": "payalraman0",
                        "content": "[@linuscodes56](/linuscodes56) you don\\'t need to reverse the array"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "amanjaiman890",
                        "content": "I Solved this question by 1ms O(n), you guys have any idea/solution that we can solve by 0ms :)"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "are you sure bro?.Seems confusing"
                    },
                    {
                        "username": "payalraman0",
                        "content": "Can you tell me how you have done in O(N)"
                    },
                    {
                        "username": "Ayu_0308958",
                        "content": " for(int i=0;i<nums.size();i++){\\n        nums[i] =(nums[i]*nums[i]);}\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n"
                    },
                    {
                        "username": "Bhavyaa_Arora_08",
                        "content": "Is an O(1) space or inplace solution possible for this question ?"
                    },
                    {
                        "username": "fireship_2004",
                        "content": "[@linuscodes56](/linuscodes56) stop spamming dude. you just said to push the values^2 in decreasing order in a new array then how come your solution stays in O(1) space complexity?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@linuscodes56](/linuscodes56) if you are using additional space then how it will be o(1).That will be o(n)"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "harshmishra3263",
                        "content": "I have solved this question using bubble sort and in this it is showing that you have passed 137 out of 137 test cases but above it is displaying time limit exceeded.\\n"
                    }
                ]
            },
            {
                "id": 1809015,
                "content": [
                    {
                        "username": "ansarnitp",
                        "content": "Is it possible to solve in O(n) time and O(k) space ?\\nLike in two pointer method, we use an extra array to store the values. But I don\\'t want to use any extra array and sort the squared result in the same array itself."
                    },
                    {
                        "username": "manojjha",
                        "content": "Hello guys for my below solution my testcases are passing when I run the code but when I submit it then I get error \"Time Limit Exceeded\". In submission it 128/137 testcases passed \\n\"\"\"class Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        SquareList=[]\\n        SquareList = [num**2 for num in nums]\\n        for i in range(len(SquareList)):\\n            for j in range(len(SquareList)):\\n                if SquareList[i]<SquareList[j]:\\n                    SquareList[j], SquareList[i] = SquareList[i],SquareList[j]\\n        return SquareList\"\"\"\\nWhat is wrong I am doing in this?\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Hope you aren\\'t gonna do sorting :)"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "Further follow-up. Is there a solution of O(N) time complexity and at the same time sort the array in-place? \\n\\nIn the \"merge two sorted array\" approach, I can only think of copying the negatives to a new array and fill back into the original nums array. Can we avoid the \"copying\" into a new array part?"
                    },
                    {
                        "username": "chubbycccc",
                        "content": "Hello guys, would you like to help me to solve this error?  I have no idea why the error showed that\"list assignment index out of range\" for the \"result[k]=result[j]*result[j].\\nThanks a lot !\\n\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n          result=[]\\n          n=len(nums)\\n          k,j=n-1,n-1\\n          i=0\\n         while i<=j:\\n            if nums[i]*nums[i]>nums[j]*nums[j]:\\n                result[k]=nums[i]*nums[i]\\n                i+=1\\n            else:\\n                result[k]=nums[j]*nums[j]\\n                j-=1\\n            k-=1\\n        \\n        return result\\n"
                    },
                    {
                        "username": "payalraman0",
                        "content": "if you want to solve it in O(n) time ,it can be converted in merge two sorted arrays but you need extra space O(n) . I don\\'t know how to do it in TC: O(n), SC :O(1) "
                    },
                    {
                        "username": "payalraman0",
                        "content": "[@linuscodes56](/linuscodes56) you don\\'t need to reverse the array"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "amanjaiman890",
                        "content": "I Solved this question by 1ms O(n), you guys have any idea/solution that we can solve by 0ms :)"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "are you sure bro?.Seems confusing"
                    },
                    {
                        "username": "payalraman0",
                        "content": "Can you tell me how you have done in O(N)"
                    },
                    {
                        "username": "Ayu_0308958",
                        "content": " for(int i=0;i<nums.size();i++){\\n        nums[i] =(nums[i]*nums[i]);}\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n"
                    },
                    {
                        "username": "Bhavyaa_Arora_08",
                        "content": "Is an O(1) space or inplace solution possible for this question ?"
                    },
                    {
                        "username": "fireship_2004",
                        "content": "[@linuscodes56](/linuscodes56) stop spamming dude. you just said to push the values^2 in decreasing order in a new array then how come your solution stays in O(1) space complexity?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@linuscodes56](/linuscodes56) if you are using additional space then how it will be o(1).That will be o(n)"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "harshmishra3263",
                        "content": "I have solved this question using bubble sort and in this it is showing that you have passed 137 out of 137 test cases but above it is displaying time limit exceeded.\\n"
                    }
                ]
            },
            {
                "id": 1791819,
                "content": [
                    {
                        "username": "ansarnitp",
                        "content": "Is it possible to solve in O(n) time and O(k) space ?\\nLike in two pointer method, we use an extra array to store the values. But I don\\'t want to use any extra array and sort the squared result in the same array itself."
                    },
                    {
                        "username": "manojjha",
                        "content": "Hello guys for my below solution my testcases are passing when I run the code but when I submit it then I get error \"Time Limit Exceeded\". In submission it 128/137 testcases passed \\n\"\"\"class Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        SquareList=[]\\n        SquareList = [num**2 for num in nums]\\n        for i in range(len(SquareList)):\\n            for j in range(len(SquareList)):\\n                if SquareList[i]<SquareList[j]:\\n                    SquareList[j], SquareList[i] = SquareList[i],SquareList[j]\\n        return SquareList\"\"\"\\nWhat is wrong I am doing in this?\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Hope you aren\\'t gonna do sorting :)"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "Further follow-up. Is there a solution of O(N) time complexity and at the same time sort the array in-place? \\n\\nIn the \"merge two sorted array\" approach, I can only think of copying the negatives to a new array and fill back into the original nums array. Can we avoid the \"copying\" into a new array part?"
                    },
                    {
                        "username": "chubbycccc",
                        "content": "Hello guys, would you like to help me to solve this error?  I have no idea why the error showed that\"list assignment index out of range\" for the \"result[k]=result[j]*result[j].\\nThanks a lot !\\n\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n          result=[]\\n          n=len(nums)\\n          k,j=n-1,n-1\\n          i=0\\n         while i<=j:\\n            if nums[i]*nums[i]>nums[j]*nums[j]:\\n                result[k]=nums[i]*nums[i]\\n                i+=1\\n            else:\\n                result[k]=nums[j]*nums[j]\\n                j-=1\\n            k-=1\\n        \\n        return result\\n"
                    },
                    {
                        "username": "payalraman0",
                        "content": "if you want to solve it in O(n) time ,it can be converted in merge two sorted arrays but you need extra space O(n) . I don\\'t know how to do it in TC: O(n), SC :O(1) "
                    },
                    {
                        "username": "payalraman0",
                        "content": "[@linuscodes56](/linuscodes56) you don\\'t need to reverse the array"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "amanjaiman890",
                        "content": "I Solved this question by 1ms O(n), you guys have any idea/solution that we can solve by 0ms :)"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "are you sure bro?.Seems confusing"
                    },
                    {
                        "username": "payalraman0",
                        "content": "Can you tell me how you have done in O(N)"
                    },
                    {
                        "username": "Ayu_0308958",
                        "content": " for(int i=0;i<nums.size();i++){\\n        nums[i] =(nums[i]*nums[i]);}\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n"
                    },
                    {
                        "username": "Bhavyaa_Arora_08",
                        "content": "Is an O(1) space or inplace solution possible for this question ?"
                    },
                    {
                        "username": "fireship_2004",
                        "content": "[@linuscodes56](/linuscodes56) stop spamming dude. you just said to push the values^2 in decreasing order in a new array then how come your solution stays in O(1) space complexity?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@linuscodes56](/linuscodes56) if you are using additional space then how it will be o(1).That will be o(n)"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "harshmishra3263",
                        "content": "I have solved this question using bubble sort and in this it is showing that you have passed 137 out of 137 test cases but above it is displaying time limit exceeded.\\n"
                    }
                ]
            },
            {
                "id": 1787176,
                "content": [
                    {
                        "username": "ansarnitp",
                        "content": "Is it possible to solve in O(n) time and O(k) space ?\\nLike in two pointer method, we use an extra array to store the values. But I don\\'t want to use any extra array and sort the squared result in the same array itself."
                    },
                    {
                        "username": "manojjha",
                        "content": "Hello guys for my below solution my testcases are passing when I run the code but when I submit it then I get error \"Time Limit Exceeded\". In submission it 128/137 testcases passed \\n\"\"\"class Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        SquareList=[]\\n        SquareList = [num**2 for num in nums]\\n        for i in range(len(SquareList)):\\n            for j in range(len(SquareList)):\\n                if SquareList[i]<SquareList[j]:\\n                    SquareList[j], SquareList[i] = SquareList[i],SquareList[j]\\n        return SquareList\"\"\"\\nWhat is wrong I am doing in this?\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Hope you aren\\'t gonna do sorting :)"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "Further follow-up. Is there a solution of O(N) time complexity and at the same time sort the array in-place? \\n\\nIn the \"merge two sorted array\" approach, I can only think of copying the negatives to a new array and fill back into the original nums array. Can we avoid the \"copying\" into a new array part?"
                    },
                    {
                        "username": "chubbycccc",
                        "content": "Hello guys, would you like to help me to solve this error?  I have no idea why the error showed that\"list assignment index out of range\" for the \"result[k]=result[j]*result[j].\\nThanks a lot !\\n\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n          result=[]\\n          n=len(nums)\\n          k,j=n-1,n-1\\n          i=0\\n         while i<=j:\\n            if nums[i]*nums[i]>nums[j]*nums[j]:\\n                result[k]=nums[i]*nums[i]\\n                i+=1\\n            else:\\n                result[k]=nums[j]*nums[j]\\n                j-=1\\n            k-=1\\n        \\n        return result\\n"
                    },
                    {
                        "username": "payalraman0",
                        "content": "if you want to solve it in O(n) time ,it can be converted in merge two sorted arrays but you need extra space O(n) . I don\\'t know how to do it in TC: O(n), SC :O(1) "
                    },
                    {
                        "username": "payalraman0",
                        "content": "[@linuscodes56](/linuscodes56) you don\\'t need to reverse the array"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "amanjaiman890",
                        "content": "I Solved this question by 1ms O(n), you guys have any idea/solution that we can solve by 0ms :)"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "are you sure bro?.Seems confusing"
                    },
                    {
                        "username": "payalraman0",
                        "content": "Can you tell me how you have done in O(N)"
                    },
                    {
                        "username": "Ayu_0308958",
                        "content": " for(int i=0;i<nums.size();i++){\\n        nums[i] =(nums[i]*nums[i]);}\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n"
                    },
                    {
                        "username": "Bhavyaa_Arora_08",
                        "content": "Is an O(1) space or inplace solution possible for this question ?"
                    },
                    {
                        "username": "fireship_2004",
                        "content": "[@linuscodes56](/linuscodes56) stop spamming dude. you just said to push the values^2 in decreasing order in a new array then how come your solution stays in O(1) space complexity?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@linuscodes56](/linuscodes56) if you are using additional space then how it will be o(1).That will be o(n)"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "harshmishra3263",
                        "content": "I have solved this question using bubble sort and in this it is showing that you have passed 137 out of 137 test cases but above it is displaying time limit exceeded.\\n"
                    }
                ]
            },
            {
                "id": 1786287,
                "content": [
                    {
                        "username": "ansarnitp",
                        "content": "Is it possible to solve in O(n) time and O(k) space ?\\nLike in two pointer method, we use an extra array to store the values. But I don\\'t want to use any extra array and sort the squared result in the same array itself."
                    },
                    {
                        "username": "manojjha",
                        "content": "Hello guys for my below solution my testcases are passing when I run the code but when I submit it then I get error \"Time Limit Exceeded\". In submission it 128/137 testcases passed \\n\"\"\"class Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        SquareList=[]\\n        SquareList = [num**2 for num in nums]\\n        for i in range(len(SquareList)):\\n            for j in range(len(SquareList)):\\n                if SquareList[i]<SquareList[j]:\\n                    SquareList[j], SquareList[i] = SquareList[i],SquareList[j]\\n        return SquareList\"\"\"\\nWhat is wrong I am doing in this?\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Hope you aren\\'t gonna do sorting :)"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "Further follow-up. Is there a solution of O(N) time complexity and at the same time sort the array in-place? \\n\\nIn the \"merge two sorted array\" approach, I can only think of copying the negatives to a new array and fill back into the original nums array. Can we avoid the \"copying\" into a new array part?"
                    },
                    {
                        "username": "chubbycccc",
                        "content": "Hello guys, would you like to help me to solve this error?  I have no idea why the error showed that\"list assignment index out of range\" for the \"result[k]=result[j]*result[j].\\nThanks a lot !\\n\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n          result=[]\\n          n=len(nums)\\n          k,j=n-1,n-1\\n          i=0\\n         while i<=j:\\n            if nums[i]*nums[i]>nums[j]*nums[j]:\\n                result[k]=nums[i]*nums[i]\\n                i+=1\\n            else:\\n                result[k]=nums[j]*nums[j]\\n                j-=1\\n            k-=1\\n        \\n        return result\\n"
                    },
                    {
                        "username": "payalraman0",
                        "content": "if you want to solve it in O(n) time ,it can be converted in merge two sorted arrays but you need extra space O(n) . I don\\'t know how to do it in TC: O(n), SC :O(1) "
                    },
                    {
                        "username": "payalraman0",
                        "content": "[@linuscodes56](/linuscodes56) you don\\'t need to reverse the array"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "amanjaiman890",
                        "content": "I Solved this question by 1ms O(n), you guys have any idea/solution that we can solve by 0ms :)"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "are you sure bro?.Seems confusing"
                    },
                    {
                        "username": "payalraman0",
                        "content": "Can you tell me how you have done in O(N)"
                    },
                    {
                        "username": "Ayu_0308958",
                        "content": " for(int i=0;i<nums.size();i++){\\n        nums[i] =(nums[i]*nums[i]);}\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n"
                    },
                    {
                        "username": "Bhavyaa_Arora_08",
                        "content": "Is an O(1) space or inplace solution possible for this question ?"
                    },
                    {
                        "username": "fireship_2004",
                        "content": "[@linuscodes56](/linuscodes56) stop spamming dude. you just said to push the values^2 in decreasing order in a new array then how come your solution stays in O(1) space complexity?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@linuscodes56](/linuscodes56) if you are using additional space then how it will be o(1).That will be o(n)"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "harshmishra3263",
                        "content": "I have solved this question using bubble sort and in this it is showing that you have passed 137 out of 137 test cases but above it is displaying time limit exceeded.\\n"
                    }
                ]
            },
            {
                "id": 1781187,
                "content": [
                    {
                        "username": "ansarnitp",
                        "content": "Is it possible to solve in O(n) time and O(k) space ?\\nLike in two pointer method, we use an extra array to store the values. But I don\\'t want to use any extra array and sort the squared result in the same array itself."
                    },
                    {
                        "username": "manojjha",
                        "content": "Hello guys for my below solution my testcases are passing when I run the code but when I submit it then I get error \"Time Limit Exceeded\". In submission it 128/137 testcases passed \\n\"\"\"class Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        SquareList=[]\\n        SquareList = [num**2 for num in nums]\\n        for i in range(len(SquareList)):\\n            for j in range(len(SquareList)):\\n                if SquareList[i]<SquareList[j]:\\n                    SquareList[j], SquareList[i] = SquareList[i],SquareList[j]\\n        return SquareList\"\"\"\\nWhat is wrong I am doing in this?\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Hope you aren\\'t gonna do sorting :)"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "Further follow-up. Is there a solution of O(N) time complexity and at the same time sort the array in-place? \\n\\nIn the \"merge two sorted array\" approach, I can only think of copying the negatives to a new array and fill back into the original nums array. Can we avoid the \"copying\" into a new array part?"
                    },
                    {
                        "username": "chubbycccc",
                        "content": "Hello guys, would you like to help me to solve this error?  I have no idea why the error showed that\"list assignment index out of range\" for the \"result[k]=result[j]*result[j].\\nThanks a lot !\\n\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n          result=[]\\n          n=len(nums)\\n          k,j=n-1,n-1\\n          i=0\\n         while i<=j:\\n            if nums[i]*nums[i]>nums[j]*nums[j]:\\n                result[k]=nums[i]*nums[i]\\n                i+=1\\n            else:\\n                result[k]=nums[j]*nums[j]\\n                j-=1\\n            k-=1\\n        \\n        return result\\n"
                    },
                    {
                        "username": "payalraman0",
                        "content": "if you want to solve it in O(n) time ,it can be converted in merge two sorted arrays but you need extra space O(n) . I don\\'t know how to do it in TC: O(n), SC :O(1) "
                    },
                    {
                        "username": "payalraman0",
                        "content": "[@linuscodes56](/linuscodes56) you don\\'t need to reverse the array"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "amanjaiman890",
                        "content": "I Solved this question by 1ms O(n), you guys have any idea/solution that we can solve by 0ms :)"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "are you sure bro?.Seems confusing"
                    },
                    {
                        "username": "payalraman0",
                        "content": "Can you tell me how you have done in O(N)"
                    },
                    {
                        "username": "Ayu_0308958",
                        "content": " for(int i=0;i<nums.size();i++){\\n        nums[i] =(nums[i]*nums[i]);}\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n"
                    },
                    {
                        "username": "Bhavyaa_Arora_08",
                        "content": "Is an O(1) space or inplace solution possible for this question ?"
                    },
                    {
                        "username": "fireship_2004",
                        "content": "[@linuscodes56](/linuscodes56) stop spamming dude. you just said to push the values^2 in decreasing order in a new array then how come your solution stays in O(1) space complexity?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@linuscodes56](/linuscodes56) if you are using additional space then how it will be o(1).That will be o(n)"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "harshmishra3263",
                        "content": "I have solved this question using bubble sort and in this it is showing that you have passed 137 out of 137 test cases but above it is displaying time limit exceeded.\\n"
                    }
                ]
            },
            {
                "id": 1781171,
                "content": [
                    {
                        "username": "ansarnitp",
                        "content": "Is it possible to solve in O(n) time and O(k) space ?\\nLike in two pointer method, we use an extra array to store the values. But I don\\'t want to use any extra array and sort the squared result in the same array itself."
                    },
                    {
                        "username": "manojjha",
                        "content": "Hello guys for my below solution my testcases are passing when I run the code but when I submit it then I get error \"Time Limit Exceeded\". In submission it 128/137 testcases passed \\n\"\"\"class Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        SquareList=[]\\n        SquareList = [num**2 for num in nums]\\n        for i in range(len(SquareList)):\\n            for j in range(len(SquareList)):\\n                if SquareList[i]<SquareList[j]:\\n                    SquareList[j], SquareList[i] = SquareList[i],SquareList[j]\\n        return SquareList\"\"\"\\nWhat is wrong I am doing in this?\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Hope you aren\\'t gonna do sorting :)"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "Further follow-up. Is there a solution of O(N) time complexity and at the same time sort the array in-place? \\n\\nIn the \"merge two sorted array\" approach, I can only think of copying the negatives to a new array and fill back into the original nums array. Can we avoid the \"copying\" into a new array part?"
                    },
                    {
                        "username": "chubbycccc",
                        "content": "Hello guys, would you like to help me to solve this error?  I have no idea why the error showed that\"list assignment index out of range\" for the \"result[k]=result[j]*result[j].\\nThanks a lot !\\n\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n          result=[]\\n          n=len(nums)\\n          k,j=n-1,n-1\\n          i=0\\n         while i<=j:\\n            if nums[i]*nums[i]>nums[j]*nums[j]:\\n                result[k]=nums[i]*nums[i]\\n                i+=1\\n            else:\\n                result[k]=nums[j]*nums[j]\\n                j-=1\\n            k-=1\\n        \\n        return result\\n"
                    },
                    {
                        "username": "payalraman0",
                        "content": "if you want to solve it in O(n) time ,it can be converted in merge two sorted arrays but you need extra space O(n) . I don\\'t know how to do it in TC: O(n), SC :O(1) "
                    },
                    {
                        "username": "payalraman0",
                        "content": "[@linuscodes56](/linuscodes56) you don\\'t need to reverse the array"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "amanjaiman890",
                        "content": "I Solved this question by 1ms O(n), you guys have any idea/solution that we can solve by 0ms :)"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "are you sure bro?.Seems confusing"
                    },
                    {
                        "username": "payalraman0",
                        "content": "Can you tell me how you have done in O(N)"
                    },
                    {
                        "username": "Ayu_0308958",
                        "content": " for(int i=0;i<nums.size();i++){\\n        nums[i] =(nums[i]*nums[i]);}\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n"
                    },
                    {
                        "username": "Bhavyaa_Arora_08",
                        "content": "Is an O(1) space or inplace solution possible for this question ?"
                    },
                    {
                        "username": "fireship_2004",
                        "content": "[@linuscodes56](/linuscodes56) stop spamming dude. you just said to push the values^2 in decreasing order in a new array then how come your solution stays in O(1) space complexity?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@linuscodes56](/linuscodes56) if you are using additional space then how it will be o(1).That will be o(n)"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "harshmishra3263",
                        "content": "I have solved this question using bubble sort and in this it is showing that you have passed 137 out of 137 test cases but above it is displaying time limit exceeded.\\n"
                    }
                ]
            },
            {
                "id": 1763423,
                "content": [
                    {
                        "username": "ansarnitp",
                        "content": "Is it possible to solve in O(n) time and O(k) space ?\\nLike in two pointer method, we use an extra array to store the values. But I don\\'t want to use any extra array and sort the squared result in the same array itself."
                    },
                    {
                        "username": "manojjha",
                        "content": "Hello guys for my below solution my testcases are passing when I run the code but when I submit it then I get error \"Time Limit Exceeded\". In submission it 128/137 testcases passed \\n\"\"\"class Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        SquareList=[]\\n        SquareList = [num**2 for num in nums]\\n        for i in range(len(SquareList)):\\n            for j in range(len(SquareList)):\\n                if SquareList[i]<SquareList[j]:\\n                    SquareList[j], SquareList[i] = SquareList[i],SquareList[j]\\n        return SquareList\"\"\"\\nWhat is wrong I am doing in this?\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Hope you aren\\'t gonna do sorting :)"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "Further follow-up. Is there a solution of O(N) time complexity and at the same time sort the array in-place? \\n\\nIn the \"merge two sorted array\" approach, I can only think of copying the negatives to a new array and fill back into the original nums array. Can we avoid the \"copying\" into a new array part?"
                    },
                    {
                        "username": "chubbycccc",
                        "content": "Hello guys, would you like to help me to solve this error?  I have no idea why the error showed that\"list assignment index out of range\" for the \"result[k]=result[j]*result[j].\\nThanks a lot !\\n\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n          result=[]\\n          n=len(nums)\\n          k,j=n-1,n-1\\n          i=0\\n         while i<=j:\\n            if nums[i]*nums[i]>nums[j]*nums[j]:\\n                result[k]=nums[i]*nums[i]\\n                i+=1\\n            else:\\n                result[k]=nums[j]*nums[j]\\n                j-=1\\n            k-=1\\n        \\n        return result\\n"
                    },
                    {
                        "username": "payalraman0",
                        "content": "if you want to solve it in O(n) time ,it can be converted in merge two sorted arrays but you need extra space O(n) . I don\\'t know how to do it in TC: O(n), SC :O(1) "
                    },
                    {
                        "username": "payalraman0",
                        "content": "[@linuscodes56](/linuscodes56) you don\\'t need to reverse the array"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "amanjaiman890",
                        "content": "I Solved this question by 1ms O(n), you guys have any idea/solution that we can solve by 0ms :)"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "are you sure bro?.Seems confusing"
                    },
                    {
                        "username": "payalraman0",
                        "content": "Can you tell me how you have done in O(N)"
                    },
                    {
                        "username": "Ayu_0308958",
                        "content": " for(int i=0;i<nums.size();i++){\\n        nums[i] =(nums[i]*nums[i]);}\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n"
                    },
                    {
                        "username": "Bhavyaa_Arora_08",
                        "content": "Is an O(1) space or inplace solution possible for this question ?"
                    },
                    {
                        "username": "fireship_2004",
                        "content": "[@linuscodes56](/linuscodes56) stop spamming dude. you just said to push the values^2 in decreasing order in a new array then how come your solution stays in O(1) space complexity?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@linuscodes56](/linuscodes56) if you are using additional space then how it will be o(1).That will be o(n)"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "harshmishra3263",
                        "content": "I have solved this question using bubble sort and in this it is showing that you have passed 137 out of 137 test cases but above it is displaying time limit exceeded.\\n"
                    }
                ]
            },
            {
                "id": 1761845,
                "content": [
                    {
                        "username": "Abhi3091",
                        "content": "\\n        for(in\\nt i = 0; i<nums.length; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        int left = 0;\\n\\n        int right = nums.length-1;\\n        int index = nums.length-1;\\n        int[] result = new int[nums.length];\\n\\n\\n        while(left <= right){\\n            //16 1 0 9 100\\n            int leftSquare = nums[left];\\n            int rightSquare = nums[right];\\n\\n            //we want to fill up the arrays from right\\n            // the trick is to use new array result\\n            //compare using pointers if right square is large\\n            // update and decrement right index\\n            if(rightSquare > leftSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            //else left index is incremented\\n            }else if(leftSquare > rightSquare){\\n\\n                result[index] = leftSquare;\\n                left++;\\n            //if equal then right value and right index decremented\\n            }else if(leftSquare == rightSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            }\\n\\n            index--;\\n        }\\n\\n        return result;\\n\\nMy java solution beats 100 %"
                    },
                    {
                        "username": "kprat",
                        "content": "Can someone help explain the space and time complexity of this solution:\\n\\nobject Solution {\\n    def sortedSquares(nums: Array[Int]): Array[Int] = {\\n        var left = 0\\n        var right = nums.length\\n        var newArray = new Array[Int](nums.length)\\n        var min = 0\\n        if (nums.length==1)\\n            return Array(sq(nums(0)))\\n        //val status:HashMap[Int,Boolean] = HashMap[Int,Boolean]()\\n        while(left<nums.length-1){\\n            //printArray(nums)\\n            if(Math.abs(nums(left))>Math.abs(nums(left+1)))\\n             swap(left,left+1)\\n            else \\n              {\\n              newArray(left) = sq(nums(left))\\n              newArray(left+1) = sq(nums(left+1))\\n              left+=1\\n              }\\n        }\\n        def swap(i:Int,j:Int) = {\\n            val temp = nums(j)\\n            nums(j) = nums(i)\\n            nums(i) = temp\\n            //newArray(i) = sq(nums(i))\\n            //newArray(j) = sq(nums(j))\\n            if(i>0){\\n            left-=1\\n            }\\n        }\\n\\n        def sq(i:Int):Int = {\\n            i*i\\n        }\\n\\n        def printArray(nums:Array[Int]) = {\\n            println(\"Left:\"+left)\\n            println(\"Array Status\")\\n            nums.foreach(x=> print(\" \" + x + \" \"))\\n            println()\\n        }\\n        newArray\\n    }\\n}"
                    },
                    {
                        "username": "mkaypl",
                        "content": "O(N^2) for time complexity (it\\'s bubble sort)"
                    },
                    {
                        "username": "hoangduy265",
                        "content": "`public class Solution {\n    public int[] SortedSquares(int[] nums) {\n        int[] result = new int[nums.Length];\n        for (int i = 0; i < nums.Length; i++)\n        {\n            if (nums[i] < 0) nums[i] = -nums[i];\n            result[i] = nums[i] * nums[i];\n        }\n        Array.Sort(result);\n        return result;\n    }\n}`"
                    },
                    {
                        "username": "AKUTOTA_SANJAY",
                        "content": "  vector<int> sortedSquares(vector<int>& nums) {\n        vector<int> v;\n        int pi=0,ni,k,l;\n        while(nums[pi]<0)\n        {\n            pi++;\n        }      \n        k=pi;\n        ni=pi-1;\n        for(int k=0;k<nums.size();k++)\n        {\n            nums[k]=nums[k]*nums[k];\n        }\n\n            if(ni==-1)\n            {\n                return nums;\n            }\n          else\n          {\n        while(k<nums.size() and ni>=0)\n        {\n            if(nums[k]<nums[ni])\n            {\n                 \n                v.push_back(nums[k]);\n                k++;\n               \n            }\n            else\n            {\n                 v.push_back(nums[ni]);\n                 ni--;\n            }  \n\n            }\n    }\n        \n        \n        for( ;ni>=0;ni--)\n        {\n            v.push_back(nums[ni]);\n        }\n\n        for(;k<nums.size();k++)\n        {\n             v.push_back(nums[k]);\n        }\n\n     return v;\n    }\n\n\nGetting this error plz help?\n\n=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000514 at pc 0x000000345f9b bp 0x7fffa113dd10 sp 0x7fffa113dd08\nREAD of size 4 at 0x602000000514 thread T0\n    #2 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000514 is located 0 bytes to the right of 4-byte region [0x602000000510,0x602000000514)\nallocated by thread T0 here:\n    #6 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n=>0x0c047fff80a0: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "  return nums.Select(x => x * x ).OrderBy(x=> x).ToArray();\\nC# Linq\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Anyone else getting signed integer overflow? Not sure how to fix this with the return type being a vector<int>"
                    },
                    {
                        "username": "Soumya1999",
                        "content": "Why its shows like memory limit exceeded?\\n"
                    },
                    {
                        "username": "Aryan_Arya",
                        "content": "I have a doubt, can we find the minimum absolute element using log(n) time complexity. Our array is given in sorted fashion. Can we use binary search to find the smallest element (in terms of magnitude)?"
                    },
                    {
                        "username": "irfann2022skipq",
                        "content": "Solved it in very easy wasy with O(n) time complexity.\nvar sortedSquares = function(nums) {\n    let squareArray = []\n    for(let i=0;i<nums.length;i++){\n      squareArray.push(nums[i]*nums[i])\n    }\n    return squareArray.sort((a,b)=>{return a-b})\n}  "
                    },
                    {
                        "username": "eliaashraf",
                        "content": "An easy solution to this would be to first find the squares of each element using a pointer and then using a Arrays.sort(array_name) function to solve this prolem.\\n\\nThis is what I have done-\\n `for(int i = 0; i <= nums.length - 1; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;`"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "then the time complexity will be 0(n logn).Try to solve this in 0(n).That is the challenge"
                    },
                    {
                        "username": "mkaypl",
                        "content": "Sorting isn\\'t O(n), just in case you missed the follow up note."
                    }
                ]
            },
            {
                "id": 1742261,
                "content": [
                    {
                        "username": "Abhi3091",
                        "content": "\\n        for(in\\nt i = 0; i<nums.length; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        int left = 0;\\n\\n        int right = nums.length-1;\\n        int index = nums.length-1;\\n        int[] result = new int[nums.length];\\n\\n\\n        while(left <= right){\\n            //16 1 0 9 100\\n            int leftSquare = nums[left];\\n            int rightSquare = nums[right];\\n\\n            //we want to fill up the arrays from right\\n            // the trick is to use new array result\\n            //compare using pointers if right square is large\\n            // update and decrement right index\\n            if(rightSquare > leftSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            //else left index is incremented\\n            }else if(leftSquare > rightSquare){\\n\\n                result[index] = leftSquare;\\n                left++;\\n            //if equal then right value and right index decremented\\n            }else if(leftSquare == rightSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            }\\n\\n            index--;\\n        }\\n\\n        return result;\\n\\nMy java solution beats 100 %"
                    },
                    {
                        "username": "kprat",
                        "content": "Can someone help explain the space and time complexity of this solution:\\n\\nobject Solution {\\n    def sortedSquares(nums: Array[Int]): Array[Int] = {\\n        var left = 0\\n        var right = nums.length\\n        var newArray = new Array[Int](nums.length)\\n        var min = 0\\n        if (nums.length==1)\\n            return Array(sq(nums(0)))\\n        //val status:HashMap[Int,Boolean] = HashMap[Int,Boolean]()\\n        while(left<nums.length-1){\\n            //printArray(nums)\\n            if(Math.abs(nums(left))>Math.abs(nums(left+1)))\\n             swap(left,left+1)\\n            else \\n              {\\n              newArray(left) = sq(nums(left))\\n              newArray(left+1) = sq(nums(left+1))\\n              left+=1\\n              }\\n        }\\n        def swap(i:Int,j:Int) = {\\n            val temp = nums(j)\\n            nums(j) = nums(i)\\n            nums(i) = temp\\n            //newArray(i) = sq(nums(i))\\n            //newArray(j) = sq(nums(j))\\n            if(i>0){\\n            left-=1\\n            }\\n        }\\n\\n        def sq(i:Int):Int = {\\n            i*i\\n        }\\n\\n        def printArray(nums:Array[Int]) = {\\n            println(\"Left:\"+left)\\n            println(\"Array Status\")\\n            nums.foreach(x=> print(\" \" + x + \" \"))\\n            println()\\n        }\\n        newArray\\n    }\\n}"
                    },
                    {
                        "username": "mkaypl",
                        "content": "O(N^2) for time complexity (it\\'s bubble sort)"
                    },
                    {
                        "username": "hoangduy265",
                        "content": "`public class Solution {\n    public int[] SortedSquares(int[] nums) {\n        int[] result = new int[nums.Length];\n        for (int i = 0; i < nums.Length; i++)\n        {\n            if (nums[i] < 0) nums[i] = -nums[i];\n            result[i] = nums[i] * nums[i];\n        }\n        Array.Sort(result);\n        return result;\n    }\n}`"
                    },
                    {
                        "username": "AKUTOTA_SANJAY",
                        "content": "  vector<int> sortedSquares(vector<int>& nums) {\n        vector<int> v;\n        int pi=0,ni,k,l;\n        while(nums[pi]<0)\n        {\n            pi++;\n        }      \n        k=pi;\n        ni=pi-1;\n        for(int k=0;k<nums.size();k++)\n        {\n            nums[k]=nums[k]*nums[k];\n        }\n\n            if(ni==-1)\n            {\n                return nums;\n            }\n          else\n          {\n        while(k<nums.size() and ni>=0)\n        {\n            if(nums[k]<nums[ni])\n            {\n                 \n                v.push_back(nums[k]);\n                k++;\n               \n            }\n            else\n            {\n                 v.push_back(nums[ni]);\n                 ni--;\n            }  \n\n            }\n    }\n        \n        \n        for( ;ni>=0;ni--)\n        {\n            v.push_back(nums[ni]);\n        }\n\n        for(;k<nums.size();k++)\n        {\n             v.push_back(nums[k]);\n        }\n\n     return v;\n    }\n\n\nGetting this error plz help?\n\n=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000514 at pc 0x000000345f9b bp 0x7fffa113dd10 sp 0x7fffa113dd08\nREAD of size 4 at 0x602000000514 thread T0\n    #2 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000514 is located 0 bytes to the right of 4-byte region [0x602000000510,0x602000000514)\nallocated by thread T0 here:\n    #6 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n=>0x0c047fff80a0: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "  return nums.Select(x => x * x ).OrderBy(x=> x).ToArray();\\nC# Linq\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Anyone else getting signed integer overflow? Not sure how to fix this with the return type being a vector<int>"
                    },
                    {
                        "username": "Soumya1999",
                        "content": "Why its shows like memory limit exceeded?\\n"
                    },
                    {
                        "username": "Aryan_Arya",
                        "content": "I have a doubt, can we find the minimum absolute element using log(n) time complexity. Our array is given in sorted fashion. Can we use binary search to find the smallest element (in terms of magnitude)?"
                    },
                    {
                        "username": "irfann2022skipq",
                        "content": "Solved it in very easy wasy with O(n) time complexity.\nvar sortedSquares = function(nums) {\n    let squareArray = []\n    for(let i=0;i<nums.length;i++){\n      squareArray.push(nums[i]*nums[i])\n    }\n    return squareArray.sort((a,b)=>{return a-b})\n}  "
                    },
                    {
                        "username": "eliaashraf",
                        "content": "An easy solution to this would be to first find the squares of each element using a pointer and then using a Arrays.sort(array_name) function to solve this prolem.\\n\\nThis is what I have done-\\n `for(int i = 0; i <= nums.length - 1; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;`"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "then the time complexity will be 0(n logn).Try to solve this in 0(n).That is the challenge"
                    },
                    {
                        "username": "mkaypl",
                        "content": "Sorting isn\\'t O(n), just in case you missed the follow up note."
                    }
                ]
            },
            {
                "id": 1732657,
                "content": [
                    {
                        "username": "Abhi3091",
                        "content": "\\n        for(in\\nt i = 0; i<nums.length; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        int left = 0;\\n\\n        int right = nums.length-1;\\n        int index = nums.length-1;\\n        int[] result = new int[nums.length];\\n\\n\\n        while(left <= right){\\n            //16 1 0 9 100\\n            int leftSquare = nums[left];\\n            int rightSquare = nums[right];\\n\\n            //we want to fill up the arrays from right\\n            // the trick is to use new array result\\n            //compare using pointers if right square is large\\n            // update and decrement right index\\n            if(rightSquare > leftSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            //else left index is incremented\\n            }else if(leftSquare > rightSquare){\\n\\n                result[index] = leftSquare;\\n                left++;\\n            //if equal then right value and right index decremented\\n            }else if(leftSquare == rightSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            }\\n\\n            index--;\\n        }\\n\\n        return result;\\n\\nMy java solution beats 100 %"
                    },
                    {
                        "username": "kprat",
                        "content": "Can someone help explain the space and time complexity of this solution:\\n\\nobject Solution {\\n    def sortedSquares(nums: Array[Int]): Array[Int] = {\\n        var left = 0\\n        var right = nums.length\\n        var newArray = new Array[Int](nums.length)\\n        var min = 0\\n        if (nums.length==1)\\n            return Array(sq(nums(0)))\\n        //val status:HashMap[Int,Boolean] = HashMap[Int,Boolean]()\\n        while(left<nums.length-1){\\n            //printArray(nums)\\n            if(Math.abs(nums(left))>Math.abs(nums(left+1)))\\n             swap(left,left+1)\\n            else \\n              {\\n              newArray(left) = sq(nums(left))\\n              newArray(left+1) = sq(nums(left+1))\\n              left+=1\\n              }\\n        }\\n        def swap(i:Int,j:Int) = {\\n            val temp = nums(j)\\n            nums(j) = nums(i)\\n            nums(i) = temp\\n            //newArray(i) = sq(nums(i))\\n            //newArray(j) = sq(nums(j))\\n            if(i>0){\\n            left-=1\\n            }\\n        }\\n\\n        def sq(i:Int):Int = {\\n            i*i\\n        }\\n\\n        def printArray(nums:Array[Int]) = {\\n            println(\"Left:\"+left)\\n            println(\"Array Status\")\\n            nums.foreach(x=> print(\" \" + x + \" \"))\\n            println()\\n        }\\n        newArray\\n    }\\n}"
                    },
                    {
                        "username": "mkaypl",
                        "content": "O(N^2) for time complexity (it\\'s bubble sort)"
                    },
                    {
                        "username": "hoangduy265",
                        "content": "`public class Solution {\n    public int[] SortedSquares(int[] nums) {\n        int[] result = new int[nums.Length];\n        for (int i = 0; i < nums.Length; i++)\n        {\n            if (nums[i] < 0) nums[i] = -nums[i];\n            result[i] = nums[i] * nums[i];\n        }\n        Array.Sort(result);\n        return result;\n    }\n}`"
                    },
                    {
                        "username": "AKUTOTA_SANJAY",
                        "content": "  vector<int> sortedSquares(vector<int>& nums) {\n        vector<int> v;\n        int pi=0,ni,k,l;\n        while(nums[pi]<0)\n        {\n            pi++;\n        }      \n        k=pi;\n        ni=pi-1;\n        for(int k=0;k<nums.size();k++)\n        {\n            nums[k]=nums[k]*nums[k];\n        }\n\n            if(ni==-1)\n            {\n                return nums;\n            }\n          else\n          {\n        while(k<nums.size() and ni>=0)\n        {\n            if(nums[k]<nums[ni])\n            {\n                 \n                v.push_back(nums[k]);\n                k++;\n               \n            }\n            else\n            {\n                 v.push_back(nums[ni]);\n                 ni--;\n            }  \n\n            }\n    }\n        \n        \n        for( ;ni>=0;ni--)\n        {\n            v.push_back(nums[ni]);\n        }\n\n        for(;k<nums.size();k++)\n        {\n             v.push_back(nums[k]);\n        }\n\n     return v;\n    }\n\n\nGetting this error plz help?\n\n=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000514 at pc 0x000000345f9b bp 0x7fffa113dd10 sp 0x7fffa113dd08\nREAD of size 4 at 0x602000000514 thread T0\n    #2 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000514 is located 0 bytes to the right of 4-byte region [0x602000000510,0x602000000514)\nallocated by thread T0 here:\n    #6 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n=>0x0c047fff80a0: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "  return nums.Select(x => x * x ).OrderBy(x=> x).ToArray();\\nC# Linq\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Anyone else getting signed integer overflow? Not sure how to fix this with the return type being a vector<int>"
                    },
                    {
                        "username": "Soumya1999",
                        "content": "Why its shows like memory limit exceeded?\\n"
                    },
                    {
                        "username": "Aryan_Arya",
                        "content": "I have a doubt, can we find the minimum absolute element using log(n) time complexity. Our array is given in sorted fashion. Can we use binary search to find the smallest element (in terms of magnitude)?"
                    },
                    {
                        "username": "irfann2022skipq",
                        "content": "Solved it in very easy wasy with O(n) time complexity.\nvar sortedSquares = function(nums) {\n    let squareArray = []\n    for(let i=0;i<nums.length;i++){\n      squareArray.push(nums[i]*nums[i])\n    }\n    return squareArray.sort((a,b)=>{return a-b})\n}  "
                    },
                    {
                        "username": "eliaashraf",
                        "content": "An easy solution to this would be to first find the squares of each element using a pointer and then using a Arrays.sort(array_name) function to solve this prolem.\\n\\nThis is what I have done-\\n `for(int i = 0; i <= nums.length - 1; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;`"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "then the time complexity will be 0(n logn).Try to solve this in 0(n).That is the challenge"
                    },
                    {
                        "username": "mkaypl",
                        "content": "Sorting isn\\'t O(n), just in case you missed the follow up note."
                    }
                ]
            },
            {
                "id": 1732488,
                "content": [
                    {
                        "username": "Abhi3091",
                        "content": "\\n        for(in\\nt i = 0; i<nums.length; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        int left = 0;\\n\\n        int right = nums.length-1;\\n        int index = nums.length-1;\\n        int[] result = new int[nums.length];\\n\\n\\n        while(left <= right){\\n            //16 1 0 9 100\\n            int leftSquare = nums[left];\\n            int rightSquare = nums[right];\\n\\n            //we want to fill up the arrays from right\\n            // the trick is to use new array result\\n            //compare using pointers if right square is large\\n            // update and decrement right index\\n            if(rightSquare > leftSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            //else left index is incremented\\n            }else if(leftSquare > rightSquare){\\n\\n                result[index] = leftSquare;\\n                left++;\\n            //if equal then right value and right index decremented\\n            }else if(leftSquare == rightSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            }\\n\\n            index--;\\n        }\\n\\n        return result;\\n\\nMy java solution beats 100 %"
                    },
                    {
                        "username": "kprat",
                        "content": "Can someone help explain the space and time complexity of this solution:\\n\\nobject Solution {\\n    def sortedSquares(nums: Array[Int]): Array[Int] = {\\n        var left = 0\\n        var right = nums.length\\n        var newArray = new Array[Int](nums.length)\\n        var min = 0\\n        if (nums.length==1)\\n            return Array(sq(nums(0)))\\n        //val status:HashMap[Int,Boolean] = HashMap[Int,Boolean]()\\n        while(left<nums.length-1){\\n            //printArray(nums)\\n            if(Math.abs(nums(left))>Math.abs(nums(left+1)))\\n             swap(left,left+1)\\n            else \\n              {\\n              newArray(left) = sq(nums(left))\\n              newArray(left+1) = sq(nums(left+1))\\n              left+=1\\n              }\\n        }\\n        def swap(i:Int,j:Int) = {\\n            val temp = nums(j)\\n            nums(j) = nums(i)\\n            nums(i) = temp\\n            //newArray(i) = sq(nums(i))\\n            //newArray(j) = sq(nums(j))\\n            if(i>0){\\n            left-=1\\n            }\\n        }\\n\\n        def sq(i:Int):Int = {\\n            i*i\\n        }\\n\\n        def printArray(nums:Array[Int]) = {\\n            println(\"Left:\"+left)\\n            println(\"Array Status\")\\n            nums.foreach(x=> print(\" \" + x + \" \"))\\n            println()\\n        }\\n        newArray\\n    }\\n}"
                    },
                    {
                        "username": "mkaypl",
                        "content": "O(N^2) for time complexity (it\\'s bubble sort)"
                    },
                    {
                        "username": "hoangduy265",
                        "content": "`public class Solution {\n    public int[] SortedSquares(int[] nums) {\n        int[] result = new int[nums.Length];\n        for (int i = 0; i < nums.Length; i++)\n        {\n            if (nums[i] < 0) nums[i] = -nums[i];\n            result[i] = nums[i] * nums[i];\n        }\n        Array.Sort(result);\n        return result;\n    }\n}`"
                    },
                    {
                        "username": "AKUTOTA_SANJAY",
                        "content": "  vector<int> sortedSquares(vector<int>& nums) {\n        vector<int> v;\n        int pi=0,ni,k,l;\n        while(nums[pi]<0)\n        {\n            pi++;\n        }      \n        k=pi;\n        ni=pi-1;\n        for(int k=0;k<nums.size();k++)\n        {\n            nums[k]=nums[k]*nums[k];\n        }\n\n            if(ni==-1)\n            {\n                return nums;\n            }\n          else\n          {\n        while(k<nums.size() and ni>=0)\n        {\n            if(nums[k]<nums[ni])\n            {\n                 \n                v.push_back(nums[k]);\n                k++;\n               \n            }\n            else\n            {\n                 v.push_back(nums[ni]);\n                 ni--;\n            }  \n\n            }\n    }\n        \n        \n        for( ;ni>=0;ni--)\n        {\n            v.push_back(nums[ni]);\n        }\n\n        for(;k<nums.size();k++)\n        {\n             v.push_back(nums[k]);\n        }\n\n     return v;\n    }\n\n\nGetting this error plz help?\n\n=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000514 at pc 0x000000345f9b bp 0x7fffa113dd10 sp 0x7fffa113dd08\nREAD of size 4 at 0x602000000514 thread T0\n    #2 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000514 is located 0 bytes to the right of 4-byte region [0x602000000510,0x602000000514)\nallocated by thread T0 here:\n    #6 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n=>0x0c047fff80a0: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "  return nums.Select(x => x * x ).OrderBy(x=> x).ToArray();\\nC# Linq\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Anyone else getting signed integer overflow? Not sure how to fix this with the return type being a vector<int>"
                    },
                    {
                        "username": "Soumya1999",
                        "content": "Why its shows like memory limit exceeded?\\n"
                    },
                    {
                        "username": "Aryan_Arya",
                        "content": "I have a doubt, can we find the minimum absolute element using log(n) time complexity. Our array is given in sorted fashion. Can we use binary search to find the smallest element (in terms of magnitude)?"
                    },
                    {
                        "username": "irfann2022skipq",
                        "content": "Solved it in very easy wasy with O(n) time complexity.\nvar sortedSquares = function(nums) {\n    let squareArray = []\n    for(let i=0;i<nums.length;i++){\n      squareArray.push(nums[i]*nums[i])\n    }\n    return squareArray.sort((a,b)=>{return a-b})\n}  "
                    },
                    {
                        "username": "eliaashraf",
                        "content": "An easy solution to this would be to first find the squares of each element using a pointer and then using a Arrays.sort(array_name) function to solve this prolem.\\n\\nThis is what I have done-\\n `for(int i = 0; i <= nums.length - 1; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;`"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "then the time complexity will be 0(n logn).Try to solve this in 0(n).That is the challenge"
                    },
                    {
                        "username": "mkaypl",
                        "content": "Sorting isn\\'t O(n), just in case you missed the follow up note."
                    }
                ]
            },
            {
                "id": 1728889,
                "content": [
                    {
                        "username": "Abhi3091",
                        "content": "\\n        for(in\\nt i = 0; i<nums.length; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        int left = 0;\\n\\n        int right = nums.length-1;\\n        int index = nums.length-1;\\n        int[] result = new int[nums.length];\\n\\n\\n        while(left <= right){\\n            //16 1 0 9 100\\n            int leftSquare = nums[left];\\n            int rightSquare = nums[right];\\n\\n            //we want to fill up the arrays from right\\n            // the trick is to use new array result\\n            //compare using pointers if right square is large\\n            // update and decrement right index\\n            if(rightSquare > leftSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            //else left index is incremented\\n            }else if(leftSquare > rightSquare){\\n\\n                result[index] = leftSquare;\\n                left++;\\n            //if equal then right value and right index decremented\\n            }else if(leftSquare == rightSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            }\\n\\n            index--;\\n        }\\n\\n        return result;\\n\\nMy java solution beats 100 %"
                    },
                    {
                        "username": "kprat",
                        "content": "Can someone help explain the space and time complexity of this solution:\\n\\nobject Solution {\\n    def sortedSquares(nums: Array[Int]): Array[Int] = {\\n        var left = 0\\n        var right = nums.length\\n        var newArray = new Array[Int](nums.length)\\n        var min = 0\\n        if (nums.length==1)\\n            return Array(sq(nums(0)))\\n        //val status:HashMap[Int,Boolean] = HashMap[Int,Boolean]()\\n        while(left<nums.length-1){\\n            //printArray(nums)\\n            if(Math.abs(nums(left))>Math.abs(nums(left+1)))\\n             swap(left,left+1)\\n            else \\n              {\\n              newArray(left) = sq(nums(left))\\n              newArray(left+1) = sq(nums(left+1))\\n              left+=1\\n              }\\n        }\\n        def swap(i:Int,j:Int) = {\\n            val temp = nums(j)\\n            nums(j) = nums(i)\\n            nums(i) = temp\\n            //newArray(i) = sq(nums(i))\\n            //newArray(j) = sq(nums(j))\\n            if(i>0){\\n            left-=1\\n            }\\n        }\\n\\n        def sq(i:Int):Int = {\\n            i*i\\n        }\\n\\n        def printArray(nums:Array[Int]) = {\\n            println(\"Left:\"+left)\\n            println(\"Array Status\")\\n            nums.foreach(x=> print(\" \" + x + \" \"))\\n            println()\\n        }\\n        newArray\\n    }\\n}"
                    },
                    {
                        "username": "mkaypl",
                        "content": "O(N^2) for time complexity (it\\'s bubble sort)"
                    },
                    {
                        "username": "hoangduy265",
                        "content": "`public class Solution {\n    public int[] SortedSquares(int[] nums) {\n        int[] result = new int[nums.Length];\n        for (int i = 0; i < nums.Length; i++)\n        {\n            if (nums[i] < 0) nums[i] = -nums[i];\n            result[i] = nums[i] * nums[i];\n        }\n        Array.Sort(result);\n        return result;\n    }\n}`"
                    },
                    {
                        "username": "AKUTOTA_SANJAY",
                        "content": "  vector<int> sortedSquares(vector<int>& nums) {\n        vector<int> v;\n        int pi=0,ni,k,l;\n        while(nums[pi]<0)\n        {\n            pi++;\n        }      \n        k=pi;\n        ni=pi-1;\n        for(int k=0;k<nums.size();k++)\n        {\n            nums[k]=nums[k]*nums[k];\n        }\n\n            if(ni==-1)\n            {\n                return nums;\n            }\n          else\n          {\n        while(k<nums.size() and ni>=0)\n        {\n            if(nums[k]<nums[ni])\n            {\n                 \n                v.push_back(nums[k]);\n                k++;\n               \n            }\n            else\n            {\n                 v.push_back(nums[ni]);\n                 ni--;\n            }  \n\n            }\n    }\n        \n        \n        for( ;ni>=0;ni--)\n        {\n            v.push_back(nums[ni]);\n        }\n\n        for(;k<nums.size();k++)\n        {\n             v.push_back(nums[k]);\n        }\n\n     return v;\n    }\n\n\nGetting this error plz help?\n\n=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000514 at pc 0x000000345f9b bp 0x7fffa113dd10 sp 0x7fffa113dd08\nREAD of size 4 at 0x602000000514 thread T0\n    #2 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000514 is located 0 bytes to the right of 4-byte region [0x602000000510,0x602000000514)\nallocated by thread T0 here:\n    #6 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n=>0x0c047fff80a0: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "  return nums.Select(x => x * x ).OrderBy(x=> x).ToArray();\\nC# Linq\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Anyone else getting signed integer overflow? Not sure how to fix this with the return type being a vector<int>"
                    },
                    {
                        "username": "Soumya1999",
                        "content": "Why its shows like memory limit exceeded?\\n"
                    },
                    {
                        "username": "Aryan_Arya",
                        "content": "I have a doubt, can we find the minimum absolute element using log(n) time complexity. Our array is given in sorted fashion. Can we use binary search to find the smallest element (in terms of magnitude)?"
                    },
                    {
                        "username": "irfann2022skipq",
                        "content": "Solved it in very easy wasy with O(n) time complexity.\nvar sortedSquares = function(nums) {\n    let squareArray = []\n    for(let i=0;i<nums.length;i++){\n      squareArray.push(nums[i]*nums[i])\n    }\n    return squareArray.sort((a,b)=>{return a-b})\n}  "
                    },
                    {
                        "username": "eliaashraf",
                        "content": "An easy solution to this would be to first find the squares of each element using a pointer and then using a Arrays.sort(array_name) function to solve this prolem.\\n\\nThis is what I have done-\\n `for(int i = 0; i <= nums.length - 1; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;`"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "then the time complexity will be 0(n logn).Try to solve this in 0(n).That is the challenge"
                    },
                    {
                        "username": "mkaypl",
                        "content": "Sorting isn\\'t O(n), just in case you missed the follow up note."
                    }
                ]
            },
            {
                "id": 1725935,
                "content": [
                    {
                        "username": "Abhi3091",
                        "content": "\\n        for(in\\nt i = 0; i<nums.length; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        int left = 0;\\n\\n        int right = nums.length-1;\\n        int index = nums.length-1;\\n        int[] result = new int[nums.length];\\n\\n\\n        while(left <= right){\\n            //16 1 0 9 100\\n            int leftSquare = nums[left];\\n            int rightSquare = nums[right];\\n\\n            //we want to fill up the arrays from right\\n            // the trick is to use new array result\\n            //compare using pointers if right square is large\\n            // update and decrement right index\\n            if(rightSquare > leftSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            //else left index is incremented\\n            }else if(leftSquare > rightSquare){\\n\\n                result[index] = leftSquare;\\n                left++;\\n            //if equal then right value and right index decremented\\n            }else if(leftSquare == rightSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            }\\n\\n            index--;\\n        }\\n\\n        return result;\\n\\nMy java solution beats 100 %"
                    },
                    {
                        "username": "kprat",
                        "content": "Can someone help explain the space and time complexity of this solution:\\n\\nobject Solution {\\n    def sortedSquares(nums: Array[Int]): Array[Int] = {\\n        var left = 0\\n        var right = nums.length\\n        var newArray = new Array[Int](nums.length)\\n        var min = 0\\n        if (nums.length==1)\\n            return Array(sq(nums(0)))\\n        //val status:HashMap[Int,Boolean] = HashMap[Int,Boolean]()\\n        while(left<nums.length-1){\\n            //printArray(nums)\\n            if(Math.abs(nums(left))>Math.abs(nums(left+1)))\\n             swap(left,left+1)\\n            else \\n              {\\n              newArray(left) = sq(nums(left))\\n              newArray(left+1) = sq(nums(left+1))\\n              left+=1\\n              }\\n        }\\n        def swap(i:Int,j:Int) = {\\n            val temp = nums(j)\\n            nums(j) = nums(i)\\n            nums(i) = temp\\n            //newArray(i) = sq(nums(i))\\n            //newArray(j) = sq(nums(j))\\n            if(i>0){\\n            left-=1\\n            }\\n        }\\n\\n        def sq(i:Int):Int = {\\n            i*i\\n        }\\n\\n        def printArray(nums:Array[Int]) = {\\n            println(\"Left:\"+left)\\n            println(\"Array Status\")\\n            nums.foreach(x=> print(\" \" + x + \" \"))\\n            println()\\n        }\\n        newArray\\n    }\\n}"
                    },
                    {
                        "username": "mkaypl",
                        "content": "O(N^2) for time complexity (it\\'s bubble sort)"
                    },
                    {
                        "username": "hoangduy265",
                        "content": "`public class Solution {\n    public int[] SortedSquares(int[] nums) {\n        int[] result = new int[nums.Length];\n        for (int i = 0; i < nums.Length; i++)\n        {\n            if (nums[i] < 0) nums[i] = -nums[i];\n            result[i] = nums[i] * nums[i];\n        }\n        Array.Sort(result);\n        return result;\n    }\n}`"
                    },
                    {
                        "username": "AKUTOTA_SANJAY",
                        "content": "  vector<int> sortedSquares(vector<int>& nums) {\n        vector<int> v;\n        int pi=0,ni,k,l;\n        while(nums[pi]<0)\n        {\n            pi++;\n        }      \n        k=pi;\n        ni=pi-1;\n        for(int k=0;k<nums.size();k++)\n        {\n            nums[k]=nums[k]*nums[k];\n        }\n\n            if(ni==-1)\n            {\n                return nums;\n            }\n          else\n          {\n        while(k<nums.size() and ni>=0)\n        {\n            if(nums[k]<nums[ni])\n            {\n                 \n                v.push_back(nums[k]);\n                k++;\n               \n            }\n            else\n            {\n                 v.push_back(nums[ni]);\n                 ni--;\n            }  \n\n            }\n    }\n        \n        \n        for( ;ni>=0;ni--)\n        {\n            v.push_back(nums[ni]);\n        }\n\n        for(;k<nums.size();k++)\n        {\n             v.push_back(nums[k]);\n        }\n\n     return v;\n    }\n\n\nGetting this error plz help?\n\n=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000514 at pc 0x000000345f9b bp 0x7fffa113dd10 sp 0x7fffa113dd08\nREAD of size 4 at 0x602000000514 thread T0\n    #2 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000514 is located 0 bytes to the right of 4-byte region [0x602000000510,0x602000000514)\nallocated by thread T0 here:\n    #6 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n=>0x0c047fff80a0: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "  return nums.Select(x => x * x ).OrderBy(x=> x).ToArray();\\nC# Linq\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Anyone else getting signed integer overflow? Not sure how to fix this with the return type being a vector<int>"
                    },
                    {
                        "username": "Soumya1999",
                        "content": "Why its shows like memory limit exceeded?\\n"
                    },
                    {
                        "username": "Aryan_Arya",
                        "content": "I have a doubt, can we find the minimum absolute element using log(n) time complexity. Our array is given in sorted fashion. Can we use binary search to find the smallest element (in terms of magnitude)?"
                    },
                    {
                        "username": "irfann2022skipq",
                        "content": "Solved it in very easy wasy with O(n) time complexity.\nvar sortedSquares = function(nums) {\n    let squareArray = []\n    for(let i=0;i<nums.length;i++){\n      squareArray.push(nums[i]*nums[i])\n    }\n    return squareArray.sort((a,b)=>{return a-b})\n}  "
                    },
                    {
                        "username": "eliaashraf",
                        "content": "An easy solution to this would be to first find the squares of each element using a pointer and then using a Arrays.sort(array_name) function to solve this prolem.\\n\\nThis is what I have done-\\n `for(int i = 0; i <= nums.length - 1; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;`"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "then the time complexity will be 0(n logn).Try to solve this in 0(n).That is the challenge"
                    },
                    {
                        "username": "mkaypl",
                        "content": "Sorting isn\\'t O(n), just in case you missed the follow up note."
                    }
                ]
            },
            {
                "id": 1683890,
                "content": [
                    {
                        "username": "Abhi3091",
                        "content": "\\n        for(in\\nt i = 0; i<nums.length; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        int left = 0;\\n\\n        int right = nums.length-1;\\n        int index = nums.length-1;\\n        int[] result = new int[nums.length];\\n\\n\\n        while(left <= right){\\n            //16 1 0 9 100\\n            int leftSquare = nums[left];\\n            int rightSquare = nums[right];\\n\\n            //we want to fill up the arrays from right\\n            // the trick is to use new array result\\n            //compare using pointers if right square is large\\n            // update and decrement right index\\n            if(rightSquare > leftSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            //else left index is incremented\\n            }else if(leftSquare > rightSquare){\\n\\n                result[index] = leftSquare;\\n                left++;\\n            //if equal then right value and right index decremented\\n            }else if(leftSquare == rightSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            }\\n\\n            index--;\\n        }\\n\\n        return result;\\n\\nMy java solution beats 100 %"
                    },
                    {
                        "username": "kprat",
                        "content": "Can someone help explain the space and time complexity of this solution:\\n\\nobject Solution {\\n    def sortedSquares(nums: Array[Int]): Array[Int] = {\\n        var left = 0\\n        var right = nums.length\\n        var newArray = new Array[Int](nums.length)\\n        var min = 0\\n        if (nums.length==1)\\n            return Array(sq(nums(0)))\\n        //val status:HashMap[Int,Boolean] = HashMap[Int,Boolean]()\\n        while(left<nums.length-1){\\n            //printArray(nums)\\n            if(Math.abs(nums(left))>Math.abs(nums(left+1)))\\n             swap(left,left+1)\\n            else \\n              {\\n              newArray(left) = sq(nums(left))\\n              newArray(left+1) = sq(nums(left+1))\\n              left+=1\\n              }\\n        }\\n        def swap(i:Int,j:Int) = {\\n            val temp = nums(j)\\n            nums(j) = nums(i)\\n            nums(i) = temp\\n            //newArray(i) = sq(nums(i))\\n            //newArray(j) = sq(nums(j))\\n            if(i>0){\\n            left-=1\\n            }\\n        }\\n\\n        def sq(i:Int):Int = {\\n            i*i\\n        }\\n\\n        def printArray(nums:Array[Int]) = {\\n            println(\"Left:\"+left)\\n            println(\"Array Status\")\\n            nums.foreach(x=> print(\" \" + x + \" \"))\\n            println()\\n        }\\n        newArray\\n    }\\n}"
                    },
                    {
                        "username": "mkaypl",
                        "content": "O(N^2) for time complexity (it\\'s bubble sort)"
                    },
                    {
                        "username": "hoangduy265",
                        "content": "`public class Solution {\n    public int[] SortedSquares(int[] nums) {\n        int[] result = new int[nums.Length];\n        for (int i = 0; i < nums.Length; i++)\n        {\n            if (nums[i] < 0) nums[i] = -nums[i];\n            result[i] = nums[i] * nums[i];\n        }\n        Array.Sort(result);\n        return result;\n    }\n}`"
                    },
                    {
                        "username": "AKUTOTA_SANJAY",
                        "content": "  vector<int> sortedSquares(vector<int>& nums) {\n        vector<int> v;\n        int pi=0,ni,k,l;\n        while(nums[pi]<0)\n        {\n            pi++;\n        }      \n        k=pi;\n        ni=pi-1;\n        for(int k=0;k<nums.size();k++)\n        {\n            nums[k]=nums[k]*nums[k];\n        }\n\n            if(ni==-1)\n            {\n                return nums;\n            }\n          else\n          {\n        while(k<nums.size() and ni>=0)\n        {\n            if(nums[k]<nums[ni])\n            {\n                 \n                v.push_back(nums[k]);\n                k++;\n               \n            }\n            else\n            {\n                 v.push_back(nums[ni]);\n                 ni--;\n            }  \n\n            }\n    }\n        \n        \n        for( ;ni>=0;ni--)\n        {\n            v.push_back(nums[ni]);\n        }\n\n        for(;k<nums.size();k++)\n        {\n             v.push_back(nums[k]);\n        }\n\n     return v;\n    }\n\n\nGetting this error plz help?\n\n=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000514 at pc 0x000000345f9b bp 0x7fffa113dd10 sp 0x7fffa113dd08\nREAD of size 4 at 0x602000000514 thread T0\n    #2 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000514 is located 0 bytes to the right of 4-byte region [0x602000000510,0x602000000514)\nallocated by thread T0 here:\n    #6 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n=>0x0c047fff80a0: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "  return nums.Select(x => x * x ).OrderBy(x=> x).ToArray();\\nC# Linq\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Anyone else getting signed integer overflow? Not sure how to fix this with the return type being a vector<int>"
                    },
                    {
                        "username": "Soumya1999",
                        "content": "Why its shows like memory limit exceeded?\\n"
                    },
                    {
                        "username": "Aryan_Arya",
                        "content": "I have a doubt, can we find the minimum absolute element using log(n) time complexity. Our array is given in sorted fashion. Can we use binary search to find the smallest element (in terms of magnitude)?"
                    },
                    {
                        "username": "irfann2022skipq",
                        "content": "Solved it in very easy wasy with O(n) time complexity.\nvar sortedSquares = function(nums) {\n    let squareArray = []\n    for(let i=0;i<nums.length;i++){\n      squareArray.push(nums[i]*nums[i])\n    }\n    return squareArray.sort((a,b)=>{return a-b})\n}  "
                    },
                    {
                        "username": "eliaashraf",
                        "content": "An easy solution to this would be to first find the squares of each element using a pointer and then using a Arrays.sort(array_name) function to solve this prolem.\\n\\nThis is what I have done-\\n `for(int i = 0; i <= nums.length - 1; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;`"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "then the time complexity will be 0(n logn).Try to solve this in 0(n).That is the challenge"
                    },
                    {
                        "username": "mkaypl",
                        "content": "Sorting isn\\'t O(n), just in case you missed the follow up note."
                    }
                ]
            },
            {
                "id": 1676020,
                "content": [
                    {
                        "username": "Abhi3091",
                        "content": "\\n        for(in\\nt i = 0; i<nums.length; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        int left = 0;\\n\\n        int right = nums.length-1;\\n        int index = nums.length-1;\\n        int[] result = new int[nums.length];\\n\\n\\n        while(left <= right){\\n            //16 1 0 9 100\\n            int leftSquare = nums[left];\\n            int rightSquare = nums[right];\\n\\n            //we want to fill up the arrays from right\\n            // the trick is to use new array result\\n            //compare using pointers if right square is large\\n            // update and decrement right index\\n            if(rightSquare > leftSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            //else left index is incremented\\n            }else if(leftSquare > rightSquare){\\n\\n                result[index] = leftSquare;\\n                left++;\\n            //if equal then right value and right index decremented\\n            }else if(leftSquare == rightSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            }\\n\\n            index--;\\n        }\\n\\n        return result;\\n\\nMy java solution beats 100 %"
                    },
                    {
                        "username": "kprat",
                        "content": "Can someone help explain the space and time complexity of this solution:\\n\\nobject Solution {\\n    def sortedSquares(nums: Array[Int]): Array[Int] = {\\n        var left = 0\\n        var right = nums.length\\n        var newArray = new Array[Int](nums.length)\\n        var min = 0\\n        if (nums.length==1)\\n            return Array(sq(nums(0)))\\n        //val status:HashMap[Int,Boolean] = HashMap[Int,Boolean]()\\n        while(left<nums.length-1){\\n            //printArray(nums)\\n            if(Math.abs(nums(left))>Math.abs(nums(left+1)))\\n             swap(left,left+1)\\n            else \\n              {\\n              newArray(left) = sq(nums(left))\\n              newArray(left+1) = sq(nums(left+1))\\n              left+=1\\n              }\\n        }\\n        def swap(i:Int,j:Int) = {\\n            val temp = nums(j)\\n            nums(j) = nums(i)\\n            nums(i) = temp\\n            //newArray(i) = sq(nums(i))\\n            //newArray(j) = sq(nums(j))\\n            if(i>0){\\n            left-=1\\n            }\\n        }\\n\\n        def sq(i:Int):Int = {\\n            i*i\\n        }\\n\\n        def printArray(nums:Array[Int]) = {\\n            println(\"Left:\"+left)\\n            println(\"Array Status\")\\n            nums.foreach(x=> print(\" \" + x + \" \"))\\n            println()\\n        }\\n        newArray\\n    }\\n}"
                    },
                    {
                        "username": "mkaypl",
                        "content": "O(N^2) for time complexity (it\\'s bubble sort)"
                    },
                    {
                        "username": "hoangduy265",
                        "content": "`public class Solution {\n    public int[] SortedSquares(int[] nums) {\n        int[] result = new int[nums.Length];\n        for (int i = 0; i < nums.Length; i++)\n        {\n            if (nums[i] < 0) nums[i] = -nums[i];\n            result[i] = nums[i] * nums[i];\n        }\n        Array.Sort(result);\n        return result;\n    }\n}`"
                    },
                    {
                        "username": "AKUTOTA_SANJAY",
                        "content": "  vector<int> sortedSquares(vector<int>& nums) {\n        vector<int> v;\n        int pi=0,ni,k,l;\n        while(nums[pi]<0)\n        {\n            pi++;\n        }      \n        k=pi;\n        ni=pi-1;\n        for(int k=0;k<nums.size();k++)\n        {\n            nums[k]=nums[k]*nums[k];\n        }\n\n            if(ni==-1)\n            {\n                return nums;\n            }\n          else\n          {\n        while(k<nums.size() and ni>=0)\n        {\n            if(nums[k]<nums[ni])\n            {\n                 \n                v.push_back(nums[k]);\n                k++;\n               \n            }\n            else\n            {\n                 v.push_back(nums[ni]);\n                 ni--;\n            }  \n\n            }\n    }\n        \n        \n        for( ;ni>=0;ni--)\n        {\n            v.push_back(nums[ni]);\n        }\n\n        for(;k<nums.size();k++)\n        {\n             v.push_back(nums[k]);\n        }\n\n     return v;\n    }\n\n\nGetting this error plz help?\n\n=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000514 at pc 0x000000345f9b bp 0x7fffa113dd10 sp 0x7fffa113dd08\nREAD of size 4 at 0x602000000514 thread T0\n    #2 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000514 is located 0 bytes to the right of 4-byte region [0x602000000510,0x602000000514)\nallocated by thread T0 here:\n    #6 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n=>0x0c047fff80a0: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "  return nums.Select(x => x * x ).OrderBy(x=> x).ToArray();\\nC# Linq\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Anyone else getting signed integer overflow? Not sure how to fix this with the return type being a vector<int>"
                    },
                    {
                        "username": "Soumya1999",
                        "content": "Why its shows like memory limit exceeded?\\n"
                    },
                    {
                        "username": "Aryan_Arya",
                        "content": "I have a doubt, can we find the minimum absolute element using log(n) time complexity. Our array is given in sorted fashion. Can we use binary search to find the smallest element (in terms of magnitude)?"
                    },
                    {
                        "username": "irfann2022skipq",
                        "content": "Solved it in very easy wasy with O(n) time complexity.\nvar sortedSquares = function(nums) {\n    let squareArray = []\n    for(let i=0;i<nums.length;i++){\n      squareArray.push(nums[i]*nums[i])\n    }\n    return squareArray.sort((a,b)=>{return a-b})\n}  "
                    },
                    {
                        "username": "eliaashraf",
                        "content": "An easy solution to this would be to first find the squares of each element using a pointer and then using a Arrays.sort(array_name) function to solve this prolem.\\n\\nThis is what I have done-\\n `for(int i = 0; i <= nums.length - 1; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;`"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "then the time complexity will be 0(n logn).Try to solve this in 0(n).That is the challenge"
                    },
                    {
                        "username": "mkaypl",
                        "content": "Sorting isn\\'t O(n), just in case you missed the follow up note."
                    }
                ]
            },
            {
                "id": 1630715,
                "content": [
                    {
                        "username": "Abhi3091",
                        "content": "\\n        for(in\\nt i = 0; i<nums.length; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        int left = 0;\\n\\n        int right = nums.length-1;\\n        int index = nums.length-1;\\n        int[] result = new int[nums.length];\\n\\n\\n        while(left <= right){\\n            //16 1 0 9 100\\n            int leftSquare = nums[left];\\n            int rightSquare = nums[right];\\n\\n            //we want to fill up the arrays from right\\n            // the trick is to use new array result\\n            //compare using pointers if right square is large\\n            // update and decrement right index\\n            if(rightSquare > leftSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            //else left index is incremented\\n            }else if(leftSquare > rightSquare){\\n\\n                result[index] = leftSquare;\\n                left++;\\n            //if equal then right value and right index decremented\\n            }else if(leftSquare == rightSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            }\\n\\n            index--;\\n        }\\n\\n        return result;\\n\\nMy java solution beats 100 %"
                    },
                    {
                        "username": "kprat",
                        "content": "Can someone help explain the space and time complexity of this solution:\\n\\nobject Solution {\\n    def sortedSquares(nums: Array[Int]): Array[Int] = {\\n        var left = 0\\n        var right = nums.length\\n        var newArray = new Array[Int](nums.length)\\n        var min = 0\\n        if (nums.length==1)\\n            return Array(sq(nums(0)))\\n        //val status:HashMap[Int,Boolean] = HashMap[Int,Boolean]()\\n        while(left<nums.length-1){\\n            //printArray(nums)\\n            if(Math.abs(nums(left))>Math.abs(nums(left+1)))\\n             swap(left,left+1)\\n            else \\n              {\\n              newArray(left) = sq(nums(left))\\n              newArray(left+1) = sq(nums(left+1))\\n              left+=1\\n              }\\n        }\\n        def swap(i:Int,j:Int) = {\\n            val temp = nums(j)\\n            nums(j) = nums(i)\\n            nums(i) = temp\\n            //newArray(i) = sq(nums(i))\\n            //newArray(j) = sq(nums(j))\\n            if(i>0){\\n            left-=1\\n            }\\n        }\\n\\n        def sq(i:Int):Int = {\\n            i*i\\n        }\\n\\n        def printArray(nums:Array[Int]) = {\\n            println(\"Left:\"+left)\\n            println(\"Array Status\")\\n            nums.foreach(x=> print(\" \" + x + \" \"))\\n            println()\\n        }\\n        newArray\\n    }\\n}"
                    },
                    {
                        "username": "mkaypl",
                        "content": "O(N^2) for time complexity (it\\'s bubble sort)"
                    },
                    {
                        "username": "hoangduy265",
                        "content": "`public class Solution {\n    public int[] SortedSquares(int[] nums) {\n        int[] result = new int[nums.Length];\n        for (int i = 0; i < nums.Length; i++)\n        {\n            if (nums[i] < 0) nums[i] = -nums[i];\n            result[i] = nums[i] * nums[i];\n        }\n        Array.Sort(result);\n        return result;\n    }\n}`"
                    },
                    {
                        "username": "AKUTOTA_SANJAY",
                        "content": "  vector<int> sortedSquares(vector<int>& nums) {\n        vector<int> v;\n        int pi=0,ni,k,l;\n        while(nums[pi]<0)\n        {\n            pi++;\n        }      \n        k=pi;\n        ni=pi-1;\n        for(int k=0;k<nums.size();k++)\n        {\n            nums[k]=nums[k]*nums[k];\n        }\n\n            if(ni==-1)\n            {\n                return nums;\n            }\n          else\n          {\n        while(k<nums.size() and ni>=0)\n        {\n            if(nums[k]<nums[ni])\n            {\n                 \n                v.push_back(nums[k]);\n                k++;\n               \n            }\n            else\n            {\n                 v.push_back(nums[ni]);\n                 ni--;\n            }  \n\n            }\n    }\n        \n        \n        for( ;ni>=0;ni--)\n        {\n            v.push_back(nums[ni]);\n        }\n\n        for(;k<nums.size();k++)\n        {\n             v.push_back(nums[k]);\n        }\n\n     return v;\n    }\n\n\nGetting this error plz help?\n\n=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000514 at pc 0x000000345f9b bp 0x7fffa113dd10 sp 0x7fffa113dd08\nREAD of size 4 at 0x602000000514 thread T0\n    #2 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000514 is located 0 bytes to the right of 4-byte region [0x602000000510,0x602000000514)\nallocated by thread T0 here:\n    #6 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n=>0x0c047fff80a0: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "  return nums.Select(x => x * x ).OrderBy(x=> x).ToArray();\\nC# Linq\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Anyone else getting signed integer overflow? Not sure how to fix this with the return type being a vector<int>"
                    },
                    {
                        "username": "Soumya1999",
                        "content": "Why its shows like memory limit exceeded?\\n"
                    },
                    {
                        "username": "Aryan_Arya",
                        "content": "I have a doubt, can we find the minimum absolute element using log(n) time complexity. Our array is given in sorted fashion. Can we use binary search to find the smallest element (in terms of magnitude)?"
                    },
                    {
                        "username": "irfann2022skipq",
                        "content": "Solved it in very easy wasy with O(n) time complexity.\nvar sortedSquares = function(nums) {\n    let squareArray = []\n    for(let i=0;i<nums.length;i++){\n      squareArray.push(nums[i]*nums[i])\n    }\n    return squareArray.sort((a,b)=>{return a-b})\n}  "
                    },
                    {
                        "username": "eliaashraf",
                        "content": "An easy solution to this would be to first find the squares of each element using a pointer and then using a Arrays.sort(array_name) function to solve this prolem.\\n\\nThis is what I have done-\\n `for(int i = 0; i <= nums.length - 1; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;`"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "then the time complexity will be 0(n logn).Try to solve this in 0(n).That is the challenge"
                    },
                    {
                        "username": "mkaypl",
                        "content": "Sorting isn\\'t O(n), just in case you missed the follow up note."
                    }
                ]
            },
            {
                "id": 1749808,
                "content": [
                    {
                        "username": "Abhi3091",
                        "content": "\\n        for(in\\nt i = 0; i<nums.length; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        int left = 0;\\n\\n        int right = nums.length-1;\\n        int index = nums.length-1;\\n        int[] result = new int[nums.length];\\n\\n\\n        while(left <= right){\\n            //16 1 0 9 100\\n            int leftSquare = nums[left];\\n            int rightSquare = nums[right];\\n\\n            //we want to fill up the arrays from right\\n            // the trick is to use new array result\\n            //compare using pointers if right square is large\\n            // update and decrement right index\\n            if(rightSquare > leftSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            //else left index is incremented\\n            }else if(leftSquare > rightSquare){\\n\\n                result[index] = leftSquare;\\n                left++;\\n            //if equal then right value and right index decremented\\n            }else if(leftSquare == rightSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            }\\n\\n            index--;\\n        }\\n\\n        return result;\\n\\nMy java solution beats 100 %"
                    },
                    {
                        "username": "kprat",
                        "content": "Can someone help explain the space and time complexity of this solution:\\n\\nobject Solution {\\n    def sortedSquares(nums: Array[Int]): Array[Int] = {\\n        var left = 0\\n        var right = nums.length\\n        var newArray = new Array[Int](nums.length)\\n        var min = 0\\n        if (nums.length==1)\\n            return Array(sq(nums(0)))\\n        //val status:HashMap[Int,Boolean] = HashMap[Int,Boolean]()\\n        while(left<nums.length-1){\\n            //printArray(nums)\\n            if(Math.abs(nums(left))>Math.abs(nums(left+1)))\\n             swap(left,left+1)\\n            else \\n              {\\n              newArray(left) = sq(nums(left))\\n              newArray(left+1) = sq(nums(left+1))\\n              left+=1\\n              }\\n        }\\n        def swap(i:Int,j:Int) = {\\n            val temp = nums(j)\\n            nums(j) = nums(i)\\n            nums(i) = temp\\n            //newArray(i) = sq(nums(i))\\n            //newArray(j) = sq(nums(j))\\n            if(i>0){\\n            left-=1\\n            }\\n        }\\n\\n        def sq(i:Int):Int = {\\n            i*i\\n        }\\n\\n        def printArray(nums:Array[Int]) = {\\n            println(\"Left:\"+left)\\n            println(\"Array Status\")\\n            nums.foreach(x=> print(\" \" + x + \" \"))\\n            println()\\n        }\\n        newArray\\n    }\\n}"
                    },
                    {
                        "username": "mkaypl",
                        "content": "O(N^2) for time complexity (it\\'s bubble sort)"
                    },
                    {
                        "username": "hoangduy265",
                        "content": "`public class Solution {\n    public int[] SortedSquares(int[] nums) {\n        int[] result = new int[nums.Length];\n        for (int i = 0; i < nums.Length; i++)\n        {\n            if (nums[i] < 0) nums[i] = -nums[i];\n            result[i] = nums[i] * nums[i];\n        }\n        Array.Sort(result);\n        return result;\n    }\n}`"
                    },
                    {
                        "username": "AKUTOTA_SANJAY",
                        "content": "  vector<int> sortedSquares(vector<int>& nums) {\n        vector<int> v;\n        int pi=0,ni,k,l;\n        while(nums[pi]<0)\n        {\n            pi++;\n        }      \n        k=pi;\n        ni=pi-1;\n        for(int k=0;k<nums.size();k++)\n        {\n            nums[k]=nums[k]*nums[k];\n        }\n\n            if(ni==-1)\n            {\n                return nums;\n            }\n          else\n          {\n        while(k<nums.size() and ni>=0)\n        {\n            if(nums[k]<nums[ni])\n            {\n                 \n                v.push_back(nums[k]);\n                k++;\n               \n            }\n            else\n            {\n                 v.push_back(nums[ni]);\n                 ni--;\n            }  \n\n            }\n    }\n        \n        \n        for( ;ni>=0;ni--)\n        {\n            v.push_back(nums[ni]);\n        }\n\n        for(;k<nums.size();k++)\n        {\n             v.push_back(nums[k]);\n        }\n\n     return v;\n    }\n\n\nGetting this error plz help?\n\n=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000514 at pc 0x000000345f9b bp 0x7fffa113dd10 sp 0x7fffa113dd08\nREAD of size 4 at 0x602000000514 thread T0\n    #2 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000514 is located 0 bytes to the right of 4-byte region [0x602000000510,0x602000000514)\nallocated by thread T0 here:\n    #6 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n=>0x0c047fff80a0: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "  return nums.Select(x => x * x ).OrderBy(x=> x).ToArray();\\nC# Linq\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Anyone else getting signed integer overflow? Not sure how to fix this with the return type being a vector<int>"
                    },
                    {
                        "username": "Soumya1999",
                        "content": "Why its shows like memory limit exceeded?\\n"
                    },
                    {
                        "username": "Aryan_Arya",
                        "content": "I have a doubt, can we find the minimum absolute element using log(n) time complexity. Our array is given in sorted fashion. Can we use binary search to find the smallest element (in terms of magnitude)?"
                    },
                    {
                        "username": "irfann2022skipq",
                        "content": "Solved it in very easy wasy with O(n) time complexity.\nvar sortedSquares = function(nums) {\n    let squareArray = []\n    for(let i=0;i<nums.length;i++){\n      squareArray.push(nums[i]*nums[i])\n    }\n    return squareArray.sort((a,b)=>{return a-b})\n}  "
                    },
                    {
                        "username": "eliaashraf",
                        "content": "An easy solution to this would be to first find the squares of each element using a pointer and then using a Arrays.sort(array_name) function to solve this prolem.\\n\\nThis is what I have done-\\n `for(int i = 0; i <= nums.length - 1; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;`"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "then the time complexity will be 0(n logn).Try to solve this in 0(n).That is the challenge"
                    },
                    {
                        "username": "mkaypl",
                        "content": "Sorting isn\\'t O(n), just in case you missed the follow up note."
                    }
                ]
            }
        ]
    }
]