[
    {
        "title": "Missing Ranges",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1788218,
                "content": [
                    {
                        "username": "v_suresh",
                        "content": "Unfortunately, One of the most frustrating experiences was with this question! \\n"
                    },
                    {
                        "username": "nikonok",
                        "content": "Because of corner cases looks like not \"easy\" =("
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Do not naively loop from lower to upper. O(n) can be achieved by looping over nums instead."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases make this obnoxious."
                    },
                    {
                        "username": "BubbleTree",
                        "content": "so many edge cases lol"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Why are there so many dislikes, is it because there are few edge cases or? I think the problem statement and constraints are clearly defined."
                    },
                    {
                        "username": "lpaben62",
                        "content": "Pay attention to the constraints, especially on the fact that \"lower <= nums[i] <= upper\". As opposed to number of dislikes may suggest, this problem is actually a good practices for you to pay attention to some of the nuances!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This used to ask for a return of []string."
                    },
                    {
                        "username": "saurabh_biswas",
                        "content": " `\\n\\n    public List<String> findMissingRanges(int[] nums, int lower, int upper) {\\n        Set<Integer> set = new HashSet<>();\\n        List<String> results = new ArrayList<>();\\n        for(int num: nums) set.add(num);\\n        for(int i=lower; i <=upper; i++){\\n            if(!set.contains(i)){\\n                StringBuilder sb = new StringBuilder();\\n                int start = i;\\n                int j=0;\\n                while(!set.contains(i+j) && i+j <= upper) j++;\\n                int end = i+j-1;\\n                i = end;\\n                if(start == end) sb.append(start);\\n                else sb.append(start).append(\"->\").append(end);\\n                results.add(sb.toString());\\n            }\\n        }\\n        return results;\\n    }\\n\\n`\\nHi need some feedback on my above solution. This is the most intuitive solution I could come up on my first attempt. The default test cases passes but it times out using [1000000000] ,lower=0, upper=1000000000. I believe the time complexity of the above code is O(n) with constant space of the Set being used. Wondering what is that I\\'m doing wrong. Thanks in advance."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Too many edge cases! Frustrating for each test case...!"
                    }
                ]
            },
            {
                "id": 1932089,
                "content": [
                    {
                        "username": "v_suresh",
                        "content": "Unfortunately, One of the most frustrating experiences was with this question! \\n"
                    },
                    {
                        "username": "nikonok",
                        "content": "Because of corner cases looks like not \"easy\" =("
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Do not naively loop from lower to upper. O(n) can be achieved by looping over nums instead."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases make this obnoxious."
                    },
                    {
                        "username": "BubbleTree",
                        "content": "so many edge cases lol"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Why are there so many dislikes, is it because there are few edge cases or? I think the problem statement and constraints are clearly defined."
                    },
                    {
                        "username": "lpaben62",
                        "content": "Pay attention to the constraints, especially on the fact that \"lower <= nums[i] <= upper\". As opposed to number of dislikes may suggest, this problem is actually a good practices for you to pay attention to some of the nuances!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This used to ask for a return of []string."
                    },
                    {
                        "username": "saurabh_biswas",
                        "content": " `\\n\\n    public List<String> findMissingRanges(int[] nums, int lower, int upper) {\\n        Set<Integer> set = new HashSet<>();\\n        List<String> results = new ArrayList<>();\\n        for(int num: nums) set.add(num);\\n        for(int i=lower; i <=upper; i++){\\n            if(!set.contains(i)){\\n                StringBuilder sb = new StringBuilder();\\n                int start = i;\\n                int j=0;\\n                while(!set.contains(i+j) && i+j <= upper) j++;\\n                int end = i+j-1;\\n                i = end;\\n                if(start == end) sb.append(start);\\n                else sb.append(start).append(\"->\").append(end);\\n                results.add(sb.toString());\\n            }\\n        }\\n        return results;\\n    }\\n\\n`\\nHi need some feedback on my above solution. This is the most intuitive solution I could come up on my first attempt. The default test cases passes but it times out using [1000000000] ,lower=0, upper=1000000000. I believe the time complexity of the above code is O(n) with constant space of the Set being used. Wondering what is that I\\'m doing wrong. Thanks in advance."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Too many edge cases! Frustrating for each test case...!"
                    }
                ]
            },
            {
                "id": 1929843,
                "content": [
                    {
                        "username": "v_suresh",
                        "content": "Unfortunately, One of the most frustrating experiences was with this question! \\n"
                    },
                    {
                        "username": "nikonok",
                        "content": "Because of corner cases looks like not \"easy\" =("
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Do not naively loop from lower to upper. O(n) can be achieved by looping over nums instead."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases make this obnoxious."
                    },
                    {
                        "username": "BubbleTree",
                        "content": "so many edge cases lol"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Why are there so many dislikes, is it because there are few edge cases or? I think the problem statement and constraints are clearly defined."
                    },
                    {
                        "username": "lpaben62",
                        "content": "Pay attention to the constraints, especially on the fact that \"lower <= nums[i] <= upper\". As opposed to number of dislikes may suggest, this problem is actually a good practices for you to pay attention to some of the nuances!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This used to ask for a return of []string."
                    },
                    {
                        "username": "saurabh_biswas",
                        "content": " `\\n\\n    public List<String> findMissingRanges(int[] nums, int lower, int upper) {\\n        Set<Integer> set = new HashSet<>();\\n        List<String> results = new ArrayList<>();\\n        for(int num: nums) set.add(num);\\n        for(int i=lower; i <=upper; i++){\\n            if(!set.contains(i)){\\n                StringBuilder sb = new StringBuilder();\\n                int start = i;\\n                int j=0;\\n                while(!set.contains(i+j) && i+j <= upper) j++;\\n                int end = i+j-1;\\n                i = end;\\n                if(start == end) sb.append(start);\\n                else sb.append(start).append(\"->\").append(end);\\n                results.add(sb.toString());\\n            }\\n        }\\n        return results;\\n    }\\n\\n`\\nHi need some feedback on my above solution. This is the most intuitive solution I could come up on my first attempt. The default test cases passes but it times out using [1000000000] ,lower=0, upper=1000000000. I believe the time complexity of the above code is O(n) with constant space of the Set being used. Wondering what is that I\\'m doing wrong. Thanks in advance."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Too many edge cases! Frustrating for each test case...!"
                    }
                ]
            },
            {
                "id": 1893062,
                "content": [
                    {
                        "username": "v_suresh",
                        "content": "Unfortunately, One of the most frustrating experiences was with this question! \\n"
                    },
                    {
                        "username": "nikonok",
                        "content": "Because of corner cases looks like not \"easy\" =("
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Do not naively loop from lower to upper. O(n) can be achieved by looping over nums instead."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases make this obnoxious."
                    },
                    {
                        "username": "BubbleTree",
                        "content": "so many edge cases lol"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Why are there so many dislikes, is it because there are few edge cases or? I think the problem statement and constraints are clearly defined."
                    },
                    {
                        "username": "lpaben62",
                        "content": "Pay attention to the constraints, especially on the fact that \"lower <= nums[i] <= upper\". As opposed to number of dislikes may suggest, this problem is actually a good practices for you to pay attention to some of the nuances!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This used to ask for a return of []string."
                    },
                    {
                        "username": "saurabh_biswas",
                        "content": " `\\n\\n    public List<String> findMissingRanges(int[] nums, int lower, int upper) {\\n        Set<Integer> set = new HashSet<>();\\n        List<String> results = new ArrayList<>();\\n        for(int num: nums) set.add(num);\\n        for(int i=lower; i <=upper; i++){\\n            if(!set.contains(i)){\\n                StringBuilder sb = new StringBuilder();\\n                int start = i;\\n                int j=0;\\n                while(!set.contains(i+j) && i+j <= upper) j++;\\n                int end = i+j-1;\\n                i = end;\\n                if(start == end) sb.append(start);\\n                else sb.append(start).append(\"->\").append(end);\\n                results.add(sb.toString());\\n            }\\n        }\\n        return results;\\n    }\\n\\n`\\nHi need some feedback on my above solution. This is the most intuitive solution I could come up on my first attempt. The default test cases passes but it times out using [1000000000] ,lower=0, upper=1000000000. I believe the time complexity of the above code is O(n) with constant space of the Set being used. Wondering what is that I\\'m doing wrong. Thanks in advance."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Too many edge cases! Frustrating for each test case...!"
                    }
                ]
            },
            {
                "id": 2039675,
                "content": [
                    {
                        "username": "v_suresh",
                        "content": "Unfortunately, One of the most frustrating experiences was with this question! \\n"
                    },
                    {
                        "username": "nikonok",
                        "content": "Because of corner cases looks like not \"easy\" =("
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Do not naively loop from lower to upper. O(n) can be achieved by looping over nums instead."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases make this obnoxious."
                    },
                    {
                        "username": "BubbleTree",
                        "content": "so many edge cases lol"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Why are there so many dislikes, is it because there are few edge cases or? I think the problem statement and constraints are clearly defined."
                    },
                    {
                        "username": "lpaben62",
                        "content": "Pay attention to the constraints, especially on the fact that \"lower <= nums[i] <= upper\". As opposed to number of dislikes may suggest, this problem is actually a good practices for you to pay attention to some of the nuances!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This used to ask for a return of []string."
                    },
                    {
                        "username": "saurabh_biswas",
                        "content": " `\\n\\n    public List<String> findMissingRanges(int[] nums, int lower, int upper) {\\n        Set<Integer> set = new HashSet<>();\\n        List<String> results = new ArrayList<>();\\n        for(int num: nums) set.add(num);\\n        for(int i=lower; i <=upper; i++){\\n            if(!set.contains(i)){\\n                StringBuilder sb = new StringBuilder();\\n                int start = i;\\n                int j=0;\\n                while(!set.contains(i+j) && i+j <= upper) j++;\\n                int end = i+j-1;\\n                i = end;\\n                if(start == end) sb.append(start);\\n                else sb.append(start).append(\"->\").append(end);\\n                results.add(sb.toString());\\n            }\\n        }\\n        return results;\\n    }\\n\\n`\\nHi need some feedback on my above solution. This is the most intuitive solution I could come up on my first attempt. The default test cases passes but it times out using [1000000000] ,lower=0, upper=1000000000. I believe the time complexity of the above code is O(n) with constant space of the Set being used. Wondering what is that I\\'m doing wrong. Thanks in advance."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Too many edge cases! Frustrating for each test case...!"
                    }
                ]
            },
            {
                "id": 2037904,
                "content": [
                    {
                        "username": "v_suresh",
                        "content": "Unfortunately, One of the most frustrating experiences was with this question! \\n"
                    },
                    {
                        "username": "nikonok",
                        "content": "Because of corner cases looks like not \"easy\" =("
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Do not naively loop from lower to upper. O(n) can be achieved by looping over nums instead."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases make this obnoxious."
                    },
                    {
                        "username": "BubbleTree",
                        "content": "so many edge cases lol"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Why are there so many dislikes, is it because there are few edge cases or? I think the problem statement and constraints are clearly defined."
                    },
                    {
                        "username": "lpaben62",
                        "content": "Pay attention to the constraints, especially on the fact that \"lower <= nums[i] <= upper\". As opposed to number of dislikes may suggest, this problem is actually a good practices for you to pay attention to some of the nuances!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This used to ask for a return of []string."
                    },
                    {
                        "username": "saurabh_biswas",
                        "content": " `\\n\\n    public List<String> findMissingRanges(int[] nums, int lower, int upper) {\\n        Set<Integer> set = new HashSet<>();\\n        List<String> results = new ArrayList<>();\\n        for(int num: nums) set.add(num);\\n        for(int i=lower; i <=upper; i++){\\n            if(!set.contains(i)){\\n                StringBuilder sb = new StringBuilder();\\n                int start = i;\\n                int j=0;\\n                while(!set.contains(i+j) && i+j <= upper) j++;\\n                int end = i+j-1;\\n                i = end;\\n                if(start == end) sb.append(start);\\n                else sb.append(start).append(\"->\").append(end);\\n                results.add(sb.toString());\\n            }\\n        }\\n        return results;\\n    }\\n\\n`\\nHi need some feedback on my above solution. This is the most intuitive solution I could come up on my first attempt. The default test cases passes but it times out using [1000000000] ,lower=0, upper=1000000000. I believe the time complexity of the above code is O(n) with constant space of the Set being used. Wondering what is that I\\'m doing wrong. Thanks in advance."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Too many edge cases! Frustrating for each test case...!"
                    }
                ]
            },
            {
                "id": 1986957,
                "content": [
                    {
                        "username": "v_suresh",
                        "content": "Unfortunately, One of the most frustrating experiences was with this question! \\n"
                    },
                    {
                        "username": "nikonok",
                        "content": "Because of corner cases looks like not \"easy\" =("
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Do not naively loop from lower to upper. O(n) can be achieved by looping over nums instead."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases make this obnoxious."
                    },
                    {
                        "username": "BubbleTree",
                        "content": "so many edge cases lol"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Why are there so many dislikes, is it because there are few edge cases or? I think the problem statement and constraints are clearly defined."
                    },
                    {
                        "username": "lpaben62",
                        "content": "Pay attention to the constraints, especially on the fact that \"lower <= nums[i] <= upper\". As opposed to number of dislikes may suggest, this problem is actually a good practices for you to pay attention to some of the nuances!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This used to ask for a return of []string."
                    },
                    {
                        "username": "saurabh_biswas",
                        "content": " `\\n\\n    public List<String> findMissingRanges(int[] nums, int lower, int upper) {\\n        Set<Integer> set = new HashSet<>();\\n        List<String> results = new ArrayList<>();\\n        for(int num: nums) set.add(num);\\n        for(int i=lower; i <=upper; i++){\\n            if(!set.contains(i)){\\n                StringBuilder sb = new StringBuilder();\\n                int start = i;\\n                int j=0;\\n                while(!set.contains(i+j) && i+j <= upper) j++;\\n                int end = i+j-1;\\n                i = end;\\n                if(start == end) sb.append(start);\\n                else sb.append(start).append(\"->\").append(end);\\n                results.add(sb.toString());\\n            }\\n        }\\n        return results;\\n    }\\n\\n`\\nHi need some feedback on my above solution. This is the most intuitive solution I could come up on my first attempt. The default test cases passes but it times out using [1000000000] ,lower=0, upper=1000000000. I believe the time complexity of the above code is O(n) with constant space of the Set being used. Wondering what is that I\\'m doing wrong. Thanks in advance."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Too many edge cases! Frustrating for each test case...!"
                    }
                ]
            },
            {
                "id": 1929880,
                "content": [
                    {
                        "username": "v_suresh",
                        "content": "Unfortunately, One of the most frustrating experiences was with this question! \\n"
                    },
                    {
                        "username": "nikonok",
                        "content": "Because of corner cases looks like not \"easy\" =("
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Do not naively loop from lower to upper. O(n) can be achieved by looping over nums instead."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases make this obnoxious."
                    },
                    {
                        "username": "BubbleTree",
                        "content": "so many edge cases lol"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Why are there so many dislikes, is it because there are few edge cases or? I think the problem statement and constraints are clearly defined."
                    },
                    {
                        "username": "lpaben62",
                        "content": "Pay attention to the constraints, especially on the fact that \"lower <= nums[i] <= upper\". As opposed to number of dislikes may suggest, this problem is actually a good practices for you to pay attention to some of the nuances!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This used to ask for a return of []string."
                    },
                    {
                        "username": "saurabh_biswas",
                        "content": " `\\n\\n    public List<String> findMissingRanges(int[] nums, int lower, int upper) {\\n        Set<Integer> set = new HashSet<>();\\n        List<String> results = new ArrayList<>();\\n        for(int num: nums) set.add(num);\\n        for(int i=lower; i <=upper; i++){\\n            if(!set.contains(i)){\\n                StringBuilder sb = new StringBuilder();\\n                int start = i;\\n                int j=0;\\n                while(!set.contains(i+j) && i+j <= upper) j++;\\n                int end = i+j-1;\\n                i = end;\\n                if(start == end) sb.append(start);\\n                else sb.append(start).append(\"->\").append(end);\\n                results.add(sb.toString());\\n            }\\n        }\\n        return results;\\n    }\\n\\n`\\nHi need some feedback on my above solution. This is the most intuitive solution I could come up on my first attempt. The default test cases passes but it times out using [1000000000] ,lower=0, upper=1000000000. I believe the time complexity of the above code is O(n) with constant space of the Set being used. Wondering what is that I\\'m doing wrong. Thanks in advance."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Too many edge cases! Frustrating for each test case...!"
                    }
                ]
            },
            {
                "id": 1759808,
                "content": [
                    {
                        "username": "v_suresh",
                        "content": "Unfortunately, One of the most frustrating experiences was with this question! \\n"
                    },
                    {
                        "username": "nikonok",
                        "content": "Because of corner cases looks like not \"easy\" =("
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Do not naively loop from lower to upper. O(n) can be achieved by looping over nums instead."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases make this obnoxious."
                    },
                    {
                        "username": "BubbleTree",
                        "content": "so many edge cases lol"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Why are there so many dislikes, is it because there are few edge cases or? I think the problem statement and constraints are clearly defined."
                    },
                    {
                        "username": "lpaben62",
                        "content": "Pay attention to the constraints, especially on the fact that \"lower <= nums[i] <= upper\". As opposed to number of dislikes may suggest, this problem is actually a good practices for you to pay attention to some of the nuances!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This used to ask for a return of []string."
                    },
                    {
                        "username": "saurabh_biswas",
                        "content": " `\\n\\n    public List<String> findMissingRanges(int[] nums, int lower, int upper) {\\n        Set<Integer> set = new HashSet<>();\\n        List<String> results = new ArrayList<>();\\n        for(int num: nums) set.add(num);\\n        for(int i=lower; i <=upper; i++){\\n            if(!set.contains(i)){\\n                StringBuilder sb = new StringBuilder();\\n                int start = i;\\n                int j=0;\\n                while(!set.contains(i+j) && i+j <= upper) j++;\\n                int end = i+j-1;\\n                i = end;\\n                if(start == end) sb.append(start);\\n                else sb.append(start).append(\"->\").append(end);\\n                results.add(sb.toString());\\n            }\\n        }\\n        return results;\\n    }\\n\\n`\\nHi need some feedback on my above solution. This is the most intuitive solution I could come up on my first attempt. The default test cases passes but it times out using [1000000000] ,lower=0, upper=1000000000. I believe the time complexity of the above code is O(n) with constant space of the Set being used. Wondering what is that I\\'m doing wrong. Thanks in advance."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Too many edge cases! Frustrating for each test case...!"
                    }
                ]
            },
            {
                "id": 1729557,
                "content": [
                    {
                        "username": "v_suresh",
                        "content": "Unfortunately, One of the most frustrating experiences was with this question! \\n"
                    },
                    {
                        "username": "nikonok",
                        "content": "Because of corner cases looks like not \"easy\" =("
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Do not naively loop from lower to upper. O(n) can be achieved by looping over nums instead."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases make this obnoxious."
                    },
                    {
                        "username": "BubbleTree",
                        "content": "so many edge cases lol"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Why are there so many dislikes, is it because there are few edge cases or? I think the problem statement and constraints are clearly defined."
                    },
                    {
                        "username": "lpaben62",
                        "content": "Pay attention to the constraints, especially on the fact that \"lower <= nums[i] <= upper\". As opposed to number of dislikes may suggest, this problem is actually a good practices for you to pay attention to some of the nuances!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This used to ask for a return of []string."
                    },
                    {
                        "username": "saurabh_biswas",
                        "content": " `\\n\\n    public List<String> findMissingRanges(int[] nums, int lower, int upper) {\\n        Set<Integer> set = new HashSet<>();\\n        List<String> results = new ArrayList<>();\\n        for(int num: nums) set.add(num);\\n        for(int i=lower; i <=upper; i++){\\n            if(!set.contains(i)){\\n                StringBuilder sb = new StringBuilder();\\n                int start = i;\\n                int j=0;\\n                while(!set.contains(i+j) && i+j <= upper) j++;\\n                int end = i+j-1;\\n                i = end;\\n                if(start == end) sb.append(start);\\n                else sb.append(start).append(\"->\").append(end);\\n                results.add(sb.toString());\\n            }\\n        }\\n        return results;\\n    }\\n\\n`\\nHi need some feedback on my above solution. This is the most intuitive solution I could come up on my first attempt. The default test cases passes but it times out using [1000000000] ,lower=0, upper=1000000000. I believe the time complexity of the above code is O(n) with constant space of the Set being used. Wondering what is that I\\'m doing wrong. Thanks in advance."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Too many edge cases! Frustrating for each test case...!"
                    }
                ]
            },
            {
                "id": 1788218,
                "content": [
                    {
                        "username": "v_suresh",
                        "content": "Unfortunately, One of the most frustrating experiences was with this question! \\n"
                    },
                    {
                        "username": "nikonok",
                        "content": "Because of corner cases looks like not \"easy\" =("
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Do not naively loop from lower to upper. O(n) can be achieved by looping over nums instead."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases make this obnoxious."
                    },
                    {
                        "username": "BubbleTree",
                        "content": "so many edge cases lol"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Why are there so many dislikes, is it because there are few edge cases or? I think the problem statement and constraints are clearly defined."
                    },
                    {
                        "username": "lpaben62",
                        "content": "Pay attention to the constraints, especially on the fact that \"lower <= nums[i] <= upper\". As opposed to number of dislikes may suggest, this problem is actually a good practices for you to pay attention to some of the nuances!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This used to ask for a return of []string."
                    },
                    {
                        "username": "saurabh_biswas",
                        "content": " `\\n\\n    public List<String> findMissingRanges(int[] nums, int lower, int upper) {\\n        Set<Integer> set = new HashSet<>();\\n        List<String> results = new ArrayList<>();\\n        for(int num: nums) set.add(num);\\n        for(int i=lower; i <=upper; i++){\\n            if(!set.contains(i)){\\n                StringBuilder sb = new StringBuilder();\\n                int start = i;\\n                int j=0;\\n                while(!set.contains(i+j) && i+j <= upper) j++;\\n                int end = i+j-1;\\n                i = end;\\n                if(start == end) sb.append(start);\\n                else sb.append(start).append(\"->\").append(end);\\n                results.add(sb.toString());\\n            }\\n        }\\n        return results;\\n    }\\n\\n`\\nHi need some feedback on my above solution. This is the most intuitive solution I could come up on my first attempt. The default test cases passes but it times out using [1000000000] ,lower=0, upper=1000000000. I believe the time complexity of the above code is O(n) with constant space of the Set being used. Wondering what is that I\\'m doing wrong. Thanks in advance."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Too many edge cases! Frustrating for each test case...!"
                    }
                ]
            },
            {
                "id": 1932089,
                "content": [
                    {
                        "username": "v_suresh",
                        "content": "Unfortunately, One of the most frustrating experiences was with this question! \\n"
                    },
                    {
                        "username": "nikonok",
                        "content": "Because of corner cases looks like not \"easy\" =("
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Do not naively loop from lower to upper. O(n) can be achieved by looping over nums instead."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases make this obnoxious."
                    },
                    {
                        "username": "BubbleTree",
                        "content": "so many edge cases lol"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Why are there so many dislikes, is it because there are few edge cases or? I think the problem statement and constraints are clearly defined."
                    },
                    {
                        "username": "lpaben62",
                        "content": "Pay attention to the constraints, especially on the fact that \"lower <= nums[i] <= upper\". As opposed to number of dislikes may suggest, this problem is actually a good practices for you to pay attention to some of the nuances!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This used to ask for a return of []string."
                    },
                    {
                        "username": "saurabh_biswas",
                        "content": " `\\n\\n    public List<String> findMissingRanges(int[] nums, int lower, int upper) {\\n        Set<Integer> set = new HashSet<>();\\n        List<String> results = new ArrayList<>();\\n        for(int num: nums) set.add(num);\\n        for(int i=lower; i <=upper; i++){\\n            if(!set.contains(i)){\\n                StringBuilder sb = new StringBuilder();\\n                int start = i;\\n                int j=0;\\n                while(!set.contains(i+j) && i+j <= upper) j++;\\n                int end = i+j-1;\\n                i = end;\\n                if(start == end) sb.append(start);\\n                else sb.append(start).append(\"->\").append(end);\\n                results.add(sb.toString());\\n            }\\n        }\\n        return results;\\n    }\\n\\n`\\nHi need some feedback on my above solution. This is the most intuitive solution I could come up on my first attempt. The default test cases passes but it times out using [1000000000] ,lower=0, upper=1000000000. I believe the time complexity of the above code is O(n) with constant space of the Set being used. Wondering what is that I\\'m doing wrong. Thanks in advance."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Too many edge cases! Frustrating for each test case...!"
                    }
                ]
            },
            {
                "id": 1929843,
                "content": [
                    {
                        "username": "v_suresh",
                        "content": "Unfortunately, One of the most frustrating experiences was with this question! \\n"
                    },
                    {
                        "username": "nikonok",
                        "content": "Because of corner cases looks like not \"easy\" =("
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Do not naively loop from lower to upper. O(n) can be achieved by looping over nums instead."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases make this obnoxious."
                    },
                    {
                        "username": "BubbleTree",
                        "content": "so many edge cases lol"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Why are there so many dislikes, is it because there are few edge cases or? I think the problem statement and constraints are clearly defined."
                    },
                    {
                        "username": "lpaben62",
                        "content": "Pay attention to the constraints, especially on the fact that \"lower <= nums[i] <= upper\". As opposed to number of dislikes may suggest, this problem is actually a good practices for you to pay attention to some of the nuances!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This used to ask for a return of []string."
                    },
                    {
                        "username": "saurabh_biswas",
                        "content": " `\\n\\n    public List<String> findMissingRanges(int[] nums, int lower, int upper) {\\n        Set<Integer> set = new HashSet<>();\\n        List<String> results = new ArrayList<>();\\n        for(int num: nums) set.add(num);\\n        for(int i=lower; i <=upper; i++){\\n            if(!set.contains(i)){\\n                StringBuilder sb = new StringBuilder();\\n                int start = i;\\n                int j=0;\\n                while(!set.contains(i+j) && i+j <= upper) j++;\\n                int end = i+j-1;\\n                i = end;\\n                if(start == end) sb.append(start);\\n                else sb.append(start).append(\"->\").append(end);\\n                results.add(sb.toString());\\n            }\\n        }\\n        return results;\\n    }\\n\\n`\\nHi need some feedback on my above solution. This is the most intuitive solution I could come up on my first attempt. The default test cases passes but it times out using [1000000000] ,lower=0, upper=1000000000. I believe the time complexity of the above code is O(n) with constant space of the Set being used. Wondering what is that I\\'m doing wrong. Thanks in advance."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Too many edge cases! Frustrating for each test case...!"
                    }
                ]
            },
            {
                "id": 1893062,
                "content": [
                    {
                        "username": "v_suresh",
                        "content": "Unfortunately, One of the most frustrating experiences was with this question! \\n"
                    },
                    {
                        "username": "nikonok",
                        "content": "Because of corner cases looks like not \"easy\" =("
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Do not naively loop from lower to upper. O(n) can be achieved by looping over nums instead."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases make this obnoxious."
                    },
                    {
                        "username": "BubbleTree",
                        "content": "so many edge cases lol"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Why are there so many dislikes, is it because there are few edge cases or? I think the problem statement and constraints are clearly defined."
                    },
                    {
                        "username": "lpaben62",
                        "content": "Pay attention to the constraints, especially on the fact that \"lower <= nums[i] <= upper\". As opposed to number of dislikes may suggest, this problem is actually a good practices for you to pay attention to some of the nuances!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This used to ask for a return of []string."
                    },
                    {
                        "username": "saurabh_biswas",
                        "content": " `\\n\\n    public List<String> findMissingRanges(int[] nums, int lower, int upper) {\\n        Set<Integer> set = new HashSet<>();\\n        List<String> results = new ArrayList<>();\\n        for(int num: nums) set.add(num);\\n        for(int i=lower; i <=upper; i++){\\n            if(!set.contains(i)){\\n                StringBuilder sb = new StringBuilder();\\n                int start = i;\\n                int j=0;\\n                while(!set.contains(i+j) && i+j <= upper) j++;\\n                int end = i+j-1;\\n                i = end;\\n                if(start == end) sb.append(start);\\n                else sb.append(start).append(\"->\").append(end);\\n                results.add(sb.toString());\\n            }\\n        }\\n        return results;\\n    }\\n\\n`\\nHi need some feedback on my above solution. This is the most intuitive solution I could come up on my first attempt. The default test cases passes but it times out using [1000000000] ,lower=0, upper=1000000000. I believe the time complexity of the above code is O(n) with constant space of the Set being used. Wondering what is that I\\'m doing wrong. Thanks in advance."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Too many edge cases! Frustrating for each test case...!"
                    }
                ]
            },
            {
                "id": 2039675,
                "content": [
                    {
                        "username": "v_suresh",
                        "content": "Unfortunately, One of the most frustrating experiences was with this question! \\n"
                    },
                    {
                        "username": "nikonok",
                        "content": "Because of corner cases looks like not \"easy\" =("
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Do not naively loop from lower to upper. O(n) can be achieved by looping over nums instead."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases make this obnoxious."
                    },
                    {
                        "username": "BubbleTree",
                        "content": "so many edge cases lol"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Why are there so many dislikes, is it because there are few edge cases or? I think the problem statement and constraints are clearly defined."
                    },
                    {
                        "username": "lpaben62",
                        "content": "Pay attention to the constraints, especially on the fact that \"lower <= nums[i] <= upper\". As opposed to number of dislikes may suggest, this problem is actually a good practices for you to pay attention to some of the nuances!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This used to ask for a return of []string."
                    },
                    {
                        "username": "saurabh_biswas",
                        "content": " `\\n\\n    public List<String> findMissingRanges(int[] nums, int lower, int upper) {\\n        Set<Integer> set = new HashSet<>();\\n        List<String> results = new ArrayList<>();\\n        for(int num: nums) set.add(num);\\n        for(int i=lower; i <=upper; i++){\\n            if(!set.contains(i)){\\n                StringBuilder sb = new StringBuilder();\\n                int start = i;\\n                int j=0;\\n                while(!set.contains(i+j) && i+j <= upper) j++;\\n                int end = i+j-1;\\n                i = end;\\n                if(start == end) sb.append(start);\\n                else sb.append(start).append(\"->\").append(end);\\n                results.add(sb.toString());\\n            }\\n        }\\n        return results;\\n    }\\n\\n`\\nHi need some feedback on my above solution. This is the most intuitive solution I could come up on my first attempt. The default test cases passes but it times out using [1000000000] ,lower=0, upper=1000000000. I believe the time complexity of the above code is O(n) with constant space of the Set being used. Wondering what is that I\\'m doing wrong. Thanks in advance."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Too many edge cases! Frustrating for each test case...!"
                    }
                ]
            },
            {
                "id": 2037904,
                "content": [
                    {
                        "username": "v_suresh",
                        "content": "Unfortunately, One of the most frustrating experiences was with this question! \\n"
                    },
                    {
                        "username": "nikonok",
                        "content": "Because of corner cases looks like not \"easy\" =("
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Do not naively loop from lower to upper. O(n) can be achieved by looping over nums instead."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases make this obnoxious."
                    },
                    {
                        "username": "BubbleTree",
                        "content": "so many edge cases lol"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Why are there so many dislikes, is it because there are few edge cases or? I think the problem statement and constraints are clearly defined."
                    },
                    {
                        "username": "lpaben62",
                        "content": "Pay attention to the constraints, especially on the fact that \"lower <= nums[i] <= upper\". As opposed to number of dislikes may suggest, this problem is actually a good practices for you to pay attention to some of the nuances!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This used to ask for a return of []string."
                    },
                    {
                        "username": "saurabh_biswas",
                        "content": " `\\n\\n    public List<String> findMissingRanges(int[] nums, int lower, int upper) {\\n        Set<Integer> set = new HashSet<>();\\n        List<String> results = new ArrayList<>();\\n        for(int num: nums) set.add(num);\\n        for(int i=lower; i <=upper; i++){\\n            if(!set.contains(i)){\\n                StringBuilder sb = new StringBuilder();\\n                int start = i;\\n                int j=0;\\n                while(!set.contains(i+j) && i+j <= upper) j++;\\n                int end = i+j-1;\\n                i = end;\\n                if(start == end) sb.append(start);\\n                else sb.append(start).append(\"->\").append(end);\\n                results.add(sb.toString());\\n            }\\n        }\\n        return results;\\n    }\\n\\n`\\nHi need some feedback on my above solution. This is the most intuitive solution I could come up on my first attempt. The default test cases passes but it times out using [1000000000] ,lower=0, upper=1000000000. I believe the time complexity of the above code is O(n) with constant space of the Set being used. Wondering what is that I\\'m doing wrong. Thanks in advance."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Too many edge cases! Frustrating for each test case...!"
                    }
                ]
            },
            {
                "id": 1986957,
                "content": [
                    {
                        "username": "v_suresh",
                        "content": "Unfortunately, One of the most frustrating experiences was with this question! \\n"
                    },
                    {
                        "username": "nikonok",
                        "content": "Because of corner cases looks like not \"easy\" =("
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Do not naively loop from lower to upper. O(n) can be achieved by looping over nums instead."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases make this obnoxious."
                    },
                    {
                        "username": "BubbleTree",
                        "content": "so many edge cases lol"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Why are there so many dislikes, is it because there are few edge cases or? I think the problem statement and constraints are clearly defined."
                    },
                    {
                        "username": "lpaben62",
                        "content": "Pay attention to the constraints, especially on the fact that \"lower <= nums[i] <= upper\". As opposed to number of dislikes may suggest, this problem is actually a good practices for you to pay attention to some of the nuances!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This used to ask for a return of []string."
                    },
                    {
                        "username": "saurabh_biswas",
                        "content": " `\\n\\n    public List<String> findMissingRanges(int[] nums, int lower, int upper) {\\n        Set<Integer> set = new HashSet<>();\\n        List<String> results = new ArrayList<>();\\n        for(int num: nums) set.add(num);\\n        for(int i=lower; i <=upper; i++){\\n            if(!set.contains(i)){\\n                StringBuilder sb = new StringBuilder();\\n                int start = i;\\n                int j=0;\\n                while(!set.contains(i+j) && i+j <= upper) j++;\\n                int end = i+j-1;\\n                i = end;\\n                if(start == end) sb.append(start);\\n                else sb.append(start).append(\"->\").append(end);\\n                results.add(sb.toString());\\n            }\\n        }\\n        return results;\\n    }\\n\\n`\\nHi need some feedback on my above solution. This is the most intuitive solution I could come up on my first attempt. The default test cases passes but it times out using [1000000000] ,lower=0, upper=1000000000. I believe the time complexity of the above code is O(n) with constant space of the Set being used. Wondering what is that I\\'m doing wrong. Thanks in advance."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Too many edge cases! Frustrating for each test case...!"
                    }
                ]
            },
            {
                "id": 1929880,
                "content": [
                    {
                        "username": "v_suresh",
                        "content": "Unfortunately, One of the most frustrating experiences was with this question! \\n"
                    },
                    {
                        "username": "nikonok",
                        "content": "Because of corner cases looks like not \"easy\" =("
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Do not naively loop from lower to upper. O(n) can be achieved by looping over nums instead."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases make this obnoxious."
                    },
                    {
                        "username": "BubbleTree",
                        "content": "so many edge cases lol"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Why are there so many dislikes, is it because there are few edge cases or? I think the problem statement and constraints are clearly defined."
                    },
                    {
                        "username": "lpaben62",
                        "content": "Pay attention to the constraints, especially on the fact that \"lower <= nums[i] <= upper\". As opposed to number of dislikes may suggest, this problem is actually a good practices for you to pay attention to some of the nuances!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This used to ask for a return of []string."
                    },
                    {
                        "username": "saurabh_biswas",
                        "content": " `\\n\\n    public List<String> findMissingRanges(int[] nums, int lower, int upper) {\\n        Set<Integer> set = new HashSet<>();\\n        List<String> results = new ArrayList<>();\\n        for(int num: nums) set.add(num);\\n        for(int i=lower; i <=upper; i++){\\n            if(!set.contains(i)){\\n                StringBuilder sb = new StringBuilder();\\n                int start = i;\\n                int j=0;\\n                while(!set.contains(i+j) && i+j <= upper) j++;\\n                int end = i+j-1;\\n                i = end;\\n                if(start == end) sb.append(start);\\n                else sb.append(start).append(\"->\").append(end);\\n                results.add(sb.toString());\\n            }\\n        }\\n        return results;\\n    }\\n\\n`\\nHi need some feedback on my above solution. This is the most intuitive solution I could come up on my first attempt. The default test cases passes but it times out using [1000000000] ,lower=0, upper=1000000000. I believe the time complexity of the above code is O(n) with constant space of the Set being used. Wondering what is that I\\'m doing wrong. Thanks in advance."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Too many edge cases! Frustrating for each test case...!"
                    }
                ]
            },
            {
                "id": 1759808,
                "content": [
                    {
                        "username": "v_suresh",
                        "content": "Unfortunately, One of the most frustrating experiences was with this question! \\n"
                    },
                    {
                        "username": "nikonok",
                        "content": "Because of corner cases looks like not \"easy\" =("
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Do not naively loop from lower to upper. O(n) can be achieved by looping over nums instead."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases make this obnoxious."
                    },
                    {
                        "username": "BubbleTree",
                        "content": "so many edge cases lol"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Why are there so many dislikes, is it because there are few edge cases or? I think the problem statement and constraints are clearly defined."
                    },
                    {
                        "username": "lpaben62",
                        "content": "Pay attention to the constraints, especially on the fact that \"lower <= nums[i] <= upper\". As opposed to number of dislikes may suggest, this problem is actually a good practices for you to pay attention to some of the nuances!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This used to ask for a return of []string."
                    },
                    {
                        "username": "saurabh_biswas",
                        "content": " `\\n\\n    public List<String> findMissingRanges(int[] nums, int lower, int upper) {\\n        Set<Integer> set = new HashSet<>();\\n        List<String> results = new ArrayList<>();\\n        for(int num: nums) set.add(num);\\n        for(int i=lower; i <=upper; i++){\\n            if(!set.contains(i)){\\n                StringBuilder sb = new StringBuilder();\\n                int start = i;\\n                int j=0;\\n                while(!set.contains(i+j) && i+j <= upper) j++;\\n                int end = i+j-1;\\n                i = end;\\n                if(start == end) sb.append(start);\\n                else sb.append(start).append(\"->\").append(end);\\n                results.add(sb.toString());\\n            }\\n        }\\n        return results;\\n    }\\n\\n`\\nHi need some feedback on my above solution. This is the most intuitive solution I could come up on my first attempt. The default test cases passes but it times out using [1000000000] ,lower=0, upper=1000000000. I believe the time complexity of the above code is O(n) with constant space of the Set being used. Wondering what is that I\\'m doing wrong. Thanks in advance."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Too many edge cases! Frustrating for each test case...!"
                    }
                ]
            },
            {
                "id": 1729557,
                "content": [
                    {
                        "username": "v_suresh",
                        "content": "Unfortunately, One of the most frustrating experiences was with this question! \\n"
                    },
                    {
                        "username": "nikonok",
                        "content": "Because of corner cases looks like not \"easy\" =("
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Do not naively loop from lower to upper. O(n) can be achieved by looping over nums instead."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases make this obnoxious."
                    },
                    {
                        "username": "BubbleTree",
                        "content": "so many edge cases lol"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Why are there so many dislikes, is it because there are few edge cases or? I think the problem statement and constraints are clearly defined."
                    },
                    {
                        "username": "lpaben62",
                        "content": "Pay attention to the constraints, especially on the fact that \"lower <= nums[i] <= upper\". As opposed to number of dislikes may suggest, this problem is actually a good practices for you to pay attention to some of the nuances!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This used to ask for a return of []string."
                    },
                    {
                        "username": "saurabh_biswas",
                        "content": " `\\n\\n    public List<String> findMissingRanges(int[] nums, int lower, int upper) {\\n        Set<Integer> set = new HashSet<>();\\n        List<String> results = new ArrayList<>();\\n        for(int num: nums) set.add(num);\\n        for(int i=lower; i <=upper; i++){\\n            if(!set.contains(i)){\\n                StringBuilder sb = new StringBuilder();\\n                int start = i;\\n                int j=0;\\n                while(!set.contains(i+j) && i+j <= upper) j++;\\n                int end = i+j-1;\\n                i = end;\\n                if(start == end) sb.append(start);\\n                else sb.append(start).append(\"->\").append(end);\\n                results.add(sb.toString());\\n            }\\n        }\\n        return results;\\n    }\\n\\n`\\nHi need some feedback on my above solution. This is the most intuitive solution I could come up on my first attempt. The default test cases passes but it times out using [1000000000] ,lower=0, upper=1000000000. I believe the time complexity of the above code is O(n) with constant space of the Set being used. Wondering what is that I\\'m doing wrong. Thanks in advance."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Too many edge cases! Frustrating for each test case...!"
                    }
                ]
            }
        ]
    },
    {
        "title": "Split Array into Consecutive Subsequences",
        "question_content": "<p>You are given an integer array <code>nums</code> that is <strong>sorted in non-decreasing order</strong>.</p>\n\n<p>Determine if it is possible to split <code>nums</code> into <strong>one or more subsequences</strong> such that <strong>both</strong> of the following conditions are true:</p>\n\n<ul>\n\t<li>Each subsequence is a <strong>consecutive increasing sequence</strong> (i.e. each integer is <strong>exactly one</strong> more than the previous integer).</li>\n\t<li>All subsequences have a length of <code>3</code><strong> or more</strong>.</li>\n</ul>\n\n<p>Return <code>true</code><em> if you can split </em><code>nums</code><em> according to the above conditions, or </em><code>false</code><em> otherwise</em>.</p>\n\n<p>A <strong>subsequence</strong> of an array is a new array that is formed from the original array by deleting some (can be none) of the elements without disturbing the relative positions of the remaining elements. (i.e., <code>[1,3,5]</code> is a subsequence of <code>[<u>1</u>,2,<u>3</u>,4,<u>5</u>]</code> while <code>[1,3,2]</code> is not).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,3,4,5]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> nums can be split into the following subsequences:\n[<strong><u>1</u></strong>,<strong><u>2</u></strong>,<strong><u>3</u></strong>,3,4,5] --&gt; 1, 2, 3\n[1,2,3,<strong><u>3</u></strong>,<strong><u>4</u></strong>,<strong><u>5</u></strong>] --&gt; 3, 4, 5\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,3,4,4,5,5]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> nums can be split into the following subsequences:\n[<strong><u>1</u></strong>,<strong><u>2</u></strong>,<strong><u>3</u></strong>,3,<strong><u>4</u></strong>,4,<strong><u>5</u></strong>,5] --&gt; 1, 2, 3, 4, 5\n[1,2,3,<strong><u>3</u></strong>,4,<strong><u>4</u></strong>,5,<strong><u>5</u></strong>] --&gt; 3, 4, 5\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4,4,5]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> It is impossible to split nums into consecutive increasing subsequences of length 3 or more.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>nums</code> is sorted in <strong>non-decreasing</strong> order.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 106514,
                "title": "c-python-esay-understand-solution",
                "content": "# Explanation\\nI used a greedy algorithm.\\n ```left```is a hashmap, ```left[i]``` counts the number of ``` i ``` that I haven\\'t placed yet.\\n ```end ```is a hashmap, ```end[i]``` counts the number of  consecutive subsequences that ends at number ```i```\\nThen I tried to split the nums one by one.\\nIf I could neither add a number to the end of a existing consecutive subsequence nor find two following number in the left, I returned ```False```\\n<br>\\n\\n# Complexity\\nTime `O(N)`\\nSpace `O(N)`\\n<br>\\n\\n**C++**\\n```cpp\\n    bool isPossible(vector<int>& A) {\\n        unordered_map<int, int> left, end;\\n        for (int i: A) {\\n            left[i]++;\\n        }\\n        for (int i: A) {\\n            if (left[i] == 0) continue;\\n            left[i]--;\\n            if (end[i - 1] > 0) {   \\n                end[i - 1]--;\\n                end[i]++;\\n            } else if (left[i + 1] > 0 && left[i + 2] > 0) {\\n                left[i + 1]--;\\n                left[i + 2]--;\\n                end[i + 2]++;\\n            } else {   \\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```\\n**Python**\\n````py\\n    def isPossible(self, A):\\n        left = collections.Counter(A)\\n        end = collections.Counter()\\n        for i in A:\\n            if not left[i]: continue\\n            left[i] -= 1\\n            if end[i - 1] > 0:\\n                end[i - 1] -= 1\\n                end[i] += 1\\n            elif left[i + 1] and left[i + 2]:\\n                left[i + 1] -= 1\\n                left[i + 2] -= 1\\n                end[i + 2] += 1\\n            else:\\n                return False\\n        return True",
                "solutionTags": [],
                "code": "```left```\n```left[i]```\n``` i ```\n```end ```\n```end[i]```\n```i```\n```False```\n```cpp\\n    bool isPossible(vector<int>& A) {\\n        unordered_map<int, int> left, end;\\n        for (int i: A) {\\n            left[i]++;\\n        }\\n        for (int i: A) {\\n            if (left[i] == 0) continue;\\n            left[i]--;\\n            if (end[i - 1] > 0) {   \\n                end[i - 1]--;\\n                end[i]++;\\n            } else if (left[i + 1] > 0 && left[i + 2] > 0) {\\n                left[i + 1]--;\\n                left[i + 2]--;\\n                end[i + 2]++;\\n            } else {   \\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 106495,
                "title": "java-o-n-time-o-1-space-solution-greedily-extending-shorter-subsequence",
                "content": "The basic idea is that, for each distinct element `ele` in the input array, we only need to maintain three pieces of information: the number of consecutive subsequences ending at `ele` with length  of `1`, length of `2` and length `>= 3`.\\n\\nThe input array will be scanned linearly from left to right. Let `cur` be the element currently being examined and `cnt` as its number of appearance. `pre` is the element processed immediately before `cur`. The number of consecutive subsequences ending at `pre` with length  of `1`, length of `2` and length `>= 3` are denoted as `p1`, `p2` and `p3`, respectively. There are two cases in general:\\n\\n1. `cur != pre + 1`: for this case, `cur` cannot be added to any consecutive subsequences ending at `pre`, therefore, we must have `p1 == 0 && p2 == 0`; otherwise the input array cannot be split into consecutive subsequences of length `>= 3`. Now let `c1, c2, c3` be the number of consecutive subsequences ending at `cur` with length  of `1`, length of `2` and length `>= 3`, respectively, we will have `c1 = cnt, c2 = 0, c3 = 0`, which means we only have consecutive subsequence ending at `cur` with length of `1` and its number given by `cnt`.\\n\\n2. `cur == pre + 1`: for this case, `cur` can be added to consecutive subsequences ending at `pre` and thus extend those subsequences. But priorities should be given to those with length of `1` first, then length of `2` and lastly length `>= 3`. Also we must have `cnt >= p1 + p2`; otherwise the input array cannot be split into consecutive subsequences of length `>= 3`. Again let `c1, c2, c3` be the number of consecutive subsequences ending at `cur` with length  of `1`, length of `2` and length `>= 3`, respectively, we will have: `c2 = p1, c3 = p2 + min(p3, cnt - (p1 + p2)), c1 = max(cnt - (p1 + p2 + p3), 0)`. The meaning is as follows: first adding `cur` to the end of subsequences of length `1` will make them subsequences of length `2`, and we have `p1` such subsequences, therefore `c2 = p1`. Then adding `cur` to the end of subsequences of length `2` will make them subsequences of length `3`, and we have `p2` such subsequences, therefore `c3` is at least `p2`. If `cnt > p1 + p2`, we can add the remaining `cur` to the end of subsequences of length  `>= 3` to make them even longer subsequences. The number of such subsequences is the smaller one of `p3` and `cnt - (p1 + p2)`. In total, `c3 = p2 + min(p3, cnt - (p1 + p2))`. If `cnt > p1 + p2 + p3`, then we still have remaining `cur` that cannot be added to any subsequences. These residual `cur` will form subsequences of length `1`, hence `c1 = max(cnt - (p1 + p2 + p3), 0)`. \\n\\nFor either case, we need to update: `pre = cur, p1 = c1, p2 = c2, p3 = c3` after processing the current element. When all the elements are done, we check the values of `p1` and `p2`. The input array can be split into consecutive subsequences of length `>= 3` if and only if `p1 == 0 && p2 == 0`.\\n\\nHere is the `O(n)` time and `O(1)` space Java solution:\\n\\n```\\npublic boolean isPossible(int[] nums) {\\n    int pre = Integer.MIN_VALUE;\\n\\tint p1 = 0;\\n\\tint p2 = 0;\\n\\tint p3 = 0;\\n\\t\\n    int cur = 0;\\n\\tint cnt = 0;\\n\\tint c1 = 0;\\n\\tint c2 = 0;\\n\\tint c3 = 0;\\n        \\n    for (int i = 0; i < nums.length; pre = cur, p1 = c1, p2 = c2, p3 = c3) {\\n        for (cur = nums[i], cnt = 0; i < nums.length && cur == nums[i]; i++) {\\n\\t\\t\\tcnt++;\\n\\t\\t}\\n        \\n        if (cur != pre + 1) {\\n            if (p1 != 0 || p2 != 0) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\t\\n            c1 = cnt;\\n\\t\\t\\tc2 = 0;\\n\\t\\t\\tc3 = 0;\\n            \\n        } else {\\n            if (cnt < p1 + p2) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\t\\n            c1 = Math.max(0, cnt - (p1 + p2 + p3));\\n            c2 = p1;\\n            c3 = p2 + Math.min(p3, cnt - (p1 + p2));\\n        }\\n    }\\n    \\n    return (p1 == 0 && p2 == 0);\\n}\\n```\\n\\n<br>\\n\\n---\\n\\n**PS:** in case you\\'re curious, here is how I come up with this solution.\\n\\nFirst note that if the array can be split into consecutive subsequences of length `>= 3`, then every element in the array must belong to such a subsequence of length `>= 3`. So let\\'s take any integer `m` in the array as an example. Apparently you can only add it to consecutive subsequences ending at `m - 1`. This tells you that we need information about consecutive subsequences ending at `m - 1`. But what kind of information about those subsequences are relevant here? \\n\\nThink about what distinguishes one subsequence from another. Since all the subsequences are ending at `m - 1`, they can only differ by length, i.e., each subsequence will be uniquely identified by its length. Now what if two subsequences have the same length? This suggests that we also need to keep track of the number of appearance of each length. Therefore in summary, we need to maintain information of subsequences ending at `m - 1` with various lengths and their corresponding number of appearance.\\n\\nOf course I know we cannot keep track of all lengths, as this would require an infinite amount of memory. So the next question is to ponder more carefully the role that the length of each subsequence is playing here. From the point view of `m - 1`, we care more about subsequences of length `1` and `2`. Since if there are no other elements that can extend these subsequences, we know the input array cannot be split into consecutive subsequences of length `>= 3`. On the other hand, we don\\'t really care about subsequences of length `>= 3`, since they already meet the required condition. So I conclude that for subsequences ending at `m - 1`, there are really only three types of length information needed: those of length `1`,  of length `2` and of length `>= 3`. \\n\\nOnce I figure this out, the next thing is to extend the conclusion to subsequences ending at `m`, so we can have a working recurrence relation. The key here is how we add `m` to those subsequences ending at `m - 1`. As I mentioned above, priorities should be given to those of length `1` and `2`, since if these subsequences cannot be extended, the input array cannot be split into consecutive subsequences of length `>= 3`. After those subsequences are extended, if we have more elements of `m`, they can be used to extend subsequences ending at `m - 1` with length `>= 3`. At last, if we still have elements of `m`, then they will form subsequences of length `1` since there are no more subsequences ending at `m - 1` available for them. Therefore for subsequences ending at `m`, we still just need subsequences of length `1`, length `2` and length `>= 3`. We can continue in this fashion until all elements are processed, at which point we need to check the number of subsequences of length `1` and `2` that ends at the last element of the input array to see if the input array can be split into consecutive subsequences of length `>= 3` (since these subsequences cannot be extended any longer as there are no more elements).\\n\\nHope this helps!",
                "solutionTags": [],
                "code": "```\\npublic boolean isPossible(int[] nums) {\\n    int pre = Integer.MIN_VALUE;\\n\\tint p1 = 0;\\n\\tint p2 = 0;\\n\\tint p3 = 0;\\n\\t\\n    int cur = 0;\\n\\tint cnt = 0;\\n\\tint c1 = 0;\\n\\tint c2 = 0;\\n\\tint c3 = 0;\\n        \\n    for (int i = 0; i < nums.length; pre = cur, p1 = c1, p2 = c2, p3 = c3) {\\n        for (cur = nums[i], cnt = 0; i < nums.length && cur == nums[i]; i++) {\\n\\t\\t\\tcnt++;\\n\\t\\t}\\n        \\n        if (cur != pre + 1) {\\n            if (p1 != 0 || p2 != 0) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\t\\n            c1 = cnt;\\n\\t\\t\\tc2 = 0;\\n\\t\\t\\tc3 = 0;\\n            \\n        } else {\\n            if (cnt < p1 + p2) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\t\\n            c1 = Math.max(0, cnt - (p1 + p2 + p3));\\n            c2 = p1;\\n            c3 = p2 + Math.min(p3, cnt - (p1 + p2));\\n        }\\n    }\\n    \\n    return (p1 == 0 && p2 == 0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 106496,
                "title": "java-o-n-time-o-n-space",
                "content": "1) We iterate through the array once to get the frequency of all the elements in the array\\n2) We iterate through the array once more and for each element we either see if it can be appended to a previously constructed consecutive sequence or if it can be the start of a new consecutive sequence. If neither are true, then we return false.\\n\\n\\n```\\npublic boolean isPossible(int[] nums) {\\n    Map<Integer, Integer> freq = new HashMap<>(), appendfreq = new HashMap<>();\\n    for (int i : nums) freq.put(i, freq.getOrDefault(i,0) + 1);\\n    for (int i : nums) {\\n        if (freq.get(i) == 0) continue;\\n        else if (appendfreq.getOrDefault(i,0) > 0) {\\n            appendfreq.put(i, appendfreq.get(i) - 1);\\n            appendfreq.put(i+1, appendfreq.getOrDefault(i+1,0) + 1);\\n        }   \\n        else if (freq.getOrDefault(i+1,0) > 0 && freq.getOrDefault(i+2,0) > 0) {\\n            freq.put(i+1, freq.get(i+1) - 1);\\n            freq.put(i+2, freq.get(i+2) - 1);\\n            appendfreq.put(i+3, appendfreq.getOrDefault(i+3,0) + 1);\\n        }\\n        else return false;\\n        freq.put(i, freq.get(i) - 1);\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isPossible(int[] nums) {\\n    Map<Integer, Integer> freq = new HashMap<>(), appendfreq = new HashMap<>();\\n    for (int i : nums) freq.put(i, freq.getOrDefault(i,0) + 1);\\n    for (int i : nums) {\\n        if (freq.get(i) == 0) continue;\\n        else if (appendfreq.getOrDefault(i,0) > 0) {\\n            appendfreq.put(i, appendfreq.get(i) - 1);\\n            appendfreq.put(i+1, appendfreq.getOrDefault(i+1,0) + 1);\\n        }   \\n        else if (freq.getOrDefault(i+1,0) > 0 && freq.getOrDefault(i+2,0) > 0) {\\n            freq.put(i+1, freq.get(i+1) - 1);\\n            freq.put(i+2, freq.get(i+2) - 1);\\n            appendfreq.put(i+3, appendfreq.getOrDefault(i+3,0) + 1);\\n        }\\n        else return false;\\n        freq.put(i, freq.get(i) - 1);\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 844738,
                "title": "java-very-easy-explanation-through-a-story-time-o-n-space-o-n",
                "content": "**Consider this hypothetical story to better understand this question : [After reading this you will understand the code like a breeze. I hope you enjoy the story!]**\\n\\n1. Consider the numbers in the nums array are actual persons that are looking for a job. If they are available, they try to find a job. If no one wants them they go on to start their own company. But, here is the twist, a new company can be started only if it can have atleast 3 persons available. ( Are you thinking why 3? => Read the question description again.)\\n\\n2. The most important thing to note here is that each person in num, first tries to look for a job and if he/she does not gets success, he/she starts a company with 3 consecutive members. [as we want to find subsequences with consecutive numbers of length atleast 3. Think a subsequence as a company for now]\\n\\n3. So, let\\'s come to our first scenario - A person `(let\\'s say x)` looks for a job and finds it. YAY!! So, this person joins an already existing company and then he/she creates a vacancy for another person `x+1` in the job search section, so that another one like him/her do not have to face any struggle like he/she faced. He/She is a good guy/girl. No?\\n\\n4. Now, let\\'s come to our second possibility of our story. The guy/girl was not able to find a job :( \\nBUT, he/she `(let\\'s say x)` was very ambitious. So he/she decides- \\'Let\\'s build a company with me (that is x), x+1 and x+2\\'. So he/she checks with (x+1) and (x+2), if they are available to build a company as it requires 3 persons to start a company. \\n\\nHere comes two scenario:\\n\\na. x finds both the potential teammates/partners, `(x+1)` & `(x+2)` to be available so, they go on to start a new company and then after finding their own company, as a goodwill they create a new job vacancy looking for `(x+3)` so that `(x+3)` do not face any struggle they faced. People are good, believe me :) \\n\\nb. x was just out of luck, he/she was able to find their teammates i.e. (x+1) & (x+2). In this case have hope and just return false to quickly complete the program execution (BACK TO REALITY :p )\\n\\n\\n**Here is the code [If you haven\\'t read the story above, please read it to understand the solution] :**\\n\\n```\\n// This is a greedy approach. The whole idea is to first look for an existing group\\n// to join for the current num. If no, then create a new group. \\n// Here a group means group of 3 or more numbers as mentioned in question description. \\n\\n//Well, If u didn\\'t understand, keep the above story of company in mind and try to understand the code below through comments, you will be fine.\\n\\nclass Solution {\\n    public boolean isPossible(int[] nums) {\\n        // This hashmap tells us about whether a number in num is available for a job or not\\n        HashMap<Integer,Integer> avaibilityMap = new HashMap<>();\\n        \\n        // This hashmap tells a number (say x), if there is a job vacancy for them\\n        HashMap<Integer,Integer> wantMap = new HashMap<>();\\n        \\n        // We store the count of every num in nums into avaibilityMap. Basically, a number\\'s count is the avaibility of it.\\n        for(int i : nums){\\n            avaibilityMap.put(i, avaibilityMap.getOrDefault(i,0)+1);\\n        }\\n        \\n        // We iterate through each number in the nums array. Remember the story ? So, treat them like a person.\\n        for(int i=0;i<nums.length;i++){\\n            // First we check if our current num/person is available. If it is not we just continue with next num/person\\n            if(avaibilityMap.get(nums[i])<=0){\\n                continue;\\n            }\\n            \\n            // If the person is available, first we check if there is a job vacancy for him/her. Basically, is someone looking for him/her?\\n            else if(wantMap.getOrDefault(nums[i],0)>0){\\n                // Yes, someone is looking, so we decrease the avaibility count of that number\\n                avaibilityMap.put(nums[i], avaibilityMap.getOrDefault(nums[i],0)-1);\\n                \\n                // we also decrease its count from the job vacancy space / wantMap\\n                wantMap.put(nums[i], wantMap.getOrDefault(nums[i],0)-1);\\n                \\n                // Then as a goodwill, he/she will also create a job vacancy for (num[i]+1) in job vacancy space / wantMap, as we need consecutive numbers only\\n                wantMap.put(nums[i]+1, wantMap.getOrDefault(nums[i]+1,0)+1);\\n            }\\n            \\n            // Ooh, we are here means nums[i] was not able to find a job.\\n            // so, nums[i] tries to start his/her own company by checking avaibility of his/her friends i.e. (nums[i]+1) and (nums[i]+2)\\n            else if(avaibilityMap.getOrDefault(nums[i],0)>0 && avaibilityMap.getOrDefault(nums[i]+1,0)>0 && avaibilityMap.getOrDefault(nums[i]+2,0)>0){\\n                \\n                // Yay! both 2 friends are available. Let\\'s start a company.\\n                // So we decrease the avaibility count of nums[i], (nums[i]+1) and (nums[i]+2) from the \\n                // avaibilityMap\\n                avaibilityMap.put(nums[i], avaibilityMap.getOrDefault(nums[i],0)-1);\\n                avaibilityMap.put(nums[i]+1, avaibilityMap.getOrDefault(nums[i]+1,0)-1);\\n                avaibilityMap.put(nums[i]+2, avaibilityMap.getOrDefault(nums[i]+2,0)-1);\\n                \\n                // Also, as a goodwill, we create a new job vacancy for (nums[i]+3), as we need consecutive numbers only\\n                wantMap.put(nums[i]+3, wantMap.getOrDefault(nums[i]+3,0)+1);\\n            }\\n            \\n            // Bad luck case, nums[i] not able to start his/her company, so just return false\\n            else{\\n                return false;\\n            }\\n        }\\n        \\n        // All good till here so we return true\\n        return true;\\n    }\\n}\\n```\\n\\n\\n***Again to reiterate the logic :\\nThe logic is to just apply a greedy approach and try to find a group of 3 consecutive numbers first and then for other numbers try to check if existing groups can be used or it is neccessary to create a new group.***\\n\\n**Hope you enjoyed the story and if you liked it please upvote.Thanks!**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// This is a greedy approach. The whole idea is to first look for an existing group\\n// to join for the current num. If no, then create a new group. \\n// Here a group means group of 3 or more numbers as mentioned in question description. \\n\\n//Well, If u didn\\'t understand, keep the above story of company in mind and try to understand the code below through comments, you will be fine.\\n\\nclass Solution {\\n    public boolean isPossible(int[] nums) {\\n        // This hashmap tells us about whether a number in num is available for a job or not\\n        HashMap<Integer,Integer> avaibilityMap = new HashMap<>();\\n        \\n        // This hashmap tells a number (say x), if there is a job vacancy for them\\n        HashMap<Integer,Integer> wantMap = new HashMap<>();\\n        \\n        // We store the count of every num in nums into avaibilityMap. Basically, a number\\'s count is the avaibility of it.\\n        for(int i : nums){\\n            avaibilityMap.put(i, avaibilityMap.getOrDefault(i,0)+1);\\n        }\\n        \\n        // We iterate through each number in the nums array. Remember the story ? So, treat them like a person.\\n        for(int i=0;i<nums.length;i++){\\n            // First we check if our current num/person is available. If it is not we just continue with next num/person\\n            if(avaibilityMap.get(nums[i])<=0){\\n                continue;\\n            }\\n            \\n            // If the person is available, first we check if there is a job vacancy for him/her. Basically, is someone looking for him/her?\\n            else if(wantMap.getOrDefault(nums[i],0)>0){\\n                // Yes, someone is looking, so we decrease the avaibility count of that number\\n                avaibilityMap.put(nums[i], avaibilityMap.getOrDefault(nums[i],0)-1);\\n                \\n                // we also decrease its count from the job vacancy space / wantMap\\n                wantMap.put(nums[i], wantMap.getOrDefault(nums[i],0)-1);\\n                \\n                // Then as a goodwill, he/she will also create a job vacancy for (num[i]+1) in job vacancy space / wantMap, as we need consecutive numbers only\\n                wantMap.put(nums[i]+1, wantMap.getOrDefault(nums[i]+1,0)+1);\\n            }\\n            \\n            // Ooh, we are here means nums[i] was not able to find a job.\\n            // so, nums[i] tries to start his/her own company by checking avaibility of his/her friends i.e. (nums[i]+1) and (nums[i]+2)\\n            else if(avaibilityMap.getOrDefault(nums[i],0)>0 && avaibilityMap.getOrDefault(nums[i]+1,0)>0 && avaibilityMap.getOrDefault(nums[i]+2,0)>0){\\n                \\n                // Yay! both 2 friends are available. Let\\'s start a company.\\n                // So we decrease the avaibility count of nums[i], (nums[i]+1) and (nums[i]+2) from the \\n                // avaibilityMap\\n                avaibilityMap.put(nums[i], avaibilityMap.getOrDefault(nums[i],0)-1);\\n                avaibilityMap.put(nums[i]+1, avaibilityMap.getOrDefault(nums[i]+1,0)-1);\\n                avaibilityMap.put(nums[i]+2, avaibilityMap.getOrDefault(nums[i]+2,0)-1);\\n                \\n                // Also, as a goodwill, we create a new job vacancy for (nums[i]+3), as we need consecutive numbers only\\n                wantMap.put(nums[i]+3, wantMap.getOrDefault(nums[i]+3,0)+1);\\n            }\\n            \\n            // Bad luck case, nums[i] not able to start his/her company, so just return false\\n            else{\\n                return false;\\n            }\\n        }\\n        \\n        // All good till here so we return true\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 106493,
                "title": "c-o-n-solution-two-pass",
                "content": "The idea is , we scan the array for two times.\\nIn first pass we count the frequencies of all numbers and record them in ```cnt```\\nFor the second pass, we are \"building\" our subsequences by the following rules:\\n1. We use a hashmap called ```tails``` to record extra information, where ```tails[i]``` means the number of consecutive subsequences we've found so far, who are longer than 3 , and tailed by number ```i```,\\n2. When we meet number ```i```, try to put it to the tail of one of found subsequences tailed by ```i-1```. No need to worry that we might have a better choice to consider ```i``` as a brand new head for another subsequence, because we can always append the new subsequence to a previous one tailed by ```i-1```.\\n3. If we can't, it will cost one ```i+1``` and one ```i+2``` later to generate a new sequence. We just pay that right now by decrease ```cnt[i+1]``` and ```cnt[i+2]```. Some one may worry that we make use of the numbers we haven't scanned so far. But actually we've already kept track of the numbers remained by ```cnt```.  Just imaging we grab the numbers needed from the very end of the string, and mark them as \"used\". If there is no such number available to pay, ```cnt``` will tell us by checking ```cnt[i+1]``` ```cnt[i+2]``` is positive or not \\n\\nThe code is short and concise, shown below: \\n```\\nbool isPossible(vector<int>& nums) {\\n        unordered_map<int,int> cnt, tails;\\n        for(int &i : nums) cnt[i]++;\\n        for(int &i : nums){\\n            if(!cnt[i]) continue;\\n            cnt[i]--;\\n            if(tails[i-1] > 0){\\n                tails[i-1]--;\\n                tails[i]++;\\n            }\\n            else if(cnt[i+1] && cnt[i+2]){\\n                cnt[i+1]--;\\n                cnt[i+2]--;\\n                tails[i+2]++;\\n            }\\n            else return false;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```cnt```\n```tails```\n```tails[i]```\n```i```\n```i```\n```i-1```\n```i```\n```i-1```\n```i+1```\n```i+2```\n```cnt[i+1]```\n```cnt[i+2]```\n```cnt```\n```cnt```\n```cnt[i+1]```\n```cnt[i+2]```\n```\\nbool isPossible(vector<int>& nums) {\\n        unordered_map<int,int> cnt, tails;\\n        for(int &i : nums) cnt[i]++;\\n        for(int &i : nums){\\n            if(!cnt[i]) continue;\\n            cnt[i]--;\\n            if(tails[i-1] > 0){\\n                tails[i-1]--;\\n                tails[i]++;\\n            }\\n            else if(cnt[i+1] && cnt[i+2]){\\n                cnt[i+1]--;\\n                cnt[i+2]--;\\n                tails[i+2]++;\\n            }\\n            else return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2446913,
                "title": "c-greedy-fully-commented-simplest-solution-of-all",
                "content": "**C++:**\\n\\n```\\nclass Solution {\\npublic:\\n    //app 1: using greedy approach in O(N) \\n    \\n/* for each num in nums first try placing it in one of the existing subseq.\\nif no subseq. needs that number.\\nthen, try creating a new subseq. of atleast length 3 starting with that num.\\n\\nif neither of the two condtn is true, we return false\\nsince, that num can\\'t be a part of any subseq.\\n\\n*/\\n    bool isPossible(vector<int>& nums) {\\n        //freq. map denotes no. of elements left to be placed in subseq.\\n        unordered_map<int,int> freq;\\n        for(int x: nums) freq[x]++;\\n        \\n        //hypothetical map which denotes the \"next\" number req. by subsequences.\\n        unordered_map<int,int> need;\\n        \\n        for(int n: nums){\\n            //all occurences of cur num is already taken\\n            if(freq[n] == 0) continue;\\n            \\n            if(need[n] > 0){ // \"n\" can be a part of some existing subseq.\\n                need[n]--;\\n                freq[n]--;\\n                \\n                need[n+1]++; //next req. num is now \"N+1\"\\n            }\\n            \\n            //try creating a new sub. of length atleast three\\n            else if(freq[n]>0 && freq[n+1]>0 && freq[n+2]>0){\\n                freq[n]--;\\n                freq[n+1]--;\\n                freq[n+2]--;\\n                \\n                //next num needed in subseq.\\n                need[n+3]++;\\n            }\\n            \\n            //above both condtn is false\\n            else{\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\n\\n**Do consider Upvoting the Post, If it\\'s been any help to you!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    //app 1: using greedy approach in O(N) \\n    \\n/* for each num in nums first try placing it in one of the existing subseq.\\nif no subseq. needs that number.\\nthen, try creating a new subseq. of atleast length 3 starting with that num.\\n\\nif neither of the two condtn is true, we return false\\nsince, that num can\\'t be a part of any subseq.\\n\\n*/\\n    bool isPossible(vector<int>& nums) {\\n        //freq. map denotes no. of elements left to be placed in subseq.\\n        unordered_map<int,int> freq;\\n        for(int x: nums) freq[x]++;\\n        \\n        //hypothetical map which denotes the \"next\" number req. by subsequences.\\n        unordered_map<int,int> need;\\n        \\n        for(int n: nums){\\n            //all occurences of cur num is already taken\\n            if(freq[n] == 0) continue;\\n            \\n            if(need[n] > 0){ // \"n\" can be a part of some existing subseq.\\n                need[n]--;\\n                freq[n]--;\\n                \\n                need[n+1]++; //next req. num is now \"N+1\"\\n            }\\n            \\n            //try creating a new sub. of length atleast three\\n            else if(freq[n]>0 && freq[n+1]>0 && freq[n+2]>0){\\n                freq[n]--;\\n                freq[n+1]--;\\n                freq[n+2]--;\\n                \\n                //next num needed in subseq.\\n                need[n+3]++;\\n            }\\n            \\n            //above both condtn is false\\n            else{\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 130452,
                "title": "20ms-java-priorityqueue-with-explanations",
                "content": "Let\\'s take  [1, 2, 3, 3, 4, 5, 7] as an example\\n```\\n[1, 2, 3, 3, 4, 5, 7]\\n>> [1]\\n>> [1,2] #2\\n>> [1,2,3]\\n>> [1,2,3] [3]  #1\\n>> [1,2,3] [3,4]\\n>> [3,4,5] #3 \\n>> [7]\\n```\\nAfter observation, there are 3 cases\\n* Case 1 : `num == pq.peek().end`, we offer a new interval (num, num) to pq => #1\\n* Case 2 : `num == pq.peek().end+ 1`, we poll a interval prev, offer a new interval (prev.start, num) => #2\\n* Case 3 : `num > p1.peek().end + 1`, \\nwe keep abandoning intervals (if the length of the interval to abandon is smaller than 3, return false) until we could reduce to case 1 or case 2 => #3\\n\\nThe order of 3 cases above matters. For easier implementation, Case 3 should be checked first. \\n\\nIn the priority queue, all intervals are sorted by end increasingly, if there is a tie, we sort them by size increasingly.\\n\\n****\\n```\\n    public boolean isPossible(int[] nums) {\\n        PriorityQueue<Interval> pq = new PriorityQueue<>(new Comparator<Interval>(){\\n            @Override\\n            public int compare(Interval a, Interval b) {\\n                if (a.end == b.end) {\\n                    return Integer.compare(a.length, b.length);\\n                }\\n                return Integer.compare(a.end, b.end);\\n            }\\n        }); \\n        \\n        for (int num : nums) {\\n            while (!pq.isEmpty() && pq.peek().end + 1 < num) {\\n                if (pq.poll().length < 3)\\n                    return false;\\n            }\\n            if (pq.isEmpty() || pq.peek().end == num) {\\n                pq.add(new Interval(num, num));\\n            } else { // pq.peek().end + 1 == num\\n                pq.add(new Interval(pq.poll().start, num));\\n            }\\n        }\\n        \\n        while (!pq.isEmpty()) {\\n            if (pq.poll().length < 3)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    class Interval {\\n        int start;\\n        int end;\\n        int length;\\n        \\n        public Interval(int start, int end) {\\n            this.start = start;\\n            this.end = end;\\n            length = end - start + 1;\\n        }\\n    }\\n```\\n**Essence**\\nLet\\'s call a sequence with two ends as an interval. Whenever we do with interval-related problem, we always encapsulate useful information into a class `Interval` and use a PriorityQueue to compare intervals - or else, we may get us into a mess for sequence comparison.\\n\\n**(\\uFF89>\\u03C9<)\\uFF89 Vote up, please!**",
                "solutionTags": [],
                "code": "```\\n[1, 2, 3, 3, 4, 5, 7]\\n>> [1]\\n>> [1,2] #2\\n>> [1,2,3]\\n>> [1,2,3] [3]  #1\\n>> [1,2,3] [3,4]\\n>> [3,4,5] #3 \\n>> [7]\\n```\n```\\n    public boolean isPossible(int[] nums) {\\n        PriorityQueue<Interval> pq = new PriorityQueue<>(new Comparator<Interval>(){\\n            @Override\\n            public int compare(Interval a, Interval b) {\\n                if (a.end == b.end) {\\n                    return Integer.compare(a.length, b.length);\\n                }\\n                return Integer.compare(a.end, b.end);\\n            }\\n        }); \\n        \\n        for (int num : nums) {\\n            while (!pq.isEmpty() && pq.peek().end + 1 < num) {\\n                if (pq.poll().length < 3)\\n                    return false;\\n            }\\n            if (pq.isEmpty() || pq.peek().end == num) {\\n                pq.add(new Interval(num, num));\\n            } else { // pq.peek().end + 1 == num\\n                pq.add(new Interval(pq.poll().start, num));\\n            }\\n        }\\n        \\n        while (!pq.isEmpty()) {\\n            if (pq.poll().length < 3)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    class Interval {\\n        int start;\\n        int end;\\n        int length;\\n        \\n        public Interval(int start, int end) {\\n            this.start = start;\\n            this.end = end;\\n            length = end - start + 1;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628950,
                "title": "c-very-ez-priority-queue-method",
                "content": "```\\nclass Solution {\\npublic:\\n    class comparasion {\\n        public:\\n        bool operator()(pair<int, int>& a, pair<int, int>& b) {//always put the smallest and shortest sequence on the top of the heap\\n            if(a.first == b.first) return a.second > b.second;\\n            return a.first > b.first;\\n        };\\n    };\\n    bool isPossible(vector<int>& nums) {\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, comparasion> qe;\\n        int i = 0;\\n        while(i < nums.size()) {\\n            if(qe.empty()) {\\n                qe.push({nums[i], 1});\\n                i++;\\n            }\\n            else {\\n                pair<int, int> tmp = qe.top();\\n                if(nums[i] == tmp.first) {\\n                    qe.push({nums[i], 1});//add a new sequence\\n                    i++;\\n                }\\n                else if(nums[i] == tmp.first + 1) {\\n                    qe.pop();\\n                    qe.push({nums[i], tmp.second + 1});//update the top of the heap\\n                    i++;\\n                }\\n                else {\\n                    if(tmp.second < 3) {//false\\n                        return false;\\n                    }\\n                    qe.pop();\\n                }\\n            }\\n        }\\n        while(!qe.empty()) {\\n            if(qe.top().second < 3) {\\n                return false;\\n            }\\n            qe.pop();\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    class comparasion {\\n        public:\\n        bool operator()(pair<int, int>& a, pair<int, int>& b) {//always put the smallest and shortest sequence on the top of the heap\\n            if(a.first == b.first) return a.second > b.second;\\n            return a.first > b.first;\\n        };\\n    };\\n    bool isPossible(vector<int>& nums) {\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, comparasion> qe;\\n        int i = 0;\\n        while(i < nums.size()) {\\n            if(qe.empty()) {\\n                qe.push({nums[i], 1});\\n                i++;\\n            }\\n            else {\\n                pair<int, int> tmp = qe.top();\\n                if(nums[i] == tmp.first) {\\n                    qe.push({nums[i], 1});//add a new sequence\\n                    i++;\\n                }\\n                else if(nums[i] == tmp.first + 1) {\\n                    qe.pop();\\n                    qe.push({nums[i], tmp.second + 1});//update the top of the heap\\n                    i++;\\n                }\\n                else {\\n                    if(tmp.second < 3) {//false\\n                        return false;\\n                    }\\n                    qe.pop();\\n                }\\n            }\\n        }\\n        while(!qe.empty()) {\\n            if(qe.top().second < 3) {\\n                return false;\\n            }\\n            qe.pop();\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447044,
                "title": "python-c-easiest-approach-explained-dictionary-map-easy-understand",
                "content": "Idea:\\n* Using two map\\n\\t* One for how many sequences have that ending word\\n\\t* Another for how many numbers are unchecked\\n* Loop through every number\\n\\t* If there is sequence before the number, we add the number to the seq\\n\\t* If not we create a new seq using the number\\n\\t* If there aren\\'t two numbers behind to let us create new seq, return False\\n\\n**PYTHON code**\\n```\\nclass Solution:\\n    def isPossible(self, nums: List[int]) -> bool:\\n        \\n        seq = defaultdict(int)      # key: ending number, val: how many seqs\\n        left = Counter(nums)        # key: number, val: how many of key are left unchecked\\n        \\n        for num in nums:\\n            if (not left[num]): continue   # the number is already in seqs, we don\\'t need to check again\\n            \\n            if (seq[num-1] > 0):    # If there is sequence before the number, we add the number to the seq\\n                seq[num-1] -= 1 \\n                seq[num] += 1\\n                left[num] -= 1\\n                \\n            else:   # If not we create a new seq using the number\\n                if (not left[num+1] or not left[num+2]):  #  If there aren\\'t two numbers behind to let us create new seq, return False\\n                    return False\\n                left[num] -= 1\\n                left[num+1] -= 1\\n                left[num+2] -= 1\\n                seq[num+2] += 1\\n        \\n        return True\\n```\\n\\n**C++ code**\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) \\n    {\\n        unordered_map<int,int>left;   // key: number, val: how many of key are left unchecked\\n        unordered_map<int,int>seq;    // key: ending number, val: how many seqs\\n        for (auto x: nums)\\n            left[x]++;\\n\\n        for (auto x: nums)\\n        {\\n            if (left[x]==0) continue;   // the number is already in seqs, we don\\'t need to check again\\n\\t\\t\\t\\n            if (seq[x-1]>0)  // If there is sequence before the number, we add the number to the seq\\n            {                \\n                left[x]--;\\n                seq[x-1]-=1;\\n                seq[x]+=1;                \\n            }\\n            else   // If not we create a new seq using the number\\n            {\\n                if (left[x+1]==0 || left[x+2]==0)   //  If there aren\\'t two numbers behind to let us create new seq, return False\\n                    return false;\\n                left[x]--;\\n                left[x+1]--;\\n                left[x+2]--;\\n                seq[x+2]+=1;\\n            }\\n        }\\n        return true;        \\n    }\\n};\\n```\\n**Please UPVOTE if you LIKE!!**\\n",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def isPossible(self, nums: List[int]) -> bool:\\n        \\n        seq = defaultdict(int)      # key: ending number, val: how many seqs\\n        left = Counter(nums)        # key: number, val: how many of key are left unchecked\\n        \\n        for num in nums:\\n            if (not left[num]): continue   # the number is already in seqs, we don\\'t need to check again\\n            \\n            if (seq[num-1] > 0):    # If there is sequence before the number, we add the number to the seq\\n                seq[num-1] -= 1 \\n                seq[num] += 1\\n                left[num] -= 1\\n                \\n            else:   # If not we create a new seq using the number\\n                if (not left[num+1] or not left[num+2]):  #  If there aren\\'t two numbers behind to let us create new seq, return False\\n                    return False\\n                left[num] -= 1\\n                left[num+1] -= 1\\n                left[num+2] -= 1\\n                seq[num+2] += 1\\n        \\n        return True\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) \\n    {\\n        unordered_map<int,int>left;   // key: number, val: how many of key are left unchecked\\n        unordered_map<int,int>seq;    // key: ending number, val: how many seqs\\n        for (auto x: nums)\\n            left[x]++;\\n\\n        for (auto x: nums)\\n        {\\n            if (left[x]==0) continue;   // the number is already in seqs, we don\\'t need to check again\\n\\t\\t\\t\\n            if (seq[x-1]>0)  // If there is sequence before the number, we add the number to the seq\\n            {                \\n                left[x]--;\\n                seq[x-1]-=1;\\n                seq[x]+=1;                \\n            }\\n            else   // If not we create a new seq using the number\\n            {\\n                if (left[x+1]==0 || left[x+2]==0)   //  If there aren\\'t two numbers behind to let us create new seq, return False\\n                    return false;\\n                left[x]--;\\n                left[x+1]--;\\n                left[x+2]--;\\n                seq[x+2]+=1;\\n            }\\n        }\\n        return true;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 311938,
                "title": "just-visual-description-had-a-lot-of-english-trouble-from-solution-descriptions",
                "content": "```\\n\\n//\\n// How to solve?\\n//\\n// (e.g.) create sequence from (3,4,5,6,7), (5,6,7), (6,7,8,9,10)\\n//\\n//        -> 3, 4, 5, 5, 6, 6, 6, 7, 7, 7, 8, 9, 10\\n//\\n//        visually we are solving\\n//\\n//                    *  *\\n//                 *  *  *\\n//           *  *  *  *  *  *  *  *\\n//           3  4  5  6  7  8  9  10\\n//\\n// we are creating open ended sequence as scanning through 3 to 10\\n//\\n// At 3, there is no open sequence so [3) will be created\\n//\\n// At 4, #(4) == #(open sequence)\\n//   so don\\'t close the open sequences, just extends them\\n//    [3 4)\\n//\\n// At 5, #(5) > #(open sequences)  : (2 > 1)\\n//   so we extends existing open sequences, plus new sequence from \\'5\\'\\n//     [3 4 5)\\n//         [5)\\n//\\n// At 6, same situation as at \\'5\\',\\n//     [3 4 5 6)\\n//         [5 6)\\n//           [6)\\n//\\n// At 7, same as at 4 #(7) == #(seq)\\n//\\n//     [3 4 5 6 7)\\n//         [5 6 7)\\n//           [6 7)\\n//\\n// At 8, #(8) < #(seq) so we must close sequences if we can\\n//   (if not return false)\\n//\\n//     [3 4 5 6 7] --> done\\n//         [5 6 7] --> done\\n//           [6 7 8)\\n//\\n// At 9 and 10, we are just extending sequences\\n//           [6 7 8 9 10)\\n//\\n// At the end, if we can close all open sequences, return \\'true\\'\\n// If not return \\'false\\'\\n//\\n\\n\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n\\n//\\n// How to solve?\\n//\\n// (e.g.) create sequence from (3,4,5,6,7), (5,6,7), (6,7,8,9,10)\\n//\\n//        -> 3, 4, 5, 5, 6, 6, 6, 7, 7, 7, 8, 9, 10\\n//\\n//        visually we are solving\\n//\\n//                    *  *\\n//                 *  *  *\\n//           *  *  *  *  *  *  *  *\\n//           3  4  5  6  7  8  9  10\\n//\\n// we are creating open ended sequence as scanning through 3 to 10\\n//\\n// At 3, there is no open sequence so [3) will be created\\n//\\n// At 4, #(4) == #(open sequence)\\n//   so don\\'t close the open sequences, just extends them\\n//    [3 4)\\n//\\n// At 5, #(5) > #(open sequences)  : (2 > 1)\\n//   so we extends existing open sequences, plus new sequence from \\'5\\'\\n//     [3 4 5)\\n//         [5)\\n//\\n// At 6, same situation as at \\'5\\',\\n//     [3 4 5 6)\\n//         [5 6)\\n//           [6)\\n//\\n// At 7, same as at 4 #(7) == #(seq)\\n//\\n//     [3 4 5 6 7)\\n//         [5 6 7)\\n//           [6 7)\\n//\\n// At 8, #(8) < #(seq) so we must close sequences if we can\\n//   (if not return false)\\n//\\n//     [3 4 5 6 7] --> done\\n//         [5 6 7] --> done\\n//           [6 7 8)\\n//\\n// At 9 and 10, we are just extending sequences\\n//           [6 7 8 9 10)\\n//\\n// At the end, if we can close all open sequences, return \\'true\\'\\n// If not return \\'false\\'\\n//\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 182460,
                "title": "java-o-n-time-o-n-space-solution-with-detailed-example",
                "content": "Similar to the highest voted answer, but with an explanation.  We have 2 hashmaps.  One is for the count of numbers, and another is used as a flag that there was a previous size 3 sequence between the current number.\n\nExample: 1 2 3 3 4 4 5 5\nWe have counts of \n1, 1   2, 1  3,2  4,2  5,2\n\nThe current element is 1, we know that in order to fit this into a sequence, either there has to be a flag set (previous size 3 sequence or 1+1 and 1+2 must have have a positive count).  2 and 3 have a positive count so, we use up these 3 values and set a flag in our other hashmap at 1+3 (4 meaning that at 4 we have the option of using this subsequence).\n\nNow we have\n1,0 2,0 3,1 4,2 5,2\n\n4,1\nWe continue until 3.  We see that there are no possible sequences so we check 3+1 and 3+2, 4 and 5 both have positive counts. So we take those, and add 6,1\nCount HashMap:1,0 2,0 3,0 4,1 5,1\nPossibility (previous valid subsequences) : 4,1 6,1\n\nWe're on 4 now, we see that we have the option of continueing a subsequence from 4,1 so we continue it and use this number. We add 5,1 since the new subsequence will end at 4 (next would be 5).\nCount HashMap:  1,0 2,0 3,0 4,0 5,1\nPossibility (previous valid subsequences) : 5,1 6,1\n\nAgain, on 5 we see we have 5,1 so we can use that and it is a valid input.\nCount HashMap:  1,0 2,0 3,0 4,0 5,0 \nPossibility (previous valid subsequences) : 6,2\n```\nclass Solution {\n    public boolean isPossible(int[] nums) {\n        Map<Integer,Integer> possibility = new HashMap<>();\n        Map<Integer,Integer> counts = new HashMap<>();\n        for(int num:nums){\n            counts.put(num,counts.getOrDefault(num,0)+1);\n        }\n        for(int num:nums){\n            if(counts.get(num)==0)continue;\n            if(possibility.getOrDefault(num,0)>0){\n                possibility.put(num,possibility.getOrDefault(num,0)-1);\n                possibility.put(num+1,possibility.getOrDefault(num+1,0)+1);\n            }\n            else if( counts.getOrDefault(num+1,0)>0 && counts.getOrDefault(num+2,0)>0 ){\n                possibility.put(num+3,possibility.getOrDefault(num+3,0)+1);\n                counts.put(num+1,counts.getOrDefault(num+1,0)-1);\n                counts.put(num+2,counts.getOrDefault(num+2,0)-1);\n            }\n            else{\n                return false;\n            }\n            counts.put(num,counts.get(num)-1);\n        }\n        return true;\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    public boolean isPossible(int[] nums) {\n        Map<Integer,Integer> possibility = new HashMap<>();\n        Map<Integer,Integer> counts = new HashMap<>();\n        for(int num:nums){\n            counts.put(num,counts.getOrDefault(num,0)+1);\n        }\n        for(int num:nums){\n            if(counts.get(num)==0)continue;\n            if(possibility.getOrDefault(num,0)>0){\n                possibility.put(num,possibility.getOrDefault(num,0)-1);\n                possibility.put(num+1,possibility.getOrDefault(num+1,0)+1);\n            }\n            else if( counts.getOrDefault(num+1,0)>0 && counts.getOrDefault(num+2,0)>0 ){\n                possibility.put(num+3,possibility.getOrDefault(num+3,0)+1);\n                counts.put(num+1,counts.getOrDefault(num+1,0)-1);\n                counts.put(num+2,counts.getOrDefault(num+2,0)-1);\n            }\n            else{\n                return false;\n            }\n            counts.put(num,counts.get(num)-1);\n        }\n        return true;\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458470,
                "title": "c-easy-solution",
                "content": "class Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        map<int,int>fm;\\n        map<int,int>hm;\\n        for(int i:nums){\\n            fm[i]++;\\n        }\\n        for(int i:nums){\\n            if(fm[i]==0)continue;\\n            if(hm[i]>0){\\n                hm[i]--;\\n                hm[i+1]++;\\n                fm[i]--;\\n            }else if(fm[i]>0&&fm[i+1]>0&&fm[i+2]>0){\\n                    fm[i]--;\\n                fm[i+1]--;\\n                fm[i+2]--;\\n                hm[i+3]++;\\n            }else return false;\\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        map<int,int>fm;\\n        map<int,int>hm;\\n        for(int i:nums){\\n            fm[i]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 188185,
                "title": "python-o-n-time-o-n-space",
                "content": "Credit to @compton_scatter for idea. I edited it to make variable names more intuitive and pythonic, and wanted to explain it a little more clearly since I didn't understand his explanation at first.\n\nThe algorithm takes two steps:\n1. Iterate once through the array to get the number of occurrences for each number in the array. Store this in a hashmap called **occurrences** mapping the number to its total # of occurrences.\n2. Iterate once through the array to check if every element can be part of a consecutive sequence of at least length 3.\n\nThe second part is the core of the algorithm. For an element to be part of a consecutive sequence, it has to either be:\n1. Appendable to an existing sequence. For example, **5** is directly appendable to the sequence **[1, 2, 3, 4]**. We keep track of this next number (**5** in this example) in each of these sequences in a separate hashmap called **next_nums**.\n2. Able to create its own sequence. For this to happen, there must be at least 1 occurrence of that number + 1 and that number + 2, since that creates a sequence of length 3. \n\nThe **occurrences** hashmap essentially acts as a \"storage\" for all the numbers, and **next_nums** keeps track of what number can be directly appended to an existing sequence. Once every number in the \"storage\" has been accounted for, every number in the input array has been reallocated into a subsequence of at least length 3, so we return True. If at any point, a number cannot create its own subsequence and cannot be added to an existing one, we return False.\n\n\n\nCode:\n```\nclass Solution(object):\n    def isPossible(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        from collections import defaultdict\n        occurrences, next_nums = defaultdict(int), defaultdict(int)\n        for num in nums:\n            occurrences[num] += 1\n        for num in nums:\n            if occurrences[num] == 0:\n                continue \n           # If next_nums contains the number, it is directly appendable to a sequence.\n           # We \"append\" it to the sequence by incrementing the next number by 1.\n            elif next_nums[num] > 0:\n                next_nums[num] -= 1\n                next_nums[num + 1] += 1\n           # If the number + 1 and the number + 2 are both still in the occurrences hashmap,\n           # We can create a new subsequence of length 3 and add the next number to next_nums.\n            elif occurrences[num + 1] > 0 and occurrences[num + 2] > 0:\n                occurrences[num + 1] -= 1\n                occurrences[num + 2] -= 1\n                next_nums[num + 3] += 1\n            else:\n                return False\n            occurrences[num] -= 1\n        return True",
                "solutionTags": [],
                "code": "1. Appendable to an existing sequence. For example, **5** is directly appendable to the sequence **[1, 2, 3, 4]**. We keep track of this next number (**5** in this example) in each of these sequences in a separate hashmap called **next_nums**.\nclass Solution(object):\n    def isPossible(self, nums):\n        from collections import defaultdict\n        occurrences, next_nums = defaultdict(int), defaultdict(int)\n            occurrences[num] += 1\n            if occurrences[num] == 0:\n                next_nums[num] -= 1\n                next_nums[num + 1] += 1\n                occurrences[num + 1] -= 1\n                occurrences[num + 2] -= 1\n                next_nums[num + 3] += 1\n            occurrences[num] -= 1",
                "codeTag": "Java"
            },
            {
                "id": 2446738,
                "title": "python-524ms-98-3-faster-multiple-solutions-94-memory-efficient",
                "content": "# DON\\'T FORGET TO UPVOTE!!!\\n# 1. 98% faster 524 ms solution:\\n\\n\\t\\tclass Solution:\\n\\t\\t\\tdef isPossible(self, nums: List[int]) -> bool:\\n\\t\\t\\t\\tlen1 = len2 = absorber = 0\\n\\t\\t\\t\\tprev_num = nums[0] - 1\\n\\t\\t\\t\\tfor streak_len, streak_num in Solution.get_streaks(nums):\\n\\t\\t\\t\\t\\tif streak_num == prev_num + 1:\\n\\t\\t\\t\\t\\t\\tspillage = streak_len - len1 - len2\\n\\t\\t\\t\\t\\t\\tif spillage < 0:\\n\\t\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\t\\tabsorber = min(absorber, spillage)\\n\\t\\t\\t\\t\\t\\tlen1, len2, absorber = spillage - absorber, len1, absorber + len2\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tif len1 or len2:\\n\\t\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\t\\tabsorber = 0\\n\\t\\t\\t\\t\\tprev_num = streak_num\\n\\t\\t\\t\\treturn len1 == len2 == 0\\n\\n\\t\\t\\t@staticmethod\\n\\t\\t\\tdef get_streaks(nums: List[int]):\\n\\t\\t\\t\\tstreak_num = nums[0]\\n\\t\\t\\t\\tstreak_len = 0\\n\\t\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\t\\tif num == streak_num:\\n\\t\\t\\t\\t\\t\\tstreak_len += 1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tyield streak_len, streak_num\\n\\t\\t\\t\\t\\t\\tstreak_num = num\\n\\t\\t\\t\\t\\t\\tstreak_len = 1\\n\\t\\t\\t\\tyield streak_len, streak_num\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n# 2. Memory Efficient solution:\\n\\n\\t\\t\\tclass Solution:\\n\\t\\t\\t\\tdef isPossible(self, nums: List[int]) -> bool:\\n\\t\\t\\t\\t\\tcounter = collections.Counter(nums)\\n\\t\\t\\t\\t\\tfor i in sorted(counter.keys()):\\n\\t\\t\\t\\t\\t\\twhile counter[i] > 0:\\n\\t\\t\\t\\t\\t\\t\\tlast = 0\\n\\t\\t\\t\\t\\t\\t\\tj = i\\n\\t\\t\\t\\t\\t\\t\\tk = 0\\n\\t\\t\\t\\t\\t\\t\\twhile counter[j] >= last:\\n\\t\\t\\t\\t\\t\\t\\t\\tlast = counter[j]\\n\\t\\t\\t\\t\\t\\t\\t\\tcounter[j] -= 1\\n\\t\\t\\t\\t\\t\\t\\t\\tj += 1\\n\\t\\t\\t\\t\\t\\t\\t\\tk += 1\\n\\t\\t\\t\\t\\t\\t\\tif k < 3:\\n\\t\\t\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\t\\t\\n# 3 Easy explained approach:\\n\\n\\tclass Solution:\\n\\t\\tdef isPossible(self, nums: List[int]) -> bool:\\n\\n\\t\\t\\tif len(nums) < 3: return False\\n\\n\\t\\t\\tfrequency = collections.Counter(nums)\\n\\t\\t\\tsubsequence = collections.defaultdict(int)\\n\\n\\t\\t\\tfor i in nums:\\n\\n\\t\\t\\t\\tif frequency[i] == 0:\\n\\t\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\t\\tfrequency[i] -= 1\\n\\n\\t\\t\\t\\t# option 1 - add to an existing subsequence\\n\\t\\t\\t\\tif subsequence[i-1] > 0:\\n\\t\\t\\t\\t\\tsubsequence[i-1] -= 1\\n\\t\\t\\t\\t\\tsubsequence[i] += 1\\n\\n\\t\\t\\t\\t# option 2 - create a new subsequence \\n\\t\\t\\t\\telif frequency[i+1] and frequency[i+2]:\\n\\t\\t\\t\\t\\tfrequency[i+1] -= 1\\n\\t\\t\\t\\t\\tfrequency[i+2] -= 1\\n\\t\\t\\t\\t\\tsubsequence[i+2] += 1\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\treturn True\\n\\n\\t\\t# TC: O(n), SC: O(n)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "# DON\\'T FORGET TO UPVOTE!!!\\n# 1. 98% faster 524 ms solution:\\n\\n\\t\\tclass Solution:\\n\\t\\t\\tdef isPossible(self, nums: List[int]) -> bool:\\n\\t\\t\\t\\tlen1 = len2 = absorber = 0\\n\\t\\t\\t\\tprev_num = nums[0] - 1\\n\\t\\t\\t\\tfor streak_len, streak_num in Solution.get_streaks(nums):\\n\\t\\t\\t\\t\\tif streak_num == prev_num + 1:\\n\\t\\t\\t\\t\\t\\tspillage = streak_len - len1 - len2\\n\\t\\t\\t\\t\\t\\tif spillage < 0:\\n\\t\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\t\\tabsorber = min(absorber, spillage)\\n\\t\\t\\t\\t\\t\\tlen1, len2, absorber = spillage - absorber, len1, absorber + len2\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tif len1 or len2:\\n\\t\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\t\\tabsorber = 0\\n\\t\\t\\t\\t\\tprev_num = streak_num\\n\\t\\t\\t\\treturn len1 == len2 == 0\\n\\n\\t\\t\\t@staticmethod\\n\\t\\t\\tdef get_streaks(nums: List[int]):\\n\\t\\t\\t\\tstreak_num = nums[0]\\n\\t\\t\\t\\tstreak_len = 0\\n\\t\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\t\\tif num == streak_num:\\n\\t\\t\\t\\t\\t\\tstreak_len += 1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tyield streak_len, streak_num\\n\\t\\t\\t\\t\\t\\tstreak_num = num\\n\\t\\t\\t\\t\\t\\tstreak_len = 1\\n\\t\\t\\t\\tyield streak_len, streak_num\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n# 2. Memory Efficient solution:\\n\\n\\t\\t\\tclass Solution:\\n\\t\\t\\t\\tdef isPossible(self, nums: List[int]) -> bool:\\n\\t\\t\\t\\t\\tcounter = collections.Counter(nums)\\n\\t\\t\\t\\t\\tfor i in sorted(counter.keys()):\\n\\t\\t\\t\\t\\t\\twhile counter[i] > 0:\\n\\t\\t\\t\\t\\t\\t\\tlast = 0\\n\\t\\t\\t\\t\\t\\t\\tj = i\\n\\t\\t\\t\\t\\t\\t\\tk = 0\\n\\t\\t\\t\\t\\t\\t\\twhile counter[j] >= last:\\n\\t\\t\\t\\t\\t\\t\\t\\tlast = counter[j]\\n\\t\\t\\t\\t\\t\\t\\t\\tcounter[j] -= 1\\n\\t\\t\\t\\t\\t\\t\\t\\tj += 1\\n\\t\\t\\t\\t\\t\\t\\t\\tk += 1\\n\\t\\t\\t\\t\\t\\t\\tif k < 3:\\n\\t\\t\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\t\\t\\n# 3 Easy explained approach:\\n\\n\\tclass Solution:\\n\\t\\tdef isPossible(self, nums: List[int]) -> bool:\\n\\n\\t\\t\\tif len(nums) < 3: return False\\n\\n\\t\\t\\tfrequency = collections.Counter(nums)\\n\\t\\t\\tsubsequence = collections.defaultdict(int)\\n\\n\\t\\t\\tfor i in nums:\\n\\n\\t\\t\\t\\tif frequency[i] == 0:\\n\\t\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\t\\tfrequency[i] -= 1\\n\\n\\t\\t\\t\\t# option 1 - add to an existing subsequence\\n\\t\\t\\t\\tif subsequence[i-1] > 0:\\n\\t\\t\\t\\t\\tsubsequence[i-1] -= 1\\n\\t\\t\\t\\t\\tsubsequence[i] += 1\\n\\n\\t\\t\\t\\t# option 2 - create a new subsequence \\n\\t\\t\\t\\telif frequency[i+1] and frequency[i+2]:\\n\\t\\t\\t\\t\\tfrequency[i+1] -= 1\\n\\t\\t\\t\\t\\tfrequency[i+2] -= 1\\n\\t\\t\\t\\t\\tsubsequence[i+2] += 1\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\treturn True\\n\\n\\t\\t# TC: O(n), SC: O(n)",
                "codeTag": "Java"
            },
            {
                "id": 106516,
                "title": "simple-c-greedy-o-nlogn-solution-with-explanation",
                "content": "**The Algorithm**\\n\\nMaintain a set of consecutive sequences, call this set `s`. `s` begins as an empty set of consecutive sequences.\\n\\nNow, iterate through each `num` in `nums`. For each iteration, if there exists a consecutive sequence in `s` that ends with element `num-1`, then append `num` to the end of the shortest such sequence; otherwise, create a new sequence that begins with `num`. \\n\\nThe problem has a solution (i.e. the array can be split into consecutive subsequences such that each subsequence consists of at least 3 consecutive integers) if and only if each sequence in `s` has size greater than or equal to 3.\\n\\n**Proof of Algorithm**\\n\\nWhy does this algorithm work? It was intuitive to me, but I could not indisputably prove that it was correct. Hopefully, someone else can prove it.\\n\\n**Implementation**\\n\\nWe don't need to actually store each sequence. Instead, we just need to know (1) the number of sequences that end at a particular element, and (2) the size of each of those sequences. To implement this, we can have an unordered map `backs` to represent the sequences: `backs[key]` returns a priority queue (smallest value at top) of the sizes of all sequences that end with element `key`. Now that we have (1) and (2), we can implement the algorithm above without knowing each particular sequence. \\n\\nFor each `num` in `nums`, if there exists any sequence that ends with `num-1` (i.e. if `backs[num-1]` is a non-empty priority queue), then find such a sequence with the smallest possible size (get the smallest value from the priority queue at `backs[num-1]`). Now, the sequence will be extended by 1 since we will add `num` to it. So pop the smallest value `count` from the priority queue at `backs[num-1]`, and add a new value `count+1` to the priority queue at `backs[num]`.\\n\\nIf no sequence was found that ends in `num-1` (i.e. `backs[num-1]` is empty), then create a new sequence. In other words, add `1` to the priority queue at `backs[num]`.\\n\\n**The Code**\\n\\n```\\nclass Solution {\\npublic:\\n\\tbool isPossible(vector<int>& nums)\\n\\t{\\n\\t\\tunordered_map<int, priority_queue<int, vector<int>, std::greater<int>>> backs;\\n\\n\\t\\t// Keep track of the number of sequences with size < 3\\n\\t\\tint need_more = 0;\\n\\n\\t\\tfor (int num : nums)\\n\\t\\t{\\n\\t\\t\\tif (! backs[num - 1].empty())\\n\\t\\t\\t{\\t// There exists a sequence that ends in num-1\\n\\t\\t\\t\\t// Append 'num' to this sequence\\n\\t\\t\\t\\t// Remove the existing sequence\\n\\t\\t\\t\\t// Add a new sequence ending in 'num' with size incremented by 1 \\n\\t\\t\\t\\tint count = backs[num - 1].top();\\n\\t\\t\\t\\tbacks[num - 1].pop();\\n\\t\\t\\t\\tbacks[num].push(++count);\\n\\n\\t\\t\\t\\tif (count == 3)\\n\\t\\t\\t\\t\\tneed_more--;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\t// There is no sequence that ends in num-1\\n\\t\\t\\t\\t// Create a new sequence with size 1 that ends with 'num'\\n\\t\\t\\t\\tbacks[num].push(1);\\n\\t\\t\\t\\tneed_more++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn need_more == 0;\\n\\t}\\n};\\n```\\n**Improvements**\\n\\nI know that there are O(n) solutions out there that use different algorithms. Can my algorithm be implemented more efficiently to be O(n) instead of O(nlogn)? \\n\\nThoughts?",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\tbool isPossible(vector<int>& nums)\\n\\t{\\n\\t\\tunordered_map<int, priority_queue<int, vector<int>, std::greater<int>>> backs;\\n\\n\\t\\t// Keep track of the number of sequences with size < 3\\n\\t\\tint need_more = 0;\\n\\n\\t\\tfor (int num : nums)\\n\\t\\t{\\n\\t\\t\\tif (! backs[num - 1].empty())\\n\\t\\t\\t{\\t// There exists a sequence that ends in num-1\\n\\t\\t\\t\\t// Append 'num' to this sequence\\n\\t\\t\\t\\t// Remove the existing sequence\\n\\t\\t\\t\\t// Add a new sequence ending in 'num' with size incremented by 1 \\n\\t\\t\\t\\tint count = backs[num - 1].top();\\n\\t\\t\\t\\tbacks[num - 1].pop();\\n\\t\\t\\t\\tbacks[num].push(++count);\\n\\n\\t\\t\\t\\tif (count == 3)\\n\\t\\t\\t\\t\\tneed_more--;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\t// There is no sequence that ends in num-1\\n\\t\\t\\t\\t// Create a new sequence with size 1 that ends with 'num'\\n\\t\\t\\t\\tbacks[num].push(1);\\n\\t\\t\\t\\tneed_more++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn need_more == 0;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2448243,
                "title": "python-easily-understood-faster-than-90-explanation",
                "content": "**Appreciate if you could upvote this solution**\\n\\nMethod: `hashmap`\\n\\nAt the beginning, we create 2 `dict` first:\\n```\\n1) subsequence[i]: \\n\\t- return the number of subsequences that end with i\\n2) num_count[i]: \\n\\t- return the remaining occurrence time of i  \\n```\\n\\nThen, access the `num` in `nums` one by one:\\n```\\n1) The is subsequence end with [num-1]\\n\\t- append num to the subsequence[num-1]\\n\\n2) Create a new subsequence start with [num]\\n\\t- Check if [num+1] and [num+2] are available\\n\\t\\t- Yes\\n\\t\\t\\t-> pick the further [num+1] and [num+2] in num_count to form a subsequence\\n\\t\\t- No\\n\\t\\t\\t-> return False\\n```\\n\\n<br/>\\n\\nCode:\\n```\\ndef isPossible(self, nums: List[int]) -> bool:\\n\\tsubsequence = defaultdict(int)\\n\\tnum_count = Counter(nums)\\n\\n\\tfor num in nums:\\n\\t\\tif not num_count[num]:\\n\\t\\t\\tcontinue\\n\\n\\t\\tif subsequence[num - 1] > 0:\\n\\t\\t\\tsubsequence[num - 1] -= 1\\n\\t\\t\\tsubsequence[num] += 1\\n\\t\\telse:\\n\\t\\t\\tif not num_count[num + 1] or not num_count[num + 2]:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\tnum_count[num + 1] -= 1\\n\\t\\t\\tnum_count[num + 2] -= 1\\n\\t\\t\\tsubsequence[num + 2] += 1\\n\\t\\tnum_count[num] -= 1\\n\\n\\treturn True\\n```\\n\\n**Time Complexity**: `O(n)`\\n**Space Complexity**: `O(n)`\\n<br/>",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n1) subsequence[i]: \\n\\t- return the number of subsequences that end with i\\n2) num_count[i]: \\n\\t- return the remaining occurrence time of i  \\n```\n```\\n1) The is subsequence end with [num-1]\\n\\t- append num to the subsequence[num-1]\\n\\n2) Create a new subsequence start with [num]\\n\\t- Check if [num+1] and [num+2] are available\\n\\t\\t- Yes\\n\\t\\t\\t-> pick the further [num+1] and [num+2] in num_count to form a subsequence\\n\\t\\t- No\\n\\t\\t\\t-> return False\\n```\n```\\ndef isPossible(self, nums: List[int]) -> bool:\\n\\tsubsequence = defaultdict(int)\\n\\tnum_count = Counter(nums)\\n\\n\\tfor num in nums:\\n\\t\\tif not num_count[num]:\\n\\t\\t\\tcontinue\\n\\n\\t\\tif subsequence[num - 1] > 0:\\n\\t\\t\\tsubsequence[num - 1] -= 1\\n\\t\\t\\tsubsequence[num] += 1\\n\\t\\telse:\\n\\t\\t\\tif not num_count[num + 1] or not num_count[num + 2]:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\tnum_count[num + 1] -= 1\\n\\t\\t\\tnum_count[num + 2] -= 1\\n\\t\\t\\tsubsequence[num + 2] += 1\\n\\t\\tnum_count[num] -= 1\\n\\n\\treturn True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2450588,
                "title": "c-detailed-explanation-w-dry-run-each-step-explained-commented-code",
                "content": "```\\nclass Solution {\\npublic:\\n    /* Idea:\\n    1) First we store frequency of all the elements into the array.\\n    2) Now, for every index, we have two possibility:\\n       i) either we append it into some coming subsequence\\n       ii) or we start a new subsequence with this number.\\n       \\n    3) If we check the first condition, i.e \\n    either we append it into some coming subsequence, then \\n    we should have a coming subsequence that is just ending with this \\n    (current element - 1), suppose we have current number as 3\\n    then we want that there should have a coming subsequence who is ending \\n    with 2, because after so only we are able to append 3 here.\\n    \\n    4) If this condition satisfies, i.e we find a coming subsequence that is \\n    ending with (current element - 1), then we will append this element into\\n    that subsequence. Since we append this current element into that coming\\n    subsequence, therefore this subsequence is now ending with this current\\n    element. suppose we have current number as 3\\n    then we want that there should have a coming subsequence who is ending \\n    with 2, suppose we append 3 here, now that subsequence is ending with 3\\n    not now 2. so we have to take care of this.\\n    \\n    5) But suppose there is no coming subsequence that is ending with \\n    (current element - 1), so we have to start a new subsequence by taking\\n    this element only. So suppose 3 is our current element, and we want to\\n    start a new subsequence with this 3, then according to given \\n    condition \"All subsequences have a length of 3 or more.\" so if \\n    we want to start a subsequence with 3, then for following this condition\\n    4 and 5 should be there.\\n    \\n    6) That\\'s why we will make a new map, and that map will store, \\n    what is the last number of subsequence ending with.\\n    \\n    DRY RUN: \\n    take array: [1, 2, 3, 3, 4, 5]\\n    \\n    now, first step: store frequency, so map will look like\\n    1 --> 1\\n    2 --> 1\\n    3 --> 2\\n    4 --> 1\\n    5 --> 1\\n    \\n    Now, Intially every thing is empty\\n    for i = 0, arr[0] = 1, we will ask whether is there any coming \\n    subsequence that is ending with (1 - 1 = 0) zero, we will say no, \\n    so we move to next step, that okay if there is no subsequence\\n    so we should start with 1, now for forming a subsequence with 1\\n    we will say 2 and 3 should be there, so we will check in our frequency\\n    whether 2 and 3 is present in our frequency map, we will get our answer\\n    as true, that yes 2 and 3 is there, so we will make a subsequence.\\n    \\n    Now, we form a subsquence with 1 as 1, 2, 3 so we have to decreae the \\n    frequency of all three, so we will do this and now \\n    our subsequence is ending with 3.\\n    \\n    now, move forward, i = 1, arr[1] = 2,\\n    since we already use this element and frequency of this becomes zero,\\n    so we will move forward.\\n    \\n    move forward, i = 2, arr[2] = 3, \\n    since intially it\\'s frequency is 2, but after forming that subsequence \\n    (1, 2, 3) it\\'s frequency left is 1\\n    \\n    again we ask the same question, whether is there any coming subsequence\\n    which is (3 - 1 = 2) two, we will get our answer as NO, since there is \\n    a subsequence present which is ending with 3 only.\\n    So, we will say there is no subsequence which is ending with 2.\\n    If there is no subsequencw which is ending with 2, then what we will try to\\n    do, we will start a new subseuqnce from here.\\n    So if I want to start a subsequence with 3, we will say that \\n    4 and 5 should be there in the frequency map, we will check \\n    is it possible, we get our answer as YES, so we will create this\\n    subsequence, and now we have anthor subsequence which is ending with 5.\\n    \\n    now, move forward, i = 3, arr[3] = 3,\\n    since we already use this element and frequency of this becomes zero,\\n    so we will move forward.\\n    \\n    now, move forward, i = 4, arr[4] = 4,\\n    since we already use this element and frequency of this becomes zero,\\n    so we will move forward.\\n    \\n    now, move forward, i = 5, arr[5] = 5,\\n    since we already use this element and frequency of this becomes zero,\\n    so we will move forward.\\n    \\n    therefore at last we are able to use every element and create susbequence\\n    by following akk the conditions so we will return true.\\n    \\n    See commented code now, you will get :)\\n    */\\n    bool isPossible(vector<int>& arr) {\\n        int n = arr.size(); // extract the size of the array\\n        \\n        // declaring map to store frequency\\n        unordered_map<int, int> frequency; \\n        \\n        for(int i = 0; i < n; i++) // traverse in the array\\n        {\\n            frequency[arr[i]]++; // store frequency\\n        }\\n        \\n        // defining anthor map which will tell us whether is there any\\n        // subsequence which is ending with a particular number\\n        unordered_map<int, int> numberEndingWith;\\n        \\n        // traverse into the array\\n        for(int i = 0; i < n; i++)\\n        {\\n            // if frequency is zero, that means we are already using \\n            // this element in any other subsequence, so move to \\n            // next element\\n            if(frequency[arr[i]] == 0)  \\n            {\\n                continue;\\n            }\\n            \\n            // we will use this element now, so decrease it\\'s frequency\\n            frequency[arr[i]]--; \\n            \\n            int prevElement = arr[i] - 1; // previous element\\n            int justNext = arr[i] + 1; // next element\\n            int justNextPlusOne = arr[i] + 2; // next second element\\n            \\n            // Is there any coming subsequence that is ending with\\n            // previous element, \\n            // if yes, then append this current element \\n            // and update that, now this current element will\\n            // act as ending with element\\n            if(numberEndingWith[prevElement] > 0)\\n            {\\n                // so decrease freq of prev ele\\n                numberEndingWith[prevElement]--; \\n                \\n                // and this current ele becomes ending with\\n                numberEndingWith[arr[i]]++; \\n            } // else we want to stat a new subsequence with this curr ele, so\\n            else if(frequency[justNext] > 0 && frequency[justNextPlusOne] > 0)\\n            {\\n                // so if just next is present as well as \\n                // just Next PlusOne is also present so \\n                // decrease there freuqencies and update the \\n                // case number ending with\\n                frequency[justNext]--;                       \\n                frequency[justNextPlusOne]--;\\n                \\n                numberEndingWith[justNextPlusOne]++;\\n            }\\n            else  // else return false\\n            {\\n                return false;\\n            }\\n        }\\n        \\n        // if we are able to put all elements into a valid cofiguration\\n        // then return true\\n        return true;\\n    }\\n};\\n```\\n***`If u find this useful , please consider to give a upvote!!`***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /* Idea:\\n    1) First we store frequency of all the elements into the array.\\n    2) Now, for every index, we have two possibility:\\n       i) either we append it into some coming subsequence\\n       ii) or we start a new subsequence with this number.\\n       \\n    3) If we check the first condition, i.e \\n    either we append it into some coming subsequence, then \\n    we should have a coming subsequence that is just ending with this \\n    (current element - 1), suppose we have current number as 3\\n    then we want that there should have a coming subsequence who is ending \\n    with 2, because after so only we are able to append 3 here.\\n    \\n    4) If this condition satisfies, i.e we find a coming subsequence that is \\n    ending with (current element - 1), then we will append this element into\\n    that subsequence. Since we append this current element into that coming\\n    subsequence, therefore this subsequence is now ending with this current\\n    element. suppose we have current number as 3\\n    then we want that there should have a coming subsequence who is ending \\n    with 2, suppose we append 3 here, now that subsequence is ending with 3\\n    not now 2. so we have to take care of this.\\n    \\n    5) But suppose there is no coming subsequence that is ending with \\n    (current element - 1), so we have to start a new subsequence by taking\\n    this element only. So suppose 3 is our current element, and we want to\\n    start a new subsequence with this 3, then according to given \\n    condition \"All subsequences have a length of 3 or more.\" so if \\n    we want to start a subsequence with 3, then for following this condition\\n    4 and 5 should be there.\\n    \\n    6) That\\'s why we will make a new map, and that map will store, \\n    what is the last number of subsequence ending with.\\n    \\n    DRY RUN: \\n    take array: [1, 2, 3, 3, 4, 5]\\n    \\n    now, first step: store frequency, so map will look like\\n    1 --> 1\\n    2 --> 1\\n    3 --> 2\\n    4 --> 1\\n    5 --> 1\\n    \\n    Now, Intially every thing is empty\\n    for i = 0, arr[0] = 1, we will ask whether is there any coming \\n    subsequence that is ending with (1 - 1 = 0) zero, we will say no, \\n    so we move to next step, that okay if there is no subsequence\\n    so we should start with 1, now for forming a subsequence with 1\\n    we will say 2 and 3 should be there, so we will check in our frequency\\n    whether 2 and 3 is present in our frequency map, we will get our answer\\n    as true, that yes 2 and 3 is there, so we will make a subsequence.\\n    \\n    Now, we form a subsquence with 1 as 1, 2, 3 so we have to decreae the \\n    frequency of all three, so we will do this and now \\n    our subsequence is ending with 3.\\n    \\n    now, move forward, i = 1, arr[1] = 2,\\n    since we already use this element and frequency of this becomes zero,\\n    so we will move forward.\\n    \\n    move forward, i = 2, arr[2] = 3, \\n    since intially it\\'s frequency is 2, but after forming that subsequence \\n    (1, 2, 3) it\\'s frequency left is 1\\n    \\n    again we ask the same question, whether is there any coming subsequence\\n    which is (3 - 1 = 2) two, we will get our answer as NO, since there is \\n    a subsequence present which is ending with 3 only.\\n    So, we will say there is no subsequence which is ending with 2.\\n    If there is no subsequencw which is ending with 2, then what we will try to\\n    do, we will start a new subseuqnce from here.\\n    So if I want to start a subsequence with 3, we will say that \\n    4 and 5 should be there in the frequency map, we will check \\n    is it possible, we get our answer as YES, so we will create this\\n    subsequence, and now we have anthor subsequence which is ending with 5.\\n    \\n    now, move forward, i = 3, arr[3] = 3,\\n    since we already use this element and frequency of this becomes zero,\\n    so we will move forward.\\n    \\n    now, move forward, i = 4, arr[4] = 4,\\n    since we already use this element and frequency of this becomes zero,\\n    so we will move forward.\\n    \\n    now, move forward, i = 5, arr[5] = 5,\\n    since we already use this element and frequency of this becomes zero,\\n    so we will move forward.\\n    \\n    therefore at last we are able to use every element and create susbequence\\n    by following akk the conditions so we will return true.\\n    \\n    See commented code now, you will get :)\\n    */\\n    bool isPossible(vector<int>& arr) {\\n        int n = arr.size(); // extract the size of the array\\n        \\n        // declaring map to store frequency\\n        unordered_map<int, int> frequency; \\n        \\n        for(int i = 0; i < n; i++) // traverse in the array\\n        {\\n            frequency[arr[i]]++; // store frequency\\n        }\\n        \\n        // defining anthor map which will tell us whether is there any\\n        // subsequence which is ending with a particular number\\n        unordered_map<int, int> numberEndingWith;\\n        \\n        // traverse into the array\\n        for(int i = 0; i < n; i++)\\n        {\\n            // if frequency is zero, that means we are already using \\n            // this element in any other subsequence, so move to \\n            // next element\\n            if(frequency[arr[i]] == 0)  \\n            {\\n                continue;\\n            }\\n            \\n            // we will use this element now, so decrease it\\'s frequency\\n            frequency[arr[i]]--; \\n            \\n            int prevElement = arr[i] - 1; // previous element\\n            int justNext = arr[i] + 1; // next element\\n            int justNextPlusOne = arr[i] + 2; // next second element\\n            \\n            // Is there any coming subsequence that is ending with\\n            // previous element, \\n            // if yes, then append this current element \\n            // and update that, now this current element will\\n            // act as ending with element\\n            if(numberEndingWith[prevElement] > 0)\\n            {\\n                // so decrease freq of prev ele\\n                numberEndingWith[prevElement]--; \\n                \\n                // and this current ele becomes ending with\\n                numberEndingWith[arr[i]]++; \\n            } // else we want to stat a new subsequence with this curr ele, so\\n            else if(frequency[justNext] > 0 && frequency[justNextPlusOne] > 0)\\n            {\\n                // so if just next is present as well as \\n                // just Next PlusOne is also present so \\n                // decrease there freuqencies and update the \\n                // case number ending with\\n                frequency[justNext]--;                       \\n                frequency[justNextPlusOne]--;\\n                \\n                numberEndingWith[justNextPlusOne]++;\\n            }\\n            else  // else return false\\n            {\\n                return false;\\n            }\\n        }\\n        \\n        // if we are able to put all elements into a valid cofiguration\\n        // then return true\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1038982,
                "title": "it-s-easy-cpp-98",
                "content": "Just check that the frequency of previous elements must be less than current element\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        for(auto& it:nums)\\n            mp[it]++;\\n        for(auto& it:nums)\\n        {\\n            if(mp[it] == 0)\\n                continue;\\n            int freq = mp[it] , curr = it , count = 0;\\n            while(mp.count(curr) && mp[curr] >= freq)\\n            {\\n                freq = fmax(freq,mp[curr]);\\n                mp[curr]--;\\n                count++;\\n                curr++;\\n            }\\n            if(count < 3)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\nupvote if you like the solution :)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        for(auto& it:nums)\\n            mp[it]++;\\n        for(auto& it:nums)\\n        {\\n            if(mp[it] == 0)\\n                continue;\\n            int freq = mp[it] , curr = it , count = 0;\\n            while(mp.count(curr) && mp[curr] >= freq)\\n            {\\n                freq = fmax(freq,mp[curr]);\\n                mp[curr]--;\\n                count++;\\n                curr++;\\n            }\\n            if(count < 3)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 589680,
                "title": "python-heap",
                "content": "```\\ndef is_possible(L: List[int]) -> bool:\\n    \"\"\"\\n    Split Array into Consecutive Subsequences\\n\\n    :param List[int] L:\\n    :return bool:\\n    \"\"\"\\n    tails = defaultdict(list)\\n\\n    for n in L:\\n        if tails[n - 1]:\\n            heappush(tails[n], heappop(tails[n - 1]) + 1)\\n        else:\\n            heappush(tails[n], 1)\\n\\n    return all(\\n        l >= 3\\n        for tail in tails.values()\\n        for l in tail\\n    )\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef is_possible(L: List[int]) -> bool:\\n    \"\"\"\\n    Split Array into Consecutive Subsequences\\n\\n    :param List[int] L:\\n    :return bool:\\n    \"\"\"\\n    tails = defaultdict(list)\\n\\n    for n in L:\\n        if tails[n - 1]:\\n            heappush(tails[n], heappop(tails[n - 1]) + 1)\\n        else:\\n            heappush(tails[n], 1)\\n\\n    return all(\\n        l >= 3\\n        for tail in tails.values()\\n        for l in tail\\n    )\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 416994,
                "title": "java-greedy-two-pass-solution-with-clear-comment",
                "content": "```\\nclass Solution {\\n    public boolean isPossible(int[] nums) {\\n        // greedy algorithm\\n        if (nums == null || nums.length < 3)\\n            return false;\\n        \\n        // map to save the frequency of each number\\n        Map<Integer, Integer> freq = new HashMap<>();\\n        \\n        // map to save that the number of subsequences that are\\n        // ended with number i\\n        Map<Integer, Integer> tail = new HashMap<>();\\n        \\n        // first pass, fill teh freq map\\n        for (int i : nums) {\\n            freq.put(i, freq.getOrDefault(i, 0) + 1);\\n        }\\n        \\n        // second pass:\\n        for (int i : nums) {\\n            // there is no such number available\\n            if (freq.get(i) == 0) {\\n                continue;\\n            }\\n            // if there is some subsequence that is ended with i - 1:\\n            // then we can put the number i in the subsequence\\n            if (tail.get(i-1) != null && tail.get(i-1) > 0) {\\n                // the number of sequence ended with i-1 decreases\\n                tail.put(i-1, tail.get(i-1) - 1);\\n                // the number of sequences ended with i increases\\n                tail.put(i, tail.getOrDefault(i, 0) + 1);\\n                // we used one number i, decrease the freq\\n                freq.put(i, freq.get(i) - 1);\\n            } else {\\n                // there is no such subsequence that is ended with i-1\\n                // we build a new subsequence start with i,\\n                // we then need i + 1 and i + 2 to make a valid subsequence\\n                if (freq.get(i+1) != null && freq.get(i+1) > 0 && \\n                    freq.get(i+2) != null && freq.get(i+2) > 0) {\\n                    // if we have available i + 1 and i + 2\\n                    // we now have one more subsequence ended with i+2\\n                    tail.put(i+2, tail.getOrDefault(i+2, 0) + 1);\\n                    // decrease the frequency\\n                    freq.put(i, freq.get(i) - 1);\\n                    freq.put(i + 1, freq.get(i + 1) - 1);\\n                    freq.put(i + 2, freq.get(i + 2) - 1);\\n                } else {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossible(int[] nums) {\\n        // greedy algorithm\\n        if (nums == null || nums.length < 3)\\n            return false;\\n        \\n        // map to save the frequency of each number\\n        Map<Integer, Integer> freq = new HashMap<>();\\n        \\n        // map to save that the number of subsequences that are\\n        // ended with number i\\n        Map<Integer, Integer> tail = new HashMap<>();\\n        \\n        // first pass, fill teh freq map\\n        for (int i : nums) {\\n            freq.put(i, freq.getOrDefault(i, 0) + 1);\\n        }\\n        \\n        // second pass:\\n        for (int i : nums) {\\n            // there is no such number available\\n            if (freq.get(i) == 0) {\\n                continue;\\n            }\\n            // if there is some subsequence that is ended with i - 1:\\n            // then we can put the number i in the subsequence\\n            if (tail.get(i-1) != null && tail.get(i-1) > 0) {\\n                // the number of sequence ended with i-1 decreases\\n                tail.put(i-1, tail.get(i-1) - 1);\\n                // the number of sequences ended with i increases\\n                tail.put(i, tail.getOrDefault(i, 0) + 1);\\n                // we used one number i, decrease the freq\\n                freq.put(i, freq.get(i) - 1);\\n            } else {\\n                // there is no such subsequence that is ended with i-1\\n                // we build a new subsequence start with i,\\n                // we then need i + 1 and i + 2 to make a valid subsequence\\n                if (freq.get(i+1) != null && freq.get(i+1) > 0 && \\n                    freq.get(i+2) != null && freq.get(i+2) > 0) {\\n                    // if we have available i + 1 and i + 2\\n                    // we now have one more subsequence ended with i+2\\n                    tail.put(i+2, tail.getOrDefault(i+2, 0) + 1);\\n                    // decrease the frequency\\n                    freq.put(i, freq.get(i) - 1);\\n                    freq.put(i + 1, freq.get(i + 1) - 1);\\n                    freq.put(i + 2, freq.get(i + 2) - 1);\\n                } else {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2586004,
                "title": "c-easy-solution",
                "content": "\\tpublic class Solution {\\n\\t\\tpublic bool IsPossible(int[] nums) {\\n\\t\\t\\tvar freq = new Dictionary<int, int>();\\n\\t\\t\\tvar hmap = new Dictionary<int, int>();\\n\\t\\t\\tforeach(var num in nums) {\\n\\t\\t\\t\\tif(!freq.ContainsKey(num))\\n\\t\\t\\t\\t\\tfreq[num] = 0;\\n\\n\\t\\t\\t\\tfreq[num]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int i = 0; i < nums.Length; i++) {\\n\\t\\t\\t\\tif(freq[nums[i]] > 0) {\\n\\t\\t\\t\\t\\tfreq[nums[i]]--;\\n\\t\\t\\t\\t\\tif(hmap.ContainsKey(nums[i]) && hmap[nums[i]] > 0) {\\n\\t\\t\\t\\t\\t\\thmap[nums[i]]--;\\n\\t\\t\\t\\t\\t\\tif(!hmap.ContainsKey(nums[i] + 1))\\n\\t\\t\\t\\t\\t\\t\\t\\thmap[nums[i] + 1] = 0;\\n\\t\\t\\t\\t\\t\\t\\thmap[nums[i] + 1]++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\tif(freq.ContainsKey(nums[i] + 1) && freq.ContainsKey(nums[i] + 2) && freq[nums[i] + 1] > 0 && freq[nums[i] + 2] > 0) {\\n\\t\\t\\t\\t\\t\\t\\tfreq[nums[i] + 1]--;\\n\\t\\t\\t\\t\\t\\t\\tfreq[nums[i] + 2]--;\\n\\t\\t\\t\\t\\t\\t\\tif(!hmap.ContainsKey(nums[i] + 3))\\n\\t\\t\\t\\t\\t\\t\\t\\thmap[nums[i] + 3] = 0;\\n\\t\\t\\t\\t\\t\\t\\thmap[nums[i] + 3]++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic bool IsPossible(int[] nums) {\\n\\t\\t\\tvar freq = new Dictionary<int, int>();\\n\\t\\t\\tvar hmap = new Dictionary<int, int>();\\n\\t\\t\\tforeach(var num in nums) {\\n\\t\\t\\t\\tif(!freq.ContainsKey(num))\\n\\t\\t\\t\\t\\tfreq[num] = 0;\\n\\n\\t\\t\\t\\tfreq[num]++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2447202,
                "title": "c-counting-sort-greedy-explanation",
                "content": "**Ex:** 1 **2 2 2** 3 3 3 3 **4 4 4 4 4** 5 5 5 **6 6**\\ncnt[] = {1, 3, 4, 5, 3, 2}.\\nEach step, find the first ascending subsequence with the first element different 0.\\nIf, the length of that subsequence less than 3, return **false.**\\nOtherwise, decrease 1 for all elements of that subsequence.\\ns1: **1, 3, 4, 5**, 3, 2: => **0, 2, 3, 4**, 3, 2\\ns2: 0, **2, 3, 4**, 3, 2 => 0, **1, 2, 3**, 3, 2\\ns3: 0, **1, 2, 3, 3**, 2 => 0, **0, 1, 2, 2**, 2\\ns4: 0, 0, **1, 2, 2, 2** => 0, 0, **0, 1, 1, 1**\\ns5: 0, 0, 0, **1, 1, 1** => 0, 0, 0, **0, 0, 0**\\n\\nif all elements of cnt is 0 => return **true.**\\notherwise, return **false.**\\n\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        vector<int> cnt (2001, 0);\\n        for (int& n : nums) cnt[n + 1000]++;\\n        \\n        for (int i = 0; i <= 1998; i++) {\\n            if (cnt[i] == 0) continue;\\n            while (cnt[i]) {\\n                int c = 0;\\n                while (cnt[i+c] <= cnt[i+c+1]) {\\n                    cnt[i+c]--;\\n                    c++;\\n                }\\n            \\n                cnt[i+c]--;\\n                c++;\\n                //cout<<i<<\" \"<<c<<endl;\\n                if (c < 3) return false;\\n            }\\n        }\\n        if (cnt[1999] or cnt[2000]) return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        vector<int> cnt (2001, 0);\\n        for (int& n : nums) cnt[n + 1000]++;\\n        \\n        for (int i = 0; i <= 1998; i++) {\\n            if (cnt[i] == 0) continue;\\n            while (cnt[i]) {\\n                int c = 0;\\n                while (cnt[i+c] <= cnt[i+c+1]) {\\n                    cnt[i+c]--;\\n                    c++;\\n                }\\n            \\n                cnt[i+c]--;\\n                c++;\\n                //cout<<i<<\" \"<<c<<endl;\\n                if (c < 3) return false;\\n            }\\n        }\\n        if (cnt[1999] or cnt[2000]) return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2448247,
                "title": "short-c-java-python-explained-solution-beginner-friendly-by-mr-coder",
                "content": "**Please UPVOTE if you LIKE!!**\\n\\n\\n\\nhttps://t.me/dsacoder  \\u2B05\\u2B05 **Telegram link** to discuss leetcode daily questions and other dsa problems\\n\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        unordered_map<int, int> freq;\\n        for(int i: nums)\\n            freq[i]++;\\n        unordered_map<int, int> sublast;\\n        for(int i=0; i< nums.size();i++){\\n            if(freq[nums[i]]==0) continue;\\n            \\n            if(sublast[nums[i]-1]>0){\\n                freq[nums[i]]--;\\n                sublast[nums[i]-1]--;\\n                sublast[nums[i]]++;\\n              \\n            }\\n            else if(freq[nums[i]+1]>0 && freq[nums[i]+2]>0)\\n            {   freq[nums[i]]--;\\n                freq[nums[i]+1]--;\\n                freq[nums[i]+2]--;\\n                sublast[nums[i]+2]++;\\n              \\n            }\\n            \\n            \\n            \\n            \\n            else\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n**PYTHON**(copied)- https://leetcode.com/problems/split-array-into-consecutive-subsequences/discuss/2447651/Python-Easy-Fast-with-comments\\n\\n```\\nclass Solution:\\n    # Maintain 2 hashmaps\\n    # First one stores the frequency of each num in nums\\n    # Second one stores 3 or more length subarrays of nums ending with a particular num\\n    # Cases when we iterate to a n in nums - \\n    # 1. there alredy exists a subarray ending with n - 1 -> add n to it\\n    # 2. there is no n - 1 ending subarray present - > create one subarray of n, n + 1, n + 2\\n    # 3. n + 1 and n + 2 are not present - > answer not possible return False\\n    # If all above cases pass without returning false you have a valid nums which can be divided hence return True\\n    \\n    def isPossible(self, nums: List[int]) -> bool:\\n        hm1 = Counter(nums)\\n        hm2 = defaultdict(int)\\n        \\n        for num in nums:\\n            if hm1[num] == 0: continue\\n            \\n            if num - 1 in hm2 and hm2[num - 1] > 0:\\n                hm2[num - 1] -= 1\\n                hm2[num] += 1\\n            \\n            elif num + 1 in hm1 and num + 2 in hm1 and hm1[num + 1] > 0 and hm1[num + 2] > 0:\\n                hm2[num + 2] += 1\\n                hm1[num + 1] -= 1\\n                hm1[num + 2] -= 1\\n            \\n            else:\\n                return False\\n            \\n            hm1[num] -= 1\\n        \\n        return True\\n```\\n**JAVA**(copied)-https://leetcode.com/problems/split-array-into-consecutive-subsequences/discuss/2447698/C%2B%2BJAVA-or-With-Example-and-Explanation-or-Approach\\n```\\nclass Solution {\\n    public boolean isPossible(int[] nums) {\\n        Map<Integer,Integer> availability = new HashMap<>();\\n        Map<Integer,Integer> possibility = new HashMap<>();\\n        for(int num:nums){\\n            availability.put(num,availability.getOrDefault(num,0)+1);\\n        }\\n        for(int num:nums){\\n            if(availability.get(num)==0)continue;\\n            if(possibility.getOrDefault(num,0)>0){\\n                possibility.put(num,possibility.getOrDefault(num,0)-1);\\n                possibility.put(num+1,possibility.getOrDefault(num+1,0)+1);\\n            }\\n            else if(availability.getOrDefault(num+1,0)>0 && availability.getOrDefault(num+2,0)>0 ){\\n                possibility.put(num+3,possibility.getOrDefault(num+3,0)+1);\\n                availability.put(num+1,availability.getOrDefault(num+1,0)-1);\\n                availability.put(num+2,availability.getOrDefault(num+2,0)-1);\\n            }\\n            else{\\n                return false;\\n            }\\n            availability.put(num,availability.get(num)-1);\\n        }\\n        return true;\\n    }\\n}\\n```\\n**Please UPVOTE  to motivate me for solving more questions like this and clubbing all languages solution!!**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        unordered_map<int, int> freq;\\n        for(int i: nums)\\n            freq[i]++;\\n        unordered_map<int, int> sublast;\\n        for(int i=0; i< nums.size();i++){\\n            if(freq[nums[i]]==0) continue;\\n            \\n            if(sublast[nums[i]-1]>0){\\n                freq[nums[i]]--;\\n                sublast[nums[i]-1]--;\\n                sublast[nums[i]]++;\\n              \\n            }\\n            else if(freq[nums[i]+1]>0 && freq[nums[i]+2]>0)\\n            {   freq[nums[i]]--;\\n                freq[nums[i]+1]--;\\n                freq[nums[i]+2]--;\\n                sublast[nums[i]+2]++;\\n              \\n            }\\n            \\n            \\n            \\n            \\n            else\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    # Maintain 2 hashmaps\\n    # First one stores the frequency of each num in nums\\n    # Second one stores 3 or more length subarrays of nums ending with a particular num\\n    # Cases when we iterate to a n in nums - \\n    # 1. there alredy exists a subarray ending with n - 1 -> add n to it\\n    # 2. there is no n - 1 ending subarray present - > create one subarray of n, n + 1, n + 2\\n    # 3. n + 1 and n + 2 are not present - > answer not possible return False\\n    # If all above cases pass without returning false you have a valid nums which can be divided hence return True\\n    \\n    def isPossible(self, nums: List[int]) -> bool:\\n        hm1 = Counter(nums)\\n        hm2 = defaultdict(int)\\n        \\n        for num in nums:\\n            if hm1[num] == 0: continue\\n            \\n            if num - 1 in hm2 and hm2[num - 1] > 0:\\n                hm2[num - 1] -= 1\\n                hm2[num] += 1\\n            \\n            elif num + 1 in hm1 and num + 2 in hm1 and hm1[num + 1] > 0 and hm1[num + 2] > 0:\\n                hm2[num + 2] += 1\\n                hm1[num + 1] -= 1\\n                hm1[num + 2] -= 1\\n            \\n            else:\\n                return False\\n            \\n            hm1[num] -= 1\\n        \\n        return True\\n```\n```\\nclass Solution {\\n    public boolean isPossible(int[] nums) {\\n        Map<Integer,Integer> availability = new HashMap<>();\\n        Map<Integer,Integer> possibility = new HashMap<>();\\n        for(int num:nums){\\n            availability.put(num,availability.getOrDefault(num,0)+1);\\n        }\\n        for(int num:nums){\\n            if(availability.get(num)==0)continue;\\n            if(possibility.getOrDefault(num,0)>0){\\n                possibility.put(num,possibility.getOrDefault(num,0)-1);\\n                possibility.put(num+1,possibility.getOrDefault(num+1,0)+1);\\n            }\\n            else if(availability.getOrDefault(num+1,0)>0 && availability.getOrDefault(num+2,0)>0 ){\\n                possibility.put(num+3,possibility.getOrDefault(num+3,0)+1);\\n                availability.put(num+1,availability.getOrDefault(num+1,0)-1);\\n                availability.put(num+2,availability.getOrDefault(num+2,0)-1);\\n            }\\n            else{\\n                return false;\\n            }\\n            availability.put(num,availability.get(num)-1);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447538,
                "title": "easiest-detailed-explained-no-priority-queque-and-hasmaps-only-array-and-greedy",
                "content": "The code is self explanatory what we are doing is explained in the comments;\\n**Please upvote if it helps.\\nThanks**\\n```\\nFor input  : [1,2,3,5,5,6,7]\\n```\\nOur array will go like this \\n{1, 1}\\n{2, 2} // means 1, 2 are subsequnece\\n{3, 3} // means 1, 2, and 3 are subsequence\\nfor input 5, 4 is not there so we have start another subsequnce from 5 with length 1\\n{{3, 3}, {5, 1}};\\nwhen next five we cant make subsequence with it so will j == -1 and we will return false from there\\n\\nNow suppose the input is\\n```\\n[1,2,3,3,4,4,5,5]\\n```\\n\\nfor index upto 2 arr will look like this\\n{{3, 3}} -> 1, 2, 3 as subsequence\\nfor index 3 we will have to start new subsequence as can\\'t go with prev subseq \\n{{3, 3}, {3, 1}} \\nindex = 4\\nnow 4 is greater than 3 and we are travelling from last so will update \\n{{3, 3}, {4,2}} -> 1, 2, 3\\n\\t\\t\\t\\t\\t-> 3, 4\\n\\nindex = 5\\nnow again 4 is smaller than last so we are going towards left and found 3 is less than 4 so we will update here\\n{{4, 4}, {4, 2}} -> 1, 2, 3, 4\\n\\t\\t\\t\\t\\t-> 3, 4\\n\\nnow i think rest of it is clear.....\\n\\n\\n\\n```\\n\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        vector<pair<int, int>> arr;\\n        arr.push_back({nums[0], 1});\\n        for(int i = 1; i<nums.size(); i++){\\n            int j = arr.size()-1;\\n            while(j>=0 && nums[i] <=arr[j].first){\\n                j--;\\n            }\\n            if(j == -1){\\n                arr.push_back({nums[i], 1}); // if no element is less than current number\\n            }\\n            else{\\n                if(arr[j].first -nums[i]<-1){\\n                    arr.push_back({nums[i], 1}); // if element is less than current number but difference is greater than 1\\n                }\\n                else{\\n                    arr[j].first = nums[i]; // if element is less than current number by 1 \\n                    arr[j].second++; // increasing subsequence length by 1\\n                }\\n                \\n            }\\n        }\\n        bool f= false;\\n        for(auto a : arr){\\n           //cout<<a.first<<\" \"<<a.second<<endl;\\n            if(a.second <3)return false; some may be of only 2 and 1 size so we are returning false\\n        }\\n        return true;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nFor input  : [1,2,3,5,5,6,7]\\n```\n```\\n[1,2,3,3,4,4,5,5]\\n```\n```\\n\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        vector<pair<int, int>> arr;\\n        arr.push_back({nums[0], 1});\\n        for(int i = 1; i<nums.size(); i++){\\n            int j = arr.size()-1;\\n            while(j>=0 && nums[i] <=arr[j].first){\\n                j--;\\n            }\\n            if(j == -1){\\n                arr.push_back({nums[i], 1}); // if no element is less than current number\\n            }\\n            else{\\n                if(arr[j].first -nums[i]<-1){\\n                    arr.push_back({nums[i], 1}); // if element is less than current number but difference is greater than 1\\n                }\\n                else{\\n                    arr[j].first = nums[i]; // if element is less than current number by 1 \\n                    arr[j].second++; // increasing subsequence length by 1\\n                }\\n                \\n            }\\n        }\\n        bool f= false;\\n        for(auto a : arr){\\n           //cout<<a.first<<\" \"<<a.second<<endl;\\n            if(a.second <3)return false; some may be of only 2 and 1 size so we are returning false\\n        }\\n        return true;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2447905,
                "title": "two-maps-clean",
                "content": "#### Java\\n\\n```java\\npublic boolean isPossible(int[] nums) {\\n        Map<Integer, Integer> notPlacedCount = new HashMap<>();   // entry = {num, count of unplaced nums}\\n        Map<Integer, Integer> sequenceEndCount = new HashMap<>(); // entry = {num, count of sequences ending at num}\\n\\n        for (int num : nums) increaseCount(notPlacedCount, num);\\n\\n        for (int num : nums) {\\n            boolean alreadyContains = notPlacedCount.get(num) == 0;\\n            boolean canAddToExisting = sequenceEndCount.getOrDefault(num - 1, 0) > 0;\\n            boolean canAddNewSequence = notPlacedCount.getOrDefault(num + 1, 0) > 0 && notPlacedCount.getOrDefault(num + 2, 0) > 0;\\n\\n            if (alreadyContains)\\n                continue;\\n\\n            if (canAddToExisting) {\\n                decreaseCount(notPlacedCount, num);\\n                decreaseCount(sequenceEndCount, num - 1);\\n                increaseCount(sequenceEndCount, num);\\n            }\\n\\n            else if (canAddNewSequence) {\\n                decreaseCount(notPlacedCount, num);\\n                decreaseCount(notPlacedCount, num + 1);\\n                decreaseCount(notPlacedCount, num + 2);\\n                increaseCount(sequenceEndCount, num + 2);\\n            }\\n\\n            else\\n                return false;\\n        }\\n        return true;\\n    }\\n\\n    private void increaseCount(Map<Integer, Integer> countMap, int num) {\\n        countMap.put(num, countMap.getOrDefault(num, 0) + 1);\\n    }\\n\\n    private void decreaseCount(Map<Integer, Integer> countMap, int num) {\\n        countMap.put(num, countMap.get(num) - 1);\\n    }\\n```\\n\\n\\n#### C++\\n\\n```c++\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        unordered_map<int, int> notPlacedCount;     // entry = {num, count of unplaced nums}\\n        unordered_map<int, int> sequenceEndCount;   // entry = {num, count of sequences ending at num}\\n\\n        for (int num : nums) notPlacedCount[num]++;\\n\\n        for (int num : nums) {\\n            bool alreadyContains = notPlacedCount[num] == 0;\\n            bool canAddToExisting = sequenceEndCount[num - 1] > 0;\\n            bool canAddNewSequence = notPlacedCount[num + 1] > 0 && notPlacedCount[num + 2] > 0;\\n\\n            if (alreadyContains)\\n                continue;\\n\\n            if (canAddToExisting) {\\n                notPlacedCount[num]--;\\n                sequenceEndCount[num - 1]--;\\n                sequenceEndCount[num]++;\\n            }\\n\\n            else if (canAddNewSequence) {\\n                notPlacedCount[num]--;\\n                notPlacedCount[num + 1]--;\\n                notPlacedCount[num + 2]--;\\n                sequenceEndCount[num + 2]++;\\n            }\\n\\n            else\\n                return false;\\n        }\\n        return true; \\n    }\\n```\\n\\nMy repositories with leetcode problems solving - [Java](https://github.com/FLlGHT/algorithms/tree/master/j-algorithms/src/main/java),  [C++](https://github.com/FLlGHT/algorithms/tree/master/c-algorithms/src/main/c%2B%2B)",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```java\\npublic boolean isPossible(int[] nums) {\\n        Map<Integer, Integer> notPlacedCount = new HashMap<>();   // entry = {num, count of unplaced nums}\\n        Map<Integer, Integer> sequenceEndCount = new HashMap<>(); // entry = {num, count of sequences ending at num}\\n\\n        for (int num : nums) increaseCount(notPlacedCount, num);\\n\\n        for (int num : nums) {\\n            boolean alreadyContains = notPlacedCount.get(num) == 0;\\n            boolean canAddToExisting = sequenceEndCount.getOrDefault(num - 1, 0) > 0;\\n            boolean canAddNewSequence = notPlacedCount.getOrDefault(num + 1, 0) > 0 && notPlacedCount.getOrDefault(num + 2, 0) > 0;\\n\\n            if (alreadyContains)\\n                continue;\\n\\n            if (canAddToExisting) {\\n                decreaseCount(notPlacedCount, num);\\n                decreaseCount(sequenceEndCount, num - 1);\\n                increaseCount(sequenceEndCount, num);\\n            }\\n\\n            else if (canAddNewSequence) {\\n                decreaseCount(notPlacedCount, num);\\n                decreaseCount(notPlacedCount, num + 1);\\n                decreaseCount(notPlacedCount, num + 2);\\n                increaseCount(sequenceEndCount, num + 2);\\n            }\\n\\n            else\\n                return false;\\n        }\\n        return true;\\n    }\\n\\n    private void increaseCount(Map<Integer, Integer> countMap, int num) {\\n        countMap.put(num, countMap.getOrDefault(num, 0) + 1);\\n    }\\n\\n    private void decreaseCount(Map<Integer, Integer> countMap, int num) {\\n        countMap.put(num, countMap.get(num) - 1);\\n    }\\n```\n```c++\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        unordered_map<int, int> notPlacedCount;     // entry = {num, count of unplaced nums}\\n        unordered_map<int, int> sequenceEndCount;   // entry = {num, count of sequences ending at num}\\n\\n        for (int num : nums) notPlacedCount[num]++;\\n\\n        for (int num : nums) {\\n            bool alreadyContains = notPlacedCount[num] == 0;\\n            bool canAddToExisting = sequenceEndCount[num - 1] > 0;\\n            bool canAddNewSequence = notPlacedCount[num + 1] > 0 && notPlacedCount[num + 2] > 0;\\n\\n            if (alreadyContains)\\n                continue;\\n\\n            if (canAddToExisting) {\\n                notPlacedCount[num]--;\\n                sequenceEndCount[num - 1]--;\\n                sequenceEndCount[num]++;\\n            }\\n\\n            else if (canAddNewSequence) {\\n                notPlacedCount[num]--;\\n                notPlacedCount[num + 1]--;\\n                notPlacedCount[num + 2]--;\\n                sequenceEndCount[num + 2]++;\\n            }\\n\\n            else\\n                return false;\\n        }\\n        return true; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 106521,
                "title": "c-dp-easy-to-understand-o-n-time-o-1-space",
                "content": "I feel this problem hard. The idea here is DP.\\n\\n1) If numbers are not continuous, I check each segment. For example, 1,2,3,3,4,5,    9,10,11;\\n2) Count frequency of each continuous number. Note the value of numbers doesn't matter.\\n3) DP part. I use parameter \"ones\" for subsequences with length 1 ending with index i, \"twos\" for subsequences with length 2 ending with index i, and \"tot\" for all subsequences ending with index i. \\nWhen processing next number, if the frequency of new number mp[i+1] < ones+twos, there is no way to split, return false. \\nIn a greedy way, we need append the new number to short sequences first.  So\\ntwos[i+1] = ones[i]; \\nones[i+1] = mp[i+1]-tot,  i.e. the extra new number\\nIf it is possible to split, ones and twos would be 0 by the end of the loop.\\n\\nThe run time is clearly O(n).\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        int n = nums.size(), k = 0;\\n        //if nums are not continuous, check each section\\n        //for example, 1,2,3, 6,7,8;\\n        for (int i = 1; i < n; i++) {\\n            if (nums[i]-nums[i-1] > 1) {\\n                if (!check(nums, k, i-1)) \\n                    return false;\\n                k = i;\\n            }\\n        }\\n        return check(nums, k, n-1);\\n    }\\nprivate:\\n    bool check(vector<int>& nums, int s, int e) {\\n        int n = nums[e]-nums[s]+1;\\n        // count frequency of each number\\n        vector<int> mp(n, 0);\\n        for (int i = s, tmp = nums[s]; i <= e; i++)\\n            mp[nums[i]-tmp]++;\\n        // ones is subsequences with length 1 ending with index i-1\\n        // twos is subsequences with length 2 ending with index i-1\\n        // tot  is all subsequences ending with index i-1\\n        // initially ones[0] ending with index -1, i.e. nonexistent \\n        vector<int> ones(n+1, 0), twos(n+1, 0), tot(n+1, 0);\\n        for (int i = 0; i < n; i++) {\\n            // we need at least ones+twos new number to make consecutive sequence\\n            // for examle, two 2, five 1,2, we need at least seven 3\\n            if (mp[i] < ones[i] + twos[i]) return false;\\n            // Greedy, appending to short sequences first\\n            // so twos = ones, and new ones is the extra new number\\n            twos[i+1] = ones[i];\\n            ones[i+1] = max(0, mp[i]-tot[i]);\\n            tot[i+1] = mp[i];\\n        }\\n        // if no subsequence length <= 2, return true\\n        return ones[n] == 0 && twos[n] == 0;\\n    }\\n};\\n```\\nSame code but O(1) space\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        int n = nums.size(), k = 0;\\n        for (int i = 1; i < n; i++) {\\n            if (nums[i]-nums[i-1] > 1) {\\n                if (!check(nums, k, i)) \\n                    return false;\\n                k = i;\\n            }\\n        }\\n        return check(nums, k, n);\\n    }\\nprivate:\\n    bool check(vector<int>& nums, int s, int e) {\\n        int ones = 0, twos = 0, tot = 0;\\n        for (int i = s+1, cnt = 1; i <= e; i++) {\\n            if (i < e && nums[i] == nums[i-1])\\n                cnt++;\\n            else {\\n                if (cnt < ones + twos) return false;\\n                twos = ones;\\n                ones = max(0, cnt-tot);\\n                tot = cnt;\\n                cnt = 1;\\n            }\\n        }\\n        return ones == 0 && twos == 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        int n = nums.size(), k = 0;\\n        //if nums are not continuous, check each section\\n        //for example, 1,2,3, 6,7,8;\\n        for (int i = 1; i < n; i++) {\\n            if (nums[i]-nums[i-1] > 1) {\\n                if (!check(nums, k, i-1)) \\n                    return false;\\n                k = i;\\n            }\\n        }\\n        return check(nums, k, n-1);\\n    }\\nprivate:\\n    bool check(vector<int>& nums, int s, int e) {\\n        int n = nums[e]-nums[s]+1;\\n        // count frequency of each number\\n        vector<int> mp(n, 0);\\n        for (int i = s, tmp = nums[s]; i <= e; i++)\\n            mp[nums[i]-tmp]++;\\n        // ones is subsequences with length 1 ending with index i-1\\n        // twos is subsequences with length 2 ending with index i-1\\n        // tot  is all subsequences ending with index i-1\\n        // initially ones[0] ending with index -1, i.e. nonexistent \\n        vector<int> ones(n+1, 0), twos(n+1, 0), tot(n+1, 0);\\n        for (int i = 0; i < n; i++) {\\n            // we need at least ones+twos new number to make consecutive sequence\\n            // for examle, two 2, five 1,2, we need at least seven 3\\n            if (mp[i] < ones[i] + twos[i]) return false;\\n            // Greedy, appending to short sequences first\\n            // so twos = ones, and new ones is the extra new number\\n            twos[i+1] = ones[i];\\n            ones[i+1] = max(0, mp[i]-tot[i]);\\n            tot[i+1] = mp[i];\\n        }\\n        // if no subsequence length <= 2, return true\\n        return ones[n] == 0 && twos[n] == 0;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        int n = nums.size(), k = 0;\\n        for (int i = 1; i < n; i++) {\\n            if (nums[i]-nums[i-1] > 1) {\\n                if (!check(nums, k, i)) \\n                    return false;\\n                k = i;\\n            }\\n        }\\n        return check(nums, k, n);\\n    }\\nprivate:\\n    bool check(vector<int>& nums, int s, int e) {\\n        int ones = 0, twos = 0, tot = 0;\\n        for (int i = s+1, cnt = 1; i <= e; i++) {\\n            if (i < e && nums[i] == nums[i-1])\\n                cnt++;\\n            else {\\n                if (cnt < ones + twos) return false;\\n                twos = ones;\\n                ones = max(0, cnt-tot);\\n                tot = cnt;\\n                cnt = 1;\\n            }\\n        }\\n        return ones == 0 && twos == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2450775,
                "title": "java-very-easy-dp-solution-map-priority-queue",
                "content": "```\\nclass Solution {\\n    public boolean isPossible(int[] nums) {\\n        Map<Integer, PriorityQueue<Integer>>lastElements = new HashMap<>();\\n        for (int element: nums){\\n            int subseqCount = 0;\\n            if (lastElements.containsKey(element-1)){\\n                subseqCount = lastElements.get(element-1).poll();\\n                if (lastElements.get(element-1).isEmpty()) lastElements.remove(element-1);\\n            }\\n            lastElements.putIfAbsent(element, new PriorityQueue<>());\\n            lastElements.get(element).add(subseqCount+1);\\n        }\\n        for (Map.Entry<Integer,PriorityQueue<Integer>>entry: lastElements.entrySet()){\\n            while (!entry.getValue().isEmpty()){\\n                if (entry.getValue().poll()<3)return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossible(int[] nums) {\\n        Map<Integer, PriorityQueue<Integer>>lastElements = new HashMap<>();\\n        for (int element: nums){\\n            int subseqCount = 0;\\n            if (lastElements.containsKey(element-1)){\\n                subseqCount = lastElements.get(element-1).poll();\\n                if (lastElements.get(element-1).isEmpty()) lastElements.remove(element-1);\\n            }\\n            lastElements.putIfAbsent(element, new PriorityQueue<>());\\n            lastElements.get(element).add(subseqCount+1);\\n        }\\n        for (Map.Entry<Integer,PriorityQueue<Integer>>entry: lastElements.entrySet()){\\n            while (!entry.getValue().isEmpty()){\\n                if (entry.getValue().poll()<3)return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2449088,
                "title": "visualize-vector-as-priority-queue-o-n-approach-without-using-hashmap",
                "content": "**Question Explanation**\\nWe\\'re given with a sorted list of integers (might contain duplicates) in ascending order. We\\'ve to return whether the given list can be split into one or more subsequences such that each one is a consecutive increasing sequence and has minimum length of 3.\\n\\n```\\nExample:\\n[1,2,3,3,4,4,5,5] can be split into [1,2,3,4,5] & [3,4,5]. But,\\n[1,2,3,5,5,6,7] can\\'t be split like [1,2,3,5] & [5,6,7] because 3 and 5 are not consecutive (3+1 != 5).\\n```\\n\\n**Intuition**\\nWe can observe that there is no restriction on the number of subsequences that we can generate. Hence, we will traverse the given array and try to push the elements in a single subsequence until we encounter a number which is not consecutive to the previous one. In that case, we can initialize another subsequence with the current element as the starting integer.\\n\\n**Edge Cases**\\n1. If the input array has length less than 3 then it\\'ll not satisfy the condition.\\n2. If the list contains duplicates then we\\'ve to check on which subsequence to append our current element.\\n\\n**Approach**\\nWe\\'ll initialize a `vector<pair<int,int>> v` to store different subsequences. Each pair `v[i]` denotes `{last element, length}` of `ith` subsequence. The vector will store `{nums[0],1}` at the beginning.\\nWe\\'ll iterate `nums` from `1st index` and check whether `nums[i]` is consecutive to the last element.\\n**Case I:** If `nums[i]` is consecutive, then we\\'ll update the pair of vector with the last element as `nums[i]` and increase the length by `1`. It can be visualized as priority queue where the top element has been popped out and updated pair is pushed in.\\n**Case II:** If `nums[i]` comes out to be equal to the last element (*i.e. duplicate*), we\\'ll iterate our vector from end to check whether `nums[i]` can be the next consecutive element of some other subsequence. If we find such a pair, then we\\'ll update it\\'s value, else, we\\'re left with no other option than generating a new subsequence. Here comes the benefit of using vector than `C++ STL priority_queue` that we can traverse the previous elements without popping out the top elements in the queue.\\n**Case III:** If none of the conditions above is true, that means `nums[i]` has to be the starting element of a new subsequence. Hence,  we `push_back`  `{nums[i],1}` in the vector. It can be visualized as pushing a pair in the priority queue.\\nAfter the traversal of `nums` is completed, we\\'ll iterate through the vector and check whether `v[i].second` (*i.e. length of that subsequence*) is greater than 3.\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        if (n < 3) {    // Edge Case #1\\n            return false;\\n        }\\n        \\n        vector<pair<int,int>> v = {{nums[0],1}};\\n        \\n        for (int i = 1; i < n; i++) {\\n            int sz = v.size();\\n            pair<int,int> end = v[sz-1];\\n            \\n            if (nums[i] == end.first+1) {\\n                v[sz-1].first++;\\n                v[sz-1].second++;\\n            }\\n            else if (nums[i] == end.first) {   // Edge Case #2\\n                bool found = false;\\n                for (int k = sz-2; k >= 0; k--) {\\n                    if (nums[i] == v[k].first+1) {\\n                        found = true;\\n                        v[k].first++;\\n                        v[k].second++;\\n                        break;\\n                    }\\n                }\\n                if (!found) {\\n                    v.push_back({nums[i],1});    \\n                }\\n            }\\n            else {\\n                v.push_back({nums[i],1});\\n            }\\n        }\\n        \\n        for (auto &it: v) {\\n            if (it.second < 3) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\nTC: O(n) since the time taken to traverse back for edge case #2 is not considerable\\n(In worst case, when not a single pair of consecutive integers exist it will be O(n^2))\\nSC: O(n) for the vector v to store the subsequences (in worst case it will be n)\\n```",
                "solutionTags": [
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nExample:\\n[1,2,3,3,4,4,5,5] can be split into [1,2,3,4,5] & [3,4,5]. But,\\n[1,2,3,5,5,6,7] can\\'t be split like [1,2,3,5] & [5,6,7] because 3 and 5 are not consecutive (3+1 != 5).\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        if (n < 3) {    // Edge Case #1\\n            return false;\\n        }\\n        \\n        vector<pair<int,int>> v = {{nums[0],1}};\\n        \\n        for (int i = 1; i < n; i++) {\\n            int sz = v.size();\\n            pair<int,int> end = v[sz-1];\\n            \\n            if (nums[i] == end.first+1) {\\n                v[sz-1].first++;\\n                v[sz-1].second++;\\n            }\\n            else if (nums[i] == end.first) {   // Edge Case #2\\n                bool found = false;\\n                for (int k = sz-2; k >= 0; k--) {\\n                    if (nums[i] == v[k].first+1) {\\n                        found = true;\\n                        v[k].first++;\\n                        v[k].second++;\\n                        break;\\n                    }\\n                }\\n                if (!found) {\\n                    v.push_back({nums[i],1});    \\n                }\\n            }\\n            else {\\n                v.push_back({nums[i],1});\\n            }\\n        }\\n        \\n        for (auto &it: v) {\\n            if (it.second < 3) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\nTC: O(n) since the time taken to traverse back for edge case #2 is not considerable\\n(In worst case, when not a single pair of consecutive integers exist it will be O(n^2))\\nSC: O(n) for the vector v to store the subsequences (in worst case it will be n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 106538,
                "title": "python-o-n-straightforward-solution",
                "content": "First, let's break up the problem into groups based on if elements are adjacent.  These are disjoint subproblems that don't interfere with each other since each subsequence cannot be in more than one group, so we can solve them separately.\\n\\nNow, for each group of consecutive elements, we'll work with how many copies of each element there is.  For example, if we have ```[1, 2, 3, 3, 4, 4, 4, 5, 6, 7, 7]```, then the copies are ```chunk = [1, 1, 2, 3, 1, 1, 2]```.\\n\\nThe key idea is: if we go from say, two copies of 10 to five copies of 11, we know that 3 subsequences must have started at 11.  Similarly, if we go from five copies of 11 to three copies of 12, we know that 2 subsequences must have ended at 11.\\n\\nNow knowing the start and ending positions of every subsequence, let's try to pair the k-th starting position with the k-th ending position.  This will make the minimum sized subsequence as long as possible.  If they are all legal subsequences, it's possible; otherwise, it's impossible.\\n\\nNote that this solution can easily be modified to change the minimum of ```K = 3``` to any minimum, by changing ```s+2```.  Also note that in the above argument, there could have been more starting and ending positions, but adding more will only make some subsequences smaller, so we don't need to consider those cases.\\n\\n```\\ndef isPossible(self, A):\\n    counts = [(x, len(list(group)))\\n              for x, group in itertools.groupby(A)]\\n\\n    def possible(chunk):\\n        starts, ends = [], []\\n        prev_count = 0\\n        for time, count in enumerate(chunk):\\n            if count > prev_count:\\n                starts.extend([time] * (count - prev_count))\\n            elif count < prev_count:\\n                ends.extend([time-1] * (prev_count - count))\\n            prev_count = count\\n\\n        ends.extend([time] * count)\\n        return all(e >= s+2 for s, e in zip(starts, ends))\\n\\n    chunk = []\\n    prev = None\\n    for x, count in counts:\\n        if prev is None or x - prev == 1:\\n            chunk.append(count)\\n        else:\\n            if not possible(chunk):\\n                return False\\n            chunk = []\\n        prev = x\\n\\n    return possible(chunk)\\n```",
                "solutionTags": [],
                "code": "```[1, 2, 3, 3, 4, 4, 4, 5, 6, 7, 7]```\n```chunk = [1, 1, 2, 3, 1, 1, 2]```\n```K = 3```\n```s+2```\n```\\ndef isPossible(self, A):\\n    counts = [(x, len(list(group)))\\n              for x, group in itertools.groupby(A)]\\n\\n    def possible(chunk):\\n        starts, ends = [], []\\n        prev_count = 0\\n        for time, count in enumerate(chunk):\\n            if count > prev_count:\\n                starts.extend([time] * (count - prev_count))\\n            elif count < prev_count:\\n                ends.extend([time-1] * (prev_count - count))\\n            prev_count = count\\n\\n        ends.extend([time] * count)\\n        return all(e >= s+2 for s, e in zip(starts, ends))\\n\\n    chunk = []\\n    prev = None\\n    for x, count in counts:\\n        if prev is None or x - prev == 1:\\n            chunk.append(count)\\n        else:\\n            if not possible(chunk):\\n                return False\\n            chunk = []\\n        prev = x\\n\\n    return possible(chunk)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 106539,
                "title": "python-solution-using-priorityqueue",
                "content": "I am using a kind of greedy method. `runs` build a map between `tail number` and the current `run length`. For example, for a consecutive seq `3,4,5`, the `key(tail number)` is `5` and length is `3`. \\n\\nThe problem is there might be multiple sub seqs which all end with the same number, but have different length.  like we have another subseq `4,5`. So there are two entries in the value part of `5`:  `runs: {5: [3,2]}`\\n\\nso, when we met a new number `6`, we want to merge it into existing subseqs. Which one should we use? Intuitively, if we pick up the shorter one and append the new number into that, we are more likely to make sure all the seqs are longer than `3`. So I use a PriorityQueue to store these length.\\n\\n```\\nimport heapq\\nclass Solution(object):\\n    def isPossible(self, A):\\n        runs = {} # end -> [lengths]\\n        for v in A:\\n            if v - 1 not in runs:\\n                if v not in runs:\\n                    runs[v] = [1]\\n                else:\\n                    heapq.heappush(runs[v], 1)\\n            else:\\n                length = heapq.heappop(runs[v-1]) + 1\\n                if len(runs[v-1]) == 0:\\n                    del runs[v-1]\\n                if v not in runs:\\n                    runs[v] = []\\n                heapq.heappush(runs[v], length)\\n        for v, arr in runs.items():\\n            if len(arr) > 0 and min(arr) < 3:\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nimport heapq\\nclass Solution(object):\\n    def isPossible(self, A):\\n        runs = {} # end -> [lengths]\\n        for v in A:\\n            if v - 1 not in runs:\\n                if v not in runs:\\n                    runs[v] = [1]\\n                else:\\n                    heapq.heappush(runs[v], 1)\\n            else:\\n                length = heapq.heappop(runs[v-1]) + 1\\n                if len(runs[v-1]) == 0:\\n                    del runs[v-1]\\n                if v not in runs:\\n                    runs[v] = []\\n                heapq.heappush(runs[v], length)\\n        for v, arr in runs.items():\\n            if len(arr) > 0 and min(arr) < 3:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2446860,
                "title": "c-easy-solution-using-map-split-array-into-consecutive-subsequences-100",
                "content": "Split Array into Consecutive Subsequences\\n\\nC++ Solution :\\n\\n```\\n        map<int,int> m,m1;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]]++;\\n        }\\n        for(auto i :nums){\\n            if(m[i]==0)\\n                continue;\\n            m[i]--;\\n            if(m1[i-1]>0){\\n                m1[i-1]--;\\n                m1[i]++;\\n            }\\n            else if(m[i+1]!=0 && m[i+2]!=0){\\n                m[i+1]--;\\n                m[i+2]--;\\n                m1[i+2]++;\\n            }\\n            else\\n                return false;\\n        }\\n        return true;\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n        map<int,int> m,m1;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]]++;\\n        }\\n        for(auto i :nums){\\n            if(m[i]==0)\\n                continue;\\n            m[i]--;\\n            if(m1[i-1]>0){\\n                m1[i-1]--;\\n                m1[i]++;\\n            }\\n            else if(m[i+1]!=0 && m[i+2]!=0){\\n                m[i+1]--;\\n                m[i+2]--;\\n                m1[i+2]++;\\n            }\\n            else\\n                return false;\\n        }\\n        return true;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2595625,
                "title": "python-solution",
                "content": "![image](https://assets.leetcode.com/users/images/6db537d6-f5f9-4e4d-9977-bf015ec4f808_1663566674.977195.png)\\n```\\nclass Solution:\\n    def isPossible(self, nums: List[int]) -> bool:\\n        subsequences = []\\n        \\n        for num in nums:\\n            while subsequences and subsequences[0][0] + 1 < num:\\n                sub = heapq.heappop(subsequences)\\n                if sub[1] < 3:\\n                    return False\\n            \\n            if not subsequences or subsequences[0][0] == num:\\n                heapq.heappush(subsequences, [num, 1]) # end, len\\n            else:\\n                # Pop and push to maintain order\\n                sub = heapq.heappop(subsequences)\\n                sub[0] += 1\\n                sub[1] += 1\\n                heapq.heappush(subsequences, sub)\\n                \\n        while subsequences:\\n            sub = heapq.heappop(subsequences)\\n            if sub[1] < 3:\\n                return False\\n            \\n        return True\\n```\\nMore LeetCode solutions of mine at https://github.com/aurimas13/SolutionsToProblems\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isPossible(self, nums: List[int]) -> bool:\\n        subsequences = []\\n        \\n        for num in nums:\\n            while subsequences and subsequences[0][0] + 1 < num:\\n                sub = heapq.heappop(subsequences)\\n                if sub[1] < 3:\\n                    return False\\n            \\n            if not subsequences or subsequences[0][0] == num:\\n                heapq.heappush(subsequences, [num, 1]) # end, len\\n            else:\\n                # Pop and push to maintain order\\n                sub = heapq.heappop(subsequences)\\n                sub[0] += 1\\n                sub[1] += 1\\n                heapq.heappush(subsequences, sub)\\n                \\n        while subsequences:\\n            sub = heapq.heappop(subsequences)\\n            if sub[1] < 3:\\n                return False\\n            \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489673,
                "title": "c-o-n-solution-using-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        /***\\n\\t\\tObservations\\n        1. Array is in ASC order with duplicate elements\\n        2. Array needs to be split into one or more subsequences\\n            such that a) each sequence should be of length >= 3\\n                      b) each sequence is increasing one i.e. each integer is exactly one more than the previous integer\\n\\n        \\n        Q. How to determine if split is even possible Or not ?\\n        A.  Base case - If len(arr) < 3\\n        \\n        Q. How to split the array ? \\n        A. Can we use frequencies of the element to figure it out ?\\n            -> Yes, but frequency array will only tells us how many times an elment has occurred in the sequence\\n            \\n        Greedy approach \\n        -> Form sequence of length 3 greedily \\n        -> How to handle left out numbers ? \\n            e.g arr = [1, 2, 3, 4, 5]\\n                Here first sequence of length 3 = [1, 2, 3]\\n                Left out numbers are = [4, 5] which collectively forms sequence of length 2\\n            Here we\\'ll use a hypothetical map (aka Vacancy map) which we\\'ll store the next available element for already formed sequences of length  >= 3\\n                i.e. Take above example\\n                    We\\'ve formed a sequence of length  = 3 => [1, 2, 3]\\n                    Now we\\'ll create a vacancy for next element of this sequence in vacancy map = { 4 : 1v, ...}\\n                    When we reach 4 in the array\\n                    we check if (vacancy for 4 is available) {\\n                        fill the vacancy\\n                        create new vacancy for next element i.e. 5\\n                    }\\n                \\n\\n        ***/\\n        const int LEAST_SPLIT = 3;\\n        const int n = nums.size();\\n        //base case\\n        if (n < 3) return false;\\n        // Array is sorted in increasing order\\n        unordered_map<int, int> freq;\\n        \\n        // Contains the elements which are available to be filled up in existing sequence\\n        unordered_map<int, int> vacancy;\\n        \\n        // calculate the frequencies\\n        for(int v : nums) {\\n            ++freq[v];\\n        }\\n        \\n        \\n        for(int v : nums) {\\n            if (!freq[v]) continue;\\n            //if number \\'v\\' can be joined to already formed sequence ending with v - 1, then do this else continue to next block\\n            // Note - This will be filled up by \\n            if (vacancy[v]) {\\n                //decrease the frequency\\n                --freq[v];\\n                //fill up the vacany\\n                --vacancy[v];\\n                //create vacany for next element in the sequence\\n                ++vacancy[v+1];\\n            } else {\\n                int len = 0;\\n                for (int e = v; freq[e]!= 0;++e) {\\n                    ++len;\\n                    --freq[e];\\n                    if (len == 3) {\\n                        //create a vacany to fill up\\n                        ++vacancy[e + 1];\\n                        break;\\n                    }\\n                }\\n                if (len < 3) return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        /***\\n\\t\\tObservations\\n        1. Array is in ASC order with duplicate elements\\n        2. Array needs to be split into one or more subsequences\\n            such that a) each sequence should be of length >= 3\\n                      b) each sequence is increasing one i.e. each integer is exactly one more than the previous integer\\n\\n        \\n        Q. How to determine if split is even possible Or not ?\\n        A.  Base case - If len(arr) < 3\\n        \\n        Q. How to split the array ? \\n        A. Can we use frequencies of the element to figure it out ?\\n            -> Yes, but frequency array will only tells us how many times an elment has occurred in the sequence\\n            \\n        Greedy approach \\n        -> Form sequence of length 3 greedily \\n        -> How to handle left out numbers ? \\n            e.g arr = [1, 2, 3, 4, 5]\\n                Here first sequence of length 3 = [1, 2, 3]\\n                Left out numbers are = [4, 5] which collectively forms sequence of length 2\\n            Here we\\'ll use a hypothetical map (aka Vacancy map) which we\\'ll store the next available element for already formed sequences of length  >= 3\\n                i.e. Take above example\\n                    We\\'ve formed a sequence of length  = 3 => [1, 2, 3]\\n                    Now we\\'ll create a vacancy for next element of this sequence in vacancy map = { 4 : 1v, ...}\\n                    When we reach 4 in the array\\n                    we check if (vacancy for 4 is available) {\\n                        fill the vacancy\\n                        create new vacancy for next element i.e. 5\\n                    }\\n                \\n\\n        ***/\\n        const int LEAST_SPLIT = 3;\\n        const int n = nums.size();\\n        //base case\\n        if (n < 3) return false;\\n        // Array is sorted in increasing order\\n        unordered_map<int, int> freq;\\n        \\n        // Contains the elements which are available to be filled up in existing sequence\\n        unordered_map<int, int> vacancy;\\n        \\n        // calculate the frequencies\\n        for(int v : nums) {\\n            ++freq[v];\\n        }\\n        \\n        \\n        for(int v : nums) {\\n            if (!freq[v]) continue;\\n            //if number \\'v\\' can be joined to already formed sequence ending with v - 1, then do this else continue to next block\\n            // Note - This will be filled up by \\n            if (vacancy[v]) {\\n                //decrease the frequency\\n                --freq[v];\\n                //fill up the vacany\\n                --vacancy[v];\\n                //create vacany for next element in the sequence\\n                ++vacancy[v+1];\\n            } else {\\n                int len = 0;\\n                for (int e = v; freq[e]!= 0;++e) {\\n                    ++len;\\n                    --freq[e];\\n                    if (len == 3) {\\n                        //create a vacany to fill up\\n                        ++vacancy[e + 1];\\n                        break;\\n                    }\\n                }\\n                if (len < 3) return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447020,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Hashmap***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n       \\n        unordered_map<int, int> count;\\n        \\n        // end will store the no. of subsequence ending with nums[i]\\n        \\n        unordered_map<int, int> end;\\n        \\n        // store the frequency of each element in count map\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            count[nums[i]]++;\\n        }\\n        \\n        // iterate over the nums array\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // if nums[i] is already included\\n            \\n            if(count[nums[i]] == 0)\\n                continue;\\n            \\n            // decrement the frequency of curr element\\n            \\n            count[nums[i]]--;\\n            \\n            // 1st check can we include in existing subsequence\\n            \\n            if(end[nums[i] - 1] > 0)\\n            {\\n                end[nums[i] - 1]--;\\n                \\n                end[nums[i]]++;\\n            }\\n            \\n            // 2nd check can we form a new subsequence starting with nums[i] and ending with nums[i] + 2\\n            \\n            else if(count[nums[i] + 1] && count[nums[i] + 2])\\n            {\\n                count[nums[i] + 1]--;\\n                \\n                count[nums[i] + 2]--;\\n                \\n                end[nums[i] + 2]++;\\n            }\\n            \\n            // otherwise return false\\n            \\n            else\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n       \\n        unordered_map<int, int> count;\\n        \\n        // end will store the no. of subsequence ending with nums[i]\\n        \\n        unordered_map<int, int> end;\\n        \\n        // store the frequency of each element in count map\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            count[nums[i]]++;\\n        }\\n        \\n        // iterate over the nums array\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // if nums[i] is already included\\n            \\n            if(count[nums[i]] == 0)\\n                continue;\\n            \\n            // decrement the frequency of curr element\\n            \\n            count[nums[i]]--;\\n            \\n            // 1st check can we include in existing subsequence\\n            \\n            if(end[nums[i] - 1] > 0)\\n            {\\n                end[nums[i] - 1]--;\\n                \\n                end[nums[i]]++;\\n            }\\n            \\n            // 2nd check can we form a new subsequence starting with nums[i] and ending with nums[i] + 2\\n            \\n            else if(count[nums[i] + 1] && count[nums[i] + 2])\\n            {\\n                count[nums[i] + 1]--;\\n                \\n                count[nums[i] + 2]--;\\n                \\n                end[nums[i] + 2]++;\\n            }\\n            \\n            // otherwise return false\\n            \\n            else\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2339688,
                "title": "c-simple-code-hash-map-priority-queue",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        unordered_map<int, int> um;\\n        for(int &num : nums)\\n        {\\n            pq.push(num);\\n            um[num]++;\\n        }\\n        queue<int> q;\\n        int count = 0, prev;\\n        while(!pq.empty())\\n        {\\n            if(count == 0)\\n            {\\n                prev = pq.top();\\n                pq.pop();\\n                count++;\\n            }\\n            else if(pq.top() == prev+1)\\n            {\\n                if(um[pq.top()] >= um[prev])\\n                {\\n                    um[prev]--;\\n                    pq.pop();\\n                    prev += 1;\\n                    count++;\\n                }\\n                else if(um[pq.top()] < um[prev])\\n                {\\n                    um[prev]--;\\n                    if(count <= 2) return false;\\n                    while(!q.empty())\\n                    {\\n                        pq.push(q.front());\\n                        q.pop();\\n                    }\\n                    count = 0;\\n                }\\n            }\\n            else if(pq.top() == prev)\\n            {\\n                q.push(pq.top());\\n                pq.pop();\\n                if(pq.empty())\\n                {\\n                    if(count <= 2) return false;\\n                    while(!q.empty())\\n                    {\\n                        pq.push(q.front());\\n                        q.pop();\\n                    }\\n                    count = 0;\\n                }\\n            }\\n            else if(pq.top() > prev+1)\\n            {\\n                if(count <= 2) return false;\\n                \\n                while(!q.empty())\\n                {\\n                    pq.push(q.front());\\n                    q.pop();\\n                }\\n                count = 0;\\n            }\\n        }\\n        if(count > 0 && count <= 2) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        unordered_map<int, int> um;\\n        for(int &num : nums)\\n        {\\n            pq.push(num);\\n            um[num]++;\\n        }\\n        queue<int> q;\\n        int count = 0, prev;\\n        while(!pq.empty())\\n        {\\n            if(count == 0)\\n            {\\n                prev = pq.top();\\n                pq.pop();\\n                count++;\\n            }\\n            else if(pq.top() == prev+1)\\n            {\\n                if(um[pq.top()] >= um[prev])\\n                {\\n                    um[prev]--;\\n                    pq.pop();\\n                    prev += 1;\\n                    count++;\\n                }\\n                else if(um[pq.top()] < um[prev])\\n                {\\n                    um[prev]--;\\n                    if(count <= 2) return false;\\n                    while(!q.empty())\\n                    {\\n                        pq.push(q.front());\\n                        q.pop();\\n                    }\\n                    count = 0;\\n                }\\n            }\\n            else if(pq.top() == prev)\\n            {\\n                q.push(pq.top());\\n                pq.pop();\\n                if(pq.empty())\\n                {\\n                    if(count <= 2) return false;\\n                    while(!q.empty())\\n                    {\\n                        pq.push(q.front());\\n                        q.pop();\\n                    }\\n                    count = 0;\\n                }\\n            }\\n            else if(pq.top() > prev+1)\\n            {\\n                if(count <= 2) return false;\\n                \\n                while(!q.empty())\\n                {\\n                    pq.push(q.front());\\n                    q.pop();\\n                }\\n                count = 0;\\n            }\\n        }\\n        if(count > 0 && count <= 2) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447452,
                "title": "java-greedy-just-a-few-lines-explained",
                "content": "#### Explanations\\nGreedy problem tends to be harder I feel, but here is a crucial observation that we need. \\nFor any element that is free to either start a new subsequence or appending to an existing subsequence,\\nit is always preferable to append, instead of starting anew.\\nThe reason is that, there is no situation in which starting anew will be benefited. In fact, starting anew requires us to add at least 2 elements after it, but there is no such restriction if we just append it to existing valid subsequences.\\n\\n#### Implementation\\nWith this insight, we can code it up with 2 arrays style. \\n`count[i]: The count of available number i that can be used.`\\n`end[i]: The number of valid subsequences that end with number i`.\\nThen, for each number `i`, we check how many `end[i-1]` we can take `= min(end[i-1], count[i])`, and the remaining will have to be the head of new subsequences.\\n\\n`Time O(N)`\\n`Space O(2003)`\\n####  Java\\n```Java\\nclass Solution {\\n    public boolean isPossible(int[] nums) {\\n        int[] count = new int[2003];\\n        int[] end = new int[2003];\\n        for (int n : nums){\\n            count[n+1000]++;\\n        }\\n        for (int i = 0; i <= 2002; i++){\\n            if (count[i] < 0){ // can\\'t be less than 0, return false\\n                return false;\\n            }else if (i <= 2000){\\n                int cont = Math.min(count[i], i==0?0:end[i-1]); // extend the subsequences\\n                count[i] -= cont;\\n                end[i] += cont;\\n                count[i+1] -= count[i]; // start some new subsequences and we must take those\\n                count[i+2] -= count[i]; // take those \\n                end[i+2] += count[i];   // update end to include the new subsequences.\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```Java\\nclass Solution {\\n    public boolean isPossible(int[] nums) {\\n        int[] count = new int[2003];\\n        int[] end = new int[2003];\\n        for (int n : nums){\\n            count[n+1000]++;\\n        }\\n        for (int i = 0; i <= 2002; i++){\\n            if (count[i] < 0){ // can\\'t be less than 0, return false\\n                return false;\\n            }else if (i <= 2000){\\n                int cont = Math.min(count[i], i==0?0:end[i-1]); // extend the subsequences\\n                count[i] -= cont;\\n                end[i] += cont;\\n                count[i+1] -= count[i]; // start some new subsequences and we must take those\\n                count[i+2] -= count[i]; // take those \\n                end[i+2] += count[i];   // update end to include the new subsequences.\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488318,
                "title": "c-o-n-simplest-solution",
                "content": "```\\n    bool isPossible(vector<int>& nums) {        \\n        unordered_map<int, int> mp;\\n        for(auto &e : nums) mp[e]++;\\n        for(auto &e : nums){\\n            if(mp[e] != 0){\\n                int len = 0;\\n                for(int j = e; mp[j] != 0 ; ++j){\\n                    len++;\\n                    mp[j]--;\\n                    if(len >= 3 && mp[j+1] <= mp[j]) break;\\n                }\\n                if(len < 3) return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool isPossible(vector<int>& nums) {        \\n        unordered_map<int, int> mp;\\n        for(auto &e : nums) mp[e]++;\\n        for(auto &e : nums){\\n            if(mp[e] != 0){\\n                int len = 0;\\n                for(int j = e; mp[j] != 0 ; ++j){\\n                    len++;\\n                    mp[j]--;\\n                    if(len >= 3 && mp[j+1] <= mp[j]) break;\\n                }\\n                if(len < 3) return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2447057,
                "title": "easy-solution-leetcode-daily-solution-c",
                "content": "\\n\\nLets take an example \\n\\n#### arr = [1,2,3,3,4,4,5,5]\\nthe frequency of element as follows :-\\n<pre>map ->  1 - 1\\n\\t2 - 1\\n\\t3 - 2\\n\\t4 - 2\\n\\t5 - 2</pre>\\n\\n<pre> <B>for it = 0 i.e. nums[i] = 1<B> </pre>\\n1) freq of 1 in map is not 0 , and freq of 2 consecutive elements (i.e. 2 & 3) is also not 0\\n2) decrement freq of 1,2,3\\n3) freq of elements now :\\n4) <pre>map->   1 - 0\\n\\t\\t2 - 0\\n\\t\\t3 - 1\\n\\t\\t4 - 2\\n\\t\\t5 - 2</pre>\\t\\n5) <pre>  check -> 0 - 0\\n              3 - 1\\n</pre>\\n\\n<pre> <B>for it = 1   i.e.   nums[i] = 2<B> </pre> \\n* * count(2) = 0 , so **continue**\\n\\n\\n<pre> <B>for it = 2   i.e.   nums[i] = 3<B> </pre>\\n1) freq of 3 in map is not 0 , and freq of 2 consecutive elements (i.e. 4 & 5) is also not 0\\n2) decrement freq of 3,4,5\\n3) freq of elements now :\\n4) <pre>  map -> 1 - 0\\n\\t\\t 2 - 0\\n\\t\\t 3 - 0\\n\\t\\t 4 - 1\\n\\t\\t 5 - 1</pre>\\n\\t5) <pre>  check -> 0 - 0\\n\\t              2 - 0\\n\\t\\t          3 - 1\\n\\t\\t\\t   5 - 1</pre>\\t \\n<pre> <B>for it = 3   i.e.   nums[i] = 3<B> </pre>\\t\\t\\n* * count(3) = 0 , so **continue**\\n\\n<pre> <B>for it = 4   i.e.   nums[i] = 4<B> </pre>\\n1.  as **check[nums[i]-1]==check[3] = 1 >0**\\n1. 1. \\t  decrement that count of 3 in check map and count of 4 from map \\n1. 1. \\t  insert 4 and freq as 1 in check map \\n2. <pre>map->   1 - 0\\n\\t\\t2 - 0\\n\\t\\t3 - 0\\n\\t\\t4 - 0\\n\\t\\t5 - 1</pre>\\t\\n1. <pre>  check ->  0 - 0\\n\\t           2 - 0\\n\\t\\t    3 - 0\\n\\t           4 - 1\\n               5 - 1</pre>\\n\\t\\t\\t  \\n<pre> <B>for it = 5   i.e.   nums[i] = 4<B> </pre>\\n* * count(4) = 0 , so **continue**   \\n<pre> <B>for it = 6   i.e.   nums[i] = 5<B> </pre>\\n1.  as **check[nums[i]-1]==check[4] = 1 >0**\\n1. 1. \\t  decrement that count of 4 in check map and count of 5 from map \\n1. 1. \\t  increase freq of 5 in count\\n2. <pre>map->   1 - 0\\n\\t\\t2 - 0\\n\\t\\t3 - 0\\n\\t\\t4 - 0\\n\\t\\t5 - 0</pre>\\t\\n1. <pre>  check ->  0 - 0\\n\\t           2 - 0\\n\\t\\t    3 - 0\\n\\t           4 - 0\\n               5 - 2</pre>\\n<pre> <B>for it = 7   i.e.   nums[i] = 5<B> </pre>\\t\\t\\n* * count(5) = 0 , so **continue**   \\n \\n**Break the loop and return true**\\n\\n ### PS  - maps are unordered here , so that will not be in order actually as shown here\\n### C++ solution\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        int sz = nums.size();\\n        unordered_map<int,int> map,check;\\n        for(int i=0;i<sz;i++){\\n            map[nums[i]]++;\\n        }\\n        \\n        for(int it = 0;it<sz;it++){\\n            if(map[nums[it]]<=0)continue;\\n            if(check[nums[it]-1]>0){\\n                check[nums[it]-1]--;\\n                map[nums[it]]--;\\n                check[nums[it]]++;\\n            }\\n            else if(map[nums[it]+1] and map[nums[it]+2]){\\n                map[nums[it]]--;\\n                map[nums[it]+1]--;\\n                map[nums[it]+2]--;\\n                check[nums[it]+2]++;\\n            }\\n            else return false;\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        int sz = nums.size();\\n        unordered_map<int,int> map,check;\\n        for(int i=0;i<sz;i++){\\n            map[nums[i]]++;\\n        }\\n        \\n        for(int it = 0;it<sz;it++){\\n            if(map[nums[it]]<=0)continue;\\n            if(check[nums[it]-1]>0){\\n                check[nums[it]-1]--;\\n                map[nums[it]]--;\\n                check[nums[it]]++;\\n            }\\n            else if(map[nums[it]+1] and map[nums[it]+2]){\\n                map[nums[it]]--;\\n                map[nums[it]+1]--;\\n                map[nums[it]+2]--;\\n                check[nums[it]+2]++;\\n            }\\n            else return false;\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 659317,
                "title": "o-n-o-1-solution-detailed-explanation-c",
                "content": "Idea is not have any subsequences of length 1 or 2 and only have lengths>=3. And also for every new number we should first give priority to subsequences which are less than 3 instead of adding the new number to subsequences >=3.\\n\\nPriority is ordered as follows:\\n\\n1. Add current number to all subsequences of length 1\\n2. Add current number to all subsequences of length 2\\n3. Add current number to all subsequences of length 3 or more.\\n\\nWe have to maintain the following for current number and its previous number at any point in the iteration.\\n1. Number of subsequences of length 1, which is represented as p1(previous) and c1(current)\\n2. Number of subsequences of length 2, which is represented as p2(previous) and c2(current)\\n3. Number of subsequences of length >=3, which is represented as p3(previous) and c3(current)\\n\\nFew other important observations are:\\nPlease note that we do not need to have the actual subsequences here, just knowing how many subsequences of lengths 1,2 and >=3 are available at every number is sufficient.\\n\\n1. For every number, we have to first count how many occurences of that number is there in the given array. Next, we have to check if we can spread it across all the subsequences of length 1 and 2. If we cannot add the current number then we can immediately return false. This is because 1 or 2 length subsequences can never be extended if we cannot add the current number to all them as all numbers are sorted, the next number would be higher so it wont satisfy the consective numbers criteria mentioned. Hence this means the count of occurences of current number should always exceed total number of subsequences of length 1 and length 2.\\n\\n2.  If the count of a number is higher than the number of subsequences of lengths 1 and 2 so then we try to add it to the number of subsequences of length 3 or more. While adding to it, we have two things to consider:\\n\\ta. count > (p1+p2+p3), then the remaining count of a number will be treated as subsequences of length 1. \\n\\tb. count < p3 but count >(p1+2), in this case first do count-(p1+p2) and then add the remaining count to p3 and only the minimum of count and p3 will be considered as that would be valid for the next number.\\n\\n3. We have to always check whether the current number is consective to the previous number, if not then we have to check at that if p1 or p2 is non-zero then immediately return false. What this means is we encountered non-consective number and at that point we have some number of subsequences of lengths 1 and 2 and this new number can never be added to them so they will stay as lengths 1 and 2.\\n\\n4. For every number, we always update the c1,c2 and c3.\\n\\t\\t\\t\\tc1 = max(0,count-(p1+p2+p3));  - Gives the number of subsequences of length 1 after adding the current number to all previous lengths. if it goes -ve then there is no subsequence of length1 so 0.\\n                c2 = p1;  - previous number of subsequences of length 1 now becomes 2 by adding the current number. so just assign c2=p1.\\n                c3 = p2+min(p3,count-(p1+p2)); - previous number of subsequences of length 2 now becomes 3 so c3 = p2 plus we have to consider how many subsequences of earlier p3 should be added. This depends on to how many subsequences of length 3 the current number can be added to. We have to add that many subsequences along with p2. We cannot simply add p3 because as that would mean invalid subsequence for next number if the count of current number is less than p3. Hence we always take min(p3,count-(p1+p2)).\\n\\n5. Finally the answer depends on c1 and c2 being 0 or not. 0 means there are no subsequences of lengths 1 and 2 so everything is of lengths 3 or more.\\n\\nInspired/Taken from @fun4LeetCode\\'s solution. Just wanted to share my understanding and explanation to it.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) \\n    {\\n        if(nums.size()<3)\\n            return false;\\n        int curr=0;\\n        int prev=0;\\n        int p1=0;\\n        int p2=0;\\n        int p3=0;\\n        \\n        int c1=0;\\n        int c2=0;\\n        int c3=0;\\n        int i=0;\\n        while(i<nums.size())\\n        {\\n            int count=0;\\n            p1=c1;p2=c2;p3=c3;\\n            prev=curr;\\n            curr = nums[i];\\n            while(i<nums.size() and nums[i]==curr)\\n            {\\n                i++;\\n                count++;\\n            }\\n            if(curr!=prev+1)\\n            {\\n                if(p1!=0 or p2!=0)\\n                    return false;\\n                c1=count;\\n                c2=0;\\n                c3=0;\\n            }\\n            else\\n            {\\n                if(count<p1+p2)\\n                    return false;\\n                c1 = max(0,count-(p1+p2+p3));\\n                c2 = p1;\\n                c3 = p2+min(p3,count-(p1+p2));\\n            }\\n        }\\n        return (c1==0 and c2==0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) \\n    {\\n        if(nums.size()<3)\\n            return false;\\n        int curr=0;\\n        int prev=0;\\n        int p1=0;\\n        int p2=0;\\n        int p3=0;\\n        \\n        int c1=0;\\n        int c2=0;\\n        int c3=0;\\n        int i=0;\\n        while(i<nums.size())\\n        {\\n            int count=0;\\n            p1=c1;p2=c2;p3=c3;\\n            prev=curr;\\n            curr = nums[i];\\n            while(i<nums.size() and nums[i]==curr)\\n            {\\n                i++;\\n                count++;\\n            }\\n            if(curr!=prev+1)\\n            {\\n                if(p1!=0 or p2!=0)\\n                    return false;\\n                c1=count;\\n                c2=0;\\n                c3=0;\\n            }\\n            else\\n            {\\n                if(count<p1+p2)\\n                    return false;\\n                c1 = max(0,count-(p1+p2+p3));\\n                c2 = p1;\\n                c3 = p2+min(p3,count-(p1+p2));\\n            }\\n        }\\n        return (c1==0 and c2==0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 106549,
                "title": "python-8-liner-o-nlgn-2-greedy-approaches-with-explanation",
                "content": "**General approach**\\n\\nUse a dictionary `seqs`, that maps keys to a collection (array/heap/priority queue). The key represents the ending value of the sequence and the collection stores lengths of sequences seen so far that end at the key. \\n\\nAs we iterate through the array, if there is an existing sequence in `seqs` that ends at `num - 1`, we can remove the sequence with the smallest length from `seqs[num - 1]` and create a new sequence at `seqs[num]` with length + 1. We choose the smallest length as we try to have as many sequences as possible that have at least length 3. If there is no existing sequence ending at `num - 1`, we create a new sequence at `seqs[num]` of length 1.\\n\\nAt the end of the iteration, return `False` if any of the sequences in `seqs` have a length < 3.\\n\\nFor the input `[1,2,3,3,4,5]`, the ending dict will look like `{ 3: [3], 5: [3] }`, indicating there is one sequence ending with 3 of length 3 and one sequence ending with 5 of length 3.\\n\\nFor the input `[2,2,3,3,4,4,5,5]`, the ending dict will look like `{ 5: [4, 4] }`, indicating there are two sequences ending with 5, both of length 4.\\n\\nFor the input `[1,2,3,4,4,5]`, the ending dict will look like `{ 4: [4], 5: [2] }`, indicating there is one sequence ending with 4 of length 4 and one sequence ending with 5 of length 2. This should return `False` since there is a sequence that is shorter then length 3.\\n\\n**\\uD83D\\uDCAF Check out https://techinterviewhandbook.org for more tips and tricks to ace your technical interview \\uD83D\\uDCAF**\\n\\n**Using Heap**\\n\\n```\\nclass Solution(object):\\n    def isPossible(self, nums):\\n        # Time: O(n.lgn)\\n        # Space: O(n)\\n        import heapq\\n        seqs = {num: [] for num in nums}\\n        for num in nums:\\n            shortest_seq = 0\\n            if num - 1 in seqs and len(seqs[num - 1]):\\n                shortest_seq = heapq.heappop(seqs[num - 1])\\n            heapq.heappush(seqs[num], shortest_seq + 1)\\n        return len([None for seq_lengths in seqs.values() if len(seq_lengths) and seq_lengths[0] < 3]) == 0\\n```\\n\\n**Using Lists** - This approach is O(n^2) because it takes O(n) to retrieve the minimum length within the list, but the list length is usually not very long so it still passes.\\n\\n```\\nclass Solution(object):\\n    def isPossible(self, nums):\\n        # Time: O(n^2)\\n        # Space: O(n)\\n        seqs = {num: [] for num in nums}\\n        for num in nums:\\n            shortest_seq = 0\\n            if num - 1 in seqs and seqs[num - 1]:\\n                shortest_seq = min(seqs[num - 1])\\n                seqs[num - 1].remove(shortest_seq)\\n            seqs[num].append(shortest_seq + 1)\\n        for seq_lengths in seqs.values():\\n            if seq_lengths and min(seq_lengths) < 3:\\n                return False\\n        return True\\n```\\n\\n**Using Priority Queue** - This approach should have the same time complexity as the heap approach but it TLEs probably because initializing a `PriorityQueue` is inefficient.\\n\\n```\\nclass Solution(object):\\n    def isPossible(self, nums):\\n        # Time: O(n.lgn). Correct implementation but it TLEs. PriorityQueue() probably takes too long to be initialized.\\n        # Space: O(n)\\n        from Queue import PriorityQueue\\n        seqs = {}\\n        for num in nums:\\n            if num not in seqs:\\n                seqs[num] = PriorityQueue()\\n            shortest_seq = 0\\n            if num - 1 in seqs and seqs[num - 1].qsize():\\n                shortest_seq = seqs[num - 1].get()\\n            seqs[num].put(shortest_seq + 1)\\n        return len([None for seq_lengths in seqs.values() if seq_lengths.qsize() > 0 and seq_lengths.get() < 3]) == 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isPossible(self, nums):\\n        # Time: O(n.lgn)\\n        # Space: O(n)\\n        import heapq\\n        seqs = {num: [] for num in nums}\\n        for num in nums:\\n            shortest_seq = 0\\n            if num - 1 in seqs and len(seqs[num - 1]):\\n                shortest_seq = heapq.heappop(seqs[num - 1])\\n            heapq.heappush(seqs[num], shortest_seq + 1)\\n        return len([None for seq_lengths in seqs.values() if len(seq_lengths) and seq_lengths[0] < 3]) == 0\\n```\n```\\nclass Solution(object):\\n    def isPossible(self, nums):\\n        # Time: O(n^2)\\n        # Space: O(n)\\n        seqs = {num: [] for num in nums}\\n        for num in nums:\\n            shortest_seq = 0\\n            if num - 1 in seqs and seqs[num - 1]:\\n                shortest_seq = min(seqs[num - 1])\\n                seqs[num - 1].remove(shortest_seq)\\n            seqs[num].append(shortest_seq + 1)\\n        for seq_lengths in seqs.values():\\n            if seq_lengths and min(seq_lengths) < 3:\\n                return False\\n        return True\\n```\n```\\nclass Solution(object):\\n    def isPossible(self, nums):\\n        # Time: O(n.lgn). Correct implementation but it TLEs. PriorityQueue() probably takes too long to be initialized.\\n        # Space: O(n)\\n        from Queue import PriorityQueue\\n        seqs = {}\\n        for num in nums:\\n            if num not in seqs:\\n                seqs[num] = PriorityQueue()\\n            shortest_seq = 0\\n            if num - 1 in seqs and seqs[num - 1].qsize():\\n                shortest_seq = seqs[num - 1].get()\\n            seqs[num].put(shortest_seq + 1)\\n        return len([None for seq_lengths in seqs.values() if seq_lengths.qsize() > 0 and seq_lengths.get() < 3]) == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2449167,
                "title": "c-o-1-memory-o-n-time",
                "content": "Key idea: iterate over the array while keeping track of currently active sequences of length 1, 2, and 3+.\\nWe *have* to extend sequences of length 1 and 2. For sequences of length 3+ it is always better to extend them if possible (greedy).\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        int i=0, // index into array\\n            a=0, // active subsequences of length 1\\n            b=0, // active subsequences of length 2\\n            c=0; // active subsequences of length 3+\\n            \\n        for(int k=-1000; k<=1001; k++){ // iterate over all numbers k\\n            int count=0; // count of times that number k appears in nums\\n            while(i<nums.size() && nums[i]==k){ i++; count++; } // also increment array index\\n            \\n            if(count < a+b) return false; // we have to extend sequences of length 1 and 2, return false if not possible\\n            int a_prev = a; // saved old value of a = sequences of length 1\\n            a = max(0, count - (a+b+c)); // newly started sequences = count - currently active sequences (because we will extend currently active sequences)\\n            b = a_prev; // sequences of length 2 = previous sequences of length 1, because we extended those\\n            c = count - (a+b); // sequences of length 3+ = rest\\n        }\\n        return true; // return true if we reached here since we iterated to k=1001 which has count=0, guarantees a=0 and b=0\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        int i=0, // index into array\\n            a=0, // active subsequences of length 1\\n            b=0, // active subsequences of length 2\\n            c=0; // active subsequences of length 3+\\n            \\n        for(int k=-1000; k<=1001; k++){ // iterate over all numbers k\\n            int count=0; // count of times that number k appears in nums\\n            while(i<nums.size() && nums[i]==k){ i++; count++; } // also increment array index\\n            \\n            if(count < a+b) return false; // we have to extend sequences of length 1 and 2, return false if not possible\\n            int a_prev = a; // saved old value of a = sequences of length 1\\n            a = max(0, count - (a+b+c)); // newly started sequences = count - currently active sequences (because we will extend currently active sequences)\\n            b = a_prev; // sequences of length 2 = previous sequences of length 1, because we extended those\\n            c = count - (a+b); // sequences of length 3+ = rest\\n        }\\n        return true; // return true if we reached here since we iterated to k=1001 which has count=0, guarantees a=0 and b=0\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447025,
                "title": "java-hashmap-o-n-space-and-time-easy-to-understand-with-comments",
                "content": "```\\nclass Solution {\\n    public boolean isPossible(int[] nums) {\\n        int n = nums.length;\\n\\t\\t//Here we will be creating two hashmap one will be fm(frequency map) which will store the frequency of the elements present in the nums array\\n        HashMap<Integer,Integer> fm = new HashMap<>();\\n\\t\\t\\n\\t\\t//second map will be hm (hypothetical map) which will contain at what positions the insertion of elements is possible\\n\\t\\t//for example if we have already gone throught 1,2,3 then it will create a entry in the hm map as  4,1 which means that at position 4   we can insert a value  and if there will be a 4 in the future\\n        HashMap<Integer,Integer> hm = new HashMap<>();\\n        \\n\\t\\t//filling up the fm map\\n        for(int i=0;i<n;i++){\\n            fm.put(nums[i],fm.getOrDefault(nums[i],0)+1);\\n        }\\n        //traversing for all the elements \\n        for(int i : nums){\\n\\t\\t//we will not consider the element if it was already processed , that\\'s why its frequency is 0\\n            if(fm.get(i)==0){\\n                continue;\\n            }\\n\\t\\t\\t//here we are checking for if the  element we are is there in the hypothetical map if there we will decement that value of the hm and add a new positon with i+1 in the hm and decrement the frequecy map of i\\n            else if(hm.getOrDefault(i,0)>0){\\n                hm.put(i,hm.get(i)-1);\\n                hm.put(i+1,hm.getOrDefault(i+1,0)+1);\\n                fm.put(i,fm.get(i)-1);\\n            }\\n\\t\\t\\t// this is where we will processes the three elemets for ex: if we will have i=1 then it will check for frequency of i=1,i=2,i=3 and decrement its value from the frequency map and insert a new positon i+3 at the hypothetical map\\n\\t\\t\\t//if we were said to make changes from 3 elements array to 4 we would have added one more element here of i+3 here only\\n            else if(fm.getOrDefault(i,0)>0 && fm.getOrDefault(i+1,0)>0 && fm.getOrDefault(i+2,0)>0){\\n                fm.put(i,fm.getOrDefault(i,0)-1);\\n                fm.put(i+1,fm.getOrDefault(i+1,0)-1);\\n                fm.put(i+2,fm.getOrDefault(i+2,0)-1);\\n                hm.put(i+3,hm.getOrDefault(i+3,0)+1);\\n            }\\n\\t\\t\\t//if none of the conditions fullfill that means we cannot store that particualar element in the array \\n\\t\\t\\t// for ex in array 1,2,3,7 it will error out\\n            else{\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossible(int[] nums) {\\n        int n = nums.length;\\n\\t\\t//Here we will be creating two hashmap one will be fm(frequency map) which will store the frequency of the elements present in the nums array\\n        HashMap<Integer,Integer> fm = new HashMap<>();\\n\\t\\t\\n\\t\\t//second map will be hm (hypothetical map) which will contain at what positions the insertion of elements is possible\\n\\t\\t//for example if we have already gone throught 1,2,3 then it will create a entry in the hm map as  4,1 which means that at position 4   we can insert a value  and if there will be a 4 in the future\\n        HashMap<Integer,Integer> hm = new HashMap<>();\\n        \\n\\t\\t//filling up the fm map\\n        for(int i=0;i<n;i++){\\n            fm.put(nums[i],fm.getOrDefault(nums[i],0)+1);\\n        }\\n        //traversing for all the elements \\n        for(int i : nums){\\n\\t\\t//we will not consider the element if it was already processed , that\\'s why its frequency is 0\\n            if(fm.get(i)==0){\\n                continue;\\n            }\\n\\t\\t\\t//here we are checking for if the  element we are is there in the hypothetical map if there we will decement that value of the hm and add a new positon with i+1 in the hm and decrement the frequecy map of i\\n            else if(hm.getOrDefault(i,0)>0){\\n                hm.put(i,hm.get(i)-1);\\n                hm.put(i+1,hm.getOrDefault(i+1,0)+1);\\n                fm.put(i,fm.get(i)-1);\\n            }\\n\\t\\t\\t// this is where we will processes the three elemets for ex: if we will have i=1 then it will check for frequency of i=1,i=2,i=3 and decrement its value from the frequency map and insert a new positon i+3 at the hypothetical map\\n\\t\\t\\t//if we were said to make changes from 3 elements array to 4 we would have added one more element here of i+3 here only\\n            else if(fm.getOrDefault(i,0)>0 && fm.getOrDefault(i+1,0)>0 && fm.getOrDefault(i+2,0)>0){\\n                fm.put(i,fm.getOrDefault(i,0)-1);\\n                fm.put(i+1,fm.getOrDefault(i+1,0)-1);\\n                fm.put(i+2,fm.getOrDefault(i+2,0)-1);\\n                hm.put(i+3,hm.getOrDefault(i+3,0)+1);\\n            }\\n\\t\\t\\t//if none of the conditions fullfill that means we cannot store that particualar element in the array \\n\\t\\t\\t// for ex in array 1,2,3,7 it will error out\\n            else{\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1279882,
                "title": "python-intuitive-faster-than-99",
                "content": "We are interested in how many of each number we have, so first our list of numbers should be put in a collection like Counter.\\n\\nNext we loop through each number in the collection, from the minimum to the maximum.\\n\\nAs we loop, we only need to keep track of how many subsequences we have with just one, two, or three (or more) numbers in a row. If we have don\\'t have enough of the current number to cover the amount we have in our subsequences of one and two, then we know to return False. Otherwise, we calculate how many subsequences we currently have of one, two, and three or more going forward. \\n\\nAt the end, one and two should have 0 subsequences. All subsequences should be three or longer.\\n\\nSimple and fast.\\n\\n```\\nfrom collections import Counter as C\\n\\nclass Solution:\\n    def isPossible(self, nums: List[int]) -> bool:\\n        h = C(nums)\\n        one = two = three = 0\\n        for current in range(nums[0], nums[-1] + 1):\\n            x = h[current]\\n            x -= one + two\\n            if x < 0:\\n                return False\\n            c = min(x, three)\\n            one, two, three = x - c, one, two + c\\n        return one == two == 0\\n\\t",
                "solutionTags": [],
                "code": "We are interested in how many of each number we have, so first our list of numbers should be put in a collection like Counter.\\n\\nNext we loop through each number in the collection, from the minimum to the maximum.\\n\\nAs we loop, we only need to keep track of how many subsequences we have with just one, two, or three (or more) numbers in a row. If we have don\\'t have enough of the current number to cover the amount we have in our subsequences of one and two, then we know to return False. Otherwise, we calculate how many subsequences we currently have of one, two, and three or more going forward. \\n\\nAt the end, one and two should have 0 subsequences. All subsequences should be three or longer.\\n\\nSimple and fast.\\n\\n```\\nfrom collections import Counter as C\\n\\nclass Solution:\\n    def isPossible(self, nums: List[int]) -> bool:\\n        h = C(nums)\\n        one = two = three = 0\\n        for current in range(nums[0], nums[-1] + 1):\\n            x = h[current]\\n            x -= one + two\\n            if x < 0:\\n                return False\\n            c = min(x, three)\\n            one, two, three = x - c, one, two + c\\n        return one == two == 0\\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 2508808,
                "title": "python3",
                "content": "class Solution:\\n\\n    def isPossible(self, nums: List[int]) -> bool:\\n        available = Counter(nums)\\n        vacancy = defaultdict(int)\\n        \\n        for num in nums:\\n            if not available[num]:\\n                continue\\n            elif vacancy[num]:\\n                vacancy[num]-=1\\n                available[num]-=1\\n                vacancy[num+1]+=1\\n            elif available[num+1] and available[num+2]:\\n                available[num]-=1\\n                available[num+1]-=1\\n                available[num+2]-=1\\n                vacancy[num+3]+=1\\n            else:\\n                return False\\n            \\n        return True",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def isPossible(self, nums: List[int]) -> bool:\\n        available = Counter(nums)\\n        vacancy = defaultdict(int)\\n        \\n        for num in nums:\\n            if not available[num]:\\n                continue\\n            elif vacancy[num]:\\n                vacancy[num]-=1\\n                available[num]-=1\\n                vacancy[num+1]+=1\\n            elif available[num+1] and available[num+2]:\\n                available[num]-=1\\n                available[num+1]-=1\\n                available[num+2]-=1\\n                vacancy[num+3]+=1\\n            else:\\n                return False\\n            \\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 2447670,
                "title": "c-solution-time-o-n-log-m-memory-o-n-beats-100-on-memory-greedy-priority-queue",
                "content": "```C#\\npublic class Solution {\\n    public bool IsPossible(int[] nums) {\\n        int maxSequences = nums.Length / 3;\\n        Dictionary<int, PriorityQueue<int, int>> d = new Dictionary<int, PriorityQueue<int, int>>();\\n        \\n        int sequences = 0;\\n        for (int i = 0; i < nums.Length; i++) {\\n            int num = nums[i];\\n            \\n            int order;\\n            if (!d.ContainsKey(num - 1) || d[num - 1].Count == 0) {\\n                if (sequences == maxSequences) return false;\\n                sequences++;\\n                order = 0;\\n            } else {\\n                order = d[num - 1].Dequeue();\\n            }\\n            \\n            if (!d.ContainsKey(num)) d[num] = new PriorityQueue<int, int>();\\n            d[num].Enqueue(order + 1, order + 1);\\n        }\\n        \\n        foreach (var (key, pq) in d) {\\n            while (pq.Count > 0) {\\n                int elementsCount = pq.Dequeue();\\n                if (elementsCount < 3) return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```C#\\npublic class Solution {\\n    public bool IsPossible(int[] nums) {\\n        int maxSequences = nums.Length / 3;\\n        Dictionary<int, PriorityQueue<int, int>> d = new Dictionary<int, PriorityQueue<int, int>>();\\n        \\n        int sequences = 0;\\n        for (int i = 0; i < nums.Length; i++) {\\n            int num = nums[i];\\n            \\n            int order;\\n            if (!d.ContainsKey(num - 1) || d[num - 1].Count == 0) {\\n                if (sequences == maxSequences) return false;\\n                sequences++;\\n                order = 0;\\n            } else {\\n                order = d[num - 1].Dequeue();\\n            }\\n            \\n            if (!d.ContainsKey(num)) d[num] = new PriorityQueue<int, int>();\\n            d[num].Enqueue(order + 1, order + 1);\\n        }\\n        \\n        foreach (var (key, pq) in d) {\\n            while (pq.Count > 0) {\\n                int elementsCount = pq.Dequeue();\\n                if (elementsCount < 3) return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315633,
                "title": "most-concised-solution",
                "content": "**Intuition**\\n\\nWe can solve this problem with yet another greedy strategy.\\n\\nCompared to the other greedy algorithm posted by me, this algorithm is clearer via looking ahead.\\n**Implementation**\\n\\nWe use two hash maps. cntcntcnt for the remaining frequency of each number, while subssubssubs for the number of subsequences that end with a certain number.\\n\\nSince the original array is sorted, we just process the numbers sequentially. For each number:\\n\\n*     First, if the frequency of numnumnum is already zero, this means numnumnum has been used by previous numbers, so we just skip it.\\n*     Then, we consider adding it to an existing subsequence. We can check sub[num\\u22121]sub[num-1]sub[num\\u22121] for that.\\n*     Next, we try to make a new subsequence with num,num+1,num+2num,num+1,num+2num,num+1,num+2. (This is looking ahead.)\\n*     Otherwise, we cannot put numnumnum into any suitable subsequence, so the test case has no valid answer.\\n\\n**Time Complexity**\\n\\nTime complexity is O(n)\\\\mathcal{O}(n)O(n) for the loop through all numbers.\\n**Space Complexity**\\n\\nSpace complexity is O(n)\\\\mathcal{O}(n)O(n) for the hash map.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        unordered_map<int, int> freq, end;\\n        for(auto i:nums)freq[i]++;\\n        for(auto i:nums){\\n            if( freq[i] <= 0)continue;\\n            if(end[i-1] > 0){\\n                end[i-1]--;\\n                freq[i]--;\\n                end[i]++;\\n            }\\n            else if( freq[i+1] and  freq[i+2] ){\\n                freq[i]--;\\n                freq[i+1]--;\\n                freq[i+2]--;\\n                end[i+2]++;\\n            }\\n            else return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Hash Table",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        unordered_map<int, int> freq, end;\\n        for(auto i:nums)freq[i]++;\\n        for(auto i:nums){\\n            if( freq[i] <= 0)continue;\\n            if(end[i-1] > 0){\\n                end[i-1]--;\\n                freq[i]--;\\n                end[i]++;\\n            }\\n            else if( freq[i+1] and  freq[i+2] ){\\n                freq[i]--;\\n                freq[i+1]--;\\n                freq[i+2]--;\\n                end[i+2]++;\\n            }\\n            else return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 561023,
                "title": "python-super-concise-o-n-solution-beats-91-explanation",
                "content": "While looping on the array elements, each of the numbers in the array can either be:\\n- The current end of some consective sequence.\\n- The start of some new VALID consective sequence (at least 3 elements).\\nOtherwise it\\'s not possible to use that number, so we\\'ll just return false.\\n\\nWe check for first possibilty by checking if sum existing sequence ends by num-1 if yes then remove this sequence and add another one ending with the new num.\\nWe check for the second possibility by checking if any num+1&num+2 is still left, if yes then we\\'re good to go.\\nNote that we save sequeneces by their end as a key and just save the count of how many sequences ends with this key.\\n```\\nfrom collections import defaultdict,Counter\\nclass Solution:\\n    def isPossible(self, nums: List[int]) -> bool:\\n        seqsDict=defaultdict(int)\\n        numsCount=Counter(nums)\\n        \\n        for num in nums:\\n            if seqsDict[num-1]:\\n                seqsDict[num-1]-=1\\n            elif numsCount[num+1] and numsCount[num+2]:\\n                numsCount[num+1]-=1\\n                numsCount[num+2]-=1\\n            else:\\n                return False\\n            seqsDict[num]+=1\\n\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict,Counter\\nclass Solution:\\n    def isPossible(self, nums: List[int]) -> bool:\\n        seqsDict=defaultdict(int)\\n        numsCount=Counter(nums)\\n        \\n        for num in nums:\\n            if seqsDict[num-1]:\\n                seqsDict[num-1]-=1\\n            elif numsCount[num+1] and numsCount[num+2]:\\n                numsCount[num+1]-=1\\n                numsCount[num+2]-=1\\n            else:\\n                return False\\n            seqsDict[num]+=1\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1149132,
                "title": "short-c-deque-solution",
                "content": "Calculate frequency of each element in nums ( map -1000 to index 1 )\\nWhile traversing freq array we can encounter 3 cases. Calculate freq[i] > freq[i-1] ( say d )\\n(a) d > 0 : d number of intervals start from this point. Push back into deque.\\n(b) d < 0 : d number of intervals expire at i-1. Pop front from deque and check size > 3.\\n(c) d = 0 : do nothing.\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        deque<int> dq;\\n        vector<int> freq(2003);\\n        for( int i : nums ) \\n            freq[i+1001]++;\\n        \\n        for( int i = 1; i < freq.size(); i++ ){\\n            int d = freq[i]-freq[i-1];\\n            while( d > 0 ){\\n                dq.push_back(i);\\n                d--;\\n            }\\n            while( d < 0 ){\\n                if(i-dq.front()<3)\\n                    return false;\\n                dq.pop_front();\\n                d++;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        deque<int> dq;\\n        vector<int> freq(2003);\\n        for( int i : nums ) \\n            freq[i+1001]++;\\n        \\n        for( int i = 1; i < freq.size(); i++ ){\\n            int d = freq[i]-freq[i-1];\\n            while( d > 0 ){\\n                dq.push_back(i);\\n                d--;\\n            }\\n            while( d < 0 ){\\n                if(i-dq.front()<3)\\n                    return false;\\n                dq.pop_front();\\n                d++;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1112207,
                "title": "java-using-treemap-easy-to-understand",
                "content": "```\\n\\tpublic boolean isPossibleDivide(int[] nums, int k) {\\n\\t\\t//Get elements frequence and sort by elements\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for(int num: nums) map.put(num, map.getOrDefault(num, 0) + 1);\\n        \\n        while(map.size() > 0) {\\n            int len = 0;\\n            int curr = map.firstKey(); //pick the smallest element\\n            while(true) {\\n                int count = map.get(curr);\\n                if(count == 1) map.remove(curr);\\n                else map.put(curr, count - 1);\\n                curr++;\\n                len++;\\n\\t\\t\\t\\t//if next element is not consecutive or next element frequence is smaller than current one.\\n\\t\\t\\t\\t//e.g {1,2,3,3,4,5} 3 has 2 freqs, and 4 has 1 freq. So, current subseqence should stop at 3.\\n                if(!map.containsKey(curr) || map.get(curr) < count) break; \\n            }\\n            if(len < 3) return false;\\n        }\\n\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic boolean isPossibleDivide(int[] nums, int k) {\\n\\t\\t//Get elements frequence and sort by elements\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for(int num: nums) map.put(num, map.getOrDefault(num, 0) + 1);\\n        \\n        while(map.size() > 0) {\\n            int len = 0;\\n            int curr = map.firstKey(); //pick the smallest element\\n            while(true) {\\n                int count = map.get(curr);\\n                if(count == 1) map.remove(curr);\\n                else map.put(curr, count - 1);\\n                curr++;\\n                len++;\\n\\t\\t\\t\\t//if next element is not consecutive or next element frequence is smaller than current one.\\n\\t\\t\\t\\t//e.g {1,2,3,3,4,5} 3 has 2 freqs, and 4 has 1 freq. So, current subseqence should stop at 3.\\n                if(!map.containsKey(curr) || map.get(curr) < count) break; \\n            }\\n            if(len < 3) return false;\\n        }\\n\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 717212,
                "title": "java-simple-o-n-counting-sequence",
                "content": "```\\n    public boolean isPossible(int[] nums) {\\n        Map<Integer, Integer> freq = new HashMap<>(), append = new HashMap<>();\\n        for (int n : nums) freq.put(n, freq.getOrDefault(n, 0) + 1);\\n        for (int n : nums) {\\n            if (freq.getOrDefault(n, 0) == 0) continue;\\n            else if (append.getOrDefault(n, 0) > 0) {\\n                append.put(n, append.get(n) - 1);\\n                append.put(n + 1, append.getOrDefault(n + 1, 0) + 1);\\n            } else if (freq.getOrDefault(n+1, 0) > 0 && freq.getOrDefault(n + 2, 0) > 0) {\\n                freq.put(n + 1, freq.getOrDefault(n+1, 0) - 1);\\n                freq.put(n +2, freq.getOrDefault(n + 2, 0) - 1); \\n                append.put(n + 3, append.getOrDefault(n + 3, 0) + 1);\\n            } else return false;\\n            freq.put(n, freq.get(n) - 1);\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean isPossible(int[] nums) {\\n        Map<Integer, Integer> freq = new HashMap<>(), append = new HashMap<>();\\n        for (int n : nums) freq.put(n, freq.getOrDefault(n, 0) + 1);\\n        for (int n : nums) {\\n            if (freq.getOrDefault(n, 0) == 0) continue;\\n            else if (append.getOrDefault(n, 0) > 0) {\\n                append.put(n, append.get(n) - 1);\\n                append.put(n + 1, append.getOrDefault(n + 1, 0) + 1);\\n            } else if (freq.getOrDefault(n+1, 0) > 0 && freq.getOrDefault(n + 2, 0) > 0) {\\n                freq.put(n + 1, freq.getOrDefault(n+1, 0) - 1);\\n                freq.put(n +2, freq.getOrDefault(n + 2, 0) - 1); \\n                append.put(n + 3, append.getOrDefault(n + 3, 0) + 1);\\n            } else return false;\\n            freq.put(n, freq.get(n) - 1);\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 626619,
                "title": "python-2-solutions-greedy-heap-with-explanations",
                "content": "**Solution 1**: Greedy\\n**Explantions**:  For every number in `nums`, if there is an exsisting chain, append current number to that chain. On the other hand, if there is no exsisting chains, the number has to have two consecutive numbers in order to form a valid chain.\\n`endsAt[i]`= # of chains that end at `i`.\\n\\n**Complexity**: Time O(N), N is the length of `nums`. Space O(N)\\n```\\nclass Solution:\\n    def isPossible(self, nums: List[int]) -> bool:\\n        counts = collections.Counter(nums)\\n        endsAt = collections.Counter()\\n        for n in nums:\\n            if counts[n] > 0 :\\n                if endsAt[n - 1] > 0:\\n                    endsAt[n - 1] -= 1\\n                    endsAt[n] += 1\\n                elif counts[n + 1] > 0 and counts[n + 2] > 0:\\n                    endsAt[n + 2] += 1\\n                    counts[n + 1] -= 1\\n                    counts[n + 2] -= 1\\n                else:\\n                    return False\\n                counts[n] -= 1\\n        return True\\n```\\n\\n**Solution 2**: Heap \\n**Explantions**: This is based on Greedy. `lens[i]`= the lengths of chains that end at `i`.  If current number is `n` and there is an exisisting chain ending at `n-1`, we should get the shortest chain to add on it, so that chain will be most likely to become valid.\\n\\n**Complexity**: Time O(NlogN), N is the length of `nums`. Space O(N).\\n```\\nclass Solution:\\n    def isPossible(self, nums: List[int]) -> bool:\\n        lens = collections.defaultdict(list)\\n        for n in nums:\\n            length = 1\\n            if len(lens[n - 1]) > 0:\\n                length += heapq.heappop(lens[n - 1])\\n            heapq.heappush(lens[n], length)\\n        for len_arr in lens.values():\\n            if len_arr and min(len_arr) < 3: return False           \\n        return True\\n```\\n\\n\\n\\nRef: \\n1. https://leetcode.com/problems/split-array-into-consecutive-subsequences/discuss/106514/Python-Easy-Understand-Greedy \\n2. https://leetcode.com/problems/split-array-into-consecutive-subsequences/discuss/106539/Python-Solution-using-PriorityQueue",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isPossible(self, nums: List[int]) -> bool:\\n        counts = collections.Counter(nums)\\n        endsAt = collections.Counter()\\n        for n in nums:\\n            if counts[n] > 0 :\\n                if endsAt[n - 1] > 0:\\n                    endsAt[n - 1] -= 1\\n                    endsAt[n] += 1\\n                elif counts[n + 1] > 0 and counts[n + 2] > 0:\\n                    endsAt[n + 2] += 1\\n                    counts[n + 1] -= 1\\n                    counts[n + 2] -= 1\\n                else:\\n                    return False\\n                counts[n] -= 1\\n        return True\\n```\n```\\nclass Solution:\\n    def isPossible(self, nums: List[int]) -> bool:\\n        lens = collections.defaultdict(list)\\n        for n in nums:\\n            length = 1\\n            if len(lens[n - 1]) > 0:\\n                length += heapq.heappop(lens[n - 1])\\n            heapq.heappush(lens[n], length)\\n        for len_arr in lens.values():\\n            if len_arr and min(len_arr) < 3: return False           \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 485075,
                "title": "greedy-approach-with-proof-of-validity-and-explanation-in-python3",
                "content": "```\\nclass Solution: \\n    def isPossible(self, nums: List[int]) -> bool:\\n        if len(nums) < 3: return False\\n        \\n        freqs = Counter(nums)\\n        tails = Counter()\\n        \\n        for num in nums:\\n\\t\\t\\t\\n\\t\\t\\t# if the number already has a place in a sequence\\n            if freqs[num] == 0:\\n                continue\\n\\t\\t\\t\\t\\n\\t\\t\\t# if the number may be placed as a continuation of another sequence\\n            elif tails[num] > 0:\\n                tails[num] -= 1\\n                tails[num + 1] += 1\\n\\t\\t\\t\\n\\t\\t\\t# the number is not consecutive to a previous sequence\\n\\t\\t\\t# a new sequence must be created\\n            elif freqs[num + 1] > 0 and freqs[num + 2] > 0:\\n                freqs[num + 1] -= 1\\n                freqs[num + 2] -= 1\\n                tails[num + 3] += 1\\n            \\n\\t\\t\\t# if the number cannot continue a new sequence\\n\\t\\t\\t# and cannot begin a new sequence then the list\\n\\t\\t\\t# cannot be split\\n\\t\\t\\telse:\\n                return False\\n            freqs[num] -= 1\\n                \\n        return True\\n```\\n\\nThis solution relies on the fact that placing a newly examined number at the end of an existing sequence is as good as starting a new sequence. \\n\\nConsider that you have a nondecreasing ordered list from 1 - n where n > 3\\nlet freq[x] be the number of occurences of x in the list\\n\\nLemma 1: The first 3 unique numbers (1, 2, 3 in our case but holds generally) cannot be a tail and must be consecutive, otherwise no sequence can be made to start and the test fails. There are k of such sequences where k is the number of occurences of the first unique numer in the list. \\n\\nThe fourth number must create 1 of 3 cases. Let\\'s handle the simple case first. \\nIf all occurrences of the fourth unique number have been placed in sequences with the second or third, treat the next available unique number that does not have a sequence as the fourth. \\n\\nCase 1: the number is not consecutive to the last number in the list\\n\\nIn this case, a new sequence must be created from this number or the test fails since this number does not have a home and a home for it cannot be created. Note that the occurences of the second and third unique number in the list must equal the occurences of the first or the test would have failed already. \\n\\nSide note, we could think of this new set of numbers as a completely new list and test it separately, since all these conditions specified here would have to hold from this point on. This leads to another solution to this problem. \\n\\t\\nCase 2: the number is consecutive to the previous number and cannot make a new sequence\\n\\nHere the choice is made for us again. Simply place the number at the end of whatever sequence ends with the number before it. We know that at least k of such sequences exist from lemma 1.  \\n\\nCase 3: the number is consecutive and a new sequence may start from the number\\n\\nThe entirety of the new sequence that may be created from that number may also be placed at the end of an existing sequence and regarded as a continuation. Therefore, we don\\'t really care if a new sequence may be started from the number. We should place it at the end of an existing sequence because this also handles case 2. \\n",
                "solutionTags": [
                    "Python3",
                    "Greedy",
                    "Iterator"
                ],
                "code": "```\\nclass Solution: \\n    def isPossible(self, nums: List[int]) -> bool:\\n        if len(nums) < 3: return False\\n        \\n        freqs = Counter(nums)\\n        tails = Counter()\\n        \\n        for num in nums:\\n\\t\\t\\t\\n\\t\\t\\t# if the number already has a place in a sequence\\n            if freqs[num] == 0:\\n                continue\\n\\t\\t\\t\\t\\n\\t\\t\\t# if the number may be placed as a continuation of another sequence\\n            elif tails[num] > 0:\\n                tails[num] -= 1\\n                tails[num + 1] += 1\\n\\t\\t\\t\\n\\t\\t\\t# the number is not consecutive to a previous sequence\\n\\t\\t\\t# a new sequence must be created\\n            elif freqs[num + 1] > 0 and freqs[num + 2] > 0:\\n                freqs[num + 1] -= 1\\n                freqs[num + 2] -= 1\\n                tails[num + 3] += 1\\n            \\n\\t\\t\\t# if the number cannot continue a new sequence\\n\\t\\t\\t# and cannot begin a new sequence then the list\\n\\t\\t\\t# cannot be split\\n\\t\\t\\telse:\\n                return False\\n            freqs[num] -= 1\\n                \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2446789,
                "title": "c-three-multisets-short-and-sweet",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        multiset<int> l1, l2, l3;\\n        for (int i : nums) {\\n            if (l1.find(i - 1) != l1.end()) {\\n                l1.erase(l1.find(i - 1)), l2.insert(i);\\n            } else if (l2.find(i - 1) != l2.end()) {\\n                l2.erase(l2.find(i - 1)), l3.insert(i);\\n            } else if (l3.find(i - 1) != l3.end()) {\\n                l3.erase(l3.find(i - 1)), l3.insert(i);\\n            } else {\\n                l1.insert(i);\\n            }\\n        }\\n        return l1.empty() && l2.empty();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        multiset<int> l1, l2, l3;\\n        for (int i : nums) {\\n            if (l1.find(i - 1) != l1.end()) {\\n                l1.erase(l1.find(i - 1)), l2.insert(i);\\n            } else if (l2.find(i - 1) != l2.end()) {\\n                l2.erase(l2.find(i - 1)), l3.insert(i);\\n            } else if (l3.find(i - 1) != l3.end()) {\\n                l3.erase(l3.find(i - 1)), l3.insert(i);\\n            } else {\\n                l1.insert(i);\\n            }\\n        }\\n        return l1.empty() && l2.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2446725,
                "title": "daily-leetcoding-challenge-august-day-19",
                "content": "This problem is the Daily LeetCoding Challenge for August, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/split-array-into-consecutive-subsequences/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Greedy using Heap\n\n  \n**Approach 2:** Greedy using Maps\n\n  \n**Approach 3:** Dynamic Programming\n\n  \n**Approach 4:** Optimal Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/split-array-into-consecutive-subsequences/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1405127,
                "title": "python-85-frequency-count-greedy-explained",
                "content": "```\\ndef isPossible(self, nums: List[int]) -> bool:\\n        \"\"\"\\n            Greedy.\\n            for example below sequence \\n            1   2   2   3   3   4   5\\n            <--------------> start from value 1, stop at value 4 (as frequence[4]<frequence[3])\\n                <------------------->  start from value 2 (since frequency[1] is already 0), stop at 5\\n\\t\\t\\tall element frequency=0\\n\\t\\t\\t\\n            #1 get every element frequency\\n            #2 as long as frequency[i] >= frequency[i-1], count it into sub sequence and reduce frequency;\\n            #3 otherwise, start again from the first element\\'s frequency > 0\\n            until :\\n            #1 True = all element frequency = 0\\n            #2 False = frequency[j] < frequency[j-1] however length of sequence < 3\\n        \"\"\"\\n        freq = Counter(nums)\\n        start, end = min(freq.keys()), max(freq.keys())\\n        i = start\\n        while i < end+1:\\n            if freq[i] == 0:\\n                i+=1\\n                continue\\n            # current frequency should >= previous\\n            max_freq = freq[i]\\n            j=i\\n            count=0\\n            while j < end+1 and freq[j] >= max_freq:\\n                max_freq = max(freq[j], max_freq)\\n                freq[j]-=1\\n                j+=1\\n                count+=1\\n            if count < 3:\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\ndef isPossible(self, nums: List[int]) -> bool:\\n        \"\"\"\\n            Greedy.\\n            for example below sequence \\n            1   2   2   3   3   4   5\\n            <--------------> start from value 1, stop at value 4 (as frequence[4]<frequence[3])\\n                <------------------->  start from value 2 (since frequency[1] is already 0), stop at 5\\n\\t\\t\\tall element frequency=0\\n\\t\\t\\t\\n            #1 get every element frequency\\n            #2 as long as frequency[i] >= frequency[i-1], count it into sub sequence and reduce frequency;\\n            #3 otherwise, start again from the first element\\'s frequency > 0\\n            until :\\n            #1 True = all element frequency = 0\\n            #2 False = frequency[j] < frequency[j-1] however length of sequence < 3\\n        \"\"\"\\n        freq = Counter(nums)\\n        start, end = min(freq.keys()), max(freq.keys())\\n        i = start\\n        while i < end+1:\\n            if freq[i] == 0:\\n                i+=1\\n                continue\\n            # current frequency should >= previous\\n            max_freq = freq[i]\\n            j=i\\n            count=0\\n            while j < end+1 and freq[j] >= max_freq:\\n                max_freq = max(freq[j], max_freq)\\n                freq[j]-=1\\n                j+=1\\n                count+=1\\n            if count < 3:\\n                return False\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1145411,
                "title": "c-priority-queue-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    struct cmp {\\n        bool operator()(const vector<int>& a, const vector<int>& b) {\\n           return (a.back()>b.back());\\n        }\\n    };\\n    bool isPossible(vector<int>& nums) {\\n       int n = nums.size();\\n        //the top element in pq has the smallest last element\\n       priority_queue<vector<int>, vector<vector<int>>, cmp> pq; \\n       map<int,int> freq;\\n       vector<vector<int>> result;\\n        for(auto n: nums) {\\n            freq[n]++;\\n        }\\n        \\n        for(auto n : freq) {\\n            int x = n.first;\\n            while(freq[x]>0) { \\n                //if the last element is not x-1 cannot add to this subsequence. So there is no use in having this subsequence anymore in the pq as the elements are in sorted order.\\n                \\n                while (!pq.empty() && pq.top().back() < x-1) {\\n                    result.push_back(pq.top());\\n                    pq.pop();\\n                }\\n                //if last element is x-1 add x to the same subsequence \\n                if(!pq.empty() && pq.top().back()==x-1) {\\n                    vector<int> temp= pq.top();\\n                    temp.push_back(x);\\n                    pq.pop();\\n                    pq.push(temp);\\n                    freq[x]--;\\n                }\\n                //If priority queue is empyty or Cannot add to exisiting subsequence create a new subsequnce and check if the next 2 consecutive elements are present\\n                else if(freq[x+1]>0 && freq[x+2]>0) {\\n                    vector<int> temp = {x,x+1,x+2};\\n                    pq.push(temp);\\n                    freq[x]--;\\n                    freq[x+1]--;\\n                    freq[x+2]--;\\n                }\\n                else {\\n                    return 0; \\n                }\\n            }\\n        }\\n        //print the subsequences \\n        for(int i=0;i<result.size();i++) {\\n            for(int j=0;j<result[i].size();j++) {\\n                cout<<result[i][j]<<\" \";\\n            }\\n            cout<<endl;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    struct cmp {\\n        bool operator()(const vector<int>& a, const vector<int>& b) {\\n           return (a.back()>b.back());\\n        }\\n    };\\n    bool isPossible(vector<int>& nums) {\\n       int n = nums.size();\\n        //the top element in pq has the smallest last element\\n       priority_queue<vector<int>, vector<vector<int>>, cmp> pq; \\n       map<int,int> freq;\\n       vector<vector<int>> result;\\n        for(auto n: nums) {\\n            freq[n]++;\\n        }\\n        \\n        for(auto n : freq) {\\n            int x = n.first;\\n            while(freq[x]>0) { \\n                //if the last element is not x-1 cannot add to this subsequence. So there is no use in having this subsequence anymore in the pq as the elements are in sorted order.\\n                \\n                while (!pq.empty() && pq.top().back() < x-1) {\\n                    result.push_back(pq.top());\\n                    pq.pop();\\n                }\\n                //if last element is x-1 add x to the same subsequence \\n                if(!pq.empty() && pq.top().back()==x-1) {\\n                    vector<int> temp= pq.top();\\n                    temp.push_back(x);\\n                    pq.pop();\\n                    pq.push(temp);\\n                    freq[x]--;\\n                }\\n                //If priority queue is empyty or Cannot add to exisiting subsequence create a new subsequnce and check if the next 2 consecutive elements are present\\n                else if(freq[x+1]>0 && freq[x+2]>0) {\\n                    vector<int> temp = {x,x+1,x+2};\\n                    pq.push(temp);\\n                    freq[x]--;\\n                    freq[x+1]--;\\n                    freq[x+2]--;\\n                }\\n                else {\\n                    return 0; \\n                }\\n            }\\n        }\\n        //print the subsequences \\n        for(int i=0;i<result.size();i++) {\\n            for(int j=0;j<result[i].size();j++) {\\n                cout<<result[i][j]<<\" \";\\n            }\\n            cout<<endl;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 803607,
                "title": "o-n-time-o-1-space-solution-with-new-approach",
                "content": "Just maintain three variables and traverse the array. \\n1. len1cnt : count of subsequences of length 1 alive till now.\\n2. len2cnt : count of subsequences of length 2 alive till now.\\n3. len3plusCnt : count of subsequences of length 3 or more alive till now.\\n\\nFor every new element, we find frequency(freq) of it by looking ahead.\\nupdate those three variables greedily and skip the iteration by freq positions.\\nHere greedily means, give preferences to len1cnt & len2cnt variable while consuming the freq of the current element. Because if we were not able to extend them, then it will immediate return false i.e. no split is possible.\\n```\\nbool isPossible(vector<int>& nums) {\\n        int len1cnt=0,len2cnt=0,len3plusCnt=0;\\n        for(int i=0;i<nums.size();){\\n            int j=i+1;\\n            while(j<nums.size() && nums[j]==nums[i]) ++j;\\n            int freq=j-i;\\n            if(len1cnt+len2cnt>freq)\\n                return false;\\n            freq -= len1cnt+len2cnt;\\n            if(freq<=len3plusCnt){\\n                len3plusCnt = freq + len2cnt;\\n                len2cnt = len1cnt;\\n                len1cnt =0;\\n            }else{\\n                freq-=len3plusCnt;\\n                len3plusCnt += len2cnt;\\n                len2cnt=len1cnt;\\n                len1cnt=freq;\\n            }\\n            if(j<nums.size() && nums[i]+1 != nums[j]){\\n                if(len1cnt || len2cnt) return false;\\n                len1cnt=0,len2cnt=0,len3plusCnt=0;\\n            }\\n            i=j;\\n        }\\n        if(len1cnt || len2cnt) return false;\\n        return true;\\n\\t\\t}\\n```",
                "solutionTags": [],
                "code": "```\\nbool isPossible(vector<int>& nums) {\\n        int len1cnt=0,len2cnt=0,len3plusCnt=0;\\n        for(int i=0;i<nums.size();){\\n            int j=i+1;\\n            while(j<nums.size() && nums[j]==nums[i]) ++j;\\n            int freq=j-i;\\n            if(len1cnt+len2cnt>freq)\\n                return false;\\n            freq -= len1cnt+len2cnt;\\n            if(freq<=len3plusCnt){\\n                len3plusCnt = freq + len2cnt;\\n                len2cnt = len1cnt;\\n                len1cnt =0;\\n            }else{\\n                freq-=len3plusCnt;\\n                len3plusCnt += len2cnt;\\n                len2cnt=len1cnt;\\n                len1cnt=freq;\\n            }\\n            if(j<nums.size() && nums[i]+1 != nums[j]){\\n                if(len1cnt || len2cnt) return false;\\n                len1cnt=0,len2cnt=0,len3plusCnt=0;\\n            }\\n            i=j;\\n        }\\n        if(len1cnt || len2cnt) return false;\\n        return true;\\n\\t\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 733533,
                "title": "simple-javascript-solution",
                "content": "This is the javascript version of the solution posted here https://leetcode.com/problems/split-array-into-consecutive-subsequences/discuss/106496/Java-O(n)-Time-O(n)-Space in Java.\\n```\\nvar isPossible = function(nums) {\\n    if(nums.length < 3) return false;\\n    \\n    const freqMap = new Map(), appendfreq = new Map();\\n    nums.forEach(card => {\\n        if (!freqMap.has(card))\\n            freqMap.set(card, 0);\\n        \\n        freqMap.set(card, freqMap.get(card) + 1);\\n    });\\n    \\n     for (let i of nums) {\\n        if (freqMap.get(i) == 0) continue;\\n        else if ((appendfreq.get(i) || 0) > 0) {\\n            appendfreq.set(i, appendfreq.get(i) - 1);\\n            appendfreq.set(i+1, (appendfreq.get(i+1) || 0) + 1);\\n        }   \\n        else if ((freqMap.get(i+1) || 0) > 0 && (freqMap.get(i+2) || 0) > 0) {\\n            freqMap.set(i+1, freqMap.get(i+1) - 1);\\n            freqMap.set(i+2, freqMap.get(i+2) - 1);\\n            appendfreq.set(i+3, (appendfreq.get(i+3) || 0) + 1);\\n        }\\n        else return false;\\n        freqMap.set(i, freqMap.get(i) - 1);\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isPossible = function(nums) {\\n    if(nums.length < 3) return false;\\n    \\n    const freqMap = new Map(), appendfreq = new Map();\\n    nums.forEach(card => {\\n        if (!freqMap.has(card))\\n            freqMap.set(card, 0);\\n        \\n        freqMap.set(card, freqMap.get(card) + 1);\\n    });\\n    \\n     for (let i of nums) {\\n        if (freqMap.get(i) == 0) continue;\\n        else if ((appendfreq.get(i) || 0) > 0) {\\n            appendfreq.set(i, appendfreq.get(i) - 1);\\n            appendfreq.set(i+1, (appendfreq.get(i+1) || 0) + 1);\\n        }   \\n        else if ((freqMap.get(i+1) || 0) > 0 && (freqMap.get(i+2) || 0) > 0) {\\n            freqMap.set(i+1, freqMap.get(i+1) - 1);\\n            freqMap.set(i+2, freqMap.get(i+2) - 1);\\n            appendfreq.set(i+3, (appendfreq.get(i+3) || 0) + 1);\\n        }\\n        else return false;\\n        freqMap.set(i, freqMap.get(i) - 1);\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 636270,
                "title": "share-a-java-intuitive-solution-o-n",
                "content": "This solution is not fast but intuitive. I think it is acceptable during the interview.\\n```\\npublic boolean isPossible(int[] nums) {\\n        Map<Integer, Integer> freq = new HashMap<>();\\n        for (int num : nums) {\\n            freq.put(num, freq.getOrDefault(num, 0) + 1);\\n        }\\n\\n        for (int num : nums) {\\n            if (!freq.containsKey(num)) {\\n                continue;\\n            }\\n            int minOccur = 1;\\n            int tmp = num;\\n            while (freq.containsKey(tmp) && freq.get(tmp) >= minOccur) {\\n                minOccur = Math.max(minOccur, freq.get(tmp));\\n                freq.put(tmp, freq.get(tmp) - 1);\\n                if (freq.get(tmp) == 0) {\\n                    freq.remove(tmp);\\n                }\\n                tmp++;\\n            }\\n            if (tmp - num < 3) return false;\\n        }\\n        return freq.isEmpty();\\n    }\\n```\\n\\nExplaniation for `freq.get(tmp) >= minOccur`: if we have \\n\\n```\\n1 2 3 4\\n. . 3 4 5\\n```\\nWhen we visit `5`, the occurance decreases. We should stop and let next subarray have it.",
                "solutionTags": [],
                "code": "```\\npublic boolean isPossible(int[] nums) {\\n        Map<Integer, Integer> freq = new HashMap<>();\\n        for (int num : nums) {\\n            freq.put(num, freq.getOrDefault(num, 0) + 1);\\n        }\\n\\n        for (int num : nums) {\\n            if (!freq.containsKey(num)) {\\n                continue;\\n            }\\n            int minOccur = 1;\\n            int tmp = num;\\n            while (freq.containsKey(tmp) && freq.get(tmp) >= minOccur) {\\n                minOccur = Math.max(minOccur, freq.get(tmp));\\n                freq.put(tmp, freq.get(tmp) - 1);\\n                if (freq.get(tmp) == 0) {\\n                    freq.remove(tmp);\\n                }\\n                tmp++;\\n            }\\n            if (tmp - num < 3) return false;\\n        }\\n        return freq.isEmpty();\\n    }\\n```\n```\\n1 2 3 4\\n. . 3 4 5\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 597442,
                "title": "really-simple-c-solution-o-n",
                "content": "I used the fact that the list is sorted and a possible subssequence can only have elements whose frequence in the list is the same or greater than the predecessor.\\n\\n``` cpp\\nbool isPossible(vector<int>& nums) {\\n        unordered_map<int, int> m;\\n        for(int n: nums) m[n]++;\\n        for(int n: nums){\\n            if(m[n] == 0) continue;\\n            int freq = m[n], count = 0, curr = n;\\n            while(m.count(curr) && m[curr] >= freq){\\n                freq = max(freq, m[curr]);\\n                m[curr]--;\\n                curr++;\\n                count++;\\n            }\\n            if(count < 3) return false;\\n        }\\n        return true;\\n    }\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "``` cpp\\nbool isPossible(vector<int>& nums) {\\n        unordered_map<int, int> m;\\n        for(int n: nums) m[n]++;\\n        for(int n: nums){\\n            if(m[n] == 0) continue;\\n            int freq = m[n], count = 0, curr = n;\\n            while(m.count(curr) && m[curr] >= freq){\\n                freq = max(freq, m[curr]);\\n                m[curr]--;\\n                curr++;\\n                count++;\\n            }\\n            if(count < 3) return false;\\n        }\\n        return true;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 216072,
                "title": "javascript",
                "content": "```\\nvar isPossible = function(nums) {\\n    let count = {}, tail = {}\\n    \\n    for(let n of nums){\\n        count[n] = count[n] ? count[n] + 1 : 1 \\n    }\\n\\n    for(let n  of nums){\\n        if(count[n] === 0){\\n            continue\\n        } else if (tail[n] > 0) {\\n            tail[n] -= 1\\n            tail[n + 1] = tail[n + 1] ? tail[n + 1] + 1 : 1\\n        } else if(count[n + 1] > 0 && count[n + 2] > 0) {\\n            count[n + 1] -= 1\\n            count[n + 2] -= 1\\n            tail[n + 3] = tail[n + 3] ? tail[n + 3] + 1 : 1\\n        } else{\\n            return false\\n        }\\n        count[n] -= 1\\n    }\\n    return true\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar isPossible = function(nums) {\\n    let count = {}, tail = {}\\n    \\n    for(let n of nums){\\n        count[n] = count[n] ? count[n] + 1 : 1 \\n    }\\n\\n    for(let n  of nums){\\n        if(count[n] === 0){\\n            continue\\n        } else if (tail[n] > 0) {\\n            tail[n] -= 1\\n            tail[n + 1] = tail[n + 1] ? tail[n + 1] + 1 : 1\\n        } else if(count[n + 1] > 0 && count[n + 2] > 0) {\\n            count[n + 1] -= 1\\n            count[n + 2] -= 1\\n            tail[n + 3] = tail[n + 3] ? tail[n + 3] + 1 : 1\\n        } else{\\n            return false\\n        }\\n        count[n] -= 1\\n    }\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 106519,
                "title": "new-solution-using-a-queue-iterate-once-only-beat-99-5-18ms-in-java",
                "content": "This problems seems like several threads starting at different timestamps, we can count the number of \"thread\" starting and ending at each timestamp. \\ne.g. the given array is [1, 1, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 6]\\nwe can consider the \"threads\" start and end as below:\\ntimestamp:    0   1   2   3   4   5  \\ncount:            2   2   3   3   2   1\\nstart:             2   0   1   0   0   0         \\nend:              0   0   1   1   1   1\\ne.g. at timestamp 0, two thread start; at timestamp 2, one starts and another one ends\\n\\n```\\npublic class Solution {\\n    Queue<int[]> queue;\\n    int timestamp;\\n    int dif;\\n    public boolean isPossible(int[] nums) {\\n        if (nums == null || nums.length == 0) return false;\\n        int precount = 0;                 // count at the last timestamp\\n        int count = 1;                    // count at the current timestamp\\n        dif = 0;                          // change of the count at the current timestamp, dif = 1 means a new                                                    thread starts; dif = -1 means a thread ends\\n        timestamp = 0;\\n        queue = new LinkedList<>();    // using a queue to record the running thread, int[] includs a starting timestamp, and the number of theads that start at this timestamp are still running. \\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] > nums[i - 1] + 1) {// not consecutive, means all the threads end now  \\n                dif = count - precount;\\n                if (!processQueue()) return false;\\n                timestamp++;\\n                dif = -count;\\n                if (!processQueue()) return false;\\n                if (!queue.isEmpty()) return false;     // check whether all the runing threads end now   \\n                precount = 0;                           \\n                count = 1;\\n                timestamp = 0;\\n            } else if (nums[i] == nums[i - 1]) {\\n                count++;\\n            } else {\\n                dif = count - precount;\\n                if (!processQueue()) return false;\\n                precount = count;\\n                count = 1;\\n                timestamp++;\\n            }\\n        }\\n        dif = count - precount;\\n        if (!processQueue()) return false;\\n        timestamp++;\\n        dif = -count;\\n        if (!processQueue()) return false;\\n        return queue.isEmpty();                        // check whether all the runing threads end now\\n    }\\n    \\n    public boolean processQueue() {\\n        // if the number of running threads changes (dif != 0), dif > 0 means new thread starts, put into queue; dif < 0 means old thread ends, poll from queue, and check whether this thread has run for 3+ timestamps. \\n        if (dif > 0) {\\n            queue.offer(new int[]{timestamp, dif});\\n        } else {\\n            while(dif < 0) {\\n                if (queue.isEmpty() || timestamp - queue.peek()[0] < 3) {\\n                    return false;\\n                } else if (queue.peek()[1] + dif > 0) {\\n                    queue.peek()[1] += dif;\\n                    break;\\n                } else {\\n                    dif += queue.poll()[1];\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    Queue<int[]> queue;\\n    int timestamp;\\n    int dif;\\n    public boolean isPossible(int[] nums) {\\n        if (nums == null || nums.length == 0) return false;\\n        int precount = 0;                 // count at the last timestamp\\n        int count = 1;                    // count at the current timestamp\\n        dif = 0;                          // change of the count at the current timestamp, dif = 1 means a new                                                    thread starts; dif = -1 means a thread ends\\n        timestamp = 0;\\n        queue = new LinkedList<>();    // using a queue to record the running thread, int[] includs a starting timestamp, and the number of theads that start at this timestamp are still running. \\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] > nums[i - 1] + 1) {// not consecutive, means all the threads end now  \\n                dif = count - precount;\\n                if (!processQueue()) return false;\\n                timestamp++;\\n                dif = -count;\\n                if (!processQueue()) return false;\\n                if (!queue.isEmpty()) return false;     // check whether all the runing threads end now   \\n                precount = 0;                           \\n                count = 1;\\n                timestamp = 0;\\n            } else if (nums[i] == nums[i - 1]) {\\n                count++;\\n            } else {\\n                dif = count - precount;\\n                if (!processQueue()) return false;\\n                precount = count;\\n                count = 1;\\n                timestamp++;\\n            }\\n        }\\n        dif = count - precount;\\n        if (!processQueue()) return false;\\n        timestamp++;\\n        dif = -count;\\n        if (!processQueue()) return false;\\n        return queue.isEmpty();                        // check whether all the runing threads end now\\n    }\\n    \\n    public boolean processQueue() {\\n        // if the number of running threads changes (dif != 0), dif > 0 means new thread starts, put into queue; dif < 0 means old thread ends, poll from queue, and check whether this thread has run for 3+ timestamps. \\n        if (dif > 0) {\\n            queue.offer(new int[]{timestamp, dif});\\n        } else {\\n            while(dif < 0) {\\n                if (queue.isEmpty() || timestamp - queue.peek()[0] < 3) {\\n                    return false;\\n                } else if (queue.peek()[1] + dif > 0) {\\n                    queue.peek()[1] += dif;\\n                    break;\\n                } else {\\n                    dif += queue.poll()[1];\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3037060,
                "title": "best-hand-written-explanation-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![Screenshot_20230111_235707.png](https://assets.leetcode.com/users/images/cac07a6f-58cc-42b6-bb88-ff1c8c000e78_1673461790.3325224.png)\\n![Screenshot_20230111_235732.png](https://assets.leetcode.com/users/images/b2536e07-6f11-4167-9499-1ab89461281c_1673461801.4203238.png)\\n![Screenshot_20230111_235745.png](https://assets.leetcode.com/users/images/78117914-9ac1-4dad-9898-21bab8002ea7_1673461812.7470374.png)\\n\\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& arr) \\n    {\\n        //We need 2 hashmaps->\\n        //1.available(to store what elements are available)\\n        //2.requirement(to store what elements are required by a previous subsequence)\\n        unordered_map<int,int>avail,req;\\n        //traverse the elements and store the count in the avail map\\n        for(auto it:arr)\\n            avail[it]++;\\n        //traverse the array and check the conditions\\n        for(auto it:arr)\\n        {\\n            if(avail[it]==0)//element is not available to be added in any subseq\\n                continue;\\n            avail[it]--;\\n            //check if the element is required by a previous subseq\\n            if(req[it])\\n            {\\n                //add to the prev subseq\\n                req[it]--;\\n                req[it+1]++;\\n            }\\n            //check if we can start a new subseq\\n            else if(avail[it+1] && avail[it+2])\\n            {\\n                avail[it+1]--;\\n                avail[it+2]--;\\n                req[it+3]++;\\n            }\\n            //valid subsequence is not possible\\n            else\\n                return false;\\n        }\\n        return true;\\n        \\n    }\\n};\\n```\\n**Please upvote if this solution helped you. Thanks :)**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& arr) \\n    {\\n        //We need 2 hashmaps->\\n        //1.available(to store what elements are available)\\n        //2.requirement(to store what elements are required by a previous subsequence)\\n        unordered_map<int,int>avail,req;\\n        //traverse the elements and store the count in the avail map\\n        for(auto it:arr)\\n            avail[it]++;\\n        //traverse the array and check the conditions\\n        for(auto it:arr)\\n        {\\n            if(avail[it]==0)//element is not available to be added in any subseq\\n                continue;\\n            avail[it]--;\\n            //check if the element is required by a previous subseq\\n            if(req[it])\\n            {\\n                //add to the prev subseq\\n                req[it]--;\\n                req[it+1]++;\\n            }\\n            //check if we can start a new subseq\\n            else if(avail[it+1] && avail[it+2])\\n            {\\n                avail[it+1]--;\\n                avail[it+2]--;\\n                req[it+3]++;\\n            }\\n            //valid subsequence is not possible\\n            else\\n                return false;\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467023,
                "title": "python-solution-fully-explained-with-examples",
                "content": "```\\nfrom collections import Counter as counter #library for making frequency of numbers of list\\nclass Solution:\\n    def isPossible(self, nums: List[int]) -> bool: \\n        #make frequency of list nums\\n        f=counter(nums)\\n        print(f) \\n        #create dictionary for storing frequency of last numbers of subsequence\\n        m=counter()\\n        #loop for nums\\'s numbers\\n        for i in nums:\\n            #if frequency of any number becomes 0 then skip\\n            if f[i]==0:\\n                continue \\n            #if just previous number of last number of any subsequence present\\n            #in m(not having freq 0 means m[i-1]>0) then it can be appended in any existing \\n            #subsequence , example is nums= [1,2,3,3,4,4,5,5] \\n            #if make [1,2,3],[3,4,5],[4,5] this will return false but that should be true \\n            #so this below condition will help to join [1,2,3],[4,5] = [1,2,3,4,5]\\n            if m[i-1]>0:\\n                f[i]-=1\\n                m[i]+=1\\n                m[i-1]-=1\\n            # initially making subsequence of length 3 so checking three consecutive numbers\\n            # i.e , f[i] , f[i+1] , f[i+2]\\n            elif f[i]>0 and f[i+1]>0 and f[i+2]>0: \\n                #after amking of subsequence decrement the frequency of those numbers\\n                #because they are already used in subsequence\\n                f[i]-=1\\n                f[i+1]-=1\\n                f[i+2]-=1\\n                m[i+2]+=1\\n            #if above conditions dont satisfy then return false\\n            else:\\n                return False\\n        #if everything will go conditionally (or not false) then return true\\n        print(m)\\n        return True\\n        \\n``` \\n**Please upvote if you found it helpful**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nfrom collections import Counter as counter #library for making frequency of numbers of list\\nclass Solution:\\n    def isPossible(self, nums: List[int]) -> bool: \\n        #make frequency of list nums\\n        f=counter(nums)\\n        print(f) \\n        #create dictionary for storing frequency of last numbers of subsequence\\n        m=counter()\\n        #loop for nums\\'s numbers\\n        for i in nums:\\n            #if frequency of any number becomes 0 then skip\\n            if f[i]==0:\\n                continue \\n            #if just previous number of last number of any subsequence present\\n            #in m(not having freq 0 means m[i-1]>0) then it can be appended in any existing \\n            #subsequence , example is nums= [1,2,3,3,4,4,5,5] \\n            #if make [1,2,3],[3,4,5],[4,5] this will return false but that should be true \\n            #so this below condition will help to join [1,2,3],[4,5] = [1,2,3,4,5]\\n            if m[i-1]>0:\\n                f[i]-=1\\n                m[i]+=1\\n                m[i-1]-=1\\n            # initially making subsequence of length 3 so checking three consecutive numbers\\n            # i.e , f[i] , f[i+1] , f[i+2]\\n            elif f[i]>0 and f[i+1]>0 and f[i+2]>0: \\n                #after amking of subsequence decrement the frequency of those numbers\\n                #because they are already used in subsequence\\n                f[i]-=1\\n                f[i+1]-=1\\n                f[i+2]-=1\\n                m[i+2]+=1\\n            #if above conditions dont satisfy then return false\\n            else:\\n                return False\\n        #if everything will go conditionally (or not false) then return true\\n        print(m)\\n        return True\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2449886,
                "title": "python-solution-using-heap",
                "content": "```\\nclass Solution:\\n    def isPossible(self, nums: List[int]) -> bool:\\n        \\n        if len(nums)<3:\\n            return False\\n        \\n        heap=[]\\n        \\n        for x in nums:\\n            \\n            while heap and (x>(heap[0][0]+1)):\\n                length= heapq.heappop(heap)\\n                if length[1]<3:\\n                    return False\\n            \\n            if heap and x==(heap[0][0]+1):\\n                length=heapq.heappop(heap)\\n                heapq.heappush(heap,(x,length[1]+1))\\n            else:\\n                heapq.heappush(heap,(x,1))\\n        \\n        while heap:\\n            if heapq.heappop(heap)[1]<3:\\n                return False\\n        \\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def isPossible(self, nums: List[int]) -> bool:\\n        \\n        if len(nums)<3:\\n            return False\\n        \\n        heap=[]\\n        \\n        for x in nums:\\n            \\n            while heap and (x>(heap[0][0]+1)):\\n                length= heapq.heappop(heap)\\n                if length[1]<3:\\n                    return False\\n            \\n            if heap and x==(heap[0][0]+1):\\n                length=heapq.heappop(heap)\\n                heapq.heappush(heap,(x,length[1]+1))\\n            else:\\n                heapq.heappush(heap,(x,1))\\n        \\n        while heap:\\n            if heapq.heappop(heap)[1]<3:\\n                return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447445,
                "title": "c-unordered-map-with-explanation-o-n-time-and-o-n-space",
                "content": "Approach:\\nThe maximum frequency of an element that can be accomodated is the number of subsequences that can start at it + number of subsequences that end at it + number of subsequences in which number can come in between.\\n\\nNumber of subsequences that can start from element i : start = min(freq[i+1],freq[i+2]);\\nNumber of subsequences that can end at element i : end = min(freq[i-1],freq[i-2]);\\nNumber of subsequences in which i can come in between : mid = min(freq[i+1]-start,freq[i-1]-end);\\n\\nif the freq[i] is more than start+end+mid then we can not form the required subsequence and false is returned, otherwise true is returned\\n\\n\\nSince frequency of each element is stored in a map,\\nSpace Complexity : O(n)\\n\\nSince each element of array will be traversed twice(once for freq calculation and once for checking),\\nTime Complexity : O(n) \\n\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        unordered_map<int,int> freq;\\n        for(int i : nums){\\n            freq[i]++;\\n        }\\n\\n        for(auto& i:nums){\\n            int ft = freq[i];\\n            int end = min(freq[i-1],freq[i-2]); //max no of sub sequences ending at i\\n            int start = min(freq[i+1],freq[i+2]); //max no of subsequences starting at i \\n            ft = ft - end - start - min(freq[i+1]-start,freq[i-1]-end); \\n            if(ft>0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        unordered_map<int,int> freq;\\n        for(int i : nums){\\n            freq[i]++;\\n        }\\n\\n        for(auto& i:nums){\\n            int ft = freq[i];\\n            int end = min(freq[i-1],freq[i-2]); //max no of sub sequences ending at i\\n            int start = min(freq[i+1],freq[i+2]); //max no of subsequences starting at i \\n            ft = ft - end - start - min(freq[i+1]-start,freq[i-1]-end); \\n            if(ft>0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447388,
                "title": "java-easy-hashmap-greedy",
                "content": "# Please Upvote \\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\n```\\nMap<Integer, Integer> count = new HashMap<>();\\n    List<Integer> starts = new ArrayList<>(); // start index of subsequence\\n    List<Integer> ends = new ArrayList<>();   // end index of subsequence\\n\\n    for (final int num : nums)\\n      count.put(num, count.getOrDefault(num, 0) + 1);\\n\\n    for (int i = 0; i < nums.length; ++i) {\\n      if (i > 0 && nums[i] == nums[i - 1])\\n        continue;\\n      final int num = nums[i];\\n      final int currCount = count.get(num);\\n      final int prevCount = count.containsKey(num - 1) ? count.get(num - 1) : 0;\\n      final int nextCount = count.containsKey(num + 1) ? count.get(num + 1) : 0;\\n      for (int j = 0; j < currCount - prevCount; ++j)\\n        starts.add(num);\\n      for (int j = 0; j < currCount - nextCount; ++j)\\n        ends.add(num);\\n    }\\n\\n    for (int i = 0; i < starts.size(); ++i)\\n      if (ends.get(i) - starts.get(i) < 2)\\n        return false;\\n\\n    return true;\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nMap<Integer, Integer> count = new HashMap<>();\\n    List<Integer> starts = new ArrayList<>(); // start index of subsequence\\n    List<Integer> ends = new ArrayList<>();   // end index of subsequence\\n\\n    for (final int num : nums)\\n      count.put(num, count.getOrDefault(num, 0) + 1);\\n\\n    for (int i = 0; i < nums.length; ++i) {\\n      if (i > 0 && nums[i] == nums[i - 1])\\n        continue;\\n      final int num = nums[i];\\n      final int currCount = count.get(num);\\n      final int prevCount = count.containsKey(num - 1) ? count.get(num - 1) : 0;\\n      final int nextCount = count.containsKey(num + 1) ? count.get(num + 1) : 0;\\n      for (int j = 0; j < currCount - prevCount; ++j)\\n        starts.add(num);\\n      for (int j = 0; j < currCount - nextCount; ++j)\\n        ends.add(num);\\n    }\\n\\n    for (int i = 0; i < starts.size(); ++i)\\n      if (ends.get(i) - starts.get(i) < 2)\\n        return false;\\n\\n    return true;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2447139,
                "title": "c-easy-to-understand-unordered-map",
                "content": "**MY CODE**\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        \\n        unordered_map<int,int> mp;\\n        for(int i =0;i<nums.size();i++) mp[nums[i]]++;\\n        for(int i =0;i<nums.size();i++)\\n        {\\n            if(mp[nums[i]] == 0) continue;\\n\\t\\t\\t\\n            int freq = mp[nums[i]] , curr =nums[i] , c = 0;\\n            \\n            while(mp.count(curr) and mp[curr] >= freq)\\n            {\\n                freq = max(freq,mp[curr]);\\n                mp[curr]--;\\n                c++;\\n                curr++;\\n            }\\n            if(c < 3) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        \\n        unordered_map<int,int> mp;\\n        for(int i =0;i<nums.size();i++) mp[nums[i]]++;\\n        for(int i =0;i<nums.size();i++)\\n        {\\n            if(mp[nums[i]] == 0) continue;\\n\\t\\t\\t\\n            int freq = mp[nums[i]] , curr =nums[i] , c = 0;\\n            \\n            while(mp.count(curr) and mp[curr] >= freq)\\n            {\\n                freq = max(freq,mp[curr]);\\n                mp[curr]--;\\n                c++;\\n                curr++;\\n            }\\n            if(c < 3) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2446904,
                "title": "java-easy-and-very-simple-o-n-solution-using-hashmap",
                "content": "If you find the code helpful, you may consider upvote :)\\n\\n\\n```\\nclass Solution {\\n    public boolean isPossible(int[] nums) {\\n        \\n        HashMap<Integer, Integer> frequencyMap = new HashMap<>();\\n        HashMap<Integer, Integer> hypotheticalMap = new HashMap<>();\\n        \\n        for(int i : nums){\\n            frequencyMap.put(i, frequencyMap.getOrDefault(i, 0) + 1);\\n        }\\n        \\n        for(int i : nums){\\n            \\n            int fromFm = frequencyMap.getOrDefault(i, 0);\\n            int fromHm = hypotheticalMap.getOrDefault(i, 0);\\n            \\n            if(fromFm == 0) continue;\\n            \\n            if(fromHm > 0) {\\n                hypotheticalMap.put(i, fromHm - 1);\\n                hypotheticalMap.put(i+1, hypotheticalMap.getOrDefault(i + 1, 0) + 1);\\n                frequencyMap.put(i, fromFm - 1);\\n            }\\n            else if(frequencyMap.getOrDefault(i, 0) > 0 && frequencyMap.getOrDefault(i + 1, 0) > 0 && frequencyMap.getOrDefault(i + 2, 0) > 0) {\\n                frequencyMap.put(i, frequencyMap.get(i) - 1);\\n                frequencyMap.put(i + 1, frequencyMap.get(i + 1) - 1);\\n                frequencyMap.put(i + 2, frequencyMap.get(i + 2) - 1);\\n                hypotheticalMap.put(i+3, hypotheticalMap.getOrDefault(i + 3, 0) + 1);\\n                \\n            }\\n            else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean isPossible(int[] nums) {\\n        \\n        HashMap<Integer, Integer> frequencyMap = new HashMap<>();\\n        HashMap<Integer, Integer> hypotheticalMap = new HashMap<>();\\n        \\n        for(int i : nums){\\n            frequencyMap.put(i, frequencyMap.getOrDefault(i, 0) + 1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2446853,
                "title": "c-solution-using-hashmap",
                "content": "# **C++ Solution Using Hashmap**\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        unordered_map<int,int>m,endWith;\\n        for(int val:nums){\\n            m[val]++;\\n        }\\n        \\n        int subseq=0;\\n        for(int val:nums){\\n            if(m[val]==0)continue;\\n            m[val]--;\\n            if(endWith[val-1]>0){\\n                endWith[val-1]--;\\n                endWith[val]++;\\n            }\\n            else if(m[val+1]&&m[val+2]){\\n                m[val+1]--;\\n                m[val+2]--;\\n                endWith[val+2]++;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n# **Please Share and Upvote**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        unordered_map<int,int>m,endWith;\\n        for(int val:nums){\\n            m[val]++;\\n        }\\n        \\n        int subseq=0;\\n        for(int val:nums){\\n            if(m[val]==0)continue;\\n            m[val]--;\\n            if(endWith[val-1]>0){\\n                endWith[val-1]--;\\n                endWith[val]++;\\n            }\\n            else if(m[val+1]&&m[val+2]){\\n                m[val+1]--;\\n                m[val+2]--;\\n                endWith[val+2]++;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2446843,
                "title": "rust-hashmap",
                "content": "~~~\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn is_possible(nums: Vec<i32>) -> bool {\\n        let mut mp = HashMap::<i32, i32>::new();\\n        for a in &nums { \\n            *mp.entry(*a).or_default() += 1; \\n        }\\n        \\n        for a in nums {\\n            let mut cnt = if let Some(count) = mp.get(&a) { *count } else { 0 };\\n            if cnt == 0 { continue; }\\n            \\n            let mut count = 0;\\n            let mut n = a;\\n            while let Some(m) = mp.get(&n) {\\n                if *m < cnt { break }\\n                cnt = *m;\\n                *mp.entry(n).or_default() -= 1;\\n                count += 1;\\n                n += 1;\\n            }\\n            if count < 3 { return false }\\n        }\\n        \\n        true\\n    }\\n}\\n~~~",
                "solutionTags": [
                    "Rust"
                ],
                "code": "~~~\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn is_possible(nums: Vec<i32>) -> bool {\\n        let mut mp = HashMap::<i32, i32>::new();\\n        for a in &nums { \\n            *mp.entry(*a).or_default() += 1; \\n        }\\n        \\n        for a in nums {\\n            let mut cnt = if let Some(count) = mp.get(&a) { *count } else { 0 };\\n            if cnt == 0 { continue; }\\n            \\n            let mut count = 0;\\n            let mut n = a;\\n            while let Some(m) = mp.get(&n) {\\n                if *m < cnt { break }\\n                cnt = *m;\\n                *mp.entry(n).or_default() -= 1;\\n                count += 1;\\n                n += 1;\\n            }\\n            if count < 3 { return false }\\n        }\\n        \\n        true\\n    }\\n}\\n~~~",
                "codeTag": "Unknown"
            },
            {
                "id": 2446770,
                "title": "python-o-n-tc-intuitive-faster-than-99",
                "content": "**Solution 1 - not the most efficient, but intuitive and easy to understand**\\n\\n1. We\\'ll iterate over the list and keep track of all the existing subsequence prefixes using their last element as key:\\n```\\nprefixes: dict[int, list[int]]\\nprefixes[n] - descriptor of prefixes ending with n\\n```\\n2. Each prefix descriptor is a list of three integers, `[n1, n2, n3]`. `n1` is the number of subsequence prefixes of length `1`, `n2` is the number of prefixes of length `2` and `n3` is the number of prefixes of length >= `3`.\\n3. For each element `n` from the input list, we\\'ll try to attach it to a pre-existing subsequence ending at `n-1`, using the shortest of the existing prefixes. Then we\\'ll update the prefix descriptor for `n` itself.\\n4. Once the iteration is over, we simply need to check that there are no prefixes left with length less than `3`\\n\\n```\\nclass Solution:\\n    def isPossible(self, nums: List[int]) -> bool:\\n        def gen_prefix_list() -> list[int]:\\n            return [0, 0, 0]\\n        \\n        prefixes: dict[int, list[int]] = defaultdict(lambda: gen_prefix_list())\\n\\n        for n in nums:\\n            prefix = prefixes[n]\\n            \\n            if n-1 in prefixes:\\n                prev_prefix = prefixes[n-1]                \\n                if prev_prefix[0]:\\n                    prev_prefix[0] -= 1\\n                    prefix[1] += 1\\n                elif prev_prefix[1]:\\n                    prev_prefix[1] -= 1\\n                    prefix[2] += 1\\n                elif prev_prefix[2]:\\n                    prev_prefix[2] -= 1\\n                    prefix[2] += 1\\n                if prev_prefix[0] == prev_prefix[1] == prev_prefix[2] == 0:\\n                    prefixes.pop(n-1)\\n            else:\\n                prefix[0] += 1\\n        return all(p[0] == p[1] == 0 for p in prefixes.values())\\n```\\n\\n**Time complexity - O(n)\\nSpace complexity - O(n)**\\n\\nThis solution is universal because it will work even if array values are not sorted. But it also means that it may be optimised further\\n\\n**Solution 2 - optimised but more complex**\\n\\n1. We\\'ll still iterate over the input list, but instead of keeping track of all pre-existing prefixes, we only track prefixes ending with value of current list element.\\n2. We also keep track of the prefixes for the value that was before the current one, so if the current element is equal to `n2` and the previous element value was `n1` then we keep track of prefixes for `n1` (`prev_stats`) and for `n2` (`cur_stats`).\\n3. As in the first solution, each array element equal to `n2` we\\'ll try to connect to a pre-existing prefix for `n1`, prioritising shorter prefixes. If elements equal to `n2` run out before all the shorter `n1` prefixes are grown to at least 3 then the algo returns `False`.\\n4. When we go from `n2` to next value `n3`, `cur_stats` become `prev_stats` and the cycle repeats.\\n\\n```\\nclass Solution:\\n    def isPossible(self, nums: List[int]) -> bool:\\n        cur_val = nums[0]\\n        prev_stats = [0, 0, 0]  # [len 1 subseqs, len 2 subseqs, len 3+ subseqs]\\n        cur_stats = [0, 0, 0]\\n\\n        for n in nums:\\n            if n != cur_val:\\n\\t\\t\\t\\t# checking if all the relevant older sequences have been grown to at least 3\\n\\t\\t\\t\\tif prev_stats[0] or prev_stats[1] or (cur_stats[0] or cur_stats[1]) and n != cur_val + 1:\\n                    return False\\n                \\n                prev_stats = cur_stats if n == cur_val + 1 else [0, 0, 0]  # if we skipped a number older stats don\\'t matter\\n                cur_val = n\\n                cur_stats = [0, 0, 0]\\n            \\n            if prev_stats[0]:\\n                prev_stats[0] -= 1\\n                cur_stats[1] += 1\\n            elif prev_stats[1]:\\n                prev_stats[1] -= 1\\n                cur_stats[2] += 1\\n            elif prev_stats[2]:\\n                prev_stats[2] -= 1\\n                cur_stats[2] += 1\\n            else:\\n                cur_stats[0] += 1\\n        \\n        return not(prev_stats[0] or prev_stats[1] or cur_stats[0] or cur_stats[1])\\n```\\n\\n**Time complexity - O(n)\\nSpace complexity - O(1)**\\n\\nThis solution ran at 518 ms, which was faster than 99% solutions in Python.\\n\\nIf you have any questions, don\\'t hesitate to ask in the comments!\\nPlease upvote this post if you found it useful \\uD83D\\uDE04",
                "solutionTags": [],
                "code": "```\\nprefixes: dict[int, list[int]]\\nprefixes[n] - descriptor of prefixes ending with n\\n```\n```\\nclass Solution:\\n    def isPossible(self, nums: List[int]) -> bool:\\n        def gen_prefix_list() -> list[int]:\\n            return [0, 0, 0]\\n        \\n        prefixes: dict[int, list[int]] = defaultdict(lambda: gen_prefix_list())\\n\\n        for n in nums:\\n            prefix = prefixes[n]\\n            \\n            if n-1 in prefixes:\\n                prev_prefix = prefixes[n-1]                \\n                if prev_prefix[0]:\\n                    prev_prefix[0] -= 1\\n                    prefix[1] += 1\\n                elif prev_prefix[1]:\\n                    prev_prefix[1] -= 1\\n                    prefix[2] += 1\\n                elif prev_prefix[2]:\\n                    prev_prefix[2] -= 1\\n                    prefix[2] += 1\\n                if prev_prefix[0] == prev_prefix[1] == prev_prefix[2] == 0:\\n                    prefixes.pop(n-1)\\n            else:\\n                prefix[0] += 1\\n        return all(p[0] == p[1] == 0 for p in prefixes.values())\\n```\n```\\nclass Solution:\\n    def isPossible(self, nums: List[int]) -> bool:\\n        cur_val = nums[0]\\n        prev_stats = [0, 0, 0]  # [len 1 subseqs, len 2 subseqs, len 3+ subseqs]\\n        cur_stats = [0, 0, 0]\\n\\n        for n in nums:\\n            if n != cur_val:\\n\\t\\t\\t\\t# checking if all the relevant older sequences have been grown to at least 3\\n\\t\\t\\t\\tif prev_stats[0] or prev_stats[1] or (cur_stats[0] or cur_stats[1]) and n != cur_val + 1:\\n                    return False\\n                \\n                prev_stats = cur_stats if n == cur_val + 1 else [0, 0, 0]  # if we skipped a number older stats don\\'t matter\\n                cur_val = n\\n                cur_stats = [0, 0, 0]\\n            \\n            if prev_stats[0]:\\n                prev_stats[0] -= 1\\n                cur_stats[1] += 1\\n            elif prev_stats[1]:\\n                prev_stats[1] -= 1\\n                cur_stats[2] += 1\\n            elif prev_stats[2]:\\n                prev_stats[2] -= 1\\n                cur_stats[2] += 1\\n            else:\\n                cur_stats[0] += 1\\n        \\n        return not(prev_stats[0] or prev_stats[1] or cur_stats[0] or cur_stats[1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2389657,
                "title": "python-one-see-you-will-feel-easy-video-tutorial",
                "content": "Tutorial (https://www.youtube.com/watch?v=-Egvieoi3Sc)\\n```\\n\\nimport collections\\nclass Solution:\\n    def isPossible(self, nums: List[int]) -> bool:\\n        \\n        counter = collections.Counter(nums)\\n        end = collections.defaultdict(int)\\n\\n        for num in nums:\\n            \\n            if counter[num]:\\n                counter[num]-=1\\n                \\n                if end[num-1]:\\n                    end[num-1]-=1\\n                    end[num]+=1\\n                elif counter[num+1] and counter[num+2]:\\n                    counter[num+1]-=1\\n                    counter[num+2]-=1\\n                    end[num+2] +=1\\n                else:\\n                    return False\\n        return True\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "Tutorial (https://www.youtube.com/watch?v=-Egvieoi3Sc)\\n```\\n\\nimport collections\\nclass Solution:\\n    def isPossible(self, nums: List[int]) -> bool:\\n        \\n        counter = collections.Counter(nums)\\n        end = collections.defaultdict(int)\\n\\n        for num in nums:\\n            \\n            if counter[num]:\\n                counter[num]-=1\\n                \\n                if end[num-1]:\\n                    end[num-1]-=1\\n                    end[num]+=1\\n                elif counter[num+1] and counter[num+2]:\\n                    counter[num+1]-=1\\n                    counter[num+2]-=1\\n                    end[num+2] +=1\\n                else:\\n                    return False\\n        return True\\n",
                "codeTag": "Java"
            },
            {
                "id": 2129999,
                "title": "c-greedy-solution",
                "content": "```\\n    public bool IsPossible(int[] nums) {\\n        var freq = nums.GroupBy(x => x).ToDictionary(x => x.Key, x => x.Count());\\n        var seq = new Dictionary<int, int>();\\n        foreach (var num in freq.Keys) {\\n            if (freq[num] == 0) continue;\\n            if (seq.ContainsKey(num - 1)) {\\n                var min = Math.Min(seq[num - 1], freq[num]);\\n                seq[num - 1] -= min;\\n                freq[num] -= min;\\n                seq[num] = seq.GetValueOrDefault(num, 0) + min;\\n            }\\n            if (freq[num] == 0) continue;\\n            if (freq.GetValueOrDefault(num + 1, 0) < freq[num] || freq.GetValueOrDefault(num + 2, 0) < freq[num])\\n                return false;\\n            seq[num + 2] = seq.GetValueOrDefault(num + 2, 0) + freq[num];\\n            freq[num + 1] -= freq[num];\\n            freq[num + 2] -= freq[num];\\n            freq[num] = 0;\\n        }\\n        return freq.All(x => x.Value == 0);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public bool IsPossible(int[] nums) {\\n        var freq = nums.GroupBy(x => x).ToDictionary(x => x.Key, x => x.Count());\\n        var seq = new Dictionary<int, int>();\\n        foreach (var num in freq.Keys) {\\n            if (freq[num] == 0) continue;\\n            if (seq.ContainsKey(num - 1)) {\\n                var min = Math.Min(seq[num - 1], freq[num]);\\n                seq[num - 1] -= min;\\n                freq[num] -= min;\\n                seq[num] = seq.GetValueOrDefault(num, 0) + min;\\n            }\\n            if (freq[num] == 0) continue;\\n            if (freq.GetValueOrDefault(num + 1, 0) < freq[num] || freq.GetValueOrDefault(num + 2, 0) < freq[num])\\n                return false;\\n            seq[num + 2] = seq.GetValueOrDefault(num + 2, 0) + freq[num];\\n            freq[num + 1] -= freq[num];\\n            freq[num + 2] -= freq[num];\\n            freq[num] = 0;\\n        }\\n        return freq.All(x => x.Value == 0);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1850131,
                "title": "python-code-with-heap",
                "content": "```\\nclass Solution(object):\\n    def isPossible(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if len(nums)<3:\\n            return False\\n        #store the length of every array\\n        len_heap=[[nums[0],1]]\\n        for i in range(1,len(nums)):\\n            while len(len_heap)>0 and len_heap[0][0]<nums[i]-1:\\n                if len_heap[0][1]<3:\\n                    return False\\n                heapq.heappop(len_heap)\\n            if len(len_heap)==0 or len_heap[0][0]==nums[i]:\\n                heapq.heappush(len_heap,[nums[i],1])\\n            else:\\n                new=[len_heap[0][0]+1,len_heap[0][1]+1]\\n                heapq.heappop(len_heap)\\n                heapq.heappush(len_heap,new)\\n        if min([len_heap[i][1] for i in range(len(len_heap))])<3:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution(object):\\n    def isPossible(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if len(nums)<3:\\n            return False\\n        #store the length of every array\\n        len_heap=[[nums[0],1]]\\n        for i in range(1,len(nums)):\\n            while len(len_heap)>0 and len_heap[0][0]<nums[i]-1:\\n                if len_heap[0][1]<3:\\n                    return False\\n                heapq.heappop(len_heap)\\n            if len(len_heap)==0 or len_heap[0][0]==nums[i]:\\n                heapq.heappush(len_heap,[nums[i],1])\\n            else:\\n                new=[len_heap[0][0]+1,len_heap[0][1]+1]\\n                heapq.heappop(len_heap)\\n                heapq.heappush(len_heap,new)\\n        if min([len_heap[i][1] for i in range(len(len_heap))])<3:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1273532,
                "title": "easy-c-solution-map-vs-vector-commented",
                "content": "Using vector \\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        //map to store the frequencies\\n        vector<int> freq(2004,0);\\n        for(int i=0;i<nums.size();i++)\\n            freq[nums[i]+1001]++; //for the negative values\\n        \\n        vector<int> mp(2004,0);//contains the subsequences endings\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            //make sure the element is not  used \\n            if(freq[nums[i]+1001]>0)\\n            {\\n                if(mp[nums[i]+1000]>0)\\n                {\\n                    //if there is a subsequence eding with nums-1 attach  to it\\n                    mp[nums[i]+1000]--;\\n                    mp[nums[i]+1001]++;\\n                }\\n                else{\\n                    //if no subsequence then create one\\n                    if(freq[nums[i]+1+1001]<=0 || freq[nums[i]+1001+2]<=0)\\n                        return false; //we can\\'t split\\n                    freq[nums[i]+1+1001]--;\\n                    freq[nums[i]+2+1001]--;\\n                    mp[nums[i]+2+1001]++;\\n                }\\n                //as we have used this one\\n                freq[nums[i]+1001]--;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\nRuntime: 80 ms, faster than 88.39% of C++ online submissions for Split Array into Consecutive Subsequences.\\nMemory Usage: 58.7 MB, less than 32.01% of C++ online submissions for Split Array into Consecutive Subsequences.\\n\\n\\nUsing Map-\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        //map to store the frequencies\\n        unordered_map<int,int> freq;\\n        for(int i=0;i<nums.size();i++)\\n            freq[nums[i]]++;\\n        unordered_map<int,int> mp;//contains the subsequences endings\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            //make sure the element is not  used \\n            if(freq[nums[i]]>0)\\n            {\\n                cout<<i<<\" \";\\n                cout<<freq[nums[i]]<<endl;\\n                if(mp[nums[i]-1]>0)\\n                {\\n                    //if there is a subsequence eding with nums-1 attahc to it\\n                    mp[nums[i]-1]--;\\n                    mp[nums[i]]++;\\n                }\\n                else{\\n                    //if no subsequence then create one\\n                    if(freq[nums[i]+1]<=0 || freq[nums[i]+2]<=0)\\n                        return false; //we can\\'t split\\n                    freq[nums[i]+1]--;\\n                    freq[nums[i]+2]--;\\n                    mp[nums[i]+2]++;\\n                }\\n                freq[nums[i]]--;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\nRuntime: 116 ms, faster than 30.39% of C++ online submissions for Split Array into Consecutive Subsequences.\\nMemory Usage: 58.7 MB, less than 32.01% of C++ online submissions for Split Array into Consecutive Subsequences.\\n\\nHave posted both the solutions using map and vector.\\nIt would be easy to understand the solution using map, But the time complexity differs a lot between both the solutions\\n\\nIf you still confused with the problem,Let me know in the comments!\\n\\n**Please upvote if this helps you :)**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        //map to store the frequencies\\n        vector<int> freq(2004,0);\\n        for(int i=0;i<nums.size();i++)\\n            freq[nums[i]+1001]++; //for the negative values\\n        \\n        vector<int> mp(2004,0);//contains the subsequences endings\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            //make sure the element is not  used \\n            if(freq[nums[i]+1001]>0)\\n            {\\n                if(mp[nums[i]+1000]>0)\\n                {\\n                    //if there is a subsequence eding with nums-1 attach  to it\\n                    mp[nums[i]+1000]--;\\n                    mp[nums[i]+1001]++;\\n                }\\n                else{\\n                    //if no subsequence then create one\\n                    if(freq[nums[i]+1+1001]<=0 || freq[nums[i]+1001+2]<=0)\\n                        return false; //we can\\'t split\\n                    freq[nums[i]+1+1001]--;\\n                    freq[nums[i]+2+1001]--;\\n                    mp[nums[i]+2+1001]++;\\n                }\\n                //as we have used this one\\n                freq[nums[i]+1001]--;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        //map to store the frequencies\\n        unordered_map<int,int> freq;\\n        for(int i=0;i<nums.size();i++)\\n            freq[nums[i]]++;\\n        unordered_map<int,int> mp;//contains the subsequences endings\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            //make sure the element is not  used \\n            if(freq[nums[i]]>0)\\n            {\\n                cout<<i<<\" \";\\n                cout<<freq[nums[i]]<<endl;\\n                if(mp[nums[i]-1]>0)\\n                {\\n                    //if there is a subsequence eding with nums-1 attahc to it\\n                    mp[nums[i]-1]--;\\n                    mp[nums[i]]++;\\n                }\\n                else{\\n                    //if no subsequence then create one\\n                    if(freq[nums[i]+1]<=0 || freq[nums[i]+2]<=0)\\n                        return false; //we can\\'t split\\n                    freq[nums[i]+1]--;\\n                    freq[nums[i]+2]--;\\n                    mp[nums[i]+2]++;\\n                }\\n                freq[nums[i]]--;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1038713,
                "title": "java-map-priority-queue-solution-greedy-approach",
                "content": "JAVA CODE IS\\n\\n```\\nclass Solution {\\n    public boolean isPossible(int[] nums) {\\n       Map<Integer,PriorityQueue<Integer>>map=new HashMap<>();\\n        for(int val : nums){\\n          map.computeIfAbsent(val, k -> new PriorityQueue<>());\\n           if(!map.containsKey(val-1))\\n               map.get(val).add(1);\\n            else{\\n                int size=map.get(val-1).poll();\\n                if(map.get(val-1).size()==0){\\n                //   System.out.println(\"yes \"+val);\\n                    map.remove(val-1);\\n                }\\n                map.get(val).add(size+1);\\n            }\\n            //System.out.println(val+ \"  \"+map.get(val).peek());\\n        }\\n        for(int key: map.keySet()){\\n             if(map.get(key).peek()<3)\\n                 return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isPossible(int[] nums) {\\n       Map<Integer,PriorityQueue<Integer>>map=new HashMap<>();\\n        for(int val : nums){\\n          map.computeIfAbsent(val, k -> new PriorityQueue<>());\\n           if(!map.containsKey(val-1))\\n               map.get(val).add(1);\\n            else{\\n                int size=map.get(val-1).poll();\\n                if(map.get(val-1).size()==0){\\n                //   System.out.println(\"yes \"+val);\\n                    map.remove(val-1);\\n                }\\n                map.get(val).add(size+1);\\n            }\\n            //System.out.println(val+ \"  \"+map.get(val).peek());\\n        }\\n        for(int key: map.keySet()){\\n             if(map.get(key).peek()<3)\\n                 return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 744657,
                "title": "decoding-answer-by-identifying-the-pattern-naive-solution",
                "content": "I wanted to map this solution to exisiting patterns I have learned , however i couldnt map to any of the existing patterns i have learned. \\nThen i thought of the brute force way i.e to generate all the consecuitve subsequence needs to be continuos and of length 3.\\nThen i looked at the example and try to see what is happening. Till this point i have no idea how to do in a better way.\\nI read the problem statement again, noted two important keywords - **Sorted** and **consecutive**. \\nThen i realised problem will be very easy if it doesnt have duplicates.\\n**Main Focus - Some decisions needs to be taken when duplicates are found.**\\nStill i cant figure what decision i can take when duplicates are found. So i decided to write the example on copy and see the pattern. Something i noticed . \\n![image](https://assets.leetcode.com/users/images/2ff4ac9b-28a2-47df-8204-5d8ad21e1ca1_1595189364.5891304.png)\\n![image](https://assets.leetcode.com/users/images/a1cd315e-71ac-4a56-831f-83cf573974a4_1595189366.5415604.png)\\n![image](https://assets.leetcode.com/users/images/236e7f64-6c1b-468d-b687-e336f184533a_1595189366.4132495.png)\\nWhenever there is a lower bump( prevFreq > currentFreq )we stop making the subsequence otherwise we continue making the subsequence. \\n```\\n\\n\\nclass Solution {\\n    public boolean isPossible(int[] nums) {\\n        if( nums.length < 3 )\\n            return false;\\n       HashMap< Integer, Integer > hm = new HashMap< Integer, Integer >();//frequency map\\n       for( int i = 0 ; i < nums.length; i++ )\\n           hm.put( nums[i], hm.getOrDefault( nums[i],0)+1 );\\n       \\n        for( int i = 0; i < nums.length; i++ )\\n        {\\n            if( hm.get( nums[i ] ) == 0 )//frequency count is zero, cant generate sequence, so skip the element\\n                continue;\\n                \\n            int k = 0;\\n            int sE = nums[i] ;\\n            int currentFreq = hm.get( sE );\\n            int prevFreq = -1;\\n            while( hm.get( sE) != null && hm.get( sE ) > 0 )\\n            {\\n                currentFreq = hm.get( sE );\\n                if( prevFreq > currentFreq )//finding the lower bump\\n                    break;\\n                prevFreq = hm.get( sE );\\n                hm.put( sE, hm.get(sE) - 1 );\\n                sE++;\\n                k++;\\n            }\\n        if( k < 3 )\\n            return false;\\n        }\\n    return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n\\nclass Solution {\\n    public boolean isPossible(int[] nums) {\\n        if( nums.length < 3 )\\n            return false;\\n       HashMap< Integer, Integer > hm = new HashMap< Integer, Integer >();//frequency map\\n       for( int i = 0 ; i < nums.length; i++ )\\n           hm.put( nums[i], hm.getOrDefault( nums[i],0)+1 );\\n       \\n        for( int i = 0; i < nums.length; i++ )\\n        {\\n            if( hm.get( nums[i ] ) == 0 )//frequency count is zero, cant generate sequence, so skip the element\\n                continue;\\n                \\n            int k = 0;\\n            int sE = nums[i] ;\\n            int currentFreq = hm.get( sE );\\n            int prevFreq = -1;\\n            while( hm.get( sE) != null && hm.get( sE ) > 0 )\\n            {\\n                currentFreq = hm.get( sE );\\n                if( prevFreq > currentFreq )//finding the lower bump\\n                    break;\\n                prevFreq = hm.get( sE );\\n                hm.put( sE, hm.get(sE) - 1 );\\n                sE++;\\n                k++;\\n            }\\n        if( k < 3 )\\n            return false;\\n        }\\n    return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 556487,
                "title": "python-o-n-2-o-nlogn-o-n-3-solutions",
                "content": "```\\n# N^2, use a stack to hold consecutive sequences, iterate all sequences to insert current number n.\\nclass Solution:\\n    def isPossible(self, nums: List[int]) -> bool:\\n        stack = []\\n        for n in nums:\\n            good = False\\n            for i in range(len(stack)-1, -1, -1):\\n                if stack[i][1] == n - 1:\\n                    stack[i][1] = n\\n                    good = True\\n                    break\\n            if not good:\\n                stack.append([n,n])\\n        for s in stack:\\n            if s[1] - s[0] < 2:\\n                return False\\n        return True\\n\\t\\t\\n# NlogN, use a heap to store consecutive sequences. heap top has the smallest end and shortest length of sequences.\\nclass Solution:\\n    def isPossible(self, nums: List[int]) -> bool:\\n        hp = []\\n        for n in nums:\\n            if not hp:\\n                heapq.heappush(hp, (n, 1))\\n            elif hp[0][0] == n - 1:\\n                _, l = heapq.heappop(hp)\\n                heapq.heappush(hp, (n, l+1))\\n            elif hp[0][0] == n:\\n                heapq.heappush(hp, (n,1))\\n            else:\\n                while hp and hp[0][0] < n - 1:\\n                    _, l = heapq.heappop(hp)\\n                    if l < 3:\\n                        return False\\n                if hp and hp[0][0] == n - 1:\\n                    _, l = heapq.heappop(hp)\\n                    heapq.heappush(hp, (n, l+1))\\n                else:\\n                    heapq.heappush(hp, (n,1))\\n        for h in hp:\\n            if h[1] < 3:\\n                return False\\n        return True\\n\\n# O(N), create two dicts, one for pending sequences with length less than 3 and good_sequences with length >= 3.\\n# Try to add current n to an existing pending sequence or good_sequences of n-1, If neither, create a new pending sequence of n.\\nclass Solution:\\n    def isPossible(self, nums: List[int]) -> bool:\\n        good_seq = {}\\n        pending = collections.defaultdict(list)\\n        for n in nums:\\n            if pending[n-1]:\\n                l = pending[n-1].pop()\\n                if l == 2:\\n                    good_seq[n] = good_seq.get(n, 0) + 1\\n                else:\\n                    pending[n].append(l+1)\\n            elif good_seq.get(n-1, 0):\\n                good_seq[n-1] -= 1\\n                good_seq[n] = good_seq.get(n, 0) + 1\\n            else:\\n                pending[n].append(1)\\n                \\n        for p in pending.values():\\n            if p:\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\n# N^2, use a stack to hold consecutive sequences, iterate all sequences to insert current number n.\\nclass Solution:\\n    def isPossible(self, nums: List[int]) -> bool:\\n        stack = []\\n        for n in nums:\\n            good = False\\n            for i in range(len(stack)-1, -1, -1):\\n                if stack[i][1] == n - 1:\\n                    stack[i][1] = n\\n                    good = True\\n                    break\\n            if not good:\\n                stack.append([n,n])\\n        for s in stack:\\n            if s[1] - s[0] < 2:\\n                return False\\n        return True\\n\\t\\t\\n# NlogN, use a heap to store consecutive sequences. heap top has the smallest end and shortest length of sequences.\\nclass Solution:\\n    def isPossible(self, nums: List[int]) -> bool:\\n        hp = []\\n        for n in nums:\\n            if not hp:\\n                heapq.heappush(hp, (n, 1))\\n            elif hp[0][0] == n - 1:\\n                _, l = heapq.heappop(hp)\\n                heapq.heappush(hp, (n, l+1))\\n            elif hp[0][0] == n:\\n                heapq.heappush(hp, (n,1))\\n            else:\\n                while hp and hp[0][0] < n - 1:\\n                    _, l = heapq.heappop(hp)\\n                    if l < 3:\\n                        return False\\n                if hp and hp[0][0] == n - 1:\\n                    _, l = heapq.heappop(hp)\\n                    heapq.heappush(hp, (n, l+1))\\n                else:\\n                    heapq.heappush(hp, (n,1))\\n        for h in hp:\\n            if h[1] < 3:\\n                return False\\n        return True\\n\\n# O(N), create two dicts, one for pending sequences with length less than 3 and good_sequences with length >= 3.\\n# Try to add current n to an existing pending sequence or good_sequences of n-1, If neither, create a new pending sequence of n.\\nclass Solution:\\n    def isPossible(self, nums: List[int]) -> bool:\\n        good_seq = {}\\n        pending = collections.defaultdict(list)\\n        for n in nums:\\n            if pending[n-1]:\\n                l = pending[n-1].pop()\\n                if l == 2:\\n                    good_seq[n] = good_seq.get(n, 0) + 1\\n                else:\\n                    pending[n].append(l+1)\\n            elif good_seq.get(n-1, 0):\\n                good_seq[n-1] -= 1\\n                good_seq[n] = good_seq.get(n, 0) + 1\\n            else:\\n                pending[n].append(1)\\n                \\n        for p in pending.values():\\n            if p:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 501675,
                "title": "python-with-detailed-explanation",
                "content": "for each e in nums, it will encouter two cases:\\n1. if there is a sequence ending with e-1:  e can append to exsiting sequence with the shortest length, because we want\\nto maximum the length of each sequence\\n2. if there is no sequence ending with e-1: create a new sequence \\nd is a dictionary which can help find e-1 easily. The key of d is the end of sequence, the value of d is a heap. This heap stores all the \\nlength of sequences ending with e-1.\\n```\\n    def isPossible(self, nums: List[int]) -> bool:\\n        d = collections.defaultdict(list)\\n        for e in nums:\\n            if d[e-1]: # there is sequence ending with e-1\\n                l = heapq.heappop(d[e-1]) # the shortest sequence\\n                heapq.heappush(d[e], l+1)\\n            else:\\n                heapq.heappush(d[e], 1) # create a new sequence\\n        for h in d.values():\\n            for hl in h:\\n                if hl < 3:\\n                    return False\\n        return True\\n            \\n```",
                "solutionTags": [],
                "code": "```\\n    def isPossible(self, nums: List[int]) -> bool:\\n        d = collections.defaultdict(list)\\n        for e in nums:\\n            if d[e-1]: # there is sequence ending with e-1\\n                l = heapq.heappop(d[e-1]) # the shortest sequence\\n                heapq.heappush(d[e], l+1)\\n            else:\\n                heapq.heappush(d[e], 1) # create a new sequence\\n        for h in d.values():\\n            for hl in h:\\n                if hl < 3:\\n                    return False\\n        return True\\n            \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 431298,
                "title": "explanation-of-the-approach-2-in-recommended-solution-and-implementation-of-hashmap-greedy-solution",
                "content": "The Approach 2 in the solution is good, but it took me long time to understand it. I have added some comments for further reference.\\n> https://leetcode.com/problems/split-array-into-consecutive-subsequences/solution/\\n```java\\nclass Solution {\\n    public boolean isPossible(int[] nums) {\\n        Counter count = new Counter();\\n        Counter tails = new Counter();\\n        for (int x: nums) count.add(x, 1);\\n\\n        for (int x: nums) {\\n            if (count.get(x) == 0) {\\n                // the current position doesn\\'t have num, skip it\\n                continue;\\n            } else if (tails.get(x) > 0) {\\n                // try to extend the previous chain which is not shorter than 3, move tail further\\n\\t\\t\\t\\t// extending the previous array is guranteed to have benefits and will not influence the correctness\\n\\t\\t\\t\\t// of the result. Imagine you have 1 or 2 number that precedes the current number\\n\\t\\t\\t\\t// they can\\'t form a valid subarray longer or equal to length 3, but they can be appended to the previous\\n\\t\\t\\t\\t// array that is already length 3\\n                tails.add(x, -1);\\n                tails.add(x+1, 1);\\n            } else if (count.get(x+1) > 0 && count.get(x+2) > 0) {\\n                // consider the next 2 element can be matched or not\\n                count.add(x+1, -1);\\n                count.add(x+2, -1);\\n                tails.add(x+3, 1);\\n            } else {\\n                // if the code is not catched the previous conditions, we know that we could not extend\\n                // a chain with length 3, return false directly\\n                return false;\\n            }\\n            \\n            // minus the current count\\n            count.add(x, -1);\\n        }\\n        return true;\\n    }\\n}\\n\\nclass Counter extends HashMap<Integer, Integer> {\\n    public int get(int k) {\\n        return containsKey(k) ? super.get(k) : 0;\\n    }\\n\\n    public void add(int k, int v) {\\n        put(k, get(k) + v);\\n    }\\n}\\n```\\n\\nActually, I think overriding the HashMap is not very necessary and we can directly use HashMap\\'s `getOrDefault()` method to implement it. It would be easier to understand and read. Please refer to the code below.\\n```java\\nclass Solution {\\n    public boolean isPossible(int[] nums) {\\n        Map<Integer, Integer> count = new HashMap<>();\\n        Map<Integer, Integer> tails = new HashMap<>();\\n        \\n        for (int x: nums) count.put(x, count.getOrDefault(x, 0) + 1);\\n\\n        for (int x: nums) {\\n            if (count.get(x) == 0) {\\n                // the current position doesn\\'t have num, skip it\\n                continue;\\n            } else if (tails.getOrDefault(x,0) > 0) {\\n                // try to extend the previous chain which is not shorter than 3, move tail further\\n                tails.put(x, tails.get(x)-1);\\n                tails.put(x+1, tails.getOrDefault(x+1, 0)+1);\\n            } else if (count.getOrDefault(x+1, 0) > 0 && count.getOrDefault(x+2, 0) > 0) {\\n                // consider the next 2 element can be matched or not\\n                count.put(x+1, count.getOrDefault(x+1, 0)-1);\\n                count.put(x+2, count.getOrDefault(x+2, 0)-1);\\n                tails.put(x+3, tails.getOrDefault(x+3, 0)+1);\\n            } else {\\n                // if the code is not catched in the previous conditions, we know that we could not extend\\n                // a chain with length 3, return false directly\\n                return false;\\n            }\\n            \\n            // minus the current count\\n            count.put(x, count.get(x)-1);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public boolean isPossible(int[] nums) {\\n        Counter count = new Counter();\\n        Counter tails = new Counter();\\n        for (int x: nums) count.add(x, 1);\\n\\n        for (int x: nums) {\\n            if (count.get(x) == 0) {\\n                // the current position doesn\\'t have num, skip it\\n                continue;\\n            } else if (tails.get(x) > 0) {\\n                // try to extend the previous chain which is not shorter than 3, move tail further\\n\\t\\t\\t\\t// extending the previous array is guranteed to have benefits and will not influence the correctness\\n\\t\\t\\t\\t// of the result. Imagine you have 1 or 2 number that precedes the current number\\n\\t\\t\\t\\t// they can\\'t form a valid subarray longer or equal to length 3, but they can be appended to the previous\\n\\t\\t\\t\\t// array that is already length 3\\n                tails.add(x, -1);\\n                tails.add(x+1, 1);\\n            } else if (count.get(x+1) > 0 && count.get(x+2) > 0) {\\n                // consider the next 2 element can be matched or not\\n                count.add(x+1, -1);\\n                count.add(x+2, -1);\\n                tails.add(x+3, 1);\\n            } else {\\n                // if the code is not catched the previous conditions, we know that we could not extend\\n                // a chain with length 3, return false directly\\n                return false;\\n            }\\n            \\n            // minus the current count\\n            count.add(x, -1);\\n        }\\n        return true;\\n    }\\n}\\n\\nclass Counter extends HashMap<Integer, Integer> {\\n    public int get(int k) {\\n        return containsKey(k) ? super.get(k) : 0;\\n    }\\n\\n    public void add(int k, int v) {\\n        put(k, get(k) + v);\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public boolean isPossible(int[] nums) {\\n        Map<Integer, Integer> count = new HashMap<>();\\n        Map<Integer, Integer> tails = new HashMap<>();\\n        \\n        for (int x: nums) count.put(x, count.getOrDefault(x, 0) + 1);\\n\\n        for (int x: nums) {\\n            if (count.get(x) == 0) {\\n                // the current position doesn\\'t have num, skip it\\n                continue;\\n            } else if (tails.getOrDefault(x,0) > 0) {\\n                // try to extend the previous chain which is not shorter than 3, move tail further\\n                tails.put(x, tails.get(x)-1);\\n                tails.put(x+1, tails.getOrDefault(x+1, 0)+1);\\n            } else if (count.getOrDefault(x+1, 0) > 0 && count.getOrDefault(x+2, 0) > 0) {\\n                // consider the next 2 element can be matched or not\\n                count.put(x+1, count.getOrDefault(x+1, 0)-1);\\n                count.put(x+2, count.getOrDefault(x+2, 0)-1);\\n                tails.put(x+3, tails.getOrDefault(x+3, 0)+1);\\n            } else {\\n                // if the code is not catched in the previous conditions, we know that we could not extend\\n                // a chain with length 3, return false directly\\n                return false;\\n            }\\n            \\n            // minus the current count\\n            count.put(x, count.get(x)-1);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 279745,
                "title": "java-11ms-priorityqueue-solution-with-explanation",
                "content": "The idea is to maintain the subsequences using a PriorityQueue and add the next element to the smallest subsequence in size. As an example for [1, 2, 3, 3, 4, 4, 5, 5] :\\n [[1, 2, 3]]\\n [[3], [1, 2, 3]]\\n [[1, 2, 3], [3, 4]]\\n [[3, 4], [1, 2, 3, 4]]\\n [[1, 2, 3, 4], [3, 4, 5]]\\n [[3, 4, 5], [1, 2, 3, 4, 5]]\\n\\n```\\nclass Solution {\\n    \\n    class Pair implements Comparable<Pair>{\\n        int end;\\n        int size;\\n        \\n        public Pair(int end, int size) {\\n            this.end = end;\\n            this.size = size;\\n        }\\n        \\n        @Override\\n        public int compareTo(Pair p) {\\n            if (this.end == p.end) {\\n                return this.size - p.size;\\n            } else {\\n                return this.end - p.end;\\n            }\\n        }\\n    }\\n    \\n    public boolean isPossible(int[] nums) {\\n        PriorityQueue<Pair> pq = new PriorityQueue<>();\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            \\n            while (!pq.isEmpty() && pq.peek().end+1 < nums[i]) {\\n                if (pq.poll().size < 3) return false;\\n            }\\n                \\n            if (pq.isEmpty()) {\\n                pq.offer(new Pair(nums[i], 1));\\n                continue;\\n            }\\n            \\n            Pair p = pq.peek();\\n            if (p.end == nums[i] || p.end+1 < nums[i]) {                \\n                pq.offer(new Pair(nums[i], 1));\\n            } else {\\n                pq.offer(new Pair(nums[i], pq.poll().size+1));\\n            }\\n        }\\n        \\n        while (!pq.isEmpty()) {\\n            if (pq.poll().size < 3) return false;\\n        }\\n        \\n        return true;  \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    class Pair implements Comparable<Pair>{\\n        int end;\\n        int size;\\n        \\n        public Pair(int end, int size) {\\n            this.end = end;\\n            this.size = size;\\n        }\\n        \\n        @Override\\n        public int compareTo(Pair p) {\\n            if (this.end == p.end) {\\n                return this.size - p.size;\\n            } else {\\n                return this.end - p.end;\\n            }\\n        }\\n    }\\n    \\n    public boolean isPossible(int[] nums) {\\n        PriorityQueue<Pair> pq = new PriorityQueue<>();\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            \\n            while (!pq.isEmpty() && pq.peek().end+1 < nums[i]) {\\n                if (pq.poll().size < 3) return false;\\n            }\\n                \\n            if (pq.isEmpty()) {\\n                pq.offer(new Pair(nums[i], 1));\\n                continue;\\n            }\\n            \\n            Pair p = pq.peek();\\n            if (p.end == nums[i] || p.end+1 < nums[i]) {                \\n                pq.offer(new Pair(nums[i], 1));\\n            } else {\\n                pq.offer(new Pair(nums[i], pq.poll().size+1));\\n            }\\n        }\\n        \\n        while (!pq.isEmpty()) {\\n            if (pq.poll().size < 3) return false;\\n        }\\n        \\n        return true;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 232811,
                "title": "java-o-n-solution-using-map-and-deque",
                "content": "```\\n//time O(n) space O(n)\\nclass Solution {\\n    public boolean isPossible(int[] nums) {\\n        Map<Integer, Deque<Integer>> map = new HashMap<>();\\n        for (int i : nums) {\\n            int length = map.containsKey(i - 1) && !map.get(i - 1).isEmpty() ? map.get(i - 1).poll() + 1 : 1;\\n            if (!map.containsKey(i)) {\\n                map.put(i, new ArrayDeque<>());\\n            }\\n            if (length == 1) {\\n                map.get(i).offerFirst(length);\\n            } else {\\n                map.get(i).offerLast(length);\\n            }\\n        }\\n        for (Deque<Integer> deque : map.values()) {\\n            for (Integer i : deque) {\\n                if (i < 3) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n//time O(n) space O(n)\\nclass Solution {\\n    public boolean isPossible(int[] nums) {\\n        Map<Integer, Deque<Integer>> map = new HashMap<>();\\n        for (int i : nums) {\\n            int length = map.containsKey(i - 1) && !map.get(i - 1).isEmpty() ? map.get(i - 1).poll() + 1 : 1;\\n            if (!map.containsKey(i)) {\\n                map.put(i, new ArrayDeque<>());\\n            }\\n            if (length == 1) {\\n                map.get(i).offerFirst(length);\\n            } else {\\n                map.get(i).offerLast(length);\\n            }\\n        }\\n        for (Deque<Integer> deque : map.values()) {\\n            for (Integer i : deque) {\\n                if (i < 3) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 218702,
                "title": "c-o-n-time-o-n-space-with-brief-explanation",
                "content": "The idea is to first try to append a current number if not possible create a new sequence.\\n\\nKey insights to remember: First get the counts of each number and keep it in a Hash Map (Dictionary)\\nWhile iterating though the numbers follow the \\'idea\\' above and maintain another candidate list.\\n\\nNote: to be candidate sequence it should already have three or more items.\\nRead the commnets in the code for better understanding. \\n\\n```\\npublic class Solution {\\n    public bool IsPossible(int[] nums) \\n    {\\n        // Complexity : Time O(n), Space O(n) - for Dictionaries\\n        // Validations\\n        if (nums == null) return false;\\n        \\n        var itemCounts = new Dictionary<int,int>();\\n        foreach(var num in nums)\\n        {\\n            if(!itemCounts.TryAdd(num,1))\\n            {\\n                itemCounts[num]++;\\n            }\\n        }\\n        \\n        var appendCandidates = new Dictionary<int,int>();\\n        \\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            int num = nums[i];\\n            if (itemCounts[num] <= 0) continue;  // Idea: if this number has been already consumed then continue\\n                                                 // This will be clear when we go though the code few times\\n            \\n            // if it\\'s possible to append to an already existing one append it (better than creating new sequence)\\n            if (appendCandidates.ContainsKey(num - 1) && appendCandidates[num - 1] > 0)\\n            {\\n                itemCounts[num]--;\\n                appendCandidates[num - 1]--;\\n                if(!appendCandidates.TryAdd(num,1))\\n                {\\n                    appendCandidates[num]++;\\n                }\\n            }\\n            else   // In case append to existing is not possible make a new sequence\\n            {\\n                if (itemCounts.ContainsKey(num+1) &&\\n                    itemCounts[num+1] > 0 &&          // Check if the new sequence can be formed\\n                    itemCounts.ContainsKey(num+2) &&\\n                    itemCounts[num+2] > 0)\\n                {\\n                    // Making the new sequence\\n                    itemCounts[num]--;\\n                    itemCounts[num + 1]--;\\n                    itemCounts[num + 2]--;\\n                    \\n                    if(!appendCandidates.TryAdd(num + 2,1))  // (num + 2) becomes a new candidate to be appended\\n                    {\\n                    appendCandidates[num + 2]++;\\n                    }\\n                    \\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool IsPossible(int[] nums) \\n    {\\n        // Complexity : Time O(n), Space O(n) - for Dictionaries\\n        // Validations\\n        if (nums == null) return false;\\n        \\n        var itemCounts = new Dictionary<int,int>();\\n        foreach(var num in nums)\\n        {\\n            if(!itemCounts.TryAdd(num,1))\\n            {\\n                itemCounts[num]++;\\n            }\\n        }\\n        \\n        var appendCandidates = new Dictionary<int,int>();\\n        \\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            int num = nums[i];\\n            if (itemCounts[num] <= 0) continue;  // Idea: if this number has been already consumed then continue\\n                                                 // This will be clear when we go though the code few times\\n            \\n            // if it\\'s possible to append to an already existing one append it (better than creating new sequence)\\n            if (appendCandidates.ContainsKey(num - 1) && appendCandidates[num - 1] > 0)\\n            {\\n                itemCounts[num]--;\\n                appendCandidates[num - 1]--;\\n                if(!appendCandidates.TryAdd(num,1))\\n                {\\n                    appendCandidates[num]++;\\n                }\\n            }\\n            else   // In case append to existing is not possible make a new sequence\\n            {\\n                if (itemCounts.ContainsKey(num+1) &&\\n                    itemCounts[num+1] > 0 &&          // Check if the new sequence can be formed\\n                    itemCounts.ContainsKey(num+2) &&\\n                    itemCounts[num+2] > 0)\\n                {\\n                    // Making the new sequence\\n                    itemCounts[num]--;\\n                    itemCounts[num + 1]--;\\n                    itemCounts[num + 2]--;\\n                    \\n                    if(!appendCandidates.TryAdd(num + 2,1))  // (num + 2) becomes a new candidate to be appended\\n                    {\\n                    appendCandidates[num + 2]++;\\n                    }\\n                    \\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 169297,
                "title": "c-greedy-solution-without-tracking-all-the-sequences",
                "content": "The idea is we go through the `nums`  and try to construct a sequence in a greedy manner:\\n\\nAssume the first number we get is `n`, and it appears `k` times, then, if the next number is `n + 1` and it appears at least `k` times, \\nwe can be sure that we need to include `n + 1` into our current sequence.\\n\\nIf the next number is not `n + 1`, we have to conclude the current sequence.\\n\\nIf the next number appears less than `k` times, we also have to conclude the current sequence, because `n + 1` needs to be included in another sequence containing `n`.\\n\\nAfter we get a sequence, we check if it has length ` >= 3 `. If not, we know it is not possible to split the array into consecutive subsequences, and we return `false`.\\n\\nWe return `true` if `nums` is empty and the last sequence we constructed has length ` >= 3 `.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        unordered_map<int, int> hm;\\n        for(auto num : nums) {\\n            hm[num] ++;\\n        } \\n        while(1) {\\n            int prevVal = -1, currVal = -1;\\n            int cnt = 0;\\n            bool start = true;\\n            for(auto it = nums.begin(); it != nums.end();) {\\n                if(start) {\\n                    currVal = *it;\\n                    it = nums.erase(it);\\n                    hm[currVal] --;\\n                    cnt ++;\\n                    start = false;\\n                } else if(*it == currVal) { // If we meet a duplicate, move forward.\\n                    it ++;\\n                } else {\\n                    prevVal = currVal;\\n                    currVal = *it;\\n                    // If \\n                    // 1. count of current value is >= count of previous value (we need +1  because when we take previous value, its count is decreased).\\n                    // 2. currVal is consecutive of previous value.\\n                    // we increase count.\\n                    if(hm[currVal] >= hm[prevVal] + 1 && currVal == prevVal + 1) { \\n                        it = nums.erase(it);\\n                        hm[currVal] --;\\n                        cnt ++;\\n                    } else {\\n                        // If current sequence we constructed has size < 3, we return false.\\n                        if(cnt < 3) {\\n                            return false;\\n                        } else {\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n            // If we have processed all the numbers, we have to check the count of the last sequence we constructed.\\n            if(nums.empty()) {\\n                if(cnt >= 3) {\\n                    return true;\\n                }\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        unordered_map<int, int> hm;\\n        for(auto num : nums) {\\n            hm[num] ++;\\n        } \\n        while(1) {\\n            int prevVal = -1, currVal = -1;\\n            int cnt = 0;\\n            bool start = true;\\n            for(auto it = nums.begin(); it != nums.end();) {\\n                if(start) {\\n                    currVal = *it;\\n                    it = nums.erase(it);\\n                    hm[currVal] --;\\n                    cnt ++;\\n                    start = false;\\n                } else if(*it == currVal) { // If we meet a duplicate, move forward.\\n                    it ++;\\n                } else {\\n                    prevVal = currVal;\\n                    currVal = *it;\\n                    // If \\n                    // 1. count of current value is >= count of previous value (we need +1  because when we take previous value, its count is decreased).\\n                    // 2. currVal is consecutive of previous value.\\n                    // we increase count.\\n                    if(hm[currVal] >= hm[prevVal] + 1 && currVal == prevVal + 1) { \\n                        it = nums.erase(it);\\n                        hm[currVal] --;\\n                        cnt ++;\\n                    } else {\\n                        // If current sequence we constructed has size < 3, we return false.\\n                        if(cnt < 3) {\\n                            return false;\\n                        } else {\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n            // If we have processed all the numbers, we have to check the count of the last sequence we constructed.\\n            if(nums.empty()) {\\n                if(cnt >= 3) {\\n                    return true;\\n                }\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 106533,
                "title": "my-o-n-java-solution-using-queue",
                "content": "The idea is that if the current element of the array has more duplicates than the previous one, then we need new subsequences starting from these increased duplicates; if the current element has less duplicates or the consecutive number is missing, then some (or all for missing numbers) subsequences stored previously should be cut since there are not enough duplicates to continue them all.\\n\\nThe subsequences begin earlier should end earlier to make more subsquences to get enough size (>= 3). We may store the starting elements of the subsequences in a queue. When the number of duplicates decreases, the staring elements of previous subsequences pop out and we may check the validity of them by comparing the starting elements and the element where they end; when more duplicates show up, we may offer new starting elements to the queue for the newly appeared subsequences.\\n\\nFor example, for input array [1,2,3,3,4,5], the number of duplicates increases at element 1, since it's the very first element. We offer 1 to the queue. The number of duplicates increases again at 3, bigger than the size of the queue which represents how many alive subseqences so far, so we offer 3 to the queue and start a new subsequence. At element 4, the number of duplicates decreases by 1, which means we need cut 1 previous subsequence. The earliest subsequence starts from element 1, we check its validity by calculating its size 4 - 1 = 3. Finally, after visiting the last element 5, we need check the validity of the remaining subsequence starting from 3. It is valid and the result is true.\\n\\n```\\npublic class Solution {\\n    public boolean isPossible(int[] nums) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        int prev = 0; // the previous distinct element in array \"nums\"\\n        for (int i = 0; i < nums.length; i++) {\\n            int count = 1;\\n            while (i + 1 < nums.length && nums[i] == nums[i + 1]) { // count repetitions\\n                i++;\\n                count++;\\n            }\\n            if (i > 0 && nums[i] > prev + 1) { // if it is not consecutive, then check all previous subsequences\\n                if (!valid(queue, prev, 0))\\n                    return false;\\n            }\\n            int size = queue.size();\\n            if (count > size) { // if the array \"expands\", new subsequences appear\\n                for (int j = 0; j < count - size; j++)\\n                    queue.offer(nums[i]);\\n            }\\n            else if (count < size) { // if the array \"shrinks\", some old subsequences end\\n                if (!valid(queue, prev, count))\\n                    return false;\\n            }\\n            prev = nums[i];\\n        }\\n        if (!valid(queue, nums[nums.length - 1], 0)) // if there are subsequences left that have not been checked\\n            return false;\\n        return true;\\n    }\\n    public boolean valid(Queue<Integer> queue, int lastEle, int count) { // check subsequences stored previously, \"lastEle\" stands for the last element of the completed subsequences, \"count\" denotes the number of subsquences \"alive\" which need not a check now\\n        int size = queue.size();\\n        for (int j = 0; j < size - count; j++) {\\n            int start = queue.poll();\\n            if (lastEle - start + 1 < 3)\\n                return false;\\n        }\\n        return true;\\n    }\\n````",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public boolean isPossible(int[] nums) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        int prev = 0; // the previous distinct element in array \"nums\"\\n        for (int i = 0; i < nums.length; i++) {\\n            int count = 1;\\n            while (i + 1 < nums.length && nums[i] == nums[i + 1]) { // count repetitions\\n                i++;\\n                count++;\\n            }\\n            if (i > 0 && nums[i] > prev + 1) { // if it is not consecutive, then check all previous subsequences\\n                if (!valid(queue, prev, 0))\\n                    return false;\\n            }\\n            int size = queue.size();\\n            if (count > size) { // if the array \"expands\", new subsequences appear\\n                for (int j = 0; j < count - size; j++)\\n                    queue.offer(nums[i]);\\n            }\\n            else if (count < size) { // if the array \"shrinks\", some old subsequences end\\n                if (!valid(queue, prev, count))\\n                    return false;\\n            }\\n            prev = nums[i];\\n        }\\n        if (!valid(queue, nums[nums.length - 1], 0)) // if there are subsequences left that have not been checked\\n            return false;\\n        return true;\\n    }\\n    public boolean valid(Queue<Integer> queue, int lastEle, int count) { // check subsequences stored previously, \"lastEle\" stands for the last element of the completed subsequences, \"count\" denotes the number of subsquences \"alive\" which need not a check now\\n        int size = queue.size();\\n        for (int j = 0; j < size - count; j++) {\\n            int start = queue.poll();\\n            if (lastEle - start + 1 < 3)\\n                return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 106541,
                "title": "c-o-n-time-o-1-space-82ms",
                "content": "Iterate through the array's distinct values. For current value, keep track of the number of subsequences of length 1, 2 or 3+ that end with the current value. Greedily appending sequences of length 1, 2 and 3+ in that order.\\n\\n```\\n    bool isPossible(vector<int>& a) {\\n        int j = 0, n = a.size(), cnt1=0,cnt2=0,cnt3=0;\\n        for (int i = 0; i < n; ++i) if(i == n-1 || a[i] != a[i+1]) {\\n            int cnt = i-j+1;\\n            if (j == 0 || a[i] > a[j-1] + 1) {\\n                if (cnt1 || cnt2) return false;\\n                cnt2=cnt3 = 0;\\n                cnt1 = cnt;\\n            }\\n            else {\\n                if (cnt < cnt1 + cnt2) return false;\\n                cnt -= cnt1 + cnt2;\\n                int x = min(cnt,cnt3);\\n                cnt3 = x + cnt2, cnt2 = cnt1, cnt1 = cnt - x;\\n            }\\n            j = i + 1;\\n        }\\n        \\n        return !cnt2 && !cnt1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool isPossible(vector<int>& a) {\\n        int j = 0, n = a.size(), cnt1=0,cnt2=0,cnt3=0;\\n        for (int i = 0; i < n; ++i) if(i == n-1 || a[i] != a[i+1]) {\\n            int cnt = i-j+1;\\n            if (j == 0 || a[i] > a[j-1] + 1) {\\n                if (cnt1 || cnt2) return false;\\n                cnt2=cnt3 = 0;\\n                cnt1 = cnt;\\n            }\\n            else {\\n                if (cnt < cnt1 + cnt2) return false;\\n                cnt -= cnt1 + cnt2;\\n                int x = min(cnt,cnt3);\\n                cnt3 = x + cnt2, cnt2 = cnt1, cnt1 = cnt - x;\\n            }\\n            j = i + 1;\\n        }\\n        \\n        return !cnt2 && !cnt1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 106544,
                "title": "c-solution",
                "content": "Simple Solution: \\nI loop through all the elements and find the bucket where it can be added. If I don't find a bucket, I will create a new bucket and add it to to the list of active buckets. At the same time, I will remove any buckets that can't be used in future.\\nWhen I remove any bucket from the list, will make sure they at least have 3 elements in them. Otherwise, Break and return false;\\nAt the end make sure you have at least 3 elements all the buckets in the active bucket list. If not return false;\\n```\\npublic bool IsPossible(int[] nums) {\\n        if (nums == null || nums.Length < 3)\\n            {\\n                return false;\\n            }\\n\\n            List<List<int>> lists = new List<List<int>>();\\n            var l1 = new List<int>();\\n            l1.Add(nums[0]);\\n            lists.Add(l1);\\n\\n            for (int i = 1; i < nums.Length; i++)\\n            {\\n                bool added = false;\\n                var temp = new List<List<int>>();\\n\\n                foreach (var item in lists)\\n                {\\n                    if (item.Last() + 1 == nums[i])\\n                    {\\n                        item.Add(nums[i]);\\n                        added = true;\\n                        break;\\n                    }\\n                    else if(item.Last() + 1 < nums[i])\\n                    {\\n                        temp.Add(item);\\n                    }\\n                }\\n\\n                if(temp.Where((x) => x.Count < 3).Count() > 0)\\n                {\\n                    return false;\\n                }\\n\\n                else\\n                {\\n                    foreach (var item in temp)\\n                    {\\n                        lists.Remove(item);\\n                    }\\n                }\\n                if (!added)\\n                {\\n                    var l = new List<int>();\\n                    l.Add(nums[i]);\\n                    lists.Insert(0, l);\\n                }\\n            }\\n\\n            return lists.Where((x) => x.Count < 3).Count() == 0;\\n    }\\n````",
                "solutionTags": [],
                "code": "```\\npublic bool IsPossible(int[] nums) {\\n        if (nums == null || nums.Length < 3)\\n            {\\n                return false;\\n            }\\n\\n            List<List<int>> lists = new List<List<int>>();\\n            var l1 = new List<int>();\\n            l1.Add(nums[0]);\\n            lists.Add(l1);\\n\\n            for (int i = 1; i < nums.Length; i++)\\n            {\\n                bool added = false;\\n                var temp = new List<List<int>>();\\n\\n                foreach (var item in lists)\\n                {\\n                    if (item.Last() + 1 == nums[i])\\n                    {\\n                        item.Add(nums[i]);\\n                        added = true;\\n                        break;\\n                    }\\n                    else if(item.Last() + 1 < nums[i])\\n                    {\\n                        temp.Add(item);\\n                    }\\n                }\\n\\n                if(temp.Where((x) => x.Count < 3).Count() > 0)\\n                {\\n                    return false;\\n                }\\n\\n                else\\n                {\\n                    foreach (var item in temp)\\n                    {\\n                        lists.Remove(item);\\n                    }\\n                }\\n                if (!added)\\n                {\\n                    var l = new List<int>();\\n                    l.Add(nums[i]);\\n                    lists.Insert(0, l);\\n                }\\n            }\\n\\n            return lists.Where((x) => x.Count < 3).Count() == 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3314794,
                "title": "659-space-94-38-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. We initialize two defaultdicts freq and appendfreq to count the frequency of each number in nums and to track the number of potential subsequence endings, respectively.\\n2. We iterate over each number in nums and increment the frequency of each number in freq.\\n3. We iterate over each number in nums again, and if the frequency of the current number is 0, we skip it. Otherwise, we check if the current number can be appended to a potential subsequence by checking if the frequency of the next number is greater than 0. If so, we decrement the frequency of the current number and increment the frequency of the next number in appendfreq. If not, we try to create a new subsequence by checking if the frequencies of the next two numbers are both greater than 0. If so, we decrement the frequencies of the current number, the next number, and the number after that in freq, and increment the frequency of the number after that in appendfreq. If neither of these conditions holds, we cannot create a valid subsequence and we return False.\\n4. If we have successfully created a subsequence for each number in nums, we return True.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isPossible(self, nums: List[int]) -> bool:\\n        freq = defaultdict(int)\\n        appendfreq = defaultdict(int)\\n        \\n        for num in nums:\\n            freq[num] += 1\\n        \\n        for num in nums:\\n            if freq[num] == 0:\\n                continue\\n            elif appendfreq[num] > 0:\\n                appendfreq[num] -= 1\\n                appendfreq[num + 1] += 1\\n            elif freq[num + 1] > 0 and freq[num + 2] > 0:\\n                freq[num + 1] -= 1\\n                freq[num + 2] -= 1\\n                appendfreq[num + 3] += 1\\n            else:\\n                return False\\n            freq[num] -= 1\\n        \\n        return True\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def isPossible(self, nums: List[int]) -> bool:\\n        freq = defaultdict(int)\\n        appendfreq = defaultdict(int)\\n        \\n        for num in nums:\\n            freq[num] += 1\\n        \\n        for num in nums:\\n            if freq[num] == 0:\\n                continue\\n            elif appendfreq[num] > 0:\\n                appendfreq[num] -= 1\\n                appendfreq[num + 1] += 1\\n            elif freq[num + 1] > 0 and freq[num + 2] > 0:\\n                freq[num + 1] -= 1\\n                freq[num + 2] -= 1\\n                appendfreq[num + 3] += 1\\n            else:\\n                return False\\n            freq[num] -= 1\\n        \\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3031724,
                "title": "easiest-solution-goldman-sachs-well-explained",
                "content": "## If you found my answer helpful, please consider giving it an upvote\\uD83D\\uDE0A\\n**#ReviseWithArsh #6Companies30Days Challenge 2023\\nChallenge Company 2 : Goldman Sachs\\nQ5. Split Array into Sequences**\\n\\n# Approach\\nThe approach is checking if it is possible to find three or more continuous numbers from the input array with the same frequency of occurence, if it is possible then return true otherwise false.\\n\\n![5.jpg](https://assets.leetcode.com/users/images/1ba67174-3114-47ef-abad-52d9cf6b54e0_1673389196.2151995.jpeg)\\n\\n# Complexity\\n**Time Complexity:** O(n)\\n**Space Complexity:** O(n)\\nIt has a linear time complexity because it iterates through the input array once, and also uses a HashMap with a size equal to the number of unique elements in the input array.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPossible(int[] nums) {\\n        // Use a HashMap to count the frequency of each number\\n        HashMap<Integer, Integer> countMap = new HashMap<>();\\n        for (int num : nums) {\\n            countMap.put(num, countMap.getOrDefault(num, 0) + 1);\\n        }\\n\\n        for (int num : nums) {\\n            // If the current number doesn\\'t have any remaining occurrences, continue\\n            if (!countMap.containsKey(num) || countMap.get(num) == 0) {\\n                continue;\\n            }\\n\\n            // Initialize variables to track the frequency of the current sequence\\n            int currNum = num;\\n            int sequenceFreq = countMap.get(num);\\n            int sequenceCount = 0;\\n\\n            // Iterate through the sequence and decrement the count of each number\\n            while (countMap.containsKey(currNum) && countMap.get(currNum) >= sequenceFreq) {\\n                sequenceFreq = Math.max(sequenceFreq, countMap.get(currNum));\\n                countMap.put(currNum, countMap.get(currNum) - 1);\\n                sequenceCount++;\\n                currNum++;\\n            }\\n\\n            // If the sequence is less than 3 numbers long, return false\\n            if (sequenceCount < 3) {\\n                return false;\\n            }\\n        }\\n        // If all sequences are at least 3 numbers long, return true\\n        return true;\\n    }\\n}\\n\\n```\\n**Here are a few key points about the provided code:-**\\n- The code uses a HashMap to store the frequency of each number in the input array. This allows for constant-time lookup of the frequency of any given number.\\n- The code iterates through the input array and for each number it check whether it is in the HashMap or not and its count is greater than zero.\\n- If the number is present in the HashMap, the code initializes some variables:\\ncurrNum which tracks the current number we are processing in the sequence\\nsequenceFreq which is the frequency of the current number in the input array\\nsequenceCount which keeps track of the number of elements in the sequence.\\n- It then iterates through the sequence and decrement the count of each number, if next number is greater than or equal to the curr with the same frequency as curr.\\n- It checks if the current sequence has more than 3 numbers if not it returns false as it is impossible otherwise it continues the iteration.\\n- Finally, it returns true if all sequences are at least 3 numbers long.\\n- In terms of complexity, the code has a time complexity of O(n) and a space complexity of O(n) because we iterate through the input array once, and we use a HashMap to store the frequency of each number which has a size of n in worst case. The most complex part of the algorithm is the while loop which at worst will iterate n times total over all the sequence thus giving us O(n) time complexity.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossible(int[] nums) {\\n        // Use a HashMap to count the frequency of each number\\n        HashMap<Integer, Integer> countMap = new HashMap<>();\\n        for (int num : nums) {\\n            countMap.put(num, countMap.getOrDefault(num, 0) + 1);\\n        }\\n\\n        for (int num : nums) {\\n            // If the current number doesn\\'t have any remaining occurrences, continue\\n            if (!countMap.containsKey(num) || countMap.get(num) == 0) {\\n                continue;\\n            }\\n\\n            // Initialize variables to track the frequency of the current sequence\\n            int currNum = num;\\n            int sequenceFreq = countMap.get(num);\\n            int sequenceCount = 0;\\n\\n            // Iterate through the sequence and decrement the count of each number\\n            while (countMap.containsKey(currNum) && countMap.get(currNum) >= sequenceFreq) {\\n                sequenceFreq = Math.max(sequenceFreq, countMap.get(currNum));\\n                countMap.put(currNum, countMap.get(currNum) - 1);\\n                sequenceCount++;\\n                currNum++;\\n            }\\n\\n            // If the sequence is less than 3 numbers long, return false\\n            if (sequenceCount < 3) {\\n                return false;\\n            }\\n        }\\n        // If all sequences are at least 3 numbers long, return true\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3030229,
                "title": "easy-simple-c-solution-hash-maps",
                "content": "## Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        map<int,int> freq;\\n        for (int i=0; i<nums.size(); i++){\\n            freq[nums[i]]++;\\n        }\\n        map<int,int> extra;\\n        for (int i=0; i<nums.size(); i++){\\n            if (freq[nums[i]]==0)continue;\\n            freq[nums[i]]--;\\n            if (extra[nums[i]-1]>0){\\n                extra[nums[i]-1]--;\\n                extra[nums[i]]++;\\n            }\\n            else if (freq[nums[i]+1]>0 && freq[nums[i]+2]>0){\\n                freq[nums[i]+1]--;\\n                freq[nums[i]+2]--;\\n                extra[nums[i]+2]++;\\n            }\\n            else return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        map<int,int> freq;\\n        for (int i=0; i<nums.size(); i++){\\n            freq[nums[i]]++;\\n        }\\n        map<int,int> extra;\\n        for (int i=0; i<nums.size(); i++){\\n            if (freq[nums[i]]==0)continue;\\n            freq[nums[i]]--;\\n            if (extra[nums[i]-1]>0){\\n                extra[nums[i]-1]--;\\n                extra[nums[i]]++;\\n            }\\n            else if (freq[nums[i]+1]>0 && freq[nums[i]+2]>0){\\n                freq[nums[i]+1]--;\\n                freq[nums[i]+2]--;\\n                extra[nums[i]+2]++;\\n            }\\n            else return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2545991,
                "title": "java-solution-linear-runtime-hashmap",
                "content": "### Please Upvote !!!\\n```\\nclass Solution {\\n    public boolean isPossible(int[] nums) {\\n        Map<Integer, Integer> avail = new HashMap<>();\\n        Map<Integer, Integer> vacant = new HashMap<>();\\n\\n        for (int i : nums) {\\n            avail.put(i, avail.getOrDefault(i, 0) + 1);\\n        }\\n\\n        for (int n : nums) {\\n            if (avail.get(n) <= 0) continue;\\n\\n            else if (vacant.getOrDefault(n, 0) > 0) {\\n                avail.put(n, avail.getOrDefault(n, 0) - 1);\\n                vacant.put(n, vacant.getOrDefault(n, 0) - 1);\\n                vacant.put(n + 1, vacant.getOrDefault(n + 1, 0) + 1);\\n\\n            } else if (avail.getOrDefault(n, 0) > 0 &&\\n                    avail.getOrDefault(n + 1, 0) > 0 &&\\n                    avail.getOrDefault(n + 2, 0) > 0) {\\n\\n                avail.put(n, avail.getOrDefault(n, 0) - 1);\\n                avail.put(n + 1, avail.getOrDefault(n + 1, 0) - 1);\\n                avail.put(n + 2, avail.getOrDefault(n + 2, 0) - 1);\\n\\n                vacant.put(n + 3, vacant.getOrDefault(n + 3, 0) + 1);\\n\\n            } else return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossible(int[] nums) {\\n        Map<Integer, Integer> avail = new HashMap<>();\\n        Map<Integer, Integer> vacant = new HashMap<>();\\n\\n        for (int i : nums) {\\n            avail.put(i, avail.getOrDefault(i, 0) + 1);\\n        }\\n\\n        for (int n : nums) {\\n            if (avail.get(n) <= 0) continue;\\n\\n            else if (vacant.getOrDefault(n, 0) > 0) {\\n                avail.put(n, avail.getOrDefault(n, 0) - 1);\\n                vacant.put(n, vacant.getOrDefault(n, 0) - 1);\\n                vacant.put(n + 1, vacant.getOrDefault(n + 1, 0) + 1);\\n\\n            } else if (avail.getOrDefault(n, 0) > 0 &&\\n                    avail.getOrDefault(n + 1, 0) > 0 &&\\n                    avail.getOrDefault(n + 2, 0) > 0) {\\n\\n                avail.put(n, avail.getOrDefault(n, 0) - 1);\\n                avail.put(n + 1, avail.getOrDefault(n + 1, 0) - 1);\\n                avail.put(n + 2, avail.getOrDefault(n + 2, 0) - 1);\\n\\n                vacant.put(n + 3, vacant.getOrDefault(n + 3, 0) + 1);\\n\\n            } else return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2519155,
                "title": "c-using-pairs-of-map",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        \\n        map <pair <int,int>, int> mp;\\n        \\n        for(auto &i:nums){\\n            if(mp[{1, i-1}]){\\n                mp[{1, i-1}] -= 1;\\n                mp[{2, i}] += 1;\\n            }\\n            else if(mp[{2, i-1}]){\\n                mp[{2, i-1}] -= 1;\\n                mp[{3, i}] += 1;\\n            }\\n            else if(mp[{3, i-1}]){\\n                mp[{3, i-1}] -= 1;\\n                mp[{3, i}] += 1;\\n            }\\n            else{\\n                mp[{1, i}] += 1;\\n            }\\n        }\\n        \\n        for(auto &i:mp){\\n            if((i.first.first == 1 || i.first.first == 2) && i.second){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        \\n        map <pair <int,int>, int> mp;\\n        \\n        for(auto &i:nums){\\n            if(mp[{1, i-1}]){\\n                mp[{1, i-1}] -= 1;\\n                mp[{2, i}] += 1;\\n            }\\n            else if(mp[{2, i-1}]){\\n                mp[{2, i-1}] -= 1;\\n                mp[{3, i}] += 1;\\n            }\\n            else if(mp[{3, i-1}]){\\n                mp[{3, i-1}] -= 1;\\n                mp[{3, i}] += 1;\\n            }\\n            else{\\n                mp[{1, i}] += 1;\\n            }\\n        }\\n        \\n        for(auto &i:mp){\\n            if((i.first.first == 1 || i.first.first == 2) && i.second){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2513812,
                "title": "easy-to-understand-c-solution-using-unordered-map",
                "content": "```\\n  bool isPossible(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int>count;\\n        unordered_map<int,int>end;\\n        \\n        for(int i=0;i<n;i++)\\n        {count[nums[i]]++;}\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(count[nums[i]]==0){continue;}\\n            \\n            count[nums[i]]--;\\n            \\n            //check if already part of existing sequence\\n            if(end[nums[i] - 1] > 0)\\n            {\\n                end[nums[i] - 1]--;\\n                end[nums[i]]++;\\n            }\\n            \\n            //check if we can form a new sequence from the current number\\n            else if(count[nums[i] + 1]!=0 && count[nums[i] + 2]!=0)\\n            {\\n               count[nums[i] + 1]--;\\n               count[nums[i] + 2]--;\\n               end[nums[i] + 2]++;\\n            }\\n            \\n            else \\n            {return false;}\\n            \\n        }\\n        \\n        return true;\\n    }\\n```\\n\\n**Upote if helpful!! :))**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n  bool isPossible(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int>count;\\n        unordered_map<int,int>end;\\n        \\n        for(int i=0;i<n;i++)\\n        {count[nums[i]]++;}\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(count[nums[i]]==0){continue;}\\n            \\n            count[nums[i]]--;\\n            \\n            //check if already part of existing sequence\\n            if(end[nums[i] - 1] > 0)\\n            {\\n                end[nums[i] - 1]--;\\n                end[nums[i]]++;\\n            }\\n            \\n            //check if we can form a new sequence from the current number\\n            else if(count[nums[i] + 1]!=0 && count[nums[i] + 2]!=0)\\n            {\\n               count[nums[i] + 1]--;\\n               count[nums[i] + 2]--;\\n               end[nums[i] + 2]++;\\n            }\\n            \\n            else \\n            {return false;}\\n            \\n        }\\n        \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2473839,
                "title": "leetcode-the-hard-way-greedy-with-explanation",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. If you like it, please give a star and watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way).\\n\\n---\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        unordered_map<int,int> m;\\n        // count the frequency for each number\\n        for(int x: nums) m[x]++;\\n        // use 3 variables to store\\n        // a: subsequences of length 1\\n        // b: subsequences of length 2\\n        // c: subsequences of length 3 or more\\n        int a = 0, b = 0, c = 0;\\n        // iterate all possible number\\n        for(int k = -1000; k <= 1001; k++){\\n            // since we need to put k to all subsequences of length 1 and 2\\n            // we need at least a + b numbers\\n            // otherwise, it is false\\n            if(m[k] < a + b) return false;\\n            // check if we need to create a new subsequence after extending to a, b, and c\\n            // we only do it when m[k] - a - b - c > 0\\n            int s = max(0, m[k] - a - b - c);\\n            // previous subsequences of length 2 &  3\\n            c = m[k] - s - a;\\n            // append the current number k to a\\n            // old_a would become subsequences of length 2 which is b\\n            b = a;\\n            // s is the new subsequence of length 1\\n            a = s;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        unordered_map<int,int> m;\\n        // count the frequency for each number\\n        for(int x: nums) m[x]++;\\n        // use 3 variables to store\\n        // a: subsequences of length 1\\n        // b: subsequences of length 2\\n        // c: subsequences of length 3 or more\\n        int a = 0, b = 0, c = 0;\\n        // iterate all possible number\\n        for(int k = -1000; k <= 1001; k++){\\n            // since we need to put k to all subsequences of length 1 and 2\\n            // we need at least a + b numbers\\n            // otherwise, it is false\\n            if(m[k] < a + b) return false;\\n            // check if we need to create a new subsequence after extending to a, b, and c\\n            // we only do it when m[k] - a - b - c > 0\\n            int s = max(0, m[k] - a - b - c);\\n            // previous subsequences of length 2 &  3\\n            c = m[k] - s - a;\\n            // append the current number k to a\\n            // old_a would become subsequences of length 2 which is b\\n            b = a;\\n            // s is the new subsequence of length 1\\n            a = s;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2450759,
                "title": "c-using-only-one-map",
                "content": "Hi, \\nThis passed - it seems I solved it a bit differenty using only one map.\\nFirst, get frequency of numbers - then for each unique number, verify if it\\'s surrounded by enough adjacent subsequences.\\nSeems to work.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {                \\n        unordered_map<int, int> map;\\n        \\n        for(auto num : nums) {\\n            map[num]++; \\n        }\\n        for(auto& kv:map) {\\n            int x=kv.first;            \\n            int l=min(check(map,x-2), check(map,x-1));\\n            int r=min(check(map,x+2), check(map,x+1));\\n            int m=min(check(map,x-1)-l, check(map,x+1)-r); \\n            \\n            if(kv.second > (l+r+m))                        \\n                return false;                        \\n        }        \\n        return true;\\n    }\\n    int check(unordered_map<int,int>& m, int k) {\\n        return m.find(k)==m.end()?0:m[k];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {                \\n        unordered_map<int, int> map;\\n        \\n        for(auto num : nums) {\\n            map[num]++; \\n        }\\n        for(auto& kv:map) {\\n            int x=kv.first;            \\n            int l=min(check(map,x-2), check(map,x-1));\\n            int r=min(check(map,x+2), check(map,x+1));\\n            int m=min(check(map,x-1)-l, check(map,x+1)-r); \\n            \\n            if(kv.second > (l+r+m))                        \\n                return false;                        \\n        }        \\n        return true;\\n    }\\n    int check(unordered_map<int,int>& m, int k) {\\n        return m.find(k)==m.end()?0:m[k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2449589,
                "title": "not-lis",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n      \\n        unordered_map<int,int>freq,hMap;\\n        for(int num:nums)freq[num]++;\\n        for(int num : nums){\\n          \\n    // wont pick num if frequency numbere as there are  not part of new sequence \\n            if(freq[num]==0)continue;\\n            \\n    // Condition for a Valid Subsequence \\n    // if number is present in hypoMap then we can expand in right direction \\n                   if(hMap[num]>0){  \\n                    hMap[num]--;\\n                    freq[num]--;\\n                    // storing the next consecutive number \\n                    hMap[num+1]++;     \\n                }\\n            else  if(freq[num]>0 and freq[num+1]>0 and freq[num+2]>0){\\n                    freq[num]--;\\n                    freq[num+1]--;\\n                    freq[num+2]--;\\n                    cout<<num<<\" \"<<num+1<<\" \"<<num+2<<endl;\\n// storing next consecutive number into hypothetical map to check for expansion\\n                    hMap[num+3]++;\\n                }     \\n                else return false ;                 \\n            }      \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n      \\n        unordered_map<int,int>freq,hMap;\\n        for(int num:nums)freq[num]++;\\n        for(int num : nums){\\n          \\n    // wont pick num if frequency numbere as there are  not part of new sequence \\n            if(freq[num]==0)continue;\\n            \\n    // Condition for a Valid Subsequence \\n    // if number is present in hypoMap then we can expand in right direction \\n                   if(hMap[num]>0){  \\n                    hMap[num]--;\\n                    freq[num]--;\\n                    // storing the next consecutive number \\n                    hMap[num+1]++;     \\n                }\\n            else  if(freq[num]>0 and freq[num+1]>0 and freq[num+2]>0){\\n                    freq[num]--;\\n                    freq[num+1]--;\\n                    freq[num+2]--;\\n                    cout<<num<<\" \"<<num+1<<\" \"<<num+2<<endl;\\n// storing next consecutive number into hypothetical map to check for expansion\\n                    hMap[num+3]++;\\n                }     \\n                else return false ;                 \\n            }      \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2449246,
                "title": "c-greedy-video-explanation",
                "content": "**Video Solution :**\\n\\nhttps://www.youtube.com/watch?v=uk09nXoJnX8\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        map<int,int>freq,need;\\n        for(auto i:nums)\\n            freq[i]++;\\n        \\n        for(auto i:nums)\\n        {\\n            if(freq[i]==0)\\n                continue;\\n            \\n            if(need[i]>0)\\n            {\\n                need[i]--;\\n                freq[i]--;\\n                \\n                need[i+1]++;\\n            }\\n            else\\n            {\\n                if(freq[i]>0 and freq[i+1]>0 and \\n                  freq[i+2]>0)\\n                {\\n                    freq[i]--;\\n                    freq[i+1]--;\\n                    freq[i+2]--;\\n                    \\n                    need[i+3]++;\\n                    \\n                }\\n                else\\n                    return false;\\n            }\\n            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        map<int,int>freq,need;\\n        for(auto i:nums)\\n            freq[i]++;\\n        \\n        for(auto i:nums)\\n        {\\n            if(freq[i]==0)\\n                continue;\\n            \\n            if(need[i]>0)\\n            {\\n                need[i]--;\\n                freq[i]--;\\n                \\n                need[i+1]++;\\n            }\\n            else\\n            {\\n                if(freq[i]>0 and freq[i+1]>0 and \\n                  freq[i+2]>0)\\n                {\\n                    freq[i]--;\\n                    freq[i+1]--;\\n                    freq[i+2]--;\\n                    \\n                    need[i+3]++;\\n                    \\n                }\\n                else\\n                    return false;\\n            }\\n            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2448964,
                "title": "c-best-solution-o-n-easy-to-understand-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n    bool isPossible(vector<int>& nums) {\\n      \\n        int c1=0, c2=0, total=0;\\n        int n=nums.size();\\n        \\n        for(int i=0;i<n;i++){\\n             int c=1;\\n             if(i>0&&nums[i]-nums[i-1]>1){\\n                 if(c1!=0||c2!=0)\\n                 return 0;\\n             total=0;}\\n            \\n            while(i<n-1&&nums[i]==nums[i+1]){\\n                c++; i++;\\n                 }\\n            \\n            if(c1+c2>c){ return 0;}\\n           \\n            c2=c1;\\n            c1=c-total;\\n            total=c;\\n            \\n             \\n        }\\n      \\n        if(c1>0||c2>0)return 0;\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    bool isPossible(vector<int>& nums) {\\n      \\n        int c1=0, c2=0, total=0;\\n        int n=nums.size();\\n        \\n        for(int i=0;i<n;i++){\\n             int c=1;\\n             if(i>0&&nums[i]-nums[i-1]>1){\\n                 if(c1!=0||c2!=0)\\n                 return 0;\\n             total=0;}\\n            \\n            while(i<n-1&&nums[i]==nums[i+1]){\\n                c++; i++;\\n                 }\\n            \\n            if(c1+c2>c){ return 0;}\\n           \\n            c2=c1;\\n            c1=c-total;\\n            total=c;\\n            \\n             \\n        }\\n      \\n        if(c1>0||c2>0)return 0;\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2448871,
                "title": "javascript-double-hashmap-o-2-n-time-o-n-size-solution",
                "content": "The idea behind this algorithm is that we track the available (or none occupied numbers) in one hashmap and the subsequences we make (and can potentially extend since we are taking a greedy approach) in another hashmap. The key in this algorithm\\'s functionality is to check if every number can either be added to a preexisting sequences, therefore extending it, or start a new one by using a look ahead approach to verify that the subsequence can be of length 3 at least. If neither of these cases is met we can safely conclude that the input is invalid for our case and return false.\\n\\n```\\nfunction isPossible(numbers) {\\n    if(numbers.length < 3) {\\n        return false;\\n    }\\n\\n    const occurrences = {};\\n    const existingSequences = {};\\n\\n    for (const number of numbers) {\\n        occurrences[number] = occurrences[number] ? occurrences[number] + 1 : 1;\\n    }\\n\\n    for (const number of numbers) {\\n        if(!occurrences[number]) {\\n            continue;\\n        }\\n\\n        if(existingSequences[number]) {\\n            occurrences[number]--;\\n            existingSequences[number]--;\\n            existingSequences[number + 1] = existingSequences[number + 1] ? existingSequences[number + 1] + 1 : 1;\\n            continue;\\n        }\\n\\n        if(occurrences[number] && occurrences[number + 1] && occurrences[number + 2]) {\\n            occurrences[number]--;\\n            occurrences[number + 1]--;\\n            occurrences[number + 2]--;\\n            existingSequences[number + 3] = existingSequences[number + 3] ? existingSequences[number + 3] + 1 : 1;\\n            continue;\\n        }\\n\\n        return false;\\n    }\\n\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction isPossible(numbers) {\\n    if(numbers.length < 3) {\\n        return false;\\n    }\\n\\n    const occurrences = {};\\n    const existingSequences = {};\\n\\n    for (const number of numbers) {\\n        occurrences[number] = occurrences[number] ? occurrences[number] + 1 : 1;\\n    }\\n\\n    for (const number of numbers) {\\n        if(!occurrences[number]) {\\n            continue;\\n        }\\n\\n        if(existingSequences[number]) {\\n            occurrences[number]--;\\n            existingSequences[number]--;\\n            existingSequences[number + 1] = existingSequences[number + 1] ? existingSequences[number + 1] + 1 : 1;\\n            continue;\\n        }\\n\\n        if(occurrences[number] && occurrences[number + 1] && occurrences[number + 2]) {\\n            occurrences[number]--;\\n            occurrences[number + 1]--;\\n            occurrences[number + 2]--;\\n            existingSequences[number + 3] = existingSequences[number + 3] ? existingSequences[number + 3] + 1 : 1;\\n            continue;\\n        }\\n\\n        return false;\\n    }\\n\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2448560,
                "title": "c-medium-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    struct compare{\\n        bool operator()(vector<int> &a, vector<int> &b){\\n            if(a[1] == b[1]) {\\n                int l1 = a[1] - a[0] + 1;\\n                int l2 = b[1] - b[0] + 1;\\n                return l1>l2;\\n            }\\n            return a[1]>b[1];\\n        }\\n    };\\n    bool isPossible(vector<int>& nums) {\\n        priority_queue<vector<int>, vector<vector<int>>, compare> pq;\\n        for(auto i: nums) {\\n            while(pq.size() > 0 && (pq.top()[1] + 1) < i) {\\n                vector<int> top = pq.top();\\n                pq.pop();\\n                if((top[1] - top[0] + 1) < 3) {\\n                    // cout<<\"here\";\\n                    return false;\\n                }\\n            }\\n            if(pq.size() == 0 || pq.top()[1] == i) {\\n                pq.push({i,i});\\n            }\\n            else {\\n                vector<int> top = pq.top();\\n                pq.pop();\\n                pq.push({top[0], i});\\n            }\\n        }\\n        while(!pq.empty()) {\\n            vector<int> top = pq.top();\\n            pq.pop();\\n            // cout<<top[0]<<\"-\"<<top[1]<<\" \";\\n            if((top[1] - top[0] + 1) < 3) {\\n                // cout<<\"ds\";\\n                return false;\\n            }\\n        }\\n        // cout<<\"\\\\n\";\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct compare{\\n        bool operator()(vector<int> &a, vector<int> &b){\\n            if(a[1] == b[1]) {\\n                int l1 = a[1] - a[0] + 1;\\n                int l2 = b[1] - b[0] + 1;\\n                return l1>l2;\\n            }\\n            return a[1]>b[1];\\n        }\\n    };\\n    bool isPossible(vector<int>& nums) {\\n        priority_queue<vector<int>, vector<vector<int>>, compare> pq;\\n        for(auto i: nums) {\\n            while(pq.size() > 0 && (pq.top()[1] + 1) < i) {\\n                vector<int> top = pq.top();\\n                pq.pop();\\n                if((top[1] - top[0] + 1) < 3) {\\n                    // cout<<\"here\";\\n                    return false;\\n                }\\n            }\\n            if(pq.size() == 0 || pq.top()[1] == i) {\\n                pq.push({i,i});\\n            }\\n            else {\\n                vector<int> top = pq.top();\\n                pq.pop();\\n                pq.push({top[0], i});\\n            }\\n        }\\n        while(!pq.empty()) {\\n            vector<int> top = pq.top();\\n            pq.pop();\\n            // cout<<top[0]<<\"-\"<<top[1]<<\" \";\\n            if((top[1] - top[0] + 1) < 3) {\\n                // cout<<\"ds\";\\n                return false;\\n            }\\n        }\\n        // cout<<\"\\\\n\";\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2448147,
                "title": "python-heap-short",
                "content": "```python\\nclass Solution(object):\\n    def isPossible(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        ends_with = defaultdict(list)\\n        for n in nums:\\n            if ends_with[n-1]:\\n                length = heapq.heappop(ends_with[n-1])\\n                heapq.heappush(ends_with[n], length+1)\\n            else:\\n                heapq.heappush(ends_with[n], 1)\\n\\n        for lengths in ends_with.values():\\n            if lengths and lengths[0] < 3:\\n                return False\\n        \\n        return True\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\nclass Solution(object):\\n    def isPossible(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        ends_with = defaultdict(list)\\n        for n in nums:\\n            if ends_with[n-1]:\\n                length = heapq.heappop(ends_with[n-1])\\n                heapq.heappush(ends_with[n], length+1)\\n            else:\\n                heapq.heappush(ends_with[n], 1)\\n\\n        for lengths in ends_with.values():\\n            if lengths and lengths[0] < 3:\\n                return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447977,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public boolean isPossible(int[] nums) {\\n        PriorityQueue<interval> queue = new PriorityQueue<>((a, b) -> (a.end == b.end ? a.len - b.len : a.end - b.end));\\n        for (int num : nums) {\\n            while (!queue.isEmpty() && queue.peek().end + 1 < num) {\\n                if (queue.poll().len < 3) return false;\\n            }\\n            if (queue.isEmpty() || queue.peek().end == num) queue.offer(new interval(num, num));\\n            else { //num == end + 1\\n                queue.add(new interval(queue.poll().start, num));\\n            }\\n        }\\n        while (!queue.isEmpty()) {\\n            if (queue.poll().len < 3) return false;\\n        }\\n        return true;\\n    }\\n    \\n    class interval {\\n        int start, end, len;\\n        public interval(int start, int end) {\\n            this.start = start;\\n            this.end = end;\\n            this.len = end - start + 1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossible(int[] nums) {\\n        PriorityQueue<interval> queue = new PriorityQueue<>((a, b) -> (a.end == b.end ? a.len - b.len : a.end - b.end));\\n        for (int num : nums) {\\n            while (!queue.isEmpty() && queue.peek().end + 1 < num) {\\n                if (queue.poll().len < 3) return false;\\n            }\\n            if (queue.isEmpty() || queue.peek().end == num) queue.offer(new interval(num, num));\\n            else { //num == end + 1\\n                queue.add(new interval(queue.poll().start, num));\\n            }\\n        }\\n        while (!queue.isEmpty()) {\\n            if (queue.poll().len < 3) return false;\\n        }\\n        return true;\\n    }\\n    \\n    class interval {\\n        int start, end, len;\\n        public interval(int start, int end) {\\n            this.start = start;\\n            this.end = end;\\n            this.len = end - start + 1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447698,
                "title": "c-java-with-example-and-explanation-approach",
                "content": "**Approach:** A number can be either added to a previous subsequence or a new subsequence will start from this number. We\\'ll need to keep track of these two conditions, we can do it using two hashmaps. See example below to understand better.\\nConsider input vector/array : [1 2 3 3 4 4 5 5]\\nLet\\'s take count of each number and store it in hashmap (let\\'s say availability). This map is going to tell us whether a number is available or not, to be added in a subsequence.\\nAvailability map will look like this (in format-  **{number,count}**):\\n**availability map = {1,1}    {2,1}     {3,2}    {4,2}     {5,2}**\\n*ITERATION 0*: let\\'s take first element i.e 1, for 1 to be a part of a valid subsequence either we should be having a previous sequence of size 3 or 1+1 and 1+2 should be present so that 1 can start a subsequence.\\nTo check for previous subsequence we keep another hashmap (let\\'s say possibility) which tells us whether it is possible to add a number into one of subsequence or not.\\nSo for 1, we can see 2 and 3 are present in availability map and possibility map is currently empty so we can update the maps by reducing the count of 1, 2 and 3 in availability map by1 since we have used them for one subsequence, and now after [1,2,3] there can be 4 in this subsequence so we can update possibility of 4 as 1.\\n**availability map= {1,0} {2,0} {3,1} {4,2} {5,2}\\npossibility map= {4,1}**\\n\\n*ITERATION 1*: the number 2 is not available (check count in availability map) since we have used it in previous subsequence so we continue to next iteration.\\n**availability map= {1,0}    {2,0}    {3,1}    {4,2}     {5,2}\\npossibility map= {4,1}**\\n\\nITERATION 2: the number 3 is available 1 time (see availability map), we can see that there are no possible subsequence in which we can use 3 (see possibility map), so we check 3+1 and 3+2, i.e 4 and 5 - both are available (see availability map). So we use these to make [3,4,5] a subsequence and update both maps.\\n**availability map= {1,0} {2,0} {3,0} {4,1} {5,1}\\npossibility map= {4,1} {6,1}**\\n\\n*ITERATION 3*: number 3 is not available now so continue\\n*ITERATION 4*: the number is 4 and it is possible to be added in one of subsequences (check possibility map), so we can update possibility map and add next number in possibility which can be added in this subsequence [1,2,3,4] which is 5 and update both maps.\\n**availability map= {1,0} {2,0} {3,0} {4,0} {5,1}\\npossibility map= {4,0} {6,1} {5,1}**\\n\\n*ITERATION 5*: 4 is not available now, so continue;\\n*ITERATION 6*: number 5 is possible to be added in one of subsequences (check possibility map), so we can both maps and one of subsequence becomes [1,2,3,4,5] and next possibility is 6 so updated in possibility map\\n**availability map= {1,0} {2,0} {3,0} {4,0} {5,0}\\npossibility map= {4,0} {6,2} {5,0}**\\nITERATION 7: number 5 is not available now so continue.\\n\\n**Time Complexity:** O(2n) , S.C: O(2n) where n is size of array/vector\\n\\n**C++ CODE**: \\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        unordered_map<int,int> availability,possibility;\\n        for(int i=0;i<nums.size();i++)\\n            availability[nums[i]]++;\\n        for(int i=0;i<nums.size();i++){\\n            if(availability[nums[i]]==0)\\n                continue;\\n            else if(possibility[nums[i]]>0){\\n                possibility[nums[i]+1]++;\\n                possibility[nums[i]]--;\\n            }\\n            else if(availability[nums[i]+1]>0 && availability[nums[i]+2]>0){\\n                possibility[nums[i]+3]++;\\n                availability[nums[i]+1]--;\\n                availability[nums[i]+2]--;\\n            }\\n            else{\\n                return false;\\n            }\\n            availability[nums[i]]--;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n**JAVA CODE**:\\n```\\nclass Solution {\\n    public boolean isPossible(int[] nums) {\\n        Map<Integer,Integer> availability = new HashMap<>();\\n        Map<Integer,Integer> possibility = new HashMap<>();\\n        for(int num:nums){\\n            availability.put(num,availability.getOrDefault(num,0)+1);\\n        }\\n        for(int num:nums){\\n            if(availability.get(num)==0)continue;\\n            if(possibility.getOrDefault(num,0)>0){\\n                possibility.put(num,possibility.getOrDefault(num,0)-1);\\n                possibility.put(num+1,possibility.getOrDefault(num+1,0)+1);\\n            }\\n            else if(availability.getOrDefault(num+1,0)>0 && availability.getOrDefault(num+2,0)>0 ){\\n                possibility.put(num+3,possibility.getOrDefault(num+3,0)+1);\\n                availability.put(num+1,availability.getOrDefault(num+1,0)-1);\\n                availability.put(num+2,availability.getOrDefault(num+2,0)-1);\\n            }\\n            else{\\n                return false;\\n            }\\n            availability.put(num,availability.get(num)-1);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        unordered_map<int,int> availability,possibility;\\n        for(int i=0;i<nums.size();i++)\\n            availability[nums[i]]++;\\n        for(int i=0;i<nums.size();i++){\\n            if(availability[nums[i]]==0)\\n                continue;\\n            else if(possibility[nums[i]]>0){\\n                possibility[nums[i]+1]++;\\n                possibility[nums[i]]--;\\n            }\\n            else if(availability[nums[i]+1]>0 && availability[nums[i]+2]>0){\\n                possibility[nums[i]+3]++;\\n                availability[nums[i]+1]--;\\n                availability[nums[i]+2]--;\\n            }\\n            else{\\n                return false;\\n            }\\n            availability[nums[i]]--;\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean isPossible(int[] nums) {\\n        Map<Integer,Integer> availability = new HashMap<>();\\n        Map<Integer,Integer> possibility = new HashMap<>();\\n        for(int num:nums){\\n            availability.put(num,availability.getOrDefault(num,0)+1);\\n        }\\n        for(int num:nums){\\n            if(availability.get(num)==0)continue;\\n            if(possibility.getOrDefault(num,0)>0){\\n                possibility.put(num,possibility.getOrDefault(num,0)-1);\\n                possibility.put(num+1,possibility.getOrDefault(num+1,0)+1);\\n            }\\n            else if(availability.getOrDefault(num+1,0)>0 && availability.getOrDefault(num+2,0)>0 ){\\n                possibility.put(num+3,possibility.getOrDefault(num+3,0)+1);\\n                availability.put(num+1,availability.getOrDefault(num+1,0)-1);\\n                availability.put(num+2,availability.getOrDefault(num+2,0)-1);\\n            }\\n            else{\\n                return false;\\n            }\\n            availability.put(num,availability.get(num)-1);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447535,
                "title": "c-2-solution-o-nlogn-o-n-time",
                "content": "**C++ Code:**\\n**Method 1: O(nlogn) Time & O(n) Space **\\n```\\nbool isPossible(vector<int>& nums) {\\n        multimap<int,vector<int>>m;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(m.find(nums[i]-1)!=m.end())\\n            {\\n                auto it = m.lower_bound(nums[i]-1);\\n                auto temp = it;\\n                while(it!=m.end() && it->first==nums[i]-1)\\n                {\\n                    if(temp->second.size()>it->second.size())\\n                        temp = it;\\n                  it++;\\n                }\\n                temp->second.push_back(nums[i]);\\n                auto arr = temp->second;\\n                m.erase(temp);\\n                m.insert({nums[i],arr});\\n            }\\n            else\\n                m.insert({nums[i],{nums[i]}});\\n        }\\n        for(auto it = m.begin();it!=m.end();it++)\\n            if(it->second.size()<3) return false;\\n      return true;  \\n    }\\n```\\n **Method 2: O(n) time & O(n) Space**\\n \\n```\\n     bool isPossible(vector<int>& nums) {\\n        unordered_map<int, int> left, end;\\n        for (int i=0;i<nums.size();i++) left[nums[i]]++;\\n        for (int i=0;i<nums.size();i++) {\\n           if (left[nums[i]] == 0) continue;\\n               left[nums[i]]--;\\n           if (end[nums[i] - 1] > 0) {   \\n                end[nums[i] - 1]--;\\n                end[nums[i]]++;\\n            } \\n           else if (left[nums[i] + 1] > 0 && left[nums[i] + 2] > 0) {\\n                left[nums[i] + 1]--;\\n                left[nums[i] + 2]--;\\n                end[nums[i] + 2]++;\\n            } \\n            else return false;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool isPossible(vector<int>& nums) {\\n        multimap<int,vector<int>>m;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(m.find(nums[i]-1)!=m.end())\\n            {\\n                auto it = m.lower_bound(nums[i]-1);\\n                auto temp = it;\\n                while(it!=m.end() && it->first==nums[i]-1)\\n                {\\n                    if(temp->second.size()>it->second.size())\\n                        temp = it;\\n                  it++;\\n                }\\n                temp->second.push_back(nums[i]);\\n                auto arr = temp->second;\\n                m.erase(temp);\\n                m.insert({nums[i],arr});\\n            }\\n            else\\n                m.insert({nums[i],{nums[i]}});\\n        }\\n        for(auto it = m.begin();it!=m.end();it++)\\n            if(it->second.size()<3) return false;\\n      return true;  \\n    }\\n```\n```\\n     bool isPossible(vector<int>& nums) {\\n        unordered_map<int, int> left, end;\\n        for (int i=0;i<nums.size();i++) left[nums[i]]++;\\n        for (int i=0;i<nums.size();i++) {\\n           if (left[nums[i]] == 0) continue;\\n               left[nums[i]]--;\\n           if (end[nums[i] - 1] > 0) {   \\n                end[nums[i] - 1]--;\\n                end[nums[i]]++;\\n            } \\n           else if (left[nums[i] + 1] > 0 && left[nums[i] + 2] > 0) {\\n                left[nums[i] + 1]--;\\n                left[nums[i] + 2]--;\\n                end[nums[i] + 2]++;\\n            } \\n            else return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2447339,
                "title": "java-code-easy-approch-hashmap",
                "content": "o(N) O(N);\\n```\\n public boolean isPossible(int[] nums) {\\n        HashMap<Integer,Integer>mp=new HashMap<Integer,Integer>();\\n        int n=nums.length;\\n        for(int i=0;i<n;i++){\\n            Integer j=mp.get(nums[i]);\\n            mp.put(nums[i],(j==null)?1:j+1);\\n        }\\n        for(int i=0;i<n;i++){\\n            int temp=0;\\n            int num=nums[i];\\n            if(mp.get(num)==0){\\n                continue;\\n            }\\n            int freq=mp.get(num);\\n            while(mp.get(num)!=null && mp.get(num)>=freq){\\n                freq=Math.max(mp.get(num),freq);\\n                mp.put(num,mp.get(num)-1); \\n                temp+=1;\\n                num+=1;\\n            }\\n            if(temp<3){\\n                 return false;\\n            }\\n        }\\n         \\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public boolean isPossible(int[] nums) {\\n        HashMap<Integer,Integer>mp=new HashMap<Integer,Integer>();\\n        int n=nums.length;\\n        for(int i=0;i<n;i++){\\n            Integer j=mp.get(nums[i]);\\n            mp.put(nums[i],(j==null)?1:j+1);\\n        }\\n        for(int i=0;i<n;i++){\\n            int temp=0;\\n            int num=nums[i];\\n            if(mp.get(num)==0){\\n                continue;\\n            }\\n            int freq=mp.get(num);\\n            while(mp.get(num)!=null && mp.get(num)>=freq){\\n                freq=Math.max(mp.get(num),freq);\\n                mp.put(num,mp.get(num)-1); \\n                temp+=1;\\n                num+=1;\\n            }\\n            if(temp<3){\\n                 return false;\\n            }\\n        }\\n         \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2447215,
                "title": "c-easiest-solution-detailed-explanation-98-3-faster",
                "content": "**Algorithm:**\\n\\nCreated two HashMap/ Unordered Map to store frequencies of each element and number of consecutive subsequence that ends at element value.\\nLoaded frequencies into count map.\\n\\nDo the following:\\na. If frequency of element is 0, continue (means number has already been used by previous subsequence).\\n\\nb. else decrease the frequency by 1.\\n\\nc. If end map previous element frequency is greater than 0, decrease the previous value frequency and increase the current value frequency by 1\\nd. else if next 2 element has frequency greater than 0, decrease its frequency by 1 and increment end map frequency by 1.\\n\\ne. else it is not possible to form subsequence, return false\\nIf all cases run, return true means it is possible to form subsequence.\\n\\nTime Complexity: O(n)\\nAuxiliary Space: O(n)\\n\\nHere the code.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        unordered_map<int, int> count, end;\\n        for (int it:nums){\\n\\t\\t\\tcount[it]++;\\n\\t\\t}\\n\\t\\t\\n        for (int it: nums) {\\n            if (count[it]==0){\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\t\\n            count[it]--;\\n            \\n            if (end[it-1]>0){\\n                end[it-1]--;\\n                end[it]++;\\n            }\\n\\t\\t\\telse if (count[it+1]>0 && count[it+2]>0){\\n                count[it+1]--;\\n                count[it+2]--;\\n                end[it+2]++;\\n            }\\n\\t\\t\\telse{\\n                return false;\\n            }\\n\\t\\t\\t\\n        }\\n\\t\\t\\n\\t\\t\\n        return true;\\n        \\n    }\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n};\\n\\n```\\n\\n\\nUpvote if it helpded!",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        unordered_map<int, int> count, end;\\n        for (int it:nums){\\n\\t\\t\\tcount[it]++;\\n\\t\\t}\\n\\t\\t\\n        for (int it: nums) {\\n            if (count[it]==0){\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\t\\n            count[it]--;\\n            \\n            if (end[it-1]>0){\\n                end[it-1]--;\\n                end[it]++;\\n            }\\n\\t\\t\\telse if (count[it+1]>0 && count[it+2]>0){\\n                count[it+1]--;\\n                count[it+2]--;\\n                end[it+2]++;\\n            }\\n\\t\\t\\telse{\\n                return false;\\n            }\\n\\t\\t\\t\\n        }\\n\\t\\t\\n\\t\\t\\n        return true;\\n        \\n    }\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447119,
                "title": "easy-java-solution-in-o-n-with-comments",
                "content": "Feel free to comment if you have any doubt or suggestion regarding solution.\\nUpvote if you find it helpful.\\n\\n```\\nclass Solution {\\n    public boolean isPossible(int[] nums) {\\n        /*\\n          we will take two hashMap.\\n          1. elementFreq -> it will contain the freq of element.\\n          2. endOfSubsequence -> it will store the num where sequence is ending.\\n        */\\n        \\n        Map<Integer,Integer> elementFreq = new HashMap<>();\\n        Map<Integer,Integer> endOfSubsequence = new HashMap<>();\\n        \\n        for(int num:nums){\\n            elementFreq.put(num, elementFreq.getOrDefault(num,0)+1);\\n        }\\n        \\n        for(int num:nums){\\n             // it means this element has been already used in subsequence\\n             if(elementFreq.get(num)==0) continue;\\n             elementFreq.put(num,elementFreq.getOrDefault(num,0)-1);\\n             \\n             if(endOfSubsequence.getOrDefault(num-1,0)>0){\\n                 // Here we are increasing the length of existing subsequence\\n                 endOfSubsequence.put(num-1, endOfSubsequence.get(num-1)-1);\\n                 endOfSubsequence.put(num, endOfSubsequence.getOrDefault(num,0)+1);\\n                 \\n             }  else if(elementFreq.getOrDefault(num+1,0)>0 && elementFreq.getOrDefault(num+2,0)>0){\\n                 // we are making num+2 as ending of subsequence\\n                 elementFreq.put(num+1,elementFreq.getOrDefault(num+1,0)-1);\\n                 elementFreq.put(num+2,elementFreq.getOrDefault(num+2,0)-1);\\n                 endOfSubsequence.put(num+2, endOfSubsequence.getOrDefault(num+2,0)+1);\\n                 \\n             }  else {\\n                 return false;\\n             }        \\n            \\n        }\\n        \\n        return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isPossible(int[] nums) {\\n        /*\\n          we will take two hashMap.\\n          1. elementFreq -> it will contain the freq of element.\\n          2. endOfSubsequence -> it will store the num where sequence is ending.\\n        */\\n        \\n        Map<Integer,Integer> elementFreq = new HashMap<>();\\n        Map<Integer,Integer> endOfSubsequence = new HashMap<>();\\n        \\n        for(int num:nums){\\n            elementFreq.put(num, elementFreq.getOrDefault(num,0)+1);\\n        }\\n        \\n        for(int num:nums){\\n             // it means this element has been already used in subsequence\\n             if(elementFreq.get(num)==0) continue;\\n             elementFreq.put(num,elementFreq.getOrDefault(num,0)-1);\\n             \\n             if(endOfSubsequence.getOrDefault(num-1,0)>0){\\n                 // Here we are increasing the length of existing subsequence\\n                 endOfSubsequence.put(num-1, endOfSubsequence.get(num-1)-1);\\n                 endOfSubsequence.put(num, endOfSubsequence.getOrDefault(num,0)+1);\\n                 \\n             }  else if(elementFreq.getOrDefault(num+1,0)>0 && elementFreq.getOrDefault(num+2,0)>0){\\n                 // we are making num+2 as ending of subsequence\\n                 elementFreq.put(num+1,elementFreq.getOrDefault(num+1,0)-1);\\n                 elementFreq.put(num+2,elementFreq.getOrDefault(num+2,0)-1);\\n                 endOfSubsequence.put(num+2, endOfSubsequence.getOrDefault(num+2,0)+1);\\n                 \\n             }  else {\\n                 return false;\\n             }        \\n            \\n        }\\n        \\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447118,
                "title": "go-golang-state-machine-solution-time-o-n-space-o-1",
                "content": "```\\nfunc isPossible(nums []int) bool {\\n    prevNum := math.MinInt32\\n    state := [3]int{}\\n    \\n    for len(nums) > 0 {\\n        num := nums[0]\\n        \\n        if prevNum+1 != num {\\n            if state[1] != 0 || state[2] != 0 {\\n                return false\\n            }\\n            \\n            state[0] = 0\\n        }\\n        \\n        count := 0\\n        \\n        for len(nums) > 0 && nums[0] == num {\\n            count++\\n            nums = nums[1:]\\n        }\\n        \\n        count -= state[1]+state[2]\\n        \\n        if count < 0 {\\n            return false\\n        }\\n\\n        state[0], state[1], state[2] = state[1]+min(count, state[0]), state[2], max(0, count-state[0])\\n        \\n        prevNum = num\\n    }\\n    \\n    return state[1] == 0 && state[2] == 0\\n}\\n\\nfunc min(i, j int) int {\\n    if i < j {\\n        return i\\n    }\\n    \\n    return j\\n}\\n\\nfunc max(i, j int) int {\\n    if i > j {\\n        return i\\n    }\\n    \\n    return j\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunc isPossible(nums []int) bool {\\n    prevNum := math.MinInt32\\n    state := [3]int{}\\n    \\n    for len(nums) > 0 {\\n        num := nums[0]\\n        \\n        if prevNum+1 != num {\\n            if state[1] != 0 || state[2] != 0 {\\n                return false\\n            }\\n            \\n            state[0] = 0\\n        }\\n        \\n        count := 0\\n        \\n        for len(nums) > 0 && nums[0] == num {\\n            count++\\n            nums = nums[1:]\\n        }\\n        \\n        count -= state[1]+state[2]\\n        \\n        if count < 0 {\\n            return false\\n        }\\n\\n        state[0], state[1], state[2] = state[1]+min(count, state[0]), state[2], max(0, count-state[0])\\n        \\n        prevNum = num\\n    }\\n    \\n    return state[1] == 0 && state[2] == 0\\n}\\n\\nfunc min(i, j int) int {\\n    if i < j {\\n        return i\\n    }\\n    \\n    return j\\n}\\n\\nfunc max(i, j int) int {\\n    if i > j {\\n        return i\\n    }\\n    \\n    return j\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2447111,
                "title": "simple-greedy-solution-c-explained-o-n",
                "content": "**Algorithm:**\\n1. Created two HashMap/ Unordered Map to store frequencies of each element and number of consecutive subsequence that ends at element value.\\n2. Loaded frequencies into count map.\\n3. Do the following: \\n\\ta. If frequency of element is 0, continue (means number has already been used by previous subsequence)\\n\\tb. else decrease the frequency by 1.\\n\\tc. If  end map previous element frequency is greater than 0, decrease the previous value frequency and increase the current value frequency by 1\\n\\td. else if next 2 element has frequency greater than 0, decrease its frequency by 1 and increment end map frequency by 1.\\n\\te. else it is not possible to form subsequence, return false\\n4. If all cases run, return true means it is possible to form subsequence.\\n\\nTime Complexity: O(n)\\nAuxiliary Space: O(n)\\n\\nHere\\'s code:\\n\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        unordered_map<int, int> count, end;\\n        for (int it:nums) count[it]++;\\n        for (int it: nums) {\\n            if (count[it]==0) continue;\\n            count[it]--;\\n            \\n            if (end[it-1]>0) {\\n                end[it-1]--;\\n                end[it]++;\\n            } else if (count[it+1]>0 && count[it+2]>0) {\\n                count[it+1]--;\\n                count[it+2]--;\\n                end[it+2]++;\\n            } else {\\n                return false;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```\\n\\nPlease upvote if you liked my explanation and code.",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        unordered_map<int, int> count, end;\\n        for (int it:nums) count[it]++;\\n        for (int it: nums) {\\n            if (count[it]==0) continue;\\n            count[it]--;\\n            \\n            if (end[it-1]>0) {\\n                end[it-1]--;\\n                end[it]++;\\n            } else if (count[it+1]>0 && count[it+2]>0) {\\n                count[it+1]--;\\n                count[it+2]--;\\n                end[it+2]++;\\n            } else {\\n                return false;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447015,
                "title": "cpp-solution-using-priority-queue",
                "content": "**Please Upvote..**\\n```\\n#define pr pair<int,int>\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        priority_queue<pr,vector<pr>,greater<pr>>q;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(q.empty()){\\n                q.push({nums[i],1});\\n            }\\n            \\n            else{\\n                auto ele=q.top();\\n                                 \\n                if(ele.first==nums[i]){\\n                    q.push({nums[i],1});\\n                }\\n                \\n\\n                else if(nums[i]-ele.first==1){\\n                    q.pop();\\n                    q.push({nums[i],ele.second+1});\\n                }\\n                else {\\n                    while(!q.empty() && q.top().second>2 && nums[i]-q.top().first!=1)q.pop();\\n                    \\n                    if(q.empty()){\\n                        q.push({nums[i],1});\\n                    }\\n                    \\n                    else{\\n                     \\n                        auto ele=q.top();\\n                        if(nums[i]-ele.first==1){\\n                            q.pop();\\n                    q.push({nums[i],ele.second+1});\\n                        }\\n                        else return false;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        while(!q.empty()){\\n            auto ele=q.top();\\n            // cout<<ele.first<<\" \"<<ele.second<<\" \";\\n            q.pop();\\n            if(ele.second<=2)return false;\\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        priority_queue<pr,vector<pr>,greater<pr>>q;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(q.empty()){\\n                q.push({nums[i],1}",
                "codeTag": "Java"
            },
            {
                "id": 2446921,
                "title": "go-golang-solution",
                "content": "```\\nfunc isPossible(nums []int) bool {\\n\\tcnt, need := make(map[int]int), make(map[int]int)\\n\\tfor _, v := range nums {\\n\\t\\tcnt[v]++\\n\\t}\\n\\tfor _, v := range nums {\\n\\t\\tif cnt[v] == 0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tcnt[v]--\\n\\t\\tif need[v-1] > 0 {\\n\\t\\t\\tneed[v-1]--\\n\\t\\t\\tneed[v]++\\n\\t\\t} else if cnt[v+1] > 0 && cnt[v+2] > 0 {\\n\\t\\t\\tcnt[v+1]--\\n\\t\\t\\tcnt[v+2]--\\n\\t\\t\\tneed[v+2]++\\n\\t\\t} else {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isPossible(nums []int) bool {\\n\\tcnt, need := make(map[int]int), make(map[int]int)\\n\\tfor _, v := range nums {\\n\\t\\tcnt[v]++\\n\\t}\\n\\tfor _, v := range nums {\\n\\t\\tif cnt[v] == 0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tcnt[v]--\\n\\t\\tif need[v-1] > 0 {\\n\\t\\t\\tneed[v-1]--\\n\\t\\t\\tneed[v]++\\n\\t\\t} else if cnt[v+1] > 0 && cnt[v+2] > 0 {\\n\\t\\t\\tcnt[v+1]--\\n\\t\\t\\tcnt[v+2]--\\n\\t\\t\\tneed[v+2]++\\n\\t\\t} else {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2159812,
                "title": "c-multiset-logic-similar-to-priority-queue",
                "content": "Every number x has to be part of a subsequence ending at x-1, so we need to check if there is a subsequence ending at x-1. If there are multiple such subsequences, take the smalles one\\n\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        \\n        unordered_map<int, multiset<int>> mp;\\n        \\n        for (int i=0; i<nums.size(); i++){\\n            \\n            if (mp.find(nums[i]-1) == mp.end()){\\n                mp[nums[i]].insert(1);\\n            }\\n            else if (mp[nums[i]-1].size() == 0){\\n                mp[nums[i]].insert(1);\\n            }\\n            else{\\n                int len = *(mp[nums[i]-1].begin());\\n                \\n                mp[nums[i]-1].erase(mp[nums[i]-1].begin());\\n                \\n                mp[nums[i]].insert(len+1);\\n            }\\n        }\\n        \\n        for (auto m : mp){\\n            \\n            if (m.second.size() != 0){\\n                int x = *((m.second).begin());\\n                \\n                if (x<3) return false;\\n            } \\n        }\\n        \\n        return true;\\n        \\n    }\\n};\\n\\n\\n//  nums[i]\\n//  nums[i]-1 \\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        \\n        unordered_map<int, multiset<int>> mp;\\n        \\n        for (int i=0; i<nums.size(); i++){\\n            \\n            if (mp.find(nums[i]-1) == mp.end()){\\n                mp[nums[i]].insert(1);\\n            }\\n            else if (mp[nums[i]-1].size() == 0){\\n                mp[nums[i]].insert(1);\\n            }\\n            else{\\n                int len = *(mp[nums[i]-1].begin());\\n                \\n                mp[nums[i]-1].erase(mp[nums[i]-1].begin());\\n                \\n                mp[nums[i]].insert(len+1);\\n            }\\n        }\\n        \\n        for (auto m : mp){\\n            \\n            if (m.second.size() != 0){\\n                int x = *((m.second).begin());\\n                \\n                if (x<3) return false;\\n            } \\n        }\\n        \\n        return true;\\n        \\n    }\\n};\\n\\n\\n//  nums[i]\\n//  nums[i]-1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1759824,
                "title": "c-maps-greedy",
                "content": "Comment down if you want an explanation\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        if(nums.size()<3)\\n            return false;\\n        map<int,int> freq_map; // stores frequency of each element\\n        map<int,int> subseq_map; // stores last number of a valid subsequence\\n        for(auto n:nums)\\n        {\\n            freq_map[n]++;\\n        }\\n        for(int n:nums)\\n        {\\n            if(freq_map[n]==0)  // all frequencies of number used up\\n                continue;\\n            else if(subseq_map[n-1]>0) // a valid subsequence already exist, append this number\\n            {\\n                subseq_map[n-1]--;\\n                subseq_map[n]++;\\n            }\\n            else if(freq_map[n+1]>0 and freq_map[n+2]>0) // create a new subsequence\\n            {\\n                subseq_map[n+2]++;\\n                freq_map[n+1]--;\\n                freq_map[n+2]--;\\n            }\\n            else\\n                return false;\\n            \\n            freq_map[n]--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        if(nums.size()<3)\\n            return false;\\n        map<int,int> freq_map; // stores frequency of each element\\n        map<int,int> subseq_map; // stores last number of a valid subsequence\\n        for(auto n:nums)\\n        {\\n            freq_map[n]++;\\n        }\\n        for(int n:nums)\\n        {\\n            if(freq_map[n]==0)  // all frequencies of number used up\\n                continue;\\n            else if(subseq_map[n-1]>0) // a valid subsequence already exist, append this number\\n            {\\n                subseq_map[n-1]--;\\n                subseq_map[n]++;\\n            }\\n            else if(freq_map[n+1]>0 and freq_map[n+2]>0) // create a new subsequence\\n            {\\n                subseq_map[n+2]++;\\n                freq_map[n+1]--;\\n                freq_map[n+2]--;\\n            }\\n            else\\n                return false;\\n            \\n            freq_map[n]--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1700418,
                "title": "javascript-use-less-memory",
                "content": "```javascript\\nvar isPossible = function(nums) {\\n    // The subsequences type is [{ length: number, num: number }, ...]\\n    // The key about use less memory is that don\\'t saving all number in each subsequences,\\n    // just only save the last number of each subsequences and the length\\n    const subsequences = []\\n    \\n    nums.forEach(num => {\\n        for(let i = subsequences.length - 1; i >= 0; i--) {\\n            const obj = subsequences[i]\\n            const subNum = obj.num\\n            \\n            if (num === subNum + 1) {\\n                obj.num = num\\n                obj.length += 1\\n                return\\n            }\\n        }\\n        \\n        subsequences.push({\\n            length: 1,\\n            num,\\n        })\\n    })\\n    \\n    \\n    return !subsequences.find(item => item.length < 3)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar isPossible = function(nums) {\\n    // The subsequences type is [{ length: number, num: number }, ...]\\n    // The key about use less memory is that don\\'t saving all number in each subsequences,\\n    // just only save the last number of each subsequences and the length\\n    const subsequences = []\\n    \\n    nums.forEach(num => {\\n        for(let i = subsequences.length - 1; i >= 0; i--) {\\n            const obj = subsequences[i]\\n            const subNum = obj.num\\n            \\n            if (num === subNum + 1) {\\n                obj.num = num\\n                obj.length += 1\\n                return\\n            }\\n        }\\n        \\n        subsequences.push({\\n            length: 1,\\n            num,\\n        })\\n    })\\n    \\n    \\n    return !subsequences.find(item => item.length < 3)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1590548,
                "title": "c-o-n-greedy-using-unordered-map",
                "content": "We use two unordered maps to keep track of the frequencies of all the available numbers, and the ends of all possible sequences.\\n\\nWith any given number, we always try to add it to the end of an existing sequence first. If no such sequence exists, then we can try to create a new sequence by looking ahead at the consecutive numbers that follow. If the consecutive numbers are not present, then we will simply return false and exit. \\n\\nThe greedy solution works because for any encountered number, it is always more optimal to add it to an existing sequence. If we have a number `x` and a sequence ending with `x - 1`, we can arrive at a valid arrangement even if numbers `x + 1` and `x + 2` exist by adding them to the same sequence. On the other hand, if we create a new sequence with `x`, `x + 1` and `x + 2`, it is possible that we get stuck with a sequence with only 2 elements. For instance, consider the input `[1,2,3,4,5,5,6,7]` . \\n```class Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        unordered_map<int, int> freq; \\n        unordered_map<int, int> ends; \\n        for (int i : nums) {\\n            freq[i]++; \\n        }\\n        \\n        for (int i : nums) {\\n            if (freq[i] == 0) {\\n                continue; \\n            }\\n            if (ends[i - 1] > 0) {\\n                freq[i]--;\\n                ends[i - 1]--;\\n                ends[i]++; \\n            } else if (freq[i + 1] > 0 && freq[i + 2] > 0) {\\n                freq[i]--;\\n                freq[i + 1]--;\\n                freq[i + 2]--;\\n                ends[i + 2]++; \\n            } else {\\n                return false; \\n            }\\n        }\\n        \\n        return true; \\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        unordered_map<int, int> freq; \\n        unordered_map<int, int> ends; \\n        for (int i : nums) {\\n            freq[i]++; \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1489587,
                "title": "java-2-hashmap-solution-with-explanation",
                "content": "```\\n// 2 HashMap Solution\\n// Time complexity: O(N)\\n// Space complexity: O(N)\\nclass Solution {\\n    public boolean isPossible(int[] nums) {\\n        if (nums == null || nums.length < 3) return false;\\n        Map<Integer, Integer> freqMap = new HashMap<>();  // Store <num, freq> pair\\n        Map<Integer, Integer> seqMap = new HashMap<>();  // Store <the end num, freq> pair\\n        for (int num : nums) {\\n            freqMap.put(num, freqMap.getOrDefault(num, 0) + 1);\\n        }\\n        for (int num : nums) {\\n            int freq = freqMap.get(num);\\n            if (freq == 0) {\\n                // If the num freq is 0, num has been added to one subsequence.\\n                continue;\\n            } else if (seqMap.getOrDefault(num - 1, 0) > 0) { \\n                // If num could be add into one subsequnce, update seqMap.\\n                seqMap.put(num - 1, seqMap.get(num - 1) - 1);\\n                seqMap.put(num, seqMap.getOrDefault(num, 0) + 1);\\n            } else if (freqMap.getOrDefault(num + 1, 0) > 0 && freqMap.getOrDefault(num + 2, 0) > 0) {\\n                // If num could be formed as one subsequnce, add it to seqMap.\\n                freqMap.put(num + 1, freqMap.get(num + 1) - 1);\\n                freqMap.put(num + 2, freqMap.get(num + 2) - 1);\\n                seqMap.put(num + 2, seqMap.getOrDefault(num + 2, 0) + 1);\\n            } else {\\n                return false;\\n            }\\n            freqMap.put(num, freq - 1);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// 2 HashMap Solution\\n// Time complexity: O(N)\\n// Space complexity: O(N)\\nclass Solution {\\n    public boolean isPossible(int[] nums) {\\n        if (nums == null || nums.length < 3) return false;\\n        Map<Integer, Integer> freqMap = new HashMap<>();  // Store <num, freq> pair\\n        Map<Integer, Integer> seqMap = new HashMap<>();  // Store <the end num, freq> pair\\n        for (int num : nums) {\\n            freqMap.put(num, freqMap.getOrDefault(num, 0) + 1);\\n        }\\n        for (int num : nums) {\\n            int freq = freqMap.get(num);\\n            if (freq == 0) {\\n                // If the num freq is 0, num has been added to one subsequence.\\n                continue;\\n            } else if (seqMap.getOrDefault(num - 1, 0) > 0) { \\n                // If num could be add into one subsequnce, update seqMap.\\n                seqMap.put(num - 1, seqMap.get(num - 1) - 1);\\n                seqMap.put(num, seqMap.getOrDefault(num, 0) + 1);\\n            } else if (freqMap.getOrDefault(num + 1, 0) > 0 && freqMap.getOrDefault(num + 2, 0) > 0) {\\n                // If num could be formed as one subsequnce, add it to seqMap.\\n                freqMap.put(num + 1, freqMap.get(num + 1) - 1);\\n                freqMap.put(num + 2, freqMap.get(num + 2) - 1);\\n                seqMap.put(num + 2, seqMap.getOrDefault(num + 2, 0) + 1);\\n            } else {\\n                return false;\\n            }\\n            freqMap.put(num, freq - 1);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1456123,
                "title": "java-simple-greedy-approach-with-explanation",
                "content": "```\\nclass Solution {\\n    \\n    /*\\n     * It is a greedy approach we are taking\\n     *  For that we need two Map\\n     *      1. To hold the frequency of the element (frequencyMap)\\n     *      2. Whether any number is eligible to join a existing sequence (probableSeqMap)\\n     *\\n     *   We will iterate over the array and wil check below step sequentially\\n     *   Step-1 : Check in the frequency map if the element is eligible for process or not. If not continue for others\\n     *   Step-2 : If any position is available to join the existing sequence or not.\\n     *              If YES -\\n     *                  1. Decrement the value by 1 in the frequency map as it is joining in the sequence\\n     *                  2. Decrement its value by 1 from probableSeqMap as a new num has joined.\\n     *                  3. Open a new probable position in the probableSeqMap for the next position i.e. (num + 1)\\n     *\\n     *   Step-3 : As there no option to join in the existing sequence then check is it possible to form a sequence of 3 by the current value.\\n     *              If Yes -\\n     *                  1. Decrement its value by 1 from frequencyMap as nums is joining. For all the three nums\\n     *                      i.e. - num , (num + 1) and (num + 2)\\n     *                  2. Open a new probable position in the probableSeqMap for the next position i.e. (num + 3)\\n     *\\n     *               If NO -\\n     *                   Means for the current num, none of the above cases is possible then there is no Consecutive Subsequences.\\n     *                   So return false.\\n     *\\n     *    Step-4 : If all the cases is passed then, that means Consecutive Subsequences is possible\\n     *             So return false.\\n     */\\n    public boolean isPossible(int[] nums) {\\n\\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\\n        Map<Integer, Integer> probableSeqMap = new HashMap<>();\\n\\n        for (int num : nums) {\\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\\n        }\\n\\n        for (int num : nums) {\\n            //Check in the frequency map if the element is eligible for process or not. If not continue for others\\n            if (frequencyMap.get(num) == 0) {\\n                continue;\\n            }\\n            // If any position is available to join the existing sequence or not.\\n            if (probableSeqMap.containsKey(num) && probableSeqMap.get(num) > 0) {\\n                // Decrement its value by 1 from frequencyMap as num is joining\\n                frequencyMap.put(num, frequencyMap.get(num) - 1);\\n                // Decrement its value by 1 from probableSeqMap as a new num is joining\\n                probableSeqMap.put(num, probableSeqMap.get(num) - 1);\\n                // Open a new probable position in the probableSeqMap for the next position i.e. (num + 1)\\n                probableSeqMap.put(num + 1, probableSeqMap.getOrDefault(num + 1, 0) + 1);\\n            }\\n            // If no space to join then is it possible to form a sequence of 3 by the current value\\n            else if (frequencyMap.containsKey(num) && frequencyMap.containsKey(num + 1) && frequencyMap.containsKey(num + 2)\\n                    && frequencyMap.get(num) > 0 && frequencyMap.get(num + 1) > 0 && frequencyMap.get(num + 2) > 0) {\\n\\n                // Decrement its value by 1 from frequencyMap as num is joining\\n                frequencyMap.put(num, frequencyMap.get(num) - 1);\\n                frequencyMap.put(num + 1, frequencyMap.get(num + 1) - 1);\\n                frequencyMap.put(num + 2, frequencyMap.get(num + 2) - 1);\\n\\n                // Open a new probable position in the probableSeqMap for the next position i.e. (num + 3)\\n                probableSeqMap.put(num + 3, probableSeqMap.getOrDefault(num + 3, 0) + 1);\\n            }\\n            // If none of the above cases is possible then there is no Consecutive Subsequences\\n            else {\\n                return false;\\n            }\\n        }\\n\\n        // If all the cases is passed then, that means Consecutive Subsequences is possible\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    /*\\n     * It is a greedy approach we are taking\\n     *  For that we need two Map\\n     *      1. To hold the frequency of the element (frequencyMap)\\n     *      2. Whether any number is eligible to join a existing sequence (probableSeqMap)\\n     *\\n     *   We will iterate over the array and wil check below step sequentially\\n     *   Step-1 : Check in the frequency map if the element is eligible for process or not. If not continue for others\\n     *   Step-2 : If any position is available to join the existing sequence or not.\\n     *              If YES -\\n     *                  1. Decrement the value by 1 in the frequency map as it is joining in the sequence\\n     *                  2. Decrement its value by 1 from probableSeqMap as a new num has joined.\\n     *                  3. Open a new probable position in the probableSeqMap for the next position i.e. (num + 1)\\n     *\\n     *   Step-3 : As there no option to join in the existing sequence then check is it possible to form a sequence of 3 by the current value.\\n     *              If Yes -\\n     *                  1. Decrement its value by 1 from frequencyMap as nums is joining. For all the three nums\\n     *                      i.e. - num , (num + 1) and (num + 2)\\n     *                  2. Open a new probable position in the probableSeqMap for the next position i.e. (num + 3)\\n     *\\n     *               If NO -\\n     *                   Means for the current num, none of the above cases is possible then there is no Consecutive Subsequences.\\n     *                   So return false.\\n     *\\n     *    Step-4 : If all the cases is passed then, that means Consecutive Subsequences is possible\\n     *             So return false.\\n     */\\n    public boolean isPossible(int[] nums) {\\n\\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\\n        Map<Integer, Integer> probableSeqMap = new HashMap<>();\\n\\n        for (int num : nums) {\\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\\n        }\\n\\n        for (int num : nums) {\\n            //Check in the frequency map if the element is eligible for process or not. If not continue for others\\n            if (frequencyMap.get(num) == 0) {\\n                continue;\\n            }\\n            // If any position is available to join the existing sequence or not.\\n            if (probableSeqMap.containsKey(num) && probableSeqMap.get(num) > 0) {\\n                // Decrement its value by 1 from frequencyMap as num is joining\\n                frequencyMap.put(num, frequencyMap.get(num) - 1);\\n                // Decrement its value by 1 from probableSeqMap as a new num is joining\\n                probableSeqMap.put(num, probableSeqMap.get(num) - 1);\\n                // Open a new probable position in the probableSeqMap for the next position i.e. (num + 1)\\n                probableSeqMap.put(num + 1, probableSeqMap.getOrDefault(num + 1, 0) + 1);\\n            }\\n            // If no space to join then is it possible to form a sequence of 3 by the current value\\n            else if (frequencyMap.containsKey(num) && frequencyMap.containsKey(num + 1) && frequencyMap.containsKey(num + 2)\\n                    && frequencyMap.get(num) > 0 && frequencyMap.get(num + 1) > 0 && frequencyMap.get(num + 2) > 0) {\\n\\n                // Decrement its value by 1 from frequencyMap as num is joining\\n                frequencyMap.put(num, frequencyMap.get(num) - 1);\\n                frequencyMap.put(num + 1, frequencyMap.get(num + 1) - 1);\\n                frequencyMap.put(num + 2, frequencyMap.get(num + 2) - 1);\\n\\n                // Open a new probable position in the probableSeqMap for the next position i.e. (num + 3)\\n                probableSeqMap.put(num + 3, probableSeqMap.getOrDefault(num + 3, 0) + 1);\\n            }\\n            // If none of the above cases is possible then there is no Consecutive Subsequences\\n            else {\\n                return false;\\n            }\\n        }\\n\\n        // If all the cases is passed then, that means Consecutive Subsequences is possible\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318507,
                "title": "swift-split-array-into-consecutive-subsequences-test-cases",
                "content": "**Solution at July 6, 2021**\\n**Wild work with mutating subscript and we don\\'t sweat it :D**\\n\\n```swift\\ntypealias Counter = Dictionary<Int,Int>\\nextension Counter {\\n    subscript(k key: Int) -> Int {\\n        mutating get {\\n            return self[key] ?? 0\\n        }\\n        mutating set(value) {\\n            self[key] = self[k: key] + value\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    func isPossible(_ nums: [Int]) -> Bool {\\n        guard nums.count >= 3 else { return false }\\n        \\n        var count = Counter(), tail = Counter()\\n        nums.forEach{ count[k: $0] = 1 }\\n        \\n        for n in nums where count[k: n] != 0 {\\n            switch tail[k: n] > 0 {\\n            case true:\\n                tail[k: n] = -1\\n                tail[k: n+1] = 1\\n            default:\\n                if count[k: n+1] > 0 && count[k: n+2] > 0 {\\n                    count[k: n+1] = -1\\n                    count[k: n+2] = -1\\n                    tail[k: n+3] = 1\\n                } else {\\n                    return false\\n                }\\n            }\\n            count[k: n] = -1\\n        }\\n        return true\\n    }\\n}\\n```\\n\\n```swift\\nimport XCTest\\n\\n// MARK: Executed 3 tests, with 0 failures (0 unexpected) in 0.146 (0.148) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test1() {\\n        let res = s.isPossible([1,2,3,3,4,5])\\n        XCTAssertEqual(res, true)\\n    }\\n    func test2() {\\n        let res = s.isPossible([1,2,3,3,4,4,5,5])\\n        XCTAssertEqual(res, true)\\n    }\\n    func test3() {\\n        let res = s.isPossible([1,2,3,4,4,5])\\n        XCTAssertEqual(res, false)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\ntypealias Counter = Dictionary<Int,Int>\\nextension Counter {\\n    subscript(k key: Int) -> Int {\\n        mutating get {\\n            return self[key] ?? 0\\n        }\\n        mutating set(value) {\\n            self[key] = self[k: key] + value\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    func isPossible(_ nums: [Int]) -> Bool {\\n        guard nums.count >= 3 else { return false }\\n        \\n        var count = Counter(), tail = Counter()\\n        nums.forEach{ count[k: $0] = 1 }\\n        \\n        for n in nums where count[k: n] != 0 {\\n            switch tail[k: n] > 0 {\\n            case true:\\n                tail[k: n] = -1\\n                tail[k: n+1] = 1\\n            default:\\n                if count[k: n+1] > 0 && count[k: n+2] > 0 {\\n                    count[k: n+1] = -1\\n                    count[k: n+2] = -1\\n                    tail[k: n+3] = 1\\n                } else {\\n                    return false\\n                }\\n            }\\n            count[k: n] = -1\\n        }\\n        return true\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// MARK: Executed 3 tests, with 0 failures (0 unexpected) in 0.146 (0.148) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test1() {\\n        let res = s.isPossible([1,2,3,3,4,5])\\n        XCTAssertEqual(res, true)\\n    }\\n    func test2() {\\n        let res = s.isPossible([1,2,3,3,4,4,5,5])\\n        XCTAssertEqual(res, true)\\n    }\\n    func test3() {\\n        let res = s.isPossible([1,2,3,4,4,5])\\n        XCTAssertEqual(res, false)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1280290,
                "title": "just-fill-in-the-number-as-the-rules-no-map-or-binary-search-needed",
                "content": "```\\n    def isPossible(self, nums: List[int]) -> bool:\\n        arr = [[nums[0]]]\\n        row = 0\\n        for i in range(1, len(nums)):\\n            row = len(arr) - 1 if nums[i - 1] != nums[i] else row - 1\\n            if row == -1:\\n                arr.append([nums[i]])\\n                row = len(arr) - 1\\n                continue\\n            if arr[row][-1] + 1 == nums[i]:\\n                arr[row].append(nums[i])  \\n            else:\\n                arr.append([nums[i]])\\n                row = len(arr) - 1\\n        # print(arr)\\n        for rows in arr:\\n            if len(rows) < 3:\\n                return False\\n        return True\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    def isPossible(self, nums: List[int]) -> bool:\\n        arr = [[nums[0]]]\\n        row = 0\\n        for i in range(1, len(nums)):\\n            row = len(arr) - 1 if nums[i - 1] != nums[i] else row - 1\\n            if row == -1:\\n                arr.append([nums[i]])\\n                row = len(arr) - 1\\n                continue\\n            if arr[row][-1] + 1 == nums[i]:\\n                arr[row].append(nums[i])  \\n            else:\\n                arr.append([nums[i]])\\n                row = len(arr) - 1\\n        # print(arr)\\n        for rows in arr:\\n            if len(rows) < 3:\\n                return False\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1246100,
                "title": "greedy-algorithm-c",
                "content": "I chose to solve this question using a greedy algorithm, which can be divided into the following steps:\\n1. Calculate the frequency of each number.\\n2. For each number ```i```, if there exits a subsequence ending in ```i - 1```, append ```i``` to the subsequence. Otherwise, if ```i + 1``` and ```i + 2``` are both numbers that have not yet been assigned to a subsequence, create a new subsequence ending in ```i + 2```. If neither of these conditions are satisfied, the array cannot be split.\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        unordered_map<int, int> left, tail;\\n        for (int i : nums) {\\n            left[i]++;\\n        }\\n        for (int i : nums){\\n            if (!left[i]) {\\n                continue;\\n            }\\n            left[i]--;\\n            if (tail[i - 1] > 0){\\n                tail[i - 1]--;\\n                tail[i]++;\\n            }\\n            else if (left[i + 1] && left[i + 2]){\\n                left[i + 1]--;\\n                left[i + 2]--;\\n                tail[i + 2]++;\\n            }\\n            else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```i```\n```i - 1```\n```i```\n```i + 1```\n```i + 2```\n```i + 2```\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        unordered_map<int, int> left, tail;\\n        for (int i : nums) {\\n            left[i]++;\\n        }\\n        for (int i : nums){\\n            if (!left[i]) {\\n                continue;\\n            }\\n            left[i]--;\\n            if (tail[i - 1] > 0){\\n                tail[i - 1]--;\\n                tail[i]++;\\n            }\\n            else if (left[i + 1] && left[i + 2]){\\n                left[i + 1]--;\\n                left[i + 2]--;\\n                tail[i + 2]++;\\n            }\\n            else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1211751,
                "title": "c-o-n-time-o-n-space-hashmap-soln",
                "content": "End[x]= No. of subsequence ending with x.\\nleft[x]= frequency of x.\\n\\n\\'\\'\\'\\n\\n    bool isPossible(vector<int>& nums) {\\n        unordered_map<int,int> left;\\n        unordered_map<int,int> end;\\n        int i;\\n        \\n        for(i=0;i<nums.size();i++)\\n        {\\n            left[nums[i]]++;\\n        }\\n        \\n        for(i=0;i<nums.size();i++)\\n        {\\n            if(left[nums[i]]==0)\\n                continue;\\n            \\n             left[nums[i]]--;\\n            \\n            if(end[nums[i]-1]>0)// checking if there is a subsequence ending with nums[i]-1, so that we can add nums[i] in that subsequence\\n            {\\n                end[nums[i]-1]--;\\n                end[nums[i]]++;\\n            }\\n            else if(left[nums[i]+1]>0 && left[nums[i]+2]>0)// checking if there can be a subsequece beginning with nums[i]\\n            {\\n                left[nums[i]+1]--;\\n                left[nums[i]+2]--;\\n                end[nums[i]+2]++;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "End[x]= No. of subsequence ending with x.\\nleft[x]= frequency of x.\\n\\n\\'\\'\\'\\n\\n    bool isPossible(vector<int>& nums) {\\n        unordered_map<int,int> left;\\n        unordered_map<int,int> end;\\n        int i;\\n        \\n        for(i=0;i<nums.size();i++)\\n        {\\n            left[nums[i]]++;\\n        }\\n        \\n        for(i=0;i<nums.size();i++)\\n        {\\n            if(left[nums[i]]==0)\\n                continue;\\n            \\n             left[nums[i]]--;\\n            \\n            if(end[nums[i]-1]>0)// checking if there is a subsequence ending with nums[i]-1, so that we can add nums[i] in that subsequence\\n            {\\n                end[nums[i]-1]--;\\n                end[nums[i]]++;\\n            }\\n            else if(left[nums[i]+1]>0 && left[nums[i]+2]>0)// checking if there can be a subsequece beginning with nums[i]\\n            {\\n                left[nums[i]+1]--;\\n                left[nums[i]+2]--;\\n                end[nums[i]+2]++;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1105357,
                "title": "c-solution",
                "content": "```\\nbool isPossible(vector<int>& nums) {\\n        int n=nums.size();\\n        map<int,int> count,end;\\n        for(auto x:nums)\\n            count[x]++;\\n        for(auto x:nums)\\n        {\\n            if(count[x]<=0)\\n                continue;\\n            count[x]--;\\n            if(end.find(x-1)!=end.end() && end[x-1]>0)\\n            {\\n                end[x]+=1;\\n                end[x-1]-=1;\\n            }\\n            else if(count.find(x+1)!=end.end() && count[x+1]>0 && count.find(x+2)!=end.end() && count[x+2]>0)\\n            {\\n                count[x+1]--;\\n                count[x+2]--;\\n                end[x+2]++;\\n            }\\n            else\\n                return false;\\n        }\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "```\\nbool isPossible(vector<int>& nums) {\\n        int n=nums.size();\\n        map<int,int> count,end;\\n        for(auto x:nums)\\n            count[x]++;\\n        for(auto x:nums)\\n        {\\n            if(count[x]<=0)\\n                continue;\\n            count[x]--;\\n            if(end.find(x-1)!=end.end() && end[x-1]>0)\\n            {\\n                end[x]+=1;\\n                end[x-1]-=1;\\n            }\\n            else if(count.find(x+1)!=end.end() && count[x+1]>0 && count.find(x+2)!=end.end() && count[x+2]>0)\\n            {\\n                count[x+1]--;\\n                count[x+2]--;\\n                end[x+2]++;\\n            }\\n            else\\n                return false;\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 994590,
                "title": "java-o-n-time-space-complexity-hashmap",
                "content": "1. use two maps: one for counting the frequency of a number, one for counting the **needed** tails of previously constructed subsequences\\n2. **key**: iterate through the array \\n     - for each element we have 2 options:\\n      - 1. append it to a previously constructed consecutive sequence \\n         2. become a start of a new consecutive sequence\\n         3. return false if both options are not valid\\n\\t\\t\\n```\\nclass Solution {\\n    public boolean isPossible(int[] nums) {\\n        HashMap<Integer, Integer> count = new HashMap<>();\\n        HashMap<Integer, Integer> tails = new HashMap<>();\\n        for (int num : nums) {\\n            count.put(num, count.getOrDefault(num, 0) + 1);\\n        }\\n        \\n        for (int num : nums) {\\n            if (count.get(num) == 0) continue;\\n            else if (tails.getOrDefault(num, 0) > 0) {\\n                tails.put(num, tails.get(num) - 1);\\n                tails.put(num + 1, tails.getOrDefault(num + 1, 0) + 1);\\n            }\\n            else if (count.getOrDefault(num + 1, 0) > 0 && count.getOrDefault(num + 2, 0) > 0) {\\n                count.put(num + 1, count.get(num + 1) - 1);\\n                count.put(num + 2, count.get(num + 2) - 1);\\n                tails.put(num + 3, tails.getOrDefault(num + 3, 0) + 1);\\n            }\\n            else return false;\\n            \\n            count.put(num, count.get(num) - 1);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isPossible(int[] nums) {\\n        HashMap<Integer, Integer> count = new HashMap<>();\\n        HashMap<Integer, Integer> tails = new HashMap<>();\\n        for (int num : nums) {\\n            count.put(num, count.getOrDefault(num, 0) + 1);\\n        }\\n        \\n        for (int num : nums) {\\n            if (count.get(num) == 0) continue;\\n            else if (tails.getOrDefault(num, 0) > 0) {\\n                tails.put(num, tails.get(num) - 1);\\n                tails.put(num + 1, tails.getOrDefault(num + 1, 0) + 1);\\n            }\\n            else if (count.getOrDefault(num + 1, 0) > 0 && count.getOrDefault(num + 2, 0) > 0) {\\n                count.put(num + 1, count.get(num + 1) - 1);\\n                count.put(num + 2, count.get(num + 2) - 1);\\n                tails.put(num + 3, tails.getOrDefault(num + 3, 0) + 1);\\n            }\\n            else return false;\\n            \\n            count.put(num, count.get(num) - 1);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 950725,
                "title": "c-intuitive-minheap-solution",
                "content": "In essence, we are using the minheap to keep track of the valid and relevant vectors that we are constructing\\nIf we cannot add onto or create a valid increasing vector of size three, then it is not possible to split the array.\\n\\nAlgorithm:\\n* First, we map numbers to their frequencies so we can confidently construct valid vectors of size three .\\n* Then, we go through all the numbers\\n\\t* First we eliminate any vectors that aren\\'t relevant anymore (have back < curr-1 means that we can never add on to those subsequences)\\n\\t* Then, we check if there is already a valid array we can add to-- if so, then add it on to the array\\n\\t* Otherwise, attempt to construct a valid three array by checking the frequencies of curr +1 and curr + 2\\n\\t*  If we cannot do either of those aactions, we fail to split the array into consecutive subarrays\\n\\nAnother potential minheap solution involves mapping a minheap to each number, prioritizing \"adding\" to vectors of smallest size (which we can just keep track of size)\\n\\n```\\nstruct custom {\\n  bool operator()(const vector<int>& lhs, const vector<int>& rhs) {\\n\\t  return lhs.back() > rhs.back();\\n  }  \\n};\\nbool isPossible(vector<int>& nums) {\\n\\tmap<int, int> freq;\\n\\tfor(int i = 0; i < nums.size(); ++i)\\n\\t\\tfreq[nums[i]]++;\\n\\n\\tpriority_queue<vector<int>, vector<vector<int> >, custom> prio;\\n\\tfor(auto it = freq.begin(); it != freq.end(); ++it) {\\n\\t\\tint curr = it->first;\\n\\n\\t\\twhile(it->second > 0) {\\n\\t\\t\\twhile(!prio.empty() && prio.top().back() < curr - 1) //get potential valid 3+ vectors\\n\\t\\t\\t\\tprio.pop();\\n\\n\\t\\t\\tif(!prio.empty() && prio.top().back() == curr - 1) {\\n\\t\\t\\t\\t//add it to a valid 3+ vector\\n\\t\\t\\t\\tvector<int> copy = prio.top();\\n\\t\\t\\t\\tprio.pop();\\n\\t\\t\\t\\tcopy.push_back(curr);\\n\\t\\t\\t\\tprio.push(copy);\\n\\t\\t\\t} else if (freq[curr + 1] > 0 && freq[curr + 2] > 0) { //can create valid 3+ vector\\n\\t\\t\\t\\tvector<int> validThree; //construct the valid vector\\n\\t\\t\\t\\tvalidThree.push_back(curr);\\n\\t\\t\\t\\tvalidThree.push_back(curr+1);\\n\\t\\t\\t\\tvalidThree.push_back(curr+2);\\n\\t\\t\\t\\tprio.push(validThree);\\n\\t\\t\\t\\t//used the values-- subtract from freq map\\n\\t\\t\\t\\tfreq[curr+1]--;\\n\\t\\t\\t\\tfreq[curr+2]--;\\n\\t\\t\\t} else { //no valid operations available-- return false\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tit->second--;\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstruct custom {\\n  bool operator()(const vector<int>& lhs, const vector<int>& rhs) {\\n\\t  return lhs.back() > rhs.back();\\n  }  \\n};\\nbool isPossible(vector<int>& nums) {\\n\\tmap<int, int> freq;\\n\\tfor(int i = 0; i < nums.size(); ++i)\\n\\t\\tfreq[nums[i]]++;\\n\\n\\tpriority_queue<vector<int>, vector<vector<int> >, custom> prio;\\n\\tfor(auto it = freq.begin(); it != freq.end(); ++it) {\\n\\t\\tint curr = it->first;\\n\\n\\t\\twhile(it->second > 0) {\\n\\t\\t\\twhile(!prio.empty() && prio.top().back() < curr - 1) //get potential valid 3+ vectors\\n\\t\\t\\t\\tprio.pop();\\n\\n\\t\\t\\tif(!prio.empty() && prio.top().back() == curr - 1) {\\n\\t\\t\\t\\t//add it to a valid 3+ vector\\n\\t\\t\\t\\tvector<int> copy = prio.top();\\n\\t\\t\\t\\tprio.pop();\\n\\t\\t\\t\\tcopy.push_back(curr);\\n\\t\\t\\t\\tprio.push(copy);\\n\\t\\t\\t} else if (freq[curr + 1] > 0 && freq[curr + 2] > 0) { //can create valid 3+ vector\\n\\t\\t\\t\\tvector<int> validThree; //construct the valid vector\\n\\t\\t\\t\\tvalidThree.push_back(curr);\\n\\t\\t\\t\\tvalidThree.push_back(curr+1);\\n\\t\\t\\t\\tvalidThree.push_back(curr+2);\\n\\t\\t\\t\\tprio.push(validThree);\\n\\t\\t\\t\\t//used the values-- subtract from freq map\\n\\t\\t\\t\\tfreq[curr+1]--;\\n\\t\\t\\t\\tfreq[curr+2]--;\\n\\t\\t\\t} else { //no valid operations available-- return false\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tit->second--;\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 884965,
                "title": "single-hash-map-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        if(n<3)return false;\\n        unordered_map<int,int>hash;\\n        for(int i=0;i<n;i++)hash[nums[i]]++;\\n        int count=n;\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=nums[i];\\n            if(hash[x]>0 and hash[x+1]>0 and hash[x+2]>0)\\n            {\\n                hash[x]--;\\n                hash[x+1]--;\\n                hash[x+2]--;\\n                x=x+3;\\n                count=count-3;\\n                while(hash[x]>0 and hash[x]>hash[x-1])\\n                {\\n                    count--;\\n                    hash[x]--;\\n                    x++;\\n                }\\n            }\\n        }\\n        if(count==0)return true;\\n        else return false;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        if(n<3)return false;\\n        unordered_map<int,int>hash;\\n        for(int i=0;i<n;i++)hash[nums[i]]++;\\n        int count=n;\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=nums[i];\\n            if(hash[x]>0 and hash[x+1]>0 and hash[x+2]>0)\\n            {\\n                hash[x]--;\\n                hash[x+1]--;\\n                hash[x+2]--;\\n                x=x+3;\\n                count=count-3;\\n                while(hash[x]>0 and hash[x]>hash[x-1])\\n                {\\n                    count--;\\n                    hash[x]--;\\n                    x++;\\n                }\\n            }\\n        }\\n        if(count==0)return true;\\n        else return false;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 850109,
                "title": "c-greedy-o-n-time-and-o-n-space",
                "content": "Inspired from other solutions, greedy approach using Dictionary. I have tried to explain with comments in code.\\n\\n```\\npublic class Solution {\\n    public bool IsPossible(int[] nums) {\\n        Dictionary<int, int> possiblity = new Dictionary<int, int>();\\n        Dictionary<int, int> count = new Dictionary<int, int>();\\n        //1. Get counts of all the numbers in array.\\n        foreach(var num in nums){\\n            if(!count.ContainsKey(num)){\\n                count.Add(num,0);\\n            }\\n            count[num]++;\\n        }\\n        //2. Iterate through nums array again, this time we will find if there are any subsequence >=3.\\n        foreach(var num in nums){\\n\\t\\t\\t//2.a. - If count is zero, num is already used by prev subsequence. Hence, we will get count 0.\\n            if(count[num] == 0) continue;\\n\\t\\t\\t\\n\\t\\t\\t//2.b. - check if we are having any continue subsequence. Here, we consume the number and \\n\\t\\t\\t//add future number. This will be to see if there is a possiblity of having continue subsequence.\\n            else if(possiblity.ContainsKey(num) && possiblity[num] > 0){\\n                possiblity[num]--;\\n                if(!possiblity.ContainsKey(num+1)){\\n                    possiblity.Add(num+1,0);\\n                }\\n                possiblity[num+1]++;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t//2.c. - check if current number is part of any future subsequence. \\n\\t\\t\\t//Decrement future subsequence from count and add possiblity number.\\n\\t\\t\\telse if(count.ContainsKey(num+1) && count[num+1] > 0 \\n                     && count.ContainsKey(num+2) && count[num+2] > 0){\\n                count[num+1]--;\\n                count[num+2]--;\\n                if(!possiblity.ContainsKey(num+3)){\\n                    possiblity.Add(num+3,0);\\n                }\\n                possiblity[num+3]++;\\n            }\\n\\t\\t\\t//2.d. - Number which is not part of subseqence >=3.\\n\\t\\t\\telse\\n                return false;\\n\\t\\t\\t//2.e - decrement count of number after consuming it.\\n            count[num]--;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\npublic class Solution {\\n    public bool IsPossible(int[] nums) {\\n        Dictionary<int, int> possiblity = new Dictionary<int, int>();\\n        Dictionary<int, int> count = new Dictionary<int, int>();\\n        //1. Get counts of all the numbers in array.\\n        foreach(var num in nums){\\n            if(!count.ContainsKey(num)){\\n                count.Add(num,0);\\n            }\\n            count[num]++;\\n        }\\n        //2. Iterate through nums array again, this time we will find if there are any subsequence >=3.\\n        foreach(var num in nums){\\n\\t\\t\\t//2.a. - If count is zero, num is already used by prev subsequence. Hence, we will get count 0.\\n            if(count[num] == 0) continue;\\n\\t\\t\\t\\n\\t\\t\\t//2.b. - check if we are having any continue subsequence. Here, we consume the number and \\n\\t\\t\\t//add future number. This will be to see if there is a possiblity of having continue subsequence.\\n            else if(possiblity.ContainsKey(num) && possiblity[num] > 0){\\n                possiblity[num]--;\\n                if(!possiblity.ContainsKey(num+1)){\\n                    possiblity.Add(num+1,0);\\n                }\\n                possiblity[num+1]++;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t//2.c. - check if current number is part of any future subsequence. \\n\\t\\t\\t//Decrement future subsequence from count and add possiblity number.\\n\\t\\t\\telse if(count.ContainsKey(num+1) && count[num+1] > 0 \\n                     && count.ContainsKey(num+2) && count[num+2] > 0){\\n                count[num+1]--;\\n                count[num+2]--;\\n                if(!possiblity.ContainsKey(num+3)){\\n                    possiblity.Add(num+3,0);\\n                }\\n                possiblity[num+3]++;\\n            }\\n\\t\\t\\t//2.d. - Number which is not part of subseqence >=3.\\n\\t\\t\\telse\\n                return false;\\n\\t\\t\\t//2.e - decrement count of number after consuming it.\\n            count[num]--;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 811017,
                "title": "hypothetical-map",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def isPossible(self, nums: List[int]) -> bool:\\n        if not nums or len(nums)<3:\\n            return False\\n        c=Counter(nums)\\n        hm=Counter()\\n        for i in nums:\\n            if c[i]==0:\\n                continue\\n            if (hm[i]>0):\\n                hm[i]-=1\\n                hm[i+1]+=1\\n                c[i]-=1\\n            elif (c[i]>0 and c[i+1]>0 and c[i+2]>0):\\n                c[i]-=1\\n                c[i+1]-=1\\n                c[i+2]-=1\\n                hm[i+3]+=1\\n            else:\\n                return False\\n        return True\\n                \\n   \\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def isPossible(self, nums: List[int]) -> bool:\\n        if not nums or len(nums)<3:\\n            return False\\n        c=Counter(nums)\\n        hm=Counter()\\n        for i in nums:\\n            if c[i]==0:\\n                continue\\n            if (hm[i]>0):\\n                hm[i]-=1\\n                hm[i+1]+=1\\n                c[i]-=1\\n            elif (c[i]>0 and c[i+1]>0 and c[i+2]>0):\\n                c[i]-=1\\n                c[i+1]-=1\\n                c[i+2]-=1\\n                hm[i+3]+=1\\n            else:\\n                return False\\n        return True\\n                \\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 758071,
                "title": "python-hash-table-opening-closing-windows-explained",
                "content": "Good naming convention, should be easy to follow the code.\\n\\nBase logic is that we open a subarary window for every ascending numbers, so for example [1,2,3,4,4]\\nWe will have a window consisting of [1,2,3,4].\\n\\nWhen we hit a number that isn\\'t directly ascending, so in our example the last 4 isn\\'t an increment of last number. So we store our current window [1,2,3,4] in a hash table, the key will be the next number to continue the incrementing order, so it\\'s going to be 5.\\n\\nAfter that we check if the the number we are currently on (last 4) is extending another window by checking if hash table has this key. If not we open a new window.\\n\\nImportant nuiance is to store the subarray windows in descending order (or even better, a priority queue), to always get the most relevant window for extension (with the smallest len).\\n\\nHope if gives you the idea, read the code and you will understand :) .\\n\\n```\\nclass Solution:\\n    def isPossible(self, nums: List[int]) -> bool:\\n        if not nums: return False\\n        \\n        hash_map = defaultdict(list)\\n        last_num = nums[0]\\n        current_ascending_window = [last_num]\\n        \\n        \\n        for i in range(1, len(nums)):\\n            num = nums[i]\\n            \\n            # If we can continue building the subarray\\n            if num - 1 == last_num:\\n                \\n                # There could be an option that I\\'m expanding a big window and there is a window that needs this number\\n                if num in hash_map and (len(current_ascending_window) > 3 and len(hash_map[num][-1]) < 3):\\n                    # There is a window that needs to be exapnd with this\\n                    last_num_needed = last_num + 1\\n                    hash_map[last_num_needed].append([*current_ascending_window])\\n                    hash_map[last_num_needed].sort(key=len, reverse=True)\\n                    \\n                    current_ascending_window = hash_map[num].pop()\\n                    \\n                    # Delete redundant keys\\n                    if len(hash_map[num]) == 0:\\n                        del hash_map[num]\\n                    \\n                current_ascending_window.append(num)\\n                \\n            # If we are not directly ascending we need to store needed value in hashmap\\n            else:\\n                last_num_needed = last_num + 1\\n                hash_map[last_num_needed].append([*current_ascending_window])\\n                \\n                # We want the items to be from smallest to biggest\\n                if len(hash_map[last_num_needed]) > 1:\\n                    hash_map[last_num_needed].sort(key=len, reverse=True)\\n                \\n                \\n                # If we have a window we can continue building with current num\\n                if num in hash_map:\\n                    current_ascending_window = hash_map[num].pop()\\n                    \\n                    # Delete redundant keys\\n                    if len(hash_map[num]) == 0:\\n                        del hash_map[num]\\n                        \\n                    current_ascending_window.append(num)\\n                    \\n                else:\\n                    current_ascending_window = [num]\\n            \\n            last_num = num\\n                \\n        # if we left iteration with a window\\n        if current_ascending_window:\\n            hash_map[last_num + 1].append([*current_ascending_window])\\n            \\n        # print(hash_map)\\n            \\n        for subarrays_for_missing in hash_map.values():\\n            for subarray in subarrays_for_missing:\\n                if len(subarray) < 3: return False\\n                \\n        return True\\n                \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isPossible(self, nums: List[int]) -> bool:\\n        if not nums: return False\\n        \\n        hash_map = defaultdict(list)\\n        last_num = nums[0]\\n        current_ascending_window = [last_num]\\n        \\n        \\n        for i in range(1, len(nums)):\\n            num = nums[i]\\n            \\n            # If we can continue building the subarray\\n            if num - 1 == last_num:\\n                \\n                # There could be an option that I\\'m expanding a big window and there is a window that needs this number\\n                if num in hash_map and (len(current_ascending_window) > 3 and len(hash_map[num][-1]) < 3):\\n                    # There is a window that needs to be exapnd with this\\n                    last_num_needed = last_num + 1\\n                    hash_map[last_num_needed].append([*current_ascending_window])\\n                    hash_map[last_num_needed].sort(key=len, reverse=True)\\n                    \\n                    current_ascending_window = hash_map[num].pop()\\n                    \\n                    # Delete redundant keys\\n                    if len(hash_map[num]) == 0:\\n                        del hash_map[num]\\n                    \\n                current_ascending_window.append(num)\\n                \\n            # If we are not directly ascending we need to store needed value in hashmap\\n            else:\\n                last_num_needed = last_num + 1\\n                hash_map[last_num_needed].append([*current_ascending_window])\\n                \\n                # We want the items to be from smallest to biggest\\n                if len(hash_map[last_num_needed]) > 1:\\n                    hash_map[last_num_needed].sort(key=len, reverse=True)\\n                \\n                \\n                # If we have a window we can continue building with current num\\n                if num in hash_map:\\n                    current_ascending_window = hash_map[num].pop()\\n                    \\n                    # Delete redundant keys\\n                    if len(hash_map[num]) == 0:\\n                        del hash_map[num]\\n                        \\n                    current_ascending_window.append(num)\\n                    \\n                else:\\n                    current_ascending_window = [num]\\n            \\n            last_num = num\\n                \\n        # if we left iteration with a window\\n        if current_ascending_window:\\n            hash_map[last_num + 1].append([*current_ascending_window])\\n            \\n        # print(hash_map)\\n            \\n        for subarrays_for_missing in hash_map.values():\\n            for subarray in subarrays_for_missing:\\n                if len(subarray) < 3: return False\\n                \\n        return True\\n                \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 704171,
                "title": "python-rust-hashmap",
                "content": "- **Python**\\n\\n```python\\nclass Solution:\\n    def isPossible(self, nums: List[int]) -> bool:\\n        count = { n: 0 for n in range(min(nums), max(nums)+2) }\\n        subseq = { n: 0 for n in range(min(nums)-1, max(nums)+1) }\\n        \\n        for n in nums: count[n] += 1\\n            \\n        for n in nums:\\n            if not count[n]: continue\\n            count[n] -= 1\\n            if subseq[n - 1]:\\n                subseq[n - 1] -= 1\\n                subseq[n] += 1\\n            elif count[n + 1] and count[n + 2]:\\n                count[n + 1] -= 1\\n                count[n + 2] -= 1\\n                subseq[n + 2] += 1\\n            else:\\n                return False\\n            \\n        return True\\n```\\n\\n- **Rust**\\n\\n```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn is_possible(nums: Vec<i32>) -> bool {\\n        let mut count: HashMap<i32, i32> = HashMap::new();\\n        let mut subseq: HashMap<i32, i32> = HashMap::new();\\n        \\n        let min = *nums.iter().min().unwrap();\\n        let max = *nums.iter().max().unwrap();\\n        \\n        for i in min..max+2 { count.insert(i, 0); }\\n        for i in min-1..max+1 { subseq.insert(i, 0); }\\n        \\n        for n in nums.iter() {\\n            let val = count.get(&n).unwrap();\\n            count.insert(*n, val + 1);\\n        }\\n        \\n        for n in nums.iter() {\\n            if *count.get(n).unwrap() == 0 { continue; }\\n            count.insert(*n, *count.get(n).unwrap() - 1);\\n            \\n            if *subseq.get(&(n - 1)).unwrap() > 0 {\\n                subseq.insert((n - 1), *subseq.get(&(n - 1)).unwrap() - 1);\\n                subseq.insert(*n, *subseq.get(&n).unwrap() + 1);\\n            } else if *count.get(&(n + 1)).unwrap() > 0 && *count.get(&(n + 2)).unwrap() > 0 {\\n                count.insert((n + 1), *count.get(&(n + 1)).unwrap() - 1);\\n                count.insert((n + 2), *count.get(&(n + 2)).unwrap() - 1);\\n                subseq.insert((n + 2), *subseq.get(&(n + 2)).unwrap() + 1);\\n            } else {\\n                return false;\\n            } \\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "Rust"
                ],
                "code": "```python\\nclass Solution:\\n    def isPossible(self, nums: List[int]) -> bool:\\n        count = { n: 0 for n in range(min(nums), max(nums)+2) }\\n        subseq = { n: 0 for n in range(min(nums)-1, max(nums)+1) }\\n        \\n        for n in nums: count[n] += 1\\n            \\n        for n in nums:\\n            if not count[n]: continue\\n            count[n] -= 1\\n            if subseq[n - 1]:\\n                subseq[n - 1] -= 1\\n                subseq[n] += 1\\n            elif count[n + 1] and count[n + 2]:\\n                count[n + 1] -= 1\\n                count[n + 2] -= 1\\n                subseq[n + 2] += 1\\n            else:\\n                return False\\n            \\n        return True\\n```\n```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn is_possible(nums: Vec<i32>) -> bool {\\n        let mut count: HashMap<i32, i32> = HashMap::new();\\n        let mut subseq: HashMap<i32, i32> = HashMap::new();\\n        \\n        let min = *nums.iter().min().unwrap();\\n        let max = *nums.iter().max().unwrap();\\n        \\n        for i in min..max+2 { count.insert(i, 0); }\\n        for i in min-1..max+1 { subseq.insert(i, 0); }\\n        \\n        for n in nums.iter() {\\n            let val = count.get(&n).unwrap();\\n            count.insert(*n, val + 1);\\n        }\\n        \\n        for n in nums.iter() {\\n            if *count.get(n).unwrap() == 0 { continue; }\\n            count.insert(*n, *count.get(n).unwrap() - 1);\\n            \\n            if *subseq.get(&(n - 1)).unwrap() > 0 {\\n                subseq.insert((n - 1), *subseq.get(&(n - 1)).unwrap() - 1);\\n                subseq.insert(*n, *subseq.get(&n).unwrap() + 1);\\n            } else if *count.get(&(n + 1)).unwrap() > 0 && *count.get(&(n + 2)).unwrap() > 0 {\\n                count.insert((n + 1), *count.get(&(n + 1)).unwrap() - 1);\\n                count.insert((n + 2), *count.get(&(n + 2)).unwrap() - 1);\\n                subseq.insert((n + 2), *subseq.get(&(n + 2)).unwrap() + 1);\\n            } else {\\n                return false;\\n            } \\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 646188,
                "title": "c-greedy-with-minheap-o-nlogn",
                "content": "The idea here is to try to greedily add elements to the shortest subsequence possible before creating a new subsequence. A hashmap is used to keep track of where each subsequence is currently ending, and for each subsequence ending at `i`, there is a minheap that keeps track of the shortest subsequence ending at `i`. \\n\\nIf we can greedily extend a subsequence for a particular number `j`, we do so by adding it to the shortest subsequence ending at `j - 1` and then update where that subsequence ends. Otherwise, we create a new subsequence that ends at `j`.\\n\\nThen, we go through all the heaps and check if any represent a subsequence with length of less than 3. If so, then it is not possible to satisfy the problem constraint, and so we immediately return false. Otherwise, we return true upon checking the lengths of all the subsequences.\\n\\nWe go through all the numbers in the input array and add them to or remove them from heaps, so the time complexity is O(nlogn). The use of a hashmap means O(n) storage is used.\\n\\n```\\n    bool isPossible(vector<int>& nums) {\\n        unordered_map<int, priority_queue<int, vector<int>, greater<int>>> sequences;\\n        for(int i = 0; i<nums.size(); i++){\\n            if(sequences[nums[i] - 1].size() > 0){\\n                // there\\'s a currently existing sequence to add to\\n                // pop from current heap and add to new heap\\n                int newLength = sequences[nums[i] - 1].top() + 1;\\n                sequences[nums[i] - 1].pop();\\n                sequences[nums[i]].push(newLength);\\n            }\\n            else{\\n                // create a new chain\\n                sequences[nums[i]].push(1);\\n            }\\n        }\\n        \\n        for(auto it = sequences.begin(); it != sequences.end(); it++){\\n            if(it->second.size() > 0 && it->second.top() < 3){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\n    bool isPossible(vector<int>& nums) {\\n        unordered_map<int, priority_queue<int, vector<int>, greater<int>>> sequences;\\n        for(int i = 0; i<nums.size(); i++){\\n            if(sequences[nums[i] - 1].size() > 0){\\n                // there\\'s a currently existing sequence to add to\\n                // pop from current heap and add to new heap\\n                int newLength = sequences[nums[i] - 1].top() + 1;\\n                sequences[nums[i] - 1].pop();\\n                sequences[nums[i]].push(newLength);\\n            }\\n            else{\\n                // create a new chain\\n                sequences[nums[i]].push(1);\\n            }\\n        }\\n        \\n        for(auto it = sequences.begin(); it != sequences.end(); it++){\\n            if(it->second.size() > 0 && it->second.top() < 3){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 630988,
                "title": "very-short-c-o-n-time-simple-greedy",
                "content": "Similar to 846. Hand of Straights, but instead used an unordered_map to count since the original array is sorted.\\nFor each number n, we increment it to get a `Consecutive Subsequences`. But when to stop?\\n1. If `count[n+1] > count[n]`, which means that there are more `n+1` than `n`, then we can add `n+1` to the array. It is because there is extra `n+1` and it makes no difference whether you put it with the current subsequences or a latter one (but there might not be latter valid subsequence).\\n2. Otherwise we stop here. An example might be `[1, 2, 2, 3, 3, 4]`, when `n == 3`, you would be better off stopping here instead of taking 4 because `(count[4] == 1) <= (2 == count[3])`\\n```c++\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        unordered_map<int, int> cnt;\\n        for (int i: nums) cnt[i] += 1;\\n\\n        int prev_cnt = 0, hi = 0;\\n        for (int lo: nums){\\n            if (!cnt[lo]) continue;\\n            prev_cnt = cnt[lo]--, hi=lo;\\n            while(++hi){\\n                if (cnt[hi] >= prev_cnt) prev_cnt = cnt[hi]--;\\n                else break;\\n            }\\n            if (hi - lo < 3) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        unordered_map<int, int> cnt;\\n        for (int i: nums) cnt[i] += 1;\\n\\n        int prev_cnt = 0, hi = 0;\\n        for (int lo: nums){\\n            if (!cnt[lo]) continue;\\n            prev_cnt = cnt[lo]--, hi=lo;\\n            while(++hi){\\n                if (cnt[hi] >= prev_cnt) prev_cnt = cnt[hi]--;\\n                else break;\\n            }\\n            if (hi - lo < 3) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 606840,
                "title": "java-greedy-solution-by-simulation-easy-to-understand-with-explanation",
                "content": "**For each word, keep going back through all the lists and see if you can add to one of them. If you can\\'t, only then create a new list and add to it.**\\n\\nThis isn\\'t the fastest solution, but hopefully it\\'s a fairly easy one to understand.\\n\\nKeep trying to add to the current list, and only go back if necessary.\\n\\nThen, at the end, check if you have any lists which have a size < 3.\\nThis check can probably be incorporated earlier, but I found it easier to reaason about by having another pass through the lists.\\n\\nAnd\\n```\\nclass Solution {\\n    public boolean isPossible(int[] nums) {\\n        List<List<Integer>> lists = new ArrayList<>();\\n        int completedList = 0;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            // For each word, keep going back all the lists and see if you can add. If you can\\'t, only then create one\\n            boolean found = false;\\n            int num = nums[i];\\n            int index = lists.size() - 1;\\n            while (index >= 0) {\\n                List<Integer> list = lists.get(index);\\n                if (list.get(list.size() - 1) == nums[i] - 1) {\\n                    found = true;\\n                    list.add(nums[i]);\\n                    break;\\n                } else if (list.get(list.size() -1)  < nums[i] - 1) {\\n                    if (list.size() < 3) {\\n                        return false;\\n                    }\\n                    break;\\n                }\\n                index--;\\n            }\\n            \\n            if (!found) {\\n                List<Integer> list = new ArrayList<>();\\n                list.add(nums[i]);\\n                lists.add(list);\\n            }\\n            \\n\\n        }\\n        \\n        for (int i = 0; i < lists.size(); i++) {\\n            if (lists.get(i).size() < 3) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossible(int[] nums) {\\n        List<List<Integer>> lists = new ArrayList<>();\\n        int completedList = 0;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            // For each word, keep going back all the lists and see if you can add. If you can\\'t, only then create one\\n            boolean found = false;\\n            int num = nums[i];\\n            int index = lists.size() - 1;\\n            while (index >= 0) {\\n                List<Integer> list = lists.get(index);\\n                if (list.get(list.size() - 1) == nums[i] - 1) {\\n                    found = true;\\n                    list.add(nums[i]);\\n                    break;\\n                } else if (list.get(list.size() -1)  < nums[i] - 1) {\\n                    if (list.size() < 3) {\\n                        return false;\\n                    }\\n                    break;\\n                }\\n                index--;\\n            }\\n            \\n            if (!found) {\\n                List<Integer> list = new ArrayList<>();\\n                list.add(nums[i]);\\n                lists.add(list);\\n            }\\n            \\n\\n        }\\n        \\n        for (int i = 0; i < lists.size(); i++) {\\n            if (lists.get(i).size() < 3) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 601263,
                "title": "updated-java-12ms-with-map-and-priorityqueue-easy-to-understand",
                "content": "[Updated on 05/17/2020] I just realized that we don\\'t need a <Integer, PriorityQueue> map. Instead, we just need two PriorityQueue to store the previous sequence ended at nums[i]-1 and current sequece ended at nums[i]. New code is attached below. \\n\\nThe basic idea is to look for a previous sequence to attach current element onto it. If there are multiple previous sequences, select the one with smallest length (hence we need the PriorityQueue).\\n\\nIf no applicable previous sequence exists, build a new sequence.\\n\\n```\\nclass Solution {\\n    //use two PriorityQueue: one for sequence ended at num-1\\n    //the other for sequence ended at num\\n    public boolean isPossible(int[] nums) {\\n        int n=nums.length;\\n        if(n<3) return false;\\n        \\n        PriorityQueue<Integer> prev=new PriorityQueue<Integer>();\\n        PriorityQueue<Integer> curr=new PriorityQueue<Integer>();\\n        for(int i=0;i<n;i++){\\n            if(prev.isEmpty()){\\n                curr.add(1);\\n            }\\n            else{\\n                curr.add(prev.poll()+1);\\n            }\\n            \\n            //prev sequence will not continue\\n            //need to check length\\n            if(i==n-1|| nums[i+1]!=nums[i]){\\n                if(!prev.isEmpty() && prev.peek()<3){\\n                    return false;\\n                } \\n                //clear since it will not continue\\n                prev.clear();\\n            }\\n            \\n            if(i==n-1 || nums[i+1]>nums[i]+1){\\n                //current sequence will not continue\\n                if(curr.peek()<3){\\n                    return false;\\n                } \\n                curr.clear();\\n            }\\n            else{\\n                //curr sequence will continue\\n                //need to become prev sequence if next element is different\\n                if(i<n-1 && nums[i+1]!=nums[i]){\\n                    while(!curr.isEmpty()){\\n                        prev.add(curr.poll());\\n                    } \\n                }       \\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n\\n\\nprevious version with Map----------------------------------------------------\\n```\\nclass Solution {\\n    public boolean isPossible(int[] nums) {\\n        int n=nums.length;\\n        if(n<3) return false;\\n\\n        //use map to record ending element - length pair\\n        HashMap<Integer,PriorityQueue<Integer>> map=new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            if(map.containsKey(nums[i]-1)){\\n                PriorityQueue<Integer> pq1=map.get(nums[i]-1);\\n                int len=pq1.poll();\\n                if(pq1.isEmpty()) map.remove(nums[i]-1);\\n                len++;\\n                PriorityQueue<Integer> pq2=map.getOrDefault(nums[i], new PriorityQueue<Integer>());\\n                pq2.add(len);\\n                map.put(nums[i],pq2);\\n            }\\n            else{\\n                //start a new sequence\\n                PriorityQueue<Integer> pq3= map.getOrDefault(nums[i],new PriorityQueue<Integer>());\\n                pq3.add(1);\\n                map.put(nums[i],pq3);\\n            }\\n            \\n            if(i<n-1 && nums[i+1]!=nums[i] ){\\n                 //the last sequence that has not been extended to nums[i] will not be continued. check length\\n                if(map.containsKey(nums[i]-1) && map.get(nums[i]-1).peek()<3){\\n                    return false;\\n                }\\n            }\\n            \\n            if(i==n-1 || nums[i+1]-nums[i]>1){\\n                //this sequence will not be continued. check length\\n                if(map.get(nums[i]).peek()<3) return false;\\n            }\\n \\n        }\\n\\n        return true;\\n    }\\n    \\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //use two PriorityQueue: one for sequence ended at num-1\\n    //the other for sequence ended at num\\n    public boolean isPossible(int[] nums) {\\n        int n=nums.length;\\n        if(n<3) return false;\\n        \\n        PriorityQueue<Integer> prev=new PriorityQueue<Integer>();\\n        PriorityQueue<Integer> curr=new PriorityQueue<Integer>();\\n        for(int i=0;i<n;i++){\\n            if(prev.isEmpty()){\\n                curr.add(1);\\n            }\\n            else{\\n                curr.add(prev.poll()+1);\\n            }\\n            \\n            //prev sequence will not continue\\n            //need to check length\\n            if(i==n-1|| nums[i+1]!=nums[i]){\\n                if(!prev.isEmpty() && prev.peek()<3){\\n                    return false;\\n                } \\n                //clear since it will not continue\\n                prev.clear();\\n            }\\n            \\n            if(i==n-1 || nums[i+1]>nums[i]+1){\\n                //current sequence will not continue\\n                if(curr.peek()<3){\\n                    return false;\\n                } \\n                curr.clear();\\n            }\\n            else{\\n                //curr sequence will continue\\n                //need to become prev sequence if next element is different\\n                if(i<n-1 && nums[i+1]!=nums[i]){\\n                    while(!curr.isEmpty()){\\n                        prev.add(curr.poll());\\n                    } \\n                }       \\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isPossible(int[] nums) {\\n        int n=nums.length;\\n        if(n<3) return false;\\n\\n        //use map to record ending element - length pair\\n        HashMap<Integer,PriorityQueue<Integer>> map=new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            if(map.containsKey(nums[i]-1)){\\n                PriorityQueue<Integer> pq1=map.get(nums[i]-1);\\n                int len=pq1.poll();\\n                if(pq1.isEmpty()) map.remove(nums[i]-1);\\n                len++;\\n                PriorityQueue<Integer> pq2=map.getOrDefault(nums[i], new PriorityQueue<Integer>());\\n                pq2.add(len);\\n                map.put(nums[i],pq2);\\n            }\\n            else{\\n                //start a new sequence\\n                PriorityQueue<Integer> pq3= map.getOrDefault(nums[i],new PriorityQueue<Integer>());\\n                pq3.add(1);\\n                map.put(nums[i],pq3);\\n            }\\n            \\n            if(i<n-1 && nums[i+1]!=nums[i] ){\\n                 //the last sequence that has not been extended to nums[i] will not be continued. check length\\n                if(map.containsKey(nums[i]-1) && map.get(nums[i]-1).peek()<3){\\n                    return false;\\n                }\\n            }\\n            \\n            if(i==n-1 || nums[i+1]-nums[i]>1){\\n                //this sequence will not be continued. check length\\n                if(map.get(nums[i]).peek()<3) return false;\\n            }\\n \\n        }\\n\\n        return true;\\n    }\\n    \\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 559446,
                "title": "short-and-straightforward-java-o-n-hashmap-solution",
                "content": "```\\n    public boolean isPossible(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num : nums) map.put(num, map.getOrDefault(num, 0) + 1);\\n        for (int num : nums) {\\n            if (map.get(num) == 0) continue;\\n            int count = 0;\\n            while (map.containsKey(num) && map.get(num) > 0) {\\n                count++;\\n                if (count > 3 && map.get(num) <= map.get(num - 1)) break;\\n                map.put(num, map.get(num) - 1);\\n                num++;\\n            }\\n            if (count < 3) return false;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean isPossible(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num : nums) map.put(num, map.getOrDefault(num, 0) + 1);\\n        for (int num : nums) {\\n            if (map.get(num) == 0) continue;\\n            int count = 0;\\n            while (map.containsKey(num) && map.get(num) > 0) {\\n                count++;\\n                if (count > 3 && map.get(num) <= map.get(num - 1)) break;\\n                map.put(num, map.get(num) - 1);\\n                num++;\\n            }\\n            if (count < 3) return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 545933,
                "title": "very-easy-and-simplistic-o-n-cpp-solution-using-two-hash-maps-with-detailed-explanation",
                "content": "```\\n/*  While iterating through the array, each element has 2 choices. Either get appended to existing subsequence or create its own subsequence.\\n    1) Append to existing subsequence: To get appended, we check if element i exists in HM with its value greater than 0. If true, we append to it. \\n    To append, we simply decrement HM[i] and its count in freq[i]. Next, create a spot for i+1 element that can be appended if it exists in array.\\n    \\n    2) Create own subsequence: To create a new subsequence with element i, then you need to have minimum of 3 elements that are consecutive, i.e., i, i+1 and i+2.\\n    If minimum of 3 subsequence exists, then decrement their corresponding freq[i] and create a spot in HM[i+3], where i+3 element can be appended to this list in future, if it exists in the array.\\n    \\n    3) If neither of above two conditions satisfy, then you cannot form a subsequence with minimum of 3 consecutive elements. Return false\\n    \\n    If 1) and 2) conditions passes, then return true at the end.\\n    \\n    Credit to this approach: https://www.youtube.com/watch?v=uJ8BAQ8lASE\\n*/\\n    \\n    bool isPossible(vector<int>& nums) {\\n        \\n        map<int, int> freq, HM; //HM means Hypothetical Map\\n        \\n        //Calculate freq of numbers\\n        for(int i : nums) freq[i]++;\\n        \\n        for(int i : nums)\\n        {\\n            if(freq[i] == 0) continue; //If count of element i is 0, then it is already used up in subsequence. Continue to next element.\\n            else if(HM[i] > 0)\\n            {\\n                HM[i]--;\\n                HM[i+1]++;\\n                freq[i]--;\\n            }\\n            //create a new subsequence\\n            else if(freq[i] > 0 && freq[i+1] > 0 && freq[i+2] > 0)\\n            {\\n                freq[i]--;\\n                freq[i+1]--;\\n                freq[i+2]--;\\n                \\n                HM[i+3]++;\\n            }\\n            else return false;\\n        }\\n        return true;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n/*  While iterating through the array, each element has 2 choices. Either get appended to existing subsequence or create its own subsequence.\\n    1) Append to existing subsequence: To get appended, we check if element i exists in HM with its value greater than 0. If true, we append to it. \\n    To append, we simply decrement HM[i] and its count in freq[i]. Next, create a spot for i+1 element that can be appended if it exists in array.\\n    \\n    2) Create own subsequence: To create a new subsequence with element i, then you need to have minimum of 3 elements that are consecutive, i.e., i, i+1 and i+2.\\n    If minimum of 3 subsequence exists, then decrement their corresponding freq[i] and create a spot in HM[i+3], where i+3 element can be appended to this list in future, if it exists in the array.\\n    \\n    3) If neither of above two conditions satisfy, then you cannot form a subsequence with minimum of 3 consecutive elements. Return false\\n    \\n    If 1) and 2) conditions passes, then return true at the end.\\n    \\n    Credit to this approach: https://www.youtube.com/watch?v=uJ8BAQ8lASE\\n*/\\n    \\n    bool isPossible(vector<int>& nums) {\\n        \\n        map<int, int> freq, HM; //HM means Hypothetical Map\\n        \\n        //Calculate freq of numbers\\n        for(int i : nums) freq[i]++;\\n        \\n        for(int i : nums)\\n        {\\n            if(freq[i] == 0) continue; //If count of element i is 0, then it is already used up in subsequence. Continue to next element.\\n            else if(HM[i] > 0)\\n            {\\n                HM[i]--;\\n                HM[i+1]++;\\n                freq[i]--;\\n            }\\n            //create a new subsequence\\n            else if(freq[i] > 0 && freq[i+1] > 0 && freq[i+2] > 0)\\n            {\\n                freq[i]--;\\n                freq[i+1]--;\\n                freq[i+2]--;\\n                \\n                HM[i+3]++;\\n            }\\n            else return false;\\n        }\\n        return true;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 544437,
                "title": "c-greedy-and-heap",
                "content": "### \\u53C2\\u8003\\nhttps://leetcode.com/problems/split-array-into-consecutive-subsequences/discuss/106516/Simple-C++-Greedy-O(nlogn)-Solution-(with-explanation) \\n\\nFor each num in nums, if there exists any sequence that ends with num-1 (i.e. if backs[num-1] is a non-empty priority queue), then find such a sequence with the smallest possible size (get the smallest value from the priority queue at backs[num-1]). Now, the sequence will be extended by 1 since we will add num to it. So pop the smallest value count from the priority queue at backs[num-1], and add a new value count+1 to the priority queue at backs[num].\\n\\nIf no sequence was found that ends in num-1 (i.e. backs[num-1] is empty), then create a new sequence. In other words, add 1 to the priority queue at backs[num].\\n\\n```C++\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        \\n        int lenLessThan3Count = 0;\\n        \\n        unordered_map< int, priority_queue<int, vector<int>, greater<int>>> record;\\n        \\n        for (auto num : nums) {\\n            \\n            if (!record[num-1].empty()) {\\n                \\n                int minCount = record[num-1].top();\\n                record[num-1].pop();\\n                record[num].push(++minCount);\\n                \\n                if (minCount == 3)\\n                    lenLessThan3Count--;\\n            }\\n            else{\\n                \\n                record[num].push(1);\\n                \\n                lenLessThan3Count++;\\n            }\\n        }\\n        \\n        return lenLessThan3Count == 0;\\n    }\\n};\\n```\\n\\n### [\\u53C2\\u8003](https://www.cnblogs.com/grandyang/p/7525821.html)\\n```C++\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        \\n        unordered_map<int, int> freq, need;\\n        \\n        for (const auto & n : nums)\\n        {\\n            freq[n]++;\\n        }\\n        \\n        for (const auto & num : nums)\\n        {\\n            if (freq[num] == 0) continue;\\n            \\n            if (need[num] > 0)\\n            {\\n                need[num]--;\\n                need[num+1]++;\\n            }\\n            else if (freq[num+1] > 0 && freq[num+2] > 0)\\n            {\\n                freq[num+1]--;\\n                freq[num+2]--;\\n                \\n                need[num+3]++;\\n            }\\n            else\\n                return false;\\n            \\n            freq[num]--;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        \\n        int lenLessThan3Count = 0;\\n        \\n        unordered_map< int, priority_queue<int, vector<int>, greater<int>>> record;\\n        \\n        for (auto num : nums) {\\n            \\n            if (!record[num-1].empty()) {\\n                \\n                int minCount = record[num-1].top();\\n                record[num-1].pop();\\n                record[num].push(++minCount);\\n                \\n                if (minCount == 3)\\n                    lenLessThan3Count--;\\n            }\\n            else{\\n                \\n                record[num].push(1);\\n                \\n                lenLessThan3Count++;\\n            }\\n        }\\n        \\n        return lenLessThan3Count == 0;\\n    }\\n};\\n```\n```C++\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        \\n        unordered_map<int, int> freq, need;\\n        \\n        for (const auto & n : nums)\\n        {\\n            freq[n]++;\\n        }\\n        \\n        for (const auto & num : nums)\\n        {\\n            if (freq[num] == 0) continue;\\n            \\n            if (need[num] > 0)\\n            {\\n                need[num]--;\\n                need[num+1]++;\\n            }\\n            else if (freq[num+1] > 0 && freq[num+2] > 0)\\n            {\\n                freq[num+1]--;\\n                freq[num+2]--;\\n                \\n                need[num+3]++;\\n            }\\n            else\\n                return false;\\n            \\n            freq[num]--;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 512093,
                "title": "c-multiset-stl-o-nlogn-easy-explanation",
                "content": "**Approach**\\n* Initialise a multiset of pairs where (p, q)  = (last_element, length)\\n* Let current element be x. Pick a pair from multiset such that p = x - 1 (so that you can add x to this sequence) and q => minimum length corresponding to such p. We can find it using **lower_bound** in multiset.\\n* Once found, erase that pair (x - 1, q) & insert (x, q + 1) since last element is now x & length of this sequence increases by 1.\\n* After all operations, iterate over the queue if not empty. If there exists a q < 3, then return false since there exists a sequence of length < 3. If no, return true.\\n\\n**Questions**\\nWhy mutliset?\\n* We need a data structure such that it is sorted by the last element of the sequence as well as the length of the sequence it belongs to. So lets create a pair<last_element, length>. Since we need it to be sorted by both, lets use multiset.\\n* How does this work?\\n\\t* Suppose my current element is x. I need to add this x in a sequence whose last element is x - 1. How do I find that sequence? And, if there are multiple such sequences, where do I insert the x? Simple - since we are using multiset, searching would be done in O(logn) using lower_bound. And in case of multiple such sequences, always choose one with the minimum length - since we need the size to be atleast 3. That\\'s why, we need to sort by length too so that in case of multiple (x - 1)s, we add x in the sequence of minimum length.\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        multiset<pair<int,int> > s; // initialize DS\\n        for(int i = 0; i < nums.size(); i++) {\\n            if(s.empty()) {\\n                s.insert(make_pair(nums[i], 1)); // add first element with length = 1\\n            }\\n            else {\\n               multiset<pair<int,int> >::iterator it = s.lower_bound(make_pair(nums[i] - 1, 0));\\n                if(it == s.end() || it->first != nums[i] - 1) { // if no sequence exists with last element as current element - 1, \\n                    s.insert(make_pair(nums[i], 1)); // create a new sequence with current element, length of sequence = 1\\n                }\\n                else {\\n                    int len = it->second; // find length of the sequence you want to insert it into\\n                    s.erase(it); // erase old sequence data\\n                    s.insert(make_pair(nums[i], len + 1)); // add the current element to this sequence & increase seq length by 1\\n                }\\n            }\\n        }\\n        for(multiset<pair<int,int> >::iterator it = s.begin(); it != s.end(); it++) {\\n            if(it->second < 3) return false; // if set has a sequence of length < 3, return false\\n        }\\n        return true; // possible\\n       \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        multiset<pair<int,int> > s; // initialize DS\\n        for(int i = 0; i < nums.size(); i++) {\\n            if(s.empty()) {\\n                s.insert(make_pair(nums[i], 1)); // add first element with length = 1\\n            }\\n            else {\\n               multiset<pair<int,int> >::iterator it = s.lower_bound(make_pair(nums[i] - 1, 0));\\n                if(it == s.end() || it->first != nums[i] - 1) { // if no sequence exists with last element as current element - 1, \\n                    s.insert(make_pair(nums[i], 1)); // create a new sequence with current element, length of sequence = 1\\n                }\\n                else {\\n                    int len = it->second; // find length of the sequence you want to insert it into\\n                    s.erase(it); // erase old sequence data\\n                    s.insert(make_pair(nums[i], len + 1)); // add the current element to this sequence & increase seq length by 1\\n                }\\n            }\\n        }\\n        for(multiset<pair<int,int> >::iterator it = s.begin(); it != s.end(); it++) {\\n            if(it->second < 3) return false; // if set has a sequence of length < 3, return false\\n        }\\n        return true; // possible\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 452962,
                "title": "java-o-n-simple-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public boolean isPossible(int[] nums) {\\n        if (nums == null || nums.length < 3) {\\n            return false;\\n        }\\n        HashMap<Integer, Integer> requirements = new HashMap<>();\\n        HashMap<Integer, Integer> counts = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            int num = nums[i];\\n            int pre = counts.getOrDefault(num-1, 0);\\n            int now = counts.getOrDefault(num, 0);\\n            if (pre <= now) { //starter\\n                requirements.put(num+1, requirements.getOrDefault(num+1, 0) + 1);\\n                requirements.put(num+2, requirements.getOrDefault(num+2, 0) + 1);\\n            }\\n            if (requirements.getOrDefault(num, 0) > 0) {\\n                requirements.put(num, requirements.get(num) - 1);\\n            }\\n            counts.put(num, counts.getOrDefault(num, 0) + 1);\\n        }\\n        for (int num: requirements.keySet())  {\\n            if (requirements.get(num) > 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isPossible(int[] nums) {\\n        if (nums == null || nums.length < 3) {\\n            return false;\\n        }\\n        HashMap<Integer, Integer> requirements = new HashMap<>();\\n        HashMap<Integer, Integer> counts = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            int num = nums[i];\\n            int pre = counts.getOrDefault(num-1, 0);\\n            int now = counts.getOrDefault(num, 0);\\n            if (pre <= now) { //starter\\n                requirements.put(num+1, requirements.getOrDefault(num+1, 0) + 1);\\n                requirements.put(num+2, requirements.getOrDefault(num+2, 0) + 1);\\n            }\\n            if (requirements.getOrDefault(num, 0) > 0) {\\n                requirements.put(num, requirements.get(num) - 1);\\n            }\\n            counts.put(num, counts.getOrDefault(num, 0) + 1);\\n        }\\n        for (int num: requirements.keySet())  {\\n            if (requirements.get(num) > 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 415527,
                "title": "java-frequency-map-hypothetical-map",
                "content": "The basic idea is to use greedy thinking. We will use two maps: one map stores frequency\\n of each number and the other map(we call it hypothetical map) that stores the potential\\n next number of a chain of already seen contiguous numbers.\\n We will iterate through the num array once. Each time we see a number, there will be 4\\n situations to consider:\\n  1. the frequency of this number is 0, we have used up this number, so skip it.\\n  2. the number exist in the hypothetical map, which means there\\'s already a chain of already\\n\\t seen contiguous numbers. Thus, we update that chain of numbers to include this number\\n\\t and also put the next potential number to the hypothetical map\\n  3. the number does not exist in hypothetical map, so we need to create a new chain of numbers\\n\\t which starts with size of 3, given the following two contiguous numbers exist in frequency map.\\n  4. if none of above situations is met, return false;\\n\\nThis video helps me understand the approach: https://www.youtube.com/watch?v=uJ8BAQ8lASE\\n```\\npublic boolean isPossible(int[] nums) {\\n\\tMap<Integer, Integer> fMap = new HashMap<>();\\n\\tMap<Integer, Integer> hMap = new HashMap<>();\\n\\tfor (int num : nums) {\\n\\t\\tfMap.put(num, fMap.getOrDefault(num ,0) + 1);\\n\\t}\\n\\tfor (int num : nums) {\\n\\t\\tif (fMap.getOrDefault(num, 0) == 0) continue;\\n\\t\\telse if (hMap.getOrDefault(num, 0) > 0) {\\n\\t\\t\\thMap.put(num, hMap.get(num) - 1);\\n\\t\\t\\thMap.put(num + 1, hMap.getOrDefault(num + 1, 0) + 1);\\n\\t\\t}\\n\\t\\telse if (fMap.getOrDefault(num + 1, 0) > 0 && fMap.getOrDefault(num + 2, 0) > 0) {\\n\\t\\t\\tfMap.put(num + 1, fMap.get(num + 1) - 1);\\n\\t\\t\\tfMap.put(num + 2, fMap.get(num + 2) - 1);\\n\\t\\t\\thMap.put(num + 3, hMap.getOrDefault(num + 3, 0) + 1);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tfMap.put(num, fMap.get(num) - 1);\\n\\t}\\n\\treturn true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isPossible(int[] nums) {\\n\\tMap<Integer, Integer> fMap = new HashMap<>();\\n\\tMap<Integer, Integer> hMap = new HashMap<>();\\n\\tfor (int num : nums) {\\n\\t\\tfMap.put(num, fMap.getOrDefault(num ,0) + 1);\\n\\t}\\n\\tfor (int num : nums) {\\n\\t\\tif (fMap.getOrDefault(num, 0) == 0) continue;\\n\\t\\telse if (hMap.getOrDefault(num, 0) > 0) {\\n\\t\\t\\thMap.put(num, hMap.get(num) - 1);\\n\\t\\t\\thMap.put(num + 1, hMap.getOrDefault(num + 1, 0) + 1);\\n\\t\\t}\\n\\t\\telse if (fMap.getOrDefault(num + 1, 0) > 0 && fMap.getOrDefault(num + 2, 0) > 0) {\\n\\t\\t\\tfMap.put(num + 1, fMap.get(num + 1) - 1);\\n\\t\\t\\tfMap.put(num + 2, fMap.get(num + 2) - 1);\\n\\t\\t\\thMap.put(num + 3, hMap.getOrDefault(num + 3, 0) + 1);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tfMap.put(num, fMap.get(num) - 1);\\n\\t}\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 334733,
                "title": "all-in-one-java-solution-map-pq-two-maps-with-explanation-examples-and-comments",
                "content": "### 1. Map + PriorityQueue\\n\\nReference:\\n\\n- [LeetCode 659. Split Array into Consecutive Subsequences \\u89E3\\u9898\\u62A5\\u544A\\uFF08Python\\uFF09](https://blog.csdn.net/fuxuemingzhu/article/details/82185011)\\n- [LeetCode[659]Split Array into Consecutive Subsequences(Java)](https://blog.csdn.net/sunday0904/article/details/78174122)\\n- [Java O(n) time & O(1) space solution -- greedily extending shorter subsequence](https://leetcode.com/problems/split-array-into-consecutive-subsequences/discuss/106513/)\\n\\nWe use a `HashMap<Integer, PriorityQueue<Integer>>` to store the information we need to process the list. For current number `val`, we compare its value to its predecessor to see if their difference is $1$. \\n\\nBy `map.get(val)`, we have a priority queue, which stores all available lengths of sequence ending with value `val`. The reason why we use a priority queue is that when we encounter a new value `val`, we want to append it to the shortest sequence that needs most \"help\". We want all sequences we have to satisfy the requirement `>= k`. For example, `[1, 2, 3]` and `[2, 3]`: The next value is `4`, we will add it to `[2, 3]` and it becomes `[2, 3, 4]` rather than adding it to `[1, 2, 3]`. This is the idea of greedy algorithm, since we always go for the shortest length of sequence at each step.\\n\\nAlgorithm:\\n\\n- For each current value `val`:\\n  - If `val - 1` exists in the map, we get the priority queue by `map.get(val - 1)` and poll the shortest sequence\\'s length and offer it into the priority queue in `map.get(val)`.\\n  - If `val - 1` does not exists in the map, or its priority queue is empty, we start over from this element and offer `1` into the `val`\\'s priority queue.\\n- Finally, we iterate the map\\'s values, and poll each sequence\\'s length by `pq.poll()` and check if all of then satisfy the requirement.\\n\\n\\nFor example, we have a sequence `[1, 2, 3, 3, 4, 4, 5, 5]`:\\n\\n```java\\nval   map                                             case\\n1     <1, [1]>                                        not exist\\n2     <2, [2]>, <1, []>                               exist\\n3     <3, [3]>, <2, []>, <1, []>                      exist\\n3     <3, [3, 1]>, <2, []>, <1, []>                   exist but no more length\\n4     <4, [2]>, <3, [3]>, <2, []>, <1, []>            exist\\n4     <4, [2, 4]>, <3, []>, <2, []>, <1, []>          exist\\n5     <5, [3]>, <4, [4]>, <3, []>, <2, []>, <1, []>   exist (remember! shortest length)\\n5     <5, [3, 5]>, <4, []>, <3, []>, <2, []>, <1, []> exist\\n```\\n\\nCode with comments:\\n\\n```java\\npublic boolean isPossible(int[] nums) {\\n  // Build map <num, minPQ of length>\\n  Map<Integer, PriorityQueue<Integer>> map = new HashMap<>();\\n  \\n  for (int val : nums) {\\n    if (map.containsKey(val - 1) && map.get(val - 1).size() > 0) { // minPQ size > 0\\n      // (num - 1) sequence exists\\n      PriorityQueue<Integer> pq = map.get(val - 1);\\n      int len = pq.poll();\\n      if (map.get(val) == null) {\\n        map.put(val, new PriorityQueue<>());\\n      }\\n      map.get(val).add(len + 1);\\n    } else {\\n      // (num - 1) sequence does not exist\\n      if (map.get(val) == null) {\\n        map.put(val, new PriorityQueue<>());\\n      }\\n      map.get(val).add(1);\\n    }\\n  }\\n  \\n  // Check each non-empty priority queue\\n  for (PriorityQueue<Integer> pq : map.values()) {\\n    while (pq.size() > 0) {\\n      if (pq.poll() < 3) {\\n        return false;\\n      }\\n    }\\n  }\\n  \\n  return true;\\n}\\n```\\n\\n**Time:** $O(N\\\\log{N})$\\n**Space:** $O(N)$\\n\\n\\n\\n### 2. Two Maps\\n\\nReference: [Java O(n) Time O(n) Space](https://leetcode.com/problems/split-array-into-consecutive-subsequences/discuss/106496/)\\n\\nThanks `marcohwlam` for the example that many post writers don\\'t even add to their posts. Not mention the code without comments. Drives me crazy!\\n\\n**Note:** I still don\\'t know why it works though, but at least I now know how it works.\\n\\nThis time, we have two hash maps: `freqMap` and `subMap`.\\n\\n- `freqMap`: Count the frequency of all numbers.\\n- `subMap`: Store qualified (`>= 3`) subsequences. It is not obvious though.\\n  - For example, `<4, 1>` means we have already `one` qualified subsequence (e.g. `[1, 2, 3]`) and it will continue from `4`. Then later when we encounter a value `4`, we can append `4` to the current subsequence and update the map to `<4, 0>, <5, 1>`.\\n\\nAlgorithm:\\n\\n- Iterate through the array to get the frequency of all the elements.\\n- Iterate through the array once more to see:\\n  - `Case 1`: If `val`\\'s frequency is used up? Yes => `continue;` to the next `val`.\\n  - `Case 2`: If each element can be appended to a previously constructed consecutive subsequence.\\n  - `Case 3`: If it can be the start of a new consecutive sequence.\\n  - `Case 4`: Returns `false`.\\n  - Remember to decrement the frequency of `val` in `freqMap` at each time.\\n\\nFor example, we have a sequence `[1, 2, 3, 3, 4, 4, 5, 5]`:\\n\\n```java\\nInit: freqMap = <1, 1>, <2, 1>, <3, 2>, <4, 2>, <5, 2>\\nval   case     subMap                   freqMap\\n1     3        <4, 1>                   <1, 0>, <2, 0>, <3, 1>, <4, 2>, <5, 2>\\n2     1        continue;\\n3     3        <4, 1>, <6, 1>           <1, 0>, <2, 0>, <3, 0>, <4, 1>, <5, 1>\\n3     1        continue;\\n4     2        <4, 0>, <5, 1>, <6, 1>   <1, 0>, <2, 0>, <3, 0>, <4, 0>, <5, 1>\\n4     1        continue;\\n5     3        <4, 0>, <5, 0>, <6, 2>   <1, 0>, <2, 0>, <3, 0>, <4, 0>, <5, 0>\\n5     1        continue;\\nreturn true;\\n```\\n\\nCode with comments:\\n\\n\\n```java\\npublic boolean isPossible(int[] nums) {\\n  Map<Integer, Integer> freqMap = new HashMap<>();\\n  Map<Integer, Integer> subMap = new HashMap<>();\\n\\n  // Count the frequency\\n  for (int val : nums) {\\n    freqMap.put(val, freqMap.getOrDefault(val, 0) + 1);\\n  }\\n\\n  // Scan the nums\\n  for (int val : nums) {\\n    // Case 1 - \"No available frequency\"\\n    if (freqMap.get(val) == 0) { // No more frequencies. It has been used up.\\n      continue;\\n    }\\n    // Case 2 - \"If val is where a subsequence in subMap could continue from\"\\n    else if (subMap.getOrDefault(val, 0) > 0) {\\n      subMap.put(val, subMap.get(val) - 1); // use this subsequence from this val\\n      subMap.put(val + 1, subMap.getOrDefault(val + 1, 0) + 1); // append val + 1, update the subsequence continuing from val + 1.\\n    }\\n    // Case 3 - \"Start of a new subsequence, 3 consecutive numbers\"\\n    else if (freqMap.getOrDefault(val + 1, 0) > 0 && freqMap.getOrDefault(val + 2, 0) > 0) { // Check if we still have frequencies\\n      freqMap.put(val + 1, freqMap.get(val + 1) - 1); // use: val + 1\\n      freqMap.put(val + 2, freqMap.get(val + 2) - 1); // use: val + 2\\n      subMap.put(val + 3, subMap.getOrDefault(val + 3, 0) + 1); // We have one more subsequence continuing from val + 3\\n    }\\n    // Case 4\\n    else {\\n      return false;\\n    }\\n    freqMap.put(val, freqMap.get(val) - 1); // frequency of val--\\n  }\\n  return true;\\n}\\n```\\n\\n\\n**Time:** $O(N)$\\n**Space:** $O(N)$\\n\\n\\n\\n\\n### 3. Extra (No Explanation)\\n\\n$O(1)$ space: \\n\\n[Java O(n) time & O(1) space solution -- greedily extending shorter subsequence](https://leetcode.com/problems/split-array-into-consecutive-subsequences/discuss/106495/)\\n\\nThe original code:\\n\\n```java\\npublic boolean isPossible(int[] nums) {\\n  int pre = Integer.MIN_VALUE, p1 = 0, p2 = 0, p3 = 0;\\n  int cur = 0, cnt = 0, c1 = 0, c2 = 0, c3 = 0;\\n      \\n  for (int i = 0; i < nums.length; pre = cur, p1 = c1, p2 = c2, p3 = c3) {\\n      for (cur = nums[i], cnt = 0; i < nums.length && cur == nums[i]; cnt++, i++);\\n          \\n      if (cur != pre + 1) {\\n          if (p1 != 0 || p2 != 0) return false;\\n          c1 = cnt; c2 = 0; c3 = 0;\\n          \\n      } else {\\n          if (cnt < p1 + p2) return false;\\n          c1 = Math.max(0, cnt - (p1 + p2 + p3));\\n          c2 = p1;\\n          c3 = p2 + Math.min(p3, cnt - (p1 + p2));\\n      }\\n  }\\n  \\n  return (p1 == 0 && p2 == 0);\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```java\\nval   map                                             case\\n1     <1, [1]>                                        not exist\\n2     <2, [2]>, <1, []>                               exist\\n3     <3, [3]>, <2, []>, <1, []>                      exist\\n3     <3, [3, 1]>, <2, []>, <1, []>                   exist but no more length\\n4     <4, [2]>, <3, [3]>, <2, []>, <1, []>            exist\\n4     <4, [2, 4]>, <3, []>, <2, []>, <1, []>          exist\\n5     <5, [3]>, <4, [4]>, <3, []>, <2, []>, <1, []>   exist (remember! shortest length)\\n5     <5, [3, 5]>, <4, []>, <3, []>, <2, []>, <1, []> exist\\n```\n```java\\npublic boolean isPossible(int[] nums) {\\n  // Build map <num, minPQ of length>\\n  Map<Integer, PriorityQueue<Integer>> map = new HashMap<>();\\n  \\n  for (int val : nums) {\\n    if (map.containsKey(val - 1) && map.get(val - 1).size() > 0) { // minPQ size > 0\\n      // (num - 1) sequence exists\\n      PriorityQueue<Integer> pq = map.get(val - 1);\\n      int len = pq.poll();\\n      if (map.get(val) == null) {\\n        map.put(val, new PriorityQueue<>());\\n      }\\n      map.get(val).add(len + 1);\\n    } else {\\n      // (num - 1) sequence does not exist\\n      if (map.get(val) == null) {\\n        map.put(val, new PriorityQueue<>());\\n      }\\n      map.get(val).add(1);\\n    }\\n  }\\n  \\n  // Check each non-empty priority queue\\n  for (PriorityQueue<Integer> pq : map.values()) {\\n    while (pq.size() > 0) {\\n      if (pq.poll() < 3) {\\n        return false;\\n      }\\n    }\\n  }\\n  \\n  return true;\\n}\\n```\n```java\\nInit: freqMap = <1, 1>, <2, 1>, <3, 2>, <4, 2>, <5, 2>\\nval   case     subMap                   freqMap\\n1     3        <4, 1>                   <1, 0>, <2, 0>, <3, 1>, <4, 2>, <5, 2>\\n2     1        continue;\\n3     3        <4, 1>, <6, 1>           <1, 0>, <2, 0>, <3, 0>, <4, 1>, <5, 1>\\n3     1        continue;\\n4     2        <4, 0>, <5, 1>, <6, 1>   <1, 0>, <2, 0>, <3, 0>, <4, 0>, <5, 1>\\n4     1        continue;\\n5     3        <4, 0>, <5, 0>, <6, 2>   <1, 0>, <2, 0>, <3, 0>, <4, 0>, <5, 0>\\n5     1        continue;\\nreturn true;\\n```\n```java\\npublic boolean isPossible(int[] nums) {\\n  Map<Integer, Integer> freqMap = new HashMap<>();\\n  Map<Integer, Integer> subMap = new HashMap<>();\\n\\n  // Count the frequency\\n  for (int val : nums) {\\n    freqMap.put(val, freqMap.getOrDefault(val, 0) + 1);\\n  }\\n\\n  // Scan the nums\\n  for (int val : nums) {\\n    // Case 1 - \"No available frequency\"\\n    if (freqMap.get(val) == 0) { // No more frequencies. It has been used up.\\n      continue;\\n    }\\n    // Case 2 - \"If val is where a subsequence in subMap could continue from\"\\n    else if (subMap.getOrDefault(val, 0) > 0) {\\n      subMap.put(val, subMap.get(val) - 1); // use this subsequence from this val\\n      subMap.put(val + 1, subMap.getOrDefault(val + 1, 0) + 1); // append val + 1, update the subsequence continuing from val + 1.\\n    }\\n    // Case 3 - \"Start of a new subsequence, 3 consecutive numbers\"\\n    else if (freqMap.getOrDefault(val + 1, 0) > 0 && freqMap.getOrDefault(val + 2, 0) > 0) { // Check if we still have frequencies\\n      freqMap.put(val + 1, freqMap.get(val + 1) - 1); // use: val + 1\\n      freqMap.put(val + 2, freqMap.get(val + 2) - 1); // use: val + 2\\n      subMap.put(val + 3, subMap.getOrDefault(val + 3, 0) + 1); // We have one more subsequence continuing from val + 3\\n    }\\n    // Case 4\\n    else {\\n      return false;\\n    }\\n    freqMap.put(val, freqMap.get(val) - 1); // frequency of val--\\n  }\\n  return true;\\n}\\n```\n```java\\npublic boolean isPossible(int[] nums) {\\n  int pre = Integer.MIN_VALUE, p1 = 0, p2 = 0, p3 = 0;\\n  int cur = 0, cnt = 0, c1 = 0, c2 = 0, c3 = 0;\\n      \\n  for (int i = 0; i < nums.length; pre = cur, p1 = c1, p2 = c2, p3 = c3) {\\n      for (cur = nums[i], cnt = 0; i < nums.length && cur == nums[i]; cnt++, i++);\\n          \\n      if (cur != pre + 1) {\\n          if (p1 != 0 || p2 != 0) return false;\\n          c1 = cnt; c2 = 0; c3 = 0;\\n          \\n      } else {\\n          if (cnt < p1 + p2) return false;\\n          c1 = Math.max(0, cnt - (p1 + p2 + p3));\\n          c2 = p1;\\n          c3 = p2 + Math.min(p3, cnt - (p1 + p2));\\n      }\\n  }\\n  \\n  return (p1 == 0 && p2 == 0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 305592,
                "title": "c-o-n-time-o-d-space-easy-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        int len = nums.size();\\n        if (len == 0) return false;\\n        int start = nums[0];\\n        int end = nums[len - 1];\\n        vector<int> counts(end - start + 1);\\n        for(int num : nums) {\\n            counts[num - start]++;\\n        }\\n        int i = 0;\\n        while (i < counts.size()) {\\n            if (counts[i] == 0) {\\n                i++;\\n                continue;\\n            }\\n            counts[i]--;\\n            int j = i + 1;\\n            while(j < counts.size()) {\\n                if (counts[j] > counts[j - 1]) {\\n                    counts[j]--;\\n                    j++;\\n                } else {\\n                    break;\\n                }\\n            }\\n                        \\n            if (j - i <= 2) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        int len = nums.size();\\n        if (len == 0) return false;\\n        int start = nums[0];\\n        int end = nums[len - 1];\\n        vector<int> counts(end - start + 1);\\n        for(int num : nums) {\\n            counts[num - start]++;\\n        }\\n        int i = 0;\\n        while (i < counts.size()) {\\n            if (counts[i] == 0) {\\n                i++;\\n                continue;\\n            }\\n            counts[i]--;\\n            int j = i + 1;\\n            while(j < counts.size()) {\\n                if (counts[j] > counts[j - 1]) {\\n                    counts[j]--;\\n                    j++;\\n                } else {\\n                    break;\\n                }\\n            }\\n                        \\n            if (j - i <= 2) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283308,
                "title": "python-easy-solution",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def isPossible(self, nums: List[int]) -> bool:\\n        c = Counter(nums)\\n        for x in nums:\\n            while c[x] > 0:\\n                c[x] -= 1\\n                y = x + 1\\n                while c[y] > 0:\\n                    c[y] -= 1\\n                    if c[y] >= c[y+1]:\\n                        break\\n                    y += 1\\n                if y - x + 1 < 3: return False\\n        return True\\n",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def isPossible(self, nums: List[int]) -> bool:\\n        c = Counter(nums)\\n        for x in nums:\\n            while c[x] > 0:\\n                c[x] -= 1\\n                y = x + 1\\n                while c[y] > 0:\\n                    c[y] -= 1\\n                    if c[y] >= c[y+1]:\\n                        break\\n                    y += 1\\n                if y - x + 1 < 3: return False\\n        return True\\n",
                "codeTag": "Java"
            },
            {
                "id": 198873,
                "title": "java-o-n-solution-with-count-and-two-pointers-beat-92",
                "content": "we first transfer all elements to start from 1, eg. [2,3,4,5] -> [1,2,3,4], in order to make the counting easier.\\nTraverse the frequency count array from start, with a valid start point, go forward to look for the end of this subsequence until frequency of current element is more than its next element.\\n\\nthis method is based on the idea that if count(i+1) >= count(i) we must include i+1 in current subsequence, else i+1 cannot be added into this subsequence.\\n\\n```\\nclass Solution {\\n    public boolean isPossible(int[] nums) {\\n        int first = nums[0], len = nums[nums.length-1] - first +1;\\n        int[] count = new int[len+1];\\n        for(int num:nums) count[num-first+1]++; //count frequency\\n\\t\\t\\n\\t\\t//traverse the count array\\n        int start = 1, end =1;\\n        while(end<=len){ \\n            while(end<len && count[end]<=count[end+1]) end++;\\n            if(end-start<2) return false;\\n\\t\\t\\t\\n\\t\\t\\t//update the frequency of elements in this subsequence\\n            for(int i=start; i<=end;i++){\\n                count[i] = count[i]-1;\\n                if(count[i]==0) start = i+1;\\n            }\\n            while(end<=len && count[end]==0){\\n                end++;\\n                start=end;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isPossible(int[] nums) {\\n        int first = nums[0], len = nums[nums.length-1] - first +1;\\n        int[] count = new int[len+1];\\n        for(int num:nums) count[num-first+1]++; //count frequency\\n\\t\\t\\n\\t\\t//traverse the count array\\n        int start = 1, end =1;\\n        while(end<=len){ \\n            while(end<len && count[end]<=count[end+1]) end++;\\n            if(end-start<2) return false;\\n\\t\\t\\t\\n\\t\\t\\t//update the frequency of elements in this subsequence\\n            for(int i=start; i<=end;i++){\\n                count[i] = count[i]-1;\\n                if(count[i]==0) start = i+1;\\n            }\\n            while(end<=len && count[end]==0){\\n                end++;\\n                start=end;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 195569,
                "title": "python3-o-n-time-o-1-space",
                "content": "Since **nums** is already sorted in ascending order, for any `i` from `1` to `len(nums)-1`, there will be only three situations.\\n\\n***1***.  `nums[i-1]==nums[i]`\\n***2***.  `nums[i-1]+1==nums[i]`\\n***3***.  `nums[i-1]+1<nums[i]`\\n\\nHere I use an array `sub` to manage subsequences. For subsequences from `sub[0]` to `sub[-1]`, if ***1***, look for next subsequence. If ***2***, then add it into the subsequences. If ***3***, since **nums** is sorted in ascending order, which means there will be no more element can be added to it, so we can just delete it when its length is larger than or equal to 3 or return False when its length is smaller than 3.\\nIf `nums[i]` can not be added into any of them, then insert a subsequence `[nums[i]]`(Note that in the code `nums[i]` simply typed as `i`) at the head of `sub`.\\n\\nFinally, simply check lengths of all subsequence in `sub` and return result.\\n\\n\\n```\\nclass Solution:\\n    def isPossible(self, nums):\\n        sub=[[nums[0]]]\\n        for i in nums[1:]:\\n            j=0\\n            while j < len(sub):\\n                if sub[j][0]==i:\\n                    j+=1\\n                elif sub[j][0]+1==i:\\n                    sub[j].insert(0,i)\\n                    break\\n                else:\\n                    if len(sub[j])<3:\\n                        return False\\n                    else:\\n                        sub.pop(j)\\n            else:\\n                sub.insert(0,[i])\\n\\t\\t\\t\\t\\n        for k in sub:\\n            if len(k)<3:\\n                return False\\n        else:\\n            return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isPossible(self, nums):\\n        sub=[[nums[0]]]\\n        for i in nums[1:]:\\n            j=0\\n            while j < len(sub):\\n                if sub[j][0]==i:\\n                    j+=1\\n                elif sub[j][0]+1==i:\\n                    sub[j].insert(0,i)\\n                    break\\n                else:\\n                    if len(sub[j])<3:\\n                        return False\\n                    else:\\n                        sub.pop(j)\\n            else:\\n                sub.insert(0,[i])\\n\\t\\t\\t\\t\\n        for k in sub:\\n            if len(k)<3:\\n                return False\\n        else:\\n            return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 188439,
                "title": "c-improve-priorityqueue-based-greedy-solution-to-o-n-time-100",
                "content": "```\\ndeque<pair<int, int>> dq;  // <tail, len>\\nfor (int num : nums) {\\n    // Step 1: pop out of range subsequences\\n    while (!dq.empty() && dq.front().first + 1 < num) {\\n        if (dq.front().second < 3) {\\n            return false;\\n        } else {\\n            dq.pop_front();\\n        }                \\n    }\\n    // Step 2: dq guarantee increasing <tail, len> \\n    if (!dq.empty() && dq.front().first + 1 == num) {\\n        auto top = dq.front();\\n        dq.pop_front();\\n        dq.push_back(make_pair(num, top.second + 1));\\n    } else {  // dp.front().first >= num in this case\\n        dq.push_front(make_pair(num, 1));\\n    }\\n}\\nwhile (!dq.empty()) {\\n    if (dq.front().second < 3) {\\n        return false;\\n    } else {\\n        dq.pop_front();\\n    }            \\n}\\nreturn true;  \\n```\\nIf you replace the above ```deque``` to ```priority_queue```, you get the priority queue based solution, which is quite easy to understand. This improved solution just use deque instead to maintain the order by ourselves. ",
                "solutionTags": [],
                "code": "```\\ndeque<pair<int, int>> dq;  // <tail, len>\\nfor (int num : nums) {\\n    // Step 1: pop out of range subsequences\\n    while (!dq.empty() && dq.front().first + 1 < num) {\\n        if (dq.front().second < 3) {\\n            return false;\\n        } else {\\n            dq.pop_front();\\n        }                \\n    }\\n    // Step 2: dq guarantee increasing <tail, len> \\n    if (!dq.empty() && dq.front().first + 1 == num) {\\n        auto top = dq.front();\\n        dq.pop_front();\\n        dq.push_back(make_pair(num, top.second + 1));\\n    } else {  // dp.front().first >= num in this case\\n        dq.push_front(make_pair(num, 1));\\n    }\\n}\\nwhile (!dq.empty()) {\\n    if (dq.front().second < 3) {\\n        return false;\\n    } else {\\n        dq.pop_front();\\n    }            \\n}\\nreturn true;  \\n```\n```deque```\n```priority_queue```",
                "codeTag": "Unknown"
            },
            {
                "id": 183821,
                "title": "one-pass-c-solution-o-1-space-beats-98-with-detailed-explanation",
                "content": "The idea is, first count repeat items of current number, then check 1) if current number has enough items to patch all incomplate items, 2) if there are more items left after patching all sequences, ther remainder become new single item sequences.\\nEdge case, when we met a inconsequetive number, we deem all sequences end here, hence if there are any incomplete sequences, the validation fails.\\nAnd in the end, we need check again if there are any incomplete sequences.\\n```\\n    bool isPossible(vector<int>& nums) {\\n        size_t len = nums.size();\\n        if(len < 3) return false;\\n        // seq1 is the count of sequences with a single number\\n        // seq2 is the count of sequences with 2 numbers \\n        // seq is the count of sequences has 3 or more numbers\\n        // count is the count of current number\\n        // prevNum is the previous number\\n        int seq1 = 0, seq2 = 0, seq = 0, count = 0, prevNum = nums[0];\\n        for(size_t i = 0; i < len; i++){\\n            count = 1;\\n            // Count current number.\\n            // When the loop ends, the pointer stays in the last item of current number and the count is the total count of current number\\n            while(i < len - 1 && nums[i] == nums[i+1]){ \\n                    count++; i++;\\n            }\\n            \\n            if(prevNum < nums[i] - 1){\\n                // If there is a gap, all sequences should start over, if there are incomplete sequences, the assert fails.\\n                if(seq1 + seq2 > 0) return false;\\n                seq = 0;\\n            }else{\\n                int all_seq = seq1 + seq2 + seq;\\n                // If current number has enough items, they can lengthen all sequences\\n                // And after that the remaining items of current number become single number sequences\\n                if(count > all_seq){\\n                    seq += seq2;\\n                    seq2 = seq1;\\n                    seq1 = count - all_seq;\\n                }else if(count >= seq1 + seq2){ // Current number has enough items to lengthen all incomplete sequences (length == 1 or 2)                    \\n                    seq = count - seq1;\\n                    seq2 = seq1;\\n                    seq1 = 0;\\n                }else \\n                    return false; // Current number doesn\\'t have enough items to lengthen all incomplete sequences, game over.\\n            }\\n\\n            prevNum = nums[i];\\n        }\\n        \\n        return seq1 + seq2 == 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool isPossible(vector<int>& nums) {\\n        size_t len = nums.size();\\n        if(len < 3) return false;\\n        // seq1 is the count of sequences with a single number\\n        // seq2 is the count of sequences with 2 numbers \\n        // seq is the count of sequences has 3 or more numbers\\n        // count is the count of current number\\n        // prevNum is the previous number\\n        int seq1 = 0, seq2 = 0, seq = 0, count = 0, prevNum = nums[0];\\n        for(size_t i = 0; i < len; i++){\\n            count = 1;\\n            // Count current number.\\n            // When the loop ends, the pointer stays in the last item of current number and the count is the total count of current number\\n            while(i < len - 1 && nums[i] == nums[i+1]){ \\n                    count++; i++;\\n            }\\n            \\n            if(prevNum < nums[i] - 1){\\n                // If there is a gap, all sequences should start over, if there are incomplete sequences, the assert fails.\\n                if(seq1 + seq2 > 0) return false;\\n                seq = 0;\\n            }else{\\n                int all_seq = seq1 + seq2 + seq;\\n                // If current number has enough items, they can lengthen all sequences\\n                // And after that the remaining items of current number become single number sequences\\n                if(count > all_seq){\\n                    seq += seq2;\\n                    seq2 = seq1;\\n                    seq1 = count - all_seq;\\n                }else if(count >= seq1 + seq2){ // Current number has enough items to lengthen all incomplete sequences (length == 1 or 2)                    \\n                    seq = count - seq1;\\n                    seq2 = seq1;\\n                    seq1 = 0;\\n                }else \\n                    return false; // Current number doesn\\'t have enough items to lengthen all incomplete sequences, game over.\\n            }\\n\\n            prevNum = nums[i];\\n        }\\n        \\n        return seq1 + seq2 == 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 127249,
                "title": "confusing-problem-description-maybe-this-will-help-clarify-what-confused-me",
                "content": "This problem description confused me as well. I thought it meant \"Make sure you can form at least 2 subsequences with consecutive integers and at least a length of 3\".\\n\\nSeems like the problem really means:\\n\\nGiven a sorted array of integers, which may contain duplicates, check if every element in the array can belong to a [subsequence](https://en.wikipedia.org/wiki/Subsequence) of consecutive integers having a length of at least 3. A subsequence is a sequence formed by deleting some or none of the elements in a larger sequence. If the elements can be arranged into 1 or more subsequences meeting these criteria, return true. If some elements do not belong to such a subsequence, return false.\\n\\n**Example 1:**\\n```\\nInput: [1,2,3,3,4,5]\\nOutput: True\\n```\\n*Explanation:*\\nThis array can be split into two subsequences, each of which meet the criteria of having at least 3 elements, all consecutive integers.\\nThe first subsequence, `1,2,3`, has 3 elements, all consecutive.\\nThe second subsequence, `3,4,5`, has 3 elements, all consecutive.\\nNo integers in the array are unaccounted for.\\n\\n**Example 2:**\\n```\\nInput: [1,2,3,3,4,4,5,5]\\nOutput: True\\n```\\n*Explanation:*\\nWe can split this array into two subsequences of consecutive integers, each with a length greater than 3.\\nThe first subsequence, `1,2,3,4,5`, has all consecutive integers, and has a length of 5.\\nThe remaining integers, `3,4,5`, form a consecutive subsequence with length 3.\\nNo integers in the array are unaccounted for.\\n\\n**Example 3:**\\n```\\nInput: [1,2,3,4,4,5]\\nOutput: False\\n```\\n*Explanation:*\\nWe could try to split this array into subsequences a few ways, but none of them result in subsequences that match the criteria.\\n\\nIf we did `1,2,3` as our first subsequence, we are left with elements `4,4,5`, which are not consecutive.\\nWe could try `1,2,3,4` and `4,5`, which are both consecutive subsequences, but `4,5` is not long enough (must have at least 3 elements).\\nWe could also try `1,2,3,4,5`, but that leaves `4` unaccounted for, which again is not long enough.\\nThus, the integers in this array can not be arranged into subsequences which meet the criteria of having at least three integers, all consecutive.\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nInput: [1,2,3,3,4,5]\\nOutput: True\\n```\n```\\nInput: [1,2,3,3,4,4,5,5]\\nOutput: True\\n```\n```\\nInput: [1,2,3,4,4,5]\\nOutput: False\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 106542,
                "title": "c-o-n-solution-beats-100-now",
                "content": "```\\n    bool isPossible(vector<int>& nums) {\\n        unordered_map<int, int> ct, end;\\n        for(int i=0;i<nums.size();i++) ct[nums[i]]++;\\n        for(int i=0;i<nums.size();i++) {\\n            if(ct[nums[i]]<=0) continue;\\n            if(end[nums[i]-1]>0) {\\n                ct[nums[i]]--;\\n                end[nums[i]-1]--, end[nums[i]]++;\\n            }\\n            else if(ct[nums[i]+1]>0&&ct[nums[i]+2]>0) {\\n                ct[nums[i]]--, ct[nums[i]+1]--, ct[nums[i]+2]--;\\n                end[nums[i]+2]++;\\n            }\\n            else return false;\\n        }\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "```\\n    bool isPossible(vector<int>& nums) {\\n        unordered_map<int, int> ct, end;\\n        for(int i=0;i<nums.size();i++) ct[nums[i]]++;\\n        for(int i=0;i<nums.size();i++) {\\n            if(ct[nums[i]]<=0) continue;\\n            if(end[nums[i]-1]>0) {\\n                ct[nums[i]]--;\\n                end[nums[i]-1]--, end[nums[i]]++;\\n            }\\n            else if(ct[nums[i]+1]>0&&ct[nums[i]+2]>0) {\\n                ct[nums[i]]--, ct[nums[i]+1]--, ct[nums[i]+2]--;\\n                end[nums[i]+2]++;\\n            }\\n            else return false;\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 106529,
                "title": "greedy-algorithm-explanation-and-code",
                "content": "I think this one should be the hardest problem for this contest. My code passed 178/180 test cases. Sad... Anyway, the idea should be correct. <b>Well, it turned out to be part of incorrect, see the replies below.</b>\\nHow to decide where to break the subsequence? Of course, we should count how many duplicates. Let's say the example is [1,2,3,3,4,5]. So the count list corresponding to 1-5 is [1,1,2,1,1]. \\nIf the current sequence is continuous and mono-increasing like [1,1,2], the first subsequence should start from the most left(smallest) all the way to the largest element that is from the first '1' to 2 in this example.  Why? Cuz the counts are mono-increasing. That means the count of next number is smaller. <b>So the count of 2 should be shared by the numbers before it and after it.</b> In this example, we got [1,1,2]. The next step to do is to wipe the known subsequence. Here, just remove 1,2,3 and the count list becomes [0,0,1,1,1]. 0 is no longer in use, just remove them. The list becomes to [1,1,1]. Well, the rest counts are all 1's, wipe it all. And then the list is empty. So literally, what you want to check is if the list can be empty at the end. \\nAnother example, [1,1,2,2,2,3,3,4]. And count list is [2,3,2,1]. Using the same algorithm as above, [2,3] first. Ehhh, it is too short. I have to add next element to the subsequence? No, it is already false. Because there are fewer numbers in 3 than in 2. If you borrow 3 here, at the end, there will be one extra 2 and the sequence here will be broken.\\nDo not forget check the length of during the process. And when the difference between 2 cells are bigger than 1, the array breaks there. So you divide it into 2 arrays.\\n\\nHere is the <b>correct</b> code. I used a list to track the count of each number\\n\\n    public boolean isPossible(int[] nums) {\\n        List<Integer> counts = new ArrayList<>();\\n        int current = nums[0];\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == current) {\\n                count++;\\n            }\\n            else {\\n                counts.add(count);\\n                if (nums[i] - current > 1) {\\n                    if (!checkList(counts)) {\\n                        return false;\\n                    };\\n                    counts = new ArrayList<Integer>();\\n                }\\n                current = nums[i];\\n                count = 1;\\n            }\\n        }\\n        if (count > 0) {\\n            counts.add(count);\\n        }\\n        return checkList(counts);\\n    }\\n    \\n    private boolean checkList(List<Integer> counts) {\\n        if (counts.size() < 3) {\\n            return false;\\n        }\\n        while (counts.size() > 0) {\\n            int end = -1;\\n            for (int i = 1; i<counts.size(); i++) {\\n                if (counts.get(i) < counts.get(i-1)) {\\n                    end = i-1;\\n                    break;\\n                }\\n            }\\n            if (end == -1) end = counts.size() - 1;\\n            if (end < 2) return false;\\n            int toRemove = 1; // So here is the place I was wrong. It used to be counts.get(0); \\n            for (int i = 0; i<=end; i++) {\\n                counts.set(i, counts.get(i) - toRemove);    \\n            }\\n            while(counts.size() > 0) {\\n                if (counts.get(0) == 0) counts.remove(0);\\n                else break;\\n            }\\n        }\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "I think this one should be the hardest problem for this contest. My code passed 178/180 test cases. Sad... Anyway, the idea should be correct. <b>Well, it turned out to be part of incorrect, see the replies below.</b>\\nHow to decide where to break the subsequence? Of course, we should count how many duplicates. Let's say the example is [1,2,3,3,4,5]. So the count list corresponding to 1-5 is [1,1,2,1,1]. \\nIf the current sequence is continuous and mono-increasing like [1,1,2], the first subsequence should start from the most left(smallest) all the way to the largest element that is from the first '1' to 2 in this example.  Why? Cuz the counts are mono-increasing. That means the count of next number is smaller. <b>So the count of 2 should be shared by the numbers before it and after it.</b> In this example, we got [1,1,2]. The next step to do is to wipe the known subsequence. Here, just remove 1,2,3 and the count list becomes [0,0,1,1,1]. 0 is no longer in use, just remove them. The list becomes to [1,1,1]. Well, the rest counts are all 1's, wipe it all. And then the list is empty. So literally, what you want to check is if the list can be empty at the end. \\nAnother example, [1,1,2,2,2,3,3,4]. And count list is [2,3,2,1]. Using the same algorithm as above, [2,3] first. Ehhh, it is too short. I have to add next element to the subsequence? No, it is already false. Because there are fewer numbers in 3 than in 2. If you borrow 3 here, at the end, there will be one extra 2 and the sequence here will be broken.\\nDo not forget check the length of during the process. And when the difference between 2 cells are bigger than 1, the array breaks there. So you divide it into 2 arrays.\\n\\nHere is the <b>correct</b> code. I used a list to track the count of each number\\n\\n    public boolean isPossible(int[] nums) {\\n        List<Integer> counts = new ArrayList<>();\\n        int current = nums[0];\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == current) {\\n                count++;\\n            }\\n            else {\\n                counts.add(count);\\n                if (nums[i] - current > 1) {\\n                    if (!checkList(counts)) {\\n                        return false;\\n                    };\\n                    counts = new ArrayList<Integer>();\\n                }\\n                current = nums[i];\\n                count = 1;\\n            }\\n        }\\n        if (count > 0) {\\n            counts.add(count);\\n        }\\n        return checkList(counts);\\n    }\\n    \\n    private boolean checkList(List<Integer> counts) {\\n        if (counts.size() < 3) {\\n            return false;\\n        }\\n        while (counts.size() > 0) {\\n            int end = -1;\\n            for (int i = 1; i<counts.size(); i++) {\\n                if (counts.get(i) < counts.get(i-1)) {\\n                    end = i-1;\\n                    break;\\n                }\\n            }\\n            if (end == -1) end = counts.size() - 1;\\n            if (end < 2) return false;\\n            int toRemove = 1; // So here is the place I was wrong. It used to be counts.get(0); \\n            for (int i = 0; i<=end; i++) {\\n                counts.set(i, counts.get(i) - toRemove);    \\n            }\\n            while(counts.size() > 0) {\\n                if (counts.get(0) == 0) counts.remove(0);\\n                else break;\\n            }\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1564967,
                "content": [
                    {
                        "username": "hdlll",
                        "content": "Two test cases:\\n\\n[1,2,3,4,4,5] yields false\\n[1,2,3] yields true\\n\\nIf the original array without split can be a sub-sequence, then [1,2,3,4,4,5] can be a sub-sequence where 3 consecutive integers are present. So the result should be True.\\n\\nIf it's not, then how can [1,2,3] be True?"
                    },
                    {
                        "username": "_shiv_70",
                        "content": "one of the condition is given like this\\nEach subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer)\\n therefore here consecutive 4\\'s are violating this condition\\n"
                    },
                    {
                        "username": "RunRunCode",
                        "content": ">[1,2,3,4,5,6,6,8,9,9]\\n>Expected: false\\n\\nWhy [1,2,3] + [4,5,6,6,8,9,9] doesn't meet the requirement of \"each subsequences consist of at least 3 consecutive integers\"?\\n\\n>[1,2,3]\\n>Expected: true\\n\\nIf [1,2,3] without a split is considered as valid, then [1,2,3,4,4,5] as a whole should also be considered as valid. Becuase it contains 3 consecutive integers \"1,2,3\".\\n\\nThe answer might want to require the output subsequences to contain only consecutive numbers, but that's not what we read from the description (at least it's ambiguous) at this moment. And I don't want to guess the requirements from the test cases anyway."
                    },
                    {
                        "username": "110abidi",
                        "content": "I was a bit confused at the third example because I thought  [1,2,3,4,4,5] could be split into \\n\\n[1,2,4] and [3, 4, 5] and satisfy the condition. But the problem states: \"consecutive\". The reason why [1,2,4] doesn\\'t satisfy the condition is because 2,4 are not consecutive (it jumps from 2 to 4 instead of 2,3,4).\\n\\nHope that clarifies it for ya\\'ll."
                    },
                    {
                        "username": "roy14",
                        "content": "[1,2,3,4,4] returns false, but it still satisfies 'where each subsequence consists of at least 3 consecutive integers', it didn't ask for the whole subsequence to be consecutive."
                    },
                    {
                        "username": "Sykes",
                        "content": "I was using greedy to solve this and not passing case 178.\\nIt is hard to debug and I am lazy. If anyone once failed or is failing the same case, please share some thought. Thanks~"
                    },
                    {
                        "username": "ode",
                        "content": "I thought I understand it. But I am not sure now. \\n\\nIn description\\n\\tInput: [1,2,3,4,4,5]\\n\\tOutput: False\\n\\nIn test cases\\n\\tInput: [1,2,3]\\n\\tOutput: True\\n\\t\\nI do not even know where I lost it. Could you please explain how these examples fit into the description. Thank you.\\n\\t\\n\\t\\n\\n"
                    },
                    {
                        "username": "wei_wei_",
                        "content": "Hi, The first one doesn't fit according to first condition \"Each subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer).\" If you make 2 subsequences from ( 1,2,3,4,4,5) You might wanna make these: (1,2,4) and (3,4,5). The former one is not a consecutive subsequence. Or if you chose these two: (1,2,3) and (4,4,5), then the latter one is  not a consecutive subsequence."
                    },
                    {
                        "username": "peterlijobs",
                        "content": "Hi there, I have a question about the example 3 in the question. I'm wondering why the output of [1,2,3,4,4,5] is false. I'm thinking that it can be split into two consecutive sequence as [1,2,4], [3,4,5].\\n\\nThanks for your help!"
                    },
                    {
                        "username": "zB0y",
                        "content": "one greater than previous\\nso 1, 2, 3 is correct because 2 is one greater than 1 and 3 is one greater than 2\\n1, 2, 4 is incorrect because while 4 is not one greater than 2"
                    },
                    {
                        "username": "MSR_Yang",
                        "content": "result should be false or just note the length of input  is guaranteed >= 6"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "1)Store frequency in map first.\\n2)iterate though nums and check if next two elements have freq>0\\n3)Always store the last element of subsequence in new map so that last few elements(in nums) can use it"
                    },
                    {
                        "username": "tkar123",
                        "content": "Why is it telling me that [1,2,3,4,5,6,4] is false? Shouldn\\'t it be true because you can split it into one subsequence: [1,2,3,4] where the 4 is the last 4 in the array and another subsequence [4,5,6] where that 4 is the first 4 that appears in the array?"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "its an invalid array it should be sorted in non decreasing order\\n"
                    },
                    {
                        "username": "user2049D",
                        "content": "[@laichbr](/laichbr) \nIn the contraints we have:\nnums is sorted in non-decreasing order.\n [1,2,3,4,5,6,4] is not a case."
                    },
                    {
                        "username": "laichbr",
                        "content": "You\\'re right, that should be a valid sequence"
                    }
                ]
            },
            {
                "id": 1565954,
                "content": [
                    {
                        "username": "hdlll",
                        "content": "Two test cases:\\n\\n[1,2,3,4,4,5] yields false\\n[1,2,3] yields true\\n\\nIf the original array without split can be a sub-sequence, then [1,2,3,4,4,5] can be a sub-sequence where 3 consecutive integers are present. So the result should be True.\\n\\nIf it's not, then how can [1,2,3] be True?"
                    },
                    {
                        "username": "_shiv_70",
                        "content": "one of the condition is given like this\\nEach subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer)\\n therefore here consecutive 4\\'s are violating this condition\\n"
                    },
                    {
                        "username": "RunRunCode",
                        "content": ">[1,2,3,4,5,6,6,8,9,9]\\n>Expected: false\\n\\nWhy [1,2,3] + [4,5,6,6,8,9,9] doesn't meet the requirement of \"each subsequences consist of at least 3 consecutive integers\"?\\n\\n>[1,2,3]\\n>Expected: true\\n\\nIf [1,2,3] without a split is considered as valid, then [1,2,3,4,4,5] as a whole should also be considered as valid. Becuase it contains 3 consecutive integers \"1,2,3\".\\n\\nThe answer might want to require the output subsequences to contain only consecutive numbers, but that's not what we read from the description (at least it's ambiguous) at this moment. And I don't want to guess the requirements from the test cases anyway."
                    },
                    {
                        "username": "110abidi",
                        "content": "I was a bit confused at the third example because I thought  [1,2,3,4,4,5] could be split into \\n\\n[1,2,4] and [3, 4, 5] and satisfy the condition. But the problem states: \"consecutive\". The reason why [1,2,4] doesn\\'t satisfy the condition is because 2,4 are not consecutive (it jumps from 2 to 4 instead of 2,3,4).\\n\\nHope that clarifies it for ya\\'ll."
                    },
                    {
                        "username": "roy14",
                        "content": "[1,2,3,4,4] returns false, but it still satisfies 'where each subsequence consists of at least 3 consecutive integers', it didn't ask for the whole subsequence to be consecutive."
                    },
                    {
                        "username": "Sykes",
                        "content": "I was using greedy to solve this and not passing case 178.\\nIt is hard to debug and I am lazy. If anyone once failed or is failing the same case, please share some thought. Thanks~"
                    },
                    {
                        "username": "ode",
                        "content": "I thought I understand it. But I am not sure now. \\n\\nIn description\\n\\tInput: [1,2,3,4,4,5]\\n\\tOutput: False\\n\\nIn test cases\\n\\tInput: [1,2,3]\\n\\tOutput: True\\n\\t\\nI do not even know where I lost it. Could you please explain how these examples fit into the description. Thank you.\\n\\t\\n\\t\\n\\n"
                    },
                    {
                        "username": "wei_wei_",
                        "content": "Hi, The first one doesn't fit according to first condition \"Each subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer).\" If you make 2 subsequences from ( 1,2,3,4,4,5) You might wanna make these: (1,2,4) and (3,4,5). The former one is not a consecutive subsequence. Or if you chose these two: (1,2,3) and (4,4,5), then the latter one is  not a consecutive subsequence."
                    },
                    {
                        "username": "peterlijobs",
                        "content": "Hi there, I have a question about the example 3 in the question. I'm wondering why the output of [1,2,3,4,4,5] is false. I'm thinking that it can be split into two consecutive sequence as [1,2,4], [3,4,5].\\n\\nThanks for your help!"
                    },
                    {
                        "username": "zB0y",
                        "content": "one greater than previous\\nso 1, 2, 3 is correct because 2 is one greater than 1 and 3 is one greater than 2\\n1, 2, 4 is incorrect because while 4 is not one greater than 2"
                    },
                    {
                        "username": "MSR_Yang",
                        "content": "result should be false or just note the length of input  is guaranteed >= 6"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "1)Store frequency in map first.\\n2)iterate though nums and check if next two elements have freq>0\\n3)Always store the last element of subsequence in new map so that last few elements(in nums) can use it"
                    },
                    {
                        "username": "tkar123",
                        "content": "Why is it telling me that [1,2,3,4,5,6,4] is false? Shouldn\\'t it be true because you can split it into one subsequence: [1,2,3,4] where the 4 is the last 4 in the array and another subsequence [4,5,6] where that 4 is the first 4 that appears in the array?"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "its an invalid array it should be sorted in non decreasing order\\n"
                    },
                    {
                        "username": "user2049D",
                        "content": "[@laichbr](/laichbr) \nIn the contraints we have:\nnums is sorted in non-decreasing order.\n [1,2,3,4,5,6,4] is not a case."
                    },
                    {
                        "username": "laichbr",
                        "content": "You\\'re right, that should be a valid sequence"
                    }
                ]
            },
            {
                "id": 1568242,
                "content": [
                    {
                        "username": "hdlll",
                        "content": "Two test cases:\\n\\n[1,2,3,4,4,5] yields false\\n[1,2,3] yields true\\n\\nIf the original array without split can be a sub-sequence, then [1,2,3,4,4,5] can be a sub-sequence where 3 consecutive integers are present. So the result should be True.\\n\\nIf it's not, then how can [1,2,3] be True?"
                    },
                    {
                        "username": "_shiv_70",
                        "content": "one of the condition is given like this\\nEach subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer)\\n therefore here consecutive 4\\'s are violating this condition\\n"
                    },
                    {
                        "username": "RunRunCode",
                        "content": ">[1,2,3,4,5,6,6,8,9,9]\\n>Expected: false\\n\\nWhy [1,2,3] + [4,5,6,6,8,9,9] doesn't meet the requirement of \"each subsequences consist of at least 3 consecutive integers\"?\\n\\n>[1,2,3]\\n>Expected: true\\n\\nIf [1,2,3] without a split is considered as valid, then [1,2,3,4,4,5] as a whole should also be considered as valid. Becuase it contains 3 consecutive integers \"1,2,3\".\\n\\nThe answer might want to require the output subsequences to contain only consecutive numbers, but that's not what we read from the description (at least it's ambiguous) at this moment. And I don't want to guess the requirements from the test cases anyway."
                    },
                    {
                        "username": "110abidi",
                        "content": "I was a bit confused at the third example because I thought  [1,2,3,4,4,5] could be split into \\n\\n[1,2,4] and [3, 4, 5] and satisfy the condition. But the problem states: \"consecutive\". The reason why [1,2,4] doesn\\'t satisfy the condition is because 2,4 are not consecutive (it jumps from 2 to 4 instead of 2,3,4).\\n\\nHope that clarifies it for ya\\'ll."
                    },
                    {
                        "username": "roy14",
                        "content": "[1,2,3,4,4] returns false, but it still satisfies 'where each subsequence consists of at least 3 consecutive integers', it didn't ask for the whole subsequence to be consecutive."
                    },
                    {
                        "username": "Sykes",
                        "content": "I was using greedy to solve this and not passing case 178.\\nIt is hard to debug and I am lazy. If anyone once failed or is failing the same case, please share some thought. Thanks~"
                    },
                    {
                        "username": "ode",
                        "content": "I thought I understand it. But I am not sure now. \\n\\nIn description\\n\\tInput: [1,2,3,4,4,5]\\n\\tOutput: False\\n\\nIn test cases\\n\\tInput: [1,2,3]\\n\\tOutput: True\\n\\t\\nI do not even know where I lost it. Could you please explain how these examples fit into the description. Thank you.\\n\\t\\n\\t\\n\\n"
                    },
                    {
                        "username": "wei_wei_",
                        "content": "Hi, The first one doesn't fit according to first condition \"Each subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer).\" If you make 2 subsequences from ( 1,2,3,4,4,5) You might wanna make these: (1,2,4) and (3,4,5). The former one is not a consecutive subsequence. Or if you chose these two: (1,2,3) and (4,4,5), then the latter one is  not a consecutive subsequence."
                    },
                    {
                        "username": "peterlijobs",
                        "content": "Hi there, I have a question about the example 3 in the question. I'm wondering why the output of [1,2,3,4,4,5] is false. I'm thinking that it can be split into two consecutive sequence as [1,2,4], [3,4,5].\\n\\nThanks for your help!"
                    },
                    {
                        "username": "zB0y",
                        "content": "one greater than previous\\nso 1, 2, 3 is correct because 2 is one greater than 1 and 3 is one greater than 2\\n1, 2, 4 is incorrect because while 4 is not one greater than 2"
                    },
                    {
                        "username": "MSR_Yang",
                        "content": "result should be false or just note the length of input  is guaranteed >= 6"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "1)Store frequency in map first.\\n2)iterate though nums and check if next two elements have freq>0\\n3)Always store the last element of subsequence in new map so that last few elements(in nums) can use it"
                    },
                    {
                        "username": "tkar123",
                        "content": "Why is it telling me that [1,2,3,4,5,6,4] is false? Shouldn\\'t it be true because you can split it into one subsequence: [1,2,3,4] where the 4 is the last 4 in the array and another subsequence [4,5,6] where that 4 is the first 4 that appears in the array?"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "its an invalid array it should be sorted in non decreasing order\\n"
                    },
                    {
                        "username": "user2049D",
                        "content": "[@laichbr](/laichbr) \nIn the contraints we have:\nnums is sorted in non-decreasing order.\n [1,2,3,4,5,6,4] is not a case."
                    },
                    {
                        "username": "laichbr",
                        "content": "You\\'re right, that should be a valid sequence"
                    }
                ]
            },
            {
                "id": 1567278,
                "content": [
                    {
                        "username": "hdlll",
                        "content": "Two test cases:\\n\\n[1,2,3,4,4,5] yields false\\n[1,2,3] yields true\\n\\nIf the original array without split can be a sub-sequence, then [1,2,3,4,4,5] can be a sub-sequence where 3 consecutive integers are present. So the result should be True.\\n\\nIf it's not, then how can [1,2,3] be True?"
                    },
                    {
                        "username": "_shiv_70",
                        "content": "one of the condition is given like this\\nEach subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer)\\n therefore here consecutive 4\\'s are violating this condition\\n"
                    },
                    {
                        "username": "RunRunCode",
                        "content": ">[1,2,3,4,5,6,6,8,9,9]\\n>Expected: false\\n\\nWhy [1,2,3] + [4,5,6,6,8,9,9] doesn't meet the requirement of \"each subsequences consist of at least 3 consecutive integers\"?\\n\\n>[1,2,3]\\n>Expected: true\\n\\nIf [1,2,3] without a split is considered as valid, then [1,2,3,4,4,5] as a whole should also be considered as valid. Becuase it contains 3 consecutive integers \"1,2,3\".\\n\\nThe answer might want to require the output subsequences to contain only consecutive numbers, but that's not what we read from the description (at least it's ambiguous) at this moment. And I don't want to guess the requirements from the test cases anyway."
                    },
                    {
                        "username": "110abidi",
                        "content": "I was a bit confused at the third example because I thought  [1,2,3,4,4,5] could be split into \\n\\n[1,2,4] and [3, 4, 5] and satisfy the condition. But the problem states: \"consecutive\". The reason why [1,2,4] doesn\\'t satisfy the condition is because 2,4 are not consecutive (it jumps from 2 to 4 instead of 2,3,4).\\n\\nHope that clarifies it for ya\\'ll."
                    },
                    {
                        "username": "roy14",
                        "content": "[1,2,3,4,4] returns false, but it still satisfies 'where each subsequence consists of at least 3 consecutive integers', it didn't ask for the whole subsequence to be consecutive."
                    },
                    {
                        "username": "Sykes",
                        "content": "I was using greedy to solve this and not passing case 178.\\nIt is hard to debug and I am lazy. If anyone once failed or is failing the same case, please share some thought. Thanks~"
                    },
                    {
                        "username": "ode",
                        "content": "I thought I understand it. But I am not sure now. \\n\\nIn description\\n\\tInput: [1,2,3,4,4,5]\\n\\tOutput: False\\n\\nIn test cases\\n\\tInput: [1,2,3]\\n\\tOutput: True\\n\\t\\nI do not even know where I lost it. Could you please explain how these examples fit into the description. Thank you.\\n\\t\\n\\t\\n\\n"
                    },
                    {
                        "username": "wei_wei_",
                        "content": "Hi, The first one doesn't fit according to first condition \"Each subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer).\" If you make 2 subsequences from ( 1,2,3,4,4,5) You might wanna make these: (1,2,4) and (3,4,5). The former one is not a consecutive subsequence. Or if you chose these two: (1,2,3) and (4,4,5), then the latter one is  not a consecutive subsequence."
                    },
                    {
                        "username": "peterlijobs",
                        "content": "Hi there, I have a question about the example 3 in the question. I'm wondering why the output of [1,2,3,4,4,5] is false. I'm thinking that it can be split into two consecutive sequence as [1,2,4], [3,4,5].\\n\\nThanks for your help!"
                    },
                    {
                        "username": "zB0y",
                        "content": "one greater than previous\\nso 1, 2, 3 is correct because 2 is one greater than 1 and 3 is one greater than 2\\n1, 2, 4 is incorrect because while 4 is not one greater than 2"
                    },
                    {
                        "username": "MSR_Yang",
                        "content": "result should be false or just note the length of input  is guaranteed >= 6"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "1)Store frequency in map first.\\n2)iterate though nums and check if next two elements have freq>0\\n3)Always store the last element of subsequence in new map so that last few elements(in nums) can use it"
                    },
                    {
                        "username": "tkar123",
                        "content": "Why is it telling me that [1,2,3,4,5,6,4] is false? Shouldn\\'t it be true because you can split it into one subsequence: [1,2,3,4] where the 4 is the last 4 in the array and another subsequence [4,5,6] where that 4 is the first 4 that appears in the array?"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "its an invalid array it should be sorted in non decreasing order\\n"
                    },
                    {
                        "username": "user2049D",
                        "content": "[@laichbr](/laichbr) \nIn the contraints we have:\nnums is sorted in non-decreasing order.\n [1,2,3,4,5,6,4] is not a case."
                    },
                    {
                        "username": "laichbr",
                        "content": "You\\'re right, that should be a valid sequence"
                    }
                ]
            },
            {
                "id": 1567994,
                "content": [
                    {
                        "username": "hdlll",
                        "content": "Two test cases:\\n\\n[1,2,3,4,4,5] yields false\\n[1,2,3] yields true\\n\\nIf the original array without split can be a sub-sequence, then [1,2,3,4,4,5] can be a sub-sequence where 3 consecutive integers are present. So the result should be True.\\n\\nIf it's not, then how can [1,2,3] be True?"
                    },
                    {
                        "username": "_shiv_70",
                        "content": "one of the condition is given like this\\nEach subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer)\\n therefore here consecutive 4\\'s are violating this condition\\n"
                    },
                    {
                        "username": "RunRunCode",
                        "content": ">[1,2,3,4,5,6,6,8,9,9]\\n>Expected: false\\n\\nWhy [1,2,3] + [4,5,6,6,8,9,9] doesn't meet the requirement of \"each subsequences consist of at least 3 consecutive integers\"?\\n\\n>[1,2,3]\\n>Expected: true\\n\\nIf [1,2,3] without a split is considered as valid, then [1,2,3,4,4,5] as a whole should also be considered as valid. Becuase it contains 3 consecutive integers \"1,2,3\".\\n\\nThe answer might want to require the output subsequences to contain only consecutive numbers, but that's not what we read from the description (at least it's ambiguous) at this moment. And I don't want to guess the requirements from the test cases anyway."
                    },
                    {
                        "username": "110abidi",
                        "content": "I was a bit confused at the third example because I thought  [1,2,3,4,4,5] could be split into \\n\\n[1,2,4] and [3, 4, 5] and satisfy the condition. But the problem states: \"consecutive\". The reason why [1,2,4] doesn\\'t satisfy the condition is because 2,4 are not consecutive (it jumps from 2 to 4 instead of 2,3,4).\\n\\nHope that clarifies it for ya\\'ll."
                    },
                    {
                        "username": "roy14",
                        "content": "[1,2,3,4,4] returns false, but it still satisfies 'where each subsequence consists of at least 3 consecutive integers', it didn't ask for the whole subsequence to be consecutive."
                    },
                    {
                        "username": "Sykes",
                        "content": "I was using greedy to solve this and not passing case 178.\\nIt is hard to debug and I am lazy. If anyone once failed or is failing the same case, please share some thought. Thanks~"
                    },
                    {
                        "username": "ode",
                        "content": "I thought I understand it. But I am not sure now. \\n\\nIn description\\n\\tInput: [1,2,3,4,4,5]\\n\\tOutput: False\\n\\nIn test cases\\n\\tInput: [1,2,3]\\n\\tOutput: True\\n\\t\\nI do not even know where I lost it. Could you please explain how these examples fit into the description. Thank you.\\n\\t\\n\\t\\n\\n"
                    },
                    {
                        "username": "wei_wei_",
                        "content": "Hi, The first one doesn't fit according to first condition \"Each subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer).\" If you make 2 subsequences from ( 1,2,3,4,4,5) You might wanna make these: (1,2,4) and (3,4,5). The former one is not a consecutive subsequence. Or if you chose these two: (1,2,3) and (4,4,5), then the latter one is  not a consecutive subsequence."
                    },
                    {
                        "username": "peterlijobs",
                        "content": "Hi there, I have a question about the example 3 in the question. I'm wondering why the output of [1,2,3,4,4,5] is false. I'm thinking that it can be split into two consecutive sequence as [1,2,4], [3,4,5].\\n\\nThanks for your help!"
                    },
                    {
                        "username": "zB0y",
                        "content": "one greater than previous\\nso 1, 2, 3 is correct because 2 is one greater than 1 and 3 is one greater than 2\\n1, 2, 4 is incorrect because while 4 is not one greater than 2"
                    },
                    {
                        "username": "MSR_Yang",
                        "content": "result should be false or just note the length of input  is guaranteed >= 6"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "1)Store frequency in map first.\\n2)iterate though nums and check if next two elements have freq>0\\n3)Always store the last element of subsequence in new map so that last few elements(in nums) can use it"
                    },
                    {
                        "username": "tkar123",
                        "content": "Why is it telling me that [1,2,3,4,5,6,4] is false? Shouldn\\'t it be true because you can split it into one subsequence: [1,2,3,4] where the 4 is the last 4 in the array and another subsequence [4,5,6] where that 4 is the first 4 that appears in the array?"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "its an invalid array it should be sorted in non decreasing order\\n"
                    },
                    {
                        "username": "user2049D",
                        "content": "[@laichbr](/laichbr) \nIn the contraints we have:\nnums is sorted in non-decreasing order.\n [1,2,3,4,5,6,4] is not a case."
                    },
                    {
                        "username": "laichbr",
                        "content": "You\\'re right, that should be a valid sequence"
                    }
                ]
            },
            {
                "id": 1569835,
                "content": [
                    {
                        "username": "hdlll",
                        "content": "Two test cases:\\n\\n[1,2,3,4,4,5] yields false\\n[1,2,3] yields true\\n\\nIf the original array without split can be a sub-sequence, then [1,2,3,4,4,5] can be a sub-sequence where 3 consecutive integers are present. So the result should be True.\\n\\nIf it's not, then how can [1,2,3] be True?"
                    },
                    {
                        "username": "_shiv_70",
                        "content": "one of the condition is given like this\\nEach subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer)\\n therefore here consecutive 4\\'s are violating this condition\\n"
                    },
                    {
                        "username": "RunRunCode",
                        "content": ">[1,2,3,4,5,6,6,8,9,9]\\n>Expected: false\\n\\nWhy [1,2,3] + [4,5,6,6,8,9,9] doesn't meet the requirement of \"each subsequences consist of at least 3 consecutive integers\"?\\n\\n>[1,2,3]\\n>Expected: true\\n\\nIf [1,2,3] without a split is considered as valid, then [1,2,3,4,4,5] as a whole should also be considered as valid. Becuase it contains 3 consecutive integers \"1,2,3\".\\n\\nThe answer might want to require the output subsequences to contain only consecutive numbers, but that's not what we read from the description (at least it's ambiguous) at this moment. And I don't want to guess the requirements from the test cases anyway."
                    },
                    {
                        "username": "110abidi",
                        "content": "I was a bit confused at the third example because I thought  [1,2,3,4,4,5] could be split into \\n\\n[1,2,4] and [3, 4, 5] and satisfy the condition. But the problem states: \"consecutive\". The reason why [1,2,4] doesn\\'t satisfy the condition is because 2,4 are not consecutive (it jumps from 2 to 4 instead of 2,3,4).\\n\\nHope that clarifies it for ya\\'ll."
                    },
                    {
                        "username": "roy14",
                        "content": "[1,2,3,4,4] returns false, but it still satisfies 'where each subsequence consists of at least 3 consecutive integers', it didn't ask for the whole subsequence to be consecutive."
                    },
                    {
                        "username": "Sykes",
                        "content": "I was using greedy to solve this and not passing case 178.\\nIt is hard to debug and I am lazy. If anyone once failed or is failing the same case, please share some thought. Thanks~"
                    },
                    {
                        "username": "ode",
                        "content": "I thought I understand it. But I am not sure now. \\n\\nIn description\\n\\tInput: [1,2,3,4,4,5]\\n\\tOutput: False\\n\\nIn test cases\\n\\tInput: [1,2,3]\\n\\tOutput: True\\n\\t\\nI do not even know where I lost it. Could you please explain how these examples fit into the description. Thank you.\\n\\t\\n\\t\\n\\n"
                    },
                    {
                        "username": "wei_wei_",
                        "content": "Hi, The first one doesn't fit according to first condition \"Each subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer).\" If you make 2 subsequences from ( 1,2,3,4,4,5) You might wanna make these: (1,2,4) and (3,4,5). The former one is not a consecutive subsequence. Or if you chose these two: (1,2,3) and (4,4,5), then the latter one is  not a consecutive subsequence."
                    },
                    {
                        "username": "peterlijobs",
                        "content": "Hi there, I have a question about the example 3 in the question. I'm wondering why the output of [1,2,3,4,4,5] is false. I'm thinking that it can be split into two consecutive sequence as [1,2,4], [3,4,5].\\n\\nThanks for your help!"
                    },
                    {
                        "username": "zB0y",
                        "content": "one greater than previous\\nso 1, 2, 3 is correct because 2 is one greater than 1 and 3 is one greater than 2\\n1, 2, 4 is incorrect because while 4 is not one greater than 2"
                    },
                    {
                        "username": "MSR_Yang",
                        "content": "result should be false or just note the length of input  is guaranteed >= 6"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "1)Store frequency in map first.\\n2)iterate though nums and check if next two elements have freq>0\\n3)Always store the last element of subsequence in new map so that last few elements(in nums) can use it"
                    },
                    {
                        "username": "tkar123",
                        "content": "Why is it telling me that [1,2,3,4,5,6,4] is false? Shouldn\\'t it be true because you can split it into one subsequence: [1,2,3,4] where the 4 is the last 4 in the array and another subsequence [4,5,6] where that 4 is the first 4 that appears in the array?"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "its an invalid array it should be sorted in non decreasing order\\n"
                    },
                    {
                        "username": "user2049D",
                        "content": "[@laichbr](/laichbr) \nIn the contraints we have:\nnums is sorted in non-decreasing order.\n [1,2,3,4,5,6,4] is not a case."
                    },
                    {
                        "username": "laichbr",
                        "content": "You\\'re right, that should be a valid sequence"
                    }
                ]
            },
            {
                "id": 1567995,
                "content": [
                    {
                        "username": "hdlll",
                        "content": "Two test cases:\\n\\n[1,2,3,4,4,5] yields false\\n[1,2,3] yields true\\n\\nIf the original array without split can be a sub-sequence, then [1,2,3,4,4,5] can be a sub-sequence where 3 consecutive integers are present. So the result should be True.\\n\\nIf it's not, then how can [1,2,3] be True?"
                    },
                    {
                        "username": "_shiv_70",
                        "content": "one of the condition is given like this\\nEach subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer)\\n therefore here consecutive 4\\'s are violating this condition\\n"
                    },
                    {
                        "username": "RunRunCode",
                        "content": ">[1,2,3,4,5,6,6,8,9,9]\\n>Expected: false\\n\\nWhy [1,2,3] + [4,5,6,6,8,9,9] doesn't meet the requirement of \"each subsequences consist of at least 3 consecutive integers\"?\\n\\n>[1,2,3]\\n>Expected: true\\n\\nIf [1,2,3] without a split is considered as valid, then [1,2,3,4,4,5] as a whole should also be considered as valid. Becuase it contains 3 consecutive integers \"1,2,3\".\\n\\nThe answer might want to require the output subsequences to contain only consecutive numbers, but that's not what we read from the description (at least it's ambiguous) at this moment. And I don't want to guess the requirements from the test cases anyway."
                    },
                    {
                        "username": "110abidi",
                        "content": "I was a bit confused at the third example because I thought  [1,2,3,4,4,5] could be split into \\n\\n[1,2,4] and [3, 4, 5] and satisfy the condition. But the problem states: \"consecutive\". The reason why [1,2,4] doesn\\'t satisfy the condition is because 2,4 are not consecutive (it jumps from 2 to 4 instead of 2,3,4).\\n\\nHope that clarifies it for ya\\'ll."
                    },
                    {
                        "username": "roy14",
                        "content": "[1,2,3,4,4] returns false, but it still satisfies 'where each subsequence consists of at least 3 consecutive integers', it didn't ask for the whole subsequence to be consecutive."
                    },
                    {
                        "username": "Sykes",
                        "content": "I was using greedy to solve this and not passing case 178.\\nIt is hard to debug and I am lazy. If anyone once failed or is failing the same case, please share some thought. Thanks~"
                    },
                    {
                        "username": "ode",
                        "content": "I thought I understand it. But I am not sure now. \\n\\nIn description\\n\\tInput: [1,2,3,4,4,5]\\n\\tOutput: False\\n\\nIn test cases\\n\\tInput: [1,2,3]\\n\\tOutput: True\\n\\t\\nI do not even know where I lost it. Could you please explain how these examples fit into the description. Thank you.\\n\\t\\n\\t\\n\\n"
                    },
                    {
                        "username": "wei_wei_",
                        "content": "Hi, The first one doesn't fit according to first condition \"Each subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer).\" If you make 2 subsequences from ( 1,2,3,4,4,5) You might wanna make these: (1,2,4) and (3,4,5). The former one is not a consecutive subsequence. Or if you chose these two: (1,2,3) and (4,4,5), then the latter one is  not a consecutive subsequence."
                    },
                    {
                        "username": "peterlijobs",
                        "content": "Hi there, I have a question about the example 3 in the question. I'm wondering why the output of [1,2,3,4,4,5] is false. I'm thinking that it can be split into two consecutive sequence as [1,2,4], [3,4,5].\\n\\nThanks for your help!"
                    },
                    {
                        "username": "zB0y",
                        "content": "one greater than previous\\nso 1, 2, 3 is correct because 2 is one greater than 1 and 3 is one greater than 2\\n1, 2, 4 is incorrect because while 4 is not one greater than 2"
                    },
                    {
                        "username": "MSR_Yang",
                        "content": "result should be false or just note the length of input  is guaranteed >= 6"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "1)Store frequency in map first.\\n2)iterate though nums and check if next two elements have freq>0\\n3)Always store the last element of subsequence in new map so that last few elements(in nums) can use it"
                    },
                    {
                        "username": "tkar123",
                        "content": "Why is it telling me that [1,2,3,4,5,6,4] is false? Shouldn\\'t it be true because you can split it into one subsequence: [1,2,3,4] where the 4 is the last 4 in the array and another subsequence [4,5,6] where that 4 is the first 4 that appears in the array?"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "its an invalid array it should be sorted in non decreasing order\\n"
                    },
                    {
                        "username": "user2049D",
                        "content": "[@laichbr](/laichbr) \nIn the contraints we have:\nnums is sorted in non-decreasing order.\n [1,2,3,4,5,6,4] is not a case."
                    },
                    {
                        "username": "laichbr",
                        "content": "You\\'re right, that should be a valid sequence"
                    }
                ]
            },
            {
                "id": 1566268,
                "content": [
                    {
                        "username": "hdlll",
                        "content": "Two test cases:\\n\\n[1,2,3,4,4,5] yields false\\n[1,2,3] yields true\\n\\nIf the original array without split can be a sub-sequence, then [1,2,3,4,4,5] can be a sub-sequence where 3 consecutive integers are present. So the result should be True.\\n\\nIf it's not, then how can [1,2,3] be True?"
                    },
                    {
                        "username": "_shiv_70",
                        "content": "one of the condition is given like this\\nEach subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer)\\n therefore here consecutive 4\\'s are violating this condition\\n"
                    },
                    {
                        "username": "RunRunCode",
                        "content": ">[1,2,3,4,5,6,6,8,9,9]\\n>Expected: false\\n\\nWhy [1,2,3] + [4,5,6,6,8,9,9] doesn't meet the requirement of \"each subsequences consist of at least 3 consecutive integers\"?\\n\\n>[1,2,3]\\n>Expected: true\\n\\nIf [1,2,3] without a split is considered as valid, then [1,2,3,4,4,5] as a whole should also be considered as valid. Becuase it contains 3 consecutive integers \"1,2,3\".\\n\\nThe answer might want to require the output subsequences to contain only consecutive numbers, but that's not what we read from the description (at least it's ambiguous) at this moment. And I don't want to guess the requirements from the test cases anyway."
                    },
                    {
                        "username": "110abidi",
                        "content": "I was a bit confused at the third example because I thought  [1,2,3,4,4,5] could be split into \\n\\n[1,2,4] and [3, 4, 5] and satisfy the condition. But the problem states: \"consecutive\". The reason why [1,2,4] doesn\\'t satisfy the condition is because 2,4 are not consecutive (it jumps from 2 to 4 instead of 2,3,4).\\n\\nHope that clarifies it for ya\\'ll."
                    },
                    {
                        "username": "roy14",
                        "content": "[1,2,3,4,4] returns false, but it still satisfies 'where each subsequence consists of at least 3 consecutive integers', it didn't ask for the whole subsequence to be consecutive."
                    },
                    {
                        "username": "Sykes",
                        "content": "I was using greedy to solve this and not passing case 178.\\nIt is hard to debug and I am lazy. If anyone once failed or is failing the same case, please share some thought. Thanks~"
                    },
                    {
                        "username": "ode",
                        "content": "I thought I understand it. But I am not sure now. \\n\\nIn description\\n\\tInput: [1,2,3,4,4,5]\\n\\tOutput: False\\n\\nIn test cases\\n\\tInput: [1,2,3]\\n\\tOutput: True\\n\\t\\nI do not even know where I lost it. Could you please explain how these examples fit into the description. Thank you.\\n\\t\\n\\t\\n\\n"
                    },
                    {
                        "username": "wei_wei_",
                        "content": "Hi, The first one doesn't fit according to first condition \"Each subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer).\" If you make 2 subsequences from ( 1,2,3,4,4,5) You might wanna make these: (1,2,4) and (3,4,5). The former one is not a consecutive subsequence. Or if you chose these two: (1,2,3) and (4,4,5), then the latter one is  not a consecutive subsequence."
                    },
                    {
                        "username": "peterlijobs",
                        "content": "Hi there, I have a question about the example 3 in the question. I'm wondering why the output of [1,2,3,4,4,5] is false. I'm thinking that it can be split into two consecutive sequence as [1,2,4], [3,4,5].\\n\\nThanks for your help!"
                    },
                    {
                        "username": "zB0y",
                        "content": "one greater than previous\\nso 1, 2, 3 is correct because 2 is one greater than 1 and 3 is one greater than 2\\n1, 2, 4 is incorrect because while 4 is not one greater than 2"
                    },
                    {
                        "username": "MSR_Yang",
                        "content": "result should be false or just note the length of input  is guaranteed >= 6"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "1)Store frequency in map first.\\n2)iterate though nums and check if next two elements have freq>0\\n3)Always store the last element of subsequence in new map so that last few elements(in nums) can use it"
                    },
                    {
                        "username": "tkar123",
                        "content": "Why is it telling me that [1,2,3,4,5,6,4] is false? Shouldn\\'t it be true because you can split it into one subsequence: [1,2,3,4] where the 4 is the last 4 in the array and another subsequence [4,5,6] where that 4 is the first 4 that appears in the array?"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "its an invalid array it should be sorted in non decreasing order\\n"
                    },
                    {
                        "username": "user2049D",
                        "content": "[@laichbr](/laichbr) \nIn the contraints we have:\nnums is sorted in non-decreasing order.\n [1,2,3,4,5,6,4] is not a case."
                    },
                    {
                        "username": "laichbr",
                        "content": "You\\'re right, that should be a valid sequence"
                    }
                ]
            },
            {
                "id": 1754001,
                "content": [
                    {
                        "username": "hdlll",
                        "content": "Two test cases:\\n\\n[1,2,3,4,4,5] yields false\\n[1,2,3] yields true\\n\\nIf the original array without split can be a sub-sequence, then [1,2,3,4,4,5] can be a sub-sequence where 3 consecutive integers are present. So the result should be True.\\n\\nIf it's not, then how can [1,2,3] be True?"
                    },
                    {
                        "username": "_shiv_70",
                        "content": "one of the condition is given like this\\nEach subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer)\\n therefore here consecutive 4\\'s are violating this condition\\n"
                    },
                    {
                        "username": "RunRunCode",
                        "content": ">[1,2,3,4,5,6,6,8,9,9]\\n>Expected: false\\n\\nWhy [1,2,3] + [4,5,6,6,8,9,9] doesn't meet the requirement of \"each subsequences consist of at least 3 consecutive integers\"?\\n\\n>[1,2,3]\\n>Expected: true\\n\\nIf [1,2,3] without a split is considered as valid, then [1,2,3,4,4,5] as a whole should also be considered as valid. Becuase it contains 3 consecutive integers \"1,2,3\".\\n\\nThe answer might want to require the output subsequences to contain only consecutive numbers, but that's not what we read from the description (at least it's ambiguous) at this moment. And I don't want to guess the requirements from the test cases anyway."
                    },
                    {
                        "username": "110abidi",
                        "content": "I was a bit confused at the third example because I thought  [1,2,3,4,4,5] could be split into \\n\\n[1,2,4] and [3, 4, 5] and satisfy the condition. But the problem states: \"consecutive\". The reason why [1,2,4] doesn\\'t satisfy the condition is because 2,4 are not consecutive (it jumps from 2 to 4 instead of 2,3,4).\\n\\nHope that clarifies it for ya\\'ll."
                    },
                    {
                        "username": "roy14",
                        "content": "[1,2,3,4,4] returns false, but it still satisfies 'where each subsequence consists of at least 3 consecutive integers', it didn't ask for the whole subsequence to be consecutive."
                    },
                    {
                        "username": "Sykes",
                        "content": "I was using greedy to solve this and not passing case 178.\\nIt is hard to debug and I am lazy. If anyone once failed or is failing the same case, please share some thought. Thanks~"
                    },
                    {
                        "username": "ode",
                        "content": "I thought I understand it. But I am not sure now. \\n\\nIn description\\n\\tInput: [1,2,3,4,4,5]\\n\\tOutput: False\\n\\nIn test cases\\n\\tInput: [1,2,3]\\n\\tOutput: True\\n\\t\\nI do not even know where I lost it. Could you please explain how these examples fit into the description. Thank you.\\n\\t\\n\\t\\n\\n"
                    },
                    {
                        "username": "wei_wei_",
                        "content": "Hi, The first one doesn't fit according to first condition \"Each subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer).\" If you make 2 subsequences from ( 1,2,3,4,4,5) You might wanna make these: (1,2,4) and (3,4,5). The former one is not a consecutive subsequence. Or if you chose these two: (1,2,3) and (4,4,5), then the latter one is  not a consecutive subsequence."
                    },
                    {
                        "username": "peterlijobs",
                        "content": "Hi there, I have a question about the example 3 in the question. I'm wondering why the output of [1,2,3,4,4,5] is false. I'm thinking that it can be split into two consecutive sequence as [1,2,4], [3,4,5].\\n\\nThanks for your help!"
                    },
                    {
                        "username": "zB0y",
                        "content": "one greater than previous\\nso 1, 2, 3 is correct because 2 is one greater than 1 and 3 is one greater than 2\\n1, 2, 4 is incorrect because while 4 is not one greater than 2"
                    },
                    {
                        "username": "MSR_Yang",
                        "content": "result should be false or just note the length of input  is guaranteed >= 6"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "1)Store frequency in map first.\\n2)iterate though nums and check if next two elements have freq>0\\n3)Always store the last element of subsequence in new map so that last few elements(in nums) can use it"
                    },
                    {
                        "username": "tkar123",
                        "content": "Why is it telling me that [1,2,3,4,5,6,4] is false? Shouldn\\'t it be true because you can split it into one subsequence: [1,2,3,4] where the 4 is the last 4 in the array and another subsequence [4,5,6] where that 4 is the first 4 that appears in the array?"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "its an invalid array it should be sorted in non decreasing order\\n"
                    },
                    {
                        "username": "user2049D",
                        "content": "[@laichbr](/laichbr) \nIn the contraints we have:\nnums is sorted in non-decreasing order.\n [1,2,3,4,5,6,4] is not a case."
                    },
                    {
                        "username": "laichbr",
                        "content": "You\\'re right, that should be a valid sequence"
                    }
                ]
            },
            {
                "id": 1573328,
                "content": [
                    {
                        "username": "hdlll",
                        "content": "Two test cases:\\n\\n[1,2,3,4,4,5] yields false\\n[1,2,3] yields true\\n\\nIf the original array without split can be a sub-sequence, then [1,2,3,4,4,5] can be a sub-sequence where 3 consecutive integers are present. So the result should be True.\\n\\nIf it's not, then how can [1,2,3] be True?"
                    },
                    {
                        "username": "_shiv_70",
                        "content": "one of the condition is given like this\\nEach subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer)\\n therefore here consecutive 4\\'s are violating this condition\\n"
                    },
                    {
                        "username": "RunRunCode",
                        "content": ">[1,2,3,4,5,6,6,8,9,9]\\n>Expected: false\\n\\nWhy [1,2,3] + [4,5,6,6,8,9,9] doesn't meet the requirement of \"each subsequences consist of at least 3 consecutive integers\"?\\n\\n>[1,2,3]\\n>Expected: true\\n\\nIf [1,2,3] without a split is considered as valid, then [1,2,3,4,4,5] as a whole should also be considered as valid. Becuase it contains 3 consecutive integers \"1,2,3\".\\n\\nThe answer might want to require the output subsequences to contain only consecutive numbers, but that's not what we read from the description (at least it's ambiguous) at this moment. And I don't want to guess the requirements from the test cases anyway."
                    },
                    {
                        "username": "110abidi",
                        "content": "I was a bit confused at the third example because I thought  [1,2,3,4,4,5] could be split into \\n\\n[1,2,4] and [3, 4, 5] and satisfy the condition. But the problem states: \"consecutive\". The reason why [1,2,4] doesn\\'t satisfy the condition is because 2,4 are not consecutive (it jumps from 2 to 4 instead of 2,3,4).\\n\\nHope that clarifies it for ya\\'ll."
                    },
                    {
                        "username": "roy14",
                        "content": "[1,2,3,4,4] returns false, but it still satisfies 'where each subsequence consists of at least 3 consecutive integers', it didn't ask for the whole subsequence to be consecutive."
                    },
                    {
                        "username": "Sykes",
                        "content": "I was using greedy to solve this and not passing case 178.\\nIt is hard to debug and I am lazy. If anyone once failed or is failing the same case, please share some thought. Thanks~"
                    },
                    {
                        "username": "ode",
                        "content": "I thought I understand it. But I am not sure now. \\n\\nIn description\\n\\tInput: [1,2,3,4,4,5]\\n\\tOutput: False\\n\\nIn test cases\\n\\tInput: [1,2,3]\\n\\tOutput: True\\n\\t\\nI do not even know where I lost it. Could you please explain how these examples fit into the description. Thank you.\\n\\t\\n\\t\\n\\n"
                    },
                    {
                        "username": "wei_wei_",
                        "content": "Hi, The first one doesn't fit according to first condition \"Each subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer).\" If you make 2 subsequences from ( 1,2,3,4,4,5) You might wanna make these: (1,2,4) and (3,4,5). The former one is not a consecutive subsequence. Or if you chose these two: (1,2,3) and (4,4,5), then the latter one is  not a consecutive subsequence."
                    },
                    {
                        "username": "peterlijobs",
                        "content": "Hi there, I have a question about the example 3 in the question. I'm wondering why the output of [1,2,3,4,4,5] is false. I'm thinking that it can be split into two consecutive sequence as [1,2,4], [3,4,5].\\n\\nThanks for your help!"
                    },
                    {
                        "username": "zB0y",
                        "content": "one greater than previous\\nso 1, 2, 3 is correct because 2 is one greater than 1 and 3 is one greater than 2\\n1, 2, 4 is incorrect because while 4 is not one greater than 2"
                    },
                    {
                        "username": "MSR_Yang",
                        "content": "result should be false or just note the length of input  is guaranteed >= 6"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "1)Store frequency in map first.\\n2)iterate though nums and check if next two elements have freq>0\\n3)Always store the last element of subsequence in new map so that last few elements(in nums) can use it"
                    },
                    {
                        "username": "tkar123",
                        "content": "Why is it telling me that [1,2,3,4,5,6,4] is false? Shouldn\\'t it be true because you can split it into one subsequence: [1,2,3,4] where the 4 is the last 4 in the array and another subsequence [4,5,6] where that 4 is the first 4 that appears in the array?"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "its an invalid array it should be sorted in non decreasing order\\n"
                    },
                    {
                        "username": "user2049D",
                        "content": "[@laichbr](/laichbr) \nIn the contraints we have:\nnums is sorted in non-decreasing order.\n [1,2,3,4,5,6,4] is not a case."
                    },
                    {
                        "username": "laichbr",
                        "content": "You\\'re right, that should be a valid sequence"
                    }
                ]
            },
            {
                "id": 1564967,
                "content": [
                    {
                        "username": "hdlll",
                        "content": "Two test cases:\\n\\n[1,2,3,4,4,5] yields false\\n[1,2,3] yields true\\n\\nIf the original array without split can be a sub-sequence, then [1,2,3,4,4,5] can be a sub-sequence where 3 consecutive integers are present. So the result should be True.\\n\\nIf it's not, then how can [1,2,3] be True?"
                    },
                    {
                        "username": "_shiv_70",
                        "content": "one of the condition is given like this\\nEach subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer)\\n therefore here consecutive 4\\'s are violating this condition\\n"
                    },
                    {
                        "username": "RunRunCode",
                        "content": ">[1,2,3,4,5,6,6,8,9,9]\\n>Expected: false\\n\\nWhy [1,2,3] + [4,5,6,6,8,9,9] doesn't meet the requirement of \"each subsequences consist of at least 3 consecutive integers\"?\\n\\n>[1,2,3]\\n>Expected: true\\n\\nIf [1,2,3] without a split is considered as valid, then [1,2,3,4,4,5] as a whole should also be considered as valid. Becuase it contains 3 consecutive integers \"1,2,3\".\\n\\nThe answer might want to require the output subsequences to contain only consecutive numbers, but that's not what we read from the description (at least it's ambiguous) at this moment. And I don't want to guess the requirements from the test cases anyway."
                    },
                    {
                        "username": "110abidi",
                        "content": "I was a bit confused at the third example because I thought  [1,2,3,4,4,5] could be split into \\n\\n[1,2,4] and [3, 4, 5] and satisfy the condition. But the problem states: \"consecutive\". The reason why [1,2,4] doesn\\'t satisfy the condition is because 2,4 are not consecutive (it jumps from 2 to 4 instead of 2,3,4).\\n\\nHope that clarifies it for ya\\'ll."
                    },
                    {
                        "username": "roy14",
                        "content": "[1,2,3,4,4] returns false, but it still satisfies 'where each subsequence consists of at least 3 consecutive integers', it didn't ask for the whole subsequence to be consecutive."
                    },
                    {
                        "username": "Sykes",
                        "content": "I was using greedy to solve this and not passing case 178.\\nIt is hard to debug and I am lazy. If anyone once failed or is failing the same case, please share some thought. Thanks~"
                    },
                    {
                        "username": "ode",
                        "content": "I thought I understand it. But I am not sure now. \\n\\nIn description\\n\\tInput: [1,2,3,4,4,5]\\n\\tOutput: False\\n\\nIn test cases\\n\\tInput: [1,2,3]\\n\\tOutput: True\\n\\t\\nI do not even know where I lost it. Could you please explain how these examples fit into the description. Thank you.\\n\\t\\n\\t\\n\\n"
                    },
                    {
                        "username": "wei_wei_",
                        "content": "Hi, The first one doesn't fit according to first condition \"Each subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer).\" If you make 2 subsequences from ( 1,2,3,4,4,5) You might wanna make these: (1,2,4) and (3,4,5). The former one is not a consecutive subsequence. Or if you chose these two: (1,2,3) and (4,4,5), then the latter one is  not a consecutive subsequence."
                    },
                    {
                        "username": "peterlijobs",
                        "content": "Hi there, I have a question about the example 3 in the question. I'm wondering why the output of [1,2,3,4,4,5] is false. I'm thinking that it can be split into two consecutive sequence as [1,2,4], [3,4,5].\\n\\nThanks for your help!"
                    },
                    {
                        "username": "zB0y",
                        "content": "one greater than previous\\nso 1, 2, 3 is correct because 2 is one greater than 1 and 3 is one greater than 2\\n1, 2, 4 is incorrect because while 4 is not one greater than 2"
                    },
                    {
                        "username": "MSR_Yang",
                        "content": "result should be false or just note the length of input  is guaranteed >= 6"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "1)Store frequency in map first.\\n2)iterate though nums and check if next two elements have freq>0\\n3)Always store the last element of subsequence in new map so that last few elements(in nums) can use it"
                    },
                    {
                        "username": "tkar123",
                        "content": "Why is it telling me that [1,2,3,4,5,6,4] is false? Shouldn\\'t it be true because you can split it into one subsequence: [1,2,3,4] where the 4 is the last 4 in the array and another subsequence [4,5,6] where that 4 is the first 4 that appears in the array?"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "its an invalid array it should be sorted in non decreasing order\\n"
                    },
                    {
                        "username": "user2049D",
                        "content": "[@laichbr](/laichbr) \nIn the contraints we have:\nnums is sorted in non-decreasing order.\n [1,2,3,4,5,6,4] is not a case."
                    },
                    {
                        "username": "laichbr",
                        "content": "You\\'re right, that should be a valid sequence"
                    }
                ]
            },
            {
                "id": 1565954,
                "content": [
                    {
                        "username": "hdlll",
                        "content": "Two test cases:\\n\\n[1,2,3,4,4,5] yields false\\n[1,2,3] yields true\\n\\nIf the original array without split can be a sub-sequence, then [1,2,3,4,4,5] can be a sub-sequence where 3 consecutive integers are present. So the result should be True.\\n\\nIf it's not, then how can [1,2,3] be True?"
                    },
                    {
                        "username": "_shiv_70",
                        "content": "one of the condition is given like this\\nEach subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer)\\n therefore here consecutive 4\\'s are violating this condition\\n"
                    },
                    {
                        "username": "RunRunCode",
                        "content": ">[1,2,3,4,5,6,6,8,9,9]\\n>Expected: false\\n\\nWhy [1,2,3] + [4,5,6,6,8,9,9] doesn't meet the requirement of \"each subsequences consist of at least 3 consecutive integers\"?\\n\\n>[1,2,3]\\n>Expected: true\\n\\nIf [1,2,3] without a split is considered as valid, then [1,2,3,4,4,5] as a whole should also be considered as valid. Becuase it contains 3 consecutive integers \"1,2,3\".\\n\\nThe answer might want to require the output subsequences to contain only consecutive numbers, but that's not what we read from the description (at least it's ambiguous) at this moment. And I don't want to guess the requirements from the test cases anyway."
                    },
                    {
                        "username": "110abidi",
                        "content": "I was a bit confused at the third example because I thought  [1,2,3,4,4,5] could be split into \\n\\n[1,2,4] and [3, 4, 5] and satisfy the condition. But the problem states: \"consecutive\". The reason why [1,2,4] doesn\\'t satisfy the condition is because 2,4 are not consecutive (it jumps from 2 to 4 instead of 2,3,4).\\n\\nHope that clarifies it for ya\\'ll."
                    },
                    {
                        "username": "roy14",
                        "content": "[1,2,3,4,4] returns false, but it still satisfies 'where each subsequence consists of at least 3 consecutive integers', it didn't ask for the whole subsequence to be consecutive."
                    },
                    {
                        "username": "Sykes",
                        "content": "I was using greedy to solve this and not passing case 178.\\nIt is hard to debug and I am lazy. If anyone once failed or is failing the same case, please share some thought. Thanks~"
                    },
                    {
                        "username": "ode",
                        "content": "I thought I understand it. But I am not sure now. \\n\\nIn description\\n\\tInput: [1,2,3,4,4,5]\\n\\tOutput: False\\n\\nIn test cases\\n\\tInput: [1,2,3]\\n\\tOutput: True\\n\\t\\nI do not even know where I lost it. Could you please explain how these examples fit into the description. Thank you.\\n\\t\\n\\t\\n\\n"
                    },
                    {
                        "username": "wei_wei_",
                        "content": "Hi, The first one doesn't fit according to first condition \"Each subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer).\" If you make 2 subsequences from ( 1,2,3,4,4,5) You might wanna make these: (1,2,4) and (3,4,5). The former one is not a consecutive subsequence. Or if you chose these two: (1,2,3) and (4,4,5), then the latter one is  not a consecutive subsequence."
                    },
                    {
                        "username": "peterlijobs",
                        "content": "Hi there, I have a question about the example 3 in the question. I'm wondering why the output of [1,2,3,4,4,5] is false. I'm thinking that it can be split into two consecutive sequence as [1,2,4], [3,4,5].\\n\\nThanks for your help!"
                    },
                    {
                        "username": "zB0y",
                        "content": "one greater than previous\\nso 1, 2, 3 is correct because 2 is one greater than 1 and 3 is one greater than 2\\n1, 2, 4 is incorrect because while 4 is not one greater than 2"
                    },
                    {
                        "username": "MSR_Yang",
                        "content": "result should be false or just note the length of input  is guaranteed >= 6"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "1)Store frequency in map first.\\n2)iterate though nums and check if next two elements have freq>0\\n3)Always store the last element of subsequence in new map so that last few elements(in nums) can use it"
                    },
                    {
                        "username": "tkar123",
                        "content": "Why is it telling me that [1,2,3,4,5,6,4] is false? Shouldn\\'t it be true because you can split it into one subsequence: [1,2,3,4] where the 4 is the last 4 in the array and another subsequence [4,5,6] where that 4 is the first 4 that appears in the array?"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "its an invalid array it should be sorted in non decreasing order\\n"
                    },
                    {
                        "username": "user2049D",
                        "content": "[@laichbr](/laichbr) \nIn the contraints we have:\nnums is sorted in non-decreasing order.\n [1,2,3,4,5,6,4] is not a case."
                    },
                    {
                        "username": "laichbr",
                        "content": "You\\'re right, that should be a valid sequence"
                    }
                ]
            },
            {
                "id": 1568242,
                "content": [
                    {
                        "username": "hdlll",
                        "content": "Two test cases:\\n\\n[1,2,3,4,4,5] yields false\\n[1,2,3] yields true\\n\\nIf the original array without split can be a sub-sequence, then [1,2,3,4,4,5] can be a sub-sequence where 3 consecutive integers are present. So the result should be True.\\n\\nIf it's not, then how can [1,2,3] be True?"
                    },
                    {
                        "username": "_shiv_70",
                        "content": "one of the condition is given like this\\nEach subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer)\\n therefore here consecutive 4\\'s are violating this condition\\n"
                    },
                    {
                        "username": "RunRunCode",
                        "content": ">[1,2,3,4,5,6,6,8,9,9]\\n>Expected: false\\n\\nWhy [1,2,3] + [4,5,6,6,8,9,9] doesn't meet the requirement of \"each subsequences consist of at least 3 consecutive integers\"?\\n\\n>[1,2,3]\\n>Expected: true\\n\\nIf [1,2,3] without a split is considered as valid, then [1,2,3,4,4,5] as a whole should also be considered as valid. Becuase it contains 3 consecutive integers \"1,2,3\".\\n\\nThe answer might want to require the output subsequences to contain only consecutive numbers, but that's not what we read from the description (at least it's ambiguous) at this moment. And I don't want to guess the requirements from the test cases anyway."
                    },
                    {
                        "username": "110abidi",
                        "content": "I was a bit confused at the third example because I thought  [1,2,3,4,4,5] could be split into \\n\\n[1,2,4] and [3, 4, 5] and satisfy the condition. But the problem states: \"consecutive\". The reason why [1,2,4] doesn\\'t satisfy the condition is because 2,4 are not consecutive (it jumps from 2 to 4 instead of 2,3,4).\\n\\nHope that clarifies it for ya\\'ll."
                    },
                    {
                        "username": "roy14",
                        "content": "[1,2,3,4,4] returns false, but it still satisfies 'where each subsequence consists of at least 3 consecutive integers', it didn't ask for the whole subsequence to be consecutive."
                    },
                    {
                        "username": "Sykes",
                        "content": "I was using greedy to solve this and not passing case 178.\\nIt is hard to debug and I am lazy. If anyone once failed or is failing the same case, please share some thought. Thanks~"
                    },
                    {
                        "username": "ode",
                        "content": "I thought I understand it. But I am not sure now. \\n\\nIn description\\n\\tInput: [1,2,3,4,4,5]\\n\\tOutput: False\\n\\nIn test cases\\n\\tInput: [1,2,3]\\n\\tOutput: True\\n\\t\\nI do not even know where I lost it. Could you please explain how these examples fit into the description. Thank you.\\n\\t\\n\\t\\n\\n"
                    },
                    {
                        "username": "wei_wei_",
                        "content": "Hi, The first one doesn't fit according to first condition \"Each subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer).\" If you make 2 subsequences from ( 1,2,3,4,4,5) You might wanna make these: (1,2,4) and (3,4,5). The former one is not a consecutive subsequence. Or if you chose these two: (1,2,3) and (4,4,5), then the latter one is  not a consecutive subsequence."
                    },
                    {
                        "username": "peterlijobs",
                        "content": "Hi there, I have a question about the example 3 in the question. I'm wondering why the output of [1,2,3,4,4,5] is false. I'm thinking that it can be split into two consecutive sequence as [1,2,4], [3,4,5].\\n\\nThanks for your help!"
                    },
                    {
                        "username": "zB0y",
                        "content": "one greater than previous\\nso 1, 2, 3 is correct because 2 is one greater than 1 and 3 is one greater than 2\\n1, 2, 4 is incorrect because while 4 is not one greater than 2"
                    },
                    {
                        "username": "MSR_Yang",
                        "content": "result should be false or just note the length of input  is guaranteed >= 6"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "1)Store frequency in map first.\\n2)iterate though nums and check if next two elements have freq>0\\n3)Always store the last element of subsequence in new map so that last few elements(in nums) can use it"
                    },
                    {
                        "username": "tkar123",
                        "content": "Why is it telling me that [1,2,3,4,5,6,4] is false? Shouldn\\'t it be true because you can split it into one subsequence: [1,2,3,4] where the 4 is the last 4 in the array and another subsequence [4,5,6] where that 4 is the first 4 that appears in the array?"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "its an invalid array it should be sorted in non decreasing order\\n"
                    },
                    {
                        "username": "user2049D",
                        "content": "[@laichbr](/laichbr) \nIn the contraints we have:\nnums is sorted in non-decreasing order.\n [1,2,3,4,5,6,4] is not a case."
                    },
                    {
                        "username": "laichbr",
                        "content": "You\\'re right, that should be a valid sequence"
                    }
                ]
            },
            {
                "id": 1567278,
                "content": [
                    {
                        "username": "hdlll",
                        "content": "Two test cases:\\n\\n[1,2,3,4,4,5] yields false\\n[1,2,3] yields true\\n\\nIf the original array without split can be a sub-sequence, then [1,2,3,4,4,5] can be a sub-sequence where 3 consecutive integers are present. So the result should be True.\\n\\nIf it's not, then how can [1,2,3] be True?"
                    },
                    {
                        "username": "_shiv_70",
                        "content": "one of the condition is given like this\\nEach subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer)\\n therefore here consecutive 4\\'s are violating this condition\\n"
                    },
                    {
                        "username": "RunRunCode",
                        "content": ">[1,2,3,4,5,6,6,8,9,9]\\n>Expected: false\\n\\nWhy [1,2,3] + [4,5,6,6,8,9,9] doesn't meet the requirement of \"each subsequences consist of at least 3 consecutive integers\"?\\n\\n>[1,2,3]\\n>Expected: true\\n\\nIf [1,2,3] without a split is considered as valid, then [1,2,3,4,4,5] as a whole should also be considered as valid. Becuase it contains 3 consecutive integers \"1,2,3\".\\n\\nThe answer might want to require the output subsequences to contain only consecutive numbers, but that's not what we read from the description (at least it's ambiguous) at this moment. And I don't want to guess the requirements from the test cases anyway."
                    },
                    {
                        "username": "110abidi",
                        "content": "I was a bit confused at the third example because I thought  [1,2,3,4,4,5] could be split into \\n\\n[1,2,4] and [3, 4, 5] and satisfy the condition. But the problem states: \"consecutive\". The reason why [1,2,4] doesn\\'t satisfy the condition is because 2,4 are not consecutive (it jumps from 2 to 4 instead of 2,3,4).\\n\\nHope that clarifies it for ya\\'ll."
                    },
                    {
                        "username": "roy14",
                        "content": "[1,2,3,4,4] returns false, but it still satisfies 'where each subsequence consists of at least 3 consecutive integers', it didn't ask for the whole subsequence to be consecutive."
                    },
                    {
                        "username": "Sykes",
                        "content": "I was using greedy to solve this and not passing case 178.\\nIt is hard to debug and I am lazy. If anyone once failed or is failing the same case, please share some thought. Thanks~"
                    },
                    {
                        "username": "ode",
                        "content": "I thought I understand it. But I am not sure now. \\n\\nIn description\\n\\tInput: [1,2,3,4,4,5]\\n\\tOutput: False\\n\\nIn test cases\\n\\tInput: [1,2,3]\\n\\tOutput: True\\n\\t\\nI do not even know where I lost it. Could you please explain how these examples fit into the description. Thank you.\\n\\t\\n\\t\\n\\n"
                    },
                    {
                        "username": "wei_wei_",
                        "content": "Hi, The first one doesn't fit according to first condition \"Each subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer).\" If you make 2 subsequences from ( 1,2,3,4,4,5) You might wanna make these: (1,2,4) and (3,4,5). The former one is not a consecutive subsequence. Or if you chose these two: (1,2,3) and (4,4,5), then the latter one is  not a consecutive subsequence."
                    },
                    {
                        "username": "peterlijobs",
                        "content": "Hi there, I have a question about the example 3 in the question. I'm wondering why the output of [1,2,3,4,4,5] is false. I'm thinking that it can be split into two consecutive sequence as [1,2,4], [3,4,5].\\n\\nThanks for your help!"
                    },
                    {
                        "username": "zB0y",
                        "content": "one greater than previous\\nso 1, 2, 3 is correct because 2 is one greater than 1 and 3 is one greater than 2\\n1, 2, 4 is incorrect because while 4 is not one greater than 2"
                    },
                    {
                        "username": "MSR_Yang",
                        "content": "result should be false or just note the length of input  is guaranteed >= 6"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "1)Store frequency in map first.\\n2)iterate though nums and check if next two elements have freq>0\\n3)Always store the last element of subsequence in new map so that last few elements(in nums) can use it"
                    },
                    {
                        "username": "tkar123",
                        "content": "Why is it telling me that [1,2,3,4,5,6,4] is false? Shouldn\\'t it be true because you can split it into one subsequence: [1,2,3,4] where the 4 is the last 4 in the array and another subsequence [4,5,6] where that 4 is the first 4 that appears in the array?"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "its an invalid array it should be sorted in non decreasing order\\n"
                    },
                    {
                        "username": "user2049D",
                        "content": "[@laichbr](/laichbr) \nIn the contraints we have:\nnums is sorted in non-decreasing order.\n [1,2,3,4,5,6,4] is not a case."
                    },
                    {
                        "username": "laichbr",
                        "content": "You\\'re right, that should be a valid sequence"
                    }
                ]
            },
            {
                "id": 1567994,
                "content": [
                    {
                        "username": "hdlll",
                        "content": "Two test cases:\\n\\n[1,2,3,4,4,5] yields false\\n[1,2,3] yields true\\n\\nIf the original array without split can be a sub-sequence, then [1,2,3,4,4,5] can be a sub-sequence where 3 consecutive integers are present. So the result should be True.\\n\\nIf it's not, then how can [1,2,3] be True?"
                    },
                    {
                        "username": "_shiv_70",
                        "content": "one of the condition is given like this\\nEach subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer)\\n therefore here consecutive 4\\'s are violating this condition\\n"
                    },
                    {
                        "username": "RunRunCode",
                        "content": ">[1,2,3,4,5,6,6,8,9,9]\\n>Expected: false\\n\\nWhy [1,2,3] + [4,5,6,6,8,9,9] doesn't meet the requirement of \"each subsequences consist of at least 3 consecutive integers\"?\\n\\n>[1,2,3]\\n>Expected: true\\n\\nIf [1,2,3] without a split is considered as valid, then [1,2,3,4,4,5] as a whole should also be considered as valid. Becuase it contains 3 consecutive integers \"1,2,3\".\\n\\nThe answer might want to require the output subsequences to contain only consecutive numbers, but that's not what we read from the description (at least it's ambiguous) at this moment. And I don't want to guess the requirements from the test cases anyway."
                    },
                    {
                        "username": "110abidi",
                        "content": "I was a bit confused at the third example because I thought  [1,2,3,4,4,5] could be split into \\n\\n[1,2,4] and [3, 4, 5] and satisfy the condition. But the problem states: \"consecutive\". The reason why [1,2,4] doesn\\'t satisfy the condition is because 2,4 are not consecutive (it jumps from 2 to 4 instead of 2,3,4).\\n\\nHope that clarifies it for ya\\'ll."
                    },
                    {
                        "username": "roy14",
                        "content": "[1,2,3,4,4] returns false, but it still satisfies 'where each subsequence consists of at least 3 consecutive integers', it didn't ask for the whole subsequence to be consecutive."
                    },
                    {
                        "username": "Sykes",
                        "content": "I was using greedy to solve this and not passing case 178.\\nIt is hard to debug and I am lazy. If anyone once failed or is failing the same case, please share some thought. Thanks~"
                    },
                    {
                        "username": "ode",
                        "content": "I thought I understand it. But I am not sure now. \\n\\nIn description\\n\\tInput: [1,2,3,4,4,5]\\n\\tOutput: False\\n\\nIn test cases\\n\\tInput: [1,2,3]\\n\\tOutput: True\\n\\t\\nI do not even know where I lost it. Could you please explain how these examples fit into the description. Thank you.\\n\\t\\n\\t\\n\\n"
                    },
                    {
                        "username": "wei_wei_",
                        "content": "Hi, The first one doesn't fit according to first condition \"Each subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer).\" If you make 2 subsequences from ( 1,2,3,4,4,5) You might wanna make these: (1,2,4) and (3,4,5). The former one is not a consecutive subsequence. Or if you chose these two: (1,2,3) and (4,4,5), then the latter one is  not a consecutive subsequence."
                    },
                    {
                        "username": "peterlijobs",
                        "content": "Hi there, I have a question about the example 3 in the question. I'm wondering why the output of [1,2,3,4,4,5] is false. I'm thinking that it can be split into two consecutive sequence as [1,2,4], [3,4,5].\\n\\nThanks for your help!"
                    },
                    {
                        "username": "zB0y",
                        "content": "one greater than previous\\nso 1, 2, 3 is correct because 2 is one greater than 1 and 3 is one greater than 2\\n1, 2, 4 is incorrect because while 4 is not one greater than 2"
                    },
                    {
                        "username": "MSR_Yang",
                        "content": "result should be false or just note the length of input  is guaranteed >= 6"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "1)Store frequency in map first.\\n2)iterate though nums and check if next two elements have freq>0\\n3)Always store the last element of subsequence in new map so that last few elements(in nums) can use it"
                    },
                    {
                        "username": "tkar123",
                        "content": "Why is it telling me that [1,2,3,4,5,6,4] is false? Shouldn\\'t it be true because you can split it into one subsequence: [1,2,3,4] where the 4 is the last 4 in the array and another subsequence [4,5,6] where that 4 is the first 4 that appears in the array?"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "its an invalid array it should be sorted in non decreasing order\\n"
                    },
                    {
                        "username": "user2049D",
                        "content": "[@laichbr](/laichbr) \nIn the contraints we have:\nnums is sorted in non-decreasing order.\n [1,2,3,4,5,6,4] is not a case."
                    },
                    {
                        "username": "laichbr",
                        "content": "You\\'re right, that should be a valid sequence"
                    }
                ]
            },
            {
                "id": 1569835,
                "content": [
                    {
                        "username": "hdlll",
                        "content": "Two test cases:\\n\\n[1,2,3,4,4,5] yields false\\n[1,2,3] yields true\\n\\nIf the original array without split can be a sub-sequence, then [1,2,3,4,4,5] can be a sub-sequence where 3 consecutive integers are present. So the result should be True.\\n\\nIf it's not, then how can [1,2,3] be True?"
                    },
                    {
                        "username": "_shiv_70",
                        "content": "one of the condition is given like this\\nEach subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer)\\n therefore here consecutive 4\\'s are violating this condition\\n"
                    },
                    {
                        "username": "RunRunCode",
                        "content": ">[1,2,3,4,5,6,6,8,9,9]\\n>Expected: false\\n\\nWhy [1,2,3] + [4,5,6,6,8,9,9] doesn't meet the requirement of \"each subsequences consist of at least 3 consecutive integers\"?\\n\\n>[1,2,3]\\n>Expected: true\\n\\nIf [1,2,3] without a split is considered as valid, then [1,2,3,4,4,5] as a whole should also be considered as valid. Becuase it contains 3 consecutive integers \"1,2,3\".\\n\\nThe answer might want to require the output subsequences to contain only consecutive numbers, but that's not what we read from the description (at least it's ambiguous) at this moment. And I don't want to guess the requirements from the test cases anyway."
                    },
                    {
                        "username": "110abidi",
                        "content": "I was a bit confused at the third example because I thought  [1,2,3,4,4,5] could be split into \\n\\n[1,2,4] and [3, 4, 5] and satisfy the condition. But the problem states: \"consecutive\". The reason why [1,2,4] doesn\\'t satisfy the condition is because 2,4 are not consecutive (it jumps from 2 to 4 instead of 2,3,4).\\n\\nHope that clarifies it for ya\\'ll."
                    },
                    {
                        "username": "roy14",
                        "content": "[1,2,3,4,4] returns false, but it still satisfies 'where each subsequence consists of at least 3 consecutive integers', it didn't ask for the whole subsequence to be consecutive."
                    },
                    {
                        "username": "Sykes",
                        "content": "I was using greedy to solve this and not passing case 178.\\nIt is hard to debug and I am lazy. If anyone once failed or is failing the same case, please share some thought. Thanks~"
                    },
                    {
                        "username": "ode",
                        "content": "I thought I understand it. But I am not sure now. \\n\\nIn description\\n\\tInput: [1,2,3,4,4,5]\\n\\tOutput: False\\n\\nIn test cases\\n\\tInput: [1,2,3]\\n\\tOutput: True\\n\\t\\nI do not even know where I lost it. Could you please explain how these examples fit into the description. Thank you.\\n\\t\\n\\t\\n\\n"
                    },
                    {
                        "username": "wei_wei_",
                        "content": "Hi, The first one doesn't fit according to first condition \"Each subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer).\" If you make 2 subsequences from ( 1,2,3,4,4,5) You might wanna make these: (1,2,4) and (3,4,5). The former one is not a consecutive subsequence. Or if you chose these two: (1,2,3) and (4,4,5), then the latter one is  not a consecutive subsequence."
                    },
                    {
                        "username": "peterlijobs",
                        "content": "Hi there, I have a question about the example 3 in the question. I'm wondering why the output of [1,2,3,4,4,5] is false. I'm thinking that it can be split into two consecutive sequence as [1,2,4], [3,4,5].\\n\\nThanks for your help!"
                    },
                    {
                        "username": "zB0y",
                        "content": "one greater than previous\\nso 1, 2, 3 is correct because 2 is one greater than 1 and 3 is one greater than 2\\n1, 2, 4 is incorrect because while 4 is not one greater than 2"
                    },
                    {
                        "username": "MSR_Yang",
                        "content": "result should be false or just note the length of input  is guaranteed >= 6"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "1)Store frequency in map first.\\n2)iterate though nums and check if next two elements have freq>0\\n3)Always store the last element of subsequence in new map so that last few elements(in nums) can use it"
                    },
                    {
                        "username": "tkar123",
                        "content": "Why is it telling me that [1,2,3,4,5,6,4] is false? Shouldn\\'t it be true because you can split it into one subsequence: [1,2,3,4] where the 4 is the last 4 in the array and another subsequence [4,5,6] where that 4 is the first 4 that appears in the array?"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "its an invalid array it should be sorted in non decreasing order\\n"
                    },
                    {
                        "username": "user2049D",
                        "content": "[@laichbr](/laichbr) \nIn the contraints we have:\nnums is sorted in non-decreasing order.\n [1,2,3,4,5,6,4] is not a case."
                    },
                    {
                        "username": "laichbr",
                        "content": "You\\'re right, that should be a valid sequence"
                    }
                ]
            },
            {
                "id": 1567995,
                "content": [
                    {
                        "username": "hdlll",
                        "content": "Two test cases:\\n\\n[1,2,3,4,4,5] yields false\\n[1,2,3] yields true\\n\\nIf the original array without split can be a sub-sequence, then [1,2,3,4,4,5] can be a sub-sequence where 3 consecutive integers are present. So the result should be True.\\n\\nIf it's not, then how can [1,2,3] be True?"
                    },
                    {
                        "username": "_shiv_70",
                        "content": "one of the condition is given like this\\nEach subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer)\\n therefore here consecutive 4\\'s are violating this condition\\n"
                    },
                    {
                        "username": "RunRunCode",
                        "content": ">[1,2,3,4,5,6,6,8,9,9]\\n>Expected: false\\n\\nWhy [1,2,3] + [4,5,6,6,8,9,9] doesn't meet the requirement of \"each subsequences consist of at least 3 consecutive integers\"?\\n\\n>[1,2,3]\\n>Expected: true\\n\\nIf [1,2,3] without a split is considered as valid, then [1,2,3,4,4,5] as a whole should also be considered as valid. Becuase it contains 3 consecutive integers \"1,2,3\".\\n\\nThe answer might want to require the output subsequences to contain only consecutive numbers, but that's not what we read from the description (at least it's ambiguous) at this moment. And I don't want to guess the requirements from the test cases anyway."
                    },
                    {
                        "username": "110abidi",
                        "content": "I was a bit confused at the third example because I thought  [1,2,3,4,4,5] could be split into \\n\\n[1,2,4] and [3, 4, 5] and satisfy the condition. But the problem states: \"consecutive\". The reason why [1,2,4] doesn\\'t satisfy the condition is because 2,4 are not consecutive (it jumps from 2 to 4 instead of 2,3,4).\\n\\nHope that clarifies it for ya\\'ll."
                    },
                    {
                        "username": "roy14",
                        "content": "[1,2,3,4,4] returns false, but it still satisfies 'where each subsequence consists of at least 3 consecutive integers', it didn't ask for the whole subsequence to be consecutive."
                    },
                    {
                        "username": "Sykes",
                        "content": "I was using greedy to solve this and not passing case 178.\\nIt is hard to debug and I am lazy. If anyone once failed or is failing the same case, please share some thought. Thanks~"
                    },
                    {
                        "username": "ode",
                        "content": "I thought I understand it. But I am not sure now. \\n\\nIn description\\n\\tInput: [1,2,3,4,4,5]\\n\\tOutput: False\\n\\nIn test cases\\n\\tInput: [1,2,3]\\n\\tOutput: True\\n\\t\\nI do not even know where I lost it. Could you please explain how these examples fit into the description. Thank you.\\n\\t\\n\\t\\n\\n"
                    },
                    {
                        "username": "wei_wei_",
                        "content": "Hi, The first one doesn't fit according to first condition \"Each subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer).\" If you make 2 subsequences from ( 1,2,3,4,4,5) You might wanna make these: (1,2,4) and (3,4,5). The former one is not a consecutive subsequence. Or if you chose these two: (1,2,3) and (4,4,5), then the latter one is  not a consecutive subsequence."
                    },
                    {
                        "username": "peterlijobs",
                        "content": "Hi there, I have a question about the example 3 in the question. I'm wondering why the output of [1,2,3,4,4,5] is false. I'm thinking that it can be split into two consecutive sequence as [1,2,4], [3,4,5].\\n\\nThanks for your help!"
                    },
                    {
                        "username": "zB0y",
                        "content": "one greater than previous\\nso 1, 2, 3 is correct because 2 is one greater than 1 and 3 is one greater than 2\\n1, 2, 4 is incorrect because while 4 is not one greater than 2"
                    },
                    {
                        "username": "MSR_Yang",
                        "content": "result should be false or just note the length of input  is guaranteed >= 6"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "1)Store frequency in map first.\\n2)iterate though nums and check if next two elements have freq>0\\n3)Always store the last element of subsequence in new map so that last few elements(in nums) can use it"
                    },
                    {
                        "username": "tkar123",
                        "content": "Why is it telling me that [1,2,3,4,5,6,4] is false? Shouldn\\'t it be true because you can split it into one subsequence: [1,2,3,4] where the 4 is the last 4 in the array and another subsequence [4,5,6] where that 4 is the first 4 that appears in the array?"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "its an invalid array it should be sorted in non decreasing order\\n"
                    },
                    {
                        "username": "user2049D",
                        "content": "[@laichbr](/laichbr) \nIn the contraints we have:\nnums is sorted in non-decreasing order.\n [1,2,3,4,5,6,4] is not a case."
                    },
                    {
                        "username": "laichbr",
                        "content": "You\\'re right, that should be a valid sequence"
                    }
                ]
            },
            {
                "id": 1566268,
                "content": [
                    {
                        "username": "hdlll",
                        "content": "Two test cases:\\n\\n[1,2,3,4,4,5] yields false\\n[1,2,3] yields true\\n\\nIf the original array without split can be a sub-sequence, then [1,2,3,4,4,5] can be a sub-sequence where 3 consecutive integers are present. So the result should be True.\\n\\nIf it's not, then how can [1,2,3] be True?"
                    },
                    {
                        "username": "_shiv_70",
                        "content": "one of the condition is given like this\\nEach subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer)\\n therefore here consecutive 4\\'s are violating this condition\\n"
                    },
                    {
                        "username": "RunRunCode",
                        "content": ">[1,2,3,4,5,6,6,8,9,9]\\n>Expected: false\\n\\nWhy [1,2,3] + [4,5,6,6,8,9,9] doesn't meet the requirement of \"each subsequences consist of at least 3 consecutive integers\"?\\n\\n>[1,2,3]\\n>Expected: true\\n\\nIf [1,2,3] without a split is considered as valid, then [1,2,3,4,4,5] as a whole should also be considered as valid. Becuase it contains 3 consecutive integers \"1,2,3\".\\n\\nThe answer might want to require the output subsequences to contain only consecutive numbers, but that's not what we read from the description (at least it's ambiguous) at this moment. And I don't want to guess the requirements from the test cases anyway."
                    },
                    {
                        "username": "110abidi",
                        "content": "I was a bit confused at the third example because I thought  [1,2,3,4,4,5] could be split into \\n\\n[1,2,4] and [3, 4, 5] and satisfy the condition. But the problem states: \"consecutive\". The reason why [1,2,4] doesn\\'t satisfy the condition is because 2,4 are not consecutive (it jumps from 2 to 4 instead of 2,3,4).\\n\\nHope that clarifies it for ya\\'ll."
                    },
                    {
                        "username": "roy14",
                        "content": "[1,2,3,4,4] returns false, but it still satisfies 'where each subsequence consists of at least 3 consecutive integers', it didn't ask for the whole subsequence to be consecutive."
                    },
                    {
                        "username": "Sykes",
                        "content": "I was using greedy to solve this and not passing case 178.\\nIt is hard to debug and I am lazy. If anyone once failed or is failing the same case, please share some thought. Thanks~"
                    },
                    {
                        "username": "ode",
                        "content": "I thought I understand it. But I am not sure now. \\n\\nIn description\\n\\tInput: [1,2,3,4,4,5]\\n\\tOutput: False\\n\\nIn test cases\\n\\tInput: [1,2,3]\\n\\tOutput: True\\n\\t\\nI do not even know where I lost it. Could you please explain how these examples fit into the description. Thank you.\\n\\t\\n\\t\\n\\n"
                    },
                    {
                        "username": "wei_wei_",
                        "content": "Hi, The first one doesn't fit according to first condition \"Each subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer).\" If you make 2 subsequences from ( 1,2,3,4,4,5) You might wanna make these: (1,2,4) and (3,4,5). The former one is not a consecutive subsequence. Or if you chose these two: (1,2,3) and (4,4,5), then the latter one is  not a consecutive subsequence."
                    },
                    {
                        "username": "peterlijobs",
                        "content": "Hi there, I have a question about the example 3 in the question. I'm wondering why the output of [1,2,3,4,4,5] is false. I'm thinking that it can be split into two consecutive sequence as [1,2,4], [3,4,5].\\n\\nThanks for your help!"
                    },
                    {
                        "username": "zB0y",
                        "content": "one greater than previous\\nso 1, 2, 3 is correct because 2 is one greater than 1 and 3 is one greater than 2\\n1, 2, 4 is incorrect because while 4 is not one greater than 2"
                    },
                    {
                        "username": "MSR_Yang",
                        "content": "result should be false or just note the length of input  is guaranteed >= 6"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "1)Store frequency in map first.\\n2)iterate though nums and check if next two elements have freq>0\\n3)Always store the last element of subsequence in new map so that last few elements(in nums) can use it"
                    },
                    {
                        "username": "tkar123",
                        "content": "Why is it telling me that [1,2,3,4,5,6,4] is false? Shouldn\\'t it be true because you can split it into one subsequence: [1,2,3,4] where the 4 is the last 4 in the array and another subsequence [4,5,6] where that 4 is the first 4 that appears in the array?"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "its an invalid array it should be sorted in non decreasing order\\n"
                    },
                    {
                        "username": "user2049D",
                        "content": "[@laichbr](/laichbr) \nIn the contraints we have:\nnums is sorted in non-decreasing order.\n [1,2,3,4,5,6,4] is not a case."
                    },
                    {
                        "username": "laichbr",
                        "content": "You\\'re right, that should be a valid sequence"
                    }
                ]
            },
            {
                "id": 1754001,
                "content": [
                    {
                        "username": "hdlll",
                        "content": "Two test cases:\\n\\n[1,2,3,4,4,5] yields false\\n[1,2,3] yields true\\n\\nIf the original array without split can be a sub-sequence, then [1,2,3,4,4,5] can be a sub-sequence where 3 consecutive integers are present. So the result should be True.\\n\\nIf it's not, then how can [1,2,3] be True?"
                    },
                    {
                        "username": "_shiv_70",
                        "content": "one of the condition is given like this\\nEach subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer)\\n therefore here consecutive 4\\'s are violating this condition\\n"
                    },
                    {
                        "username": "RunRunCode",
                        "content": ">[1,2,3,4,5,6,6,8,9,9]\\n>Expected: false\\n\\nWhy [1,2,3] + [4,5,6,6,8,9,9] doesn't meet the requirement of \"each subsequences consist of at least 3 consecutive integers\"?\\n\\n>[1,2,3]\\n>Expected: true\\n\\nIf [1,2,3] without a split is considered as valid, then [1,2,3,4,4,5] as a whole should also be considered as valid. Becuase it contains 3 consecutive integers \"1,2,3\".\\n\\nThe answer might want to require the output subsequences to contain only consecutive numbers, but that's not what we read from the description (at least it's ambiguous) at this moment. And I don't want to guess the requirements from the test cases anyway."
                    },
                    {
                        "username": "110abidi",
                        "content": "I was a bit confused at the third example because I thought  [1,2,3,4,4,5] could be split into \\n\\n[1,2,4] and [3, 4, 5] and satisfy the condition. But the problem states: \"consecutive\". The reason why [1,2,4] doesn\\'t satisfy the condition is because 2,4 are not consecutive (it jumps from 2 to 4 instead of 2,3,4).\\n\\nHope that clarifies it for ya\\'ll."
                    },
                    {
                        "username": "roy14",
                        "content": "[1,2,3,4,4] returns false, but it still satisfies 'where each subsequence consists of at least 3 consecutive integers', it didn't ask for the whole subsequence to be consecutive."
                    },
                    {
                        "username": "Sykes",
                        "content": "I was using greedy to solve this and not passing case 178.\\nIt is hard to debug and I am lazy. If anyone once failed or is failing the same case, please share some thought. Thanks~"
                    },
                    {
                        "username": "ode",
                        "content": "I thought I understand it. But I am not sure now. \\n\\nIn description\\n\\tInput: [1,2,3,4,4,5]\\n\\tOutput: False\\n\\nIn test cases\\n\\tInput: [1,2,3]\\n\\tOutput: True\\n\\t\\nI do not even know where I lost it. Could you please explain how these examples fit into the description. Thank you.\\n\\t\\n\\t\\n\\n"
                    },
                    {
                        "username": "wei_wei_",
                        "content": "Hi, The first one doesn't fit according to first condition \"Each subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer).\" If you make 2 subsequences from ( 1,2,3,4,4,5) You might wanna make these: (1,2,4) and (3,4,5). The former one is not a consecutive subsequence. Or if you chose these two: (1,2,3) and (4,4,5), then the latter one is  not a consecutive subsequence."
                    },
                    {
                        "username": "peterlijobs",
                        "content": "Hi there, I have a question about the example 3 in the question. I'm wondering why the output of [1,2,3,4,4,5] is false. I'm thinking that it can be split into two consecutive sequence as [1,2,4], [3,4,5].\\n\\nThanks for your help!"
                    },
                    {
                        "username": "zB0y",
                        "content": "one greater than previous\\nso 1, 2, 3 is correct because 2 is one greater than 1 and 3 is one greater than 2\\n1, 2, 4 is incorrect because while 4 is not one greater than 2"
                    },
                    {
                        "username": "MSR_Yang",
                        "content": "result should be false or just note the length of input  is guaranteed >= 6"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "1)Store frequency in map first.\\n2)iterate though nums and check if next two elements have freq>0\\n3)Always store the last element of subsequence in new map so that last few elements(in nums) can use it"
                    },
                    {
                        "username": "tkar123",
                        "content": "Why is it telling me that [1,2,3,4,5,6,4] is false? Shouldn\\'t it be true because you can split it into one subsequence: [1,2,3,4] where the 4 is the last 4 in the array and another subsequence [4,5,6] where that 4 is the first 4 that appears in the array?"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "its an invalid array it should be sorted in non decreasing order\\n"
                    },
                    {
                        "username": "user2049D",
                        "content": "[@laichbr](/laichbr) \nIn the contraints we have:\nnums is sorted in non-decreasing order.\n [1,2,3,4,5,6,4] is not a case."
                    },
                    {
                        "username": "laichbr",
                        "content": "You\\'re right, that should be a valid sequence"
                    }
                ]
            },
            {
                "id": 1573328,
                "content": [
                    {
                        "username": "hdlll",
                        "content": "Two test cases:\\n\\n[1,2,3,4,4,5] yields false\\n[1,2,3] yields true\\n\\nIf the original array without split can be a sub-sequence, then [1,2,3,4,4,5] can be a sub-sequence where 3 consecutive integers are present. So the result should be True.\\n\\nIf it's not, then how can [1,2,3] be True?"
                    },
                    {
                        "username": "_shiv_70",
                        "content": "one of the condition is given like this\\nEach subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer)\\n therefore here consecutive 4\\'s are violating this condition\\n"
                    },
                    {
                        "username": "RunRunCode",
                        "content": ">[1,2,3,4,5,6,6,8,9,9]\\n>Expected: false\\n\\nWhy [1,2,3] + [4,5,6,6,8,9,9] doesn't meet the requirement of \"each subsequences consist of at least 3 consecutive integers\"?\\n\\n>[1,2,3]\\n>Expected: true\\n\\nIf [1,2,3] without a split is considered as valid, then [1,2,3,4,4,5] as a whole should also be considered as valid. Becuase it contains 3 consecutive integers \"1,2,3\".\\n\\nThe answer might want to require the output subsequences to contain only consecutive numbers, but that's not what we read from the description (at least it's ambiguous) at this moment. And I don't want to guess the requirements from the test cases anyway."
                    },
                    {
                        "username": "110abidi",
                        "content": "I was a bit confused at the third example because I thought  [1,2,3,4,4,5] could be split into \\n\\n[1,2,4] and [3, 4, 5] and satisfy the condition. But the problem states: \"consecutive\". The reason why [1,2,4] doesn\\'t satisfy the condition is because 2,4 are not consecutive (it jumps from 2 to 4 instead of 2,3,4).\\n\\nHope that clarifies it for ya\\'ll."
                    },
                    {
                        "username": "roy14",
                        "content": "[1,2,3,4,4] returns false, but it still satisfies 'where each subsequence consists of at least 3 consecutive integers', it didn't ask for the whole subsequence to be consecutive."
                    },
                    {
                        "username": "Sykes",
                        "content": "I was using greedy to solve this and not passing case 178.\\nIt is hard to debug and I am lazy. If anyone once failed or is failing the same case, please share some thought. Thanks~"
                    },
                    {
                        "username": "ode",
                        "content": "I thought I understand it. But I am not sure now. \\n\\nIn description\\n\\tInput: [1,2,3,4,4,5]\\n\\tOutput: False\\n\\nIn test cases\\n\\tInput: [1,2,3]\\n\\tOutput: True\\n\\t\\nI do not even know where I lost it. Could you please explain how these examples fit into the description. Thank you.\\n\\t\\n\\t\\n\\n"
                    },
                    {
                        "username": "wei_wei_",
                        "content": "Hi, The first one doesn't fit according to first condition \"Each subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer).\" If you make 2 subsequences from ( 1,2,3,4,4,5) You might wanna make these: (1,2,4) and (3,4,5). The former one is not a consecutive subsequence. Or if you chose these two: (1,2,3) and (4,4,5), then the latter one is  not a consecutive subsequence."
                    },
                    {
                        "username": "peterlijobs",
                        "content": "Hi there, I have a question about the example 3 in the question. I'm wondering why the output of [1,2,3,4,4,5] is false. I'm thinking that it can be split into two consecutive sequence as [1,2,4], [3,4,5].\\n\\nThanks for your help!"
                    },
                    {
                        "username": "zB0y",
                        "content": "one greater than previous\\nso 1, 2, 3 is correct because 2 is one greater than 1 and 3 is one greater than 2\\n1, 2, 4 is incorrect because while 4 is not one greater than 2"
                    },
                    {
                        "username": "MSR_Yang",
                        "content": "result should be false or just note the length of input  is guaranteed >= 6"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "1)Store frequency in map first.\\n2)iterate though nums and check if next two elements have freq>0\\n3)Always store the last element of subsequence in new map so that last few elements(in nums) can use it"
                    },
                    {
                        "username": "tkar123",
                        "content": "Why is it telling me that [1,2,3,4,5,6,4] is false? Shouldn\\'t it be true because you can split it into one subsequence: [1,2,3,4] where the 4 is the last 4 in the array and another subsequence [4,5,6] where that 4 is the first 4 that appears in the array?"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "its an invalid array it should be sorted in non decreasing order\\n"
                    },
                    {
                        "username": "user2049D",
                        "content": "[@laichbr](/laichbr) \nIn the contraints we have:\nnums is sorted in non-decreasing order.\n [1,2,3,4,5,6,4] is not a case."
                    },
                    {
                        "username": "laichbr",
                        "content": "You\\'re right, that should be a valid sequence"
                    }
                ]
            },
            {
                "id": 1572791,
                "content": [
                    {
                        "username": "kesihai",
                        "content": "[1,2,3,4,5,6,6,8,9,9], I could split it to  [123][4,5,6,6,8,9,9]"
                    },
                    {
                        "username": "sherlock321",
                        "content": "The question said \"you need to split them into several subsequences, where each subsequences consist of at least 3 consecutive integers\". However, There is no way to split [1,2,3,4,5] into two subsequences, for example, but it seems like the problem expect this case to be True? Am I interpreting this wrong?"
                    },
                    {
                        "username": "user2049D",
                        "content": "It\\'s now said : \"Determine if it is possible to split nums into one or more subsequences such that...\""
                    },
                    {
                        "username": "quanhoang91",
                        "content": "The statement asks to split original array into subsequence(s).\\nFor input [1,2,3,4,5] => solution is to split into 1 subsequence, which is the array itself.\\nHowever, for input [1,2,3,4,5,5] => solution says it is impossible. What stops me from doing the same of splitting it into 1 subsequence of itself. It still satisfies the problem description (no where saying that each element in subsequences need to be unique)."
                    },
                    {
                        "username": "Guyuelulin",
                        "content": "The misleading part seems all from here. \\n\\nYou are given an integer array sorted in ascending order (may contain duplicates), you need to split them into several subsequences, where each subsequences **consist of** at least 3 consecutive integers. Return whether you can make such a split.\\n\\n\\u5F88\\u660E\\u663E\\uFF0C\\u8FD9\\u662F\\u4E00\\u9053\\u9AD8\\u8003\\u82F1\\u8BED\\u9898\\u3002\\n\\nConsist of\\n\\u82F1\\u6C49\\u7FFB\\u8BD1:\\n\\u7531\\u2026\\u7EC4\\u6210\\uFF1B\\u7531\\u2026\\u6784\\u6210\\uFF1B\\n\\n\\u6240\\u4EE5\\u9898\\u76EE\\u662F\\uFF0C\\u6BCF\\u4E2Asubsequence\\u90FD**\\u53EA**\\u7531 \\u8FDE\\u7EED\\u6574\\u6570\\uFF08\\u81F3\\u5C113\\u4E2A\\uFF09\\u7EC4\\u6210\\u3002\\n\\n\\u6240\\u4EE5\\u5C0F\\u4F19\\u4F34\\u4EEC\\u660E\\u767D\\u4E86\\u5417\\uFF1F"
                    },
                    {
                        "username": "rajneeshkabdwal",
                        "content": "nums = [1,2,3,4,4,5]\\nWhat is wrong with test case, acc to me it should return true coz we can split it in [1,2,3] whose length is 3 .\\nSomeone please explain it to me."
                    },
                    {
                        "username": "alirehmat4318",
                        "content": "it says consective but in last paragraph they violent this rule  states as:\"i.e., [1,3,5] is a subsequence of [1,2,3,4,5] while [1,3,2] is not\"  how can [1,3,5] be subsequence if indexes are not consective. its so confusin "
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "Tip 1 : Remember it is asking for consecutive sequence i.e [1,2,3,4]  \\nTip 2 : Marked the the last index of sequence so that if possible it can be used in previous chaining\\nTip 3 : Use 2 map one for count and one for tip2(marking the last sequence)"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "the_att_21",
                        "content": "Wasn\\'t this a Premium Question?"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        unordered_map<int, int> freq, need;\\n        \\n        for (int v : nums) freq[v]++;\\n        \\n        for (int v : nums) {\\n            if (freq[v] == 0) {\\n                continue;\\n            }\\n\\n            if (need.count(v) && need[v] > 0) {\\n                \\n                freq[v]--;\\n                need[v]--;\\n                need[v + 1] ++;\\n\\n            } else if (freq[v] > 0 && freq[v + 1] > 0 && freq[v + 2] > 0) {\\n                \\n                freq[v]--;\\n                freq[v + 1]--;\\n                freq[v + 2]--;\\n                    \\n                need[v + 3]++;\\n\\n            } else {\\n                return false;\\n            }\\n        }\\n           \\n        return true;       \\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1569147,
                "content": [
                    {
                        "username": "kesihai",
                        "content": "[1,2,3,4,5,6,6,8,9,9], I could split it to  [123][4,5,6,6,8,9,9]"
                    },
                    {
                        "username": "sherlock321",
                        "content": "The question said \"you need to split them into several subsequences, where each subsequences consist of at least 3 consecutive integers\". However, There is no way to split [1,2,3,4,5] into two subsequences, for example, but it seems like the problem expect this case to be True? Am I interpreting this wrong?"
                    },
                    {
                        "username": "user2049D",
                        "content": "It\\'s now said : \"Determine if it is possible to split nums into one or more subsequences such that...\""
                    },
                    {
                        "username": "quanhoang91",
                        "content": "The statement asks to split original array into subsequence(s).\\nFor input [1,2,3,4,5] => solution is to split into 1 subsequence, which is the array itself.\\nHowever, for input [1,2,3,4,5,5] => solution says it is impossible. What stops me from doing the same of splitting it into 1 subsequence of itself. It still satisfies the problem description (no where saying that each element in subsequences need to be unique)."
                    },
                    {
                        "username": "Guyuelulin",
                        "content": "The misleading part seems all from here. \\n\\nYou are given an integer array sorted in ascending order (may contain duplicates), you need to split them into several subsequences, where each subsequences **consist of** at least 3 consecutive integers. Return whether you can make such a split.\\n\\n\\u5F88\\u660E\\u663E\\uFF0C\\u8FD9\\u662F\\u4E00\\u9053\\u9AD8\\u8003\\u82F1\\u8BED\\u9898\\u3002\\n\\nConsist of\\n\\u82F1\\u6C49\\u7FFB\\u8BD1:\\n\\u7531\\u2026\\u7EC4\\u6210\\uFF1B\\u7531\\u2026\\u6784\\u6210\\uFF1B\\n\\n\\u6240\\u4EE5\\u9898\\u76EE\\u662F\\uFF0C\\u6BCF\\u4E2Asubsequence\\u90FD**\\u53EA**\\u7531 \\u8FDE\\u7EED\\u6574\\u6570\\uFF08\\u81F3\\u5C113\\u4E2A\\uFF09\\u7EC4\\u6210\\u3002\\n\\n\\u6240\\u4EE5\\u5C0F\\u4F19\\u4F34\\u4EEC\\u660E\\u767D\\u4E86\\u5417\\uFF1F"
                    },
                    {
                        "username": "rajneeshkabdwal",
                        "content": "nums = [1,2,3,4,4,5]\\nWhat is wrong with test case, acc to me it should return true coz we can split it in [1,2,3] whose length is 3 .\\nSomeone please explain it to me."
                    },
                    {
                        "username": "alirehmat4318",
                        "content": "it says consective but in last paragraph they violent this rule  states as:\"i.e., [1,3,5] is a subsequence of [1,2,3,4,5] while [1,3,2] is not\"  how can [1,3,5] be subsequence if indexes are not consective. its so confusin "
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "Tip 1 : Remember it is asking for consecutive sequence i.e [1,2,3,4]  \\nTip 2 : Marked the the last index of sequence so that if possible it can be used in previous chaining\\nTip 3 : Use 2 map one for count and one for tip2(marking the last sequence)"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "the_att_21",
                        "content": "Wasn\\'t this a Premium Question?"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        unordered_map<int, int> freq, need;\\n        \\n        for (int v : nums) freq[v]++;\\n        \\n        for (int v : nums) {\\n            if (freq[v] == 0) {\\n                continue;\\n            }\\n\\n            if (need.count(v) && need[v] > 0) {\\n                \\n                freq[v]--;\\n                need[v]--;\\n                need[v + 1] ++;\\n\\n            } else if (freq[v] > 0 && freq[v + 1] > 0 && freq[v + 2] > 0) {\\n                \\n                freq[v]--;\\n                freq[v + 1]--;\\n                freq[v + 2]--;\\n                    \\n                need[v + 3]++;\\n\\n            } else {\\n                return false;\\n            }\\n        }\\n           \\n        return true;       \\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1572825,
                "content": [
                    {
                        "username": "kesihai",
                        "content": "[1,2,3,4,5,6,6,8,9,9], I could split it to  [123][4,5,6,6,8,9,9]"
                    },
                    {
                        "username": "sherlock321",
                        "content": "The question said \"you need to split them into several subsequences, where each subsequences consist of at least 3 consecutive integers\". However, There is no way to split [1,2,3,4,5] into two subsequences, for example, but it seems like the problem expect this case to be True? Am I interpreting this wrong?"
                    },
                    {
                        "username": "user2049D",
                        "content": "It\\'s now said : \"Determine if it is possible to split nums into one or more subsequences such that...\""
                    },
                    {
                        "username": "quanhoang91",
                        "content": "The statement asks to split original array into subsequence(s).\\nFor input [1,2,3,4,5] => solution is to split into 1 subsequence, which is the array itself.\\nHowever, for input [1,2,3,4,5,5] => solution says it is impossible. What stops me from doing the same of splitting it into 1 subsequence of itself. It still satisfies the problem description (no where saying that each element in subsequences need to be unique)."
                    },
                    {
                        "username": "Guyuelulin",
                        "content": "The misleading part seems all from here. \\n\\nYou are given an integer array sorted in ascending order (may contain duplicates), you need to split them into several subsequences, where each subsequences **consist of** at least 3 consecutive integers. Return whether you can make such a split.\\n\\n\\u5F88\\u660E\\u663E\\uFF0C\\u8FD9\\u662F\\u4E00\\u9053\\u9AD8\\u8003\\u82F1\\u8BED\\u9898\\u3002\\n\\nConsist of\\n\\u82F1\\u6C49\\u7FFB\\u8BD1:\\n\\u7531\\u2026\\u7EC4\\u6210\\uFF1B\\u7531\\u2026\\u6784\\u6210\\uFF1B\\n\\n\\u6240\\u4EE5\\u9898\\u76EE\\u662F\\uFF0C\\u6BCF\\u4E2Asubsequence\\u90FD**\\u53EA**\\u7531 \\u8FDE\\u7EED\\u6574\\u6570\\uFF08\\u81F3\\u5C113\\u4E2A\\uFF09\\u7EC4\\u6210\\u3002\\n\\n\\u6240\\u4EE5\\u5C0F\\u4F19\\u4F34\\u4EEC\\u660E\\u767D\\u4E86\\u5417\\uFF1F"
                    },
                    {
                        "username": "rajneeshkabdwal",
                        "content": "nums = [1,2,3,4,4,5]\\nWhat is wrong with test case, acc to me it should return true coz we can split it in [1,2,3] whose length is 3 .\\nSomeone please explain it to me."
                    },
                    {
                        "username": "alirehmat4318",
                        "content": "it says consective but in last paragraph they violent this rule  states as:\"i.e., [1,3,5] is a subsequence of [1,2,3,4,5] while [1,3,2] is not\"  how can [1,3,5] be subsequence if indexes are not consective. its so confusin "
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "Tip 1 : Remember it is asking for consecutive sequence i.e [1,2,3,4]  \\nTip 2 : Marked the the last index of sequence so that if possible it can be used in previous chaining\\nTip 3 : Use 2 map one for count and one for tip2(marking the last sequence)"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "the_att_21",
                        "content": "Wasn\\'t this a Premium Question?"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        unordered_map<int, int> freq, need;\\n        \\n        for (int v : nums) freq[v]++;\\n        \\n        for (int v : nums) {\\n            if (freq[v] == 0) {\\n                continue;\\n            }\\n\\n            if (need.count(v) && need[v] > 0) {\\n                \\n                freq[v]--;\\n                need[v]--;\\n                need[v + 1] ++;\\n\\n            } else if (freq[v] > 0 && freq[v + 1] > 0 && freq[v + 2] > 0) {\\n                \\n                freq[v]--;\\n                freq[v + 1]--;\\n                freq[v + 2]--;\\n                    \\n                need[v + 3]++;\\n\\n            } else {\\n                return false;\\n            }\\n        }\\n           \\n        return true;       \\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1571983,
                "content": [
                    {
                        "username": "kesihai",
                        "content": "[1,2,3,4,5,6,6,8,9,9], I could split it to  [123][4,5,6,6,8,9,9]"
                    },
                    {
                        "username": "sherlock321",
                        "content": "The question said \"you need to split them into several subsequences, where each subsequences consist of at least 3 consecutive integers\". However, There is no way to split [1,2,3,4,5] into two subsequences, for example, but it seems like the problem expect this case to be True? Am I interpreting this wrong?"
                    },
                    {
                        "username": "user2049D",
                        "content": "It\\'s now said : \"Determine if it is possible to split nums into one or more subsequences such that...\""
                    },
                    {
                        "username": "quanhoang91",
                        "content": "The statement asks to split original array into subsequence(s).\\nFor input [1,2,3,4,5] => solution is to split into 1 subsequence, which is the array itself.\\nHowever, for input [1,2,3,4,5,5] => solution says it is impossible. What stops me from doing the same of splitting it into 1 subsequence of itself. It still satisfies the problem description (no where saying that each element in subsequences need to be unique)."
                    },
                    {
                        "username": "Guyuelulin",
                        "content": "The misleading part seems all from here. \\n\\nYou are given an integer array sorted in ascending order (may contain duplicates), you need to split them into several subsequences, where each subsequences **consist of** at least 3 consecutive integers. Return whether you can make such a split.\\n\\n\\u5F88\\u660E\\u663E\\uFF0C\\u8FD9\\u662F\\u4E00\\u9053\\u9AD8\\u8003\\u82F1\\u8BED\\u9898\\u3002\\n\\nConsist of\\n\\u82F1\\u6C49\\u7FFB\\u8BD1:\\n\\u7531\\u2026\\u7EC4\\u6210\\uFF1B\\u7531\\u2026\\u6784\\u6210\\uFF1B\\n\\n\\u6240\\u4EE5\\u9898\\u76EE\\u662F\\uFF0C\\u6BCF\\u4E2Asubsequence\\u90FD**\\u53EA**\\u7531 \\u8FDE\\u7EED\\u6574\\u6570\\uFF08\\u81F3\\u5C113\\u4E2A\\uFF09\\u7EC4\\u6210\\u3002\\n\\n\\u6240\\u4EE5\\u5C0F\\u4F19\\u4F34\\u4EEC\\u660E\\u767D\\u4E86\\u5417\\uFF1F"
                    },
                    {
                        "username": "rajneeshkabdwal",
                        "content": "nums = [1,2,3,4,4,5]\\nWhat is wrong with test case, acc to me it should return true coz we can split it in [1,2,3] whose length is 3 .\\nSomeone please explain it to me."
                    },
                    {
                        "username": "alirehmat4318",
                        "content": "it says consective but in last paragraph they violent this rule  states as:\"i.e., [1,3,5] is a subsequence of [1,2,3,4,5] while [1,3,2] is not\"  how can [1,3,5] be subsequence if indexes are not consective. its so confusin "
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "Tip 1 : Remember it is asking for consecutive sequence i.e [1,2,3,4]  \\nTip 2 : Marked the the last index of sequence so that if possible it can be used in previous chaining\\nTip 3 : Use 2 map one for count and one for tip2(marking the last sequence)"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "the_att_21",
                        "content": "Wasn\\'t this a Premium Question?"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        unordered_map<int, int> freq, need;\\n        \\n        for (int v : nums) freq[v]++;\\n        \\n        for (int v : nums) {\\n            if (freq[v] == 0) {\\n                continue;\\n            }\\n\\n            if (need.count(v) && need[v] > 0) {\\n                \\n                freq[v]--;\\n                need[v]--;\\n                need[v + 1] ++;\\n\\n            } else if (freq[v] > 0 && freq[v + 1] > 0 && freq[v + 2] > 0) {\\n                \\n                freq[v]--;\\n                freq[v + 1]--;\\n                freq[v + 2]--;\\n                    \\n                need[v + 3]++;\\n\\n            } else {\\n                return false;\\n            }\\n        }\\n           \\n        return true;       \\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 2069344,
                "content": [
                    {
                        "username": "kesihai",
                        "content": "[1,2,3,4,5,6,6,8,9,9], I could split it to  [123][4,5,6,6,8,9,9]"
                    },
                    {
                        "username": "sherlock321",
                        "content": "The question said \"you need to split them into several subsequences, where each subsequences consist of at least 3 consecutive integers\". However, There is no way to split [1,2,3,4,5] into two subsequences, for example, but it seems like the problem expect this case to be True? Am I interpreting this wrong?"
                    },
                    {
                        "username": "user2049D",
                        "content": "It\\'s now said : \"Determine if it is possible to split nums into one or more subsequences such that...\""
                    },
                    {
                        "username": "quanhoang91",
                        "content": "The statement asks to split original array into subsequence(s).\\nFor input [1,2,3,4,5] => solution is to split into 1 subsequence, which is the array itself.\\nHowever, for input [1,2,3,4,5,5] => solution says it is impossible. What stops me from doing the same of splitting it into 1 subsequence of itself. It still satisfies the problem description (no where saying that each element in subsequences need to be unique)."
                    },
                    {
                        "username": "Guyuelulin",
                        "content": "The misleading part seems all from here. \\n\\nYou are given an integer array sorted in ascending order (may contain duplicates), you need to split them into several subsequences, where each subsequences **consist of** at least 3 consecutive integers. Return whether you can make such a split.\\n\\n\\u5F88\\u660E\\u663E\\uFF0C\\u8FD9\\u662F\\u4E00\\u9053\\u9AD8\\u8003\\u82F1\\u8BED\\u9898\\u3002\\n\\nConsist of\\n\\u82F1\\u6C49\\u7FFB\\u8BD1:\\n\\u7531\\u2026\\u7EC4\\u6210\\uFF1B\\u7531\\u2026\\u6784\\u6210\\uFF1B\\n\\n\\u6240\\u4EE5\\u9898\\u76EE\\u662F\\uFF0C\\u6BCF\\u4E2Asubsequence\\u90FD**\\u53EA**\\u7531 \\u8FDE\\u7EED\\u6574\\u6570\\uFF08\\u81F3\\u5C113\\u4E2A\\uFF09\\u7EC4\\u6210\\u3002\\n\\n\\u6240\\u4EE5\\u5C0F\\u4F19\\u4F34\\u4EEC\\u660E\\u767D\\u4E86\\u5417\\uFF1F"
                    },
                    {
                        "username": "rajneeshkabdwal",
                        "content": "nums = [1,2,3,4,4,5]\\nWhat is wrong with test case, acc to me it should return true coz we can split it in [1,2,3] whose length is 3 .\\nSomeone please explain it to me."
                    },
                    {
                        "username": "alirehmat4318",
                        "content": "it says consective but in last paragraph they violent this rule  states as:\"i.e., [1,3,5] is a subsequence of [1,2,3,4,5] while [1,3,2] is not\"  how can [1,3,5] be subsequence if indexes are not consective. its so confusin "
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "Tip 1 : Remember it is asking for consecutive sequence i.e [1,2,3,4]  \\nTip 2 : Marked the the last index of sequence so that if possible it can be used in previous chaining\\nTip 3 : Use 2 map one for count and one for tip2(marking the last sequence)"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "the_att_21",
                        "content": "Wasn\\'t this a Premium Question?"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        unordered_map<int, int> freq, need;\\n        \\n        for (int v : nums) freq[v]++;\\n        \\n        for (int v : nums) {\\n            if (freq[v] == 0) {\\n                continue;\\n            }\\n\\n            if (need.count(v) && need[v] > 0) {\\n                \\n                freq[v]--;\\n                need[v]--;\\n                need[v + 1] ++;\\n\\n            } else if (freq[v] > 0 && freq[v + 1] > 0 && freq[v + 2] > 0) {\\n                \\n                freq[v]--;\\n                freq[v + 1]--;\\n                freq[v + 2]--;\\n                    \\n                need[v + 3]++;\\n\\n            } else {\\n                return false;\\n            }\\n        }\\n           \\n        return true;       \\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 2018104,
                "content": [
                    {
                        "username": "kesihai",
                        "content": "[1,2,3,4,5,6,6,8,9,9], I could split it to  [123][4,5,6,6,8,9,9]"
                    },
                    {
                        "username": "sherlock321",
                        "content": "The question said \"you need to split them into several subsequences, where each subsequences consist of at least 3 consecutive integers\". However, There is no way to split [1,2,3,4,5] into two subsequences, for example, but it seems like the problem expect this case to be True? Am I interpreting this wrong?"
                    },
                    {
                        "username": "user2049D",
                        "content": "It\\'s now said : \"Determine if it is possible to split nums into one or more subsequences such that...\""
                    },
                    {
                        "username": "quanhoang91",
                        "content": "The statement asks to split original array into subsequence(s).\\nFor input [1,2,3,4,5] => solution is to split into 1 subsequence, which is the array itself.\\nHowever, for input [1,2,3,4,5,5] => solution says it is impossible. What stops me from doing the same of splitting it into 1 subsequence of itself. It still satisfies the problem description (no where saying that each element in subsequences need to be unique)."
                    },
                    {
                        "username": "Guyuelulin",
                        "content": "The misleading part seems all from here. \\n\\nYou are given an integer array sorted in ascending order (may contain duplicates), you need to split them into several subsequences, where each subsequences **consist of** at least 3 consecutive integers. Return whether you can make such a split.\\n\\n\\u5F88\\u660E\\u663E\\uFF0C\\u8FD9\\u662F\\u4E00\\u9053\\u9AD8\\u8003\\u82F1\\u8BED\\u9898\\u3002\\n\\nConsist of\\n\\u82F1\\u6C49\\u7FFB\\u8BD1:\\n\\u7531\\u2026\\u7EC4\\u6210\\uFF1B\\u7531\\u2026\\u6784\\u6210\\uFF1B\\n\\n\\u6240\\u4EE5\\u9898\\u76EE\\u662F\\uFF0C\\u6BCF\\u4E2Asubsequence\\u90FD**\\u53EA**\\u7531 \\u8FDE\\u7EED\\u6574\\u6570\\uFF08\\u81F3\\u5C113\\u4E2A\\uFF09\\u7EC4\\u6210\\u3002\\n\\n\\u6240\\u4EE5\\u5C0F\\u4F19\\u4F34\\u4EEC\\u660E\\u767D\\u4E86\\u5417\\uFF1F"
                    },
                    {
                        "username": "rajneeshkabdwal",
                        "content": "nums = [1,2,3,4,4,5]\\nWhat is wrong with test case, acc to me it should return true coz we can split it in [1,2,3] whose length is 3 .\\nSomeone please explain it to me."
                    },
                    {
                        "username": "alirehmat4318",
                        "content": "it says consective but in last paragraph they violent this rule  states as:\"i.e., [1,3,5] is a subsequence of [1,2,3,4,5] while [1,3,2] is not\"  how can [1,3,5] be subsequence if indexes are not consective. its so confusin "
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "Tip 1 : Remember it is asking for consecutive sequence i.e [1,2,3,4]  \\nTip 2 : Marked the the last index of sequence so that if possible it can be used in previous chaining\\nTip 3 : Use 2 map one for count and one for tip2(marking the last sequence)"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "the_att_21",
                        "content": "Wasn\\'t this a Premium Question?"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        unordered_map<int, int> freq, need;\\n        \\n        for (int v : nums) freq[v]++;\\n        \\n        for (int v : nums) {\\n            if (freq[v] == 0) {\\n                continue;\\n            }\\n\\n            if (need.count(v) && need[v] > 0) {\\n                \\n                freq[v]--;\\n                need[v]--;\\n                need[v + 1] ++;\\n\\n            } else if (freq[v] > 0 && freq[v + 1] > 0 && freq[v + 2] > 0) {\\n                \\n                freq[v]--;\\n                freq[v + 1]--;\\n                freq[v + 2]--;\\n                    \\n                need[v + 3]++;\\n\\n            } else {\\n                return false;\\n            }\\n        }\\n           \\n        return true;       \\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1815640,
                "content": [
                    {
                        "username": "kesihai",
                        "content": "[1,2,3,4,5,6,6,8,9,9], I could split it to  [123][4,5,6,6,8,9,9]"
                    },
                    {
                        "username": "sherlock321",
                        "content": "The question said \"you need to split them into several subsequences, where each subsequences consist of at least 3 consecutive integers\". However, There is no way to split [1,2,3,4,5] into two subsequences, for example, but it seems like the problem expect this case to be True? Am I interpreting this wrong?"
                    },
                    {
                        "username": "user2049D",
                        "content": "It\\'s now said : \"Determine if it is possible to split nums into one or more subsequences such that...\""
                    },
                    {
                        "username": "quanhoang91",
                        "content": "The statement asks to split original array into subsequence(s).\\nFor input [1,2,3,4,5] => solution is to split into 1 subsequence, which is the array itself.\\nHowever, for input [1,2,3,4,5,5] => solution says it is impossible. What stops me from doing the same of splitting it into 1 subsequence of itself. It still satisfies the problem description (no where saying that each element in subsequences need to be unique)."
                    },
                    {
                        "username": "Guyuelulin",
                        "content": "The misleading part seems all from here. \\n\\nYou are given an integer array sorted in ascending order (may contain duplicates), you need to split them into several subsequences, where each subsequences **consist of** at least 3 consecutive integers. Return whether you can make such a split.\\n\\n\\u5F88\\u660E\\u663E\\uFF0C\\u8FD9\\u662F\\u4E00\\u9053\\u9AD8\\u8003\\u82F1\\u8BED\\u9898\\u3002\\n\\nConsist of\\n\\u82F1\\u6C49\\u7FFB\\u8BD1:\\n\\u7531\\u2026\\u7EC4\\u6210\\uFF1B\\u7531\\u2026\\u6784\\u6210\\uFF1B\\n\\n\\u6240\\u4EE5\\u9898\\u76EE\\u662F\\uFF0C\\u6BCF\\u4E2Asubsequence\\u90FD**\\u53EA**\\u7531 \\u8FDE\\u7EED\\u6574\\u6570\\uFF08\\u81F3\\u5C113\\u4E2A\\uFF09\\u7EC4\\u6210\\u3002\\n\\n\\u6240\\u4EE5\\u5C0F\\u4F19\\u4F34\\u4EEC\\u660E\\u767D\\u4E86\\u5417\\uFF1F"
                    },
                    {
                        "username": "rajneeshkabdwal",
                        "content": "nums = [1,2,3,4,4,5]\\nWhat is wrong with test case, acc to me it should return true coz we can split it in [1,2,3] whose length is 3 .\\nSomeone please explain it to me."
                    },
                    {
                        "username": "alirehmat4318",
                        "content": "it says consective but in last paragraph they violent this rule  states as:\"i.e., [1,3,5] is a subsequence of [1,2,3,4,5] while [1,3,2] is not\"  how can [1,3,5] be subsequence if indexes are not consective. its so confusin "
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "Tip 1 : Remember it is asking for consecutive sequence i.e [1,2,3,4]  \\nTip 2 : Marked the the last index of sequence so that if possible it can be used in previous chaining\\nTip 3 : Use 2 map one for count and one for tip2(marking the last sequence)"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "the_att_21",
                        "content": "Wasn\\'t this a Premium Question?"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        unordered_map<int, int> freq, need;\\n        \\n        for (int v : nums) freq[v]++;\\n        \\n        for (int v : nums) {\\n            if (freq[v] == 0) {\\n                continue;\\n            }\\n\\n            if (need.count(v) && need[v] > 0) {\\n                \\n                freq[v]--;\\n                need[v]--;\\n                need[v + 1] ++;\\n\\n            } else if (freq[v] > 0 && freq[v + 1] > 0 && freq[v + 2] > 0) {\\n                \\n                freq[v]--;\\n                freq[v + 1]--;\\n                freq[v + 2]--;\\n                    \\n                need[v + 3]++;\\n\\n            } else {\\n                return false;\\n            }\\n        }\\n           \\n        return true;       \\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1773179,
                "content": [
                    {
                        "username": "kesihai",
                        "content": "[1,2,3,4,5,6,6,8,9,9], I could split it to  [123][4,5,6,6,8,9,9]"
                    },
                    {
                        "username": "sherlock321",
                        "content": "The question said \"you need to split them into several subsequences, where each subsequences consist of at least 3 consecutive integers\". However, There is no way to split [1,2,3,4,5] into two subsequences, for example, but it seems like the problem expect this case to be True? Am I interpreting this wrong?"
                    },
                    {
                        "username": "user2049D",
                        "content": "It\\'s now said : \"Determine if it is possible to split nums into one or more subsequences such that...\""
                    },
                    {
                        "username": "quanhoang91",
                        "content": "The statement asks to split original array into subsequence(s).\\nFor input [1,2,3,4,5] => solution is to split into 1 subsequence, which is the array itself.\\nHowever, for input [1,2,3,4,5,5] => solution says it is impossible. What stops me from doing the same of splitting it into 1 subsequence of itself. It still satisfies the problem description (no where saying that each element in subsequences need to be unique)."
                    },
                    {
                        "username": "Guyuelulin",
                        "content": "The misleading part seems all from here. \\n\\nYou are given an integer array sorted in ascending order (may contain duplicates), you need to split them into several subsequences, where each subsequences **consist of** at least 3 consecutive integers. Return whether you can make such a split.\\n\\n\\u5F88\\u660E\\u663E\\uFF0C\\u8FD9\\u662F\\u4E00\\u9053\\u9AD8\\u8003\\u82F1\\u8BED\\u9898\\u3002\\n\\nConsist of\\n\\u82F1\\u6C49\\u7FFB\\u8BD1:\\n\\u7531\\u2026\\u7EC4\\u6210\\uFF1B\\u7531\\u2026\\u6784\\u6210\\uFF1B\\n\\n\\u6240\\u4EE5\\u9898\\u76EE\\u662F\\uFF0C\\u6BCF\\u4E2Asubsequence\\u90FD**\\u53EA**\\u7531 \\u8FDE\\u7EED\\u6574\\u6570\\uFF08\\u81F3\\u5C113\\u4E2A\\uFF09\\u7EC4\\u6210\\u3002\\n\\n\\u6240\\u4EE5\\u5C0F\\u4F19\\u4F34\\u4EEC\\u660E\\u767D\\u4E86\\u5417\\uFF1F"
                    },
                    {
                        "username": "rajneeshkabdwal",
                        "content": "nums = [1,2,3,4,4,5]\\nWhat is wrong with test case, acc to me it should return true coz we can split it in [1,2,3] whose length is 3 .\\nSomeone please explain it to me."
                    },
                    {
                        "username": "alirehmat4318",
                        "content": "it says consective but in last paragraph they violent this rule  states as:\"i.e., [1,3,5] is a subsequence of [1,2,3,4,5] while [1,3,2] is not\"  how can [1,3,5] be subsequence if indexes are not consective. its so confusin "
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "Tip 1 : Remember it is asking for consecutive sequence i.e [1,2,3,4]  \\nTip 2 : Marked the the last index of sequence so that if possible it can be used in previous chaining\\nTip 3 : Use 2 map one for count and one for tip2(marking the last sequence)"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "the_att_21",
                        "content": "Wasn\\'t this a Premium Question?"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        unordered_map<int, int> freq, need;\\n        \\n        for (int v : nums) freq[v]++;\\n        \\n        for (int v : nums) {\\n            if (freq[v] == 0) {\\n                continue;\\n            }\\n\\n            if (need.count(v) && need[v] > 0) {\\n                \\n                freq[v]--;\\n                need[v]--;\\n                need[v + 1] ++;\\n\\n            } else if (freq[v] > 0 && freq[v + 1] > 0 && freq[v + 2] > 0) {\\n                \\n                freq[v]--;\\n                freq[v + 1]--;\\n                freq[v + 2]--;\\n                    \\n                need[v + 3]++;\\n\\n            } else {\\n                return false;\\n            }\\n        }\\n           \\n        return true;       \\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1758346,
                "content": [
                    {
                        "username": "kesihai",
                        "content": "[1,2,3,4,5,6,6,8,9,9], I could split it to  [123][4,5,6,6,8,9,9]"
                    },
                    {
                        "username": "sherlock321",
                        "content": "The question said \"you need to split them into several subsequences, where each subsequences consist of at least 3 consecutive integers\". However, There is no way to split [1,2,3,4,5] into two subsequences, for example, but it seems like the problem expect this case to be True? Am I interpreting this wrong?"
                    },
                    {
                        "username": "user2049D",
                        "content": "It\\'s now said : \"Determine if it is possible to split nums into one or more subsequences such that...\""
                    },
                    {
                        "username": "quanhoang91",
                        "content": "The statement asks to split original array into subsequence(s).\\nFor input [1,2,3,4,5] => solution is to split into 1 subsequence, which is the array itself.\\nHowever, for input [1,2,3,4,5,5] => solution says it is impossible. What stops me from doing the same of splitting it into 1 subsequence of itself. It still satisfies the problem description (no where saying that each element in subsequences need to be unique)."
                    },
                    {
                        "username": "Guyuelulin",
                        "content": "The misleading part seems all from here. \\n\\nYou are given an integer array sorted in ascending order (may contain duplicates), you need to split them into several subsequences, where each subsequences **consist of** at least 3 consecutive integers. Return whether you can make such a split.\\n\\n\\u5F88\\u660E\\u663E\\uFF0C\\u8FD9\\u662F\\u4E00\\u9053\\u9AD8\\u8003\\u82F1\\u8BED\\u9898\\u3002\\n\\nConsist of\\n\\u82F1\\u6C49\\u7FFB\\u8BD1:\\n\\u7531\\u2026\\u7EC4\\u6210\\uFF1B\\u7531\\u2026\\u6784\\u6210\\uFF1B\\n\\n\\u6240\\u4EE5\\u9898\\u76EE\\u662F\\uFF0C\\u6BCF\\u4E2Asubsequence\\u90FD**\\u53EA**\\u7531 \\u8FDE\\u7EED\\u6574\\u6570\\uFF08\\u81F3\\u5C113\\u4E2A\\uFF09\\u7EC4\\u6210\\u3002\\n\\n\\u6240\\u4EE5\\u5C0F\\u4F19\\u4F34\\u4EEC\\u660E\\u767D\\u4E86\\u5417\\uFF1F"
                    },
                    {
                        "username": "rajneeshkabdwal",
                        "content": "nums = [1,2,3,4,4,5]\\nWhat is wrong with test case, acc to me it should return true coz we can split it in [1,2,3] whose length is 3 .\\nSomeone please explain it to me."
                    },
                    {
                        "username": "alirehmat4318",
                        "content": "it says consective but in last paragraph they violent this rule  states as:\"i.e., [1,3,5] is a subsequence of [1,2,3,4,5] while [1,3,2] is not\"  how can [1,3,5] be subsequence if indexes are not consective. its so confusin "
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "Tip 1 : Remember it is asking for consecutive sequence i.e [1,2,3,4]  \\nTip 2 : Marked the the last index of sequence so that if possible it can be used in previous chaining\\nTip 3 : Use 2 map one for count and one for tip2(marking the last sequence)"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "the_att_21",
                        "content": "Wasn\\'t this a Premium Question?"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        unordered_map<int, int> freq, need;\\n        \\n        for (int v : nums) freq[v]++;\\n        \\n        for (int v : nums) {\\n            if (freq[v] == 0) {\\n                continue;\\n            }\\n\\n            if (need.count(v) && need[v] > 0) {\\n                \\n                freq[v]--;\\n                need[v]--;\\n                need[v + 1] ++;\\n\\n            } else if (freq[v] > 0 && freq[v + 1] > 0 && freq[v + 2] > 0) {\\n                \\n                freq[v]--;\\n                freq[v + 1]--;\\n                freq[v + 2]--;\\n                    \\n                need[v + 3]++;\\n\\n            } else {\\n                return false;\\n            }\\n        }\\n           \\n        return true;       \\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1749121,
                "content": [
                    {
                        "username": "kesihai",
                        "content": "[1,2,3,4,5,6,6,8,9,9], I could split it to  [123][4,5,6,6,8,9,9]"
                    },
                    {
                        "username": "sherlock321",
                        "content": "The question said \"you need to split them into several subsequences, where each subsequences consist of at least 3 consecutive integers\". However, There is no way to split [1,2,3,4,5] into two subsequences, for example, but it seems like the problem expect this case to be True? Am I interpreting this wrong?"
                    },
                    {
                        "username": "user2049D",
                        "content": "It\\'s now said : \"Determine if it is possible to split nums into one or more subsequences such that...\""
                    },
                    {
                        "username": "quanhoang91",
                        "content": "The statement asks to split original array into subsequence(s).\\nFor input [1,2,3,4,5] => solution is to split into 1 subsequence, which is the array itself.\\nHowever, for input [1,2,3,4,5,5] => solution says it is impossible. What stops me from doing the same of splitting it into 1 subsequence of itself. It still satisfies the problem description (no where saying that each element in subsequences need to be unique)."
                    },
                    {
                        "username": "Guyuelulin",
                        "content": "The misleading part seems all from here. \\n\\nYou are given an integer array sorted in ascending order (may contain duplicates), you need to split them into several subsequences, where each subsequences **consist of** at least 3 consecutive integers. Return whether you can make such a split.\\n\\n\\u5F88\\u660E\\u663E\\uFF0C\\u8FD9\\u662F\\u4E00\\u9053\\u9AD8\\u8003\\u82F1\\u8BED\\u9898\\u3002\\n\\nConsist of\\n\\u82F1\\u6C49\\u7FFB\\u8BD1:\\n\\u7531\\u2026\\u7EC4\\u6210\\uFF1B\\u7531\\u2026\\u6784\\u6210\\uFF1B\\n\\n\\u6240\\u4EE5\\u9898\\u76EE\\u662F\\uFF0C\\u6BCF\\u4E2Asubsequence\\u90FD**\\u53EA**\\u7531 \\u8FDE\\u7EED\\u6574\\u6570\\uFF08\\u81F3\\u5C113\\u4E2A\\uFF09\\u7EC4\\u6210\\u3002\\n\\n\\u6240\\u4EE5\\u5C0F\\u4F19\\u4F34\\u4EEC\\u660E\\u767D\\u4E86\\u5417\\uFF1F"
                    },
                    {
                        "username": "rajneeshkabdwal",
                        "content": "nums = [1,2,3,4,4,5]\\nWhat is wrong with test case, acc to me it should return true coz we can split it in [1,2,3] whose length is 3 .\\nSomeone please explain it to me."
                    },
                    {
                        "username": "alirehmat4318",
                        "content": "it says consective but in last paragraph they violent this rule  states as:\"i.e., [1,3,5] is a subsequence of [1,2,3,4,5] while [1,3,2] is not\"  how can [1,3,5] be subsequence if indexes are not consective. its so confusin "
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "Tip 1 : Remember it is asking for consecutive sequence i.e [1,2,3,4]  \\nTip 2 : Marked the the last index of sequence so that if possible it can be used in previous chaining\\nTip 3 : Use 2 map one for count and one for tip2(marking the last sequence)"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "the_att_21",
                        "content": "Wasn\\'t this a Premium Question?"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums) {\\n        unordered_map<int, int> freq, need;\\n        \\n        for (int v : nums) freq[v]++;\\n        \\n        for (int v : nums) {\\n            if (freq[v] == 0) {\\n                continue;\\n            }\\n\\n            if (need.count(v) && need[v] > 0) {\\n                \\n                freq[v]--;\\n                need[v]--;\\n                need[v + 1] ++;\\n\\n            } else if (freq[v] > 0 && freq[v + 1] > 0 && freq[v + 2] > 0) {\\n                \\n                freq[v]--;\\n                freq[v + 1]--;\\n                freq[v + 2]--;\\n                    \\n                need[v + 3]++;\\n\\n            } else {\\n                return false;\\n            }\\n        }\\n           \\n        return true;       \\n    }\\n};\\n```"
                    }
                ]
            }
        ]
    }
]