[
    {
        "title": "Maximum Number of Robots Within Budget",
        "question_content": "You have n robots. You are given two 0-indexed integer arrays, chargeTimes and runningCosts, both of length n. The ith robot costs chargeTimes[i] units to charge and costs runningCosts[i] units to run. You are also given an integer budget.\nThe total cost of running k chosen robots is equal to max(chargeTimes) + k * sum(runningCosts), where max(chargeTimes) is the largest charge cost among the k robots and sum(runningCosts) is the sum of running costs among the k robots.\nReturn the maximum number of consecutive robots you can run such that the total cost does not exceed budget.\n&nbsp;\nExample 1:\n\nInput: chargeTimes = [3,6,1,3,4], runningCosts = [2,1,3,4,5], budget = 25\nOutput: 3\nExplanation: \nIt is possible to run all individual and consecutive pairs of robots within budget.\nTo obtain answer 3, consider the first 3 robots. The total cost will be max(3,6,1) + 3 * sum(2,1,3) = 6 + 3 * 6 = 24 which is less than 25.\nIt can be shown that it is not possible to run more than 3 consecutive robots within budget, so we return 3.\n\nExample 2:\n\nInput: chargeTimes = [11,12,19], runningCosts = [10,8,7], budget = 19\nOutput: 0\nExplanation: No robot can be run that does not exceed the budget, so we return 0.\n\n&nbsp;\nConstraints:\n\n\tchargeTimes.length == runningCosts.length == n\n\t1 <= n <= 5 * 104\n\t1 <= chargeTimes[i], runningCosts[i] <= 105\n\t1 <= budget <= 1015",
        "solutions": [
            {
                "id": 2524838,
                "title": "java-c-python-sliding-window-o-n-solution",
                "content": "# Solution 1: Sliding Window + TreeMap\\nUse a sorted data structure to find the maximum value in a sliding window.\\n\\nTime `O(nlogn)`\\nSpace `O(n)`\\n<br>\\n\\n**C++**\\n```cpp\\n    int maximumRobots(vector<int>& times, vector<int>& costs, long long budget) {\\n        long long i = 0, j, sum = 0, n = times.size();\\n        multiset<int> s;\\n        for (int j = 0; j < n; ++j) {\\n            sum += costs[j];\\n            s.insert(times[j]);\\n            if (*rbegin(s) + sum * (j - i + 1) > budget) {\\n                sum -= costs[i];\\n                s.erase(s.find(times[i++]));\\n            }\\n        }\\n        return n - i;\\n    }\\n```\\n**Python**\\n```python\\n    def maximumRobots(self, times: List[int], costs: List[int], budget: int) -> int:\\n        cur = i = 0\\n        n = len(times)\\n        s = SortedList()\\n        for j in range(n):\\n            cur += costs[j]\\n            s.add(times[j])\\n            if s[-1] + (j - i + 1) * cur > budget:\\n                s.remove(times[i])\\n                cur -= costs[i]\\n                i += 1\\n        return n - i\\n```\\n\\n\\n# Solution 2: Sliding Window + Mono Deque\\nUse a mono deque to find the maximum value in a sliding window.\\n\\nTime `O(n)`\\nSpace `O(n)`\\n\\n**Java**\\n```java\\n    public int maximumRobots(int[] times, int[] costs, long budget) {\\n        long sum = 0;\\n        int i = 0, n = times.length;\\n        Deque<Integer> d = new LinkedList<Integer>();\\n        for (int j = 0; j < n; ++j) {\\n            sum += costs[j];\\n            while (!d.isEmpty() && times[d.peekLast()] <= times[j])\\n                d.pollLast();\\n            d.addLast(j);\\n            if (times[d.getFirst()] + (j - i + 1) * sum > budget) {\\n                if (d.getFirst() == i)\\n                    d.pollFirst();\\n                sum -= costs[i++];\\n            }\\n        }\\n        return n - i;\\n    }\\n```\\n**Python**\\n```py\\n    def maximumRobots(self, times: List[int], costs: List[int], budget: int) -> int:\\n        cur = i = 0\\n        n = len(times)\\n        d = deque()\\n        for j in range(n):\\n            cur += costs[j]\\n            while d and times[d[-1]] <= times[j]:\\n                d.pop()\\n            d.append(j)\\n            if times[d[0]] + (j - i + 1) * cur > budget:\\n                if d[0] == i:\\n                    d.popleft()\\n                cur -= costs[i]\\n                i += 1\\n        return n - i\\n```\\n\\n\\n# More Similar Sliding Window Problems\\nHere are some similar sliding window problems.\\nAlso find more explanations and discussion.\\nGood luck and have fun.\\n\\n- 2398. [Maximum Number of Robots Within Budget](https://leetcode.com/problems/maximum-number-of-robots-within-budget/discuss/2524838/Python-Sliding-Window-O(n))\\n- 1838. [Frequency of the Most Frequent Element](https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1175090/JavaC%2B%2BPython-Sliding-Window)\\n- 1493. [Longest Subarray of 1\\'s After Deleting One Element](https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/discuss/708112/JavaC%2B%2BPython-Sliding-Window-at-most-one-0)\\n- 1425. [Constrained Subsequence Sum](https://leetcode.com/problems/constrained-subsequence-sum/discuss/597751/JavaC++Python-O(N)-Decreasing-Deque)\\n- 1358. [Number of Substrings Containing All Three Characters](https://leetcode.com/problems/number-of-substrings-containing-all-three-characters/discuss/516977/JavaC++Python-Easy-and-Concise)\\n- 1248. [Count Number of Nice Subarrays](https://leetcode.com/problems/count-number-of-nice-subarrays/discuss/419378/JavaC%2B%2BPython-Sliding-Window-atMost(K)-atMost(K-1))\\n- 1234. [Replace the Substring for Balanced String](https://leetcode.com/problems/replace-the-substring-for-balanced-string/discuss/408978/javacpython-sliding-window/)\\n- 1004. [Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/discuss/247564/JavaC%2B%2BPython-Sliding-Window)\\n-  930. [Binary Subarrays With Sum](https://leetcode.com/problems/binary-subarrays-with-sum/discuss/186683/)\\n-  992. [Subarrays with K Different Integers](https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/523136/JavaC%2B%2BPython-Sliding-Window)\\n-  904. [Fruit Into Baskets](https://leetcode.com/problems/fruit-into-baskets/discuss/170740/Sliding-Window-for-K-Elements)\\n-  862. [Shortest Subarray with Sum at Least K](https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/discuss/143726/C%2B%2BJavaPython-O(N)-Using-Deque)\\n-  209. [Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/discuss/433123/JavaC++Python-Sliding-Window)\\n<br>\\n\\n# More Good Stack Problems\\nHere are some problems that impressed me.\\nGood luck and have fun.\\n\\n- 2398. [Maximum Number of Robots Within Budget](https://leetcode.com/problems/maximum-number-of-robots-within-budget/discuss/2524838/Python-Sliding-Window-O(n))\\n- 2289. [Steps to Make Array Non-decreasing](https://leetcode.com/problems/steps-to-make-array-non-decreasing/discuss/2085864/)\\n- 2281. [Sum of Total Strength of Wizards](https://leetcode.com/problems/sum-of-total-strength-of-wizards/discuss/2061985/python-solution-on/1405190)\\n- 1776. [Car Fleet II](https://leetcode.com/problems/car-fleet-ii/discuss/1085987/javacpython-on-stack-solution/)\\n- 1673. [Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/discuss/952786/javacpython-one-pass-stack-solution/776191 )\\n- 1671. [Minimum Number of Removals to Make Mountain Array](https://leetcode.com/problems/minimum-number-of-removals-to-make-mountain-array/discuss/952136/Python-LIS-O(nlogn))\\n- 1475. [Final Prices With a Special Discount in a Shop](https://leetcode.com/problems/final-prices-with-a-special-discount-in-a-shop/discuss/685390/javacpython-stack-one-pass/809992)\\n- 1425. [Constrained Subsequence Sum](https://leetcode.com/problems/constrained-subsequence-sum/discuss/597751/JavaC++Python-O(N)-Decreasing-Deque)\\n- 1130. [Minimum Cost Tree From Leaf Values](https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space)\\n- 907. [Sum of Subarray Minimums](https://leetcode.com/problems/sum-of-subarray-minimums/discuss/170750/C++JavaPython-Stack-Solution)\\n- 901. [Online Stock Span](https://leetcode.com/problems/online-stock-span/discuss/168311/C++JavaPython-O(1))\\n- 856. [Score of Parentheses](https://leetcode.com/problems/score-of-parentheses/discuss/141777/C++JavaPython-O(1)-Space)\\n- 503. [Next Greater Element II](https://leetcode.com/problems/next-greater-element-ii/discuss/98270/JavaC++Python-Loop-Twice)\\n- 496. Next Greater Element I\\n- 84. Largest Rectangle in Histogram\\n- 42. Trapping Rain Water\\n<br>\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```cpp\\n    int maximumRobots(vector<int>& times, vector<int>& costs, long long budget) {\\n        long long i = 0, j, sum = 0, n = times.size();\\n        multiset<int> s;\\n        for (int j = 0; j < n; ++j) {\\n            sum += costs[j];\\n            s.insert(times[j]);\\n            if (*rbegin(s) + sum * (j - i + 1) > budget) {\\n                sum -= costs[i];\\n                s.erase(s.find(times[i++]));\\n            }\\n        }\\n        return n - i;\\n    }\\n```\n```python\\n    def maximumRobots(self, times: List[int], costs: List[int], budget: int) -> int:\\n        cur = i = 0\\n        n = len(times)\\n        s = SortedList()\\n        for j in range(n):\\n            cur += costs[j]\\n            s.add(times[j])\\n            if s[-1] + (j - i + 1) * cur > budget:\\n                s.remove(times[i])\\n                cur -= costs[i]\\n                i += 1\\n        return n - i\\n```\n```java\\n    public int maximumRobots(int[] times, int[] costs, long budget) {\\n        long sum = 0;\\n        int i = 0, n = times.length;\\n        Deque<Integer> d = new LinkedList<Integer>();\\n        for (int j = 0; j < n; ++j) {\\n            sum += costs[j];\\n            while (!d.isEmpty() && times[d.peekLast()] <= times[j])\\n                d.pollLast();\\n            d.addLast(j);\\n            if (times[d.getFirst()] + (j - i + 1) * sum > budget) {\\n                if (d.getFirst() == i)\\n                    d.pollFirst();\\n                sum -= costs[i++];\\n            }\\n        }\\n        return n - i;\\n    }\\n```\n```py\\n    def maximumRobots(self, times: List[int], costs: List[int], budget: int) -> int:\\n        cur = i = 0\\n        n = len(times)\\n        d = deque()\\n        for j in range(n):\\n            cur += costs[j]\\n            while d and times[d[-1]] <= times[j]:\\n                d.pop()\\n            d.append(j)\\n            if times[d[0]] + (j - i + 1) * cur > budget:\\n                if d[0] == i:\\n                    d.popleft()\\n                cur -= costs[i]\\n                i += 1\\n        return n - i\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2524676,
                "title": "c-java-python3-sliding-window-priority-queue-explained",
                "content": "**Explanation**\\n* Sliding window is used to keep track of sum between i and j. `s` stores running sum\\n* Priority queue gives max element between indexes i and j\\n* We do a lazy removal of stale elements from the priority queue. When j is greater than the index of the element in priority queue we remove it. For this we use a priority queue of pairs of elements. First element of pair is value, second element is index\\n* `k = i - j`\\n* Time complexity = `nlogn`\\n\\n<iframe src=\"https://leetcode.com/playground/2nJFXAEL/shared\" frameBorder=\"0\" width=\"750\" height=\"370\"></iframe>",
                "solutionTags": [],
                "code": "**Explanation**\\n* Sliding window is used to keep track of sum between i and j. `s` stores running sum\\n* Priority queue gives max element between indexes i and j\\n* We do a lazy removal of stale elements from the priority queue. When j is greater than the index of the element in priority queue we remove it. For this we use a priority queue of pairs of elements. First element of pair is value, second element is index\\n* `k = i - j`\\n* Time complexity = `nlogn`\\n\\n<iframe src=\"https://leetcode.com/playground/2nJFXAEL/shared\" frameBorder=\"0\" width=\"750\" height=\"370\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 2524728,
                "title": "c-with-explanation-multiple-approaches-binary-search-or-sliding-window",
                "content": "**Overview**\\n* I solved this problem with **Binary Search** and **Segment Tree** approach. \\n* But a better alternative approach also exists using **Sliding Window** and **Maps**. It was implemented by my friend, [Nishant Chandhok](https://leetcode.com/nishantchandhok/). \\n\\n**How I figured it out as Binary Search?**\\n* We need to find the **maximum** consecutive size. Whenever there are words like **maximum/minimum** present in the question, the first thing that clicks my mind is Binary Search.\\n* Since the constraints mentioned the value of `1 <= n <= 5 * 10^4`, hence, this problem can be solved in `O(n logn)`.\\n\\n**How Nishant figured it out as Sliding Window?**\\n* We need to find the maximum **consecutive** size. This is enough to consider it as sliding window.\\n* We can keep combining the consecutive elements until it doesn\\'t exceed the budget and once it does, we can keep removing elements from the back.\\n\\n**Approach 1**\\n**Pre-requisite:**\\n* Knowledge of Binary Search.\\n* Knowledge of Segment Trees.\\n* Must have solved questions similar to [Aggressive Cows](https://www.codingninjas.com/codestudio/problems/aggressive-cows_1082559) \\n\\t\\n**Algorithm**\\n1. Build a Segment for finding `max(chargeTime)` for a given range \\n2. Build a prefix array for finding `sum(runningTime)` for a given range\\n3. Do Binary Search for finding the maximum consecutive size.\\n\\n**Code**\\n```\\nclass Solution {\\n    /******************** Segment Tree to find maximum in a range ********************/\\n    vector<int> arr;\\n    vector<int> tree;\\n\\n    void build(int start, int end, int idx) {\\n        if(start == end) {\\n            tree[idx] = arr[start];\\n        } else {\\n            int mid = (start + end) / 2;\\n            build(start, mid, 2 * idx);\\n            build(mid + 1, end, 2 * idx + 1);\\n            tree[idx] = max(tree[2 * idx], tree[2 * idx + 1]);\\n        }\\n    }\\n    \\n    int query(int start, int end, int left, int right, int idx) {\\n        if(start > right || end < left) {\\n            return INT_MIN;\\n        }\\n        if(start >= left && end <= right) {\\n            return tree[idx];\\n        }\\n        int mid = (start + end) / 2;\\n        return max(query(start, mid, left, right, 2 * idx), query(mid + 1, end, left, right, 2 * idx + 1));\\n    }\\n    \\n    /******************** Checking if subarray of size K exists in the given budget ********************/\\n    bool check(vector<long long>& prefix, int k, int n, long long budget) {\\n        for(int i = 0; i + k <= n; i++) {\\n            int end = i + k;\\n            \\n            long long total = prefix[end];\\n            total -= prefix[i];\\n            total *= k;\\n            total += query(0, n - 1, i, end - 1, 1);\\n            \\n            if(total <= budget)\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        int n = chargeTimes.size();\\n        \\n        /******************** Building the Segment Tree ********************/\\n        arr = chargeTimes;\\n        tree = vector<int>(4 * n);\\n        build(0, n - 1, 1);\\n        \\n        /******************** Forming Prefix array for finding sum(runningCost) in range ********************/\\n        vector<long long> prefix(n + 1);\\n        for(int i = 1; i <= n; i++) {\\n            prefix[i] = prefix[i - 1] + runningCosts[i - 1];\\n        }\\n        \\n        /******************** Binary Search the Maximum Size ********************/\\n        int l = 1, r = n;\\n        int ans = 0;\\n        while(l <= r) { \\n            int mid = (l + r) / 2;\\n            \\n            if(check(prefix, mid, n, budget)) {\\n                ans = mid;\\n                l = mid + 1;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n        return ans;\\n    } \\n};\\n```\\n**Comments:**\\n1. For faster implementation, I used my template for Segment Tree.\\n\\n**Approach 2**\\n**Pre-requisite:**\\n* Knowledge of Sliding Window.\\n\\t\\n**Algorithm**\\n1. Use variable `sum` for calculating the sum of being considered range.\\n2. Use map for calculating the maximum value of chargeTime. \\n3. We can erase the value from the map of the non-considered range, once they are of no use.\\n\\n**Code**\\n```\\nint maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        int n = chargeTimes.size();\\n        \\n        int i = 0;\\n        int j = 0;\\n        \\n        ll cost = 0;\\n        int maxRobo = 0;\\n        map<int, int> mp;\\n        ll sum = 0;\\n        int k;\\n        while(j < n) {\\n            mp[-(chargeTimes[j])]++;\\n            sum += runningCosts[j];\\n            j++;\\n             k = j - i;\\n            cost = -(mp.begin()->first) + (k * sum);\\n            if(cost <= budget ) maxRobo = max(maxRobo, k);\\n            \\n            while(cost > budget) {\\n                mp[-(chargeTimes[i])]--;\\n                if(mp[-(chargeTimes[i])] == 0) mp.erase(-(chargeTimes[i]));\\n                sum -= runningCosts[i];\\n                i++;\\n                k = j - i;\\n                cost = -(mp.begin()->first) + (k * sum);\\n                \\n            }\\n        }\\n        \\n        return maxRobo;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    /******************** Segment Tree to find maximum in a range ********************/\\n    vector<int> arr;\\n    vector<int> tree;\\n\\n    void build(int start, int end, int idx) {\\n        if(start == end) {\\n            tree[idx] = arr[start];\\n        } else {\\n            int mid = (start + end) / 2;\\n            build(start, mid, 2 * idx);\\n            build(mid + 1, end, 2 * idx + 1);\\n            tree[idx] = max(tree[2 * idx], tree[2 * idx + 1]);\\n        }\\n    }\\n    \\n    int query(int start, int end, int left, int right, int idx) {\\n        if(start > right || end < left) {\\n            return INT_MIN;\\n        }\\n        if(start >= left && end <= right) {\\n            return tree[idx];\\n        }\\n        int mid = (start + end) / 2;\\n        return max(query(start, mid, left, right, 2 * idx), query(mid + 1, end, left, right, 2 * idx + 1));\\n    }\\n    \\n    /******************** Checking if subarray of size K exists in the given budget ********************/\\n    bool check(vector<long long>& prefix, int k, int n, long long budget) {\\n        for(int i = 0; i + k <= n; i++) {\\n            int end = i + k;\\n            \\n            long long total = prefix[end];\\n            total -= prefix[i];\\n            total *= k;\\n            total += query(0, n - 1, i, end - 1, 1);\\n            \\n            if(total <= budget)\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        int n = chargeTimes.size();\\n        \\n        /******************** Building the Segment Tree ********************/\\n        arr = chargeTimes;\\n        tree = vector<int>(4 * n);\\n        build(0, n - 1, 1);\\n        \\n        /******************** Forming Prefix array for finding sum(runningCost) in range ********************/\\n        vector<long long> prefix(n + 1);\\n        for(int i = 1; i <= n; i++) {\\n            prefix[i] = prefix[i - 1] + runningCosts[i - 1];\\n        }\\n        \\n        /******************** Binary Search the Maximum Size ********************/\\n        int l = 1, r = n;\\n        int ans = 0;\\n        while(l <= r) { \\n            int mid = (l + r) / 2;\\n            \\n            if(check(prefix, mid, n, budget)) {\\n                ans = mid;\\n                l = mid + 1;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n        return ans;\\n    } \\n};\\n```\n```\\nint maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        int n = chargeTimes.size();\\n        \\n        int i = 0;\\n        int j = 0;\\n        \\n        ll cost = 0;\\n        int maxRobo = 0;\\n        map<int, int> mp;\\n        ll sum = 0;\\n        int k;\\n        while(j < n) {\\n            mp[-(chargeTimes[j])]++;\\n            sum += runningCosts[j];\\n            j++;\\n             k = j - i;\\n            cost = -(mp.begin()->first) + (k * sum);\\n            if(cost <= budget ) maxRobo = max(maxRobo, k);\\n            \\n            while(cost > budget) {\\n                mp[-(chargeTimes[i])]--;\\n                if(mp[-(chargeTimes[i])] == 0) mp.erase(-(chargeTimes[i]));\\n                sum -= runningCosts[i];\\n                i++;\\n                k = j - i;\\n                cost = -(mp.begin()->first) + (k * sum);\\n                \\n            }\\n        }\\n        \\n        return maxRobo;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524683,
                "title": "sliding-window-multiset-monostack",
                "content": "#### Monostack\\n**C++**\\n```cpp\\nint maximumRobots(vector<int>& times, vector<int>& costs, long long budget) {\\n    long long i = 0, j = 0, k = 0;\\n    deque<int> mono;\\n    for (long long cost = 0; i < times.size(); ++i) {\\n        cost += costs[i];\\n        while(!mono.empty() && mono.back() <= times[i])\\n            mono.pop_back();\\n        mono.push_back(times[i]);\\n        if (cost * (i - j + 1) + mono.front() > budget) {\\n            cost -= costs[j];\\n            if (mono.front() == times[j])\\n                mono.pop_front();\\n            ++j;\\n        }\\n    }\\n    return times.size() - j;\\n}\\n```\\n\\n#### Multiset\\nWe use a multiset to track the largest charging time. It\\'s a bit simpler than using a priority queue - as the latter only allows removing elements from the top.\\n\\n**C++**\\n```cpp\\nint maximumRobots(vector<int>& times, vector<int>& costs, long long budget) {\\n    long long i = 0, j = 0;\\n    multiset<int> ms;\\n    for (long long cost = 0; i < times.size(); ++i) {\\n        cost += costs[i];\\n        ms.insert(times[i]);\\n        if (cost * (i - j + 1) + *rbegin(ms) > budget) {\\n            cost -= costs[j];\\n            ms.erase(ms.find(times[j]));\\n            ++j;\\n        }\\n    }\\n    return i - j;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint maximumRobots(vector<int>& times, vector<int>& costs, long long budget) {\\n    long long i = 0, j = 0, k = 0;\\n    deque<int> mono;\\n    for (long long cost = 0; i < times.size(); ++i) {\\n        cost += costs[i];\\n        while(!mono.empty() && mono.back() <= times[i])\\n            mono.pop_back();\\n        mono.push_back(times[i]);\\n        if (cost * (i - j + 1) + mono.front() > budget) {\\n            cost -= costs[j];\\n            if (mono.front() == times[j])\\n                mono.pop_front();\\n            ++j;\\n        }\\n    }\\n    return times.size() - j;\\n}\\n```\n```cpp\\nint maximumRobots(vector<int>& times, vector<int>& costs, long long budget) {\\n    long long i = 0, j = 0;\\n    multiset<int> ms;\\n    for (long long cost = 0; i < times.size(); ++i) {\\n        cost += costs[i];\\n        ms.insert(times[i]);\\n        if (cost * (i - j + 1) + *rbegin(ms) > budget) {\\n            cost -= costs[j];\\n            ms.erase(ms.find(times[j]));\\n            ++j;\\n        }\\n    }\\n    return i - j;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2524710,
                "title": "cpp-two-solutions-o-n-and-o-nlogn-time-deque-and-multiset",
                "content": "**Before trying this question try**\\n1. \\t[239. Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/)\\n2. \\t[560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/)\\n\\n**Intuition :** Use sliding window technique to get the `value` for subarray `[start,end]` if `value` exceeds `budget` move `start` and remove values associated with `start` to get new `value` and each time take maximum of your `answer` and length of your subarray\\n\\n**1 : using multiset\\nTime : O(nlogn)\\nSpace : O(n)**\\n```\\n\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    int maximumRobots(vector<int>& ct, vector<int>& rc, long long budget) {\\n        multiset<int> ms;\\n        ll start=0,end=0,ans=0,n=ct.size(),s=0;\\n        while(end<n){\\n            s+=rc[end];\\n            ms.insert(ct[end++]);\\n            ll val = (*ms.rbegin())+(end-start)*s;\\n            while(val>budget){\\n                s-=rc[start];\\n                ms.erase(ms.find(ct[start++]));\\n                val =ms.empty()?0 : (*ms.rbegin())+(end-start)*s;\\n            }\\n            ans=max(ans,end-start);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n**2 : using deque\\nTime : O(n)\\nSpace : O(n)**\\n\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    int maximumRobots(vector<int>& ct, vector<int>& rc, long long budget) {\\n        deque<int> dq;\\n        ll start=0,end=0,ans=0,n=ct.size(),s=0;\\n        while(end<n){\\n            s+=rc[end];\\n            while(!dq.empty() && ct[dq.back()]<ct[end])dq.pop_back();\\n            dq.push_back(end++);\\n            ll val = ct[dq.front()]+(end-start)*s;\\n            while(val>budget){\\n                s-=rc[start];\\n                if(!dq.empty() && dq.front()<=start)dq.pop_front();\\n                start++;\\n                val = (end == start?0:ct[dq.front()])+(end-start)*s;\\n            }\\n            ans=max(ans,end-start);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    int maximumRobots(vector<int>& ct, vector<int>& rc, long long budget) {\\n        multiset<int> ms;\\n        ll start=0,end=0,ans=0,n=ct.size(),s=0;\\n        while(end<n){\\n            s+=rc[end];\\n            ms.insert(ct[end++]);\\n            ll val = (*ms.rbegin())+(end-start)*s;\\n            while(val>budget){\\n                s-=rc[start];\\n                ms.erase(ms.find(ct[start++]));\\n                val =ms.empty()?0 : (*ms.rbegin())+(end-start)*s;\\n            }\\n            ans=max(ans,end-start);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    int maximumRobots(vector<int>& ct, vector<int>& rc, long long budget) {\\n        deque<int> dq;\\n        ll start=0,end=0,ans=0,n=ct.size(),s=0;\\n        while(end<n){\\n            s+=rc[end];\\n            while(!dq.empty() && ct[dq.back()]<ct[end])dq.pop_back();\\n            dq.push_back(end++);\\n            ll val = ct[dq.front()]+(end-start)*s;\\n            while(val>budget){\\n                s-=rc[start];\\n                if(!dq.empty() && dq.front()<=start)dq.pop_front();\\n                start++;\\n                val = (end == start?0:ct[dq.front()])+(end-start)*s;\\n            }\\n            ans=max(ans,end-start);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524772,
                "title": "c-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& ct, vector<int>& rt, long long budget) {\\n        long long n = ct.size();\\n        long long max_robots = 0, i = 0, curr_cost = 0;\\n        //we will store the maximum element of a subarray and its corresponding index in a priority queue\\n        priority_queue<pair<long long,long long>>pq;\\n        for(long long j=0;j<n;j++){\\n            curr_cost+=rt[j];\\n            pq.push({ct[j],j});\\n            //if the current total cost is less than budget update the number of robots\\n            if(pq.size() and curr_cost*(j-i+1)+pq.top().first<=budget){\\n                max_robots = max(max_robots,j-i+1);\\n            }else{\\n                //our current total cost is exceeding budget so increment the starting index of current subarray \\n                while(pq.size() and curr_cost*(j-i+1)+pq.top().first>budget){\\n                    curr_cost-=rt[i];\\n                    //if the maximum element lies in the previous range pop them out until the maximum element is \\n                    //within the range of current subarray\\n                    while(pq.size() and pq.top().second<=i){\\n                        pq.pop();\\n                    }\\n                    i++;\\n                }\\n                //update the max robots if cost is less than budget\\n                if(pq.size() and curr_cost*(j-i+1)+pq.top().first<=budget){\\n                    max_robots = max(max_robots,j-i+1);\\n                }\\n            }\\n        }\\n        return max_robots;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& ct, vector<int>& rt, long long budget) {\\n        long long n = ct.size();\\n        long long max_robots = 0, i = 0, curr_cost = 0;\\n        //we will store the maximum element of a subarray and its corresponding index in a priority queue\\n        priority_queue<pair<long long,long long>>pq;\\n        for(long long j=0;j<n;j++){\\n            curr_cost+=rt[j];\\n            pq.push({ct[j],j});\\n            //if the current total cost is less than budget update the number of robots\\n            if(pq.size() and curr_cost*(j-i+1)+pq.top().first<=budget){\\n                max_robots = max(max_robots,j-i+1);\\n            }else{\\n                //our current total cost is exceeding budget so increment the starting index of current subarray \\n                while(pq.size() and curr_cost*(j-i+1)+pq.top().first>budget){\\n                    curr_cost-=rt[i];\\n                    //if the maximum element lies in the previous range pop them out until the maximum element is \\n                    //within the range of current subarray\\n                    while(pq.size() and pq.top().second<=i){\\n                        pq.pop();\\n                    }\\n                    i++;\\n                }\\n                //update the max robots if cost is less than budget\\n                if(pq.size() and curr_cost*(j-i+1)+pq.top().first<=budget){\\n                    max_robots = max(max_robots,j-i+1);\\n                }\\n            }\\n        }\\n        return max_robots;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524813,
                "title": "sliding-window-and-priority-queue",
                "content": "\\nWe keep track of  the max till now using a priority queue and keep adding to it untill it exceeds the given budget.\\nWhen it exceeds the budget we start removing the elements from the start(using another pointer j).\\n```\\n public int maximumRobots(int[] ct, int[] rc, long budget) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        int n = rc.length;\\n        int res = Integer.MIN_VALUE;\\n        long cost = 0;\\n        for (int i = 0, j = 0; i < n; i++) {\\n            cost += rc[i];\\n            pq.add(ct[i]);\\n            while (!pq.isEmpty() && (pq.peek() + pq.size() * cost > budget)) {\\n                pq.remove(ct[j]);\\n                cost -= rc[j];\\n                j++;\\n            }\\n            res = Math.max(res, pq.size());\\n        }\\n        return res;\\n    } \\n```\\n\\n\\tTime Complexity - O(N log N) - Since each element goes and comes out of the priority queue only once, it\\'s O(2 N log N) but we can drop the 2.\\nSpace Complexity - O(N) -Size of Priority Queue - When the budget is high, all the elements of the array might enter the priority queue.",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\n public int maximumRobots(int[] ct, int[] rc, long budget) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        int n = rc.length;\\n        int res = Integer.MIN_VALUE;\\n        long cost = 0;\\n        for (int i = 0, j = 0; i < n; i++) {\\n            cost += rc[i];\\n            pq.add(ct[i]);\\n            while (!pq.isEmpty() && (pq.peek() + pq.size() * cost > budget)) {\\n                pq.remove(ct[j]);\\n                cost -= rc[j];\\n                j++;\\n            }\\n            res = Math.max(res, pq.size());\\n        }\\n        return res;\\n    } \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2525713,
                "title": "python-sliding-window-max-heap",
                "content": "look for the largest valid window.\\ninitiallize 2 pointers `left` and `right` for the boundries, the window size is `right - left + 1.`\\nat every iteration add new robot to the window, if we exceed the budget then we have to shift our left pointer.\\nusing a `max_heap` to keep track of the maximum charge time in the current window.\\nin our `max_heap` we also save the robot\\'s **index** to so we can easily know if the current robot is still valid meaning its still in the window. if ```max_heap[0][1] <= left``` is true, it means the current robot is not in the window anymore, hence we have to pop it from our heap.\\nwhen the while loop ends, we have a valid window, therefore we update the result.\\n\\n```\\nclass Solution:\\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\\n        n = len(chargeTimes)\\n        print(n)\\n        max_heap = []\\n        left = s = res = 0\\n        for right in range(n):\\n            s += runningCosts[right]\\n            heapq.heappush(max_heap, (-chargeTimes[right], right))\\n            while max_heap and (-max_heap[0][0]) + s * (right - left + 1) > budget:\\n                s -= runningCosts[left]\\n                while max_heap and max_heap[0][1] <= left:\\n                    heapq.heappop(max_heap)\\n                left += 1\\n            res = max(res, right - left + 1)\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window",
                    "Heap (Priority Queue)"
                ],
                "code": "```max_heap[0][1] <= left```\n```\\nclass Solution:\\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\\n        n = len(chargeTimes)\\n        print(n)\\n        max_heap = []\\n        left = s = res = 0\\n        for right in range(n):\\n            s += runningCosts[right]\\n            heapq.heappush(max_heap, (-chargeTimes[right], right))\\n            while max_heap and (-max_heap[0][0]) + s * (right - left + 1) > budget:\\n                s -= runningCosts[left]\\n                while max_heap and max_heap[0][1] <= left:\\n                    heapq.heappop(max_heap)\\n                left += 1\\n            res = max(res, right - left + 1)\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524982,
                "title": "c-sliding-window-easy-solution-segmenttree",
                "content": "```\\nclass SegmentTreeMax\\n{\\nprivate:\\n    vector<int> arr;\\n    vector<int> seg;\\n    int low = 0;\\n    int high = 0;\\n    int build(int i, int low, int high)\\n    {\\n        if (low == high)\\n        {\\n            return seg[i] = arr[low];\\n        }\\n        int mid = (low + high) / 2;\\n        return seg[i] = max(build(i * 2 + 1, low, mid), build(i * 2 + 2, mid + 1, high));\\n    }\\n\\n    int rangeMaxHelper(int i, int low, int high, int l, int r)\\n    {\\n        if (low >= l && high <= r)\\n        {\\n            return seg[i];\\n        }\\n        if (high < l || low > r)\\n        {\\n            return INT_MIN;\\n        }\\n        int mid = (low + high) / 2;\\n        return max(rangeMaxHelper(i * 2 + 1, low, mid, l, r), rangeMaxHelper(i * 2 + 2, mid + 1, high, l, r));\\n    }\\n\\npublic:\\n    SegmentTreeMax(vector<int> arr1)\\n    {\\n        seg = vector<int>(4 * arr1.size(), INT_MIN);\\n        arr = arr1;\\n        high = arr1.size() - 1;\\n        build(0, low, high);\\n    }\\n    int rangeMax(int l, int r)\\n    {\\n        return rangeMaxHelper(0, low, high, l, r);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        long long l = 0;\\n        long long ans = 0;\\n        SegmentTreeMax seg(chargeTimes);\\n        long long rangeSum = 0;\\n        \\n        for(int i=0;i<chargeTimes.size();i++){\\n            \\n            long long mSum = seg.rangeMax(l,i);\\n            rangeSum += runningCosts[i];\\n            \\n            long long sum = ( (i-l) + 1) * rangeSum + mSum;\\n            \\n            while(sum>budget ){\\n                rangeSum-=runningCosts[l];\\n                l++;\\n                \\n                mSum = seg.rangeMax(l,i);\\n                sum = ( (i-l) + 1) * rangeSum + mSum;\\n            }\\n            \\n            ans = max(ans, 1 + (i-l) );\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Sliding Window"
                ],
                "code": "```\\nclass SegmentTreeMax\\n{\\nprivate:\\n    vector<int> arr;\\n    vector<int> seg;\\n    int low = 0;\\n    int high = 0;\\n    int build(int i, int low, int high)\\n    {\\n        if (low == high)\\n        {\\n            return seg[i] = arr[low];\\n        }\\n        int mid = (low + high) / 2;\\n        return seg[i] = max(build(i * 2 + 1, low, mid), build(i * 2 + 2, mid + 1, high));\\n    }\\n\\n    int rangeMaxHelper(int i, int low, int high, int l, int r)\\n    {\\n        if (low >= l && high <= r)\\n        {\\n            return seg[i];\\n        }\\n        if (high < l || low > r)\\n        {\\n            return INT_MIN;\\n        }\\n        int mid = (low + high) / 2;\\n        return max(rangeMaxHelper(i * 2 + 1, low, mid, l, r), rangeMaxHelper(i * 2 + 2, mid + 1, high, l, r));\\n    }\\n\\npublic:\\n    SegmentTreeMax(vector<int> arr1)\\n    {\\n        seg = vector<int>(4 * arr1.size(), INT_MIN);\\n        arr = arr1;\\n        high = arr1.size() - 1;\\n        build(0, low, high);\\n    }\\n    int rangeMax(int l, int r)\\n    {\\n        return rangeMaxHelper(0, low, high, l, r);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        long long l = 0;\\n        long long ans = 0;\\n        SegmentTreeMax seg(chargeTimes);\\n        long long rangeSum = 0;\\n        \\n        for(int i=0;i<chargeTimes.size();i++){\\n            \\n            long long mSum = seg.rangeMax(l,i);\\n            rangeSum += runningCosts[i];\\n            \\n            long long sum = ( (i-l) + 1) * rangeSum + mSum;\\n            \\n            while(sum>budget ){\\n                rangeSum-=runningCosts[l];\\n                l++;\\n                \\n                mSum = seg.rangeMax(l,i);\\n                sum = ( (i-l) + 1) * rangeSum + mSum;\\n            }\\n            \\n            ans = max(ans, 1 + (i-l) );\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524716,
                "title": "greedy-sliding-window-priorityqueue-for-max-element",
                "content": "* Find score till now \\n* if score get fits in criteria then store the best answer\\n* if its not simply calculate our ans for next score \\n* even if the score of current index exceeds the budget then reset everything\\n```\\n public int maximumRobots(int[] charge, int[] running, long budget) {\\n        PriorityQueue<Integer> pq\\n            = new PriorityQueue<Integer>((o1,o2)->(o2-o1));\\n        long ans=0,sum=0,count=0;\\n        \\n        for(int i=0; i<charge.length; i++){\\n            pq.add(charge[i]); sum+=running[i];\\n            \\n            if(getScore(sum,pq.peek(),count+1)<=budget){\\n                ans=Math.max(ans,count+1); count++; \\n            }else if(getScore(sum,pq.peek(),count+1)==getScore(running[i],charge[i],1)){\\n                count=0; sum=0; pq.clear(); \\n            }else{\\n        \\n                pq.remove(charge[i-(int)count]); sum-=running[i-(int)count]; \\n            }\\n        }\\n        \\n        return (int)ans;\\n    }\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\n public int maximumRobots(int[] charge, int[] running, long budget) {\\n        PriorityQueue<Integer> pq\\n            = new PriorityQueue<Integer>((o1,o2)->(o2-o1));\\n        long ans=0,sum=0,count=0;\\n        \\n        for(int i=0; i<charge.length; i++){\\n            pq.add(charge[i]); sum+=running[i];\\n            \\n            if(getScore(sum,pq.peek(),count+1)<=budget){\\n                ans=Math.max(ans,count+1); count++; \\n            }else if(getScore(sum,pq.peek(),count+1)==getScore(running[i],charge[i],1)){\\n                count=0; sum=0; pq.clear(); \\n            }else{\\n        \\n                pq.remove(charge[i-(int)count]); sum-=running[i-(int)count]; \\n            }\\n        }\\n        \\n        return (int)ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2524682,
                "title": "c-explained-solution-using-sliding-window-and-multiset-time-o-nlogn-space-o-n",
                "content": "**Approach -**\\n\\nStep 1 - Take two pointer i and j, Initialize both with 0.\\nStep 2 - Iterate loop from 0 to n-1using pointer i\\n* Calculate the cost for pointer i and add to curCost.\\n-Use multiset to find max chargeTime in log(n)\\n* If curCost is greater than budget.\\n-Reduced cost form curCost for pointer j while curCost is greater than budget.\\n* If length form j to i  in greater than answer, than store length in answer.\\n\\n\\n**Code-**\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& time, vector<int>& cost, long long tar) {\\n        \\n        int i =0, j=0 , n = cost.size(),ans=0;\\n        long long sum=0,curCost;\\n        multiset<int> s;\\n        while(i<n)\\n        {\\n            sum += cost[i];\\n            s.insert(time[i]);\\n            curCost = (i-j+1)*sum+*s.rbegin();\\n            while(j<=i&&curCost>tar)\\n            {\\n                sum -= cost[j];\\n                auto it = s.find(time[j]);\\n                s.erase(it);\\n                j++;\\n                if(j>i) curCost =0 ;\\n                else curCost = (i-j+1)*sum+*s.rbegin();\\n            }\\n            ans = max(ans,i-j+1);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Time Complexity - O(NlogN) \\nSpace Complexity - O(N)**\\nN is length of given array\\n\\n**Upvote if you like it!**\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& time, vector<int>& cost, long long tar) {\\n        \\n        int i =0, j=0 , n = cost.size(),ans=0;\\n        long long sum=0,curCost;\\n        multiset<int> s;\\n        while(i<n)\\n        {\\n            sum += cost[i];\\n            s.insert(time[i]);\\n            curCost = (i-j+1)*sum+*s.rbegin();\\n            while(j<=i&&curCost>tar)\\n            {\\n                sum -= cost[j];\\n                auto it = s.find(time[j]);\\n                s.erase(it);\\n                j++;\\n                if(j>i) curCost =0 ;\\n                else curCost = (i-j+1)*sum+*s.rbegin();\\n            }\\n            ans = max(ans,i-j+1);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2526426,
                "title": "c-sliding-window-multiset-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& ct, vector<int>& rc, long long budget) \\n    {\\n        multiset<int,greater<int>> s;\\n        int i=0,j=0;\\n        int ans=0;\\n        long long sum=0;\\n        \\n        while(j<ct.size())\\n        {\\n            s.insert(ct[j]);\\n            sum+=rc[j];\\n            while(s.size() && *s.begin()+(j-i+1)*sum>budget)\\n            {\\n                s.erase(s.find(ct[i]));\\n                sum-=rc[i];\\n                i++;\\n            }\\n            ans=max(ans,j-i+1);\\n            j++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    int maximumRobots(vector<int>& ct, vector<int>& rc, long long budget) \\n    {\\n        multiset<int,greater<int>> s;\\n        int i=0,j=0;\\n        int ans=0;\\n        long long sum=0;\\n        \\n        while(j<ct.size())\\n        {\\n            s.insert(ct[j]);\\n            sum+=rc[j];\\n            while(s.size() && *s.begin()+(j-i+1)*sum>budget)\\n            {\\n                s.erase(s.find(ct[i]));\\n                sum-=rc[i];\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2524691,
                "title": "deque-multiset-sliding-window",
                "content": "***MultiSet Approach:\\nTime Complexity = O(NlogN)\\nSpace Complexity = O(N**)*\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maximumRobots(vector<int>& ct, vector<int>& rt, long long budget) {\\n\\t\\t\\tlong long pre = 0;\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tmultiset<int>st;\\n\\t\\t\\t for(int i=0,j = 0,maxi;i<size(ct);i++){\\n\\t\\t\\t\\tpre+=rt[i];\\n\\t\\t\\t\\t st.insert(ct[i]);\\n\\t\\t\\t\\t maxi = *st.rbegin();\\n\\t\\t\\t\\tlong total = maxi + pre*(i-j+1);\\n\\t\\t\\t\\twhile(j<=i and total>budget){\\n\\t\\t\\t\\t\\tif(maxi==ct[j]) st.erase(maxi);\\n\\t\\t\\t\\t\\t\\tpre-=rt[j++];\\n\\t\\t\\t\\t\\tif(st.size()) maxi = *st.rbegin();\\n\\t\\t\\t\\t\\ttotal = pre*(i-j+1) + maxi;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tres = max(res,i-j+1);\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};\\n\\n***Deque Approach\\nTime Complexity = O(N)\\nSpace Complexity = O(N)***\\n\\n\\t\\tclass Solution {\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tint maximumRobots(vector<int>& ct, vector<int>& rt, long long budget) {\\n\\t\\t\\t\\t\\tlong long pre = 0;\\n\\t\\t\\t\\t\\tint res = 0;\\n\\t\\t\\t\\t\\tdeque<int>q;\\n\\t\\t\\t\\t\\tfor(int i=0,j = 0;i<size(ct);i++){\\n\\t\\t\\t\\t\\t\\tpre+=rt[i];\\n\\t\\t\\t\\t\\t\\twhile(q.size() and q.back()<ct[i]) q.pop_back();\\n\\t\\t\\t\\t\\t\\tq.push_back(ct[i]);\\n\\t\\t\\t\\t\\t\\tlong total = q.front() + pre*(i-j+1);\\n\\t\\t\\t\\t\\t\\twhile(total>budget){\\n\\t\\t\\t\\t\\t\\t\\tif(q.front()==ct[j]) q.pop_front();\\n\\t\\t\\t\\t\\t\\t\\t\\tpre-=rt[j++];\\n\\t\\t\\t\\t\\t\\t\\t\\ttotal = pre*(i-j+1) + q.front();\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tres = max(res,i-j+1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn res;\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t\\t\\n\\t\\n***Similiar Question - [Sliding Window Maximum](http:/https://leetcode.com/problems/sliding-window-maximum//)***",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint maximumRobots(vector<int>& ct, vector<int>& rt, long long budget) {\\n\\t\\t\\tlong long pre = 0;\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tmultiset<int>st;\\n\\t\\t\\t for(int i=0,j = 0,maxi;i<size(ct);i++){\\n\\t\\t\\t\\tpre+=rt[i];\\n\\t\\t\\t\\t st.insert(ct[i]);\\n\\t\\t\\t\\t maxi = *st.rbegin();\\n\\t\\t\\t\\tlong total = maxi + pre*(i-j+1);\\n\\t\\t\\t\\twhile(j<=i and total>budget){\\n\\t\\t\\t\\t\\tif(maxi==ct[j]) st.erase(maxi);\\n\\t\\t\\t\\t\\t\\tpre-=rt[j++];\\n\\t\\t\\t\\t\\tif(st.size()) maxi = *st.rbegin();\\n\\t\\t\\t\\t\\ttotal = pre*(i-j+1) + maxi;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2524677,
                "title": "sparse-table-binary-search-o-nlog-n-c",
                "content": "```\\n#define ll long long\\nstruct sparse_table {\\n    ll level, n;\\n    vector<vector<ll>> table;\\n    vector<ll> lg;\\n    \\n    sparse_table(vector<int> &a) {\\n        n = a.size();\\n        level = ceil(log2(n));\\n        table.resize(n, vector<ll> (level + 1));\\n        lg.resize(n + 1);\\n        build(a);\\n    }\\n    \\n    void build(vector<int> &a) {\\n        lg[1] = 0;\\n        for(int i = 2; i < n + 1; ++i)\\n            lg[i] = lg[i / 2] + 1;\\n            \\n        for(int i = 0; i < n; ++i) \\n            table[i][0] = a[i];\\n        \\n        for(int j = 1; j <= level; ++j) {\\n            for(int i = 0; i + (1LL << j) <= n; ++i) {\\n                table[i][j] = max(table[i][j - 1], table[i + (1LL << (j - 1))][j - 1]);\\n            }\\n        }\\n    }\\n    \\n    ll query(ll l, ll r) {\\n        l--, r--;\\n        ll j = lg[r - l + 1];\\n    \\n        return max(table[l][j], table[r - (1LL << j) + 1][j]);\\n    }\\n};\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& ct, vector<int>& rt, long long budget) {\\n        ll n = ct.size();\\n        sparse_table rmq(ct); // for getting maximum in a range [l, r] in O(1)\\n        \\n        vector<ll> pre(n + 1, 0);\\n        for(int i = 0; i < n; ++i) pre[i + 1] =  pre[i] + rt[i]; // precalculating prefix sums on running costs\\n        \\n        ll res = 0;\\n        for(int i = 0; i < n; ++i) {\\n            int lo = i, hi = n - 1, ind = -1;\\n            while(lo <= hi) {\\n                int mid = lo + (hi - lo) / 2;\\n                ll mx = rmq.query(i + 1, mid + 1); // maximum in the current range\\n                ll sum = pre[mid + 1] - pre[i]; // range sum \\n                \\n                if(mx + (mid - i + 1) * sum <= budget) { // if the current range cost is less than or equal to budget\\n                    ind = mid;\\n                    lo = mid + 1;\\n                } else {\\n                    hi = mid - 1;\\n                }\\n            }\\n            if(ind != -1) {\\n                res = max(res, 1LL * (ind - i + 1));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\nstruct sparse_table {\\n    ll level, n;\\n    vector<vector<ll>> table;\\n    vector<ll> lg;\\n    \\n    sparse_table(vector<int> &a) {\\n        n = a.size();\\n        level = ceil(log2(n));\\n        table.resize(n, vector<ll> (level + 1));\\n        lg.resize(n + 1);\\n        build(a);\\n    }\\n    \\n    void build(vector<int> &a) {\\n        lg[1] = 0;\\n        for(int i = 2; i < n + 1; ++i)\\n            lg[i] = lg[i / 2] + 1;\\n            \\n        for(int i = 0; i < n; ++i) \\n            table[i][0] = a[i];\\n        \\n        for(int j = 1; j <= level; ++j) {\\n            for(int i = 0; i + (1LL << j) <= n; ++i) {\\n                table[i][j] = max(table[i][j - 1], table[i + (1LL << (j - 1))][j - 1]);\\n            }\\n        }\\n    }\\n    \\n    ll query(ll l, ll r) {\\n        l--, r--;\\n        ll j = lg[r - l + 1];\\n    \\n        return max(table[l][j], table[r - (1LL << j) + 1][j]);\\n    }\\n};\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& ct, vector<int>& rt, long long budget) {\\n        ll n = ct.size();\\n        sparse_table rmq(ct); // for getting maximum in a range [l, r] in O(1)\\n        \\n        vector<ll> pre(n + 1, 0);\\n        for(int i = 0; i < n; ++i) pre[i + 1] =  pre[i] + rt[i]; // precalculating prefix sums on running costs\\n        \\n        ll res = 0;\\n        for(int i = 0; i < n; ++i) {\\n            int lo = i, hi = n - 1, ind = -1;\\n            while(lo <= hi) {\\n                int mid = lo + (hi - lo) / 2;\\n                ll mx = rmq.query(i + 1, mid + 1); // maximum in the current range\\n                ll sum = pre[mid + 1] - pre[i]; // range sum \\n                \\n                if(mx + (mid - i + 1) * sum <= budget) { // if the current range cost is less than or equal to budget\\n                    ind = mid;\\n                    lo = mid + 1;\\n                } else {\\n                    hi = mid - 1;\\n                }\\n            }\\n            if(ind != -1) {\\n                res = max(res, 1LL * (ind - i + 1));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848693,
                "title": "c-o-n-sliding-window-dequeue",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        int n=chargeTimes.size();\\n        \\n        int ans=0;\\n        \\n        deque<int> dq; // storing elements in \\'descending order\\': front -> max. , rear -> min.\\n        \\n        int i=0;\\n        long long sum=0;\\n        for(int j=0;j<n;j++){\\n            sum += runningCosts[j];\\n            \\n            while(dq.size()>0 && dq.back()<chargeTimes[j]) dq.pop_back();\\n            dq.push_back(chargeTimes[j]);\\n            \\n            long long cost = sum*(j-i+1) + dq.front();\\n            \\n            while(i<=j && cost>budget){\\n                sum -= runningCosts[i];\\n                \\n                if(dq.front()==chargeTimes[i]) dq.pop_front();\\n                i++;\\n                \\n                cost = sum*(j-i+1) + dq.front();\\n            }\\n            ans=max(ans,j-i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Do upvote if it helps:)**",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        int n=chargeTimes.size();\\n        \\n        int ans=0;\\n        \\n        deque<int> dq; // storing elements in \\'descending order\\': front -> max. , rear -> min.\\n        \\n        int i=0;\\n        long long sum=0;\\n        for(int j=0;j<n;j++){\\n            sum += runningCosts[j];\\n            \\n            while(dq.size()>0 && dq.back()<chargeTimes[j]) dq.pop_back();\\n            dq.push_back(chargeTimes[j]);\\n            \\n            long long cost = sum*(j-i+1) + dq.front();\\n            \\n            while(i<=j && cost>budget){\\n                sum -= runningCosts[i];\\n                \\n                if(dq.front()==chargeTimes[i]) dq.pop_front();\\n                i++;\\n                \\n                cost = sum*(j-i+1) + dq.front();\\n            }\\n            ans=max(ans,j-i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2530099,
                "title": "c-sliding-window-multiset-prefix-sum-o-n-logn-important-explaination",
                "content": "Sliding Window, Multiset, Prefix Sum Approach !!\\nEasy and Important Question as per Interview Point of view.\\n\\n**Approach :-**\\n\\n* Try to  use sliding window technique to get the value for subarray [start,end].\\n* We can use Prefix sum for calculating the sum of Running Costs.\\n* If the value that we calculated via the formula that is mentioned in the question \"**max(chargeTimes) + k*sum(runningCosts)**\" exceeds budget then simply move start and remove values that is associated with the start to get the new value.\\n*  And each time take maximum of the length of subarray, as we need to return that only.\\n\\n**`NOTE:- We can also use Priority Queue in case of using Multiset.`**\\n\\n**Complexity Analysis:-**\\n\\n**Time Complexity:- O(n*logn)\\nSpace Complexity:- O(n)**\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        \\n        multiset<int> st;\\n       \\n        int n=chargeTimes.size();\\n        vector<long long> pre(n);\\n        pre[0]=runningCosts[0];\\n        \\n        for(int i=1;i<n;i++){\\n            pre[i]=runningCosts[i]+pre[i-1];\\n        }\\n        \\n        int j=0;\\n        int maxi=0;\\n        for(int i=0;i<n;i++){\\n            st.insert(chargeTimes[i]);\\n            long long res;\\n            if(j!=0){\\n               res=*(st.rbegin())+(i-j+1)*(pre[i]-pre[j-1]); \\n            }\\n            else{\\n               res=*(st.rbegin())+(i-j+1)*(pre[i]-0);\\n            }\\n            \\n            if(res <= budget){\\n                maxi=max(maxi,(i-j+1));\\n    \\n                cout<<chargeTimes[i]<<endl;\\n                \\n            }\\n            else{\\n                while(j<=i){\\n                    st.erase(st.find(chargeTimes[j]));\\n                    j=j+1;\\n                    if(i<j){\\n                        break;\\n                    }\\n                    long long res2=*(st.rbegin())+(i-j+1)*(pre[i]-pre[j-1]);\\n                    \\n                    if(res2>budget){\\n                        continue;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n                \\n            }\\n    \\n            \\n        }\\n        \\n        return maxi;\\n      \\n    }\\n};\\n\\n\\n\\n    \\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Heap (Priority Queue)",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        \\n        multiset<int> st;\\n       \\n        int n=chargeTimes.size();\\n        vector<long long> pre(n);\\n        pre[0]=runningCosts[0];\\n        \\n        for(int i=1;i<n;i++){\\n            pre[i]=runningCosts[i]+pre[i-1];\\n        }\\n        \\n        int j=0;\\n        int maxi=0;\\n        for(int i=0;i<n;i++){\\n            st.insert(chargeTimes[i]);\\n            long long res;\\n            if(j!=0){\\n               res=*(st.rbegin())+(i-j+1)*(pre[i]-pre[j-1]); \\n            }\\n            else{\\n               res=*(st.rbegin())+(i-j+1)*(pre[i]-0);\\n            }\\n            \\n            if(res <= budget){\\n                maxi=max(maxi,(i-j+1));\\n    \\n                cout<<chargeTimes[i]<<endl;\\n                \\n            }\\n            else{\\n                while(j<=i){\\n                    st.erase(st.find(chargeTimes[j]));\\n                    j=j+1;\\n                    if(i<j){\\n                        break;\\n                    }\\n                    long long res2=*(st.rbegin())+(i-j+1)*(pre[i]-pre[j-1]);\\n                    \\n                    if(res2>budget){\\n                        continue;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n                \\n            }\\n    \\n            \\n        }\\n        \\n        return maxi;\\n      \\n    }\\n};\\n\\n\\n\\n    \\n```",
                "codeTag": "C++"
            },
            {
                "id": 2524824,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int>sum;\\n    long long func(const vector<int>& cc, const vector<int>& rc, ll k) {\\n        if (k == 0) {\\n            return 0;\\n        }\\n        priority_queue<pair<int,int>>pq;\\n        for (int i = 0;i < k;++i) {\\n            pq.push({ cc[i],i });\\n        }\\n        long long ans = (sum[k - 1] * k) + pq.top().first;\\n        for (int i = 1;i + k - 1 < n;++i) {\\n            pq.push({ cc[i + k - 1], i + k - 1 });\\n            while (pq.top().second < i) {\\n                pq.pop();\\n            }\\n            ans = min(ans, (sum[i + k - 1] - sum[i - 1]) * k + pq.top().first);\\n        }\\n        return ans;\\n    }\\n    int maximumRobots(vector<int>& cc, vector<int>& rc, long long b) {\\n        n = cc.size();\\n        sum.assign(n, 0);\\n        sum[0] = rc[0];\\n        for (int i = 1;i < n;++i) {\\n            sum[i] = sum[i - 1] + rc[i];\\n        }\\n        int ans = 0, l = 0, r = n;\\n        while (l <= r) {\\n            long long m = l + ((r - l) >> 1), req = func(cc, rc, m);\\n            if (req <= b) {\\n                ans = m;\\n                l = m + 1;\\n            }\\n            else {\\n                r = m - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int>sum;\\n    long long func(const vector<int>& cc, const vector<int>& rc, ll k) {\\n        if (k == 0) {\\n            return 0;\\n        }\\n        priority_queue<pair<int,int>>pq;\\n        for (int i = 0;i < k;++i) {\\n            pq.push({ cc[i],i });\\n        }\\n        long long ans = (sum[k - 1] * k) + pq.top().first;\\n        for (int i = 1;i + k - 1 < n;++i) {\\n            pq.push({ cc[i + k - 1], i + k - 1 });\\n            while (pq.top().second < i) {\\n                pq.pop();\\n            }\\n            ans = min(ans, (sum[i + k - 1] - sum[i - 1]) * k + pq.top().first);\\n        }\\n        return ans;\\n    }\\n    int maximumRobots(vector<int>& cc, vector<int>& rc, long long b) {\\n        n = cc.size();\\n        sum.assign(n, 0);\\n        sum[0] = rc[0];\\n        for (int i = 1;i < n;++i) {\\n            sum[i] = sum[i - 1] + rc[i];\\n        }\\n        int ans = 0, l = 0, r = n;\\n        while (l <= r) {\\n            long long m = l + ((r - l) >> 1), req = func(cc, rc, m);\\n            if (req <= b) {\\n                ans = m;\\n                l = m + 1;\\n            }\\n            else {\\n                r = m - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524823,
                "title": "sliding-window-deque",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        deque<int> d;\\n        int res = 0;\\n        int n = chargeTimes.size();\\n        int i = 0;\\n        int j = 0;\\n        long long sum = 0;\\n        \\n        while(j<n){\\n            while( !d.empty() && d.back() < chargeTimes[j])\\n                d.pop_back();\\n            \\n            d.push_back(chargeTimes[j]);\\n            sum += runningCosts[j];\\n            \\n            int windowSize = j - i + 1;\\n            if(d.front() +  windowSize*sum <= budget){\\n                res = max(res, windowSize);\\n                j++;\\n            }\\n            \\n            else{\\n                if(d.front()==chargeTimes[i])\\n                    d.pop_front();\\n                \\n                sum -= runningCosts[i];\\n                i++;\\n                j++;\\n            }\\n            \\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\nSimilar ques : 239. [Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        deque<int> d;\\n        int res = 0;\\n        int n = chargeTimes.size();\\n        int i = 0;\\n        int j = 0;\\n        long long sum = 0;\\n        \\n        while(j<n){\\n            while( !d.empty() && d.back() < chargeTimes[j])\\n                d.pop_back();\\n            \\n            d.push_back(chargeTimes[j]);\\n            sum += runningCosts[j];\\n            \\n            int windowSize = j - i + 1;\\n            if(d.front() +  windowSize*sum <= budget){\\n                res = max(res, windowSize);\\n                j++;\\n            }\\n            \\n            else{\\n                if(d.front()==chargeTimes[i])\\n                    d.pop_front();\\n                \\n                sum -= runningCosts[i];\\n                i++;\\n                j++;\\n            }\\n            \\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524798,
                "title": "sliding-window-c",
                "content": "* The basic idea is to use two pointers in order to maintain a variable length sliding window.\\n* According to the problem the given expression is **max(chargeTimes) + k * sum(runningCosts)**.\\n* So to maintain  sum(runningCosts) I have used **prefix sum** and to get max element in present window **priority queue** is begin used.\\n\\nTime Complexity: O(nlogn)\\nSpace Complexity: O(n)\\n```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        int ans=0;\\n        int n=chargeTimes.size();\\n\\n        vector <long long> prefix(n,0);\\n        prefix[0]=runningCosts[0];\\n        for(int i=1;i<n;i++){\\n            prefix[i]+=prefix[i-1]+runningCosts[i];\\n        }\\n        \\n        long long cost=0;\\n        long long p=0,q=0;\\n        priority_queue <pair<long long,int>> pq;\\n        \\n        while(q<n){\\n            while(q<n){\\n                pq.push({chargeTimes[q],q});\\n                if(p==0){\\n                    cost=prefix[q]*(q-p+1)+pq.top().first;\\n                }\\n                else{\\n                    cost=(prefix[q]-prefix[p-1])*(q-p+1)+pq.top().first;\\n                }\\n                \\n                if(cost<=budget){\\n                    if(ans<q-p+1){\\n                     ans=q-p+1;\\n                   }\\n                }\\n                else \\n                    break;\\n                q++;\\n            }\\n            \\n            if(q>=n){\\n                break;\\n            }\\n            \\n            if(p<q){\\n                p++;\\n            }\\n            else{\\n                p++;\\n                q++;\\n            }\\n            \\n            while(!pq.empty() && pq.top().second<p){\\n                pq.pop();\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window",
                    "Heap (Priority Queue)",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        int ans=0;\\n        int n=chargeTimes.size();\\n\\n        vector <long long> prefix(n,0);\\n        prefix[0]=runningCosts[0];\\n        for(int i=1;i<n;i++){\\n            prefix[i]+=prefix[i-1]+runningCosts[i];\\n        }\\n        \\n        long long cost=0;\\n        long long p=0,q=0;\\n        priority_queue <pair<long long,int>> pq;\\n        \\n        while(q<n){\\n            while(q<n){\\n                pq.push({chargeTimes[q],q});\\n                if(p==0){\\n                    cost=prefix[q]*(q-p+1)+pq.top().first;\\n                }\\n                else{\\n                    cost=(prefix[q]-prefix[p-1])*(q-p+1)+pq.top().first;\\n                }\\n                \\n                if(cost<=budget){\\n                    if(ans<q-p+1){\\n                     ans=q-p+1;\\n                   }\\n                }\\n                else \\n                    break;\\n                q++;\\n            }\\n            \\n            if(q>=n){\\n                break;\\n            }\\n            \\n            if(p<q){\\n                p++;\\n            }\\n            else{\\n                p++;\\n                q++;\\n            }\\n            \\n            while(!pq.empty() && pq.top().second<p){\\n                pq.pop();\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524761,
                "title": "simple-sliding-window-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        int i = 0;\\n        long long currSum = 0;\\n        long long cost = 0;\\n        int ans = 0;\\n        \\n        multiset<int> orderedSet;\\n        for(int j = 0; j<chargeTimes.size(); j++)\\n        {\\n            orderedSet.insert(chargeTimes[j]);\\n            cost += runningCosts[j];\\n            currSum = (*orderedSet.rbegin()) + (j - i + 1) * (cost);\\n            \\n            while(currSum > budget and i<=j)\\n            {\\n                cost -= runningCosts[i];\\n                orderedSet.erase(orderedSet.find(chargeTimes[i]));\\n                i+=1;\\n                if(!orderedSet.empty())\\n                    currSum = (*orderedSet.rbegin()) + (j - i + 1) * (cost);\\n                else\\n                    currSum = 0;\\n            }\\n            \\n            ans = max(ans, j - i + 1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        int i = 0;\\n        long long currSum = 0;\\n        long long cost = 0;\\n        int ans = 0;\\n        \\n        multiset<int> orderedSet;\\n        for(int j = 0; j<chargeTimes.size(); j++)\\n        {\\n            orderedSet.insert(chargeTimes[j]);\\n            cost += runningCosts[j];\\n            currSum = (*orderedSet.rbegin()) + (j - i + 1) * (cost);\\n            \\n            while(currSum > budget and i<=j)\\n            {\\n                cost -= runningCosts[i];\\n                orderedSet.erase(orderedSet.find(chargeTimes[i]));\\n                i+=1;\\n                if(!orderedSet.empty())\\n                    currSum = (*orderedSet.rbegin()) + (j - i + 1) * (cost);\\n                else\\n                    currSum = 0;\\n            }\\n            \\n            ans = max(ans, j - i + 1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524720,
                "title": "sliding-window-with-bst-explanations-java",
                "content": "This is a  \"Variable size sliding window\" technique, also called \"Caterpillar method\" or \"Two pointers\"\\n\\nInspired by this template for finding maximum substring problems: https://leetcode.com/problems/minimum-window-substring/discuss/26808/Here-is-a-10-line-template-that-can-solve-most-\\'substring\\'-problems\\n\\nThe only trick here is to update the maximum of `chargeTimes`. Normally you would use a priority queue (for O(1) access to maximum and O(log n) for add/remove) but in Java removing from a priority queue is O(n). Si I am using a `TreeMap` instead which represents a multiset, it stays O(log n) for add/remove but access to maximum becomes O(log n). I won\\'t change the overall complexity here which is O(n log n).  \\n\\n```\\n\\nclass Solution {\\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long maxBudget) {\\n        int n = chargeTimes.length;\\n        int start=0; //two pointers, one point to tail and one  head\\n        int max = 0;\\n          int k = 0;\\n        long totalRunningCosts = 0;\\n\\n        CustomPriorityQueue pq = new CustomPriorityQueue();\\n\\n        for (int end = 0; end < n; end++) {\\n            k++;\\n            pq.add(chargeTimes[end]);\\n            totalRunningCosts += runningCosts[end];\\n            long budget = totalRunningCosts* k + pq.getMax();\\n\\n            while(budget > maxBudget){\\n                totalRunningCosts -= runningCosts[start];\\n                pq.remove(chargeTimes[start]);\\n                start++;\\n                k--;\\n                budget = totalRunningCosts * k + pq.getMax();\\n\\n            }\\n\\n           max = Math.max(k, max);\\n        }\\n\\n        return max;\\n    }\\n    \\n    private static class CustomPriorityQueue{\\n        TreeMap<Integer, Integer> multiset = new TreeMap<>();\\n        \\n        public void add(Integer i){\\n            multiset.merge(i, 1, Integer::sum);\\n        }\\n        \\n        public void remove(Integer i){\\n            multiset.computeIfPresent(i, (_k,v) -> v <= 1 ? null : v-1);\\n        }\\n        \\n        public Integer getMax(){\\n            return multiset.isEmpty() ? 0 : multiset.lastKey();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long maxBudget) {\\n        int n = chargeTimes.length;\\n        int start=0; //two pointers, one point to tail and one  head\\n        int max = 0;\\n          int k = 0;\\n        long totalRunningCosts = 0;\\n\\n        CustomPriorityQueue pq = new CustomPriorityQueue();\\n\\n        for (int end = 0; end < n; end++) {\\n            k++;\\n            pq.add(chargeTimes[end]);\\n            totalRunningCosts += runningCosts[end];\\n            long budget = totalRunningCosts* k + pq.getMax();\\n\\n            while(budget > maxBudget){\\n                totalRunningCosts -= runningCosts[start];\\n                pq.remove(chargeTimes[start]);\\n                start++;\\n                k--;\\n                budget = totalRunningCosts * k + pq.getMax();\\n\\n            }\\n\\n           max = Math.max(k, max);\\n        }\\n\\n        return max;\\n    }\\n    \\n    private static class CustomPriorityQueue{\\n        TreeMap<Integer, Integer> multiset = new TreeMap<>();\\n        \\n        public void add(Integer i){\\n            multiset.merge(i, 1, Integer::sum);\\n        }\\n        \\n        public void remove(Integer i){\\n            multiset.computeIfPresent(i, (_k,v) -> v <= 1 ? null : v-1);\\n        }\\n        \\n        public Integer getMax(){\\n            return multiset.isEmpty() ? 0 : multiset.lastKey();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524688,
                "title": "avoid-using-set-in-cpp-sliding-window-binary-search",
                "content": "So, getting intuition of this problem is easy(if you saw the constraints during contest) but the actual problem I faced during implementation. \\n## Thought process :\\n* We can have atleast 0 robot and atmax n robot.\\n* Use binary search on robot count.\\n\\n## Implementation :\\n**Tried with Set but got tle because set is too castly in cpp (might be possible to get ac in java)**\\n* Use priority queue\\n\\t* Store <chargingTime, index>\\n\\t* while iterating if \\n\\t\\t* pq.top().index < currIndex - k do pop\\n\\t* get the required budget for current window\\n\\n```\\nclass Solution {    \\n#define ll long long\\npublic:\\n    ll budget;int n;\\n    bool is(vector<int> &ct, vector<int>&rc, ll k) {\\n        int i=0,j=0;\\n        ll sm = 0;\\n        set<int> st;\\n        priority_queue <pair<int,int>, vector<pair<int,int>>> pq;\\n        while(j<k) {\\n            pq.push({ct[j], j});\\n            sm+=rc[j];\\n            j++;\\n        }\\n        ll  b = pq.top().first + k*sm;\\n        if(b<=budget) return true;\\n        while(j<n) {\\n            sm-=rc[i++];\\n            pq.push({ct[j], j});\\n            sm+=rc[j++];\\n          while(pq.top().second<(j-k)) {\\n                pq.pop();\\n            }\\n            b = pq.top().first + k*sm;\\n            if(b<=budget) return true;\\n        }\\n        return false;\\n    }\\n    \\n    int maximumRobots(vector<int>& ct, vector<int>& rc, long long budget) {\\n        this->budget = budget;\\n        n = ct.size();\\n        int i = 1, j = n, res =0;\\n        while(i<=j) {\\n            int m = (i+j)/2;\\n            if(is(ct, rc, m)) {\\n                res = m;\\n                i = m+1;\\n            } else {\\n                j = m-1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n***please upvote if it help***\\n***happy coding***",
                "solutionTags": [
                    "C++",
                    "Sliding Window",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {    \\n#define ll long long\\npublic:\\n    ll budget;int n;\\n    bool is(vector<int> &ct, vector<int>&rc, ll k) {\\n        int i=0,j=0;\\n        ll sm = 0;\\n        set<int> st;\\n        priority_queue <pair<int,int>, vector<pair<int,int>>> pq;\\n        while(j<k) {\\n            pq.push({ct[j], j});\\n            sm+=rc[j];\\n            j++;\\n        }\\n        ll  b = pq.top().first + k*sm;\\n        if(b<=budget) return true;\\n        while(j<n) {\\n            sm-=rc[i++];\\n            pq.push({ct[j], j});\\n            sm+=rc[j++];\\n          while(pq.top().second<(j-k)) {\\n                pq.pop();\\n            }\\n            b = pq.top().first + k*sm;\\n            if(b<=budget) return true;\\n        }\\n        return false;\\n    }\\n    \\n    int maximumRobots(vector<int>& ct, vector<int>& rc, long long budget) {\\n        this->budget = budget;\\n        n = ct.size();\\n        int i = 1, j = n, res =0;\\n        while(i<=j) {\\n            int m = (i+j)/2;\\n            if(is(ct, rc, m)) {\\n                res = m;\\n                i = m+1;\\n            } else {\\n                j = m-1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525059,
                "title": "c-binary-search-solution",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        long long n;\\n    int find(vector<int> &ch, vector<int> &run, int k, long long bud)\\n    {\\n        deque<int> q;\\n        long long sum = 0;\\n        for (int i = 0; i < k; i++)\\n        {\\n            while (q.size() && ch[q.back()] < ch[i])\\n            {\\n                q.pop_back();\\n            }\\n            q.push_back(i);\\n            sum += run[i];\\n        }\\n        int xt = 0;\\n        long long max_val = ch[q.front()];\\n        if (max_val + k * sum <= bud)\\n        {\\n            return true;\\n        }\\n        for (int i = k; i < n; i++)\\n        {\\n            if (q.front() == i - k)\\n            {\\n                q.pop_front();\\n            }\\n            while (q.size() && ch[q.back()] < ch[i])\\n            {\\n                q.pop_back();\\n            }\\n            q.push_back(i);\\n            sum -= run[i - k];\\n            sum += run[i];\\n            max_val = ch[q.front()];\\n            if (max_val + k * sum <= bud)\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    int maximumRobots(vector<int> &charge, vector<int> &run, long long bud)\\n    {\\n        n = charge.size();\\n        long long l = 1;\\n        long long r = n;\\n        int ans = 0;\\n        while (l <= r)\\n        {\\n            long long mid = (l + r) / 2;\\n            if (find(charge, run, mid, bud))\\n            {\\n                ans = mid;\\n                l = mid + 1;\\n            }\\n            else\\n            {\\n                r = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        long long n;\\n    int find(vector<int> &ch, vector<int> &run, int k, long long bud)\\n    {\\n        deque<int> q;\\n        long long sum = 0;\\n        for (int i = 0; i < k; i++)\\n        {\\n            while (q.size() && ch[q.back()] < ch[i])\\n            {\\n                q.pop_back();\\n            }\\n            q.push_back(i);\\n            sum += run[i];\\n        }\\n        int xt = 0;\\n        long long max_val = ch[q.front()];\\n        if (max_val + k * sum <= bud)\\n        {\\n            return true;\\n        }\\n        for (int i = k; i < n; i++)\\n        {\\n            if (q.front() == i - k)\\n            {\\n                q.pop_front();\\n            }\\n            while (q.size() && ch[q.back()] < ch[i])\\n            {\\n                q.pop_back();\\n            }\\n            q.push_back(i);\\n            sum -= run[i - k];\\n            sum += run[i];\\n            max_val = ch[q.front()];\\n            if (max_val + k * sum <= bud)\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    int maximumRobots(vector<int> &charge, vector<int> &run, long long bud)\\n    {\\n        n = charge.size();\\n        long long l = 1;\\n        long long r = n;\\n        int ans = 0;\\n        while (l <= r)\\n        {\\n            long long mid = (l + r) / 2;\\n            if (find(charge, run, mid, bud))\\n            {\\n                ans = mid;\\n                l = mid + 1;\\n            }\\n            else\\n            {\\n                r = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524949,
                "title": "sliding-window-monotonic-queue-plus-a-combo-harder-version-of-the-problem",
                "content": "We can just slide through the runningCosts and maintain a monotonic queue for maximum of chargeTimes to keep track of the Sliding Window Maximum.\\n\\nSimilar Problems:\\n1. [Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/)\\n\\n```\\n\\nclass Solution:\\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\\n        maxQ = deque()\\n        maxCons = current = p1 = 0\\n        getBudget = lambda: chargeTimes[maxQ[0]]  + ((p2 - p1 + 1) * current) if(maxQ) else 0\\n        \\n        for p2, (charge, running) in enumerate(zip(chargeTimes, runningCosts)):\\n            current += running\\n            while(maxQ and chargeTimes[maxQ[-1]] < charge):\\n                maxQ.pop()\\n            maxQ.append(p2)\\n            \\n            while(getBudget() > budget):\\n                current -= runningCosts[p1]\\n                p1 += 1\\n                while(maxQ and maxQ[0] < p1):\\n                    maxQ.popleft()\\n            \\n            maxCons = max(maxCons, p2 - p1 + 1)\\n        return maxCons\\n                \\n            \\n```\\n\\n\\t\\t `End of the actual problem`\\n\\t\\t \\nThe below solution is for the much harder version of this problem, consider it for fun. Maximum non consecutive robots below the budget\\ncomment down you thoughts on this.\\n```\\nclass Solution:\\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\\n        max1, max2 = [], []\\n        using = set()\\n        maxCons = current = 0\\n        getBudget = lambda: -max1[0][0]  + (len(max2) * current) \\n        \\n        for i, (charge, running) in enumerate(zip(chargeTimes, runningCosts)):\\n            current += running\\n            heappush(max2, (-running, i))\\n            heappush(max1, (-charge, i))\\n            using.add(i)\\n            while(max1 and max2 and getBudget() > budget):\\n                value, index = heappop(max2)\\n                current += value\\n                using.remove(index)\\n                while(max1 and max1[0][1] not in using):\\n                    heappop(max1)\\n            maxCons = max(maxCons, len(max2))\\n            \\n        return maxCons\\n                \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\n\\nclass Solution:\\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\\n        maxQ = deque()\\n        maxCons = current = p1 = 0\\n        getBudget = lambda: chargeTimes[maxQ[0]]  + ((p2 - p1 + 1) * current) if(maxQ) else 0\\n        \\n        for p2, (charge, running) in enumerate(zip(chargeTimes, runningCosts)):\\n            current += running\\n            while(maxQ and chargeTimes[maxQ[-1]] < charge):\\n                maxQ.pop()\\n            maxQ.append(p2)\\n            \\n            while(getBudget() > budget):\\n                current -= runningCosts[p1]\\n                p1 += 1\\n                while(maxQ and maxQ[0] < p1):\\n                    maxQ.popleft()\\n            \\n            maxCons = max(maxCons, p2 - p1 + 1)\\n        return maxCons\\n                \\n            \\n```\n```\\nclass Solution:\\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\\n        max1, max2 = [], []\\n        using = set()\\n        maxCons = current = 0\\n        getBudget = lambda: -max1[0][0]  + (len(max2) * current) \\n        \\n        for i, (charge, running) in enumerate(zip(chargeTimes, runningCosts)):\\n            current += running\\n            heappush(max2, (-running, i))\\n            heappush(max1, (-charge, i))\\n            using.add(i)\\n            while(max1 and max2 and getBudget() > budget):\\n                value, index = heappop(max2)\\n                current += value\\n                using.remove(index)\\n                while(max1 and max1[0][1] not in using):\\n                    heappop(max1)\\n            maxCons = max(maxCons, len(max2))\\n            \\n        return maxCons\\n                \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524822,
                "title": "explanation-sliding-window-with-priority-queue",
                "content": "Just do the sliding window for the cost part so that cost will be less than the required amount, and use the priority_queue for the max charge time.\\n\\nwe will do sliding window for the cost part and maintain a priority queue seperatly only for the max charge part. we will add an element to sum and save that element and its index in priority_queue.\\nfor checking if current window is valid or not we will use the sum variable for the fuel sum of the current window and priority_queue top for the maximum charge time of the current window. \\nThen if the window is invalid then we will first subtract the Left most element of the window from sum and we\\'ll do l++ for shrinking the window. and repeat it till our window becomes valid. \\nWe will also check if the top of priority_queue is valid element or not my compairing it with l. if its second value is less than l , that means that element does not belong to our current window.\\nWe have to do the checking of the top element of the priority queue once before the window check and each time after updating l\\'s value.\\nFor size of the current window we will do r-l+1.\\nat the end of the loop we will check if the current valid windows lenght is max or not.\\nthen return the max valid windows length in the end.\\n\\n```\\nint maximumRobots(vector<int>& chargeTimes, vector<int>& rc, long long budget) {\\n        int l=0,r=0;\\n        int n=chargeTimes.size();\\n        priority_queue<pair<long long,long long>>pq;\\n        int ans=0;\\n        long long sum=0;\\n        while(r<n){\\n            sum+=rc[r];\\n            pq.push({chargeTimes[r],r});\\n            while(!pq.empty() && pq.top().second<l){\\n                pq.pop();\\n            }\\n            while(!pq.empty() && sum*(r-l+1)+pq.top().first>budget){\\n                sum-=rc[l];\\n                l++;\\n                \\n                while(!pq.empty() && pq.top().second<l){\\n                    pq.pop();\\n                }\\n                \\n                \\n            }\\n            ans=max(ans,r-l+1);\\n            r++;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nint maximumRobots(vector<int>& chargeTimes, vector<int>& rc, long long budget) {\\n        int l=0,r=0;\\n        int n=chargeTimes.size();\\n        priority_queue<pair<long long,long long>>pq;\\n        int ans=0;\\n        long long sum=0;\\n        while(r<n){\\n            sum+=rc[r];\\n            pq.push({chargeTimes[r],r});\\n            while(!pq.empty() && pq.top().second<l){\\n                pq.pop();\\n            }\\n            while(!pq.empty() && sum*(r-l+1)+pq.top().first>budget){\\n                sum-=rc[l];\\n                l++;\\n                \\n                while(!pq.empty() && pq.top().second<l){\\n                    pq.pop();\\n                }\\n                \\n                \\n            }\\n            ans=max(ans,r-l+1);\\n            r++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2524706,
                "title": "sparse-table-prefix-sum-java-o-nlog-n",
                "content": "```\\n    static int [] log;\\n    static int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n        int [][] sparse = new int [(int)(1e5)][17];\\n        log = new int [(int)(1e5)];\\n        log[1] = 0;\\n        for(int i = 2; i < log.length; i++) log[i] = log[i/2] + 1;\\n        \\n        for(int i = 0; i < chargeTimes.length; i++) sparse[i][0] = chargeTimes[i];\\n\\n        for(int i = 1; i < 17; i++) {\\n            for(int j = 0; j + (1<<i) - 1 < sparse.length; j++){\\n                sparse[j][i] = Math.max(sparse[j][i-1], sparse[j+(1<<(i-1))][i-1]);\\n            }\\n        }\\n\\n        long [] prefixSum = new long [runningCosts.length];\\n        prefixSum[0] = runningCosts[0];\\n        for(int i = 1; i < prefixSum.length; i++){\\n            prefixSum[i] = prefixSum[i-1] + runningCosts[i];\\n        }\\n\\n        int max = 0;\\n        for(int i = 0; i < runningCosts.length; i++) {\\n            max = Math.max(max, getMax(i, runningCosts.length-1, prefixSum, sparse, budget));\\n        }\\n        return max;\\n    }\\n\\n    static int getMax(int start, int end, long[] prefixSum, int[][] sparse, long budget) {\\n        int best = 0, left = start;\\n        while(start <= end){\\n            int mid = (start + end) / 2;\\n            long sum = (prefixSum[mid] - (left == 0? 0 : prefixSum[left-1]));\\n            long cost = ((mid - left + 1) * sum) + getMax(left, mid, sparse);\\n            if(cost > budget){\\n                end = mid - 1;\\n            }\\n            else{\\n                best = mid - left + 1;\\n                start = mid + 1;\\n            }\\n        }\\n        return best;\\n    }\\n    static int getMax(int start, int end, int[][] sparse) {\\n        int j = log[end - start + 1];\\n        int max = Math.max(sparse[start][j], sparse[end - (1 << j) + 1][j]);\\n        return max;\\n    }\\n```",
                "solutionTags": [
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\n    static int [] log;\\n    static int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n        int [][] sparse = new int [(int)(1e5)][17];\\n        log = new int [(int)(1e5)];\\n        log[1] = 0;\\n        for(int i = 2; i < log.length; i++) log[i] = log[i/2] + 1;\\n        \\n        for(int i = 0; i < chargeTimes.length; i++) sparse[i][0] = chargeTimes[i];\\n\\n        for(int i = 1; i < 17; i++) {\\n            for(int j = 0; j + (1<<i) - 1 < sparse.length; j++){\\n                sparse[j][i] = Math.max(sparse[j][i-1], sparse[j+(1<<(i-1))][i-1]);\\n            }\\n        }\\n\\n        long [] prefixSum = new long [runningCosts.length];\\n        prefixSum[0] = runningCosts[0];\\n        for(int i = 1; i < prefixSum.length; i++){\\n            prefixSum[i] = prefixSum[i-1] + runningCosts[i];\\n        }\\n\\n        int max = 0;\\n        for(int i = 0; i < runningCosts.length; i++) {\\n            max = Math.max(max, getMax(i, runningCosts.length-1, prefixSum, sparse, budget));\\n        }\\n        return max;\\n    }\\n\\n    static int getMax(int start, int end, long[] prefixSum, int[][] sparse, long budget) {\\n        int best = 0, left = start;\\n        while(start <= end){\\n            int mid = (start + end) / 2;\\n            long sum = (prefixSum[mid] - (left == 0? 0 : prefixSum[left-1]));\\n            long cost = ((mid - left + 1) * sum) + getMax(left, mid, sparse);\\n            if(cost > budget){\\n                end = mid - 1;\\n            }\\n            else{\\n                best = mid - left + 1;\\n                start = mid + 1;\\n            }\\n        }\\n        return best;\\n    }\\n    static int getMax(int start, int end, int[][] sparse) {\\n        int j = log[end - start + 1];\\n        int max = Math.max(sparse[start][j], sparse[end - (1 << j) + 1][j]);\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2702873,
                "title": "c-sliding-window-deque-faster-than-100-explained",
                "content": "It\\'s definitely quite difficult to figure out how to approach the problem if it comes at you out of the blue. Fortunately I was solving some other Deque related problems and this was suggested to me so I was in a \\'Deque state of mind\\'.\\n\\nOnce you try to break down the statements, what you\\'ll realize is that you have to maintain a window of maximum size that satisfies ```max(chargeTimes) + (i-j+1)* sum(runningCosts)```, where ``i`` and ```j``` are your window boundaries (the good old sliding window pointers). If you have solved Sliding Window before, you\\'ll remember how these pointers are handled. \\n\\nNow comes the interesting part - keeping track of the maximum ```chargeTime``` in your window. If you have a few minutes to spare, I recommend solving [this](https://leetcode.com/problems/sliding-window-maximum/). What we have to ourselves is a standard Montonic Queue condition. So we\\'ll have a ```deque``` that will store the indice(s) of some of the elements in your window. The front element of this deque will always be the ```maximum chargeTime```- having index. To reduce the window size, we\\'ll subtract ```runningCosts[j]``` from the sum and remove ```j``` from the deque if it is stored. Please look at the code below:\\n\\n![image](https://assets.leetcode.com/users/images/9ee36ffb-b0df-47de-ad82-7aae8af33da4_1665757024.8924537.png)\\n\\nFeel free to ask questions.",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```max(chargeTimes) + (i-j+1)* sum(runningCosts)```\n```j```\n```chargeTime```\n```deque```\n```maximum chargeTime```\n```runningCosts[j]```\n```j```",
                "codeTag": "Unknown"
            },
            {
                "id": 2533059,
                "title": "amazon-interview-question",
                "content": "Same question asked in amazon interview with changing problem description.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2530626,
                "title": "c-solution-using-priority-queue",
                "content": "```\\nint maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) \\n{\\n\\tlong result=0,n=chargeTimes.size(),s=0,p=0;\\n\\tpriority_queue<pair<long,long>> q;\\n\\tfor(int i=0;i<n;i++)\\n\\t{\\n\\t\\ts+=runningCosts[i];\\n\\t\\tq.push({chargeTimes[i],i});\\n\\t\\twhile(!q.empty()&&(q.top().first+s*(i-p+1)>budget))\\n\\t\\t{\\n\\t\\t\\ts-=runningCosts[p++];\\n\\t\\t\\twhile(!q.empty()&&q.top().second<p) q.pop();\\n\\t\\t}\\n\\t\\tresult=max(result,i-p+1);\\n\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) \\n{\\n\\tlong result=0,n=chargeTimes.size(),s=0,p=0;\\n\\tpriority_queue<pair<long,long>> q;\\n\\tfor(int i=0;i<n;i++)\\n\\t{\\n\\t\\ts+=runningCosts[i];\\n\\t\\tq.push({chargeTimes[i],i});\\n\\t\\twhile(!q.empty()&&(q.top().first+s*(i-p+1)>budget))\\n\\t\\t{\\n\\t\\t\\ts-=runningCosts[p++];\\n\\t\\t\\twhile(!q.empty()&&q.top().second<p) q.pop();\\n\\t\\t}\\n\\t\\tresult=max(result,i-p+1);\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2527816,
                "title": "c-very-easy-binary-search-sliding-window",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n   vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        deque<pair<int,int>> dq;  //We will store elements in the deque only inside our current window\\n        vector<int> ans;\\n        \\n        for(int i=0;i<nums.size();++i)\\n        {\\n            if(!dq.empty() and dq.front().second<=(i-k))    //Remove front element if it goes out of window size\\n                dq.pop_front();\\n            while(!dq.empty() and dq.back().first<nums[i])  //Maintain elements in DSC order\\n                dq.pop_back();\\n            dq.push_back(make_pair(nums[i],i));     //Push current NODE\\n            if(i>=(k-1))\\n                ans.push_back(dq.front().first);    //Include maximum of cuurrent window\\n        }\\n        return ans;\\n    }\\n    bool check(vector<int>& v, vector<int>& c, long long k,ll mid){\\n        vector<int> t=maxSlidingWindow(v,mid);\\n        ll sum=0;\\n        if(mid==0) return true;\\n        if(mid==1){\\n            for(int i=0;i<v.size();i++){\\n                if(v[i]+c[i]<=k) return true;\\n            }return false;\\n        }\\n        for(int i=0;i<mid-1;i++) sum+=c[i];\\n        int l=0;\\n        for(int i=mid-1;i<v.size();i++){\\n            sum+=c[i];\\n            ll maxi=t[l]+mid*(ll)sum;\\n            if(maxi<=k) return true;\\n            sum-=c[l];l++;\\n        }return false;\\n    }\\n    int maximumRobots(vector<int>& v, vector<int>& c, long long k) {\\n        ll si=0,ei=v.size();\\n        int ans=0;\\n        while(si<=ei){\\n            ll mid=si+(ei-si)/2;\\n            if(check(v,c,k,mid)) {ans=mid;si=mid+1;}\\n            else ei=mid-1;\\n        }return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window",
                    "Binary Tree"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n   vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        deque<pair<int,int>> dq;  //We will store elements in the deque only inside our current window\\n        vector<int> ans;\\n        \\n        for(int i=0;i<nums.size();++i)\\n        {\\n            if(!dq.empty() and dq.front().second<=(i-k))    //Remove front element if it goes out of window size\\n                dq.pop_front();\\n            while(!dq.empty() and dq.back().first<nums[i])  //Maintain elements in DSC order\\n                dq.pop_back();\\n            dq.push_back(make_pair(nums[i],i));     //Push current NODE\\n            if(i>=(k-1))\\n                ans.push_back(dq.front().first);    //Include maximum of cuurrent window\\n        }\\n        return ans;\\n    }\\n    bool check(vector<int>& v, vector<int>& c, long long k,ll mid){\\n        vector<int> t=maxSlidingWindow(v,mid);\\n        ll sum=0;\\n        if(mid==0) return true;\\n        if(mid==1){\\n            for(int i=0;i<v.size();i++){\\n                if(v[i]+c[i]<=k) return true;\\n            }return false;\\n        }\\n        for(int i=0;i<mid-1;i++) sum+=c[i];\\n        int l=0;\\n        for(int i=mid-1;i<v.size();i++){\\n            sum+=c[i];\\n            ll maxi=t[l]+mid*(ll)sum;\\n            if(maxi<=k) return true;\\n            sum-=c[l];l++;\\n        }return false;\\n    }\\n    int maximumRobots(vector<int>& v, vector<int>& c, long long k) {\\n        ll si=0,ei=v.size();\\n        int ans=0;\\n        while(si<=ei){\\n            ll mid=si+(ei-si)/2;\\n            if(check(v,c,k,mid)) {ans=mid;si=mid+1;}\\n            else ei=mid-1;\\n        }return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2526362,
                "title": "easy-c-using-concept-of-sliding-window-maximum-ques-239",
                "content": "**Prerequisite - Sliding Window Maximum [Question No - 239]**\\nHere I am calculating budget of each window and if current budget is greater than given budget than I am shrinking the window by first decreasing current sum by runningCosts[left] then increasing left.\\nHere I keep track of maximum value of chargeTimes by using a dequeue like we solved question no 239.\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        int left = 0, right = 0, ans = 0;\\n        long long currsum = 0;\\n        deque<int> dq;\\n        for(right=0; right < chargeTimes.size(); right++) {\\n            while(!dq.empty() && chargeTimes[dq.back()] < chargeTimes[right])\\n                dq.pop_back();\\n            dq.push_back(right);\\n            currsum += runningCosts[right];\\n            long long curr_b = (right - left + 1) * currsum + chargeTimes[dq.front()];\\n            \\n            while(left < right && curr_b > budget) {\\n                currsum -= runningCosts[left];\\n                if(dq.front() <= left) dq.pop_front();\\n                left++;\\n                curr_b = (right - left + 1) * currsum + chargeTimes[dq.front()];\\n            }\\n            if(curr_b <= budget) ans = max(ans, right - left + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        int left = 0, right = 0, ans = 0;\\n        long long currsum = 0;\\n        deque<int> dq;\\n        for(right=0; right < chargeTimes.size(); right++) {\\n            while(!dq.empty() && chargeTimes[dq.back()] < chargeTimes[right])\\n                dq.pop_back();\\n            dq.push_back(right);\\n            currsum += runningCosts[right];\\n            long long curr_b = (right - left + 1) * currsum + chargeTimes[dq.front()];\\n            \\n            while(left < right && curr_b > budget) {\\n                currsum -= runningCosts[left];\\n                if(dq.front() <= left) dq.pop_front();\\n                left++;\\n                curr_b = (right - left + 1) * currsum + chargeTimes[dq.front()];\\n            }\\n            if(curr_b <= budget) ans = max(ans, right - left + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525940,
                "title": "simple-sliding-window-prefix-sum-approach-c",
                "content": "Since we have been asked to find max length of consecutive elements with condition, the idea is simply to use **sliding window**.\\n\\nWe have to take care of **two conditions** while moving our window:\\n1. **Maximum** charging time from i to j.\\n2. **Total sum** of all elements from i to j.\\n\\n1st condition can be taken care with the help of a Map. **Sorted Map** more specifically so as to get the max element directly by accesing end of the map.\\n2nd condition can be deal using **prefix sum**. We can just get sum of all elements from i to j efficiently using prefix array.\\n\\nFurther for sliding window, we will maintain two pointers i and j which will help us in acessing the length and \\nWill keep on **adding elements** with the help of j **till our current budget <= given budge**t.\\nif **current budget > given budget**, we will simply **remove ith element** from our map.\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n     \\n        int n = chargeTimes.size();\\n        vector<long long> prefix(n+1, 0);\\n        \\n        for(long long i=0;i<n;i++){\\n            prefix[i+1] = prefix[i] + runningCosts[i];\\n        }\\n        \\n        \\n        long long i = 0, ans = 0;\\n        map<long long,long long> window;\\n        for(long long j=0;j<n;j++){\\n            \\n            window[chargeTimes[j]]++;\\n            \\n            //calculate cur budget:\\n            long long curBudget = 0;\\n            auto it = window.end();\\n            it--;\\n            long long curMaxTime = (*it).first;\\n            long long curPrice = (j-i+1) * (prefix[j+1] - prefix[i]);\\n            curBudget = curMaxTime + curPrice;\\n            \\n            \\n            if(curBudget <= budget){\\n                ans = max(ans, (j-i+1));\\n            }\\n            else{\\n                //subtract i:\\n                window[chargeTimes[i]]--;\\n                if(window[chargeTimes[i]] <= 0) window.erase(chargeTimes[i]);\\n                i++;\\n            }\\n        \\n        }\\n       \\n        return ans;\\n    }\\n};\\n```\\n\\nTC: NlogN\\nSC: O(N)\\n\\n**Kindly upvote if it helps!!**",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n     \\n        int n = chargeTimes.size();\\n        vector<long long> prefix(n+1, 0);\\n        \\n        for(long long i=0;i<n;i++){\\n            prefix[i+1] = prefix[i] + runningCosts[i];\\n        }\\n        \\n        \\n        long long i = 0, ans = 0;\\n        map<long long,long long> window;\\n        for(long long j=0;j<n;j++){\\n            \\n            window[chargeTimes[j]]++;\\n            \\n            //calculate cur budget:\\n            long long curBudget = 0;\\n            auto it = window.end();\\n            it--;\\n            long long curMaxTime = (*it).first;\\n            long long curPrice = (j-i+1) * (prefix[j+1] - prefix[i]);\\n            curBudget = curMaxTime + curPrice;\\n            \\n            \\n            if(curBudget <= budget){\\n                ans = max(ans, (j-i+1));\\n            }\\n            else{\\n                //subtract i:\\n                window[chargeTimes[i]]--;\\n                if(window[chargeTimes[i]] <= 0) window.erase(chargeTimes[i]);\\n                i++;\\n            }\\n        \\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525924,
                "title": "c-solution-sliding-window",
                "content": "```cpp\\nclass SparseTable {\\nprivate:\\n    int n, log;\\n    vector<vector<int>> grid;\\npublic:\\n    SparseTable(int _n) {\\n        n = _n;\\n        log = (int)log2(n);\\n        grid.resize(n, vector<int>(log + 1));\\n    }\\n    void createTable(vector<int> &arr) {\\n        for (int i = 0; i < n; i++) {\\n            grid[i][0] = arr[i];\\n        }\\n        for (int k = 1; k <= log; k++) {\\n            for (int i = 0; i < n; i++) {\\n                if (i + (1 << (k - 1)) < n) {\\n                    grid[i][k] = max(grid[i][k - 1], grid[i + (1 << (k - 1))][k - 1]);\\n                } else {\\n                    grid[i][k] = grid[i][k - 1];\\n                }\\n            }\\n        }\\n    }\\n    int Query(int L, int R) {\\n        int k = (int)log2(R - L + 1);\\n        return max(grid[L][k], grid[R - (1 << k) + 1][k]);\\n    }\\n};\\n\\nclass Solution {\\nprivate:\\n    vector<long long> pref;\\npublic:\\n    int maximumRobots(vector<int> &chargeTimes, vector<int> &runningCosts, long long budget) {\\n        int n = chargeTimes.size();\\n        SparseTable st(n);\\n        st.createTable(chargeTimes);\\n        pref.resize(n + 1);\\n        for (int i = 1; i <= n; i++) {\\n            pref[i] = pref[i - 1] + runningCosts[i - 1];\\n        }\\n        int l = 0, r = n;\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            int i = 0, j = mid;\\n            bool flag = false;\\n            while (j < n) {\\n                long long sum = (st.Query(i, j) + (mid + 1) * (pref[j + 1] - pref[i]));\\n                flag |= (sum <= budget);\\n                i++, j++;\\n            }\\n            if (flag) l = mid + 1;\\n            else r = mid;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```cpp\\nclass SparseTable {\\nprivate:\\n    int n, log;\\n    vector<vector<int>> grid;\\npublic:\\n    SparseTable(int _n) {\\n        n = _n;\\n        log = (int)log2(n);\\n        grid.resize(n, vector<int>(log + 1));\\n    }\\n    void createTable(vector<int> &arr) {\\n        for (int i = 0; i < n; i++) {\\n            grid[i][0] = arr[i];\\n        }\\n        for (int k = 1; k <= log; k++) {\\n            for (int i = 0; i < n; i++) {\\n                if (i + (1 << (k - 1)) < n) {\\n                    grid[i][k] = max(grid[i][k - 1], grid[i + (1 << (k - 1))][k - 1]);\\n                } else {\\n                    grid[i][k] = grid[i][k - 1];\\n                }\\n            }\\n        }\\n    }\\n    int Query(int L, int R) {\\n        int k = (int)log2(R - L + 1);\\n        return max(grid[L][k], grid[R - (1 << k) + 1][k]);\\n    }\\n};\\n\\nclass Solution {\\nprivate:\\n    vector<long long> pref;\\npublic:\\n    int maximumRobots(vector<int> &chargeTimes, vector<int> &runningCosts, long long budget) {\\n        int n = chargeTimes.size();\\n        SparseTable st(n);\\n        st.createTable(chargeTimes);\\n        pref.resize(n + 1);\\n        for (int i = 1; i <= n; i++) {\\n            pref[i] = pref[i - 1] + runningCosts[i - 1];\\n        }\\n        int l = 0, r = n;\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            int i = 0, j = mid;\\n            bool flag = false;\\n            while (j < n) {\\n                long long sum = (st.Query(i, j) + (mid + 1) * (pref[j + 1] - pref[i]));\\n                flag |= (sum <= budget);\\n                i++, j++;\\n            }\\n            if (flag) l = mid + 1;\\n            else r = mid;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525576,
                "title": "binary-search-priority-queue",
                "content": "```\\nclass Solution {\\n    vector<int> c;\\n    vector<int> rc;\\n    bool check(long long int k,long long int b){\\n        priority_queue<pair<int,int>> pq;\\n        long long int s=0;\\n        int i=0;\\n        int j=0;\\n        long long int ans=INT_MAX;\\n        while(j<c.size()){\\n            \\n            pq.push({c[j],j});\\n            s+=rc[j]; \\n            j++;\\n            if(j-i==k){\\n\\n                while((pq.top().second<i)){\\n                    pq.pop();\\n                }\\n                long long int l=pq.top().first + k*s;\\n                if(l<=b)return true;\\n                s-=rc[i];\\n                i++;\\n\\n            }\\n            \\n        }\\n\\n        return false;\\n    }\\npublic:\\n    int maximumRobots(vector<int>& ch, vector<int>& r, long long budget) {\\n        c=ch;\\n        rc=r;\\n        long long int n=r.size();\\n        long long int start=1;\\n        long long int end=n;\\n        long long int mid;\\n        long long int ans=0;\\n        \\n        while(start<=end){\\n            mid=start + (end-start)/2;\\n            \\n            if(check(mid,budget)){\\n                ans=mid;\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> c;\\n    vector<int> rc;\\n    bool check(long long int k,long long int b){\\n        priority_queue<pair<int,int>> pq;\\n        long long int s=0;\\n        int i=0;\\n        int j=0;\\n        long long int ans=INT_MAX;\\n        while(j<c.size()){\\n            \\n            pq.push({c[j],j});\\n            s+=rc[j]; \\n            j++;\\n            if(j-i==k){\\n\\n                while((pq.top().second<i)){\\n                    pq.pop();\\n                }\\n                long long int l=pq.top().first + k*s;\\n                if(l<=b)return true;\\n                s-=rc[i];\\n                i++;\\n\\n            }\\n            \\n        }\\n\\n        return false;\\n    }\\npublic:\\n    int maximumRobots(vector<int>& ch, vector<int>& r, long long budget) {\\n        c=ch;\\n        rc=r;\\n        long long int n=r.size();\\n        long long int start=1;\\n        long long int end=n;\\n        long long int mid;\\n        long long int ans=0;\\n        \\n        while(start<=end){\\n            mid=start + (end-start)/2;\\n            \\n            if(check(mid,budget)){\\n                ans=mid;\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525448,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Deque && Sliding Window***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        \\n        int n = chargeTimes.size();\\n        \\n        // find the prefix sum of runningCosts array\\n        \\n        vector<long long> prefix(n, 0);\\n        \\n        prefix[0] = runningCosts[0];\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            prefix[i] = runningCosts[i] + prefix[i - 1];\\n        }\\n        \\n        // declare a deque, which will store the element in descending order\\n        \\n        // maximum will be at front\\n        \\n        deque<int> dq;\\n        \\n        long long curr_sum = 0;\\n        \\n        int left = 0;\\n        \\n        int maxi = INT_MIN;\\n        \\n        for(int right = 0; right < n; right++)\\n        {\\n            // pop the smaller element from back, so that it will be in descending order\\n            \\n            while(dq.empty() == false && dq.back() < chargeTimes[right])\\n            {\\n                dq.pop_back();\\n            }\\n            \\n            // push the curr element into deque\\n            \\n            dq.push_back(chargeTimes[right]);\\n            \\n            // find the length of the window\\n            \\n            long long k = right - left + 1;\\n            \\n            // find the maximum element of the window, which will be at the front of queue\\n                \\n            long long maxii = dq.front();\\n            \\n            //  find the sum of the window\\n            \\n            long long p_sum = prefix[right];\\n                \\n            if(left > 0)\\n            {\\n                p_sum -= prefix[left - 1];\\n            }\\n            \\n            // update the curr_sum\\n                \\n            curr_sum = maxii + k * p_sum;\\n            \\n            // shrink the window from left if we are getting the curr_sum exceeding the budget\\n            \\n            while(left <= right && curr_sum > budget)\\n            {\\n                // the number which we are removing from window is maximum then pop the dq from front\\n                \\n                if(dq.front() == chargeTimes[left])\\n                {\\n                    dq.pop_front();\\n                }\\n                \\n                // increment left pointer\\n                \\n                left++;\\n                \\n                // find the length of the window\\n                \\n                k = right - left + 1;\\n                \\n                // find the maximum of the window\\n                \\n                maxii = dq.front();\\n                \\n                // find the sum of the window\\n                \\n                p_sum = prefix[right];\\n                \\n                if(left > 0)\\n                {\\n                    p_sum -= prefix[left - 1];\\n                }\\n                \\n                // update the curr_sum\\n                \\n                curr_sum = maxii + k * p_sum;\\n            }\\n            \\n            // find the curr_size of the window\\n          \\n            int curr_size = right - left + 1;\\n            \\n            // update the maximum size of the window\\n            \\n            maxi = max(maxi, curr_size);\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        \\n        int n = chargeTimes.size();\\n        \\n        // find the prefix sum of runningCosts array\\n        \\n        vector<long long> prefix(n, 0);\\n        \\n        prefix[0] = runningCosts[0];\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            prefix[i] = runningCosts[i] + prefix[i - 1];\\n        }\\n        \\n        // declare a deque, which will store the element in descending order\\n        \\n        // maximum will be at front\\n        \\n        deque<int> dq;\\n        \\n        long long curr_sum = 0;\\n        \\n        int left = 0;\\n        \\n        int maxi = INT_MIN;\\n        \\n        for(int right = 0; right < n; right++)\\n        {\\n            // pop the smaller element from back, so that it will be in descending order\\n            \\n            while(dq.empty() == false && dq.back() < chargeTimes[right])\\n            {\\n                dq.pop_back();\\n            }\\n            \\n            // push the curr element into deque\\n            \\n            dq.push_back(chargeTimes[right]);\\n            \\n            // find the length of the window\\n            \\n            long long k = right - left + 1;\\n            \\n            // find the maximum element of the window, which will be at the front of queue\\n                \\n            long long maxii = dq.front();\\n            \\n            //  find the sum of the window\\n            \\n            long long p_sum = prefix[right];\\n                \\n            if(left > 0)\\n            {\\n                p_sum -= prefix[left - 1];\\n            }\\n            \\n            // update the curr_sum\\n                \\n            curr_sum = maxii + k * p_sum;\\n            \\n            // shrink the window from left if we are getting the curr_sum exceeding the budget\\n            \\n            while(left <= right && curr_sum > budget)\\n            {\\n                // the number which we are removing from window is maximum then pop the dq from front\\n                \\n                if(dq.front() == chargeTimes[left])\\n                {\\n                    dq.pop_front();\\n                }\\n                \\n                // increment left pointer\\n                \\n                left++;\\n                \\n                // find the length of the window\\n                \\n                k = right - left + 1;\\n                \\n                // find the maximum of the window\\n                \\n                maxii = dq.front();\\n                \\n                // find the sum of the window\\n                \\n                p_sum = prefix[right];\\n                \\n                if(left > 0)\\n                {\\n                    p_sum -= prefix[left - 1];\\n                }\\n                \\n                // update the curr_sum\\n                \\n                curr_sum = maxii + k * p_sum;\\n            }\\n            \\n            // find the curr_size of the window\\n          \\n            int curr_size = right - left + 1;\\n            \\n            // update the maximum size of the window\\n            \\n            maxi = max(maxi, curr_size);\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525157,
                "title": "java-solution-sliding-window-priorityqueue",
                "content": "```\\nclass Solution {\\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)->b-a);\\n        long sum=0;\\n       int i=0,j=0;\\n       int max=0;\\n       while(j<chargeTimes.length){\\n           pq.add(chargeTimes[j]);\\n           sum=sum+runningCosts[j];\\n           if(pq.peek()+pq.size()*sum<=budget){\\n               max=Math.max(max,(j-i+1));\\n           }\\n           else{\\n               while(!pq.isEmpty() && pq.peek()+pq.size()*sum>budget){\\n                   pq.remove(chargeTimes[i]);\\n                   sum=sum-runningCosts[i];\\n                   i++;\\n               }\\n           }\\n           j++;\\n       }\\n\\n      return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)->b-a);\\n        long sum=0;\\n       int i=0,j=0;\\n       int max=0;\\n       while(j<chargeTimes.length){\\n           pq.add(chargeTimes[j]);\\n           sum=sum+runningCosts[j];\\n           if(pq.peek()+pq.size()*sum<=budget){\\n               max=Math.max(max,(j-i+1));\\n           }\\n           else{\\n               while(!pq.isEmpty() && pq.peek()+pq.size()*sum>budget){\\n                   pq.remove(chargeTimes[i]);\\n                   sum=sum-runningCosts[i];\\n                   i++;\\n               }\\n           }\\n           j++;\\n       }\\n\\n      return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524905,
                "title": "c-segment-tree-solution-prefix-sum",
                "content": "```\\nclass Solution {\\n    \\n    class segment_tree {\\n    // tl and tr are used for the tree only \\n    // l and r are used for the query range\\n    // Node is the index of the current node in the tree array\\n    // 0 based indexing is used here\\n    int N;\\n    vector<int> tree; // tree will store the data as node->left (2*i) -> right(2*i+1)\\n\\n    // function to change the logic\\n    int operation(int a, int b) {\\n        return max(a,b);\\n    }\\n\\n    void build(vector<int>& arr, int Node, int tl, int tr) {\\n        if (tl == tr) {\\n            tree[Node] = arr[tl];\\n        }\\n        else {\\n            int mid = (tl + tr) >> 1;\\n\\n            build(arr, 2 * Node + 1, tl, mid); // left child 2*Node\\n            build(arr, 2 * Node + 2, mid + 1, tr); // right child 2*Node+1\\n\\n            tree[Node] = operation(tree[2 * Node + 1], tree[2 * Node + 2]); // summing up the left child and right child results\\n        }\\n    }\\n\\n    int query(int Node, int tl, int tr, int l, int r) {\\n        // completely overlapping\\n        if (tl >= l && tr <= r)\\n            return tree[Node];\\n        // out of bounds range\\n        if (tl > r || tr < l)\\n            return 0;\\n\\n        // partial overlapping \\n        int mid = (tl + tr) >> 1;\\n\\n        int left = query(2 * Node + 1, tl, mid, l, r);\\n        int right = query(2 * Node + 2, mid + 1, tr, l, r);\\n\\n        return operation(left, right); // returning the sum\\n    }\\n\\n    void update(int Node, int tl, int tr, int pos, int new_val) {\\n        if (tl == tr)\\n            tree[Node] = new_val;\\n        else {\\n            int mid = (tl + tr) >> 1;\\n\\n            if (pos <= mid) // if updating index lies on the left of mid\\n                update(2 * Node + 1, tl, mid, pos, new_val);\\n            else // if updating index lies on the right of mid\\n                update(2 * Node + 2, mid + 1, tr, pos, new_val);\\n\\n            tree[Node] = operation(tree[2 * Node + 1], tree[2 * Node + 2]); // updating the new sum values\\n        }\\n    }\\n\\npublic:\\n    void construct(vector<int>& arr, int N) {\\n        this->N = N;\\n        tree.resize(4 * N);\\n        build(arr, 0, 0, N - 1);\\n    }\\n\\n    int get_query(int l, int r) {\\n        return query(0, 0, N - 1, l, r);\\n    }\\n\\n    void update_at(int pos, int new_val) {\\n        update(0, 0, N - 1, pos, new_val);\\n    }\\n};\\n    \\n    \\n    \\npublic:\\n    int maximumRobots(vector<int>& charge, vector<int>& run, long long budget) {\\n        segment_tree seg;\\n        int n = run.size();\\n        \\n        seg.construct(charge,n);\\n        vector<long long int> pref(n);\\n        long long int sum = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=run[i];\\n            pref[i]=sum;\\n        }\\n        \\n        int i=0,j=0;\\n        \\n        int ans = 0;\\n        while(j<n && i<n)\\n        {\\n            if(i>=j)\\n                j=i;\\n            long long curr = seg.get_query(i,j);\\n            curr += (j-i+1)*(pref[j]-pref[i]+run[i]);\\n            \\n            if(curr<=budget)\\n                ans=max(ans,j-i+1);\\n            if(curr<budget)\\n                j++;\\n            else\\n                i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    \\n    class segment_tree {\\n    // tl and tr are used for the tree only \\n    // l and r are used for the query range\\n    // Node is the index of the current node in the tree array\\n    // 0 based indexing is used here\\n    int N;\\n    vector<int> tree; // tree will store the data as node->left (2*i) -> right(2*i+1)\\n\\n    // function to change the logic\\n    int operation(int a, int b) {\\n        return max(a,b);\\n    }\\n\\n    void build(vector<int>& arr, int Node, int tl, int tr) {\\n        if (tl == tr) {\\n            tree[Node] = arr[tl];\\n        }\\n        else {\\n            int mid = (tl + tr) >> 1;\\n\\n            build(arr, 2 * Node + 1, tl, mid); // left child 2*Node\\n            build(arr, 2 * Node + 2, mid + 1, tr); // right child 2*Node+1\\n\\n            tree[Node] = operation(tree[2 * Node + 1], tree[2 * Node + 2]); // summing up the left child and right child results\\n        }\\n    }\\n\\n    int query(int Node, int tl, int tr, int l, int r) {\\n        // completely overlapping\\n        if (tl >= l && tr <= r)\\n            return tree[Node];\\n        // out of bounds range\\n        if (tl > r || tr < l)\\n            return 0;\\n\\n        // partial overlapping \\n        int mid = (tl + tr) >> 1;\\n\\n        int left = query(2 * Node + 1, tl, mid, l, r);\\n        int right = query(2 * Node + 2, mid + 1, tr, l, r);\\n\\n        return operation(left, right); // returning the sum\\n    }\\n\\n    void update(int Node, int tl, int tr, int pos, int new_val) {\\n        if (tl == tr)\\n            tree[Node] = new_val;\\n        else {\\n            int mid = (tl + tr) >> 1;\\n\\n            if (pos <= mid) // if updating index lies on the left of mid\\n                update(2 * Node + 1, tl, mid, pos, new_val);\\n            else // if updating index lies on the right of mid\\n                update(2 * Node + 2, mid + 1, tr, pos, new_val);\\n\\n            tree[Node] = operation(tree[2 * Node + 1], tree[2 * Node + 2]); // updating the new sum values\\n        }\\n    }\\n\\npublic:\\n    void construct(vector<int>& arr, int N) {\\n        this->N = N;\\n        tree.resize(4 * N);\\n        build(arr, 0, 0, N - 1);\\n    }\\n\\n    int get_query(int l, int r) {\\n        return query(0, 0, N - 1, l, r);\\n    }\\n\\n    void update_at(int pos, int new_val) {\\n        update(0, 0, N - 1, pos, new_val);\\n    }\\n};\\n    \\n    \\n    \\npublic:\\n    int maximumRobots(vector<int>& charge, vector<int>& run, long long budget) {\\n        segment_tree seg;\\n        int n = run.size();\\n        \\n        seg.construct(charge,n);\\n        vector<long long int> pref(n);\\n        long long int sum = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=run[i];\\n            pref[i]=sum;\\n        }\\n        \\n        int i=0,j=0;\\n        \\n        int ans = 0;\\n        while(j<n && i<n)\\n        {\\n            if(i>=j)\\n                j=i;\\n            long long curr = seg.get_query(i,j);\\n            curr += (j-i+1)*(pref[j]-pref[i]+run[i]);\\n            \\n            if(curr<=budget)\\n                ans=max(ans,j-i+1);\\n            if(curr<budget)\\n                j++;\\n            else\\n                i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524872,
                "title": "c-sliding-window-multiset-a-template-problem",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& ct, vector<int>& rc, long long budget) {\\n        int n = ct.size();\\n        int l = 0, r = 0, mx = 0;\\n        long long cost = 0, psum = 0;\\n        multiset<int, greater<int>> mset;\\n        while (r < n) {\\n            mset.insert(ct[r]);\\n            psum += rc[r];\\n            r ++;\\n            cost = *mset.begin() + (r - l) * psum;\\n            while (cost > budget) {\\n                auto it = mset.find(ct[l]);\\n                mset.erase(it);\\n                psum -= rc[l];\\n                l ++;\\n                cost = *mset.begin() + (r - l) * psum;\\n            }\\n            mx = max(mx, r - l);\\n        }\\n        return mx;\\n    }\\n};```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& ct, vector<int>& rc, long long budget) {\\n        int n = ct.size();\\n        int l = 0, r = 0, mx = 0;\\n        long long cost = 0, psum = 0;\\n        multiset<int, greater<int>> mset;\\n        while (r < n) {\\n            mset.insert(ct[r]);\\n            psum += rc[r];\\n            r ++;\\n            cost = *mset.begin() + (r - l) * psum;\\n            while (cost > budget) {\\n                auto it = mset.find(ct[l]);\\n                mset.erase(it);\\n                psum -= rc[l];\\n                l ++;\\n                cost = *mset.begin() + (r - l) * psum;\\n            }\\n            mx = max(mx, r - l);\\n        }\\n        return mx;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 2524845,
                "title": "python-o-n-sliding-window-sorted-containers",
                "content": "So for this problem, we will need to use a basic sliding window approach where we incrementally check the subarrays. For example, we begin the \\u201Cend\\u201D variable from the 0 index and increment it meaning that this will be the end of the array we are looking at. We will also need to keep track of the current max and the current sum to make sure that they are within the budget. In case they are not within the budget, we will increment the start index meaning that we will look at a different subarray. \\n\\nThe hard part is to find the current max without looking through the whole list and to do that we\\u2019ll use a little trick with sorted containers and the SortedSet which removes and adds elements in O(1), as well as it is possible to check the maximum element in O(1). After each iteration, we check whether the current length of the subarray is larger than the maximum length so far and update correspondingly. \\n\\n```\\nfrom sortedcontainers import SortedSet\\n\\nclass Solution:\\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\\n\\n        start = res = 0\\n        curr_max = curr_sum = 0\\n        sorted_set = SortedSet()\\n        \\n        for end in range(len(chargeTimes)):\\n            curr_sum += runningCosts[end]\\n            \\n            sorted_set.add(chargeTimes[end])\\n            curr_max = sorted_set[-1]\\n\\n            k = end-start+1\\n            \\n            while end>=start and (curr_max + k * curr_sum)>budget:\\n                \\n                curr_sum-=runningCosts[start]\\n                sorted_set.discard(chargeTimes[start])\\n                curr_max = sorted_set[-1] if sorted_set else 0\\n                start += 1\\n\\t\\t\\t\\tk-=1\\n                \\n            res = max(res, end-start+1)\\n            \\n        return res\\n",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "So for this problem, we will need to use a basic sliding window approach where we incrementally check the subarrays. For example, we begin the \\u201Cend\\u201D variable from the 0 index and increment it meaning that this will be the end of the array we are looking at. We will also need to keep track of the current max and the current sum to make sure that they are within the budget. In case they are not within the budget, we will increment the start index meaning that we will look at a different subarray. \\n\\nThe hard part is to find the current max without looking through the whole list and to do that we\\u2019ll use a little trick with sorted containers and the SortedSet which removes and adds elements in O(1), as well as it is possible to check the maximum element in O(1). After each iteration, we check whether the current length of the subarray is larger than the maximum length so far and update correspondingly. \\n\\n```\\nfrom sortedcontainers import SortedSet\\n\\nclass Solution:\\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\\n\\n        start = res = 0\\n        curr_max = curr_sum = 0\\n        sorted_set = SortedSet()\\n        \\n        for end in range(len(chargeTimes)):\\n            curr_sum += runningCosts[end]\\n            \\n            sorted_set.add(chargeTimes[end])\\n            curr_max = sorted_set[-1]\\n\\n            k = end-start+1\\n            \\n            while end>=start and (curr_max + k * curr_sum)>budget:\\n                \\n                curr_sum-=runningCosts[start]\\n                sorted_set.discard(chargeTimes[start])\\n                curr_max = sorted_set[-1] if sorted_set else 0\\n                start += 1\\n\\t\\t\\t\\tk-=1\\n                \\n            res = max(res, end-start+1)\\n            \\n        return res\\n",
                "codeTag": "Java"
            },
            {
                "id": 2524689,
                "title": "binary-search-sliding-window-maximum-with-explanation",
                "content": "**Explanation:-**\\n1. Assume answer is \"k\", then 0 to k-1 also satisfies the condition.Because ```k * sum(runningCosts)``` this factor definitely decrease.If you shrink the size of \"k\" window that you have taken for answer.\\n2. So it tells us to use binary search.\\n3. Now,what we have to do?\\n4. For calculating ```max(chargeTimes) + k * sum(runningCosts)``` we need maximum chargeTime of every window of size \"k\" and sum of that window.\\n5. ```we need maximum chargeTime of every window of size \"k\"``` for calculating this we can use same logic of [Sliding window maximum](https://leetcode.com/problems/sliding-window-maximum/)\\n6. And calculating sum of \"k\" window is easy.\\n7. In code ```mid``` refers to ```k``` .\\n```\\nclass Solution {\\n public:\\n  int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts,  long long budget) {\\n    int sz = chargeTimes.size(), low = 0, high = sz, mid, ans = -1;\\n    // binary search between 0 and sz,because minimum answer can be 0 and maxcan be sz\\n    while (low <= high) {\\n      mid = low + (high - low) / 2;\\n      if (check(chargeTimes, runningCosts, budget, mid)) {\\n        ans = mid;\\n        low = mid + 1;\\n      } else\\n        high = mid - 1;\\n    }\\n    return ans;\\n  }\\n  bool check(vector<int>& chargeTimes, vector<int>& runningCosts,long long budget, int mid) {\\n    deque<int> dq;\\n    int sz = chargeTimes.size(), left = 0;\\n    // sum will store sum of mid size window\\n    long sum = 0;\\n    for (int i = 0; i < sz; i++) {\\n        \\n      sum += runningCosts[i];\\n\\n      while (!dq.empty() && chargeTimes[dq.back()] <= chargeTimes[i])\\n        dq.pop_back();\\n      dq.push_back(i);\\n        \\n      // this will run when we have mid size window\\n      if (i >= mid - 1) {\\n        long maxChargingTime = chargeTimes[dq.front()];\\n          \\n        // checking the condition mentioned in problem\\n        if (maxChargingTime + 1LL * mid * sum <= budget)\\n            return true;\\n          \\n        if (left == dq.front())\\n            dq.pop_front();\\n        sum -= runningCosts[left];\\n        left++;\\n      }\\n    }\\n    return false;\\n  }\\n};\\n```\\nDo **UPVOTE** it it helps :)",
                "solutionTags": [],
                "code": "```k * sum(runningCosts)```\n```max(chargeTimes) + k * sum(runningCosts)```\n```we need maximum chargeTime of every window of size \"k\"```\n```mid```\n```k```\n```\\nclass Solution {\\n public:\\n  int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts,  long long budget) {\\n    int sz = chargeTimes.size(), low = 0, high = sz, mid, ans = -1;\\n    // binary search between 0 and sz,because minimum answer can be 0 and maxcan be sz\\n    while (low <= high) {\\n      mid = low + (high - low) / 2;\\n      if (check(chargeTimes, runningCosts, budget, mid)) {\\n        ans = mid;\\n        low = mid + 1;\\n      } else\\n        high = mid - 1;\\n    }\\n    return ans;\\n  }\\n  bool check(vector<int>& chargeTimes, vector<int>& runningCosts,long long budget, int mid) {\\n    deque<int> dq;\\n    int sz = chargeTimes.size(), left = 0;\\n    // sum will store sum of mid size window\\n    long sum = 0;\\n    for (int i = 0; i < sz; i++) {\\n        \\n      sum += runningCosts[i];\\n\\n      while (!dq.empty() && chargeTimes[dq.back()] <= chargeTimes[i])\\n        dq.pop_back();\\n      dq.push_back(i);\\n        \\n      // this will run when we have mid size window\\n      if (i >= mid - 1) {\\n        long maxChargingTime = chargeTimes[dq.front()];\\n          \\n        // checking the condition mentioned in problem\\n        if (maxChargingTime + 1LL * mid * sum <= budget)\\n            return true;\\n          \\n        if (left == dq.front())\\n            dq.pop_front();\\n        sum -= runningCosts[left];\\n        left++;\\n      }\\n    }\\n    return false;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673906,
                "title": "c-binary-search-on-space-sliding-window-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are to find maximum number of consecutive robots you can run, so we want an optimal k, hence we can apply binary search on space.\\n\\nUsing binary search we can find k, now the task is to check for validity of k. Now, we have a fixed window size of k, we can apply simple sliding window to calculate the sum of running time and max of chargeTimes in the window.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNow, we need to decide the range on which we can perform binary search. So the minimum number of robots to choose will be 1 and maximum can be the size of the array.\\n\\ns = 1;\\ne = n;\\n\\nNow, we search the space for an optimal value of k.\\nif k is valid we store it in answer and try to search in higher range to get the maximum k. so s = mid+1;\\nelse e = mid-1;\\n\\nto check validity of k, we perform sliding window in the fixed window size of k.\\n\\nwe calculate the sum of the window and maintain max in the window.\\nTo maintain max of the window, is similar to this question.\\n\\nhttps://leetcode.com/problems/sliding-window-maximum/ \\n\\nNow when we hit the window size we check for cost of k robots if less than our budget we return true, else check for next window.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nlist of size n \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(int k, vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        int n = chargeTimes.size();\\n        \\n        int i=0;\\n        int j=0;\\n        \\n        long long sum = 0;\\n        int maxi = 0;\\n        \\n        list<int> l;\\n        \\n        while(j<n) {\\n            // calculate sum of running costs till we hit the window size\\n            sum+=runningCosts[j];\\n\\n            // to maintain maximum at the begining of the list\\n            while(l.size() > 0 and l.back() < chargeTimes[j]) l.pop_back();\\n            \\n            l.push_back(chargeTimes[j]);\\n            \\n            if(j-i+1 == k) {\\n                // when we hit the window size of k running robots\\n                \\n                maxi = l.front(); // maximum is at the front of the list\\n                \\n                long long b = maxi + k*sum;\\n                // Cost of running k consecutive robots\\n                // if in budget return true\\n                if(b <= budget) return true;\\n\\n                // else shift the window by 1\\n                sum-=runningCosts[i];\\n                if(maxi == chargeTimes[i]) {\\n                    l.pop_front();\\n                }\\n                i++;\\n            }\\n            \\n            j++;\\n        }\\n        \\n        return false;\\n        \\n    }\\n\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        int s = 1;\\n        int e = chargeTimes.size();\\n        \\n        int ans = 0;\\n        \\n        while(s<=e) {\\n            int k = s+(e-s)/2;\\n            \\n            if(isValid(k, chargeTimes, runningCosts, budget)) {\\n                ans = k;\\n                s=k+1;\\n            }\\n            else e = k-1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(int k, vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        int n = chargeTimes.size();\\n        \\n        int i=0;\\n        int j=0;\\n        \\n        long long sum = 0;\\n        int maxi = 0;\\n        \\n        list<int> l;\\n        \\n        while(j<n) {\\n            // calculate sum of running costs till we hit the window size\\n            sum+=runningCosts[j];\\n\\n            // to maintain maximum at the begining of the list\\n            while(l.size() > 0 and l.back() < chargeTimes[j]) l.pop_back();\\n            \\n            l.push_back(chargeTimes[j]);\\n            \\n            if(j-i+1 == k) {\\n                // when we hit the window size of k running robots\\n                \\n                maxi = l.front(); // maximum is at the front of the list\\n                \\n                long long b = maxi + k*sum;\\n                // Cost of running k consecutive robots\\n                // if in budget return true\\n                if(b <= budget) return true;\\n\\n                // else shift the window by 1\\n                sum-=runningCosts[i];\\n                if(maxi == chargeTimes[i]) {\\n                    l.pop_front();\\n                }\\n                i++;\\n            }\\n            \\n            j++;\\n        }\\n        \\n        return false;\\n        \\n    }\\n\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        int s = 1;\\n        int e = chargeTimes.size();\\n        \\n        int ans = 0;\\n        \\n        while(s<=e) {\\n            int k = s+(e-s)/2;\\n            \\n            if(isValid(k, chargeTimes, runningCosts, budget)) {\\n                ans = k;\\n                s=k+1;\\n            }\\n            else e = k-1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054076,
                "title": "ez-c-solution-slinding-window-with-multiset-explained",
                "content": "**Time Complexity : O(N log N)**\\n**Space Complexity : O(N)**\\n```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        int ans=0,n=chargeTimes.size();\\n        int i=0;//left pointer\\n        long long cost=0ll;//Store the  sum of running costs among the k robots.\\n        // Here k is the size of the sliding window, which is j-i+1\\n        \\n        int maxCharge=0;\\n        // A multiset [ in Descending Order] so that the beginning element is the largest element of the window\\n        multiset<int,greater<int>>ds;\\n        \\n        for(int j=0;j<n;j++){\\n            \\n            cost+=runningCosts[j];//Calculating the sum of the running costs of the sliding window\\n            ds.insert(chargeTimes[j]);//Inserting each element if chargeTimes to our multiset\\n            maxCharge=*(ds.begin());//The maxElement will be the largest charge cost of the window\\n            long long total=maxCharge+((j-i+1)*cost);//The total cost of running the window [ k robots]\\n            \\n            while(total>budget){//Window is INVALID when total exceeds budget\\n                //We start removing elements from the beginning of the window\\n                cost-=runningCosts[i];\\n                \\n                auto x=ds.find(chargeTimes[i]);//The element that is to be removed, we are finding it in our multiset\\n                if(x!=ds.end())\\n                   ds.erase(x);//Removing that element\\n                \\n                maxCharge=*(ds.begin());//Since its a multiset the fisrt element will be the maximum\\n                \\n                total=maxCharge+((j-i+1)*cost);//Computing new total\\n                i++;//Moving the left pointer\\n            }\\n            ans=max(ans,j-i+1);//Claculating the size of the window [k]\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        int ans=0,n=chargeTimes.size();\\n        int i=0;//left pointer\\n        long long cost=0ll;//Store the  sum of running costs among the k robots.\\n        // Here k is the size of the sliding window, which is j-i+1\\n        \\n        int maxCharge=0;\\n        // A multiset [ in Descending Order] so that the beginning element is the largest element of the window\\n        multiset<int,greater<int>>ds;\\n        \\n        for(int j=0;j<n;j++){\\n            \\n            cost+=runningCosts[j];//Calculating the sum of the running costs of the sliding window\\n            ds.insert(chargeTimes[j]);//Inserting each element if chargeTimes to our multiset\\n            maxCharge=*(ds.begin());//The maxElement will be the largest charge cost of the window\\n            long long total=maxCharge+((j-i+1)*cost);//The total cost of running the window [ k robots]\\n            \\n            while(total>budget){//Window is INVALID when total exceeds budget\\n                //We start removing elements from the beginning of the window\\n                cost-=runningCosts[i];\\n                \\n                auto x=ds.find(chargeTimes[i]);//The element that is to be removed, we are finding it in our multiset\\n                if(x!=ds.end())\\n                   ds.erase(x);//Removing that element\\n                \\n                maxCharge=*(ds.begin());//Since its a multiset the fisrt element will be the maximum\\n                \\n                total=maxCharge+((j-i+1)*cost);//Computing new total\\n                i++;//Moving the left pointer\\n            }\\n            ans=max(ans,j-i+1);//Claculating the size of the window [k]\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017899,
                "title": "java-binary-search-solution-with-sliding-window",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n        int n = chargeTimes.length;\\n        int lo = 0, hi = n;\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo + 1) / 2;\\n            if (check(chargeTimes, runningCosts, budget, mid)) {\\n                lo = mid;\\n            } else {\\n                hi = mid - 1;\\n            }\\n        }\\n        return lo;\\n    }\\n\\n    public boolean check(int[] chargeTimes, int[] runningCosts, long budget, int num) {\\n        long sum = 0;\\n        Deque<Integer> deque = new LinkedList<>();\\n        for (int i = 0; i < chargeTimes.length; i++) {\\n            while (!deque.isEmpty() && chargeTimes[i] >= chargeTimes[deque.peekLast()]) deque.pollLast();\\n            while (!deque.isEmpty() && i - deque.peekFirst() >= num) deque.pollFirst();\\n            if (i >= num) sum -= runningCosts[i - num];\\n            \\n            deque.addLast(i);\\n            sum += runningCosts[i];\\n            if (i >= num - 1 && chargeTimes[deque.peekFirst()] + num * sum <= budget) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Sliding Window",
                    "Monotonic Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n        int n = chargeTimes.length;\\n        int lo = 0, hi = n;\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo + 1) / 2;\\n            if (check(chargeTimes, runningCosts, budget, mid)) {\\n                lo = mid;\\n            } else {\\n                hi = mid - 1;\\n            }\\n        }\\n        return lo;\\n    }\\n\\n    public boolean check(int[] chargeTimes, int[] runningCosts, long budget, int num) {\\n        long sum = 0;\\n        Deque<Integer> deque = new LinkedList<>();\\n        for (int i = 0; i < chargeTimes.length; i++) {\\n            while (!deque.isEmpty() && chargeTimes[i] >= chargeTimes[deque.peekLast()]) deque.pollLast();\\n            while (!deque.isEmpty() && i - deque.peekFirst() >= num) deque.pollFirst();\\n            if (i >= num) sum -= runningCosts[i - num];\\n            \\n            deque.addLast(i);\\n            sum += runningCosts[i];\\n            if (i >= num - 1 && chargeTimes[deque.peekFirst()] + num * sum <= budget) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2880683,
                "title": "c-prefix-sum-sliding-window-maximum-o-n-time-o-n-space",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    typedef long long ll;\\n    \\n    int maximumRobots(vector<int>& c, vector<int>& d, long long budget) {\\n        \\n        int maxLen = 0;\\n        int n = c.size();\\n        int l=0, r=0;\\n        \\n        ll currsum = 0LL; // stores the running sum of our current range.\\n        int maxval = 0LL; // stores the maximum element out of all the elements in our current range.\\n        \\n        deque<int>q;\\n        \\n        while(l<n && r<n){\\n            \\n            currsum += (ll)d[r];\\n            \\n            while(!q.empty() && c[q.back()] <= c[r]){\\n                q.pop_back();\\n            }\\n            \\n            q.push_back(r);\\n            \\n            maxval = c[q.front()];\\n            \\n            while(l<=r && ((ll)maxval + ((r-l+1) * currsum)) > budget){\\n                currsum -= (ll)d[l];\\n                \\n                while(!q.empty() && q.front() <= l){\\n                    q.pop_front();\\n                }\\n                \\n                if(!q.empty()){\\n                    maxval = (ll)c[q.front()];\\n                }else{\\n                    maxval = 0LL;\\n                }\\n                \\n                l++;\\n                \\n            }\\n            \\n            maxLen = max(maxLen,r-l+1);\\n            \\n            r++;\\n            \\n        }\\n        \\n        return maxLen;\\n        \\n    }\\n};\\n\\n\\n/*\\n\\ngoal : maximum number of consecutive robots --> maximize k within\\nbudget\\n\\neq..n  : x =  max(c[i]...c[j]) + (j-i+1) * sum(d[i]...d[j])\\n    \\nif we expand our subarray\\'s right boundary (j -> j+1)\\n    \\n         y = max(c[i]...c[j+1]) + (j-i+2) * sum(d[i]...d[j+1])\\n    \\n         it is easy to observe that \\n         \\n         max(c[i]...c[j+1]) >= max(c[i]...c[j])\\n         sum(d[i]...d[j+1]) >= sum(d[i]...d[j])\\n    \\ndefinitely y >= x\\n\\n(1) obs..n : by expanding our range , we can increase current cost\\n\\nsimilarly , \\n\\nif we shrink the left boundary (i -> i+1)\\n    \\n       z = max(c[i+1]...c[j]) + (j-i) * sum(d[i+1]...d[j])\\n    \\n    it is easily observable that\\n    \\n    max(c[i+1]...c[j]) <= max(c[i]...c[j])\\n    sum(d[i+1]...d[j]) <= sum(d[i]...d[j])\\n    \\n(2) obs..n : by shrinking our range , we can decrease current cost\\n\\n\\nsummary : when the length of the current range increases , ass \\ncost will be higher , and similarly when the length of the current \\nrange decreases , ass cost will be lower than previous cost.\\n    \\n          All in all , it shows the monotoneous behaviour , that\\n          is a clear indication to use sliding window approach.\\n    \\n    (1) during these approach , we need to calc the running sum of \\n    the current interval , that we can easily do using prefix sum.\\n    \\n    (2) also we need to calc the max out of all the current \\n    elements in the interval (we use a deque to store the maximum\\n    value of the interval at the top of the DS).\\n    \\n*/\\n\\n/*\\n\\nTime Complexity  : O(N)\\nSpace Complexity : O(N)\\n\\n*/\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    typedef long long ll;\\n    \\n    int maximumRobots(vector<int>& c, vector<int>& d, long long budget) {\\n        \\n        int maxLen = 0;\\n        int n = c.size();\\n        int l=0, r=0;\\n        \\n        ll currsum = 0LL; // stores the running sum of our current range.\\n        int maxval = 0LL; // stores the maximum element out of all the elements in our current range.\\n        \\n        deque<int>q;\\n        \\n        while(l<n && r<n){\\n            \\n            currsum += (ll)d[r];\\n            \\n            while(!q.empty() && c[q.back()] <= c[r]){\\n                q.pop_back();\\n            }\\n            \\n            q.push_back(r);\\n            \\n            maxval = c[q.front()];\\n            \\n            while(l<=r && ((ll)maxval + ((r-l+1) * currsum)) > budget){\\n                currsum -= (ll)d[l];\\n                \\n                while(!q.empty() && q.front() <= l){\\n                    q.pop_front();\\n                }\\n                \\n                if(!q.empty()){\\n                    maxval = (ll)c[q.front()];\\n                }else{\\n                    maxval = 0LL;\\n                }\\n                \\n                l++;\\n                \\n            }\\n            \\n            maxLen = max(maxLen,r-l+1);\\n            \\n            r++;\\n            \\n        }\\n        \\n        return maxLen;\\n        \\n    }\\n};\\n\\n\\n/*\\n\\ngoal : maximum number of consecutive robots --> maximize k within\\nbudget\\n\\neq..n  : x =  max(c[i]...c[j]) + (j-i+1) * sum(d[i]...d[j])\\n    \\nif we expand our subarray\\'s right boundary (j -> j+1)\\n    \\n         y = max(c[i]...c[j+1]) + (j-i+2) * sum(d[i]...d[j+1])\\n    \\n         it is easy to observe that \\n         \\n         max(c[i]...c[j+1]) >= max(c[i]...c[j])\\n         sum(d[i]...d[j+1]) >= sum(d[i]...d[j])\\n    \\ndefinitely y >= x\\n\\n(1) obs..n : by expanding our range , we can increase current cost\\n\\nsimilarly , \\n\\nif we shrink the left boundary (i -> i+1)\\n    \\n       z = max(c[i+1]...c[j]) + (j-i) * sum(d[i+1]...d[j])\\n    \\n    it is easily observable that\\n    \\n    max(c[i+1]...c[j]) <= max(c[i]...c[j])\\n    sum(d[i+1]...d[j]) <= sum(d[i]...d[j])\\n    \\n(2) obs..n : by shrinking our range , we can decrease current cost\\n\\n\\nsummary : when the length of the current range increases , ass \\ncost will be higher , and similarly when the length of the current \\nrange decreases , ass cost will be lower than previous cost.\\n    \\n          All in all , it shows the monotoneous behaviour , that\\n          is a clear indication to use sliding window approach.\\n    \\n    (1) during these approach , we need to calc the running sum of \\n    the current interval , that we can easily do using prefix sum.\\n    \\n    (2) also we need to calc the max out of all the current \\n    elements in the interval (we use a deque to store the maximum\\n    value of the interval at the top of the DS).\\n    \\n*/\\n\\n/*\\n\\nTime Complexity  : O(N)\\nSpace Complexity : O(N)\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2731523,
                "title": "maximum-number-of-robots-within-budget-c-explained-solution",
                "content": "The question here is basically a simple combination of two algorithms, namely : **Binary Search** and **Sliding Window Maximum**. Now binary search is basically to find the most optimum number of robots. This is applicable here because if budget does not satisfies for **M** robots, then for sure it cannot satisfy for any number of robots greater than **M**. Similarly if budget satisfies for **M** robots, then it will surely satisfy for any number of robots lesser than **M**. Now the second part is for finding maximum in a window of size **mid**. The first approach for this purpose is using a **max heap / priority queue** which takes a runtime of O(NlogN). In this post we are going to use a better approach which uses **deque** for finding maximum in a window with a runtime of O(N). The implementation of above approach is given below : \\n\\nTime Complexity : O(NLogN) , **Log(N) is for binary search and N is for finding max in a window**. Had it been use of priority queue, runtime would be O(N*(LogN)^2).\\nSpace Complexity : O(N)\\n\\nCode : \\n```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        ios_base::sync_with_stdio(0);\\n        int start = 1,end = chargeTimes.size(),mid = 0,ans = 0,n = chargeTimes.size();\\n        while(start<=end){             // Finding most optimal number of robots\\n            mid = start+(end-start)/2;\\n            long long sum = 0; bool c = false;\\n            deque<int>dq;                            \\n            int i = 0;\\n            for(; i<mid; i++){            // Sliding Window Maximum Algorithm\\n                sum+=runningCosts[i];\\n                while(!dq.empty() && chargeTimes[dq.back()]<=chargeTimes[i]){\\n                    dq.pop_back();\\n                }\\n                dq.push_back(i);\\n            }\\n            for(; i<n; i++){\\n                long long cost = mid*sum+(long long)chargeTimes[dq.front()];\\n                if(cost<=budget){\\n                    c = true;\\n                    break;\\n                }\\n                while(!dq.empty() && dq.front()<=i-mid){\\n                    dq.pop_front();\\n                }\\n                while(!dq.empty() && chargeTimes[dq.back()]<=chargeTimes[i]){\\n                    dq.pop_back();\\n                }\\n                dq.push_back(i);\\n                sum-=runningCosts[i-mid];\\n                sum+=runningCosts[i];\\n            }\\n            long long cost = mid*sum+(long long)chargeTimes[dq.front()];\\n            if(cost<=budget){\\n                c = true;\\n            }\\n            if(c){\\n                ans = mid;\\n                start = mid+1;\\n            }\\n            else{\\n                end = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Do Upvote If Found Helpful !**",
                "solutionTags": [
                    "Math",
                    "Binary Search",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        ios_base::sync_with_stdio(0);\\n        int start = 1,end = chargeTimes.size(),mid = 0,ans = 0,n = chargeTimes.size();\\n        while(start<=end){             // Finding most optimal number of robots\\n            mid = start+(end-start)/2;\\n            long long sum = 0; bool c = false;\\n            deque<int>dq;                            \\n            int i = 0;\\n            for(; i<mid; i++){            // Sliding Window Maximum Algorithm\\n                sum+=runningCosts[i];\\n                while(!dq.empty() && chargeTimes[dq.back()]<=chargeTimes[i]){\\n                    dq.pop_back();\\n                }\\n                dq.push_back(i);\\n            }\\n            for(; i<n; i++){\\n                long long cost = mid*sum+(long long)chargeTimes[dq.front()];\\n                if(cost<=budget){\\n                    c = true;\\n                    break;\\n                }\\n                while(!dq.empty() && dq.front()<=i-mid){\\n                    dq.pop_front();\\n                }\\n                while(!dq.empty() && chargeTimes[dq.back()]<=chargeTimes[i]){\\n                    dq.pop_back();\\n                }\\n                dq.push_back(i);\\n                sum-=runningCosts[i-mid];\\n                sum+=runningCosts[i];\\n            }\\n            long long cost = mid*sum+(long long)chargeTimes[dq.front()];\\n            if(cost<=budget){\\n                c = true;\\n            }\\n            if(c){\\n                ans = mid;\\n                start = mid+1;\\n            }\\n            else{\\n                end = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2638468,
                "title": "python3-sliding-window-decreasing-monotonic-queue-beats-98",
                "content": "1. we will track the maximum chargeTimes in the current window so far using decreasing monotonic queue.\\n    so, we can always found the maximum chargeTimes with in current window on dec_queue[0]\\n\\t--> whenever we remove left element from window, we should check if its chargeTimes is the maximum chargeTimes we have had so far (i.e if chargeTime == dec_queue[0]) if so we will popleft it\\n\\t\\n\\n\\n\\'\\'\\'\\n\\n        \\n        \\n\\tclass Solution:\\n\\t\\tdef maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\\n\\t\\t\\tdec_queue = collections.deque() # to contain maximum chargeTimes \\n\\t\\t\\tl = r = 0\\n\\t\\t\\tcurWindowSum = res = 0\\n\\t\\t\\twhile r < len(chargeTimes):\\n\\n\\t\\t\\t\\twhile dec_queue and dec_queue[-1] < chargeTimes[r]:\\n\\t\\t\\t\\t\\tdec_queue.pop() \\n\\n\\t\\t\\t\\tdec_queue.append(chargeTimes[r])\\n\\n\\t\\t\\t\\tcurWindowSum += runningCosts[r]\\n\\t\\t\\t\\tcurCost = dec_queue[0] + (r-l+1) * curWindowSum\\n\\n\\t\\t\\t\\twhile dec_queue and curCost > budget:\\n\\n\\t\\t\\t\\t\\tif chargeTimes[l] == dec_queue[0]:\\n\\t\\t\\t\\t\\t\\tdec_queue.popleft()\\n\\n\\t\\t\\t\\t\\tcurWindowSum -= runningCosts[l]\\n\\t\\t\\t\\t\\tl += 1\\n\\n\\t\\t\\t\\t\\tif not dec_queue:\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t# re calculate curCost after removing runningCosts[l]\\n\\t\\t\\t\\t\\tcurCost = dec_queue[0] + (r-l+1) * curWindowSum\\n\\n\\t\\t\\t\\tif curCost <= budget:\\n\\t\\t\\t\\t\\tres = max(res, r-l+1)\\n\\t\\t\\t\\tr += 1\\n\\n\\n\\t\\t\\treturn res\\n\\'\\'\\'",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "1. we will track the maximum chargeTimes in the current window so far using decreasing monotonic queue.\\n    so, we can always found the maximum chargeTimes with in current window on dec_queue[0]\\n\\t--> whenever we remove left element from window, we should check if its chargeTimes is the maximum chargeTimes we have had so far (i.e if chargeTime == dec_queue[0]) if so we will popleft it\\n\\t\\n\\n\\n\\'\\'\\'\\n\\n        \\n        \\n\\tclass Solution:\\n\\t\\tdef maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\\n\\t\\t\\tdec_queue = collections.deque() # to contain maximum chargeTimes \\n\\t\\t\\tl = r = 0\\n\\t\\t\\tcurWindowSum = res = 0\\n\\t\\t\\twhile r < len(chargeTimes):\\n\\n\\t\\t\\t\\twhile dec_queue and dec_queue[-1] < chargeTimes[r]:\\n\\t\\t\\t\\t\\tdec_queue.pop() \\n\\n\\t\\t\\t\\tdec_queue.append(chargeTimes[r])\\n\\n\\t\\t\\t\\tcurWindowSum += runningCosts[r]\\n\\t\\t\\t\\tcurCost = dec_queue[0] + (r-l+1) * curWindowSum\\n\\n\\t\\t\\t\\twhile dec_queue and curCost > budget:\\n\\n\\t\\t\\t\\t\\tif chargeTimes[l] == dec_queue[0]:\\n\\t\\t\\t\\t\\t\\tdec_queue.popleft()\\n\\n\\t\\t\\t\\t\\tcurWindowSum -= runningCosts[l]\\n\\t\\t\\t\\t\\tl += 1\\n\\n\\t\\t\\t\\t\\tif not dec_queue:\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t# re calculate curCost after removing runningCosts[l]\\n\\t\\t\\t\\t\\tcurCost = dec_queue[0] + (r-l+1) * curWindowSum\\n\\n\\t\\t\\t\\tif curCost <= budget:\\n\\t\\t\\t\\t\\tres = max(res, r-l+1)\\n\\t\\t\\t\\tr += 1\\n\\n\\n\\t\\t\\treturn res\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 2630569,
                "title": "c-100-faster-than-all-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& charge, vector<int>& runningCosts, long long budget) {\\n // It is mixture of (maximum value in k size sliding window + a normal problem of variable size sliding window with prefix sum)\\n        int i=0;\\n        int j=0;\\n        deque<int>dq;\\n        long long prefix_sum=0;\\n        int ans=0;\\n            \\n        // Variable window size problem\\n        while(j<runningCosts.size())\\n        {\\n            // Do pre-calculation \\n               // 1\\n                while(!dq.empty()&&(charge[dq.back()]<charge[j]))\\n                    dq.pop_back();\\n                dq.push_back(j);\\n              \\n              // 2\\n               prefix_sum+=runningCosts[j];\\n            \\n            long long need=charge[dq.front()]+(long long)(j-i+1)*prefix_sum;\\n            \\n            // Play with condition\\n            while(need>budget)\\n            {\\n                // Remove the calculation for i\\n                \\n                if(!dq.empty()&&dq.front()==i)\\n                    dq.pop_front();\\n                prefix_sum-=runningCosts[i];\\n                if(!dq.empty())\\n                need=charge[dq.front()]+(long long)(j-i+1)*prefix_sum;\\n                else\\n                    need=0;\\n                i++;\\n            } \\n            \\n            // Store result\\n            ans=max(ans,j-i+1);\\n            \\n            // Slide the window\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maximumRobots(vector<int>& charge, vector<int>& runningCosts, long long budget) {\\n // It is mixture of (maximum value in k size sliding window + a normal problem of variable size sliding window with prefix sum)\\n        int i=0;\\n        int j=0;\\n        deque<int>dq;\\n        long long prefix_sum=0;\\n        int ans=0;\\n            \\n        // Variable window size problem\\n        while(j<runningCosts.size())\\n        {\\n            // Do pre-calculation \\n               // 1\\n                while(!dq.empty()&&(charge[dq.back()]<charge[j]))\\n                    dq.pop_back();\\n                dq.push_back(j);\\n              \\n              // 2\\n               prefix_sum+=runningCosts[j];\\n            \\n            long long need=charge[dq.front()]+(long long)(j-i+1)*prefix_sum;\\n            \\n            // Play with condition\\n            while(need>budget)\\n            {\\n                // Remove the calculation for i\\n                \\n                if(!dq.empty()&&dq.front()==i)\\n                    dq.pop_front();\\n                prefix_sum-=runningCosts[i];\\n                if(!dq.empty())\\n                need=charge[dq.front()]+(long long)(j-i+1)*prefix_sum;\\n                else\\n                    need=0;\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2585623,
                "title": "java-sliding-window-priority-queue",
                "content": "```\\nclass Solution {\\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n        int ans=0;\\n        PriorityQueue<Integer>pq=new PriorityQueue<>(Collections.reverseOrder());\\n        long currsum=0;\\n        int i=0;\\n        for(int j=0;j<chargeTimes.length;j++){\\n            currsum+=runningCosts[j];\\n            pq.add(chargeTimes[j]);\\n            \\n            while(i<=j &&(long)(pq.peek()+(j-i+1)*(long)currsum)>budget){\\n                currsum-=runningCosts[i];\\n                pq.remove(chargeTimes[i]);\\n                i++;\\n            }\\n            ans=Math.max(ans,j-i+1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n        int ans=0;\\n        PriorityQueue<Integer>pq=new PriorityQueue<>(Collections.reverseOrder());\\n        long currsum=0;\\n        int i=0;\\n        for(int j=0;j<chargeTimes.length;j++){\\n            currsum+=runningCosts[j];\\n            pq.add(chargeTimes[j]);\\n            \\n            while(i<=j &&(long)(pq.peek()+(j-i+1)*(long)currsum)>budget){\\n                currsum-=runningCosts[i];\\n                pq.remove(chargeTimes[i]);\\n                i++;\\n            }\\n            ans=Math.max(ans,j-i+1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568354,
                "title": "why-does-a-monotonic-stack-work",
                "content": "I see a lot of solutions using a monotonic stack/deque. I get the intuition of why it would work but is there a formal demonstration/explanation?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2552243,
                "title": "java-o-n-easy-explain",
                "content": "There are two costs : c1 and c2\\nThe total cost = max(c1) + k * sum(c2)\\nwhere k is the number of elements in the subarray\\n\\nidea:\\nc1 -> need the maximum for each subarray window -> can be found with sliding window with deque in o(n)\\nc2 -> need the contiguous sum of each subarray window -> can be found using prefix sum\\n\\nwe simply keep track of left end of window if the total cost exceeds budget then we increase the left end and then recompute the total cost -> can be done in O (n) as shown below\\n\\n\\n```\\nclass Solution {\\n    public int maximumRobots(int[] c1, int[] c2, long budget) {\\n        Deque<Integer> dq = new ArrayDeque<>();\\n        int n = c1.length, left = -1, ans = 0, mx = 0;\\n        long[] pre = new long[n];\\n        long sum = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            pre[i] = i==0?c2[i]:pre[i-1]+c2[i];\\n            while(!dq.isEmpty() && c1[dq.peekLast()] < c1[i])\\n                dq.removeLast();\\n            while(!dq.isEmpty() && dq.peekFirst() <= left )\\n                dq.removeFirst();            \\n            \\n            dq.addLast(i);\\n            mx = c1[dq.peekFirst()];\\n            sum = pre[i] - (left>=0?pre[left]:0);\\n            \\n            int k = i - left;\\n            long cost = mx + k * sum;\\n            \\n            while(left < i && cost > budget){\\n                if(!dq.isEmpty() && dq.peekFirst() == left)\\n                    dq.removeFirst();\\n                left++;\\n                if(!dq.isEmpty()){\\n                    mx = c1[dq.peekFirst()];\\n                    k = i - left;\\n                    sum = pre[i] - pre[left];\\n                    cost = mx + k * sum;\\n                }\\n            }\\n            \\n            if(cost <= budget)\\n                ans = Math.max(k, ans);            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumRobots(int[] c1, int[] c2, long budget) {\\n        Deque<Integer> dq = new ArrayDeque<>();\\n        int n = c1.length, left = -1, ans = 0, mx = 0;\\n        long[] pre = new long[n];\\n        long sum = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            pre[i] = i==0?c2[i]:pre[i-1]+c2[i];\\n            while(!dq.isEmpty() && c1[dq.peekLast()] < c1[i])\\n                dq.removeLast();\\n            while(!dq.isEmpty() && dq.peekFirst() <= left )\\n                dq.removeFirst();            \\n            \\n            dq.addLast(i);\\n            mx = c1[dq.peekFirst()];\\n            sum = pre[i] - (left>=0?pre[left]:0);\\n            \\n            int k = i - left;\\n            long cost = mx + k * sum;\\n            \\n            while(left < i && cost > budget){\\n                if(!dq.isEmpty() && dq.peekFirst() == left)\\n                    dq.removeFirst();\\n                left++;\\n                if(!dq.isEmpty()){\\n                    mx = c1[dq.peekFirst()];\\n                    k = i - left;\\n                    sum = pre[i] - pre[left];\\n                    cost = mx + k * sum;\\n                }\\n            }\\n            \\n            if(cost <= budget)\\n                ans = Math.max(k, ans);            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2547006,
                "title": "javascript-sliding-window-max-heap-for-charging-quite-similar-to-jump-game-vi",
                "content": "Quite similiar to the way I solved Jump game VI https://leetcode.com/submissions/detail/794296300/\\nIdea: Sliding window + Max heap for charging\\n```\\nvar maximumRobots = function(chargeTimes, runningCosts, budget) {\\n    const pq = new PriorityQueue((a,b) => b.val - a.val)\\n    let i = 0\\n    let j = 0 \\n    \\n    let currSum = 0\\n    let maxSoFar = 0\\n    while(j < runningCosts.length) {\\n        pq.enqueue({idx:j, val: chargeTimes[j]})\\n        currSum+=runningCosts[j]\\n        \\n        while(pq.size() && currSum*(j-i+1) + pq.peek().val > budget && i < runningCosts.length) {\\n            currSum -= runningCosts[i]\\n            while(pq.size() && pq.peek().idx <= i) {\\n                pq.dequeue()\\n            }\\n            i++\\n        }\\n        \\n        maxSoFar = Math.max(maxSoFar, j-i+1)\\n        j++\\n    }\\n    \\n    return maxSoFar\\n};\\n\\n\\n// My priority queue implementation\\nclass PriorityQueue {\\n  constructor(compFunc){\\n    this.compFunc =  compFunc\\n    this.heap = []\\n  }\\n\\n\\n  enqueue(val){\\n    this.heap.push(val)\\n\\n    if(this.heap.length > 1){\\n      this.siftUp(this.heap.length - 1)\\n    }\\n      \\n  }\\n\\n  dequeue(){\\n      \\n    if(this.heap.length <= 1){\\n      return this.heap.pop()\\n    }\\n\\n    this.swap(0, this.heap.length - 1)\\n\\n    const removed = this.heap.pop()\\n\\n    if(this.heap.length > 1){\\n      this.siftDown(0)\\n    }\\n\\n    return removed\\n  }\\n\\n  size(){\\n    return this.heap.length\\n  }\\n\\n  peek(){\\n    return this.heap[0]\\n  }\\n\\n  siftUp(idx){\\n    const parent = Math.floor((idx - 1)/2)\\n    if(parent < 0) return\\n    \\n\\n    //                     5                  3\\n    if(this.compFunc(this.heap[parent], this.heap[idx]) > 0){\\n      this.swap(parent, idx)\\n      this.siftUp(parent)\\n    }\\n  }\\n\\n  siftDown(idx){\\n    if(idx >= this.heap.length - 1) return\\n\\n    const child = this.getChild(idx)\\n    if(!child) return\\n\\n\\n    //                       5            1\\n    if(this.compFunc(this.heap[idx], this.heap[child]) > 0){\\n      this.swap(idx, child)\\n      this.siftDown(child)\\n    }\\n  }\\n\\n  getChild(idx){\\n    let left = 2*idx + 1\\n    let right = 2*idx + 2\\n    \\n   if(this.heap.length <= left) left = null\\n    if(this.heap.length <= right) right = null\\n\\n    if(left !== null && right !== null) {\\n      return this.compFunc(this.heap[left], this.heap[right]) > 0 ? right : left\\n    }\\n\\n    return left\\n  }\\n\\n  swap(i, j){\\n    [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]]\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\nvar maximumRobots = function(chargeTimes, runningCosts, budget) {\\n    const pq = new PriorityQueue((a,b) => b.val - a.val)\\n    let i = 0\\n    let j = 0 \\n    \\n    let currSum = 0\\n    let maxSoFar = 0\\n    while(j < runningCosts.length) {\\n        pq.enqueue({idx:j, val: chargeTimes[j]})\\n        currSum+=runningCosts[j]\\n        \\n        while(pq.size() && currSum*(j-i+1) + pq.peek().val > budget && i < runningCosts.length) {\\n            currSum -= runningCosts[i]\\n            while(pq.size() && pq.peek().idx <= i) {\\n                pq.dequeue()\\n            }\\n            i++\\n        }\\n        \\n        maxSoFar = Math.max(maxSoFar, j-i+1)\\n        j++\\n    }\\n    \\n    return maxSoFar\\n};\\n\\n\\n// My priority queue implementation\\nclass PriorityQueue {\\n  constructor(compFunc){\\n    this.compFunc =  compFunc\\n    this.heap = []\\n  }\\n\\n\\n  enqueue(val){\\n    this.heap.push(val)\\n\\n    if(this.heap.length > 1){\\n      this.siftUp(this.heap.length - 1)\\n    }\\n      \\n  }\\n\\n  dequeue(){\\n      \\n    if(this.heap.length <= 1){\\n      return this.heap.pop()\\n    }\\n\\n    this.swap(0, this.heap.length - 1)\\n\\n    const removed = this.heap.pop()\\n\\n    if(this.heap.length > 1){\\n      this.siftDown(0)\\n    }\\n\\n    return removed\\n  }\\n\\n  size(){\\n    return this.heap.length\\n  }\\n\\n  peek(){\\n    return this.heap[0]\\n  }\\n\\n  siftUp(idx){\\n    const parent = Math.floor((idx - 1)/2)\\n    if(parent < 0) return\\n    \\n\\n    //                     5                  3\\n    if(this.compFunc(this.heap[parent], this.heap[idx]) > 0){\\n      this.swap(parent, idx)\\n      this.siftUp(parent)\\n    }\\n  }\\n\\n  siftDown(idx){\\n    if(idx >= this.heap.length - 1) return\\n\\n    const child = this.getChild(idx)\\n    if(!child) return\\n\\n\\n    //                       5            1\\n    if(this.compFunc(this.heap[idx], this.heap[child]) > 0){\\n      this.swap(idx, child)\\n      this.siftDown(child)\\n    }\\n  }\\n\\n  getChild(idx){\\n    let left = 2*idx + 1\\n    let right = 2*idx + 2\\n    \\n   if(this.heap.length <= left) left = null\\n    if(this.heap.length <= right) right = null\\n\\n    if(left !== null && right !== null) {\\n      return this.compFunc(this.heap[left], this.heap[right]) > 0 ? right : left\\n    }\\n\\n    return left\\n  }\\n\\n  swap(i, j){\\n    [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]]\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2533479,
                "title": "simple-c-solution-using-priority-queue-and-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    using ll=long long int;\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        \\n        ll end=0;\\n        ll start=0;\\n        \\n        priority_queue<pair<ll,ll>> pq;\\n        ll n=chargeTimes.size();\\n        ll cost=0;\\n        ll ans=0;\\n        for(;end<n;end++){\\n            \\n            cost+=runningCosts[end];\\n            pq.push({chargeTimes[end],end});\\n\\t\\t\\t// remove those max charge times from pq who are out of the  current window \\n            while(pq.empty()==false && pq.top().second<start)pq.pop();\\n            // pq top will contain the max charge time in that window\\n            ll maxChargeTime=pq.top().first;\\n            //calc the current budget\\n            ll currBudget= maxChargeTime+(end-start+1)*(cost);\\n            //check for the condition \\n            if(currBudget<=budget){\\n                \\n                ans=max(ans,end-start+1);\\n                \\n                \\n            }\\n            else{\\n                //if curr budget is greater that given budget squeez the window from left\\n                cost-=runningCosts[start];\\n                start++;\\n   \\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using ll=long long int;\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        \\n        ll end=0;\\n        ll start=0;\\n        \\n        priority_queue<pair<ll,ll>> pq;\\n        ll n=chargeTimes.size();\\n        ll cost=0;\\n        ll ans=0;\\n        for(;end<n;end++){\\n            \\n            cost+=runningCosts[end];\\n            pq.push({chargeTimes[end],end});\\n\\t\\t\\t// remove those max charge times from pq who are out of the  current window \\n            while(pq.empty()==false && pq.top().second<start)pq.pop();\\n            // pq top will contain the max charge time in that window\\n            ll maxChargeTime=pq.top().first;\\n            //calc the current budget\\n            ll currBudget= maxChargeTime+(end-start+1)*(cost);\\n            //check for the condition \\n            if(currBudget<=budget){\\n                \\n                ans=max(ans,end-start+1);\\n                \\n                \\n            }\\n            else{\\n                //if curr budget is greater that given budget squeez the window from left\\n                cost-=runningCosts[start];\\n                start++;\\n   \\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2533174,
                "title": "cpp-binary-search-segment-tree-sliding-window-akash-kumar-akash-musky",
                "content": "I have Used segement tree to find range maximum in logn Times. I have used binary search and with sliding window so that if i found that within given budget if mid number of robots can be bought then we can ignore the left half and look for the more number of robots. \\n\\nTime Complexity:: O(N*Logn*Logn)\\nHere Is my Code::\\n\\n```\\n\\n\\n```class Solution {\\npublic:\\nvoid buildTree(int *tree,vector<int> &a,int index,int s,int e)\\n {\\n\\t//base case\\n\\tif(s>e)\\n\\t\\treturn;\\n\\t//reached leaf node\\n\\tif(s==e)\\n\\t{\\n\\t\\ttree[index]=a[s];\\n\\t\\treturn ;\\n\\t}\\n\\t//now build the segment tree in bottom up manner\\n\\tint m = (s+e)/2;\\n\\tbuildTree(tree,a,2*index,s,m);\\n\\tbuildTree(tree,a,2*index+1,m+1,e);\\n\\ttree[index]= max(tree[2*index],tree[2*index+1]);\\n\\treturn;\\n}\\n    \\nint query(int *tree,int index,int s,int e,int qs,int qe)\\n{\\n\\t//base case: if query range is outside the node range\\n\\tif(qs>e || s>qe)\\n\\t\\treturn INT_MIN;\\n\\t//complete overlap\\n\\tif(s>=qs && e<=qe)\\n\\t\\treturn tree[index];\\n\\t//now partial overlap case is executed\\n\\tint m = (s+e)/2;\\n\\tint left_ans = query(tree,2*index,s,m,qs,qe);\\n\\tint right_ans = query(tree,2*index+1,m+1,e,qs,qe);\\n\\treturn max(left_ans,right_ans);\\n}\\n    \\nint maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        //this is simple question. segment tree and binary search..\\n        //segment tree to get the range maximum and binary search to fix the length...\\n        \\n        \\n        //first applying binary search successfully..\\n        //Time Complexity:: O(nLog(n)*Log(n));\\n        \\n        int ans=0,n=chargeTimes.size(),low=0,high=n;\\n        int *tree = new int[4*n+1];  \\n        int index = 1,s =0,e=n-1;\\n        \\n        buildTree(tree,chargeTimes,index,s,e);\\n        \\n        while(low<=high)\\n        {\\n            int mid=(high-low)/2+low;\\n            bool ok=false;\\n            \\n            long long curr_budget=0LL;\\n            long long sum=0LL;\\n            \\n            for(int i=0;i<mid;i++)\\n            sum+=runningCosts[i];\\n            \\n            \\n            curr_budget=sum*mid+query(tree,index,0,n-1,0,mid-1);\\n            \\n            if(curr_budget<=budget)\\n                ok=true;\\n            \\n            for(int i=mid;i<n;i++)\\n            {\\n                sum+=(runningCosts[i]-runningCosts[i-mid]);\\n                curr_budget=sum*mid+query(tree,index,0,n-1,i-mid+1,i);\\n                \\n                if(curr_budget<=budget)\\n                {\\n                    ok=true;\\n                    break;\\n                }\\n            }\\n            \\n            if(ok)\\n            ans=mid,low=mid+1;\\n            else\\n            high=mid-1;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Binary Search",
                    "Tree",
                    "Sliding Window"
                ],
                "code": "```\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2530560,
                "title": "pure-o-n-simple-deque-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) \\n    {\\n        deque<int> q;\\n        \\n        int n = chargeTimes.size(), j = 0, ans = 0;\\n        long long rCost = 0, cCost = 0;\\n        \\n        for(int i=0; i<n; i++)\\n        {   \\n            rCost += runningCosts[i];\\n            \\n            while(q.empty() == false and chargeTimes[q.back()] <= chargeTimes[i])\\n            {\\n                q.pop_back();\\n            }\\n            \\n            q.push_back(i);\\n            \\n            while( q.empty() == false and (chargeTimes[q.front()] + ((i - j + 1) * rCost)) > budget)\\n            {\\n                rCost -= runningCosts[j];\\n                j++;\\n                \\n                while(q.empty() == false and q.front() < j)\\n                    q.pop_front();\\n            }\\n            \\n            ans = max(ans,  (i - j + 1));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) \\n    {\\n        deque<int> q;\\n        \\n        int n = chargeTimes.size(), j = 0, ans = 0;\\n        long long rCost = 0, cCost = 0;\\n        \\n        for(int i=0; i<n; i++)\\n        {   \\n            rCost += runningCosts[i];\\n            \\n            while(q.empty() == false and chargeTimes[q.back()] <= chargeTimes[i])\\n            {\\n                q.pop_back();\\n            }\\n            \\n            q.push_back(i);\\n            \\n            while( q.empty() == false and (chargeTimes[q.front()] + ((i - j + 1) * rCost)) > budget)\\n            {\\n                rCost -= runningCosts[j];\\n                j++;\\n                \\n                while(q.empty() == false and q.front() < j)\\n                    q.pop_front();\\n            }\\n            \\n            ans = max(ans,  (i - j + 1));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2529923,
                "title": "java-sliding-window-similar-to-sliding-window-maximum",
                "content": "```\\npublic int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n       int n = chargeTimes.length;\\n       int i = 0;\\n       int j = 0;\\n       int max = 0;\\n       int count = 0;\\n       int ans = 0;\\n       long sum =0 ;\\n       long res = 0;\\n\\n       while(j < n){\\n           // calculations\\n           sum += runningCosts[j];\\n           max = Math.max(max,chargeTimes[i]);\\n           count++;\\n           res = max + count * sum;\\n    \\n           // Return the max window size that is <= budget\\n           if(res <= budget){\\n               ans = Math.max(ans, j-i+1);\\n               j++;\\n           }\\n\\n            if(res > budget){\\n               while(res > budget){\\n                   // Remove calculatons of i\\n                   sum -= runningCosts[i];\\n                   max = 0;\\n                   for(int a = i+1; a < j; a++){\\n                       max = Math.max(max,chargeTimes[a]);\\n                   }\\n                   count--;\\n                   res = max + count*sum;\\n                   i++;\\n               }\\n               j++;\\n            }\\n       }\\n\\n       return ans;\\n\\n    }\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\npublic int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n       int n = chargeTimes.length;\\n       int i = 0;\\n       int j = 0;\\n       int max = 0;\\n       int count = 0;\\n       int ans = 0;\\n       long sum =0 ;\\n       long res = 0;\\n\\n       while(j < n){\\n           // calculations\\n           sum += runningCosts[j];\\n           max = Math.max(max,chargeTimes[i]);\\n           count++;\\n           res = max + count * sum;\\n    \\n           // Return the max window size that is <= budget\\n           if(res <= budget){\\n               ans = Math.max(ans, j-i+1);\\n               j++;\\n           }\\n\\n            if(res > budget){\\n               while(res > budget){\\n                   // Remove calculatons of i\\n                   sum -= runningCosts[i];\\n                   max = 0;\\n                   for(int a = i+1; a < j; a++){\\n                       max = Math.max(max,chargeTimes[a]);\\n                   }\\n                   count--;\\n                   res = max + count*sum;\\n                   i++;\\n               }\\n               j++;\\n            }\\n       }\\n\\n       return ans;\\n\\n    }\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2529193,
                "title": "easy-binary-search-and-sliding-window-solution-c-efficient-solution",
                "content": "class Solution {\\npublic:\\n\\n    int n;\\n    long long res(vector<int> &ct, vector<int> &rc, long long k){\\n        if(k <= 0) return 0;\\n        long long ans = 1e18;\\n        long long i = 0, mx = 0, sum = 0;\\n        deque<long long> dq(k);\\n        for(i = 0; i < n and i < k; i++){\\n            while ((!dq.empty()) && ct[i] >= ct[dq.back()])\\n                dq.pop_back();\\n \\n            dq.push_back(i);\\n            sum += rc[i];\\n        }\\n        mx = ct[dq.front()];\\n        \\n        for(int j = 0; i < n; i++, j ++){\\n            mx = ct[dq.front()];\\n            ans = min(ans, mx + k * sum);\\n            while ((!dq.empty()) && dq.front() <= i - k)\\n                dq.pop_front();\\n            \\n            while ((!dq.empty()) && ct[i] >= ct[dq.back()])\\n                dq.pop_back();\\n \\n            dq.push_back(i);\\n            sum += rc[i];\\n            sum -= rc[j];\\n        }\\n        mx = ct[dq.front()];\\n        ans = min(ans, mx + k * sum);\\n        \\n        return ans;\\n    }\\n    int maximumRobots(vector<int>& ct, vector<int>& rc, long long b) {\\n        n = ct.size();\\n        \\n        long long l = 0, r = n;\\n        int ans = 0;\\n        while(l <= r){\\n            long long mid = l + (r-l)/2;\\n            \\n            if(res(ct, rc, mid) <= b){\\n                ans = mid;\\n                l = mid + 1;\\n            }\\n            else r = mid-1;\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int n;\\n    long long res(vector<int> &ct, vector<int> &rc, long long k){\\n        if(k <= 0) return 0;\\n        long long ans = 1e18;\\n        long long i = 0, mx = 0, sum = 0;\\n        deque<long long> dq(k);\\n        for(i = 0; i < n and i < k; i++){\\n            while ((!dq.empty()) && ct[i] >= ct[dq.back()])\\n                dq.pop_back();\\n \\n            dq.push_back(i);\\n            sum += rc[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2528963,
                "title": "java-sliding-window-deque",
                "content": "```\\nclass Solution {\\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n        long sum = 0 ;\\n        int i = 0, n = chargeTimes.length ;\\n        Deque<Integer> d = new LinkedList<>() ;\\n        \\n        for (int j = 0; j < n; j++) {\\n            sum += runningCosts[j] ;\\n            \\n            while (!d.isEmpty() && chargeTimes[d.peekLast()] <= chargeTimes[j])\\n                d.pollLast() ;\\n            d.addLast(j) ;\\n            if (chargeTimes[d.getFirst()] + (j-i+1)*sum > budget) {\\n                if (d.getFirst() == i)\\n                    d.pollFirst() ;\\n                sum -= runningCosts[i++] ;\\n            }\\n        }\\n        \\n        return n-i ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n        long sum = 0 ;\\n        int i = 0, n = chargeTimes.length ;\\n        Deque<Integer> d = new LinkedList<>() ;\\n        \\n        for (int j = 0; j < n; j++) {\\n            sum += runningCosts[j] ;\\n            \\n            while (!d.isEmpty() && chargeTimes[d.peekLast()] <= chargeTimes[j])\\n                d.pollLast() ;\\n            d.addLast(j) ;\\n            if (chargeTimes[d.getFirst()] + (j-i+1)*sum > budget) {\\n                if (d.getFirst() == i)\\n                    d.pollFirst() ;\\n                sum -= runningCosts[i++] ;\\n            }\\n        }\\n        \\n        return n-i ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2528218,
                "title": "javascript-clean-code-using-heap",
                "content": "As problem requires consecutive robots, we need to use sliding window for that problem. As we increase or decrease our subarray we need to keep the track of maximum time of repairing robots, for that we use priority queue, and in that we store the indexes of repairing times. Every time we increse the size of our window to one, we need to subtract the cost of repairing that robot, and also if the biggest repairing time is equal to the time of robot at that index, we need to dequeue(pop) that index from the priority queue.\\n\\n```\\nvar maximumRobots = function (chargeTimes, runningCosts, budget) {\\n  let sumCost = 0;\\n  let maxRobots = 0;\\n  let window_start = 0;\\n  const pq = new MaxPriorityQueue({\\n    compare: (a, b) => chargeTimes[b] - chargeTimes[a],\\n  });\\n  for (let i = 0; i < runningCosts.length; i++) {\\n    pq.enqueue(i);\\n    const runningCost = runningCosts[i];\\n    sumCost += runningCost;\\n    while (\\n      sumCost * (i - window_start + 1) + chargeTimes[pq.front()] > budget\\n    ) {\\n      sumCost -= runningCosts[window_start];\\n      while (pq.front() <= window_start) {\\n        pq.dequeue();\\n      }\\n      window_start++;\\n    }\\n    maxRobots = Math.max(i - window_start + 1, maxRobots);\\n  }\\n  return maxRobots;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nvar maximumRobots = function (chargeTimes, runningCosts, budget) {\\n  let sumCost = 0;\\n  let maxRobots = 0;\\n  let window_start = 0;\\n  const pq = new MaxPriorityQueue({\\n    compare: (a, b) => chargeTimes[b] - chargeTimes[a],\\n  });\\n  for (let i = 0; i < runningCosts.length; i++) {\\n    pq.enqueue(i);\\n    const runningCost = runningCosts[i];\\n    sumCost += runningCost;\\n    while (\\n      sumCost * (i - window_start + 1) + chargeTimes[pq.front()] > budget\\n    ) {\\n      sumCost -= runningCosts[window_start];\\n      while (pq.front() <= window_start) {\\n        pq.dequeue();\\n      }\\n      window_start++;\\n    }\\n    maxRobots = Math.max(i - window_start + 1, maxRobots);\\n  }\\n  return maxRobots;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2526645,
                "title": "scala-functional-sliding-window-solution",
                "content": "```\\n  import scala.collection.immutable.TreeSet\\n  import scala.util.chaining._\\n\\n  def maximumRobots(chargeTimes: Array[Int], runningCosts: Array[Int], budget: Long): Int =\\n    runningCosts.indices\\n      .foldLeft(-1, 0L, TreeSet.empty[(Int, Int)], 0) { case ((left, sum, window, prevMax), right) =>\\n        Iterator\\n          .iterate((left, sum + runningCosts(right), window + (chargeTimes(right) -> right))) {\\n            case (left, sum, window) =>\\n              val next = left + 1\\n              (next, sum - runningCosts(next), window - (chargeTimes(next) -> next))\\n          }\\n          .dropWhile { case (_, sum, window) =>\\n            window.maxOption.map(_._1).getOrElse(0) + (right - left) * sum > budget\\n          }\\n          .next()\\n          .pipe { case (left, sum, window) => (left, sum, window, prevMax.max(right - left)) }\\n      }\\n      ._4\\n```",
                "solutionTags": [],
                "code": "```\\n  import scala.collection.immutable.TreeSet\\n  import scala.util.chaining._\\n\\n  def maximumRobots(chargeTimes: Array[Int], runningCosts: Array[Int], budget: Long): Int =\\n    runningCosts.indices\\n      .foldLeft(-1, 0L, TreeSet.empty[(Int, Int)], 0) { case ((left, sum, window, prevMax), right) =>\\n        Iterator\\n          .iterate((left, sum + runningCosts(right), window + (chargeTimes(right) -> right))) {\\n            case (left, sum, window) =>\\n              val next = left + 1\\n              (next, sum - runningCosts(next), window - (chargeTimes(next) -> next))\\n          }\\n          .dropWhile { case (_, sum, window) =>\\n            window.maxOption.map(_._1).getOrElse(0) + (right - left) * sum > budget\\n          }\\n          .next()\\n          .pipe { case (left, sum, window) => (left, sum, window, prevMax.max(right - left)) }\\n      }\\n      ._4\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2526330,
                "title": "o-n-c-solution",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        ll n = chargeTimes.size();\\n        ll i = 0, j = 0;\\n        ll res = 0, sum = 0;\\n        deque<ll> dq;\\n        while(j < n) {\\n            while(!dq.empty() && chargeTimes[dq.back()] < chargeTimes[j]) {\\n                dq.pop_back();\\n            }\\n            dq.push_back(j);\\n            sum += runningCosts[j];\\n            while(i <= j && (j-i+1)*sum + chargeTimes[dq.front()] > budget) {\\n                sum -= runningCosts[i];\\n                if(dq.front() == i) dq.pop_front();\\n                i++;\\n            }\\n            res = max(res, j-i+1);\\n            j++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        ll n = chargeTimes.size();\\n        ll i = 0, j = 0;\\n        ll res = 0, sum = 0;\\n        deque<ll> dq;\\n        while(j < n) {\\n            while(!dq.empty() && chargeTimes[dq.back()] < chargeTimes[j]) {\\n                dq.pop_back();\\n            }\\n            dq.push_back(j);\\n            sum += runningCosts[j];\\n            while(i <= j && (j-i+1)*sum + chargeTimes[dq.front()] > budget) {\\n                sum -= runningCosts[i];\\n                if(dq.front() == i) dq.pop_front();\\n                i++;\\n            }\\n            res = max(res, j-i+1);\\n            j++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2526170,
                "title": "c-sliding-window-multiset-prefix-o-nlogn-time-o-n-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        int l = 0, r = 0, n = chargeTimes.size();\\n        long long sum = 0;\\n        multiset<long long> s;\\n        int mx = 0;\\n        while(r < n){\\n            sum += runningCosts[r];\\n            s.insert(chargeTimes[r]);\\n            while(l <= r && (*s.rbegin() + (r-l+1)*sum) > budget){\\n                s.erase(s.find(chargeTimes[l]));\\n                sum -= runningCosts[l];\\n                l++;\\n            }\\n            mx = max(mx, r-l+1);\\n            r++;\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        int l = 0, r = 0, n = chargeTimes.size();\\n        long long sum = 0;\\n        multiset<long long> s;\\n        int mx = 0;\\n        while(r < n){\\n            sum += runningCosts[r];\\n            s.insert(chargeTimes[r]);\\n            while(l <= r && (*s.rbegin() + (r-l+1)*sum) > budget){\\n                s.erase(s.find(chargeTimes[l]));\\n                sum -= runningCosts[l];\\n                l++;\\n            }\\n            mx = max(mx, r-l+1);\\n            r++;\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2526141,
                "title": "python3-intuition-explained-sliding-window-similar-problems-link",
                "content": "# Intution\\nGiven a formula  current budget  `max(chargeTimes) + k * sum(runningCosts)`  should be less than the target budget .\\nSo what we can do is keep on increasing our window length until and unless current budget exceeds target budget.\\nwhen this is the case we should **try shrinking our window length because we are allowed max of target budget.**\\nand each time when our window is valid we can `calculate the maximum consecutive robots that can be run.`\\n\\nOkay, that being said we know that for current budget calculation we need to keep track of two things one is `max_so_far` which is maximum value of chargeTimes in our window **and variable secondmax because if we try to shrink our window then if left out value was max_so_far then our current window max becomes secondmax else max_so_far does not change.**\\n\\nso we can go ahead and return `max_consecutive` that we are keeping track of during the iteration. \\n\\n# Similar Problems ( Same Template )\\n* https://leetcode.com/problems/longest-repeating-character-replacement/\\n* https://leetcode.com/problems/max-consecutive-ones-iii/\\n* https://leetcode.com/problems/maximize-the-confusion-of-an-exam/\\n* https://leetcode.com/problems/longest-repeating-character-replacement/\\n\\n*upvote if it was helpful*\\n\\n```\\nclass Solution:\\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\\n        \\n        n=len(chargeTimes)\\n        start=0\\n        runningsum=0\\n        max_consecutive=0\\n        max_so_far=0\\n        secondmax=0\\n        \\n        for end in range(n):\\n            runningsum+=runningCosts[end]\\n            \\n            if max_so_far<=chargeTimes[end]:\\n                secondmax=max_so_far\\n                max_so_far=chargeTimes[end]\\n                \\n            k=end-start+1\\n            \\n            currentbudget=max_so_far+(k*runningsum)\\n            \\n            if currentbudget>budget:\\n                runningsum-=runningCosts[start]\\n                max_so_far=secondmax if chargeTimes[start]==max_so_far else max_so_far\\n                start+=1\\n\\t\\t\\t\\t\\n            max_consecutive=max(max_consecutive,end-start+1)\\n\\t\\t\\t\\n        return max_consecutive\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "# Intution\\nGiven a formula  current budget  `max(chargeTimes) + k * sum(runningCosts)`  should be less than the target budget .\\nSo what we can do is keep on increasing our window length until and unless current budget exceeds target budget.\\nwhen this is the case we should **try shrinking our window length because we are allowed max of target budget.**\\nand each time when our window is valid we can `calculate the maximum consecutive robots that can be run.`\\n\\nOkay, that being said we know that for current budget calculation we need to keep track of two things one is `max_so_far` which is maximum value of chargeTimes in our window **and variable secondmax because if we try to shrink our window then if left out value was max_so_far then our current window max becomes secondmax else max_so_far does not change.**\\n\\nso we can go ahead and return `max_consecutive` that we are keeping track of during the iteration. \\n\\n# Similar Problems ( Same Template )\\n* https://leetcode.com/problems/longest-repeating-character-replacement/\\n* https://leetcode.com/problems/max-consecutive-ones-iii/\\n* https://leetcode.com/problems/maximize-the-confusion-of-an-exam/\\n* https://leetcode.com/problems/longest-repeating-character-replacement/\\n\\n*upvote if it was helpful*\\n\\n```\\nclass Solution:\\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\\n        \\n        n=len(chargeTimes)\\n        start=0\\n        runningsum=0\\n        max_consecutive=0\\n        max_so_far=0\\n        secondmax=0\\n        \\n        for end in range(n):\\n            runningsum+=runningCosts[end]\\n            \\n            if max_so_far<=chargeTimes[end]:\\n                secondmax=max_so_far\\n                max_so_far=chargeTimes[end]\\n                \\n            k=end-start+1\\n            \\n            currentbudget=max_so_far+(k*runningsum)\\n            \\n            if currentbudget>budget:\\n                runningsum-=runningCosts[start]\\n                max_so_far=secondmax if chargeTimes[start]==max_so_far else max_so_far\\n                start+=1\\n\\t\\t\\t\\t\\n            max_consecutive=max(max_consecutive,end-start+1)\\n\\t\\t\\t\\n        return max_consecutive\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 2526049,
                "title": "java-sliding-window-treemap-o-nlogn",
                "content": "```\\nclass Solution {\\n    public int maximumRobots(int[] ct, int[] rt, long budget) {\\n        \\n        int n = ct.length;\\n        TreeMap<Integer, Integer> map = new TreeMap<>(Comparator.comparingInt(x -> -x));\\n        long sum = 0;\\n        int ans = 0;\\n        int i = 0, j = 0;\\n        while (j < n) {\\n            sum += rt[j];\\n            put(map, ct[j]);\\n            \\n            long curr = map.firstKey() + (sum * (j - i + 1));\\n            while (curr > budget) {\\n                sum -= rt[i];\\n                remove(map, ct[i]);\\n                curr = (map.size() == 0 ? 0 : map.firstKey()) + (sum * (j - i + 1));\\n                i++;\\n            }\\n            \\n            ans = Math.max(ans, j - i + 1);\\n            j++;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private static void put(TreeMap<Integer, Integer> map, int k) {\\n        map.put(k, map.getOrDefault(k, 0) + 1);\\n    }\\n    \\n    private static void remove(TreeMap<Integer, Integer> map, int k) {\\n        map.put(k, map.get(k) - 1);\\n        if (map.get(k) == 0) map.remove(k);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumRobots(int[] ct, int[] rt, long budget) {\\n        \\n        int n = ct.length;\\n        TreeMap<Integer, Integer> map = new TreeMap<>(Comparator.comparingInt(x -> -x));\\n        long sum = 0;\\n        int ans = 0;\\n        int i = 0, j = 0;\\n        while (j < n) {\\n            sum += rt[j];\\n            put(map, ct[j]);\\n            \\n            long curr = map.firstKey() + (sum * (j - i + 1));\\n            while (curr > budget) {\\n                sum -= rt[i];\\n                remove(map, ct[i]);\\n                curr = (map.size() == 0 ? 0 : map.firstKey()) + (sum * (j - i + 1));\\n                i++;\\n            }\\n            \\n            ans = Math.max(ans, j - i + 1);\\n            j++;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private static void put(TreeMap<Integer, Integer> map, int k) {\\n        map.put(k, map.getOrDefault(k, 0) + 1);\\n    }\\n    \\n    private static void remove(TreeMap<Integer, Integer> map, int k) {\\n        map.put(k, map.get(k) - 1);\\n        if (map.get(k) == 0) map.remove(k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525897,
                "title": "maximum-number-of-robots-within-budget-using-priority-queue-t-c-0-n-a-s-0",
                "content": "```\\n\\nclass Solution { //Using Priority Queue\\n    public int maximumRobots(int[] ct, int[] rc, long budget) {// T.C: 0(N) A.S:0()\\n     PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        int n = rc.length;\\n        int res = Integer.MIN_VALUE;\\n        long cost = 0;\\n        for (int i = 0, j = 0; i < n; i++) {\\n            cost += rc[i];\\n            pq.add(ct[i]);\\n            while (!pq.isEmpty() && (pq.peek() + pq.size() * cost > budget)) {\\n                pq.remove(ct[j]);\\n                cost -= rc[j];\\n                j++;\\n            }\\n            res = Math.max(res, pq.size());\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution { //Using Priority Queue\\n    public int maximumRobots(int[] ct, int[] rc, long budget) {// T.C: 0(N) A.S:0()\\n     PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        int n = rc.length;\\n        int res = Integer.MIN_VALUE;\\n        long cost = 0;\\n        for (int i = 0, j = 0; i < n; i++) {\\n            cost += rc[i];\\n            pq.add(ct[i]);\\n            while (!pq.isEmpty() && (pq.peek() + pq.size() * cost > budget)) {\\n                pq.remove(ct[j]);\\n                cost -= rc[j];\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2525861,
                "title": "simple-sliding-window-priority-queue-to-maintain-the-max",
                "content": "This is based on the acquire and release strategy.\\nKeep on acquiring till the time the total cost does not exceed the total budget.\\nThen start to release until the total cost <= total budget since now we have a fair chance to increase the ans.\\n```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& c, vector<int>& r, long long budget) {\\n        int ans = 0;\\n        int fa = 0;\\n        int i = -1 , j = -1;\\n        long long ci = 0;\\n        long long maxe = INT_MIN;\\n        long long sum = 0;\\n        int size = c.size()-1;\\n        priority_queue<int> maxh; // for maintaining the max element all the time\\n        while(true)\\n        {\\n            int a1 = 0 , a2 = 0;\\n            while(i < size)\\n            {\\n                i++;\\n                a1 = 1;\\n                ans++;\\n                maxh.push(c[i]);\\n                sum = sum + r[i];\\n                ci = maxh.top() + ans*(sum);\\n                if(ci <= budget) // keep on acquiring until ci > budget\\n                {\\n                    fa = max(fa , ans);\\n                }\\n                else \\n                {\\n                    break;\\n                }\\n            }\\n            while(j < i)\\n            {\\n                j++;\\n                a2 = 1;\\n                if(maxh.top()==c[j]) maxh.pop(); // pop the max element while releasing if found\\n                sum = sum - r[j];\\n                ans--;\\n                ci = maxh.top() + ans*sum;\\n                if(ci <= budget) // when we are in a condition to expand our answer then break and start acquiring again\\n                {\\n                    break;\\n                }\\n                \\n            }\\n            if(a1==0 && a2==0) break;\\n        }\\n        return fa;\\n    }\\n};\\n```\\n\\nDo upvote if you like the solution",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& c, vector<int>& r, long long budget) {\\n        int ans = 0;\\n        int fa = 0;\\n        int i = -1 , j = -1;\\n        long long ci = 0;\\n        long long maxe = INT_MIN;\\n        long long sum = 0;\\n        int size = c.size()-1;\\n        priority_queue<int> maxh; // for maintaining the max element all the time\\n        while(true)\\n        {\\n            int a1 = 0 , a2 = 0;\\n            while(i < size)\\n            {\\n                i++;\\n                a1 = 1;\\n                ans++;\\n                maxh.push(c[i]);\\n                sum = sum + r[i];\\n                ci = maxh.top() + ans*(sum);\\n                if(ci <= budget) // keep on acquiring until ci > budget\\n                {\\n                    fa = max(fa , ans);\\n                }\\n                else \\n                {\\n                    break;\\n                }\\n            }\\n            while(j < i)\\n            {\\n                j++;\\n                a2 = 1;\\n                if(maxh.top()==c[j]) maxh.pop(); // pop the max element while releasing if found\\n                sum = sum - r[j];\\n                ans--;\\n                ci = maxh.top() + ans*sum;\\n                if(ci <= budget) // when we are in a condition to expand our answer then break and start acquiring again\\n                {\\n                    break;\\n                }\\n                \\n            }\\n            if(a1==0 && a2==0) break;\\n        }\\n        return fa;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525858,
                "title": "c-sliding-window-multiset-simple-solution",
                "content": "1) Use multiset to get maximum in the window, multiset can contain duplicate values and is sorted\\n2) Use sliding window to expand consecutive numbers whose totalCost is within the budget\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        \\n        int i,j,maxInWindow,ans,n=runningCosts.size();\\n        long long currentSum,totalCost;\\n        multiset<int>mst;\\n        i=0;j=0;currentSum=0;ans=0;\\n        \\n        while(i<n&&j<n){\\n            mst.insert(chargeTimes[j]);\\n            maxInWindow= *mst.rbegin();\\n            currentSum = currentSum +runningCosts[j];\\n            totalCost = maxInWindow + (j-i+1)*currentSum;\\n\\n            if(totalCost<=budget){ \\n                ans=max(ans,j-i+1);   \\n            }\\n            else{\\n                currentSum = currentSum - runningCosts[i];\\n                mst.erase(mst.find(chargeTimes[i]));\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        \\n        int i,j,maxInWindow,ans,n=runningCosts.size();\\n        long long currentSum,totalCost;\\n        multiset<int>mst;\\n        i=0;j=0;currentSum=0;ans=0;\\n        \\n        while(i<n&&j<n){\\n            mst.insert(chargeTimes[j]);\\n            maxInWindow= *mst.rbegin();\\n            currentSum = currentSum +runningCosts[j];\\n            totalCost = maxInWindow + (j-i+1)*currentSum;\\n\\n            if(totalCost<=budget){ \\n                ans=max(ans,j-i+1);   \\n            }\\n            else{\\n                currentSum = currentSum - runningCosts[i];\\n                mst.erase(mst.find(chargeTimes[i]));\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525720,
                "title": "deque-prefix-sum-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef long long int ll;\\n    unsigned long long int mod=1e9+7;\\n    int maximumRobots(vector<int>& c, vector<int>& r, long long b) {\\n        int n=r.size();\\n        vector<ll> pref(n+1,0);\\n        pref[1]=r[0];\\n        for(int i=2;i<=n;i++){\\n            pref[i]=pref[i-1]+r[i-1];\\n        }\\n        int m=0;\\n        deque<ll> dq;\\n        for(int i=0,j=0;j<n;j++){\\n            \\n            while(!dq.empty() && c[j]>=c[dq.back()]){\\n                dq.pop_back();\\n            }\\n            dq.push_back(j);\\n            int l=j-i+1;\\n            ll y=(ll)l*(pref[j+1]-pref[i]);\\n            long long x=c[dq.front()]+y;\\n            while(!dq.empty() && x>b){\\n                i++;    \\n                if(dq.front()<i){\\n                    dq.pop_front();\\n                }\\n                if(dq.empty())break;\\n                l=j-i+1;\\n                y=(ll)l*(pref[j+1]-pref[i]);\\n                x=c[dq.front()]+y;\\n            }\\n            l=j-i+1;\\n            m=max(m,l);\\n        }\\n        return m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long int ll;\\n    unsigned long long int mod=1e9+7;\\n    int maximumRobots(vector<int>& c, vector<int>& r, long long b) {\\n        int n=r.size();\\n        vector<ll> pref(n+1,0);\\n        pref[1]=r[0];\\n        for(int i=2;i<=n;i++){\\n            pref[i]=pref[i-1]+r[i-1];\\n        }\\n        int m=0;\\n        deque<ll> dq;\\n        for(int i=0,j=0;j<n;j++){\\n            \\n            while(!dq.empty() && c[j]>=c[dq.back()]){\\n                dq.pop_back();\\n            }\\n            dq.push_back(j);\\n            int l=j-i+1;\\n            ll y=(ll)l*(pref[j+1]-pref[i]);\\n            long long x=c[dq.front()]+y;\\n            while(!dq.empty() && x>b){\\n                i++;    \\n                if(dq.front()<i){\\n                    dq.pop_front();\\n                }\\n                if(dq.empty())break;\\n                l=j-i+1;\\n                y=(ll)l*(pref[j+1]-pref[i]);\\n                x=c[dq.front()]+y;\\n            }\\n            l=j-i+1;\\n            m=max(m,l);\\n        }\\n        return m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525385,
                "title": "c-sliding-window-binary-search",
                "content": "Prerequisite question:([Sliding Window Maximum)](https://leetcode.com/problems/sliding-window-maximum/)\\nRest is very easy just apply Binary Search \\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& chargeTimes, vector<int>& runningCosts,int m, long long k){\\n        list<long long>l;\\n        int i=0;\\n        int j=0;\\n        long long n=chargeTimes.size();\\n        long long sum=0;\\n        while(j<n){\\n            \\n            while(!l.empty() && l.back()<chargeTimes[j]){\\n                l.pop_back();\\n            }\\n            l.push_back(chargeTimes[j]);\\n            sum+=runningCosts[j];\\n            if(j-i+1==m){\\n                long long b=l.front()+m*sum;\\n                if(b<=k){\\n                    return true;\\n                }\\n                sum-=runningCosts[i];\\n                if(l.front()==chargeTimes[i]){\\n                    l.pop_front();\\n                }\\n                i++;\\n                \\n            }\\n            j++;\\n          \\n        }\\n          return false;\\n    }\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long k) {\\n        int s=1;\\n        int e=chargeTimes.size();\\n        int ans=0;\\n        while(s<=e){\\n            int m=s+(e-s)/2;\\n            if(check(chargeTimes,runningCosts,m,k)){\\n                ans=m;\\n                s=m+1;\\n            }\\n            else{\\n                e=m-1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\nfeel free to ask.\\nHappy Coding:)",
                "solutionTags": [
                    "Sliding Window",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& chargeTimes, vector<int>& runningCosts,int m, long long k){\\n        list<long long>l;\\n        int i=0;\\n        int j=0;\\n        long long n=chargeTimes.size();\\n        long long sum=0;\\n        while(j<n){\\n            \\n            while(!l.empty() && l.back()<chargeTimes[j]){\\n                l.pop_back();\\n            }\\n            l.push_back(chargeTimes[j]);\\n            sum+=runningCosts[j];\\n            if(j-i+1==m){\\n                long long b=l.front()+m*sum;\\n                if(b<=k){\\n                    return true;\\n                }\\n                sum-=runningCosts[i];\\n                if(l.front()==chargeTimes[i]){\\n                    l.pop_front();\\n                }\\n                i++;\\n                \\n            }\\n            j++;\\n          \\n        }\\n          return false;\\n    }\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long k) {\\n        int s=1;\\n        int e=chargeTimes.size();\\n        int ans=0;\\n        while(s<=e){\\n            int m=s+(e-s)/2;\\n            if(check(chargeTimes,runningCosts,m,k)){\\n                ans=m;\\n                s=m+1;\\n            }\\n            else{\\n                e=m-1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525272,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n        \\n        TreeMap<Long,Integer> tm=new TreeMap<>();\\n        int n=chargeTimes.length;\\n        int i=0,j=0;\\n        int maxLen=0;\\n        long sum=0;\\n        while(j<n)\\n        {   sum+=runningCosts[j];\\n            update(tm,(long)chargeTimes[j],1);\\n            \\n            if(tm.floorKey((long)1000000)+(j-i+1)*sum<=budget)\\n            {\\n                maxLen=Math.max(maxLen,j-i+1);\\n            }\\n            else\\n            {\\n             while(i<j)\\n             {  \\n                 sum-=runningCosts[i];\\n                 update(tm,(long)chargeTimes[i],-1);\\n                 \\n                  if(tm.floorKey((long)1000000)+(j-i)*sum<=budget)\\n                 {\\n                    maxLen=Math.max(maxLen,j-i);\\n                      i++;\\n                     break; \\n                 }\\n                 i++;\\n             }\\n              }\\n          j++;  \\n            \\n        }\\n        \\n        return maxLen;\\n        \\n        \\n    }\\n    \\n    public void update(TreeMap<Long,Integer> tm,Long val,int flag)\\n    {\\n        if(flag==1)\\n        {\\n            if(!tm.containsKey(val))\\n                tm.put(val,1);\\n            else\\n                tm.put(val,tm.get(val)+1);\\n        }\\n        else\\n        {  \\n            tm.put(val,tm.get(val)-1);\\n            if(tm.get(val)==0)\\n                tm.remove(val);\\n            \\n        }\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n        \\n        TreeMap<Long,Integer> tm=new TreeMap<>();\\n        int n=chargeTimes.length;\\n        int i=0,j=0;\\n        int maxLen=0;\\n        long sum=0;\\n        while(j<n)\\n        {   sum+=runningCosts[j];\\n            update(tm,(long)chargeTimes[j],1);\\n            \\n            if(tm.floorKey((long)1000000)+(j-i+1)*sum<=budget)\\n            {\\n                maxLen=Math.max(maxLen,j-i+1);\\n            }\\n            else\\n            {\\n             while(i<j)\\n             {  \\n                 sum-=runningCosts[i];\\n                 update(tm,(long)chargeTimes[i],-1);\\n                 \\n                  if(tm.floorKey((long)1000000)+(j-i)*sum<=budget)\\n                 {\\n                    maxLen=Math.max(maxLen,j-i);\\n                      i++;\\n                     break; \\n                 }\\n                 i++;\\n             }\\n              }\\n          j++;  \\n            \\n        }\\n        \\n        return maxLen;\\n        \\n        \\n    }\\n    \\n    public void update(TreeMap<Long,Integer> tm,Long val,int flag)\\n    {\\n        if(flag==1)\\n        {\\n            if(!tm.containsKey(val))\\n                tm.put(val,1);\\n            else\\n                tm.put(val,tm.get(val)+1);\\n        }\\n        else\\n        {  \\n            tm.put(val,tm.get(val)-1);\\n            if(tm.get(val)==0)\\n                tm.remove(val);\\n            \\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525261,
                "title": "java-slide-window-easy-to-understand",
                "content": "```\\n\\n    //Runtime: 24 ms, faster than 100.00% of Java online submissions for Maximum Number of Robots Within Budget.\\n    //Memory Usage: 51.5 MB, less than 75.00% of Java online submissions for Maximum Number of Robots Within Budget.\\n    //Slide window + Deque\\n    //Time: O(N); Space: O(N)\\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n        int left = 0, right = 0;\\n        long sum = 0;\\n\\n        Deque<Integer> deque = new ArrayDeque<>();\\n        while (right < runningCosts.length) {\\n            while(!deque.isEmpty() && deque.peekLast() < chargeTimes[right])\\n                deque.pollLast();\\n            deque.addLast(chargeTimes[right]);\\n            sum += runningCosts[right];\\n            right++;\\n\\n            //\"if\" keep the max length\\n            if (!deque.isEmpty() && ((right - left) * sum  > (budget - deque.peekFirst())) ){\\n                sum -= runningCosts[left];\\n                if (deque.peekFirst() == chargeTimes[left]) deque.pollFirst();\\n                left++;\\n            }\\n        }\\n        return runningCosts.length - left;\\n    }\\n    \\n    //Runtime: 237 ms, faster than 75.00% of Java online submissions for Maximum Number of Robots Within Budget.\\n    //Memory Usage: 121.7 MB, less than 25.00% of Java online submissions for Maximum Number of Robots Within Budget.\\n    //Slide window + TreeMap\\n    //Time: O(N*logN); Space: O(N)\\n    public int maximumRobots_treemap(int[] chargeTimes, int[] runningCosts, long budget) {\\n        int left = 0, right = 0;\\n        long sum = 0;\\n\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        while (right < chargeTimes.length) {\\n            map.put(chargeTimes[right], map.getOrDefault(chargeTimes[right],0) + 1);\\n            sum += runningCosts[right];\\n            right++;\\n\\n            if (left < right && (right - left) * sum > budget - map.lastKey()){\\n                sum -= runningCosts[left];\\n                if (map.get(chargeTimes[left]) == 1)\\n                    map.remove(chargeTimes[left]);\\n                else\\n                    map.put(chargeTimes[left], map.get(chargeTimes[left]) - 1);\\n                left++;\\n            }\\n        }\\n        return runningCosts.length - left;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Queue"
                ],
                "code": "```\\n\\n    //Runtime: 24 ms, faster than 100.00% of Java online submissions for Maximum Number of Robots Within Budget.\\n    //Memory Usage: 51.5 MB, less than 75.00% of Java online submissions for Maximum Number of Robots Within Budget.\\n    //Slide window + Deque\\n    //Time: O(N); Space: O(N)\\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n        int left = 0, right = 0;\\n        long sum = 0;\\n\\n        Deque<Integer> deque = new ArrayDeque<>();\\n        while (right < runningCosts.length) {\\n            while(!deque.isEmpty() && deque.peekLast() < chargeTimes[right])\\n                deque.pollLast();\\n            deque.addLast(chargeTimes[right]);\\n            sum += runningCosts[right];\\n            right++;\\n\\n            //\"if\" keep the max length\\n            if (!deque.isEmpty() && ((right - left) * sum  > (budget - deque.peekFirst())) ){\\n                sum -= runningCosts[left];\\n                if (deque.peekFirst() == chargeTimes[left]) deque.pollFirst();\\n                left++;\\n            }\\n        }\\n        return runningCosts.length - left;\\n    }\\n    \\n    //Runtime: 237 ms, faster than 75.00% of Java online submissions for Maximum Number of Robots Within Budget.\\n    //Memory Usage: 121.7 MB, less than 25.00% of Java online submissions for Maximum Number of Robots Within Budget.\\n    //Slide window + TreeMap\\n    //Time: O(N*logN); Space: O(N)\\n    public int maximumRobots_treemap(int[] chargeTimes, int[] runningCosts, long budget) {\\n        int left = 0, right = 0;\\n        long sum = 0;\\n\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        while (right < chargeTimes.length) {\\n            map.put(chargeTimes[right], map.getOrDefault(chargeTimes[right],0) + 1);\\n            sum += runningCosts[right];\\n            right++;\\n\\n            if (left < right && (right - left) * sum > budget - map.lastKey()){\\n                sum -= runningCosts[left];\\n                if (map.get(chargeTimes[left]) == 1)\\n                    map.remove(chargeTimes[left]);\\n                else\\n                    map.put(chargeTimes[left], map.get(chargeTimes[left]) - 1);\\n                left++;\\n            }\\n        }\\n        return runningCosts.length - left;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2525215,
                "title": "c-easy-solution",
                "content": "Here deque is used to find the max value in each window.\\n```\\nclass Solution {\\n    #define ll long long int\\n    bool solve(vector<int>& a, vector<int>& b, ll c, ll k) {\\n        int n = a.size();\\n        deque<int> q;\\n        ll sum = 0;\\n        for(int i = 0; i < k; ++i) {\\n            while(!q.empty() && a[i] >= a[q.back()]) {\\n                q.pop_back();\\n            }\\n            sum += b[i];\\n            q.push_back(i);\\n        }\\n        // cout << k << \" \" << q.front() << \" \";\\n        ll ans = 0;\\n        ans = (k * sum) + a[q.front()];\\n        for(int i = k; i < n; i++){\\n            while(!q.empty() && q.front() <= i - k) {\\n                q.pop_front();\\n            }\\n            while(!q.empty() && a[i] >= a[q.back()]) {\\n                q.pop_back();\\n            }\\n            q.push_back(i);\\n            sum -= b[i - k];\\n            sum += b[i];\\n            ans = min(ans, a[q.front()] + (k * sum));\\n        }\\n        return (ans <= c);\\n    }\\npublic:\\n    int maximumRobots(vector<int>& a, vector<int>& b, long long c) {\\n        int n = a.size();\\n        int l = 1, r = n;\\n        int ans = 0;\\n        while(l <= r) {\\n            int mid = (l + r) / 2;\\n            if(solve(a, b, c, mid)) {\\n                ans = mid;\\n                l = mid + 1;\\n            }else r = mid - 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    #define ll long long int\\n    bool solve(vector<int>& a, vector<int>& b, ll c, ll k) {\\n        int n = a.size();\\n        deque<int> q;\\n        ll sum = 0;\\n        for(int i = 0; i < k; ++i) {\\n            while(!q.empty() && a[i] >= a[q.back()]) {\\n                q.pop_back();\\n            }\\n            sum += b[i];\\n            q.push_back(i);\\n        }\\n        // cout << k << \" \" << q.front() << \" \";\\n        ll ans = 0;\\n        ans = (k * sum) + a[q.front()];\\n        for(int i = k; i < n; i++){\\n            while(!q.empty() && q.front() <= i - k) {\\n                q.pop_front();\\n            }\\n            while(!q.empty() && a[i] >= a[q.back()]) {\\n                q.pop_back();\\n            }\\n            q.push_back(i);\\n            sum -= b[i - k];\\n            sum += b[i];\\n            ans = min(ans, a[q.front()] + (k * sum));\\n        }\\n        return (ans <= c);\\n    }\\npublic:\\n    int maximumRobots(vector<int>& a, vector<int>& b, long long c) {\\n        int n = a.size();\\n        int l = 1, r = n;\\n        int ans = 0;\\n        while(l <= r) {\\n            int mid = (l + r) / 2;\\n            if(solve(a, b, c, mid)) {\\n                ans = mid;\\n                l = mid + 1;\\n            }else r = mid - 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2525144,
                "title": "sliding-window-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& charge, vector<int>& run, long long budget) {\\n        long long cur=0,ans=0,n=run.size(),st=0;\\n        multiset<long long> mt;\\n        for(int i=0 ; i<n ; i++){\\n            mt.insert(charge[i]);\\n            cur+=run[i];\\n            auto it=mt.end();it--;\\n            while(*it+(i-st+1)*cur>budget){\\n                mt.erase(mt.lower_bound(charge[st]));\\n                cur-=run[st++];\\n                if(st>i)break;\\n                it=mt.end();it--;\\n            }\\n            ans=max(ans,i-st+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& charge, vector<int>& run, long long budget) {\\n        long long cur=0,ans=0,n=run.size(),st=0;\\n        multiset<long long> mt;\\n        for(int i=0 ; i<n ; i++){\\n            mt.insert(charge[i]);\\n            cur+=run[i];\\n            auto it=mt.end();it--;\\n            while(*it+(i-st+1)*cur>budget){\\n                mt.erase(mt.lower_bound(charge[st]));\\n                cur-=run[st++];\\n                if(st>i)break;\\n                it=mt.end();it--;\\n            }\\n            ans=max(ans,i-st+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525129,
                "title": "sparse-table-binary-search-c",
                "content": "```\\nclass SparseTable {\\nprivate:\\n    vector<vector<int>> table;\\n\\npublic:\\n    void build(vector<int>& arr)\\n    {\\n        int n = arr.size();\\n        table = vector<vector<int>> (n + 1, vector<int> (__lg(n) + 1));\\n        for (int i = 0; i < n; i++)\\n            table[i][0] = arr[i];\\n\\n        for (int j = 1; (1 << j) <= n; j++)\\n            for (int i = 0; i + (1 << j) <= n; i++)\\n                table[i][j] = max(table[i][j - 1], table[i + (1 << (j - 1))][j - 1]);\\n    }\\n\\n    int query(int st, int en)\\n    {\\n        int j = __lg(en - st + 1);\\n        return max(table[st][j], table[en - (1 << j) + 1][j]);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    SparseTable spt;\\n\\n    bool good(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget, int k) {\\n        long long sum = 0;\\n        for (int i = 0; i < k; i++)\\n            sum += runningCosts[i];\\n        long long mn = sum * k + spt.query(0, k - 1);\\n        for (int i = k; i < chargeTimes.size(); i++)\\n        {\\n            sum -= runningCosts[i - k];\\n            sum += runningCosts[i];\\n            mn = min(mn, sum * k + spt.query(i - k + 1, i));\\n        }\\n        return mn <= budget;\\n    }\\n\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        spt.build(chargeTimes);\\n        int n = chargeTimes.size();\\n        int l = 0, r = n, mid;\\n        while (l < r)\\n        {\\n            mid = l + (r - l + 1) / 2;\\n            good(chargeTimes, runningCosts, budget, mid) ? l = mid : r = mid - 1;\\n        }\\n        return l;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    SparseTable spt;\\n\\n    bool good(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget, int k) {\\n        long long sum = 0;\\n        for (int i = 0; i < k; i++)\\n            sum += runningCosts[i];\\n        long long mn = sum * k + spt.query(0, k - 1);\\n        for (int i = k; i < chargeTimes.size(); i++)\\n        {\\n            sum -= runningCosts[i - k];\\n            sum += runningCosts[i];\\n            mn = min(mn, sum * k + spt.query(i - k + 1, i));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2525123,
                "title": "java-same-as-sliding-window-maximum",
                "content": "**Code is almost same as of the question Sliding Window Maximum [Question No - 239]**\\n```\\nclass Solution {\\n    public int maximumRobots(int[] charge, int[] running, long budget) {\\n        \\n        Deque<Integer> dq = new ArrayDeque<>();\\n        int i=0, j= 0, ans = 0;\\n        long cost = 0;\\n        while(j < running.length) {\\n            \\n            while(dq.size() > 0 && dq.peekLast() < charge[j]) {\\n                dq.pollLast();\\n            }\\n            dq.addLast(charge[j]);\\n            cost += running[j];\\n            \\n            if(dq.peekFirst() + ((j-i+1) * cost) <= budget) {\\n                ans = Math.max(ans, j-i+1);\\n                j++;\\n            }\\n\\t\\t\\t\\n            else if(dq.peekFirst() + ((j-i+1) * cost) > budget) {\\n                    if(dq.peekFirst() == charge[i]) dq.pollFirst(); \\n                    cost -= running[i];\\n                    j++; i++;   \\n            } \\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumRobots(int[] charge, int[] running, long budget) {\\n        \\n        Deque<Integer> dq = new ArrayDeque<>();\\n        int i=0, j= 0, ans = 0;\\n        long cost = 0;\\n        while(j < running.length) {\\n            \\n            while(dq.size() > 0 && dq.peekLast() < charge[j]) {\\n                dq.pollLast();\\n            }\\n            dq.addLast(charge[j]);\\n            cost += running[j];\\n            \\n            if(dq.peekFirst() + ((j-i+1) * cost) <= budget) {\\n                ans = Math.max(ans, j-i+1);\\n                j++;\\n            }\\n\\t\\t\\t\\n            else if(dq.peekFirst() + ((j-i+1) * cost) > budget) {\\n                    if(dq.peekFirst() == charge[i]) dq.pollFirst(); \\n                    cost -= running[i];\\n                    j++; i++;   \\n            } \\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525113,
                "title": "c-sliding-window-priority-queue-clean-code",
                "content": "#define ll long long \\nclass Solution {\\npublic:\\n    \\n    \\n    \\n    int maximumRobots(vector<int>& ct, vector<int>& rc, long long budget) {\\n        int res=0;\\n        ll sum=0;\\n        int n=ct.size();\\n        int i=0,j=0;\\n        priority_queue<pair<int,int>> pq;\\n        \\n        while(j<n){\\n            sum+=rc[j];\\n            pq.push({ct[j],j});\\n            \\n            while(!pq.empty()&&pq.top().second<i)pq.pop();\\n            if (pq.size()==0){\\n                i++;j++;continue;\\n            }\\n            int mx=pq.top().first;\\n            \\n            ll ans=mx+(j-i+1)*sum;\\n            \\n            if (ans<=budget){\\n                res=max(res,j-i+1);\\n                j++;\\n            }\\n            \\n            else{\\n                while(ans>budget){\\n                    sum-=rc[i];\\n                    while(!pq.empty()&&pq.top().second<=i)pq.pop();\\n                    if (pq.size()==0){\\n                        i++;break;\\n                    }\\n                    mx=pq.top().first;\\n                    ans=mx+(j-i+1)*sum;\\n                    i++;\\n                }\\n                j++;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    \\n    \\n    int maximumRobots(vector<int>& ct, vector<int>& rc, long long budget) {\\n        int res=0;\\n        ll sum=0;\\n        int n=ct.size();\\n        int i=0,j=0;\\n        priority_queue<pair<int,int>> pq;\\n        \\n        while(j<n){\\n            sum+=rc[j];\\n            pq.push({ct[j],j}",
                "codeTag": "Java"
            },
            {
                "id": 2525049,
                "title": "sliding-window-c",
                "content": "The idea is to keep adding the elements in the current subarray, hence moving the fast pointer to the left  until the current value exceeds the budget. Once it does so, we have to shift the slow pointer to the left such that the value falls below the budget. For tracking the maximum element in the subarray, one can just use a max heap.\\n\\n```\\n    int maximumRobots(vector<int>& cT, vector<int>& rC, long long b) {\\n        int i = 0, j = 0;\\n        long long sum = 0;\\n        int ans = 0;\\n        priority_queue<pair<long long,int>> pq;\\n        while(j<cT.size()){\\n            pq.push({cT[j], j});\\n            sum += rC[j];\\n            while(!pq.empty()&&(sum*((long long)(j-i+1)) + pq.top().first>b)){\\n                sum = sum - rC[i];\\n                i++;\\n                while(!pq.empty()&&pq.top().second<i)pq.pop();\\n            }\\n            if(!pq.empty())\\n            ans = max(ans, j-i+1);\\n            j++;\\n        }\\n        return ans;\\n    }\\n```\\n\\nTime Complexity: O(nlog(n))",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\n    int maximumRobots(vector<int>& cT, vector<int>& rC, long long b) {\\n        int i = 0, j = 0;\\n        long long sum = 0;\\n        int ans = 0;\\n        priority_queue<pair<long long,int>> pq;\\n        while(j<cT.size()){\\n            pq.push({cT[j], j});\\n            sum += rC[j];\\n            while(!pq.empty()&&(sum*((long long)(j-i+1)) + pq.top().first>b)){\\n                sum = sum - rC[i];\\n                i++;\\n                while(!pq.empty()&&pq.top().second<i)pq.pop();\\n            }\\n            if(!pq.empty())\\n            ans = max(ans, j-i+1);\\n            j++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2524984,
                "title": "java-sliding-window-priorityqueue-prefix-sum",
                "content": "```\\nclass Solution {\\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n        int l = -1;\\n        int r = 0;\\n        \\n        int n = chargeTimes.length;\\n        PriorityQueue<Integer> queue = new PriorityQueue<Integer>((a, b) -> (b - a));\\n        long sum = 0L;\\n        \\n        int res = 0;\\n        while (r < n) {\\n            queue.offer(chargeTimes[r]);\\n            sum += runningCosts[r];\\n            long tmp = queue.peek() + (r - l) * sum;\\n            while (l <= r && !queue.isEmpty() && tmp > budget) {\\n                l++;\\n                sum -= runningCosts[l];\\n                queue.remove(chargeTimes[l]);\\n                \\n                if (l <= r && !queue.isEmpty()) {\\n                    tmp = queue.peek() + (r - l) * sum;\\n                }\\n            }\\n            \\n            res = Math.max(res, r - l);\\n            r++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n        int l = -1;\\n        int r = 0;\\n        \\n        int n = chargeTimes.length;\\n        PriorityQueue<Integer> queue = new PriorityQueue<Integer>((a, b) -> (b - a));\\n        long sum = 0L;\\n        \\n        int res = 0;\\n        while (r < n) {\\n            queue.offer(chargeTimes[r]);\\n            sum += runningCosts[r];\\n            long tmp = queue.peek() + (r - l) * sum;\\n            while (l <= r && !queue.isEmpty() && tmp > budget) {\\n                l++;\\n                sum -= runningCosts[l];\\n                queue.remove(chargeTimes[l]);\\n                \\n                if (l <= r && !queue.isEmpty()) {\\n                    tmp = queue.peek() + (r - l) * sum;\\n                }\\n            }\\n            \\n            res = Math.max(res, r - l);\\n            r++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524966,
                "title": "sliding-window-multiset-explained",
                "content": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        multiset<ll,greater<ll>> st;\\n        \\n        ll j=0;\\n        ll sum = 0ll;\\n        \\n        ll len = 0,val = 0;\\n        \\n        for(int i=0;i<chargeTimes.size();i++)\\n        {\\n            sum += runningCosts[i];\\n            st.insert(chargeTimes[i]);\\n            \\n            while(i>=j and ((i-j+1)*sum + (*st.begin())) > budget)\\n            {\\n                sum -= runningCosts[j];\\n                st.erase(st.find(chargeTimes[j]));\\n                \\n                j++;\\n            }\\n            \\n            len = max(len,i-j+1);\\n        }\\n        \\n        return len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window",
                    "Heap (Priority Queue)",
                    "Prefix Sum"
                ],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        multiset<ll,greater<ll>> st;\\n        \\n        ll j=0;\\n        ll sum = 0ll;\\n        \\n        ll len = 0,val = 0;\\n        \\n        for(int i=0;i<chargeTimes.size();i++)\\n        {\\n            sum += runningCosts[i];\\n            st.insert(chargeTimes[i]);\\n            \\n            while(i>=j and ((i-j+1)*sum + (*st.begin())) > budget)\\n            {\\n                sum -= runningCosts[j];\\n                st.erase(st.find(chargeTimes[j]));\\n                \\n                j++;\\n            }\\n            \\n            len = max(len,i-j+1);\\n        }\\n        \\n        return len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524941,
                "title": "faster-than-100-o-n-sliding-window-python",
                "content": "```\\nclass Solution:\\n    def maximumRobots(self, c: List[int], a: List[int], b: int) -> int:\\n        n=len(c)\\n        \\n        ans=0\\n        s=0\\n        j=0\\n        \\n        d=deque([])\\n        \\n        for i in range(n):\\n            s+=a[i]\\n            while d and d[-1][0]<c[i]:\\n                d.pop()\\n            d.append((c[i],i))\\n            while d and (i-j+1)*s+d[0][0]>b:\\n                s-=a[j]\\n                j+=1\\n                if j>d[0][1]:\\n                    d.popleft()\\n            ans=max(ans,i-j+1)\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maximumRobots(self, c: List[int], a: List[int], b: int) -> int:\\n        n=len(c)\\n        \\n        ans=0\\n        s=0\\n        j=0\\n        \\n        d=deque([])\\n        \\n        for i in range(n):\\n            s+=a[i]\\n            while d and d[-1][0]<c[i]:\\n                d.pop()\\n            d.append((c[i],i))\\n            while d and (i-j+1)*s+d[0][0]>b:\\n                s-=a[j]\\n                j+=1\\n                if j>d[0][1]:\\n                    d.popleft()\\n            ans=max(ans,i-j+1)\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2524933,
                "title": "sliding-window-neat-and-clean-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& time, vector<int>& cost, long long budget) {\\n        \\n        \\n        int i=0,j=0;\\n        deque<int>q;\\n        long long csum = 0;\\n        int res=0;\\n        \\n        int n = time.size();\\n        long long totalCost;\\n        \\n        while(j<n)\\n        {\\n            // calcualtion \\n            csum+=cost[j];\\n            while(q.size()>0 and q.back()<time[j])\\n            {\\n                q.pop_back();\\n            }\\n            q.push_back(time[j]);\\n            \\n            \\n            // total cost calculate \\n            \\n            totalCost = q.front() + (j-i+1)*csum;\\n            \\n            if(totalCost<= budget)\\n            {\\n                res = max(res , j-i+1);\\n                j++;\\n            }\\n            else\\n            {\\n                // move the window \\n                while(totalCost>budget)\\n                {\\n                    if(q.front()==time[i])\\n                        q.pop_front();\\n                    csum-=cost[i];\\n                    i++;\\n                    \\n                    totalCost = q.front() + (j-i+1)*csum;  \\n                    \\n                }\\n                res = max(res , j-i+1);\\n                j++;\\n            }\\n            \\n            \\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& time, vector<int>& cost, long long budget) {\\n        \\n        \\n        int i=0,j=0;\\n        deque<int>q;\\n        long long csum = 0;\\n        int res=0;\\n        \\n        int n = time.size();\\n        long long totalCost;\\n        \\n        while(j<n)\\n        {\\n            // calcualtion \\n            csum+=cost[j];\\n            while(q.size()>0 and q.back()<time[j])\\n            {\\n                q.pop_back();\\n            }\\n            q.push_back(time[j]);\\n            \\n            \\n            // total cost calculate \\n            \\n            totalCost = q.front() + (j-i+1)*csum;\\n            \\n            if(totalCost<= budget)\\n            {\\n                res = max(res , j-i+1);\\n                j++;\\n            }\\n            else\\n            {\\n                // move the window \\n                while(totalCost>budget)\\n                {\\n                    if(q.front()==time[i])\\n                        q.pop_front();\\n                    csum-=cost[i];\\n                    i++;\\n                    \\n                    totalCost = q.front() + (j-i+1)*csum;  \\n                    \\n                }\\n                res = max(res , j-i+1);\\n                j++;\\n            }\\n            \\n            \\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524917,
                "title": "java-segment-tree-binary-search",
                "content": "```\\nclass Solution {\\n    \\n    SegmentTree maxTree;    // max segment tree\\n    long[] sum;             // prefix sum\\n    int n;\\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n        n = runningCosts.length;\\n        maxTree = new SegmentTree(chargeTimes);\\n        sum = new long[n+1];\\n        for (int i=0; i<n; i++) {\\n            sum[i+1] = sum[i]+runningCosts[i];\\n        }\\n        \\n        // binary search to find k\\n        int lo=1, hi=n, ans = 0;\\n        while (lo <= hi) {\\n            int mid = lo+ (hi-lo)/2;\\n            if (possible(mid, budget)) {\\n                ans = mid;\\n                lo = mid+1;\\n            } else {\\n                hi = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    private boolean possible(int k, long budget) {\\n        if (k == 0) return false;\\n        for (int i=0; i<=n-k; i++) {\\n            long cost = (maxTree.query(0, n-1, i, i+k-1,0) + k * (sum[i+k]-sum[i]));\\n            if (cost <= budget) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    \\n    \\n    \\n    \\n    static class SegmentTree {\\n        static Integer[] segTree;\\n        public SegmentTree (int[] input){\\n            int n=input.length;\\n            int size=(int)Math.ceil(Math.log(n)/Math.log(2));\\n            segTree=new Integer[pow(2,size+1)-1];\\n            buildSegmentTree(input, 0, n-1, 0);\\n        }\\n\\n        void buildSegmentTree(int[] input, int lo, int hi, int pos){\\n            if(lo==hi){\\n                segTree[pos]=input[lo];\\n                return;\\n            }\\n            int mid=lo+(hi-lo)/2;\\n            buildSegmentTree(input, lo, mid, 2*pos+1);\\n            buildSegmentTree(input, mid+1, hi, 2*pos+2);\\n            segTree[pos]=Math.max(segTree[2*pos+1], segTree[2*pos+2]);\\n        }\\n\\n        public int query(int lo, int hi, int qlo, int qhi, int pos){\\n            if(qlo>hi || qhi<lo) return Integer.MIN_VALUE;\\n            else if(qlo<=lo && qhi>=hi) return segTree[pos];\\n            int mid=lo+(hi-lo)/2;\\n            return Math.max(\\n                    query(lo, mid, qlo, qhi, 2*pos+1),\\n                    query(mid+1, hi, qlo, qhi, 2*pos+2)\\n                    );\\n        }\\n\\n        private static int pow(int a, int b){\\n            int result = 1, MOD=Integer.MAX_VALUE;\\n            while (b>0){\\n                if (b%2==1) result=(result*a)%MOD;\\n                b>>=1;\\n                a=(a*a)%MOD;\\n            }\\n            return result%MOD;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    SegmentTree maxTree;    // max segment tree\\n    long[] sum;             // prefix sum\\n    int n;\\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n        n = runningCosts.length;\\n        maxTree = new SegmentTree(chargeTimes);\\n        sum = new long[n+1];\\n        for (int i=0; i<n; i++) {\\n            sum[i+1] = sum[i]+runningCosts[i];\\n        }\\n        \\n        // binary search to find k\\n        int lo=1, hi=n, ans = 0;\\n        while (lo <= hi) {\\n            int mid = lo+ (hi-lo)/2;\\n            if (possible(mid, budget)) {\\n                ans = mid;\\n                lo = mid+1;\\n            } else {\\n                hi = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    private boolean possible(int k, long budget) {\\n        if (k == 0) return false;\\n        for (int i=0; i<=n-k; i++) {\\n            long cost = (maxTree.query(0, n-1, i, i+k-1,0) + k * (sum[i+k]-sum[i]));\\n            if (cost <= budget) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    \\n    \\n    \\n    \\n    static class SegmentTree {\\n        static Integer[] segTree;\\n        public SegmentTree (int[] input){\\n            int n=input.length;\\n            int size=(int)Math.ceil(Math.log(n)/Math.log(2));\\n            segTree=new Integer[pow(2,size+1)-1];\\n            buildSegmentTree(input, 0, n-1, 0);\\n        }\\n\\n        void buildSegmentTree(int[] input, int lo, int hi, int pos){\\n            if(lo==hi){\\n                segTree[pos]=input[lo];\\n                return;\\n            }\\n            int mid=lo+(hi-lo)/2;\\n            buildSegmentTree(input, lo, mid, 2*pos+1);\\n            buildSegmentTree(input, mid+1, hi, 2*pos+2);\\n            segTree[pos]=Math.max(segTree[2*pos+1], segTree[2*pos+2]);\\n        }\\n\\n        public int query(int lo, int hi, int qlo, int qhi, int pos){\\n            if(qlo>hi || qhi<lo) return Integer.MIN_VALUE;\\n            else if(qlo<=lo && qhi>=hi) return segTree[pos];\\n            int mid=lo+(hi-lo)/2;\\n            return Math.max(\\n                    query(lo, mid, qlo, qhi, 2*pos+1),\\n                    query(mid+1, hi, qlo, qhi, 2*pos+2)\\n                    );\\n        }\\n\\n        private static int pow(int a, int b){\\n            int result = 1, MOD=Integer.MAX_VALUE;\\n            while (b>0){\\n                if (b%2==1) result=(result*a)%MOD;\\n                b>>=1;\\n                a=(a*a)%MOD;\\n            }\\n            return result%MOD;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524903,
                "title": "java-easy-sliding-window-maximum",
                "content": "class Solution {\\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n        int n =  runningCosts.length;\\n        int ans = 0;\\n\\n        long cb = 0;\\n        long[] prefixSum = new long[n+1];\\n        prefixSum[0] = 0;\\n        for(int i=1;i<=n;i++){\\n            prefixSum[i] = prefixSum[i-1] + runningCosts[i-1];\\n        }\\n        \\n        int i = 0;\\n        int j = 1;\\n        \\n        Queue<Integer> que = new PriorityQueue<Integer>(new Comparator<Integer>(){\\n            @Override\\n            public int compare(Integer i1, Integer i2){\\n                return Integer.compare(i2, i1);\\n            }\\n        });\\n        \\n        \\n        while(j <= n){\\n            que.add(chargeTimes[j-1]);\\n            cb = que.peek()  + (j-i) * (prefixSum[j]-prefixSum[i]);\\n            if(cb <= budget){\\n                ans =  Math.max(j-i,ans);\\n            }\\n            if(cb > budget){\\n                que.remove(chargeTimes[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sliding Window",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n        int n =  runningCosts.length;\\n        int ans = 0;\\n\\n        long cb = 0;\\n        long[] prefixSum = new long[n+1];\\n        prefixSum[0] = 0;\\n        for(int i=1;i<=n;i++){\\n            prefixSum[i] = prefixSum[i-1] + runningCosts[i-1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2524869,
                "title": "o-n-log-n-set-map-c-prefix-sum",
                "content": "```\\n/*\\nApproach is to use a left/start pointer and we will consider subarray from [start,current_index \\'i\\'] , \\n\\ni. We will use prefix sum to find sum of runningcost in O(1)\\n\\nii. We will use set and map , set to get the max element in range in O(logn)\\n\\niii. We will use map to store the frequency of each element in subarray choosen,\\n    while moving the left/start pointer we will decrease the freqeuncy count of left/start element and remove from set\\n    if frequency becomes zero\\n\\nSo Time complexity :- O(n*log(n))\\n*/\\n\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& charge, vector<int>& run, long long budget) {\\n        int ans = 0;\\n        \\n        //we will use two pointer \\n        //we will find the cost and also the \\n        //let us have prefix array of sum of cost of subarray in range in O(1)\\n        \\n        int n = run.size();\\n        vector<long long>pref(n);\\n        long long tot = 0;\\n        \\n        for(int i=0;i<n;++i){\\n            tot+=run[i];\\n            pref[i] = tot;\\n        }\\n        \\n        set<int>P;\\n        map<int,int>count;\\n        //so we will use set to find the max element in O(log n)\\n        //we will use count to remove the elements\\n        \\n        tot = 0;\\n        int c = 0,start = 0;\\n        long long z;\\n        for(int i=0;i<n;++i){\\n           //I choose the current value \\n            //add in set and increment frequency of it\\n            P.insert(charge[i]);\\n            count[charge[i]]++;\\n            c++;\\n            \\n            //now find the current score\\n            tot = pref[i];\\n            if(start)tot-=pref[start-1];\\n            z = c;\\n            tot*=z;\\n            auto it = P.rbegin();\\n            long long val = *it;\\n            \\n            tot += val;\\n           \\n            \\n            //now if this score is within the budget then we store the max size of subarray in answer\\n            if(tot<=budget){\\n                ans = max(ans,c);\\n            }\\n            else{\\n                //now I need to move my left poitner until\\n                //the score is less than budget\\n                \\n                while(start<=i){\\n                    \\n                    if(count[charge[start]] == 1){\\n                        P.erase(charge[start]);\\n                    }\\n                    count[charge[start]]--;\\n                    start++;\\n                    c--;\\n                    \\n                    //this means our subarray is empty\\n                    if(start>i)break;\\n                    \\n                    auto it2 = P.rbegin();\\n                    val = *it2;\\n                    long long cur_score = 0;\\n                    cur_score += pref[i];\\n                    cur_score -= pref[start-1];\\n                    z = c;\\n                    cur_score*=c;\\n                    cur_score+=val;\\n                    \\n                    if(cur_score<=budget)break;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum",
                    "Ordered Set"
                ],
                "code": "```\\n/*\\nApproach is to use a left/start pointer and we will consider subarray from [start,current_index \\'i\\'] , \\n\\ni. We will use prefix sum to find sum of runningcost in O(1)\\n\\nii. We will use set and map , set to get the max element in range in O(logn)\\n\\niii. We will use map to store the frequency of each element in subarray choosen,\\n    while moving the left/start pointer we will decrease the freqeuncy count of left/start element and remove from set\\n    if frequency becomes zero\\n\\nSo Time complexity :- O(n*log(n))\\n*/\\n\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& charge, vector<int>& run, long long budget) {\\n        int ans = 0;\\n        \\n        //we will use two pointer \\n        //we will find the cost and also the \\n        //let us have prefix array of sum of cost of subarray in range in O(1)\\n        \\n        int n = run.size();\\n        vector<long long>pref(n);\\n        long long tot = 0;\\n        \\n        for(int i=0;i<n;++i){\\n            tot+=run[i];\\n            pref[i] = tot;\\n        }\\n        \\n        set<int>P;\\n        map<int,int>count;\\n        //so we will use set to find the max element in O(log n)\\n        //we will use count to remove the elements\\n        \\n        tot = 0;\\n        int c = 0,start = 0;\\n        long long z;\\n        for(int i=0;i<n;++i){\\n           //I choose the current value \\n            //add in set and increment frequency of it\\n            P.insert(charge[i]);\\n            count[charge[i]]++;\\n            c++;\\n            \\n            //now find the current score\\n            tot = pref[i];\\n            if(start)tot-=pref[start-1];\\n            z = c;\\n            tot*=z;\\n            auto it = P.rbegin();\\n            long long val = *it;\\n            \\n            tot += val;\\n           \\n            \\n            //now if this score is within the budget then we store the max size of subarray in answer\\n            if(tot<=budget){\\n                ans = max(ans,c);\\n            }\\n            else{\\n                //now I need to move my left poitner until\\n                //the score is less than budget\\n                \\n                while(start<=i){\\n                    \\n                    if(count[charge[start]] == 1){\\n                        P.erase(charge[start]);\\n                    }\\n                    count[charge[start]]--;\\n                    start++;\\n                    c--;\\n                    \\n                    //this means our subarray is empty\\n                    if(start>i)break;\\n                    \\n                    auto it2 = P.rbegin();\\n                    val = *it2;\\n                    long long cur_score = 0;\\n                    cur_score += pref[i];\\n                    cur_score -= pref[start-1];\\n                    z = c;\\n                    cur_score*=c;\\n                    cur_score+=val;\\n                    \\n                    if(cur_score<=budget)break;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524792,
                "title": "sliding-window",
                "content": "Use a Deque to store maximum of each window.\\nWindow will be of variable length depending upon max(chargeTimes) + windowLength * sum(runningCosts)\\n\\nSimilar: https://leetcode.com/problems/sliding-window-maximum/\\n\\n```\\npublic int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n\\t\\tDeque<Long> queue = new LinkedList<Long>();\\n\\t\\tint j = 0, i = 0, l = 0;\\n\\t\\tlong sum = 0;\\n\\t\\tint n = chargeTimes.length;\\n\\t\\tint maxWindow = 0;\\n//\\t\\tmax(chargeTimes) + k * sum(runningCosts)\\n\\t\\t\\n\\t\\twhile(j < n) {\\n\\t\\t\\tsum += runningCosts[j];\\n\\t\\t\\twhile(!queue.isEmpty() && queue.peekLast() < chargeTimes[j]) {\\n\\t\\t\\t\\t// queue should contain useful numbers only, i.e. max\\n\\t\\t\\t\\tqueue.pollLast();\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// since smaller numbers are popped from last, add new number\\n\\t\\t\\tqueue.offerLast((long)chargeTimes[j]);\\n\\t\\t\\t\\n\\t\\t\\t// window will slide when budget < queue.peekLast() + (j - i + 1) * sum\\n\\t\\t\\twhile(!queue.isEmpty() && budget < queue.peekFirst() + (j - i + 1) * sum) {\\n\\t\\t\\t\\tif(!queue.isEmpty() && queue.peekFirst() == chargeTimes[i])\\n\\t\\t\\t\\t\\t//since window is gonna slide, remove the outgoing element from queue\\n\\t\\t\\t\\t\\t// if it is the max of window\\n\\t\\t\\t\\t\\tqueue.removeFirst();\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// also substract from sum running cost of window start\\n\\t\\t\\t\\tsum -= runningCosts[i];\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\tmaxWindow = Math.max(maxWindow, j - i + 1);\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t\\treturn maxWindow;\\n\\t}",
                "solutionTags": [],
                "code": "Use a Deque to store maximum of each window.\\nWindow will be of variable length depending upon max(chargeTimes) + windowLength * sum(runningCosts)\\n\\nSimilar: https://leetcode.com/problems/sliding-window-maximum/\\n\\n```\\npublic int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n\\t\\tDeque<Long> queue = new LinkedList<Long>();\\n\\t\\tint j = 0, i = 0, l = 0;\\n\\t\\tlong sum = 0;\\n\\t\\tint n = chargeTimes.length;\\n\\t\\tint maxWindow = 0;\\n//\\t\\tmax(chargeTimes) + k * sum(runningCosts)\\n\\t\\t\\n\\t\\twhile(j < n) {\\n\\t\\t\\tsum += runningCosts[j];\\n\\t\\t\\twhile(!queue.isEmpty() && queue.peekLast() < chargeTimes[j]) {\\n\\t\\t\\t\\t// queue should contain useful numbers only, i.e. max\\n\\t\\t\\t\\tqueue.pollLast();\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// since smaller numbers are popped from last, add new number\\n\\t\\t\\tqueue.offerLast((long)chargeTimes[j]);\\n\\t\\t\\t\\n\\t\\t\\t// window will slide when budget < queue.peekLast() + (j - i + 1) * sum\\n\\t\\t\\twhile(!queue.isEmpty() && budget < queue.peekFirst() + (j - i + 1) * sum) {\\n\\t\\t\\t\\tif(!queue.isEmpty() && queue.peekFirst() == chargeTimes[i])\\n\\t\\t\\t\\t\\t//since window is gonna slide, remove the outgoing element from queue\\n\\t\\t\\t\\t\\t// if it is the max of window\\n\\t\\t\\t\\t\\tqueue.removeFirst();\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// also substract from sum running cost of window start\\n\\t\\t\\t\\tsum -= runningCosts[i];\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\tmaxWindow = Math.max(maxWindow, j - i + 1);\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t\\treturn maxWindow;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2524718,
                "title": "python3-binary-search",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/35b262c16bc702edbad6adc895bc8321a037ebaa) for solutions of biweekly 86. \\n\\n```\\nclass Solution:\\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\\n        \\n        def fn(k): \\n            \"\"\"Return min cost of running k consecutive robots.\"\"\"\\n            if k == 0: return 0\\n            ans = inf \\n            sm = 0 \\n            pq = []\\n            for i, (ct, rc) in enumerate(zip(chargeTimes, runningCosts)): \\n                sm += rc\\n                heappush(pq, (-ct, i))\\n                if i >= k: \\n                    sm -= runningCosts[i-k]\\n                    while pq[0][1] <= i-k: heappop(pq)\\n                if i >= k-1: ans = min(ans, -pq[0][0] + k*sm)\\n            return ans \\n        \\n        lo, hi = 0, len(chargeTimes)\\n        while lo < hi: \\n            mid = lo + hi + 1 >> 1\\n            if fn(mid) <= budget: lo = mid \\n            else: hi = mid - 1\\n        return lo \\n```\\n\\nPer @lee215, \\n```\\nclass Solution:\\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\\n        ii = rsm = 0\\n        qq = deque()\\n        for i, (ct, rc) in enumerate(zip(chargeTimes, runningCosts)): \\n            rsm += rc \\n            while qq and qq[-1][0] <= ct: qq.pop()\\n            qq.append((ct, i))\\n            if chargeTimes[qq[0][1]] + (i - ii + 1) * rsm > budget: \\n                if qq[0][1] == ii: qq.popleft()\\n                rsm -= runningCosts[ii]\\n                ii += 1\\n        return len(chargeTimes)-ii\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\\n        \\n        def fn(k): \\n            \"\"\"Return min cost of running k consecutive robots.\"\"\"\\n            if k == 0: return 0\\n            ans = inf \\n            sm = 0 \\n            pq = []\\n            for i, (ct, rc) in enumerate(zip(chargeTimes, runningCosts)): \\n                sm += rc\\n                heappush(pq, (-ct, i))\\n                if i >= k: \\n                    sm -= runningCosts[i-k]\\n                    while pq[0][1] <= i-k: heappop(pq)\\n                if i >= k-1: ans = min(ans, -pq[0][0] + k*sm)\\n            return ans \\n        \\n        lo, hi = 0, len(chargeTimes)\\n        while lo < hi: \\n            mid = lo + hi + 1 >> 1\\n            if fn(mid) <= budget: lo = mid \\n            else: hi = mid - 1\\n        return lo \\n```\n```\\nclass Solution:\\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\\n        ii = rsm = 0\\n        qq = deque()\\n        for i, (ct, rc) in enumerate(zip(chargeTimes, runningCosts)): \\n            rsm += rc \\n            while qq and qq[-1][0] <= ct: qq.pop()\\n            qq.append((ct, i))\\n            if chargeTimes[qq[0][1]] + (i - ii + 1) * rsm > budget: \\n                if qq[0][1] == ii: qq.popleft()\\n                rsm -= runningCosts[ii]\\n                ii += 1\\n        return len(chargeTimes)-ii\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524711,
                "title": "c-easy-sliding-window-deque",
                "content": "class Solution {\\npublic:\\n\\n    int maximumRobots(vector<int>& charge, vector<int>& run, long long budget) {\\n        int i=0,j=0;\\n        int n=charge.size();\\n        int ans=0;\\n        deque<int>q;\\n        long long sum=0;\\n        while(j<n)\\n        {\\n            while(!q.empty()&& q.back()<charge[j])\\n            {\\n                q.pop_back();\\n                \\n            }\\n            q.push_back(charge[j]);\\n            sum+=run[j];\\n            if(sum*(j-i+1) + q.front()<=budget)\\n            {\\n                ans=max(ans,j-i+1);\\n                j++;\\n                \\n            }\\n            else\\n            {\\n                sum-=run[i];\\n                if(q.front()==charge[i])\\n                {\\n                    q.pop_front();\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n**Upvote if it helped**",
                "solutionTags": [
                    "C",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int maximumRobots(vector<int>& charge, vector<int>& run, long long budget) {\\n        int i=0,j=0;\\n        int n=charge.size();\\n        int ans=0;\\n        deque<int>q;\\n        long long sum=0;\\n        while(j<n)\\n        {\\n            while(!q.empty()&& q.back()<charge[j])\\n            {\\n                q.pop_back();\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2524708,
                "title": "easy-sliding-window-cpp",
                "content": "```\\n\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        int n = chargeTimes.size();\\n        priority_queue<pair<int, int>>q;\\n        int i = 0, j = 0, ans = 0;\\n        long long res = 0, sum = 0;\\n        while(j<n){\\n            while(i<j && res >= budget){\\n                sum -= runningCosts[i++];\\n                while(!q.empty() && i > q.top().second)q.pop();\\n                if(q.empty()){\\n                    res = 0; break;\\n                }\\n                int k = j-i;\\n                res = q.top().first + k*sum;\\n                if(res <= budget)ans = max(ans, k);\\n            }\\n            while(j<n && res <= budget){\\n                if(res <= budget)ans = max(ans, j-i);\\n                q.push({chargeTimes[j], j});\\n                sum += runningCosts[j++];\\n                int k = j-i;\\n                res = q.top().first + k*sum;\\n                if(res <= budget)ans = max(ans, k);\\n            }\\n        }\\n        if(res <= budget)ans = max(ans, j-i);\\n        while(i<j && res >= budget){\\n                sum -= runningCosts[i++];\\n                while(!q.empty() && i > q.top().second)q.pop();\\n                if(q.empty()){\\n                    res = 0; break;\\n                }\\n                int k = j-i;\\n                res = q.top().first + k*sum;\\n                if(res <= budget)ans = max(ans, k);\\n            }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\n\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        int n = chargeTimes.size();\\n        priority_queue<pair<int, int>>q;\\n        int i = 0, j = 0, ans = 0;\\n        long long res = 0, sum = 0;\\n        while(j<n){\\n            while(i<j && res >= budget){\\n                sum -= runningCosts[i++];\\n                while(!q.empty() && i > q.top().second)q.pop();\\n                if(q.empty()){\\n                    res = 0; break;\\n                }\\n                int k = j-i;\\n                res = q.top().first + k*sum;\\n                if(res <= budget)ans = max(ans, k);\\n            }\\n            while(j<n && res <= budget){\\n                if(res <= budget)ans = max(ans, j-i);\\n                q.push({chargeTimes[j], j});\\n                sum += runningCosts[j++];\\n                int k = j-i;\\n                res = q.top().first + k*sum;\\n                if(res <= budget)ans = max(ans, k);\\n            }\\n        }\\n        if(res <= budget)ans = max(ans, j-i);\\n        while(i<j && res >= budget){\\n                sum -= runningCosts[i++];\\n                while(!q.empty() && i > q.top().second)q.pop();\\n                if(q.empty()){\\n                    res = 0; break;\\n                }\\n                int k = j-i;\\n                res = q.top().first + k*sum;\\n                if(res <= budget)ans = max(ans, k);\\n            }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2524707,
                "title": "very-simple-java-solution-using-treemap",
                "content": "```\\nclass Solution {\\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n        int n=runningCosts.length;\\n        TreeMap<Integer,Integer> map=new TreeMap<>();\\n        int maxSelect=0;\\n        long[] preSum=new long[n];\\n        preSum[0]=runningCosts[0];\\n        for(int i=1;i<n;i++){\\n            preSum[i]+=preSum[i-1]+runningCosts[i];\\n        }\\n        int prev=0;\\n        for(int curr=0;curr<n;curr++){\\n            long subSum=preSum[curr]-(prev-1>=0?preSum[prev-1]:0);\\n            map.put(chargeTimes[curr],map.getOrDefault(chargeTimes[curr],0)+1);\\n            while((prev<=curr) && ((map.lastKey()+(curr-prev+1)*subSum)>budget)){\\n                int prevCount=map.get(chargeTimes[prev]);\\n                int key=chargeTimes[prev];\\n                prevCount--;\\n                if(prevCount==0){\\n                    map.remove(key);\\n                }\\n                else{\\n                    map.put(key,prevCount);\\n                }\\n                subSum-=runningCosts[prev];\\n                prev++;\\n            }\\n            maxSelect=Math.max(maxSelect,curr-prev+1);\\n        }\\n        return maxSelect;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n        int n=runningCosts.length;\\n        TreeMap<Integer,Integer> map=new TreeMap<>();\\n        int maxSelect=0;\\n        long[] preSum=new long[n];\\n        preSum[0]=runningCosts[0];\\n        for(int i=1;i<n;i++){\\n            preSum[i]+=preSum[i-1]+runningCosts[i];\\n        }\\n        int prev=0;\\n        for(int curr=0;curr<n;curr++){\\n            long subSum=preSum[curr]-(prev-1>=0?preSum[prev-1]:0);\\n            map.put(chargeTimes[curr],map.getOrDefault(chargeTimes[curr],0)+1);\\n            while((prev<=curr) && ((map.lastKey()+(curr-prev+1)*subSum)>budget)){\\n                int prevCount=map.get(chargeTimes[prev]);\\n                int key=chargeTimes[prev];\\n                prevCount--;\\n                if(prevCount==0){\\n                    map.remove(key);\\n                }\\n                else{\\n                    map.put(key,prevCount);\\n                }\\n                subSum-=runningCosts[prev];\\n                prev++;\\n            }\\n            maxSelect=Math.max(maxSelect,curr-prev+1);\\n        }\\n        return maxSelect;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090518,
                "title": "python3-binary-search-on-answer",
                "content": "# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n# Code\\n```\\nclass Solution:\\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\\n        def maxSubarray(nums,k):\\n            q = deque()\\n            n = len(nums)\\n            ans = []\\n            for i in range(n):\\n                if q and q[0] == i - k:\\n                    q.popleft()\\n                while q and nums[q[-1]] < nums[i]:\\n                    q.pop()\\n                q.append(i)\\n                if i >= k - 1:\\n                    ans.append(nums[q[0]])\\n            return ans\\n\\n        def prefixSum(nums):\\n            n = len(nums)\\n            pref = list(nums)\\n            for i in range(1,n):\\n                pref[i] += pref[i-1]\\n            return pref\\n        \\n        def getSum(start,end):\\n            if start == 0 :\\n                return pref[end]\\n            return pref[end] - pref[start-1]\\n\\n        def check(k):\\n            maxs = maxSubarray(chargeTimes,k)\\n            # print(chargeTimes, k, len(maxs) == n-k+1)\\n            for i in range(n-k+1):\\n                if maxs[i] + k * getSum(i,i+k-1) <=  budget:\\n                    return True\\n            return False\\n\\n        \\n        pref = prefixSum(runningCosts)\\n        low = 1\\n        ans = 0\\n        n = len(chargeTimes)\\n        high = n \\n        while low <= high :\\n            mid = (low+high)//2\\n            if check(mid):\\n                ans = mid \\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n        return ans \\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\\n        def maxSubarray(nums,k):\\n            q = deque()\\n            n = len(nums)\\n            ans = []\\n            for i in range(n):\\n                if q and q[0] == i - k:\\n                    q.popleft()\\n                while q and nums[q[-1]] < nums[i]:\\n                    q.pop()\\n                q.append(i)\\n                if i >= k - 1:\\n                    ans.append(nums[q[0]])\\n            return ans\\n\\n        def prefixSum(nums):\\n            n = len(nums)\\n            pref = list(nums)\\n            for i in range(1,n):\\n                pref[i] += pref[i-1]\\n            return pref\\n        \\n        def getSum(start,end):\\n            if start == 0 :\\n                return pref[end]\\n            return pref[end] - pref[start-1]\\n\\n        def check(k):\\n            maxs = maxSubarray(chargeTimes,k)\\n            # print(chargeTimes, k, len(maxs) == n-k+1)\\n            for i in range(n-k+1):\\n                if maxs[i] + k * getSum(i,i+k-1) <=  budget:\\n                    return True\\n            return False\\n\\n        \\n        pref = prefixSum(runningCosts)\\n        low = 1\\n        ans = 0\\n        n = len(chargeTimes)\\n        high = n \\n        while low <= high :\\n            mid = (low+high)//2\\n            if check(mid):\\n                ans = mid \\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4089615,
                "title": "explained-step-by-step-binary-search-monotonic-deque-sliding-window-python3",
                "content": "This problem can basically be divided into a few different subproblems. The main one that people might struggle with if they\\'ve never seen it before is sliding window maximum, which uses a monotonic deque to keep track of the max number in the current window.\\n\\nWe use this sliding window maximum idea to keep track of the maximum in the \"chargeTimes window\" - Store indices in the queue rather than the actual values to make sure the max is in range of the window. While the current number added to the sliding window is greater than the number (contained at the stored index) at the right of the queue, pop from the queue. If the number at the left of the queue is out of range of the window (q[0] == i - k), pop from the left of the queue. The maximum number in your window is now always the number at the left of the queue.\\n\\nUse a normal sliding window to track the sum of the \"runningCosts window\" - each iteration, subtract the number at runningCosts[i - k] and add the number at runningCosts[i].\\n\\nAt the end of each window iteration, we can minimize the cost of the current number of consecutive robots being considered. If this number is less than the budget, return immediately.\\n\\nThe binary search is straight forward - binary search between 0 and N and run the sliding window function on each \"middle\".\\n\\nI believe the time complexity is O(n*logn) for binary search * sliding window, but I could be wrong.\\n\\nSpace complexity = O(n) when size = n\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\\n        def slide(size):\\n            if size == 0:\\n                return True\\n\\n            min_cost = float(\\'inf\\')\\n            curr_sum, curr_max = 0, 0\\n            q = deque()\\n\\n            for i in range(size):\\n                while q and chargeTimes[i] >= chargeTimes[q[-1]]:\\n                    q.pop()\\n                q.append(i)\\n\\n                curr_sum += runningCosts[i]\\n\\n            curr_max = max(curr_max, chargeTimes[q[0]])\\n            min_cost = min(min_cost, curr_max + (size * curr_sum))\\n\\n            for i in range(size, len(chargeTimes)):\\n                if i - size == q[0]:\\n                    q.popleft()\\n                \\n                while q and chargeTimes[i] >= chargeTimes[q[-1]]:\\n                    q.pop()\\n\\n                q.append(i)\\n\\n                curr_sum -= runningCosts[i - size]\\n                curr_sum += runningCosts[i]\\n                curr_max = chargeTimes[q[0]]\\n                min_cost = min(min_cost, curr_max + (size * curr_sum))\\n                if min_cost <= budget:\\n                    return True\\n\\n            return min_cost <= budget\\n\\n        left, right = 0, len(chargeTimes)\\n        while left <= right:\\n            mid = (left + right) // 2\\n            res = slide(mid)\\n            if res:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n\\n        return right\\n                    \\n                    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\\n        def slide(size):\\n            if size == 0:\\n                return True\\n\\n            min_cost = float(\\'inf\\')\\n            curr_sum, curr_max = 0, 0\\n            q = deque()\\n\\n            for i in range(size):\\n                while q and chargeTimes[i] >= chargeTimes[q[-1]]:\\n                    q.pop()\\n                q.append(i)\\n\\n                curr_sum += runningCosts[i]\\n\\n            curr_max = max(curr_max, chargeTimes[q[0]])\\n            min_cost = min(min_cost, curr_max + (size * curr_sum))\\n\\n            for i in range(size, len(chargeTimes)):\\n                if i - size == q[0]:\\n                    q.popleft()\\n                \\n                while q and chargeTimes[i] >= chargeTimes[q[-1]]:\\n                    q.pop()\\n\\n                q.append(i)\\n\\n                curr_sum -= runningCosts[i - size]\\n                curr_sum += runningCosts[i]\\n                curr_max = chargeTimes[q[0]]\\n                min_cost = min(min_cost, curr_max + (size * curr_sum))\\n                if min_cost <= budget:\\n                    return True\\n\\n            return min_cost <= budget\\n\\n        left, right = 0, len(chargeTimes)\\n        while left <= right:\\n            mid = (left + right) // 2\\n            res = slide(mid)\\n            if res:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n\\n        return right\\n                    \\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4052870,
                "title": "c-solution-using-multiset-with-t-c-o-n-log-n-and-s-c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        int n = chargeTimes.size(),i = 0, j = 0,mxLen = 0;\\n        long long sum = 0;\\n        multiset<int> mst;\\n        while(j < n){\\n            sum += runningCosts[j];\\n            mst.insert(chargeTimes[j]);\\n            while(i <= j && (*mst.rbegin() + (j-i+1) * sum) > budget){\\n                sum -= runningCosts[i];\\n                mst.erase(mst.find(chargeTimes[i++]));\\n            }\\n            mxLen = max(mxLen,j++ -i+1);\\n        }\\n        return mxLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        int n = chargeTimes.size(),i = 0, j = 0,mxLen = 0;\\n        long long sum = 0;\\n        multiset<int> mst;\\n        while(j < n){\\n            sum += runningCosts[j];\\n            mst.insert(chargeTimes[j]);\\n            while(i <= j && (*mst.rbegin() + (j-i+1) * sum) > budget){\\n                sum -= runningCosts[i];\\n                mst.erase(mst.find(chargeTimes[i++]));\\n            }\\n            mxLen = max(mxLen,j++ -i+1);\\n        }\\n        return mxLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013915,
                "title": "c-sliding-window-map-no-use-priority-queue",
                "content": "# AUTHOR: JAYESH BADGUJAR\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        long long sum=0;\\n        map<int,int>::iterator it;\\n        int maxi=0,i=0,j=0,n=chargeTimes.size(),ans=0;\\n        map<int,int> mp;\\n        while(j<n){\\n            sum+=runningCosts[j];\\n            mp[chargeTimes[j]]++;\\n            it=mp.end();\\n            it--;\\n            long long curr_budget=(it->first)+((j-i+1)*sum);\\n            while(i<=j && curr_budget>budget){                \\n                \\n                if(curr_budget>budget){\\n                    mp[chargeTimes[i]]--;\\n                    if(mp[chargeTimes[i]]==0){\\n                        mp.erase(chargeTimes[i]);\\n                    }\\n                    sum-=runningCosts[i];\\n                    i++;\\n                }else{\\n                    break;\\n                }\\n                if(i<=j){\\n                    it=mp.end();\\n                    it--;\\n                    curr_budget=(it->first)+((j-i+1)*sum);\\n                }\\n            }\\n            ans=max(ans,j-i+1);\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Queue",
                    "Sliding Window",
                    "Heap (Priority Queue)",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        long long sum=0;\\n        map<int,int>::iterator it;\\n        int maxi=0,i=0,j=0,n=chargeTimes.size(),ans=0;\\n        map<int,int> mp;\\n        while(j<n){\\n            sum+=runningCosts[j];\\n            mp[chargeTimes[j]]++;\\n            it=mp.end();\\n            it--;\\n            long long curr_budget=(it->first)+((j-i+1)*sum);\\n            while(i<=j && curr_budget>budget){                \\n                \\n                if(curr_budget>budget){\\n                    mp[chargeTimes[i]]--;\\n                    if(mp[chargeTimes[i]]==0){\\n                        mp.erase(chargeTimes[i]);\\n                    }\\n                    sum-=runningCosts[i];\\n                    i++;\\n                }else{\\n                    break;\\n                }\\n                if(i<=j){\\n                    it=mp.end();\\n                    it--;\\n                    curr_budget=(it->first)+((j-i+1)*sum);\\n                }\\n            }\\n            ans=max(ans,j-i+1);\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999013,
                "title": "kotlin-monotonic-deque-sliding-window",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    fun maximumRobots(chargeTimes: IntArray, runningCosts: IntArray, budget: Long): Int {\\n        val deque = ArrayDeque<Int>()\\n        var answer = 0\\n        var runningSum = 0L\\n        \\n        var left = 0\\n        for (right in chargeTimes.indices) {\\n            // keep stack monotonically decreasing\\n            while (deque.isNotEmpty() && deque.last() < chargeTimes[right]) {\\n                deque.removeLast()\\n            }\\n\\n            deque.add(chargeTimes[right])\\n            runningSum += runningCosts[right]\\n\\n            // if violates constraint, shrink the window\\n            while (deque.isNotEmpty() && deque.first() + (right - left + 1) * runningSum > budget) {\\n                if (chargeTimes[left] == deque.first()) deque.removeFirst()\\n                runningSum -= runningCosts[left]\\n                left++\\n            }\\n\\n            answer = maxOf(answer, right - left + 1) \\n        }\\n\\n        return answer\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Sliding Window",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    fun maximumRobots(chargeTimes: IntArray, runningCosts: IntArray, budget: Long): Int {\\n        val deque = ArrayDeque<Int>()\\n        var answer = 0\\n        var runningSum = 0L\\n        \\n        var left = 0\\n        for (right in chargeTimes.indices) {\\n            // keep stack monotonically decreasing\\n            while (deque.isNotEmpty() && deque.last() < chargeTimes[right]) {\\n                deque.removeLast()\\n            }\\n\\n            deque.add(chargeTimes[right])\\n            runningSum += runningCosts[right]\\n\\n            // if violates constraint, shrink the window\\n            while (deque.isNotEmpty() && deque.first() + (right - left + 1) * runningSum > budget) {\\n                if (chargeTimes[left] == deque.first()) deque.removeFirst()\\n                runningSum -= runningCosts[left]\\n                left++\\n            }\\n\\n            answer = maxOf(answer, right - left + 1) \\n        }\\n\\n        return answer\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3986746,
                "title": "sliding-window-max-heap-dictionary",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe use a sliding window to search for the maximum number of robots that satisfy the budget constraints. the max_heap returns the maximum value in logK time and the dictionary keeps track of removed entries from the window that are not the maximum value of the heap. It\\'s important to remember that removing a value from a heap that is not the max value takes O(N) Time by using the dictionary we don\\'t remove the value until it becomes the maximum which takes O(1) Time to remove. This greatly improves the time complexity of the algorithm.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1)  use sliding window template from leet codes data structures and algorithms course. \\n\\n\\n# Complexity\\n- Time complexity:$$O(NlogK)$$ Where N is the length of charge times and runningCosts and K is the Max Number Of Robots since we store the max number of robots on a heap and it takes logK time to get the max value from the heap.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:$$O(K)$$ since the heap and Dictionary group up to at most K  wher K is the Max Number of Robots\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nfrom heapq import *\\n\\nclass Solution:\\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\\n        heap = []\\n        seen = defaultdict(int)\\n        left = ans = running_sum = 0\\n        \\n        for right in range(len(chargeTimes)):\\n            \\n            heappush(heap, -chargeTimes[right])\\n            seen[chargeTimes[right]] +=1\\n            running_sum += runningCosts[right]\\n            total_cost = -heap[0] + (right - left +1)*running_sum\\n          \\n            #contract window until it is valid again\\n            while total_cost > budget:\\n               \\n                seen[chargeTimes[left]] -=1 \\n                running_sum-= runningCosts[left]\\n                left+=1\\n                \\n\\n                #remove max value from heap if it is no longer in dictionary!\\n                while len(heap) > 0  and seen[-heap[0]] ==0:\\n                    del seen[-heap[0]]\\n                    heappop(heap)\\n                \\n                \\n                total_cost = -heap[0] + (right - left +1)*running_sum  if len(heap) > 0 else 0\\n\\n            #update the answer here\\n            ans  = max(ans, right - left+1)  \\n\\n        \\n        return ans\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Sliding Window",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom heapq import *\\n\\nclass Solution:\\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\\n        heap = []\\n        seen = defaultdict(int)\\n        left = ans = running_sum = 0\\n        \\n        for right in range(len(chargeTimes)):\\n            \\n            heappush(heap, -chargeTimes[right])\\n            seen[chargeTimes[right]] +=1\\n            running_sum += runningCosts[right]\\n            total_cost = -heap[0] + (right - left +1)*running_sum\\n          \\n            #contract window until it is valid again\\n            while total_cost > budget:\\n               \\n                seen[chargeTimes[left]] -=1 \\n                running_sum-= runningCosts[left]\\n                left+=1\\n                \\n\\n                #remove max value from heap if it is no longer in dictionary!\\n                while len(heap) > 0  and seen[-heap[0]] ==0:\\n                    del seen[-heap[0]]\\n                    heappop(heap)\\n                \\n                \\n                total_cost = -heap[0] + (right - left +1)*running_sum  if len(heap) > 0 else 0\\n\\n            #update the answer here\\n            ans  = max(ans, right - left+1)  \\n\\n        \\n        return ans\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978094,
                "title": "c-sliding-window-dequeue-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(int x,vector<int>& chargeTimes, vector<int>& runningCosts, long long budget){\\n        long long n=chargeTimes.size(),sum=0,ans=0;\\n        deque<int> dq;\\n        \\n        for(int i=0;i<x-1;i++){\\n            sum += runningCosts[i];\\n            while(!dq.empty() && chargeTimes[i]>chargeTimes[dq.back()]){\\n                dq.pop_back();\\n            }\\n            dq.push_back(i);\\n        }\\n        \\n        for(long long i=x-1;i<n;i++){\\n            sum +=  runningCosts[i];\\n            \\n            while(!dq.empty() && chargeTimes[i]>chargeTimes[dq.back()]){\\n                dq.pop_back();\\n            }\\n            if(dq.size()>=x) dq.pop_front();\\n            dq.push_back(i);\\n            \\n            long long total = chargeTimes[dq.front()] + x*sum;\\n            if(total<=budget){\\n                // cout<<dq.front()<<\" \"<<i<<\" \";\\n                return true;\\n            } \\n            sum -=  runningCosts[i-x+1];\\n            if(dq.front()==i-x+1){\\n                dq.pop_front();\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        long long l=1,r=chargeTimes.size(),ans=0;\\n        while(l<=r){\\n            int mid=(l+r)/2;\\n            \\n            if(check(mid,chargeTimes,runningCosts,budget)){\\n                ans=mid;l=mid+1;\\n            } else {\\n                r=mid-1;\\n            }\\n        }\\n        // cout<<check(2,chargeTimes,runningCosts,budget)<<endl;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Queue",
                    "Sliding Window",
                    "Heap (Priority Queue)",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int x,vector<int>& chargeTimes, vector<int>& runningCosts, long long budget){\\n        long long n=chargeTimes.size(),sum=0,ans=0;\\n        deque<int> dq;\\n        \\n        for(int i=0;i<x-1;i++){\\n            sum += runningCosts[i];\\n            while(!dq.empty() && chargeTimes[i]>chargeTimes[dq.back()]){\\n                dq.pop_back();\\n            }\\n            dq.push_back(i);\\n        }\\n        \\n        for(long long i=x-1;i<n;i++){\\n            sum +=  runningCosts[i];\\n            \\n            while(!dq.empty() && chargeTimes[i]>chargeTimes[dq.back()]){\\n                dq.pop_back();\\n            }\\n            if(dq.size()>=x) dq.pop_front();\\n            dq.push_back(i);\\n            \\n            long long total = chargeTimes[dq.front()] + x*sum;\\n            if(total<=budget){\\n                // cout<<dq.front()<<\" \"<<i<<\" \";\\n                return true;\\n            } \\n            sum -=  runningCosts[i-x+1];\\n            if(dq.front()==i-x+1){\\n                dq.pop_front();\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        long long l=1,r=chargeTimes.size(),ans=0;\\n        while(l<=r){\\n            int mid=(l+r)/2;\\n            \\n            if(check(mid,chargeTimes,runningCosts,budget)){\\n                ans=mid;l=mid+1;\\n            } else {\\n                r=mid-1;\\n            }\\n        }\\n        // cout<<check(2,chargeTimes,runningCosts,budget)<<endl;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3976118,
                "title": "easy-to-understand-solution-in-java-using-binary-search-and-duque",
                "content": "# Intuition\\nTrying all possible consecutive sum gives you the intuition of brute force which can be optimized using binary search. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirst perform a binary search on the values of consecutive number of robots. log(n).\\nThe function you will use to check for binary search condition is O(n)\\nsliding window to find the maximum and calculating sum.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n\\n        int n = chargeTimes.length;\\n        int ans =0;\\n        int low = 0, high = n;\\n        while(low<=high)\\n        {\\n\\n            int mid = low+(high-low)/2;\\n            if(isPossible(mid,budget,runningCosts, chargeTimes))\\n            {\\n                ans=mid;\\n                low = mid+1;\\n            }\\n            else\\n            {\\n                high = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    boolean isPossible(int consecutiveNumberOfRobots , long budget, int[] runningCosts, int[] chargeTimes)\\n    {\\n        int n = chargeTimes.length;\\n        Deque<Integer> dq = new LinkedList();\\n        int l = 0, r = 0;\\n        long sum = 0;\\n      \\n        for(r=0;r>=0 && r<n;r++)\\n        {\\n           \\n            //calculate max time for charge\\n            sum= sum+runningCosts[r];\\n            \\n            while(dq.size()>0 && dq.getFirst()<l)\\n                dq.removeFirst();\\n\\n            while(dq.size()>0 && chargeTimes[dq.getLast()]<chargeTimes[r])\\n                dq.removeLast();\\n            \\n            dq.addLast(r);\\n            if(r>=consecutiveNumberOfRobots-1)\\n            {\\n            \\n                if((consecutiveNumberOfRobots*sum + chargeTimes[dq.getFirst()])<=budget)\\n                    return true;\\n                sum=sum-runningCosts[l];\\n                l++;\\n            }           \\n        }\\n        return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Sliding Window",
                    "Doubly-Linked List"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n\\n        int n = chargeTimes.length;\\n        int ans =0;\\n        int low = 0, high = n;\\n        while(low<=high)\\n        {\\n\\n            int mid = low+(high-low)/2;\\n            if(isPossible(mid,budget,runningCosts, chargeTimes))\\n            {\\n                ans=mid;\\n                low = mid+1;\\n            }\\n            else\\n            {\\n                high = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    boolean isPossible(int consecutiveNumberOfRobots , long budget, int[] runningCosts, int[] chargeTimes)\\n    {\\n        int n = chargeTimes.length;\\n        Deque<Integer> dq = new LinkedList();\\n        int l = 0, r = 0;\\n        long sum = 0;\\n      \\n        for(r=0;r>=0 && r<n;r++)\\n        {\\n           \\n            //calculate max time for charge\\n            sum= sum+runningCosts[r];\\n            \\n            while(dq.size()>0 && dq.getFirst()<l)\\n                dq.removeFirst();\\n\\n            while(dq.size()>0 && chargeTimes[dq.getLast()]<chargeTimes[r])\\n                dq.removeLast();\\n            \\n            dq.addLast(r);\\n            if(r>=consecutiveNumberOfRobots-1)\\n            {\\n            \\n                if((consecutiveNumberOfRobots*sum + chargeTimes[dq.getFirst()])<=budget)\\n                    return true;\\n                sum=sum-runningCosts[l];\\n                l++;\\n            }           \\n        }\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972929,
                "title": "neatly-coded-binary-search-and-deque-solution-in-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing binary search and its range being from 0 to the total number of robots. We use the solution from Problem 239. Sliding Window Maximum https://leetcode.com/problems/sliding-window-maximum/solutions/3969294/neatly-coded-monotonically-decreasing-stack-solution/ to calculate the maximum of the robots when the window is k. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe also extract the sum of the window which is used to calculate the budget. The functions runCosts and MaxTimes return a list of max times and sums for window size k. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\\n    \\n<!-- Return true if k robots can run on or below budget, else false -->\\n        n = len(chargeTimes)\\n        def possibleToRun(k):\\n            max_times = maxTimes(k)\\n            run_costs = runCosts(k)\\n            for i in range(len(max_times)):\\n                quote = max_times[i] + (k * run_costs[i])\\n                if quote <= budget:\\n                    return True\\n            return False\\n\\n<!-- Returns a list of sum of all elements in a window of size k -->\\n        def runCosts(k):\\n            cost = sum(runningCosts[:k])\\n            r = k\\n            run_costs = [cost]\\n            while r < len(runningCosts):\\n                cost += runningCosts[r]\\n                cost -= runningCosts[r-k]\\n                run_costs.append(cost)\\n                r += 1\\n            return run_costs\\n\\n<!-- Returns a list of max element in a window where the size is k -->\\n        def maxTimes(k):\\n            times = []\\n            l = r = 0\\n            q = deque()\\n            while r < len(chargeTimes):\\n                while q and chargeTimes[q[-1]] < chargeTimes[r]:\\n                    q.pop()\\n                q.append(r)\\n\\n                if l > q[0]:\\n                    q.popleft()\\n\\n                if r+1 >= k:\\n                    times.append(chargeTimes[q[0]])\\n                    l += 1\\n                r += 1\\n            return times\\n\\n<!-- Binary search from 0 to the total number of robots present -->\\n        low = 0\\n        high = len(chargeTimes)\\n        while(low <= high):\\n            mid = (low + high) // 2\\n            if possibleToRun(mid):\\n                res = mid\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n        return res \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\\n    \\n<!-- Return true if k robots can run on or below budget, else false -->\\n        n = len(chargeTimes)\\n        def possibleToRun(k):\\n            max_times = maxTimes(k)\\n            run_costs = runCosts(k)\\n            for i in range(len(max_times)):\\n                quote = max_times[i] + (k * run_costs[i])\\n                if quote <= budget:\\n                    return True\\n            return False\\n\\n<!-- Returns a list of sum of all elements in a window of size k -->\\n        def runCosts(k):\\n            cost = sum(runningCosts[:k])\\n            r = k\\n            run_costs = [cost]\\n            while r < len(runningCosts):\\n                cost += runningCosts[r]\\n                cost -= runningCosts[r-k]\\n                run_costs.append(cost)\\n                r += 1\\n            return run_costs\\n\\n<!-- Returns a list of max element in a window where the size is k -->\\n        def maxTimes(k):\\n            times = []\\n            l = r = 0\\n            q = deque()\\n            while r < len(chargeTimes):\\n                while q and chargeTimes[q[-1]] < chargeTimes[r]:\\n                    q.pop()\\n                q.append(r)\\n\\n                if l > q[0]:\\n                    q.popleft()\\n\\n                if r+1 >= k:\\n                    times.append(chargeTimes[q[0]])\\n                    l += 1\\n                r += 1\\n            return times\\n\\n<!-- Binary search from 0 to the total number of robots present -->\\n        low = 0\\n        high = len(chargeTimes)\\n        while(low <= high):\\n            mid = (low + high) // 2\\n            if possibleToRun(mid):\\n                res = mid\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n        return res \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962556,
                "title": "c-beats-100-1-deque-2-set",
                "content": "\\n# Code 1 deque beats100%\\n```\\nclass Solution {\\n    \\npublic:\\n    Solution(){\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n    }\\n    int maximumRobots(vector<int>& c, vector<int>& r, long long b) {\\n        deque<int>q;\\n        int ptr1=0,ptr2=0;\\n        int ans=0;\\n        long long sum=0,score=0;\\n        int n=c.size();\\n        while(ptr2<n)\\n        {\\n            while(!q.empty() && c[q.back()]<c[ptr2])\\n                q.pop_back();\\n            q.push_back(ptr2);\\n            sum+=r[ptr2];\\n            score=sum*(ptr2-ptr1+1) + c[q.front()];\\n            while(score>b)\\n            {\\n                sum-=r[ptr1];\\n                if(q.front()<=ptr1)\\n                    q.pop_front();\\n                ptr1++;    \\n                if(q.empty())\\n                    break;\\n                score=sum*(ptr2-ptr1+1) + c[q.front()];\\n            }\\n            ans=max(ans,ptr2-ptr1+1);\\n            ptr2++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n# Code 2 set beats 80%\\n```\\nclass Solution {\\npublic:\\n    Solution(){\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n    }\\n    int maximumRobots(vector<int>& c, vector<int>& r, long long b) {\\n        multiset<int>s;\\n        int ptr1=0,ptr2=0;\\n        long long val=0;\\n        int ans=0,n=c.size();\\n        long long sum1=0;\\n        while(ptr2<n)\\n        {\\n            s.insert(c[ptr2]);\\n            sum1+=r[ptr2];\\n            long long score= *s.rbegin() +(ptr2-ptr1+1)*(sum1);\\n            while(score>b)\\n            {\\n                s.erase(s.find(c[ptr1]));\\n                sum1-=r[ptr1];\\n                ptr1++;\\n                if(s.empty())\\n                    break;\\n                score= *s.rbegin() +(ptr2-ptr1+1)*(sum1);\\n            }\\n            ans=max(ans,ptr2-ptr1+1);\\n            ptr2++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    Solution(){\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n    }\\n    int maximumRobots(vector<int>& c, vector<int>& r, long long b) {\\n        deque<int>q;\\n        int ptr1=0,ptr2=0;\\n        int ans=0;\\n        long long sum=0,score=0;\\n        int n=c.size();\\n        while(ptr2<n)\\n        {\\n            while(!q.empty() && c[q.back()]<c[ptr2])\\n                q.pop_back();\\n            q.push_back(ptr2);\\n            sum+=r[ptr2];\\n            score=sum*(ptr2-ptr1+1) + c[q.front()];\\n            while(score>b)\\n            {\\n                sum-=r[ptr1];\\n                if(q.front()<=ptr1)\\n                    q.pop_front();\\n                ptr1++;    \\n                if(q.empty())\\n                    break;\\n                score=sum*(ptr2-ptr1+1) + c[q.front()];\\n            }\\n            ans=max(ans,ptr2-ptr1+1);\\n            ptr2++;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    Solution(){\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n    }\\n    int maximumRobots(vector<int>& c, vector<int>& r, long long b) {\\n        multiset<int>s;\\n        int ptr1=0,ptr2=0;\\n        long long val=0;\\n        int ans=0,n=c.size();\\n        long long sum1=0;\\n        while(ptr2<n)\\n        {\\n            s.insert(c[ptr2]);\\n            sum1+=r[ptr2];\\n            long long score= *s.rbegin() +(ptr2-ptr1+1)*(sum1);\\n            while(score>b)\\n            {\\n                s.erase(s.find(c[ptr1]));\\n                sum1-=r[ptr1];\\n                ptr1++;\\n                if(s.empty())\\n                    break;\\n                score= *s.rbegin() +(ptr2-ptr1+1)*(sum1);\\n            }\\n            ans=max(ans,ptr2-ptr1+1);\\n            ptr2++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3959515,
                "title": "c-sliding-window-easy-approach",
                "content": "# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& charge, vector<int>& runcost, long long budget) {\\n        int i=0,j=0,n=charge.size(),ans=0,maximum=0;\\n        long long sum=0,val=0;\\n        priority_queue<int>pq;\\n        while(j<n)\\n        {\\n            pq.push(charge[j]);\\n            maximum=pq.top();\\n            sum+=runcost[j];\\n            val=maximum+(j-i+1)*sum;\\n            if(val<=budget)\\n            {\\n                ans=max(ans,j-i+1);\\n                j++;\\n            }\\n            else\\n            {\\n                while(val>budget)\\n                {\\n                    sum-=runcost[i];\\n                    if(pq.top()==charge[i])pq.pop();\\n                    if(pq.empty())maximum=0;\\n                    else maximum=pq.top();\\n                    i++;\\n                    if(j<i){\\n                        val=0;\\n                        sum=0;\\n                        while(!pq.empty())pq.pop();\\n                    }\\n                   else  val=maximum+(j-i+1)*sum;\\n                }\\n                if(val==budget)ans=max(ans,j-i+1);\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& charge, vector<int>& runcost, long long budget) {\\n        int i=0,j=0,n=charge.size(),ans=0,maximum=0;\\n        long long sum=0,val=0;\\n        priority_queue<int>pq;\\n        while(j<n)\\n        {\\n            pq.push(charge[j]);\\n            maximum=pq.top();\\n            sum+=runcost[j];\\n            val=maximum+(j-i+1)*sum;\\n            if(val<=budget)\\n            {\\n                ans=max(ans,j-i+1);\\n                j++;\\n            }\\n            else\\n            {\\n                while(val>budget)\\n                {\\n                    sum-=runcost[i];\\n                    if(pq.top()==charge[i])pq.pop();\\n                    if(pq.empty())maximum=0;\\n                    else maximum=pq.top();\\n                    i++;\\n                    if(j<i){\\n                        val=0;\\n                        sum=0;\\n                        while(!pq.empty())pq.pop();\\n                    }\\n                   else  val=maximum+(j-i+1)*sum;\\n                }\\n                if(val==budget)ans=max(ans,j-i+1);\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951575,
                "title": "c-solution-using-deque",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        deque<ll>dq;\\n        ll low=0, high=0, n = chargeTimes.size(), res = 0, sum1=0;\\n\\n        vector<ll>prefix(n, 0);\\n        for(int i=0;i<runningCosts.size();i++){\\n            sum1+=(ll)runningCosts[i];\\n            prefix[i] = sum1;\\n        }\\n\\n        while(high < n){\\n            while(!dq.empty() && chargeTimes[dq.back()] < chargeTimes[high])\\n                dq.pop_back();\\n            \\n            dq.push_back(high);\\n            ll temp = chargeTimes[dq.front()], count = high - low + 1, sum = 0;\\n            if(low == 0)    sum = prefix[high];\\n            else\\n                sum = prefix[high] - prefix[low-1];\\n\\n            ll curr = temp + count*sum;\\n            if(budget >= curr){\\n                res = max(res, count);\\n                ++high;\\n            }\\n            else{\\n                while(low<high){\\n                    ++low;\\n                    while(!dq.empty() && dq.front() < low)\\n                        dq.pop_front();\\n                    temp = chargeTimes[dq.front()], count = high - low + 1, sum = prefix[high] - prefix[low-1];\\n\\n                    curr = temp + count*sum;\\n                    if(curr <= budget){\\n                        res = max(res, count);\\n                        break;\\n                    }\\n                }\\n                ++high;\\n            }\\n        }\\n\\n        ll temp = chargeTimes[dq.front()], count = high - low, sum = 0;\\n        if(low == 0)    sum = prefix[high-1];\\n        else    sum = prefix[high-1] - prefix[low-1];\\n\\n        ll curr = temp + count*sum;\\n        if(budget >= curr){\\n            res = max(res, count);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Doubly-Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        deque<ll>dq;\\n        ll low=0, high=0, n = chargeTimes.size(), res = 0, sum1=0;\\n\\n        vector<ll>prefix(n, 0);\\n        for(int i=0;i<runningCosts.size();i++){\\n            sum1+=(ll)runningCosts[i];\\n            prefix[i] = sum1;\\n        }\\n\\n        while(high < n){\\n            while(!dq.empty() && chargeTimes[dq.back()] < chargeTimes[high])\\n                dq.pop_back();\\n            \\n            dq.push_back(high);\\n            ll temp = chargeTimes[dq.front()], count = high - low + 1, sum = 0;\\n            if(low == 0)    sum = prefix[high];\\n            else\\n                sum = prefix[high] - prefix[low-1];\\n\\n            ll curr = temp + count*sum;\\n            if(budget >= curr){\\n                res = max(res, count);\\n                ++high;\\n            }\\n            else{\\n                while(low<high){\\n                    ++low;\\n                    while(!dq.empty() && dq.front() < low)\\n                        dq.pop_front();\\n                    temp = chargeTimes[dq.front()], count = high - low + 1, sum = prefix[high] - prefix[low-1];\\n\\n                    curr = temp + count*sum;\\n                    if(curr <= budget){\\n                        res = max(res, count);\\n                        break;\\n                    }\\n                }\\n                ++high;\\n            }\\n        }\\n\\n        ll temp = chargeTimes[dq.front()], count = high - low, sum = 0;\\n        if(low == 0)    sum = prefix[high-1];\\n        else    sum = prefix[high-1] - prefix[low-1];\\n\\n        ll curr = temp + count*sum;\\n        if(budget >= curr){\\n            res = max(res, count);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949741,
                "title": "python3-82-easy-to-understand-monotonic-queue-approach",
                "content": "# Intuition\\nWe use a monotonic decreasing array to store the max values encountered in `chargeTimes` and use a sliding window to keep track of the sum. `que1` is the monotonic array that would have this format: `[(max1,max1_idx),(max2,max2_idx),...]`. Variable `l` is the pointer that points to the left of the sliding window, the right pointer of the sliding window is the variable `i` in each interation. \\n\\nI would really appreciate an upvote if you find this post helpful! \\n# Code\\n```\\nfrom collections import deque\\nclass Solution:\\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\\n        ans = 0 \\n        que1 = deque()\\n        l = 0\\n        runningSum = 0\\n        # Use a monotonic stack to store max value\\n        # que1 = [(max1,max1idx),(max2,max2idx),...]\\n        # Use a sliding window with left index to store the sum \\n        for i in range(len(chargeTimes)):\\n            # Making sure the que1 is always in descending order\\n            while que1 and que1[-1][0]<=chargeTimes[i]:\\n                que1.pop()\\n            que1.append((chargeTimes[i],i))\\n            runningSum += runningCosts[i]\\n            # The length of the sliding window is i-l+1\\n            totalCost = que1[0][0]+(i-l+1)*runningSum\\n\\n            while totalCost> budget:\\n                l+=1  #poping the leftmost element\\n                # the index of the element poped is l-1\\n                # update max if the max value is poped\\n                if l-1>=que1[0][1]:\\n                    que1.popleft()\\n                # update runningSum\\n                runningSum -= runningCosts[l-1]\\n                if que1: #Prevention of calling an empty array\\n                    totalCost = que1[0][0]+(i-l+1)*runningSum\\n                else:\\n                    totalCost = 0 \\n            ans = max(ans,(i-l+1))\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Monotonic Queue"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\\n        ans = 0 \\n        que1 = deque()\\n        l = 0\\n        runningSum = 0\\n        # Use a monotonic stack to store max value\\n        # que1 = [(max1,max1idx),(max2,max2idx),...]\\n        # Use a sliding window with left index to store the sum \\n        for i in range(len(chargeTimes)):\\n            # Making sure the que1 is always in descending order\\n            while que1 and que1[-1][0]<=chargeTimes[i]:\\n                que1.pop()\\n            que1.append((chargeTimes[i],i))\\n            runningSum += runningCosts[i]\\n            # The length of the sliding window is i-l+1\\n            totalCost = que1[0][0]+(i-l+1)*runningSum\\n\\n            while totalCost> budget:\\n                l+=1  #poping the leftmost element\\n                # the index of the element poped is l-1\\n                # update max if the max value is poped\\n                if l-1>=que1[0][1]:\\n                    que1.popleft()\\n                # update runningSum\\n                runningSum -= runningCosts[l-1]\\n                if que1: #Prevention of calling an empty array\\n                    totalCost = que1[0][0]+(i-l+1)*runningSum\\n                else:\\n                    totalCost = 0 \\n            ans = max(ans,(i-l+1))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3940494,
                "title": "sliding-window-monotonic-queue-amazon",
                "content": "# Intuition\\n\\nI love this questions because it is fairely easy to solve if you know the algorithms involved, but absolutly hellish if you dont.\\n\\nWhenever you see in the question that you are searching for a CONTINUOUS/CONSECURIVE subsequence the sliding/moving window algorithm should jump to you mind. Not that it is the right solution every time, but it is ALWAYS good to check.\\n\\nWhenever you need to calculate the min or max of MULTIPLE (CONTINUOUS) subranges the Monodeque/Monostack algorithm and the Segment Tree data structure should be checked. In our case is the monostack algorithm that will help us. (If you are not familiar with Segment Tree it is worth to check it out, it is a very versatile DS, and once you are familiar it is fairely easy to implement* https://leetcode.com/problems/count-good-triplets/solutions/3173326/segment-tree-and-fenwick-tree-solution-in-on2logn/)\\n\\n\\\\* Like Union Find algorithm, the first time you see it you think that you will never be able to memorize it, but once you understand it you can simply recreate it every time :)\\n\\n> Why MonoQueue?\\n\\nImagine that you are checking all the max values of ranges that end at $$x_n$$, and you find out that $$x_n$$ is the greates value so far, do you really need to store the information of other values? No, because ALL the subranges that end at $$x_n$$ will have $$x_n$$ as the max.\\n\\nWhat if $$x_{k2}$$ (k1<k2<n) was the biggest value between `]k1,k2]`, do we really need to store/ compare all the values between `]k1,k2]`? No, because any subrange that starts at those points and ends in `n` will have that value as a max.\\n\\nSo The idea of monodeque/monostack is to drop the data that is not useful, this way avoiding comparing it over and over withou need.\\n\\n> Steps\\n\\n1. Move the right of the window (`a`) to the right one cell.\\n2. Add that cell to the sum.\\n3. Update the MonoQueue with the new value.\\n4. Decreate the window on the right (`b`) until the calculation is on the acceptable threshold. (remember to drop items on the MonoStack that leave the window)\\n5. Check if the window size is the max.\\n\\n\\n# Approach\\n- Sliding Window\\n- MonoQueue\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n![image.png](https://assets.leetcode.com/users/images/40d7bc70-9c1a-453b-9ee4-547a59f6ff80_1692615318.9903984.png)\\n\\n```java\\nclass Solution {\\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n        // I like to use arrays as queues/stack, but you could\\n        // use LinkedList/ArrayDeque if you prefer.\\n        int[] queue=new int[chargeTimes.length];\\n        int b=0,first=0,last=0,max=0;\\n        long sum=0;\\n        // Step 1: Move the right of the window to the right one cell.\\n        for(int a=0;a<runningCosts.length;a++) {\\n            // Step 2: Add that cell to the sum.\\n            sum+=runningCosts[a];\\n            // Step 3: Update the MonoQueue with the new value.\\n            int ct=chargeTimes[a];\\n            while(last>first&&chargeTimes[queue[last-1]]<=ct) last--;\\n            queue[last++]=a;\\n            // Step 4: Decreate the window on the right until\\n            // the calculation is on the acceptable threshold.\\n            // (remember to drop items on the MonoStack that\\n            // leave the window)\\n            while(b<a&&chargeTimes[queue[first]]+(a-b+1)*sum>budget) {\\n                while(queue[first]<=b) first++;\\n                sum-=runningCosts[b++];\\n            }\\n            // Step 5: Check if the window size is the max.\\n            if(chargeTimes[queue[first]]+(a-b+1)*sum<=budget&&\\n                max<a-b+1) max=a-b+1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n        // I like to use arrays as queues/stack, but you could\\n        // use LinkedList/ArrayDeque if you prefer.\\n        int[] queue=new int[chargeTimes.length];\\n        int b=0,first=0,last=0,max=0;\\n        long sum=0;\\n        // Step 1: Move the right of the window to the right one cell.\\n        for(int a=0;a<runningCosts.length;a++) {\\n            // Step 2: Add that cell to the sum.\\n            sum+=runningCosts[a];\\n            // Step 3: Update the MonoQueue with the new value.\\n            int ct=chargeTimes[a];\\n            while(last>first&&chargeTimes[queue[last-1]]<=ct) last--;\\n            queue[last++]=a;\\n            // Step 4: Decreate the window on the right until\\n            // the calculation is on the acceptable threshold.\\n            // (remember to drop items on the MonoStack that\\n            // leave the window)\\n            while(b<a&&chargeTimes[queue[first]]+(a-b+1)*sum>budget) {\\n                while(queue[first]<=b) first++;\\n                sum-=runningCosts[b++];\\n            }\\n            // Step 5: Check if the window size is the max.\\n            if(chargeTimes[queue[first]]+(a-b+1)*sum<=budget&&\\n                max<a-b+1) max=a-b+1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922087,
                "title": "c-python-binary-search-monotonic-queue-solution-with-explanation",
                "content": "### binary search\\nwe can use binary search to enumerate length of subarray.\\nIn the check(x) function, use slding window to check if there has any subarray whose length is x and its cost <= budget.\\nTo find max chargeTimes value in window, we can use monotonic queue, keep it in decreasing order from left to right.\\n\\nwe can find valid max value on the left of queue.\\n\\ntc is O(n), sc is (nlogn).\\n### python\\n```python\\nclass Solution:\\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\\n        def check(x):\\n            q = deque()\\n            sum_running = 0\\n            for i, (c, r) in enumerate(zip(chargeTimes, runningCosts)):\\n                sum_running += r\\n                while q and c >= chargeTimes[q[-1]]: q.pop()\\n                q.append(i)\\n                if i >= x - 1:\\n                    if i - x >= 0: sum_running -= runningCosts[i - x]\\n                    while q and q[0] <= i - x: q.popleft()\\n                    cost = (chargeTimes[q[0]] if q else 0) + x * sum_running\\n                    if cost <= budget: return True\\n            return False\\n\\t\\t\\n        l = 0\\n        r = len(chargeTimes)\\n        while l <= r:\\n            m = (l + r) // 2\\n            if check(m): l = m + 1\\n            else: r = m - 1\\n        return r\\n```\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        int l = 0, r = runningCosts.size(), m;\\n        while (l <= r) {\\n            m = l + (r - l) / 2;\\n            if (this -> check(chargeTimes, runningCosts, budget, m)) l = m + 1;\\n            else r = m - 1;\\n        }\\n        return r;\\n    }\\n    bool check(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget, int x) {\\n        long long sum_running = 0, cost;\\n        deque<int> q;\\n        for (int i = 0; i < chargeTimes.size(); i+=1) {\\n            sum_running += runningCosts[i];\\n            while (!q.empty() && chargeTimes[i] >= chargeTimes[q.back()]) q.pop_back();\\n            q.emplace_back(i);\\n            if (i >= x - 1) {\\n                if (i - x >= 0) sum_running -= runningCosts[i-x];\\n                while (!q.empty() && q[0] <= i - x) q.pop_front();\\n                cost = (q.empty()? 0: chargeTimes[q[0]]) + (long long) x * sum_running;\\n                if (cost <= budget) return true;\\n            }\\n        }\\n        return false; \\n    }\\n};\\n```\\n\\n### monotonic queue\\nwe can use slidng window to enumerate subarray whose cost <= budget.\\n\\nTo find max chargeTimes value in window, we can use monotonic queue, keep it in decreasing order from left to right.\\n\\nwe can find valid max value on the left of queue.\\n\\nIf cost of window > budget. move left pointer to make cost of window <= budget.\\n\\ntc is O(n), sc is O(n).\\n### python\\n```python\\nclass Solution:\\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\\n        left = 0\\n        q = deque()\\n        sum_running = 0\\n        ans = 0\\n        for i, (c, r) in enumerate(zip(chargeTimes, runningCosts)):\\n            sum_running += r\\n            while q and c >= chargeTimes[q[-1]]: q.pop()\\n            q.append(i)\\n            \\n            while q and chargeTimes[q[0]] + (i - left + 1) * sum_running > budget:\\n                if q[0] == left: q.popleft()\\n                sum_running -= runningCosts[left]\\n                left += 1\\n            ans = ans if ans > i - left + 1 else i - left + 1\\n        return ans\\n```\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        deque<int> q;\\n        int left = 0, ans = 0;\\n        long long sum_running = 0;\\n        for (int i = 0; i < chargeTimes.size(); i+=1) {\\n            sum_running += runningCosts[i];\\n            while (!q.empty() && chargeTimes[i] >= chargeTimes[q.back()]) q.pop_back();\\n            q.emplace_back(i);\\n            \\n            while (!q.empty() && chargeTimes[q[0]] + (i - left + 1) * sum_running > budget) {\\n                if (q[0] == left) q.pop_front();\\n                sum_running -= runningCosts[left];\\n                left += 1;\\n            }\\n            ans = ans > i - left + 1? ans: i - left + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Binary Search"
                ],
                "code": "```python\\nclass Solution:\\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\\n        def check(x):\\n            q = deque()\\n            sum_running = 0\\n            for i, (c, r) in enumerate(zip(chargeTimes, runningCosts)):\\n                sum_running += r\\n                while q and c >= chargeTimes[q[-1]]: q.pop()\\n                q.append(i)\\n                if i >= x - 1:\\n                    if i - x >= 0: sum_running -= runningCosts[i - x]\\n                    while q and q[0] <= i - x: q.popleft()\\n                    cost = (chargeTimes[q[0]] if q else 0) + x * sum_running\\n                    if cost <= budget: return True\\n            return False\\n\\t\\t\\n        l = 0\\n        r = len(chargeTimes)\\n        while l <= r:\\n            m = (l + r) // 2\\n            if check(m): l = m + 1\\n            else: r = m - 1\\n        return r\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        int l = 0, r = runningCosts.size(), m;\\n        while (l <= r) {\\n            m = l + (r - l) / 2;\\n            if (this -> check(chargeTimes, runningCosts, budget, m)) l = m + 1;\\n            else r = m - 1;\\n        }\\n        return r;\\n    }\\n    bool check(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget, int x) {\\n        long long sum_running = 0, cost;\\n        deque<int> q;\\n        for (int i = 0; i < chargeTimes.size(); i+=1) {\\n            sum_running += runningCosts[i];\\n            while (!q.empty() && chargeTimes[i] >= chargeTimes[q.back()]) q.pop_back();\\n            q.emplace_back(i);\\n            if (i >= x - 1) {\\n                if (i - x >= 0) sum_running -= runningCosts[i-x];\\n                while (!q.empty() && q[0] <= i - x) q.pop_front();\\n                cost = (q.empty()? 0: chargeTimes[q[0]]) + (long long) x * sum_running;\\n                if (cost <= budget) return true;\\n            }\\n        }\\n        return false; \\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\\n        left = 0\\n        q = deque()\\n        sum_running = 0\\n        ans = 0\\n        for i, (c, r) in enumerate(zip(chargeTimes, runningCosts)):\\n            sum_running += r\\n            while q and c >= chargeTimes[q[-1]]: q.pop()\\n            q.append(i)\\n            \\n            while q and chargeTimes[q[0]] + (i - left + 1) * sum_running > budget:\\n                if q[0] == left: q.popleft()\\n                sum_running -= runningCosts[left]\\n                left += 1\\n            ans = ans if ans > i - left + 1 else i - left + 1\\n        return ans\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        deque<int> q;\\n        int left = 0, ans = 0;\\n        long long sum_running = 0;\\n        for (int i = 0; i < chargeTimes.size(); i+=1) {\\n            sum_running += runningCosts[i];\\n            while (!q.empty() && chargeTimes[i] >= chargeTimes[q.back()]) q.pop_back();\\n            q.emplace_back(i);\\n            \\n            while (!q.empty() && chargeTimes[q[0]] + (i - left + 1) * sum_running > budget) {\\n                if (q[0] == left) q.pop_front();\\n                sum_running -= runningCosts[left];\\n                left += 1;\\n            }\\n            ans = ans > i - left + 1? ans: i - left + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921740,
                "title": "c-sliding-window-deque",
                "content": "# Intuition\\nTry [Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/description/) first.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& ct, vector<int>& rc, long long amt) {\\n        int ans = 0;\\n        int n = ct.size();\\n        int i = 0,j = 0;\\n        long long csum = 0;\\n        deque<long long> dq;\\n        while(j<n)\\n        {\\n            csum+=rc[j];\\n            while(dq.size()>0 && dq.back()<ct[j])\\n            dq.pop_back();\\n            dq.push_back(ct[j]);\\n            long long val = dq.front()+(j-i+1)*csum;\\n            if(val<=amt)\\n            {\\n                ans = max(ans,(j-i+1));\\n            }\\n            else\\n            {\\n                while(val>amt)\\n                {\\n                    csum-=rc[i];\\n                    if(dq.front()==ct[i])\\n                    dq.pop_front();\\n                    i++;\\n                    if(dq.size()==0)\\n                    val = 0;\\n                    else\\n                    val = dq.front()+(j-i+1)*csum; \\n                }\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& ct, vector<int>& rc, long long amt) {\\n        int ans = 0;\\n        int n = ct.size();\\n        int i = 0,j = 0;\\n        long long csum = 0;\\n        deque<long long> dq;\\n        while(j<n)\\n        {\\n            csum+=rc[j];\\n            while(dq.size()>0 && dq.back()<ct[j])\\n            dq.pop_back();\\n            dq.push_back(ct[j]);\\n            long long val = dq.front()+(j-i+1)*csum;\\n            if(val<=amt)\\n            {\\n                ans = max(ans,(j-i+1));\\n            }\\n            else\\n            {\\n                while(val>amt)\\n                {\\n                    csum-=rc[i];\\n                    if(dq.front()==ct[i])\\n                    dq.pop_front();\\n                    i++;\\n                    if(dq.size()==0)\\n                    val = 0;\\n                    else\\n                    val = dq.front()+(j-i+1)*csum; \\n                }\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918362,
                "title": "c-sliding-window-o-n-using-map-easy-to-understand",
                "content": "```\\nclass Solution {\\n    long long n , sum = 0,curB;\\n    int ans = 0, mx = 0, l =0;\\n    map<int,int,greater<int>> mp;\\n    \\npublic:\\n    int maximumRobots(vector<int>& ct, vector<int>& ec, long long b) {\\n        n = ct.size();\\n        for(int i = 0;i<n;i++) {\\n            mp[ct[i]]++;\\n            sum += ec[i];\\n            mx = (*mp.begin()).first;\\n            curB = (i+1 - l)*sum + mx;\\n            if(curB <= b) ans = max(ans,i+1 - l); \\n            else {\\n                if(--mp[ct[l]] == 0)  mp.erase(ct[l]);\\n                sum -= ec[l];\\n                l++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    long long n , sum = 0,curB;\\n    int ans = 0, mx = 0, l =0;\\n    map<int,int,greater<int>> mp;\\n    \\npublic:\\n    int maximumRobots(vector<int>& ct, vector<int>& ec, long long b) {\\n        n = ct.size();\\n        for(int i = 0;i<n;i++) {\\n            mp[ct[i]]++;\\n            sum += ec[i];\\n            mx = (*mp.begin()).first;\\n            curB = (i+1 - l)*sum + mx;\\n            if(curB <= b) ans = max(ans,i+1 - l); \\n            else {\\n                if(--mp[ct[l]] == 0)  mp.erase(ct[l]);\\n                sum -= ec[l];\\n                l++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880259,
                "title": "prefix-sum-sliding-window-deque-beats-77-runtimes-linear-space-and-time",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n  public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n    long[] runningCostSum = new long[runningCosts.length];\\n    int i = 0, j = 0;\\n    for (i = 0; i < runningCosts.length; i++) {\\n      runningCostSum[i] = runningCosts[i] + (i > 0 ? runningCostSum[i - 1] : 0);\\n    }\\n\\n    Deque<Integer> maxCharges = new ArrayDeque<>();\\n    int countMaxRobots = 0;\\n    i = j = 0;\\n    long cumCost = 0;\\n    while (j < runningCosts.length) {\\n      while (!maxCharges.isEmpty() && chargeTimes[maxCharges.getLast()] < chargeTimes[j]) {\\n        maxCharges.removeLast();\\n      }\\n\\n      maxCharges.addLast(j);\\n\\n      cumCost = -1;\\n      while (i < j && (cumCost == -1 || cumCost > budget)) {\\n        if (cumCost == -1) {\\n          cumCost = chargeTimes[maxCharges.peekFirst()]\\n              + (j - i + 1) * (long) (runningCostSum[j] - (i - 1 >= 0 ? runningCostSum[i - 1] : 0));\\n          continue;\\n        }\\n\\n        if (maxCharges.getFirst() == i) {\\n          maxCharges.removeFirst();\\n        }\\n        i++;\\n        cumCost = chargeTimes[maxCharges.getFirst()]\\n            + (j - i + 1) * (long) (runningCostSum[j] - (i - 1 > 0 ? runningCostSum[i - 1] : 0));\\n      }\\n\\n      if (i == j && cumCost == -1) {\\n        cumCost = chargeTimes[maxCharges.getFirst()]\\n            + (j - i + 1) * (long) (runningCostSum[j] - (i - 1 > 0 ? runningCostSum[i - 1] : 0));\\n      }\\n\\n      countMaxRobots = cumCost <= budget ? Math.max(countMaxRobots, j - i + 1) : countMaxRobots;\\n      j++;\\n    }\\n\\n    return countMaxRobots;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n    long[] runningCostSum = new long[runningCosts.length];\\n    int i = 0, j = 0;\\n    for (i = 0; i < runningCosts.length; i++) {\\n      runningCostSum[i] = runningCosts[i] + (i > 0 ? runningCostSum[i - 1] : 0);\\n    }\\n\\n    Deque<Integer> maxCharges = new ArrayDeque<>();\\n    int countMaxRobots = 0;\\n    i = j = 0;\\n    long cumCost = 0;\\n    while (j < runningCosts.length) {\\n      while (!maxCharges.isEmpty() && chargeTimes[maxCharges.getLast()] < chargeTimes[j]) {\\n        maxCharges.removeLast();\\n      }\\n\\n      maxCharges.addLast(j);\\n\\n      cumCost = -1;\\n      while (i < j && (cumCost == -1 || cumCost > budget)) {\\n        if (cumCost == -1) {\\n          cumCost = chargeTimes[maxCharges.peekFirst()]\\n              + (j - i + 1) * (long) (runningCostSum[j] - (i - 1 >= 0 ? runningCostSum[i - 1] : 0));\\n          continue;\\n        }\\n\\n        if (maxCharges.getFirst() == i) {\\n          maxCharges.removeFirst();\\n        }\\n        i++;\\n        cumCost = chargeTimes[maxCharges.getFirst()]\\n            + (j - i + 1) * (long) (runningCostSum[j] - (i - 1 > 0 ? runningCostSum[i - 1] : 0));\\n      }\\n\\n      if (i == j && cumCost == -1) {\\n        cumCost = chargeTimes[maxCharges.getFirst()]\\n            + (j - i + 1) * (long) (runningCostSum[j] - (i - 1 > 0 ? runningCostSum[i - 1] : 0));\\n      }\\n\\n      countMaxRobots = cumCost <= budget ? Math.max(countMaxRobots, j - i + 1) : countMaxRobots;\\n      j++;\\n    }\\n\\n    return countMaxRobots;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874165,
                "title": "java-o-n-sliding-window-dequeue",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n        \\n        Deque<Integer> dq = new ArrayDeque<>();\\n\\n        long sum = 0;\\n        int left = 0;\\n        int right = 0;\\n        long result = 0;\\n        int l = 0;\\n\\n        while (right < chargeTimes.length) {\\n            sum += runningCosts[right];\\n            while ( ! dq.isEmpty() && chargeTimes[right] >= chargeTimes[dq.peekLast()]) {\\n                dq.pollLast();\\n            }\\n            dq.addLast(right);\\n\\n            while (left <= right) {\\n                result = chargeTimes[dq.peekFirst()] + (right-left+1) * sum;\\n                if (result <= budget) {\\n                    break;\\n                }\\n                if (dq.peekFirst() == left) {\\n                    dq.pollFirst();\\n                }\\n                sum -= runningCosts[left];\\n                left++;\\n\\n            }\\n            l = Math.max(l, right-left+1);\\n            right++;\\n        }\\n\\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n        \\n        Deque<Integer> dq = new ArrayDeque<>();\\n\\n        long sum = 0;\\n        int left = 0;\\n        int right = 0;\\n        long result = 0;\\n        int l = 0;\\n\\n        while (right < chargeTimes.length) {\\n            sum += runningCosts[right];\\n            while ( ! dq.isEmpty() && chargeTimes[right] >= chargeTimes[dq.peekLast()]) {\\n                dq.pollLast();\\n            }\\n            dq.addLast(right);\\n\\n            while (left <= right) {\\n                result = chargeTimes[dq.peekFirst()] + (right-left+1) * sum;\\n                if (result <= budget) {\\n                    break;\\n                }\\n                if (dq.peekFirst() == left) {\\n                    dq.pollFirst();\\n                }\\n                sum -= runningCosts[left];\\n                left++;\\n\\n            }\\n            l = Math.max(l, right-left+1);\\n            right++;\\n        }\\n\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3867380,
                "title": "python-o-n-monotonic-queue",
                "content": "Usual sliding window idea: grow the window until the constraint is violated, then shrink it from the left. Now on the constraint: it is easy to operate with runningCost, since it is additive, however chargeTimes is a bit more complicated. Every time we shrink the window from the left we need to update the current maximum of the sliding window. This is easy to do with the monotonic queue, which keeps decreasing sequence of window elements. We pop all elements smaller the the next incoming one when we are growing the window to maintain monotonic property and we potentially drop the element from the left when we shrink the window (only in the case leftmost element is the current maximum).\\n\\n```\\nfrom collections import deque\\nclass Solution:\\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\\n        # monotonic queue to track current maximum in [l, r) window\\n        q = deque()\\n\\n        # left and right pointers\\n        l = r = 0\\n        \\n        # current charging cost and running cost sum\\n        cc = rc = 0\\n        # current best result\\n        max_running = 0\\n        \\n        # sweep sliding window\\n        while l != len(chargeTimes) and r != len(chargeTimes):\\n            \\n            # charging_cost + num_robots * sum(running_cost) is our costraint\\n            if cc + (r-l)*rc <= budget and r < len(chargeTimes):\\n                # grow the window to the right here\\n                rc += runningCosts[r]\\n                \\n                # drain the queue from the right until we drop\\n                # all charging costs less or equal than the current one\\n                # they do not matter anymore.\\n                while q and chargeTimes[r] >= chargeTimes[q[-1]]:\\n                    e = q.pop()\\n                # add current charging cost to the monotonic queue\\n                q.append(r)\\n                \\n                # q[0] is the index of the current maximum, \\n                # use it in our cost constraint\\n                cc = chargeTimes[q[0]]\\n                r += 1\\n            else:\\n                # here we shrink the window from the left\\n                # correct the running cost sum by subtracting cost of \\n                # the leftmost element we are excluding.\\n                rc -= runningCosts[l]\\n                \\n                # here we need to potentially drop an index from the queue\\n                # if the current maximum is our leftmost element we are dropping.\\n                # we do that by checking its index (it is l in this case)\\n                if q and q[0] <= l:\\n                    q.popleft()\\n                \\n                # and we update charging cost to the new maximum.\\n                cc = chargeTimes[q[0]] if q else 0\\n                \\n                # advance left pointer\\n                l += 1\\n                \\n            # ipdate the solution if we are within the budget\\n            if cc + (r-l)*rc <= budget and r - l > max_running:\\n                max_running = r - l\\n                    \\n        return max_running\\n       \\n            \\n                \\n                \\n            \\n        \\n```",
                "solutionTags": [
                    "Queue",
                    "Monotonic Queue"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\\n        # monotonic queue to track current maximum in [l, r) window\\n        q = deque()\\n\\n        # left and right pointers\\n        l = r = 0\\n        \\n        # current charging cost and running cost sum\\n        cc = rc = 0\\n        # current best result\\n        max_running = 0\\n        \\n        # sweep sliding window\\n        while l != len(chargeTimes) and r != len(chargeTimes):\\n            \\n            # charging_cost + num_robots * sum(running_cost) is our costraint\\n            if cc + (r-l)*rc <= budget and r < len(chargeTimes):\\n                # grow the window to the right here\\n                rc += runningCosts[r]\\n                \\n                # drain the queue from the right until we drop\\n                # all charging costs less or equal than the current one\\n                # they do not matter anymore.\\n                while q and chargeTimes[r] >= chargeTimes[q[-1]]:\\n                    e = q.pop()\\n                # add current charging cost to the monotonic queue\\n                q.append(r)\\n                \\n                # q[0] is the index of the current maximum, \\n                # use it in our cost constraint\\n                cc = chargeTimes[q[0]]\\n                r += 1\\n            else:\\n                # here we shrink the window from the left\\n                # correct the running cost sum by subtracting cost of \\n                # the leftmost element we are excluding.\\n                rc -= runningCosts[l]\\n                \\n                # here we need to potentially drop an index from the queue\\n                # if the current maximum is our leftmost element we are dropping.\\n                # we do that by checking its index (it is l in this case)\\n                if q and q[0] <= l:\\n                    q.popleft()\\n                \\n                # and we update charging cost to the new maximum.\\n                cc = chargeTimes[q[0]] if q else 0\\n                \\n                # advance left pointer\\n                l += 1\\n                \\n            # ipdate the solution if we are within the budget\\n            if cc + (r-l)*rc <= budget and r - l > max_running:\\n                max_running = r - l\\n                    \\n        return max_running\\n       \\n            \\n                \\n                \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3863544,
                "title": "concise-c-implementation",
                "content": ". The concept is the same as [*239. Sliding Window Maximum*](https://leetcode.com/problems/sliding-window-maximum/) (my implementation is  [here](https://leetcode.com/problems/sliding-window-maximum/discuss/3863502/Concise-C-implementation) for reference)\\n. Only keep the meaningful indexes in the lut array\\n. Feel free to use malloc/free instead for the lut array\\n. Time complexity: O(n)\\n\\n```\\nint maximumRobots(int* chargeTimes, int chargeTimesSize, int* runningCosts, int runningCostsSize,\\n                  long long budget){\\n  int lut_array[50001];\\n  int idx_head = 0;\\n  int idx_tail = 0;\\n  int ret_len = 0;\\n  int curr_len = 0;\\n  long long curr_cost = 0;\\n  \\n  for (int loop_idx=0; loop_idx<chargeTimesSize; loop_idx++) {\\n    long long curr_sum;\\n    curr_cost += runningCosts[loop_idx];\\n    \\n    while (idx_head < idx_tail && lut_array[idx_head] < (loop_idx-curr_len)) {\\n      idx_head++;\\n    }\\n    \\n    while (idx_head < idx_tail && chargeTimes[lut_array[idx_tail-1]] < chargeTimes[loop_idx]) {\\n      idx_tail--;\\n    }\\n    \\n    lut_array[idx_tail++] = loop_idx;\\n    \\n    curr_sum = chargeTimes[lut_array[idx_head]];\\n    curr_sum += (long long) ((++curr_len) * curr_cost);\\n    \\n    while (curr_len > 0 && curr_sum > budget) {\\n      curr_cost -= runningCosts[loop_idx - (--curr_len)];\\n      \\n      while (idx_head < idx_tail && lut_array[idx_head] < (loop_idx-curr_len)) {\\n        idx_head++;\\n      }\\n      \\n      curr_sum = chargeTimes[lut_array[idx_head]];\\n      curr_sum += (long long) (curr_len * curr_cost);\\n    }\\n    \\n    if (ret_len < curr_len) {\\n      ret_len = curr_len;\\n    }\\n  }\\n  \\n  return ret_len;\\n}\\n\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint maximumRobots(int* chargeTimes, int chargeTimesSize, int* runningCosts, int runningCostsSize,\\n                  long long budget){\\n  int lut_array[50001];\\n  int idx_head = 0;\\n  int idx_tail = 0;\\n  int ret_len = 0;\\n  int curr_len = 0;\\n  long long curr_cost = 0;\\n  \\n  for (int loop_idx=0; loop_idx<chargeTimesSize; loop_idx++) {\\n    long long curr_sum;\\n    curr_cost += runningCosts[loop_idx];\\n    \\n    while (idx_head < idx_tail && lut_array[idx_head] < (loop_idx-curr_len)) {\\n      idx_head++;\\n    }\\n    \\n    while (idx_head < idx_tail && chargeTimes[lut_array[idx_tail-1]] < chargeTimes[loop_idx]) {\\n      idx_tail--;\\n    }\\n    \\n    lut_array[idx_tail++] = loop_idx;\\n    \\n    curr_sum = chargeTimes[lut_array[idx_head]];\\n    curr_sum += (long long) ((++curr_len) * curr_cost);\\n    \\n    while (curr_len > 0 && curr_sum > budget) {\\n      curr_cost -= runningCosts[loop_idx - (--curr_len)];\\n      \\n      while (idx_head < idx_tail && lut_array[idx_head] < (loop_idx-curr_len)) {\\n        idx_head++;\\n      }\\n      \\n      curr_sum = chargeTimes[lut_array[idx_head]];\\n      curr_sum += (long long) (curr_len * curr_cost);\\n    }\\n    \\n    if (ret_len < curr_len) {\\n      ret_len = curr_len;\\n    }\\n  }\\n  \\n  return ret_len;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3796975,
                "title": "cpp-sliding-window-max-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& time, vector<int>& cost, long long budget) {\\n        long long i=0,j=0,sum=0,ct=0,ans=0;\\n        #define pi pair<long long,long long>\\n        priority_queue<pi,vector<pi>> pq;\\n        \\n        while(j<cost.size()){\\n            sum+=cost[j];\\n            pq.push({time[j],j});\\n            \\n            if(sum*(j-i+1)+pq.top().first<=budget) ans=max(ans,j-i+1);\\n            \\n            while(i<=j and sum*(j-i+1)+pq.top().first>budget){\\n                sum-=cost[i++];\\n                while(!pq.empty() and pq.top().second<i) pq.pop();\\n            }\\n            j++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& time, vector<int>& cost, long long budget) {\\n        long long i=0,j=0,sum=0,ct=0,ans=0;\\n        #define pi pair<long long,long long>\\n        priority_queue<pi,vector<pi>> pq;\\n        \\n        while(j<cost.size()){\\n            sum+=cost[j];\\n            pq.push({time[j],j});\\n            \\n            if(sum*(j-i+1)+pq.top().first<=budget) ans=max(ans,j-i+1);\\n            \\n            while(i<=j and sum*(j-i+1)+pq.top().first>budget){\\n                sum-=cost[i++];\\n                while(!pq.empty() and pq.top().second<i) pq.pop();\\n            }\\n            j++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760016,
                "title": "c-using-monotonic-queue-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n        int maxCount = 0;\\n        LinkedList<int> localMaximum = new LinkedList<int>();\\n        long currentBudget = 0;\\n\\n        for (int start = 0, end = 0; end < chargeTimes.Length; end++)\\n        {\\n            while (localMaximum.Count != 0 && chargeTimes[localMaximum.Last.Value] < chargeTimes[end])\\n            {\\n                localMaximum.RemoveLast();\\n            }\\n\\n            localMaximum.AddLast(end);\\n            currentBudget += runningCosts[end];\\n\\n            while (localMaximum.Count != 0 && budget < (chargeTimes[localMaximum.First.Value] + (end - start + 1) * currentBudget))\\n            {\\n                currentBudget -= runningCosts[start];\\n                if (localMaximum.First.Value <= start)\\n                {\\n                    localMaximum.RemoveFirst();\\n                }\\n\\n                start++;\\n            }\\n\\n            maxCount = Math.Max(maxCount, end - start + 1);\\n        }\\n\\n        return maxCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Sliding Window",
                    "Monotonic Queue"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n        int maxCount = 0;\\n        LinkedList<int> localMaximum = new LinkedList<int>();\\n        long currentBudget = 0;\\n\\n        for (int start = 0, end = 0; end < chargeTimes.Length; end++)\\n        {\\n            while (localMaximum.Count != 0 && chargeTimes[localMaximum.Last.Value] < chargeTimes[end])\\n            {\\n                localMaximum.RemoveLast();\\n            }\\n\\n            localMaximum.AddLast(end);\\n            currentBudget += runningCosts[end];\\n\\n            while (localMaximum.Count != 0 && budget < (chargeTimes[localMaximum.First.Value] + (end - start + 1) * currentBudget))\\n            {\\n                currentBudget -= runningCosts[start];\\n                if (localMaximum.First.Value <= start)\\n                {\\n                    localMaximum.RemoveFirst();\\n                }\\n\\n                start++;\\n            }\\n\\n            maxCount = Math.Max(maxCount, end - start + 1);\\n        }\\n\\n        return maxCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737021,
                "title": "rust-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nWe need to track a subarray sum and maximum. The sum makes me think to use a two-pointer approach, and the maximum means we\\'ll also need a stack. When getting deeper into the problem, I realized we\\'ll need a double-ended queue instead of a normal stack.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n$$O(n)$$ (worst-case for the stack)\\n\\n# Code\\n```\\n\\nuse std::collections::VecDeque;\\n\\nfn total_cost(max_charge_time: i32, k: usize, sum_running_cost: i64) -> i64 {\\n    max_charge_time as i64 + (k as i64) * sum_running_cost as i64\\n}\\n\\nimpl Solution {\\n    pub fn maximum_robots(charge_times: Vec<i32>, running_costs: Vec<i32>, budget: i64) -> i32 {\\n        let mut result = 0;\\n        let mut sum_running_cost = 0i64;\\n        let mut charge_time_stack = VecDeque::<usize>::new();\\n        let mut k = 0;\\n        let mut left = 0usize;\\n        \\'outer: for right in 0..charge_times.len() {\\n            k += 1;\\n            sum_running_cost += running_costs[right] as i64;\\n            while let Some(&prev) = charge_time_stack.back() {\\n                if charge_times[prev] > charge_times[right] {\\n                    break;\\n                }\\n                charge_time_stack.pop_back();\\n            }\\n            charge_time_stack.push_back(right);\\n            while total_cost(charge_times[charge_time_stack[0]], k, sum_running_cost) > budget {\\n                k -= 1;\\n                sum_running_cost -= running_costs[left] as i64;\\n                left += 1;\\n                if left > right {\\n                    charge_time_stack.clear();\\n                    continue \\'outer;\\n                }\\n                while left > charge_time_stack[0] {\\n                    charge_time_stack.pop_front();\\n                }\\n            }\\n            result = result.max(k)\\n        }\\n        result as i32\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n\\nuse std::collections::VecDeque;\\n\\nfn total_cost(max_charge_time: i32, k: usize, sum_running_cost: i64) -> i64 {\\n    max_charge_time as i64 + (k as i64) * sum_running_cost as i64\\n}\\n\\nimpl Solution {\\n    pub fn maximum_robots(charge_times: Vec<i32>, running_costs: Vec<i32>, budget: i64) -> i32 {\\n        let mut result = 0;\\n        let mut sum_running_cost = 0i64;\\n        let mut charge_time_stack = VecDeque::<usize>::new();\\n        let mut k = 0;\\n        let mut left = 0usize;\\n        \\'outer: for right in 0..charge_times.len() {\\n            k += 1;\\n            sum_running_cost += running_costs[right] as i64;\\n            while let Some(&prev) = charge_time_stack.back() {\\n                if charge_times[prev] > charge_times[right] {\\n                    break;\\n                }\\n                charge_time_stack.pop_back();\\n            }\\n            charge_time_stack.push_back(right);\\n            while total_cost(charge_times[charge_time_stack[0]], k, sum_running_cost) > budget {\\n                k -= 1;\\n                sum_running_cost -= running_costs[left] as i64;\\n                left += 1;\\n                if left > right {\\n                    charge_time_stack.clear();\\n                    continue \\'outer;\\n                }\\n                while left > charge_time_stack[0] {\\n                    charge_time_stack.pop_front();\\n                }\\n            }\\n            result = result.max(k)\\n        }\\n        result as i32\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3735042,
                "title": "sliding-window-multiset",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        int n = chargeTimes.size();\\n        int i = 0;\\n        int j = 0;\\n        int res = 0;\\n        long long sum = 0;\\n        multiset<int,greater<int>>hash;\\n        long long cost = 0;\\n        while(i < n)\\n        {\\n            hash.insert(chargeTimes[i]);\\n            sum += runningCosts[i];\\n            cost = *hash.begin();\\n            cost += (i-j+1) * sum;\\n            while(cost > budget)\\n            {\\n                sum -= runningCosts[j];\\n                int k = chargeTimes[j];\\n                auto x = hash.find(k);\\n                if(x != hash.end())\\n                hash.erase(x);\\n                cost = *hash.begin();\\n                cost += (i-j+1) * sum;\\n                j++;\\n            }\\n            res = max(res,i-j+1);\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        int n = chargeTimes.size();\\n        int i = 0;\\n        int j = 0;\\n        int res = 0;\\n        long long sum = 0;\\n        multiset<int,greater<int>>hash;\\n        long long cost = 0;\\n        while(i < n)\\n        {\\n            hash.insert(chargeTimes[i]);\\n            sum += runningCosts[i];\\n            cost = *hash.begin();\\n            cost += (i-j+1) * sum;\\n            while(cost > budget)\\n            {\\n                sum -= runningCosts[j];\\n                int k = chargeTimes[j];\\n                auto x = hash.find(k);\\n                if(x != hash.end())\\n                hash.erase(x);\\n                cost = *hash.begin();\\n                cost += (i-j+1) * sum;\\n                j++;\\n            }\\n            res = max(res,i-j+1);\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724449,
                "title": "python-o-n-solution-with-monotonic-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import deque\\nclass Solution:\\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\\n\\n        prefix_sum = [0] * (len(chargeTimes) + 1)\\n\\n        max_count = 0\\n        stack = deque()\\n\\n        for i in range(1, len(chargeTimes) + 1):\\n            prefix_sum[i] = prefix_sum[i-1] + runningCosts[i-1]\\n\\n\\n        left = 0\\n        for right in range(len(chargeTimes)):\\n\\n            while stack and chargeTimes[stack[-1]] < chargeTimes[right]:\\n                stack.pop()\\n\\n            stack.append(right)\\n\\n            current_budget = chargeTimes[stack[0]] + (right+1-left) * (prefix_sum[right+1] - prefix_sum[left])\\n\\n            while stack and current_budget > budget:\\n                \\n                if left == stack[0]:\\n                    stack.popleft()\\n\\n                left += 1\\n\\n                if stack:\\n                    current_budget = chargeTimes[stack[0]] + (right+1-left) * (prefix_sum[right+1] - prefix_sum[left])\\n\\n            if current_budget <= budget:\\n                max_count = max(max_count, right+1-left)\\n\\n        return max_count\\n```",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum",
                    "Monotonic Queue"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\\n\\n        prefix_sum = [0] * (len(chargeTimes) + 1)\\n\\n        max_count = 0\\n        stack = deque()\\n\\n        for i in range(1, len(chargeTimes) + 1):\\n            prefix_sum[i] = prefix_sum[i-1] + runningCosts[i-1]\\n\\n\\n        left = 0\\n        for right in range(len(chargeTimes)):\\n\\n            while stack and chargeTimes[stack[-1]] < chargeTimes[right]:\\n                stack.pop()\\n\\n            stack.append(right)\\n\\n            current_budget = chargeTimes[stack[0]] + (right+1-left) * (prefix_sum[right+1] - prefix_sum[left])\\n\\n            while stack and current_budget > budget:\\n                \\n                if left == stack[0]:\\n                    stack.popleft()\\n\\n                left += 1\\n\\n                if stack:\\n                    current_budget = chargeTimes[stack[0]] + (right+1-left) * (prefix_sum[right+1] - prefix_sum[left])\\n\\n            if current_budget <= budget:\\n                max_count = max(max_count, right+1-left)\\n\\n        return max_count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3720012,
                "title": "java-typical-binary-search-prefixsum-max-heap",
                "content": "# Intuition\\nDo a binary search on answer spectrum, the answer must be between 0 and array length inclusive. For each guess (mid value -> answer), check if it is possible to choose the robots within the budget. if possible, then we need maximum or this one, so move left to mid, if not possible, then choose lesser answer by moving right to mid - 1.\\n\\n# Approach\\nEverytime we need to find, sum for the selected guess. Get this in constant time using prefix sum.\\nEverytime we need to find the max value, use a max heap and do a lazy removal of invalid max.\\n\\n# Complexity\\n- Time complexity:\\nO(n log n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    long prefixSum[];\\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n        prefixSum = new long[chargeTimes.length];\\n        long prev = 0;\\n        for(int i=0; i<runningCosts.length; i++) {\\n            prefixSum[i] += prev + runningCosts[i];\\n            prev = prefixSum[i];\\n        }\\n        int left = 0, right = chargeTimes.length;\\n\\n        while(left < right) {\\n            int mid = (left + right + 1) / 2;\\n            if(possible(chargeTimes, budget, mid))\\n                left = mid;\\n            else\\n                right = mid - 1;\\n        }\\n\\n        return left;\\n    }\\n\\n    public boolean possible(int chargeTimes[], long budget, int k) {\\n        Queue<int[]> pq = new PriorityQueue<>(\\n            (a, b) -> Integer.compare(b[0], a[0])\\n        );\\n        for(int i=0; i<k; i++)\\n            pq.add(new int[]{chargeTimes[i], i});\\n        for(int i=0; i<=chargeTimes.length - k; i++) {\\n            while(pq.peek()[1] < i)\\n                pq.poll();\\n            long max = pq.peek()[0];\\n            long sum = prefixSum[i+k-1] - (i-1 >= 0 ? prefixSum[i-1] : 0);\\n            if ((sum * (long)k) + max <= budget) return true;\\n            if(i+k < chargeTimes.length)\\n                pq.add(new int[]{chargeTimes[i+k], i+k});\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    long prefixSum[];\\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n        prefixSum = new long[chargeTimes.length];\\n        long prev = 0;\\n        for(int i=0; i<runningCosts.length; i++) {\\n            prefixSum[i] += prev + runningCosts[i];\\n            prev = prefixSum[i];\\n        }\\n        int left = 0, right = chargeTimes.length;\\n\\n        while(left < right) {\\n            int mid = (left + right + 1) / 2;\\n            if(possible(chargeTimes, budget, mid))\\n                left = mid;\\n            else\\n                right = mid - 1;\\n        }\\n\\n        return left;\\n    }\\n\\n    public boolean possible(int chargeTimes[], long budget, int k) {\\n        Queue<int[]> pq = new PriorityQueue<>(\\n            (a, b) -> Integer.compare(b[0], a[0])\\n        );\\n        for(int i=0; i<k; i++)\\n            pq.add(new int[]{chargeTimes[i], i});\\n        for(int i=0; i<=chargeTimes.length - k; i++) {\\n            while(pq.peek()[1] < i)\\n                pq.poll();\\n            long max = pq.peek()[0];\\n            long sum = prefixSum[i+k-1] - (i-1 >= 0 ? prefixSum[i-1] : 0);\\n            if ((sum * (long)k) + max <= budget) return true;\\n            if(i+k < chargeTimes.length)\\n                pq.add(new int[]{chargeTimes[i+k], i+k});\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714251,
                "title": "python-sliding-window-mono-deque-o-n",
                "content": "# Intuition\\nSliding Window + Mono Deque\\n\\n# Approach\\nSure, here\\'s an explanation of the code part by part:\\n\\n```python\\nclass Solution:\\n    def maximumRobots(self, ct: List[int], rc: List[int], budget: int) -> int:\\n```\\nThis defines a class `Solution` with a method `maximumRobots` that takes in three arguments: `ct`, `rc`, and `budget`. The method returns an integer value.\\n\\n```python\\nmaxq=deque()\\nsumi,i,ans,n=0,0,0,len(ct)\\ntarget=0\\n```\\nThe method initializes a deque `maxq` to keep track of the maximum element in the current window, variables `sumi`, `i`, and `ans` to 0, and a variable `n` to the length of `ct`. It also initializes a variable `target` to the value of `budget`.\\n\\n```python\\nfor j in range(n):\\n    while maxq and ct[maxq[-1]]<ct[j]:\\n        maxq.pop()\\n    sumi+=rc[j]\\n    maxq.append(j)\\n    target=ct[maxq[0]]+((j-i+1)*sumi)\\n```\\nThe method iterates over the elements in `ct` using a for loop. In each iteration, it updates the deque `maxq` to keep track of the maximum element in the current window, updates the sum of elements in the current window by adding the value of `rc[j]`, and updates the target value.\\n\\n```python\\nwhile i<=j and target>budget:\\n    if maxq and maxq[0]==i:\\n        maxq.popleft()\\n    sumi-=rc[i]\\n    i+=1\\n    multi=0\\n    if maxq:\\n        multi=ct[maxq[0]]\\n    target=multi+((j-i+1)*sumi)\\n```\\nIf the target value is greater than the budget, it shrinks the window from the left until the target value is less than or equal to the budget. It does this by removing elements from the deque `maxq`, updating the sum of elements in the current window, and incrementing the value of `i`.\\n\\n```python\\nans=max(ans,j-i+1)\\n```\\nFinally, it updates the maximum value of `ans`.\\n\\n```python\\nreturn ans\\n```\\nThe method returns the maximum value of `ans`.\\n\\nI hope this helps you understand how this code works. Is there anything else you would like to know?\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumRobots(self, ct: List[int], rc: List[int], budget: int) -> int:\\n        maxq=deque()\\n        sumi,i,ans,n=0,0,0,len(ct)\\n        target=budget\\n        for j in range(n):\\n            while maxq and ct[maxq[-1]]<ct[j]:\\n                maxq.pop()\\n            sumi+=rc[j]\\n            maxq.append(j)\\n            target=ct[maxq[0]]+((j-i+1)*sumi)\\n            while i<=j and target>budget:\\n                if maxq and maxq[0]==i:\\n                    maxq.popleft()\\n                sumi-=rc[i]\\n                i+=1\\n                multi=0\\n                if maxq:\\n                    multi=ct[maxq[0]]\\n                target=multi+((j-i+1)*sumi)\\n            #if target<=budget and j>i:    \\n            ans=max(ans,j-i+1)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Queue",
                    "Sliding Window",
                    "Monotonic Queue"
                ],
                "code": "```python\\nclass Solution:\\n    def maximumRobots(self, ct: List[int], rc: List[int], budget: int) -> int:\\n```\n```python\\nmaxq=deque()\\nsumi,i,ans,n=0,0,0,len(ct)\\ntarget=0\\n```\n```python\\nfor j in range(n):\\n    while maxq and ct[maxq[-1]]<ct[j]:\\n        maxq.pop()\\n    sumi+=rc[j]\\n    maxq.append(j)\\n    target=ct[maxq[0]]+((j-i+1)*sumi)\\n```\n```python\\nwhile i<=j and target>budget:\\n    if maxq and maxq[0]==i:\\n        maxq.popleft()\\n    sumi-=rc[i]\\n    i+=1\\n    multi=0\\n    if maxq:\\n        multi=ct[maxq[0]]\\n    target=multi+((j-i+1)*sumi)\\n```\n```python\\nans=max(ans,j-i+1)\\n```\n```python\\nreturn ans\\n```\n```\\nclass Solution:\\n    def maximumRobots(self, ct: List[int], rc: List[int], budget: int) -> int:\\n        maxq=deque()\\n        sumi,i,ans,n=0,0,0,len(ct)\\n        target=budget\\n        for j in range(n):\\n            while maxq and ct[maxq[-1]]<ct[j]:\\n                maxq.pop()\\n            sumi+=rc[j]\\n            maxq.append(j)\\n            target=ct[maxq[0]]+((j-i+1)*sumi)\\n            while i<=j and target>budget:\\n                if maxq and maxq[0]==i:\\n                    maxq.popleft()\\n                sumi-=rc[i]\\n                i+=1\\n                multi=0\\n                if maxq:\\n                    multi=ct[maxq[0]]\\n                target=multi+((j-i+1)*sumi)\\n            #if target<=budget and j>i:    \\n            ans=max(ans,j-i+1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713033,
                "title": "c-sliding-window-using-multiset",
                "content": "# Complexity\\n- Time complexity: O(nlogn)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        long long n = chargeTimes.size();\\n        long long ans = 0;\\n        long long sum = 0;\\n        multiset<long long>s;\\n        long long i=0 , j=0;\\n        while(j<n) {\\n            s.insert(chargeTimes[j]);\\n            sum+=runningCosts[j];\\n            long long val = *s.rbegin() + ((j-i+1)*sum);\\n            while(val>budget) {\\n                s.erase(s.find(chargeTimes[i]));\\n                sum-=runningCosts[i];\\n                i++;\\n                if(s.empty()) break;\\n                val = *s.begin() + ((j-i+1)*sum);\\n            }\\n            if(!s.empty()) ans = max(ans , j-i+1);\\n            j++;\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        long long n = chargeTimes.size();\\n        long long ans = 0;\\n        long long sum = 0;\\n        multiset<long long>s;\\n        long long i=0 , j=0;\\n        while(j<n) {\\n            s.insert(chargeTimes[j]);\\n            sum+=runningCosts[j];\\n            long long val = *s.rbegin() + ((j-i+1)*sum);\\n            while(val>budget) {\\n                s.erase(s.find(chargeTimes[i]));\\n                sum-=runningCosts[i];\\n                i++;\\n                if(s.empty()) break;\\n                val = *s.begin() + ((j-i+1)*sum);\\n            }\\n            if(!s.empty()) ans = max(ans , j-i+1);\\n            j++;\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3694198,
                "title": "sliding-window-priority-queue-with-lazy-deletion",
                "content": "```\\nimport heapq\\n\\nclass Heap:\\n    def __init__(self):\\n        self.heap = []\\n        self.deleted = defaultdict(int)\\n\\n    def push(self, val):\\n        heapq.heappush(self.heap, val)\\n\\n    def clean(self):\\n        while len(self.heap) > 0 and self.heap[0] in self.deleted:\\n            self.deleted[self.heap[0]] -= 1\\n            if self.deleted[self.heap[0]] == 0:\\n                del self.deleted[self.heap[0]]\\n            heapq.heappop(self.heap)\\n\\n    def __len__(self):\\n        self.clean()\\n        return len(self.heap)\\n    \\n    def min(self):\\n        self.clean()\\n        return self.heap[0]\\n    \\n    def __repr__(self):\\n        return str(self.deleted)\\n    \\n    def delete(self, val):\\n        self.deleted[val] += 1\\n\\n    def pop(self):\\n        self.clean()\\n        return heapq.heappop(self.heap)\\n\\nclass Solution:\\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\\n        n = len(chargeTimes)\\n        curr = Heap()\\n        currsum = 0\\n        i = 0\\n        res = 0\\n        for j in range(n):\\n            curr.push(-chargeTimes[j])\\n            currsum += runningCosts[j]\\n            while i < j and -curr.min() + (j - i + 1) * currsum > budget:\\n                currsum -= runningCosts[i]\\n                curr.delete(-chargeTimes[i])\\n                i += 1\\n            if -curr.min() + (j - i + 1) * currsum <= budget:\\n                res = max(res, j - i + 1)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport heapq\\n\\nclass Heap:\\n    def __init__(self):\\n        self.heap = []\\n        self.deleted = defaultdict(int)\\n\\n    def push(self, val):\\n        heapq.heappush(self.heap, val)\\n\\n    def clean(self):\\n        while len(self.heap) > 0 and self.heap[0] in self.deleted:\\n            self.deleted[self.heap[0]] -= 1\\n            if self.deleted[self.heap[0]] == 0:\\n                del self.deleted[self.heap[0]]\\n            heapq.heappop(self.heap)\\n\\n    def __len__(self):\\n        self.clean()\\n        return len(self.heap)\\n    \\n    def min(self):\\n        self.clean()\\n        return self.heap[0]\\n    \\n    def __repr__(self):\\n        return str(self.deleted)\\n    \\n    def delete(self, val):\\n        self.deleted[val] += 1\\n\\n    def pop(self):\\n        self.clean()\\n        return heapq.heappop(self.heap)\\n\\nclass Solution:\\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\\n        n = len(chargeTimes)\\n        curr = Heap()\\n        currsum = 0\\n        i = 0\\n        res = 0\\n        for j in range(n):\\n            curr.push(-chargeTimes[j])\\n            currsum += runningCosts[j]\\n            while i < j and -curr.min() + (j - i + 1) * currsum > budget:\\n                currsum -= runningCosts[i]\\n                curr.delete(-chargeTimes[i])\\n                i += 1\\n            if -curr.min() + (j - i + 1) * currsum <= budget:\\n                res = max(res, j - i + 1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680073,
                "title": "java-easy-sliding-window-o-n-tc",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n        // PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        int max = 0;\\n        int i = 0;\\n        int j = 0;\\n        long sum = 0;\\n        int n = chargeTimes.length;\\n        System.out.println(n);\\n        while(j<n){\\n            sum+=runningCosts[j];\\n            map.put(chargeTimes[j], map.getOrDefault(chargeTimes[j], 0)+1);\\n            while(map.size()>0&&(map.lastKey())+((j-i+1)*sum)>budget){\\n                map.put(chargeTimes[i], map.getOrDefault(chargeTimes[i], 0)-1);\\n                if(map.get(chargeTimes[i])<=0)map.remove(chargeTimes[i]);\\n                sum-=runningCosts[i];\\n                i++;\\n            }\\n            max = Math.max(j-i+1, max);\\n            j++;\\n        }\\n        System.out.println(i+\" \"+j);\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n        // PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        int max = 0;\\n        int i = 0;\\n        int j = 0;\\n        long sum = 0;\\n        int n = chargeTimes.length;\\n        System.out.println(n);\\n        while(j<n){\\n            sum+=runningCosts[j];\\n            map.put(chargeTimes[j], map.getOrDefault(chargeTimes[j], 0)+1);\\n            while(map.size()>0&&(map.lastKey())+((j-i+1)*sum)>budget){\\n                map.put(chargeTimes[i], map.getOrDefault(chargeTimes[i], 0)-1);\\n                if(map.get(chargeTimes[i])<=0)map.remove(chargeTimes[i]);\\n                sum-=runningCosts[i];\\n                i++;\\n            }\\n            max = Math.max(j-i+1, max);\\n            j++;\\n        }\\n        System.out.println(i+\" \"+j);\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671518,
                "title": "2398-maximum-number-of-robots-within-budget-binary-search-deque-java-code",
                "content": "time: O(n + log n) = O(n); space: O(n)\\nclass Solution {\\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n     int n = chargeTimes.length;\\n\\n        int left = 0, right = n;\\n        while(left < right){\\n            int mid = right - (right - left) / 2;\\n            if(isOK(mid, chargeTimes, runningCosts, budget)){\\n                left = mid;\\n            }else{\\n                right = mid - 1;\\n            }\\n        }\\n        return (int) left;\\n    }\\n\\n    private boolean isOK(long k, int[] chargeTimes, int[] runningCosts, long budget){\\n        int n = chargeTimes.length;\\n        long sum = 0;\\n        Deque<Integer> dq = new ArrayDeque<>();\\n\\n        for(int i = 0; i < n; i++){\\n            sum += runningCosts[i];\\n            while(!dq.isEmpty() && chargeTimes[dq.peekLast()] <= chargeTimes[i])\\n                dq.pollLast();\\n                dq.addLast(i);\\n            \\n           while(!dq.isEmpty() && dq.peekFirst() <= i - k)\\n               dq.pollFirst();\\n           \\n\\n            if(i >= k - 1){\\n                long res = chargeTimes[dq.peekFirst()] + k * sum;\\n                if(res <= budget)\\n                    return true;\\n                \\n                sum -= runningCosts[i - (int) (k - 1)];\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n     int n = chargeTimes.length;\\n\\n        int left = 0, right = n;\\n        while(left < right){\\n            int mid = right - (right - left) / 2;\\n            if(isOK(mid, chargeTimes, runningCosts, budget)){\\n                left = mid;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3658370,
                "title": "short-and-easy-o-n-solution-using-sliding-window-explanationsli",
                "content": "# Intuition\\n1. Note that the ```max(chargeTimes) + k * sum(runningCosts)``` is an increasing funciton. This tells us to do Binary Search leading O(nlogn) solution. \\n2. But since we can only take consecutive subarrays, sliding window can be used also. Assume 2 different function :```max(chargeTimes)``` and ```k * sum(runningCosts)``` independtly to solve. \\n\\n# Approach\\n1. For every index i, find the rightmost possible index j such that your total cost <= budget. Window size = j - i + 1. \\n2. You can use a Doubly Ended Queue to find the max(chargeTimes) for index in range [i,j]. This solved 1st function. \\n3. let say we are at index i(current window start at i), and we want to add the index j to current window, you can only add if it does not exceeds the budget.\\n4. When you add something how to find the total cost of 2nd function?\\n    4.1. Let a variable ```mx``` be used to find the max(chargeTime) for current window.\\n    4.2 Let say variable ```sum``` constains sum(runningCosts) for current window\\n    4.3. Let say variable ```currSum``` contains k * sum(runningCosts) for current window where k is window size.\\n    4.4. If you want to add element at index j, then sum will be added to currSum and j\\'th element\\'s running cost will be added k times to currSum. This will give new currSum. (Tryout some examples for validation).\\n    4.5 sum will be added by j\\'th element\\'s running cost. This solves 2nd function.\\n3. When you move the window, make sure you remove any previous element from the queue and remove the contribution to ith element to currSum and sum. \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n        int j = -1;\\n        long sum = 0;\\n        long currSum = 0;\\n        int ans = 0;\\n        int n =chargeTimes.length;\\n        Deque<Integer> dq = new ArrayDeque<>();\\n        for(int i=0;i<n;i++){\\n            while(!dq.isEmpty() && dq.peekFirst() < i)\\n                dq.pollFirst();\\n            j = Math.max(j,i-1);\\n            while(j+1<n){\\n                int mx= chargeTimes[j+1];\\n                if(!dq.isEmpty())mx = Math.max(mx,chargeTimes[dq.peekFirst()]);\\n                long ns = currSum + sum + (j+1 - i + 1L) * runningCosts[j+1];\\n                if(mx + ns <=budget){\\n                    while(!dq.isEmpty() && chargeTimes[dq.peekLast()] <= chargeTimes[j+1])dq.pollLast();\\n                    dq.addLast(++j);\\n                    currSum = ns;\\n                    sum += runningCosts[j];\\n                    ans = Math.max(ans,j-i+1);\\n+currSum+\" \"+mx);\\n                }else break;\\n            }\\n            if(j>=i){\\n                currSum -= sum ;\\n                currSum -=(j-i+0L)* runningCosts[i];\\n                sum -=runningCosts[i];\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue",
                    "Sliding Window",
                    "Doubly-Linked List",
                    "Monotonic Queue"
                ],
                "code": "```max(chargeTimes) + k * sum(runningCosts)```\n```max(chargeTimes)```\n```k * sum(runningCosts)```\n```mx```\n```sum```\n```currSum```\n```\\nclass Solution {\\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n        int j = -1;\\n        long sum = 0;\\n        long currSum = 0;\\n        int ans = 0;\\n        int n =chargeTimes.length;\\n        Deque<Integer> dq = new ArrayDeque<>();\\n        for(int i=0;i<n;i++){\\n            while(!dq.isEmpty() && dq.peekFirst() < i)\\n                dq.pollFirst();\\n            j = Math.max(j,i-1);\\n            while(j+1<n){\\n                int mx= chargeTimes[j+1];\\n                if(!dq.isEmpty())mx = Math.max(mx,chargeTimes[dq.peekFirst()]);\\n                long ns = currSum + sum + (j+1 - i + 1L) * runningCosts[j+1];\\n                if(mx + ns <=budget){\\n                    while(!dq.isEmpty() && chargeTimes[dq.peekLast()] <= chargeTimes[j+1])dq.pollLast();\\n                    dq.addLast(++j);\\n                    currSum = ns;\\n                    sum += runningCosts[j];\\n                    ans = Math.max(ans,j-i+1);\\n+currSum+\" \"+mx);\\n                }else break;\\n            }\\n            if(j>=i){\\n                currSum -= sum ;\\n                currSum -=(j-i+0L)* runningCosts[i];\\n                sum -=runningCosts[i];\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3638312,
                "title": "c-sliding-window-with-deque",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n       int start=0;\\n       long long sum=0;\\n        int ans=0;\\n        deque<int>dq;\\n        \\n        for(int end=0; end<chargeTimes.size(); end++){\\n            \\n            sum+=runningCosts[end];\\n            while(!dq.empty()&& chargeTimes[dq.back()]<=chargeTimes[end]) dq.pop_back();\\n            \\n            dq.push_back(end);\\n            //cout<<dq.size()<<endl;\\n            \\n            long long current_cost = chargeTimes[dq.front()]+ (end-start+1) * sum;\\n            \\n            while(current_cost>budget){\\n                \\n                sum-=runningCosts[start];\\n                //cout<<dq.front();\\n                if(dq.front()==start) dq.pop_front();\\n                                //cout<<dq.front();\\n\\n                \\n                start++;\\n                if(start>end){// to handle case we pop out the elements from queue\\n                    current_cost=0;\\n                }\\n                else{\\n                    current_cost = chargeTimes[dq.front()] + (end-start+1) * sum;\\n                }\\n                \\n            }\\n            \\n            ans=max(ans, end-start+1);\\n            \\n            \\n        }\\n        \\n        return ans;\\n            \\n            \\n            \\n        }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n       int start=0;\\n       long long sum=0;\\n        int ans=0;\\n        deque<int>dq;\\n        \\n        for(int end=0; end<chargeTimes.size(); end++){\\n            \\n            sum+=runningCosts[end];\\n            while(!dq.empty()&& chargeTimes[dq.back()]<=chargeTimes[end]) dq.pop_back();\\n            \\n            dq.push_back(end);\\n            //cout<<dq.size()<<endl;\\n            \\n            long long current_cost = chargeTimes[dq.front()]+ (end-start+1) * sum;\\n            \\n            while(current_cost>budget){\\n                \\n                sum-=runningCosts[start];\\n                //cout<<dq.front();\\n                if(dq.front()==start) dq.pop_front();\\n                                //cout<<dq.front();\\n\\n                \\n                start++;\\n                if(start>end){// to handle case we pop out the elements from queue\\n                    current_cost=0;\\n                }\\n                else{\\n                    current_cost = chargeTimes[dq.front()] + (end-start+1) * sum;\\n                }\\n                \\n            }\\n            \\n            ans=max(ans, end-start+1);\\n            \\n            \\n        }\\n        \\n        return ans;\\n            \\n            \\n            \\n        }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3634415,
                "title": "sliding-window-approach-easy-cpp-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& c, vector<int>& r, long long budget) {\\n    multiset<int>m;\\n\\n         long long  int i=0,j=0,ans=0; long long sum=0,count=0;\\n          while(j<c.size()){\\n              m.insert(c[j]);\\n              \\n                \\n              count+=r[j];\\n\\n             \\n                   sum= *m.rbegin()+(j-i+1)*count;\\n              if(sum>budget){\\n                  while(sum>budget && i<=j){\\n                    count-=r[i];\\n                     m.erase(m.find(c[i]));\\n                    \\n                     i++;\\n                      if(m.size()==0) sum=0;\\n                 else  sum= *m.rbegin()+(j-i+1) *count;\\n                    \\n                  }\\n              }\\n               ans=max(ans,j-i+1);\\n               j++;\\n          }\\n          return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& c, vector<int>& r, long long budget) {\\n    multiset<int>m;\\n\\n         long long  int i=0,j=0,ans=0; long long sum=0,count=0;\\n          while(j<c.size()){\\n              m.insert(c[j]);\\n              \\n                \\n              count+=r[j];\\n\\n             \\n                   sum= *m.rbegin()+(j-i+1)*count;\\n              if(sum>budget){\\n                  while(sum>budget && i<=j){\\n                    count-=r[i];\\n                     m.erase(m.find(c[i]));\\n                    \\n                     i++;\\n                      if(m.size()==0) sum=0;\\n                 else  sum= *m.rbegin()+(j-i+1) *count;\\n                    \\n                  }\\n              }\\n               ans=max(ans,j-i+1);\\n               j++;\\n          }\\n          return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605110,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\n//very similar to sliding window maximum problem\\n//main approach of this problem is monotonic queue for the maximum of a particular range as in sliding window maximum problem\\n\\n//first i did it with brute force,to check whether the logic was correct\\n//then optimized the approach of finding maximum\\n//seems like a better way of doing tough problems\\nclass Solution \\n{\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) \\n    {\\n        int i,n,l,r,ans;\\n        n=chargeTimes.size();\\n        ans=0;\\n\\n        long long sum;\\n        deque<int> mx;\\n        vector<long long> pre(n+1);\\n        pre[0]=0;\\n\\n        for(l=0,r=1;r<=n;r++)\\n        {\\n            while(mx.size() && chargeTimes[r-1]>chargeTimes[mx.back()])\\n            {\\n                mx.pop_back();\\n            }\\n            if(mx.size() && mx.front()<l)\\n            {\\n                mx.pop_front();\\n            }\\n            mx.push_back(r-1);\\n\\n            pre[r]=pre[r-1]+runningCosts[r-1];\\n            sum=(pre[r]-pre[l])*(r-l)+chargeTimes[mx.front()];\\n\\n            if(sum<=budget)\\n            {\\n                ans=max(ans,r-l);\\n            }\\n            else\\n            {\\n                l++;\\n            }\\n        }\\n\\n        return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//very similar to sliding window maximum problem\\n//main approach of this problem is monotonic queue for the maximum of a particular range as in sliding window maximum problem\\n\\n//first i did it with brute force,to check whether the logic was correct\\n//then optimized the approach of finding maximum\\n//seems like a better way of doing tough problems\\nclass Solution \\n{\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) \\n    {\\n        int i,n,l,r,ans;\\n        n=chargeTimes.size();\\n        ans=0;\\n\\n        long long sum;\\n        deque<int> mx;\\n        vector<long long> pre(n+1);\\n        pre[0]=0;\\n\\n        for(l=0,r=1;r<=n;r++)\\n        {\\n            while(mx.size() && chargeTimes[r-1]>chargeTimes[mx.back()])\\n            {\\n                mx.pop_back();\\n            }\\n            if(mx.size() && mx.front()<l)\\n            {\\n                mx.pop_front();\\n            }\\n            mx.push_back(r-1);\\n\\n            pre[r]=pre[r-1]+runningCosts[r-1];\\n            sum=(pre[r]-pre[l])*(r-l)+chargeTimes[mx.front()];\\n\\n            if(sum<=budget)\\n            {\\n                ans=max(ans,r-l);\\n            }\\n            else\\n            {\\n                l++;\\n            }\\n        }\\n\\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3593055,
                "title": "python-easy-to-understand-o-n-log-n-sliding-window-maximum-and-binary-search",
                "content": "# Intuition\\nIf we fix a $k$, the problem is really similar to [239. Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/). So basically we just need to solve this auxiliary problem for the *chargeTimes* array, keeping the current window sum to compute the window total cost.\\n\\nThe problem now becomes how to find a candidate $k$. Linear search could be employed, but that would lead to quadratic time complexity, hence we rely on binary search to find the optimal candidate in logarithmic time.\\n\\n---\\n\\n# Approach\\nUse binary search to find the optimal $k$. For each candidate, check if we can build a valid window in linear time, using the sliding window maximum algorithm.\\n\\n---\\n\\n\\n# Complexity\\nLet $n$ bet the lenght of the array.\\n\\n### Time complexity\\nGiven a $k$, we can find if a valid window exists in $O(n)$ using a deque to solve the sliding window maximum problem. \\n\\nFinding the optimal $k$ costs $\\\\log(n)$, as we need to binary search the answer between $0$ and $n$.\\n\\n### Space complexity\\nSpace is used only to keep the deque in the sliding window computation, that window could potentially be $O(n)$ long for large $k$ values.\\n\\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\\n        \\n        N = len(runningCosts)\\n\\n        def compute(k):\\n            l = r = curr_sum = max_win_val = 0\\n            d = deque()\\n\\n            while r < N:\\n                # update deque storing max value of window\\n                while d and chargeTimes[d[-1]] < chargeTimes[r]:\\n                    d.pop()\\n                d.append(r)\\n                if l > d[0]:\\n                    d.popleft()\\n\\n                # update window sum\\n                curr_sum += runningCosts[r]\\n                \\n                # if this is a valid window\\n                # compute answer\\n                if r >= k-1:\\n                    max_win_val = chargeTimes[d[0]]\\n                    if (max_win_val + k * curr_sum) <= budget:\\n                        return True\\n                    curr_sum -= runningCosts[l]\\n                    l += 1\\n                r += 1\\n\\n            return False\\n\\n        # binary search the answer\\n        i, j = 0, N\\n        ans = 0\\n        while i <= j:\\n            m = (i + j) // 2\\n            if compute(m):\\n                ans = m\\n                i = m + 1\\n            else:\\n                j = m-1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Sliding Window",
                    "Monotonic Queue"
                ],
                "code": "```\\nclass Solution:\\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\\n        \\n        N = len(runningCosts)\\n\\n        def compute(k):\\n            l = r = curr_sum = max_win_val = 0\\n            d = deque()\\n\\n            while r < N:\\n                # update deque storing max value of window\\n                while d and chargeTimes[d[-1]] < chargeTimes[r]:\\n                    d.pop()\\n                d.append(r)\\n                if l > d[0]:\\n                    d.popleft()\\n\\n                # update window sum\\n                curr_sum += runningCosts[r]\\n                \\n                # if this is a valid window\\n                # compute answer\\n                if r >= k-1:\\n                    max_win_val = chargeTimes[d[0]]\\n                    if (max_win_val + k * curr_sum) <= budget:\\n                        return True\\n                    curr_sum -= runningCosts[l]\\n                    l += 1\\n                r += 1\\n\\n            return False\\n\\n        # binary search the answer\\n        i, j = 0, N\\n        ans = 0\\n        while i <= j:\\n            m = (i + j) // 2\\n            if compute(m):\\n                ans = m\\n                i = m + 1\\n            else:\\n                j = m-1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572340,
                "title": "sliding-window-treemap-java-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n        int n = chargeTimes.length;\\n        TreeMap<Integer,Integer> map= new TreeMap<>();\\n        long maxScore = 0;\\n        int robots = 0;\\n        int i=0,j=0;\\n        long sum = 0;\\n        while(j<n){\\n            if(maxScore>budget){\\n                sum -= runningCosts[i]*1L;\\n                if(map.get(chargeTimes[i])>1) map.put(chargeTimes[i],map.getOrDefault(chargeTimes[i],0)-1);\\n                else map.remove(chargeTimes[i]);\\n                i++;\\n            }\\n            map.put(chargeTimes[j],map.getOrDefault(chargeTimes[j],0)+1);\\n            sum += runningCosts[j]*1L;\\n            maxScore = sum*(j-i+1)*1L + map.lastKey()*1L;\\n            if(maxScore<=budget) robots = Math.max(robots,(j-i+1));\\n            j++;\\n        }\\n        return robots;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sliding Window",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n        int n = chargeTimes.length;\\n        TreeMap<Integer,Integer> map= new TreeMap<>();\\n        long maxScore = 0;\\n        int robots = 0;\\n        int i=0,j=0;\\n        long sum = 0;\\n        while(j<n){\\n            if(maxScore>budget){\\n                sum -= runningCosts[i]*1L;\\n                if(map.get(chargeTimes[i])>1) map.put(chargeTimes[i],map.getOrDefault(chargeTimes[i],0)-1);\\n                else map.remove(chargeTimes[i]);\\n                i++;\\n            }\\n            map.put(chargeTimes[j],map.getOrDefault(chargeTimes[j],0)+1);\\n            sum += runningCosts[j]*1L;\\n            maxScore = sum*(j-i+1)*1L + map.lastKey()*1L;\\n            if(maxScore<=budget) robots = Math.max(robots,(j-i+1));\\n            j++;\\n        }\\n        return robots;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555817,
                "title": "java-sliding-window-100-tc",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n        int left=0;\\n        long currentMax = chargeTimes[0];\\n        long currentSum = 0;\\n        int maxRobots = 0;\\n        long currentBudget=0;\\n       for(int end =0 ; end < chargeTimes.length;end++)\\n       {\\n            currentSum += runningCosts[end];\\n            currentMax = Math.max(currentMax, chargeTimes[end]);          \\n            currentBudget = currentMax + (end-left+1)*currentSum;\\n            if(currentBudget <= budget)\\n            {\\n                maxRobots = Math.max( maxRobots,end-left+1);\\n            }\\n            if(currentBudget > budget)\\n            {               \\n                currentSum -= runningCosts[left];\\n                currentMax=0;\\n                for(int i = left+1;i <= end ;i++)\\n                {\\n                currentMax = Math.max(currentMax, chargeTimes[i]);\\n                }\\n               \\n                left++;    \\n                currentBudget = currentMax + (end-left+1)*currentSum;\\n                \\n            }\\n           \\n            \\n       }\\n\\n       return maxRobots; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n        int left=0;\\n        long currentMax = chargeTimes[0];\\n        long currentSum = 0;\\n        int maxRobots = 0;\\n        long currentBudget=0;\\n       for(int end =0 ; end < chargeTimes.length;end++)\\n       {\\n            currentSum += runningCosts[end];\\n            currentMax = Math.max(currentMax, chargeTimes[end]);          \\n            currentBudget = currentMax + (end-left+1)*currentSum;\\n            if(currentBudget <= budget)\\n            {\\n                maxRobots = Math.max( maxRobots,end-left+1);\\n            }\\n            if(currentBudget > budget)\\n            {               \\n                currentSum -= runningCosts[left];\\n                currentMax=0;\\n                for(int i = left+1;i <= end ;i++)\\n                {\\n                currentMax = Math.max(currentMax, chargeTimes[i]);\\n                }\\n               \\n                left++;    \\n                currentBudget = currentMax + (end-left+1)*currentSum;\\n                \\n            }\\n           \\n            \\n       }\\n\\n       return maxRobots; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476233,
                "title": "sliding-window",
                "content": "# Intuition Sliding window \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach  Sliding window \\n<!-- Describe your approach to solving the problem. -->\\nTo get the maximum for a given range (i , i + 1 .. .j) use multiset\\nbecause last element of it is the largest one while shrinking the window erase the value which goes outside of the window .\\n\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& ct, vector<int>& rc, long long budget) {\\n\\n       // sliding window // \\n       //       j               \\n       //   i                        // max at given range (i .. j)  // prefix_sum array \\n       // 3 6 1 3 4 // \\n       // 2 1 3 4 5 //\\n\\n\\n\\n          int n  =  ct.size();\\n          multiset<int>ms ;\\n        //   vector<long long int>prefix(n+1) ;\\n          long long sum = 0  ;\\n          int  i = 0 ;\\n          int  j = 0 ;\\n          int  len = 0 ;\\n          while(j < n)\\n          { \\n              ms.insert(ct[j]) ;\\n              sum += rc[j] ;\\n\\n              long long temp = *(--ms.end()) +  (j - i + 1) * (sum) ;\\n               if(temp <= budget)\\n               {\\n                   len = max(len , j - i + 1) ;\\n               }\\n               //cout << temp << endl;\\n               \\n\\n               while(i < j and temp > budget)\\n               {\\n                    sum -= rc[i] ;\\n                    ms.erase(ms.find(ct[i]));\\n                    i++ ;\\n                    temp = *(--ms.end()) +  (j - i + 1) * (sum) ;\\n                      if(temp <= budget)\\n                      {\\n                         len = max(len , j - i + 1) ;\\n                      }\\n\\n               }\\n                \\n               j++;\\n                         \\n          }\\n   \\nreturn len ;\\n\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& ct, vector<int>& rc, long long budget) {\\n\\n       // sliding window // \\n       //       j               \\n       //   i                        // max at given range (i .. j)  // prefix_sum array \\n       // 3 6 1 3 4 // \\n       // 2 1 3 4 5 //\\n\\n\\n\\n          int n  =  ct.size();\\n          multiset<int>ms ;\\n        //   vector<long long int>prefix(n+1) ;\\n          long long sum = 0  ;\\n          int  i = 0 ;\\n          int  j = 0 ;\\n          int  len = 0 ;\\n          while(j < n)\\n          { \\n              ms.insert(ct[j]) ;\\n              sum += rc[j] ;\\n\\n              long long temp = *(--ms.end()) +  (j - i + 1) * (sum) ;\\n               if(temp <= budget)\\n               {\\n                   len = max(len , j - i + 1) ;\\n               }\\n               //cout << temp << endl;\\n               \\n\\n               while(i < j and temp > budget)\\n               {\\n                    sum -= rc[i] ;\\n                    ms.erase(ms.find(ct[i]));\\n                    i++ ;\\n                    temp = *(--ms.end()) +  (j - i + 1) * (sum) ;\\n                      if(temp <= budget)\\n                      {\\n                         len = max(len , j - i + 1) ;\\n                      }\\n\\n               }\\n                \\n               j++;\\n                         \\n          }\\n   \\nreturn len ;\\n\\n\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3418063,
                "title": "javascript-sliding-window",
                "content": "```\\n/**\\n * @param {number[]} chargeTimes\\n * @param {number[]} runningCosts\\n * @param {number} budget\\n * @return {number}\\n */\\nvar maximumRobots = function(chargeTimes, runningCosts, budget) {\\n  const queue = [];\\n  const n = chargeTimes.length;\\n  let [l, r, j, sum] = [0, -1, 0, 0];\\n\\n  for (let i = 0; i < n; i++) {\\n    sum += runningCosts[i];\\n    while (l <= r && chargeTimes[queue[r]] <= chargeTimes[i]) r--;\\n\\n    queue[++r] = i;\\n\\n    if (l <= r && chargeTimes[queue[l]] + (i - j + 1) * sum > budget) {\\n      if (queue[l] === j) l++;\\n      \\n      sum -= runningCosts[j++];\\n    }\\n  }\\n\\n  return n - j;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} chargeTimes\\n * @param {number[]} runningCosts\\n * @param {number} budget\\n * @return {number}\\n */\\nvar maximumRobots = function(chargeTimes, runningCosts, budget) {\\n  const queue = [];\\n  const n = chargeTimes.length;\\n  let [l, r, j, sum] = [0, -1, 0, 0];\\n\\n  for (let i = 0; i < n; i++) {\\n    sum += runningCosts[i];\\n    while (l <= r && chargeTimes[queue[r]] <= chargeTimes[i]) r--;\\n\\n    queue[++r] = i;\\n\\n    if (l <= r && chargeTimes[queue[l]] + (i - j + 1) * sum > budget) {\\n      if (queue[l] === j) l++;\\n      \\n      sum -= runningCosts[j++];\\n    }\\n  }\\n\\n  return n - j;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3410400,
                "title": "java-easy-solution-sliding-window-monotonic-deque-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimilar to sliding window maximum\\nacquire and release approach\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n        Deque<Integer>ct = new ArrayDeque<>();\\n        long maxRobots=0;\\n        int s=0,e=0;\\n        long sum=0;\\n        for(e=0;e<chargeTimes.length;e++){\\n            while(!ct.isEmpty()&&ct.peekLast()<chargeTimes[e]){\\n                    ct.pollLast();\\n            }\\n            ct.offerLast(chargeTimes[e]);\\n            sum+=runningCosts[e];\\n\\n            long cost=ct.peekFirst()+(e-s+1)*sum;               \\n            \\n                while(!ct.isEmpty()&&(ct.peekFirst()+sum*(e-s+1))>budget)\\n            {\\n                      sum-=runningCosts[s];\\n                if(ct.peekFirst()==chargeTimes[s]){\\n                    ct.pollFirst();\\n                }                \\n                s++;\\n            }\\n            \\n             maxRobots=Math.max(maxRobots, e-s+1);\\n          \\n        }\\n\\n        return (int)maxRobots;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window",
                    "Monotonic Queue"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n        Deque<Integer>ct = new ArrayDeque<>();\\n        long maxRobots=0;\\n        int s=0,e=0;\\n        long sum=0;\\n        for(e=0;e<chargeTimes.length;e++){\\n            while(!ct.isEmpty()&&ct.peekLast()<chargeTimes[e]){\\n                    ct.pollLast();\\n            }\\n            ct.offerLast(chargeTimes[e]);\\n            sum+=runningCosts[e];\\n\\n            long cost=ct.peekFirst()+(e-s+1)*sum;               \\n            \\n                while(!ct.isEmpty()&&(ct.peekFirst()+sum*(e-s+1))>budget)\\n            {\\n                      sum-=runningCosts[s];\\n                if(ct.peekFirst()==chargeTimes[s]){\\n                    ct.pollFirst();\\n                }                \\n                s++;\\n            }\\n            \\n             maxRobots=Math.max(maxRobots, e-s+1);\\n          \\n        }\\n\\n        return (int)maxRobots;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384144,
                "title": "python3-binary-search-sliding-window-maximum-approach",
                "content": "```\\nclass Solution:\\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\\n        \\n        def is_within_budget(chargeTimes: List[int], runningCosts: List[int], budget: int, k: int) -> bool:\\n            \\n            current_running_cost, max_queue = 0, deque()\\n            \\n            for i in range(k):\\n                current_running_cost += runningCosts[i]\\n                while max_queue and chargeTimes[max_queue[-1]] <= chargeTimes[i]:\\n                    max_queue.pop()\\n                max_queue.append(i)\\n               \\n            for i in range(k, len(chargeTimes)):\\n                if chargeTimes[max_queue[0]] + k * current_running_cost <= budget:\\n                    return True\\n                \\n                current_running_cost += runningCosts[i]\\n                current_running_cost -= runningCosts[i - k]\\n                \\n                while max_queue and max_queue[0] <= i - k:\\n                    max_queue.popleft()\\n                while max_queue and chargeTimes[max_queue[-1]] <= chargeTimes[i]:\\n                    max_queue.pop()\\n                max_queue.append(i)\\n                \\n            return chargeTimes[max_queue[0]] + k * current_running_cost <= budget\\n            \\n                \\n        n = len(chargeTimes)\\n        start, end, ans = 1, n, 0\\n        \\n        while start <= end:\\n            mid = (start + end) // 2\\n            \\n            if is_within_budget(chargeTimes, runningCosts, budget, mid):\\n                ans = mid\\n                start = mid + 1\\n            else:\\n                end = mid - 1\\n        return ans\\n        \\n```\\n\\nTime complexity :- `O(N * log N)` where N is the number of elements in the array and our search space is within [1, N].\\n\\nSpace Complexity :- `O(N)` for using the deque.",
                "solutionTags": [
                    "Python3",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\\n        \\n        def is_within_budget(chargeTimes: List[int], runningCosts: List[int], budget: int, k: int) -> bool:\\n            \\n            current_running_cost, max_queue = 0, deque()\\n            \\n            for i in range(k):\\n                current_running_cost += runningCosts[i]\\n                while max_queue and chargeTimes[max_queue[-1]] <= chargeTimes[i]:\\n                    max_queue.pop()\\n                max_queue.append(i)\\n               \\n            for i in range(k, len(chargeTimes)):\\n                if chargeTimes[max_queue[0]] + k * current_running_cost <= budget:\\n                    return True\\n                \\n                current_running_cost += runningCosts[i]\\n                current_running_cost -= runningCosts[i - k]\\n                \\n                while max_queue and max_queue[0] <= i - k:\\n                    max_queue.popleft()\\n                while max_queue and chargeTimes[max_queue[-1]] <= chargeTimes[i]:\\n                    max_queue.pop()\\n                max_queue.append(i)\\n                \\n            return chargeTimes[max_queue[0]] + k * current_running_cost <= budget\\n            \\n                \\n        n = len(chargeTimes)\\n        start, end, ans = 1, n, 0\\n        \\n        while start <= end:\\n            mid = (start + end) // 2\\n            \\n            if is_within_budget(chargeTimes, runningCosts, budget, mid):\\n                ans = mid\\n                start = mid + 1\\n            else:\\n                end = mid - 1\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345830,
                "title": "c-sliding-window-with-priority-queue",
                "content": "# Intuition\\nSince we are looking for continues set of robots sliding window solution should work.\\n\\n# Approach\\nKey here is to find max value from window of size K in const time. for that we will keep priority queue of pairs (value, index). When we need to reduce budget window size all we need to make sure is that top of the queue is still inside our window.\\n\\nRest is simple, we are incrementaly updating budget one robot at a time. If we don\\'t fit budget we start kicking robots from window until we fit into budget again or window size shrinks to 0.\\n\\n# Complexity\\n- Time complexity:\\nO(n*k) we need to walk all element once and we need to update window k elements in worst case.\\n\\n- Space complexity:\\nO(n) in worst case, all elements will be in the queue.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        int maxK = 0;\\n        int k = 0;\\n        \\n        long long curRunCostSum = 0;\\n\\n        priority_queue<pair<int, int>> chargeTimeQ; // charge cost, index\\n\\n        for (int i = 0;i < chargeTimes.size();i ++) {\\n            int chargeT = chargeTimeQ.empty() ? chargeT = chargeTimes[i] : chargeT = max(chargeTimeQ.top().first, chargeTimes[i]);\\n\\n            long long newBudget = chargeT + (k + 1)*(curRunCostSum + runningCosts[i]);\\n            if (newBudget > budget) {\\n                for (int j = i - k; j < i;j ++) {\\n                    while (!chargeTimeQ.empty() && chargeTimeQ.top().second <= j) {\\n                        chargeTimeQ.pop();\\n                    }\\n                    curRunCostSum -= runningCosts[j];\\n                    k --;\\n                    \\n                    chargeT = chargeTimeQ.empty() ? chargeT = chargeTimes[i] : chargeT = max(chargeTimeQ.top().first, chargeTimes[i]);\\n                    newBudget = chargeT + (k + 1)*(curRunCostSum + runningCosts[i]);\\n                    if (newBudget <= budget) {\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            k ++;\\n\\n            if (newBudget <= budget) {\\n                maxK = max(maxK, k);\\n            }\\n\\n            curRunCostSum += runningCosts[i];\\n            chargeTimeQ.push( {chargeTimes[i], i});\\n        }      \\n\\n        return maxK;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        int maxK = 0;\\n        int k = 0;\\n        \\n        long long curRunCostSum = 0;\\n\\n        priority_queue<pair<int, int>> chargeTimeQ; // charge cost, index\\n\\n        for (int i = 0;i < chargeTimes.size();i ++) {\\n            int chargeT = chargeTimeQ.empty() ? chargeT = chargeTimes[i] : chargeT = max(chargeTimeQ.top().first, chargeTimes[i]);\\n\\n            long long newBudget = chargeT + (k + 1)*(curRunCostSum + runningCosts[i]);\\n            if (newBudget > budget) {\\n                for (int j = i - k; j < i;j ++) {\\n                    while (!chargeTimeQ.empty() && chargeTimeQ.top().second <= j) {\\n                        chargeTimeQ.pop();\\n                    }\\n                    curRunCostSum -= runningCosts[j];\\n                    k --;\\n                    \\n                    chargeT = chargeTimeQ.empty() ? chargeT = chargeTimes[i] : chargeT = max(chargeTimeQ.top().first, chargeTimes[i]);\\n                    newBudget = chargeT + (k + 1)*(curRunCostSum + runningCosts[i]);\\n                    if (newBudget <= budget) {\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            k ++;\\n\\n            if (newBudget <= budget) {\\n                maxK = max(maxK, k);\\n            }\\n\\n            curRunCostSum += runningCosts[i];\\n            chargeTimeQ.push( {chargeTimes[i], i});\\n        }      \\n\\n        return maxK;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312588,
                "title": "c-o-n-solution-sliding-window-monotonic-deque",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        int n = runningCosts.size();\\n        long long totalCost = 0;\\n        int ans = 0;\\n        int left = 0;\\n        long long  sum = 0;\\n        deque<int> dq;\\n        \\n        for(int right = 0; right < n; right++) {\\n            while(!dq.empty() && chargeTimes[dq.back()] < chargeTimes[right]) {\\n                dq.pop_back();\\n            }\\n            dq.push_back(right);\\n            sum += runningCosts[right];\\n            int maxChargeTime = chargeTimes[dq.front()];\\n            totalCost = maxChargeTime + (right - left + 1) * sum;\\n            while(totalCost > budget) {\\n                sum -= runningCosts[left];\\n                if(left == dq.front() ) dq.pop_front();\\n                maxChargeTime = dq.empty()? 0 : chargeTimes[dq.front()];\\n                left++;\\n                totalCost = maxChargeTime + (right - left + 1) * sum;\\n                \\n            } \\n            ans = max(ans, right - left + 1);\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        int n = runningCosts.size();\\n        long long totalCost = 0;\\n        int ans = 0;\\n        int left = 0;\\n        long long  sum = 0;\\n        deque<int> dq;\\n        \\n        for(int right = 0; right < n; right++) {\\n            while(!dq.empty() && chargeTimes[dq.back()] < chargeTimes[right]) {\\n                dq.pop_back();\\n            }\\n            dq.push_back(right);\\n            sum += runningCosts[right];\\n            int maxChargeTime = chargeTimes[dq.front()];\\n            totalCost = maxChargeTime + (right - left + 1) * sum;\\n            while(totalCost > budget) {\\n                sum -= runningCosts[left];\\n                if(left == dq.front() ) dq.pop_front();\\n                maxChargeTime = dq.empty()? 0 : chargeTimes[dq.front()];\\n                left++;\\n                totalCost = maxChargeTime + (right - left + 1) * sum;\\n                \\n            } \\n            ans = max(ans, right - left + 1);\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3305734,
                "title": "c-sliding-window-segment-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can use sliding window to keep track of the maximum number of  consecutive robots. \\nFor each window, we can calculate the maximum using segment trees and calculate the sum using prefix sum.\\n\\n# Code\\n```\\nclass Solution {\\n    vector<int> tree;\\n    int n;\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        n = chargeTimes.size();\\n\\n        int treeSize = n;\\n        while(__builtin_popcount(treeSize) != 1) {\\n            treeSize++;\\n        }\\n        tree.resize(treeSize*2);\\n\\n        //build tree\\n        for (int i = 0; i < n; i++) {\\n            tree[treeSize+i] = chargeTimes[i];\\n        }\\n        for (int i = treeSize-1; i >= 1; i--) {\\n            tree[i] = max(tree[i*2], tree[i*2+1]);\\n        }\\n\\n        int res = 0;\\n        int l = 0;\\n        long long pre = 0;\\n        for (int r = 0; r < n; r++) {\\n            pre += runningCosts[r];\\n            long long cost = findMax(l, r, 1, 0, treeSize-1) + (r - l + 1) * pre;\\n            while( cost > budget ) {\\n                pre -= runningCosts[l];\\n                l++;\\n                cost = findMax(l, r, 1, 0, treeSize-1) + (r - l + 1) * pre;\\n            }\\n\\n            res = max(res, (r - l + 1));\\n        }\\n\\n        return res;\\n    }\\n\\n    int findMax(int l, int r, int node, int nodeLow, int nodeHigh) {\\n        if (l <= nodeLow && nodeHigh <= r) {\\n            return tree[node];\\n        }\\n\\n        if (r < nodeLow || nodeHigh < l) {\\n            return 0;\\n        }\\n\\n        int m = nodeLow + (nodeHigh - nodeLow) / 2;\\n        return max(findMax(l, r, node*2, nodeLow, m), findMax(l, r, node*2+1, m+1, nodeHigh));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> tree;\\n    int n;\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        n = chargeTimes.size();\\n\\n        int treeSize = n;\\n        while(__builtin_popcount(treeSize) != 1) {\\n            treeSize++;\\n        }\\n        tree.resize(treeSize*2);\\n\\n        //build tree\\n        for (int i = 0; i < n; i++) {\\n            tree[treeSize+i] = chargeTimes[i];\\n        }\\n        for (int i = treeSize-1; i >= 1; i--) {\\n            tree[i] = max(tree[i*2], tree[i*2+1]);\\n        }\\n\\n        int res = 0;\\n        int l = 0;\\n        long long pre = 0;\\n        for (int r = 0; r < n; r++) {\\n            pre += runningCosts[r];\\n            long long cost = findMax(l, r, 1, 0, treeSize-1) + (r - l + 1) * pre;\\n            while( cost > budget ) {\\n                pre -= runningCosts[l];\\n                l++;\\n                cost = findMax(l, r, 1, 0, treeSize-1) + (r - l + 1) * pre;\\n            }\\n\\n            res = max(res, (r - l + 1));\\n        }\\n\\n        return res;\\n    }\\n\\n    int findMax(int l, int r, int node, int nodeLow, int nodeHigh) {\\n        if (l <= nodeLow && nodeHigh <= r) {\\n            return tree[node];\\n        }\\n\\n        if (r < nodeLow || nodeHigh < l) {\\n            return 0;\\n        }\\n\\n        int m = nodeLow + (nodeHigh - nodeLow) / 2;\\n        return max(findMax(l, r, node*2, nodeLow, m), findMax(l, r, node*2+1, m+1, nodeHigh));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284759,
                "title": "c-concise-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        int l=0, r=1+chargeTimes.size();\\n        while(l+1<r){\\n            auto mid = (l+r)/2;\\n            able(chargeTimes, runningCosts, budget, mid) ? l = mid : r = mid;\\n        }\\n        return l;\\n    }\\n\\n    bool able(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget, int k){\\n        map<int, int, greater<int>> m;\\n        long long sum = 0;\\n        for(int i=0;i<chargeTimes.size();i++){\\n            sum += runningCosts[i];\\n            m[chargeTimes[i]]++;\\n            if(i>=k){\\n                sum -= runningCosts[i-k];\\n                auto it = m.find(chargeTimes[i-k]);\\n                if(--it->second == 0) m.erase(it);\\n            }\\n            if(i>=k-1 && sum * k + m.begin()->first <= budget)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        int l=0, r=1+chargeTimes.size();\\n        while(l+1<r){\\n            auto mid = (l+r)/2;\\n            able(chargeTimes, runningCosts, budget, mid) ? l = mid : r = mid;\\n        }\\n        return l;\\n    }\\n\\n    bool able(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget, int k){\\n        map<int, int, greater<int>> m;\\n        long long sum = 0;\\n        for(int i=0;i<chargeTimes.size();i++){\\n            sum += runningCosts[i];\\n            m[chargeTimes[i]]++;\\n            if(i>=k){\\n                sum -= runningCosts[i-k];\\n                auto it = m.find(chargeTimes[i-k]);\\n                if(--it->second == 0) m.erase(it);\\n            }\\n            if(i>=k-1 && sum * k + m.begin()->first <= budget)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281413,
                "title": "python-simple-sliding-window-sortedlist",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumRobots(self, chargeTimes, runningCosts, budget):\\n        from sortedcontainers import SortedList\\n\\n        running_sum, left, n, ans = 0, 0, len(chargeTimes), SortedList()\\n\\n        for right in range(n):\\n            running_sum += runningCosts[right]\\n            ans.add(chargeTimes[right])\\n            if ans[-1] + (right-left+1)*running_sum > budget:\\n                ans.remove(chargeTimes[left])\\n                running_sum -= runningCosts[left]\\n                left += 1\\n\\n        return n - left\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumRobots(self, chargeTimes, runningCosts, budget):\\n        from sortedcontainers import SortedList\\n\\n        running_sum, left, n, ans = 0, 0, len(chargeTimes), SortedList()\\n\\n        for right in range(n):\\n            running_sum += runningCosts[right]\\n            ans.add(chargeTimes[right])\\n            if ans[-1] + (right-left+1)*running_sum > budget:\\n                ans.remove(chargeTimes[left])\\n                running_sum -= runningCosts[left]\\n                left += 1\\n\\n        return n - left\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3250691,
                "title": "c-o-n-complexity-monotonic-deque-optimization",
                "content": "```c++\\nclass Solution {\\npublic:\\n    static int maximumRobots(\\n            const vector<int> &chargeTimes,\\n            const vector<int> &runningCosts,\\n            int64_t budget) {\\n        int n = chargeTimes.size();\\n        deque<int> dq;\\n\\n        int64_t sum = 0, ans = 0;\\n        for (int i = 0, j = 0; i < n;) {\\n            int ch = chargeTimes[i];\\n            sum += runningCosts[i];\\n            while (!dq.empty() && dq.back() < ch) dq.pop_back();\\n            dq.push_back(ch);\\n            ++i;\\n            for (; j < i; ++j) {\\n                assert(!dq.empty());\\n                int64_t t = sum * (i - j) + dq.front();\\n                out(j, i, t);\\n                if (t <= budget) break;\\n                sum -= runningCosts[j];\\n                if (dq.front() == chargeTimes[j]) dq.pop_front();\\n            }\\n            if (ans < i - j) ans = i - j;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    static int maximumRobots(\\n            const vector<int> &chargeTimes,\\n            const vector<int> &runningCosts,\\n            int64_t budget) {\\n        int n = chargeTimes.size();\\n        deque<int> dq;\\n\\n        int64_t sum = 0, ans = 0;\\n        for (int i = 0, j = 0; i < n;) {\\n            int ch = chargeTimes[i];\\n            sum += runningCosts[i];\\n            while (!dq.empty() && dq.back() < ch) dq.pop_back();\\n            dq.push_back(ch);\\n            ++i;\\n            for (; j < i; ++j) {\\n                assert(!dq.empty());\\n                int64_t t = sum * (i - j) + dq.front();\\n                out(j, i, t);\\n                if (t <= budget) break;\\n                sum -= runningCosts[j];\\n                if (dq.front() == chargeTimes[j]) dq.pop_front();\\n            }\\n            if (ans < i - j) ans = i - j;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222627,
                "title": "solution-using-binary-search-deque-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe simply try to search for window size as if we choose small size then it will show that we can choose these number of robots but if we choose high number than it will show that we cannot choose that number of robots is any scenerio .\\nSo we use binary search for that as\\n```\\n    0 1 2 3 4 5 6 7 8 9 ..\\n    T T T T T F F F F F F ...\\nWE HAVE TO FIND 4 SO WE TRY BINARY SEARCH FOR THAT\\n```\\n# Complexity\\n- Time complexity: O(NLogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& ch, vector<int>& runc, long long bd) {\\n        // deque<int> q;\\n        vector<long long int> prs(ch.size(),0);\\n        prs[0] = runc[0];\\n        for(int i=1;i<ch.size();i++){\\n            prs[i] = prs[i-1]+runc[i];\\n        }\\n        // Now we have sum pre counted\\n        int left = 1, right = ch.size();\\n        int ans = 0;\\n        while(left <= right){\\n            deque<int> q;\\n            int mid = left + (right - left)/2;\\n            long long bdk = 0;\\n            bool ist = 0;\\n            // first we choose a window of mid size\\n            int i=0;\\n            for(;i<mid;i++){\\n                while(!q.empty() && ch[q.back()] <= ch[i]) q.pop_back();\\n                q.push_back(i);\\n            }\\n            bdk = (ch[q.front()] + 1ll*(mid)*(prs[i-1]));\\n            if(bdk <= bd) ist = 1;\\n            while(i < ch.size() && (!ist)){\\n                // now we remove mid - i th element and then add i\\'th element\\n                // removing element\\n                while(!q.empty() && q.front() <= (i-mid)) q.pop_front();\\n                // adding element\\n                while(!q.empty() && ch[q.back()] <= ch[i]) q.pop_back();\\n                q.push_back(i);\\n                bdk = (ch[q.front()] + 1ll*(mid)*(prs[i]-prs[i-mid]));\\n                i++;\\n                if(bdk <= bd) ist = 1;\\n            }\\n            if(ist){\\n                left = mid + 1;\\n                ans = mid;\\n            }else{\\n                right = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    0 1 2 3 4 5 6 7 8 9 ..\\n    T T T T T F F F F F F ...\\nWE HAVE TO FIND 4 SO WE TRY BINARY SEARCH FOR THAT\\n```\n```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& ch, vector<int>& runc, long long bd) {\\n        // deque<int> q;\\n        vector<long long int> prs(ch.size(),0);\\n        prs[0] = runc[0];\\n        for(int i=1;i<ch.size();i++){\\n            prs[i] = prs[i-1]+runc[i];\\n        }\\n        // Now we have sum pre counted\\n        int left = 1, right = ch.size();\\n        int ans = 0;\\n        while(left <= right){\\n            deque<int> q;\\n            int mid = left + (right - left)/2;\\n            long long bdk = 0;\\n            bool ist = 0;\\n            // first we choose a window of mid size\\n            int i=0;\\n            for(;i<mid;i++){\\n                while(!q.empty() && ch[q.back()] <= ch[i]) q.pop_back();\\n                q.push_back(i);\\n            }\\n            bdk = (ch[q.front()] + 1ll*(mid)*(prs[i-1]));\\n            if(bdk <= bd) ist = 1;\\n            while(i < ch.size() && (!ist)){\\n                // now we remove mid - i th element and then add i\\'th element\\n                // removing element\\n                while(!q.empty() && q.front() <= (i-mid)) q.pop_front();\\n                // adding element\\n                while(!q.empty() && ch[q.back()] <= ch[i]) q.pop_back();\\n                q.push_back(i);\\n                bdk = (ch[q.front()] + 1ll*(mid)*(prs[i]-prs[i-mid]));\\n                i++;\\n                if(bdk <= bd) ist = 1;\\n            }\\n            if(ist){\\n                left = mid + 1;\\n                ans = mid;\\n            }else{\\n                right = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202517,
                "title": "java-sliding-window-prefixsum-segment-tree",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will use sliding window appraoch. \\nWe will have two pointers. Initially both of them (l, h) will point to index 0. \\nwe will add the index h to the window and caculate the `cost = sum(l, h) * length + max(l, h)`\\n\\nif the cost doesn\\'t exceed budget, we will increament h.\\nif it exceeds, we will increment `l`, `if (l == h)` we set `l = h = h+1`\\n\\nNow the problem is how efficently we find the sum and max b/w two limits.\\n\\nSum b/w two limits:\\nWe can use the prefix sum method to find the sum b/w given two index\\n\\nMax b/w two limits:\\nWe will use the segment tree to find the max b/w the given two index\\n\\n# Complexity\\nn - length of array\\n- Time complexity: $$O(n log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public class SegmentTree\\n    {\\n        public SegmentTree left, right;\\n        public int val, l, r;\\n        public SegmentTree(int l, int r)\\n        {\\n            this.l = l;\\n            this.r = r;\\n            if(l == r) return;\\n            var m = (l+r)/2;\\n            this.left = new SegmentTree(l, m);\\n            this.right = new SegmentTree(m+1, r);\\n        }\\n        public int insert(int ind, int v)\\n        {\\n            if(ind < l || ind > r) return val;\\n            if(l == r && l == ind)\\n            {\\n                this.val = v;\\n                return val;\\n            }\\n            var lval = left.insert(ind, v);\\n            var rval = right.insert(ind, v);\\n            this.val = Math.max(lval, rval);\\n            return this.val;\\n        }\\n        public int find(int s, int e)\\n        {\\n            if(e < l || r < s )\\n            {\\n                return 0;\\n            }\\n            if(s <= l && r <= e) return val;\\n            return Math.max(left.find(s, e), right.find(s, e) );\\n        }\\n    }\\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n        var l = 0;\\n        var h = 0;\\n        var ans = 0;\\n        var len = chargeTimes.length;\\n        var seg = new SegmentTree(0, len-1);\\n        var dp = new Long[len];\\n        for(int i = 0; i < len; i++)\\n        {\\n            dp[i] = ( i == 0 ? 0 : dp[i-1] ) + runningCosts[i];\\n            seg.insert(i, chargeTimes[i]);\\n        }\\n        while(h < len)\\n        {\\n            long temp =  ( dp[h] - dp[l] + runningCosts[l]) * (h-l+1) + seg.find(l, h);\\n            if(temp <= budget) \\n            {\\n                ans = Math.max(ans, (h-l+1) );\\n                h++;\\n            }\\n            else if(temp > budget)\\n            {\\n                if(l < h) l++;\\n                else if(l == h)\\n                {\\n                    h++;\\n                    l = h;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Segment Tree",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public class SegmentTree\\n    {\\n        public SegmentTree left, right;\\n        public int val, l, r;\\n        public SegmentTree(int l, int r)\\n        {\\n            this.l = l;\\n            this.r = r;\\n            if(l == r) return;\\n            var m = (l+r)/2;\\n            this.left = new SegmentTree(l, m);\\n            this.right = new SegmentTree(m+1, r);\\n        }\\n        public int insert(int ind, int v)\\n        {\\n            if(ind < l || ind > r) return val;\\n            if(l == r && l == ind)\\n            {\\n                this.val = v;\\n                return val;\\n            }\\n            var lval = left.insert(ind, v);\\n            var rval = right.insert(ind, v);\\n            this.val = Math.max(lval, rval);\\n            return this.val;\\n        }\\n        public int find(int s, int e)\\n        {\\n            if(e < l || r < s )\\n            {\\n                return 0;\\n            }\\n            if(s <= l && r <= e) return val;\\n            return Math.max(left.find(s, e), right.find(s, e) );\\n        }\\n    }\\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n        var l = 0;\\n        var h = 0;\\n        var ans = 0;\\n        var len = chargeTimes.length;\\n        var seg = new SegmentTree(0, len-1);\\n        var dp = new Long[len];\\n        for(int i = 0; i < len; i++)\\n        {\\n            dp[i] = ( i == 0 ? 0 : dp[i-1] ) + runningCosts[i];\\n            seg.insert(i, chargeTimes[i]);\\n        }\\n        while(h < len)\\n        {\\n            long temp =  ( dp[h] - dp[l] + runningCosts[l]) * (h-l+1) + seg.find(l, h);\\n            if(temp <= budget) \\n            {\\n                ans = Math.max(ans, (h-l+1) );\\n                h++;\\n            }\\n            else if(temp > budget)\\n            {\\n                if(l < h) l++;\\n                else if(l == h)\\n                {\\n                    h++;\\n                    l = h;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185388,
                "title": "java-simple-clean-for-interviews-sliding-window",
                "content": "# Intuition\\nIf closely observe, what do we need:\\n- Consecutive and non-negative numbers then its a good candidate for Sliding Window.\\n- Instead of k we have to shrink on the basis of budget.\\n- While shrinking we need index (windowStart) & max chargeTimes(TreeSet).\\n\\n# Approach\\nInstead of chargeTimesValues will keep chargeTimesIndices in TreeSet as duplicates are also possible.\\n\\nSimilar to https://leetcode.com/problems/sliding-window-maximum/\\nExcept now instead of maxSum we need maxLength...\\n\\n# Complexity\\nb is the budget\\n- Time complexity:\\nO(nlogb)  ~O(nlogn)\\n\\n- Space complexity:\\nO(b)  ~O(n)\\n\\n**Please upvote if you find useful..thanks for dropping-by... :-)**\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n        TreeSet<Integer> idxSet=new TreeSet<>(\\n        (a,b)->chargeTimes[a] == chargeTimes[b] ? a-b : \\n        chargeTimes[b]-chargeTimes[a]); //max index set, sorted on chargeTimes value\\n        int n=chargeTimes.length;\\n        int max=0;\\n        int windowStart=0;\\n        long sum=0;\\n\\n        for(int windowEnd=0; windowEnd<n; windowEnd++) {\\n            sum += runningCosts[windowEnd];\\n            idxSet.add(windowEnd);\\n\\n            if(sum*(windowEnd-windowStart+1)*1L + chargeTimes[idxSet.first()]*1L > budget) { //shrink\\n                int startCost=runningCosts[windowStart];\\n                idxSet.remove(windowStart++);\\n                sum -= startCost;\\n            }\\n            max=Math.max(max,windowEnd-windowStart+1); //capture candidate\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n        TreeSet<Integer> idxSet=new TreeSet<>(\\n        (a,b)->chargeTimes[a] == chargeTimes[b] ? a-b : \\n        chargeTimes[b]-chargeTimes[a]); //max index set, sorted on chargeTimes value\\n        int n=chargeTimes.length;\\n        int max=0;\\n        int windowStart=0;\\n        long sum=0;\\n\\n        for(int windowEnd=0; windowEnd<n; windowEnd++) {\\n            sum += runningCosts[windowEnd];\\n            idxSet.add(windowEnd);\\n\\n            if(sum*(windowEnd-windowStart+1)*1L + chargeTimes[idxSet.first()]*1L > budget) { //shrink\\n                int startCost=runningCosts[windowStart];\\n                idxSet.remove(windowStart++);\\n                sum -= startCost;\\n            }\\n            max=Math.max(max,windowEnd-windowStart+1); //capture candidate\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3183041,
                "title": "java-solution-using-sliding-window-without-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    class Pair implements Comparable<Pair>{\\n        int idx; int val;\\n        Pair(int idx, int val){\\n            this.idx=idx; this.val=val;\\n        }\\n        public int compareTo(Pair p){\\n            return p.val-this.val;\\n        }\\n    }\\n\\n    public int maximumRobots(int[] chargeTimes, int[] running, long budget) {\\n        int n=chargeTimes.length;\\n        long runningCosts[] = new long[n];\\n        runningCosts[0]=running[0];\\n        for(int i=1; i<n; i++){\\n            runningCosts[i]+=(runningCosts[i-1]+running[i]);\\n        }\\n        int ans = 0;    int left=0;\\n\\n        PriorityQueue<Pair> pq = new PriorityQueue<>();\\n        for(int right=0; right<n; right++){\\n            pq.add(new Pair(right,chargeTimes[right]));\\n            int k = (right-left+1);\\n            long val = runningCosts[right];\\n            if(left-1>=0) val-=runningCosts[left-1];\\n            val*=k;\\n\\n            int max = -1;\\n            while(!pq.isEmpty() && pq.peek().idx<left){\\n                pq.poll();\\n            }\\n            val+=pq.peek().val;\\n\\n            if(val<=budget){\\n                ans=Math.max(ans,right-left+1);\\n            }else{\\n                while(val>budget){\\n                    k=right-left;\\n                    val=(runningCosts[right]-runningCosts[left])*k;\\n                    while(!pq.isEmpty() && pq.peek().idx<=left){\\n                        pq.poll();\\n                    }\\n                    if(pq.isEmpty()==false) val+=pq.peek().val;\\n                    left++;                                        \\n                }\\n            }\\n        }\\n        ans = Math.max(ans,n-left);\\n        return ans;      \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    class Pair implements Comparable<Pair>{\\n        int idx; int val;\\n        Pair(int idx, int val){\\n            this.idx=idx; this.val=val;\\n        }\\n        public int compareTo(Pair p){\\n            return p.val-this.val;\\n        }\\n    }\\n\\n    public int maximumRobots(int[] chargeTimes, int[] running, long budget) {\\n        int n=chargeTimes.length;\\n        long runningCosts[] = new long[n];\\n        runningCosts[0]=running[0];\\n        for(int i=1; i<n; i++){\\n            runningCosts[i]+=(runningCosts[i-1]+running[i]);\\n        }\\n        int ans = 0;    int left=0;\\n\\n        PriorityQueue<Pair> pq = new PriorityQueue<>();\\n        for(int right=0; right<n; right++){\\n            pq.add(new Pair(right,chargeTimes[right]));\\n            int k = (right-left+1);\\n            long val = runningCosts[right];\\n            if(left-1>=0) val-=runningCosts[left-1];\\n            val*=k;\\n\\n            int max = -1;\\n            while(!pq.isEmpty() && pq.peek().idx<left){\\n                pq.poll();\\n            }\\n            val+=pq.peek().val;\\n\\n            if(val<=budget){\\n                ans=Math.max(ans,right-left+1);\\n            }else{\\n                while(val>budget){\\n                    k=right-left;\\n                    val=(runningCosts[right]-runningCosts[left])*k;\\n                    while(!pq.isEmpty() && pq.peek().idx<=left){\\n                        pq.poll();\\n                    }\\n                    if(pq.isEmpty()==false) val+=pq.peek().val;\\n                    left++;                                        \\n                }\\n            }\\n        }\\n        ans = Math.max(ans,n-left);\\n        return ans;      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098719,
                "title": "easy-solution-python",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\\n\\n        arr = []\\n        a=0\\n        b=0\\n        acumSuma=0\\n        ans=0\\n        n=len(chargeTimes)\\n\\n        while (a < n):\\n            while (len(arr) != 0 and chargeTimes[arr[-1]] < chargeTimes[a]):\\n                arr.pop()\\n            arr.append(a)\\n            acumSuma += runningCosts[a]\\n            a += 1\\n            while (b != a and chargeTimes[arr[0]] + (a - b) * acumSuma > budget):\\n                if arr[0] == b:\\n                    arr.pop(0)\\n                acumSuma -= runningCosts[b]\\n                b += 1\\n            ans = max(ans, a - b)\\n\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\\n\\n        arr = []\\n        a=0\\n        b=0\\n        acumSuma=0\\n        ans=0\\n        n=len(chargeTimes)\\n\\n        while (a < n):\\n            while (len(arr) != 0 and chargeTimes[arr[-1]] < chargeTimes[a]):\\n                arr.pop()\\n            arr.append(a)\\n            acumSuma += runningCosts[a]\\n            a += 1\\n            while (b != a and chargeTimes[arr[0]] + (a - b) * acumSuma > budget):\\n                if arr[0] == b:\\n                    arr.pop(0)\\n                acumSuma -= runningCosts[b]\\n                b += 1\\n            ans = max(ans, a - b)\\n\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066579,
                "title": "easy-solution-c-binary-search-and-multi-set",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    #define ll long long \\n    int maximumRobots(vector<int>& v, vector<int>& ve, long long bg) {\\n       int ans=0;\\n       int l=1,r=v.size();\\n       if(r==0) return 0;\\n      // cout<<r<<endl;\\n        while(l<=r) {\\n            int md=(l+r)/2;\\n            multiset<ll>s;\\n            ll sum=0,c=0;\\n            bool f=false;\\n            for(ll i=0,j=0; i<v.size(); i++) {\\n                c++;\\n                s.insert(v[i]);\\n                sum+=ve[i];\\n                if(c>md) {\\n                    sum-=ve[j];\\n                    s.erase(s.find(v[j]));\\n                    j++;\\n                }\\n                \\n                if(c>=md) {\\n                    ll p=*s.rbegin();\\n                    \\n                    if(sum*md+p<=bg) {\\n                        f=true;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(f) ans=md,l=md+1;\\n            else r=md-1;\\n           \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long \\n    int maximumRobots(vector<int>& v, vector<int>& ve, long long bg) {\\n       int ans=0;\\n       int l=1,r=v.size();\\n       if(r==0) return 0;\\n      // cout<<r<<endl;\\n        while(l<=r) {\\n            int md=(l+r)/2;\\n            multiset<ll>s;\\n            ll sum=0,c=0;\\n            bool f=false;\\n            for(ll i=0,j=0; i<v.size(); i++) {\\n                c++;\\n                s.insert(v[i]);\\n                sum+=ve[i];\\n                if(c>md) {\\n                    sum-=ve[j];\\n                    s.erase(s.find(v[j]));\\n                    j++;\\n                }\\n                \\n                if(c>=md) {\\n                    ll p=*s.rbegin();\\n                    \\n                    if(sum*md+p<=bg) {\\n                        f=true;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(f) ans=md,l=md+1;\\n            else r=md-1;\\n           \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3056708,
                "title": "c-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        long long cost = 0;\\n        int j= 0;\\n        int ans =0;\\n        multiset<int> pq;\\n        long long running = 0;\\n        for (int i= 0; i < chargeTimes.size(); i++)\\n        {\\n            pq.insert(chargeTimes[i]);\\n            running += runningCosts[i];\\n            cost =  *pq.rbegin() + (i-j+1)*running;\\n            while ( pq.size() && cost > budget)\\n            {\\n                auto it = pq.find(chargeTimes[j]);\\n                pq.erase(it);\\n\\n                int t=  pq.size()>1 ? *pq.rbegin():0;\\n                running -= runningCosts[j];\\n                cost =  t + (i-j+1)*running;\\n                j++;\\n            }\\n            ans = max(ans,i-j+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        long long cost = 0;\\n        int j= 0;\\n        int ans =0;\\n        multiset<int> pq;\\n        long long running = 0;\\n        for (int i= 0; i < chargeTimes.size(); i++)\\n        {\\n            pq.insert(chargeTimes[i]);\\n            running += runningCosts[i];\\n            cost =  *pq.rbegin() + (i-j+1)*running;\\n            while ( pq.size() && cost > budget)\\n            {\\n                auto it = pq.find(chargeTimes[j]);\\n                pq.erase(it);\\n\\n                int t=  pq.size()>1 ? *pq.rbegin():0;\\n                running -= runningCosts[j];\\n                cost =  t + (i-j+1)*running;\\n                j++;\\n            }\\n            ans = max(ans,i-j+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053585,
                "title": "python3-sliding-window-easy-to-understand",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1) if we do not consider the output size\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\\n        charges_deq = collections.deque()\\n        curr = 0\\n        left = right = 0\\n        res = 0\\n        while right < len(chargeTimes):\\n            curr += runningCosts[right]\\n            while charges_deq and chargeTimes[charges_deq[-1]] < chargeTimes[right]:\\n                charges_deq.pop()\\n            charges_deq.append(right)\\n            while left <= right and (right - left + 1) * curr + chargeTimes[charges_deq[0]] > budget:\\n                curr -= runningCosts[left]\\n                while charges_deq and charges_deq[0] <= left:\\n                    charges_deq.popleft()\\n                left += 1\\n            res = max(right - left + 1, res)\\n            right += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\\n        charges_deq = collections.deque()\\n        curr = 0\\n        left = right = 0\\n        res = 0\\n        while right < len(chargeTimes):\\n            curr += runningCosts[right]\\n            while charges_deq and chargeTimes[charges_deq[-1]] < chargeTimes[right]:\\n                charges_deq.pop()\\n            charges_deq.append(right)\\n            while left <= right and (right - left + 1) * curr + chargeTimes[charges_deq[0]] > budget:\\n                curr -= runningCosts[left]\\n                while charges_deq and charges_deq[0] <= left:\\n                    charges_deq.popleft()\\n                left += 1\\n            res = max(right - left + 1, res)\\n            right += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045792,
                "title": "c-sliding-windows-segment-tree-binary-search-with-explanation",
                "content": "# Intuition\\nFirst let us analysing the question:\\n- Find max length that satisfy: max(range) + count * sum(range)\\n\\n=> Notice it is a optimization problem: we could use binary search on answer set to test and try the answer in log(n) time.\\n=> For finding max of a range: We could use a very standard segment tree template and get what we want in o(nlogn) time\\n=> For find sum of range: We could get it from sliding windows in o(n) time\\n\\n==> That is what we need for this question. Quite straight forward\\n# Time Complexity\\n=> In total, it will be O(n(logn)^2)\\n\\n# Code\\n```\\n\\ntypedef struct SegmentTreeMaxWithLazyTag{\\n    vector<int> count;\\n    vector<int> lazyTag;\\n    SegmentTreeMaxWithLazyTag(int n): count(n * 4, 0), lazyTag(n * 4, 0){}\\n\\n    void propogateRoot(int vertex, int value){\\n        if (vertex == 0) return;\\n        vertex = (vertex - 1) / 2;\\n        if (count[vertex] < value) {\\n            count[vertex] = value;\\n            propogateRoot(vertex, value);\\n        }\\n    }\\n\\n    void setMax(int l, int r, int L, int R, int value, int vertex){\\n        if (l == L && r == R){\\n            count[vertex] = max(value, count[vertex]);\\n            lazyTag[vertex] = max(value, lazyTag[vertex]);\\n            propogateRoot(vertex, value);\\n            return;\\n        }\\n        int mid((L + R) / 2);\\n        if (mid < l) setMax(l, r, mid + 1, R, value, vertex * 2 + 2);\\n        else if (mid >= r) setMax(l, r, L, mid, value, vertex * 2 + 1);\\n        else {\\n            setMax(l , mid, L, mid, value, vertex * 2 + 1);\\n            setMax(mid + 1, r, mid + 1, R, value, vertex * 2 + 2);\\n        }\\n    }\\n\\n    int query(int l, int r, int L, int R, int vertex, int lazy){\\n        if (l == L && r == R){\\n            return max(lazy, count[vertex]);\\n        }\\n        int mid((L + R) / 2);\\n        lazy = max(lazyTag[vertex], lazy);\\n        if (mid < l) return query(l, r, mid + 1, R, vertex * 2 + 2, lazy);\\n        else if (mid >= r) return query(l, r, L, mid, vertex * 2 + 1, lazy);\\n        else\\n            return max(query(l , mid, L, mid, vertex * 2 + 1, lazy), query(mid + 1, r, mid + 1, R, vertex * 2 + 2, lazy));\\n    }\\n\\n} SegmentTree;\\n\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        SegmentTree tree(chargeTimes.size());\\n        for (int i = 0; i <= chargeTimes.size() - 1; ++i) tree.setMax(i, i, 0, chargeTimes.size() - 1, chargeTimes[i], 0);\\n        long long low(1), high(chargeTimes.size()), ans(0), budgetll(budget);\\n        while(low <= high){\\n            long long mid((low + high) / 2), sum(0), tmp(LLONG_MAX), ptr1(0), ptr2(0);\\n            // cout << low << \" \" << high << \" \" << mid << \" \" << tmp << endl;\\n            if (mid == 0) break;\\n            while (ptr2 < mid){\\n                sum += runningCosts[ptr2];\\n                ptr2++;\\n            }\\n            tmp = min(tmp, mid * sum + tree.query(ptr1, ptr2 - 1, 0, chargeTimes.size() - 1, 0, 0));\\n            while (ptr2 < chargeTimes.size()){\\n                sum += runningCosts[ptr2] - runningCosts[ptr1];\\n                // cout << mid << \" \" << sum << \" \" << tree.query(ptr1 + 1, ptr2, 0, chargeTimes.size() - 1, 0, 0) << \" \" <<  mid * sum + tree.query(ptr1 + 1, ptr2, 0, chargeTimes.size() - 1, 0, 0) << endl;\\n                tmp = min(tmp, mid * sum + tree.query(ptr1 + 1, ptr2, 0, chargeTimes.size() - 1, 0, 0));\\n                // cout << \"tmp3:\" << tmp << \" \" << budgetll << endl;\\n                if (tmp <= budgetll) break;\\n                ptr2++;\\n                ptr1++;\\n            }\\n            if (tmp > budgetll) high = mid - 1;\\n            else {\\n                low = mid + 1;\\n                ans = mid;\\n            }\\n            // cout << \" === \" << endl;\\n            // cout << low << \" \" << tmp << \" \" << high << endl;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\ntypedef struct SegmentTreeMaxWithLazyTag{\\n    vector<int> count;\\n    vector<int> lazyTag;\\n    SegmentTreeMaxWithLazyTag(int n): count(n * 4, 0), lazyTag(n * 4, 0){}\\n\\n    void propogateRoot(int vertex, int value){\\n        if (vertex == 0) return;\\n        vertex = (vertex - 1) / 2;\\n        if (count[vertex] < value) {\\n            count[vertex] = value;\\n            propogateRoot(vertex, value);\\n        }\\n    }\\n\\n    void setMax(int l, int r, int L, int R, int value, int vertex){\\n        if (l == L && r == R){\\n            count[vertex] = max(value, count[vertex]);\\n            lazyTag[vertex] = max(value, lazyTag[vertex]);\\n            propogateRoot(vertex, value);\\n            return;\\n        }\\n        int mid((L + R) / 2);\\n        if (mid < l) setMax(l, r, mid + 1, R, value, vertex * 2 + 2);\\n        else if (mid >= r) setMax(l, r, L, mid, value, vertex * 2 + 1);\\n        else {\\n            setMax(l , mid, L, mid, value, vertex * 2 + 1);\\n            setMax(mid + 1, r, mid + 1, R, value, vertex * 2 + 2);\\n        }\\n    }\\n\\n    int query(int l, int r, int L, int R, int vertex, int lazy){\\n        if (l == L && r == R){\\n            return max(lazy, count[vertex]);\\n        }\\n        int mid((L + R) / 2);\\n        lazy = max(lazyTag[vertex], lazy);\\n        if (mid < l) return query(l, r, mid + 1, R, vertex * 2 + 2, lazy);\\n        else if (mid >= r) return query(l, r, L, mid, vertex * 2 + 1, lazy);\\n        else\\n            return max(query(l , mid, L, mid, vertex * 2 + 1, lazy), query(mid + 1, r, mid + 1, R, vertex * 2 + 2, lazy));\\n    }\\n\\n} SegmentTree;\\n\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\\n        SegmentTree tree(chargeTimes.size());\\n        for (int i = 0; i <= chargeTimes.size() - 1; ++i) tree.setMax(i, i, 0, chargeTimes.size() - 1, chargeTimes[i], 0);\\n        long long low(1), high(chargeTimes.size()), ans(0), budgetll(budget);\\n        while(low <= high){\\n            long long mid((low + high) / 2), sum(0), tmp(LLONG_MAX), ptr1(0), ptr2(0);\\n            // cout << low << \" \" << high << \" \" << mid << \" \" << tmp << endl;\\n            if (mid == 0) break;\\n            while (ptr2 < mid){\\n                sum += runningCosts[ptr2];\\n                ptr2++;\\n            }\\n            tmp = min(tmp, mid * sum + tree.query(ptr1, ptr2 - 1, 0, chargeTimes.size() - 1, 0, 0));\\n            while (ptr2 < chargeTimes.size()){\\n                sum += runningCosts[ptr2] - runningCosts[ptr1];\\n                // cout << mid << \" \" << sum << \" \" << tree.query(ptr1 + 1, ptr2, 0, chargeTimes.size() - 1, 0, 0) << \" \" <<  mid * sum + tree.query(ptr1 + 1, ptr2, 0, chargeTimes.size() - 1, 0, 0) << endl;\\n                tmp = min(tmp, mid * sum + tree.query(ptr1 + 1, ptr2, 0, chargeTimes.size() - 1, 0, 0));\\n                // cout << \"tmp3:\" << tmp << \" \" << budgetll << endl;\\n                if (tmp <= budgetll) break;\\n                ptr2++;\\n                ptr1++;\\n            }\\n            if (tmp > budgetll) high = mid - 1;\\n            else {\\n                low = mid + 1;\\n                ans = mid;\\n            }\\n            // cout << \" === \" << endl;\\n            // cout << low << \" \" << tmp << \" \" << high << endl;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3037532,
                "title": "python-two-pointers-max-heap-72-time-30-space",
                "content": "```\\nclass Solution:\\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\\n        output = 0\\n        l, r = 0, 0\\n        heap, charge_count, running_total = [], collections.defaultdict(int), 0\\n\\n        while r < len(chargeTimes):\\n            heapq.heappush(heap, -chargeTimes[r])\\n            charge_count[chargeTimes[r]] += 1\\n            running_total += runningCosts[r]\\n            while heap and charge_count[-heap[0]] == 0: heapq.heappop(heap)\\n            length = r - l + 1\\n            cost = -heap[0] + length * running_total\\n            if cost <= budget: output = max(output, length)\\n            # Elif cost > budget\\n            while heap and cost > budget:\\n                charge_count[chargeTimes[l]] -= 1\\n                running_total -= runningCosts[l]\\n                l += 1\\n                while heap and charge_count[-heap[0]] == 0: heapq.heappop(heap)\\n                cost = -heap[0] + (r - l + 1) * running_total if heap else cost\\n            r += 1\\n        return output\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\\n        output = 0\\n        l, r = 0, 0\\n        heap, charge_count, running_total = [], collections.defaultdict(int), 0\\n\\n        while r < len(chargeTimes):\\n            heapq.heappush(heap, -chargeTimes[r])\\n            charge_count[chargeTimes[r]] += 1\\n            running_total += runningCosts[r]\\n            while heap and charge_count[-heap[0]] == 0: heapq.heappop(heap)\\n            length = r - l + 1\\n            cost = -heap[0] + length * running_total\\n            if cost <= budget: output = max(output, length)\\n            # Elif cost > budget\\n            while heap and cost > budget:\\n                charge_count[chargeTimes[l]] -= 1\\n                running_total -= runningCosts[l]\\n                l += 1\\n                while heap and charge_count[-heap[0]] == 0: heapq.heappop(heap)\\n                cost = -heap[0] + (r - l + 1) * running_total if heap else cost\\n            r += 1\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035461,
                "title": "ruby-monotonic-queue",
                "content": "```ruby\\ndef maximum_robots c, r, t\\n    i, z, s, m = 0, c.size, 0, []\\n    for j in 0...z\\n        m.pop while m.last&.< c[j]\\n        m << c[j]\\n        s += r[j]\\n        if m.first + s * (j - i + 1) > t\\n            m.shift if m.first == c[i]\\n            s -= r[i]\\n            i += 1\\n        end\\n    end\\n    z - i\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef maximum_robots c, r, t\\n    i, z, s, m = 0, c.size, 0, []\\n    for j in 0...z\\n        m.pop while m.last&.< c[j]\\n        m << c[j]\\n        s += r[j]\\n        if m.first + s * (j - i + 1) > t\\n            m.shift if m.first == c[i]\\n            s -= r[i]\\n            i += 1\\n        end\\n    end\\n    z - i\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3005082,
                "title": "c-easy-solution-using-sliding-window-technique",
                "content": "**Sliding Window + Multiset**\\n\\n**Time complexity :- O(nlogn)\\nSpace  complexity :-  O(n)***\\n```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& charge, vector<int>& costs, long long budget) {\\n        int n = charge.size();\\n        int i = 0 , j = 0 ;\\n        long long sum = 0 , max_charge = 0;\\n        int ans = 0;\\n        multiset<long long> mt;\\n        while(j < n){\\n            sum += costs[j];\\n            max_charge = max(max_charge,(long long)charge[j]);\\n            mt.insert(charge[j]);\\n            \\n            // if total cost is less than budget ;\\n            if(max_charge + (j-i+1)*sum <= budget){\\n                ans = max(ans,j-i+1);\\n                j++;\\n            }\\n            \\n            // if total cost is greater than budget ;\\n            else{\\n                \\n                // we will move i until cost become less than budget\\n                while(max_charge + (j-i+1)*sum > budget && i <= j){\\n                    mt.erase(mt.find(charge[i]));\\n                    if(mt.empty()){\\n                        sum = 0,max_charge = 0;\\n                        i++;\\n                    }\\n                    else{\\n                        max_charge = *mt.rbegin();\\n                        sum -= costs[i];\\n                        i++;\\n                    }\\n                }\\n                ans = max(ans,j-i+1);\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRobots(vector<int>& charge, vector<int>& costs, long long budget) {\\n        int n = charge.size();\\n        int i = 0 , j = 0 ;\\n        long long sum = 0 , max_charge = 0;\\n        int ans = 0;\\n        multiset<long long> mt;\\n        while(j < n){\\n            sum += costs[j];\\n            max_charge = max(max_charge,(long long)charge[j]);\\n            mt.insert(charge[j]);\\n            \\n            // if total cost is less than budget ;\\n            if(max_charge + (j-i+1)*sum <= budget){\\n                ans = max(ans,j-i+1);\\n                j++;\\n            }\\n            \\n            // if total cost is greater than budget ;\\n            else{\\n                \\n                // we will move i until cost become less than budget\\n                while(max_charge + (j-i+1)*sum > budget && i <= j){\\n                    mt.erase(mt.find(charge[i]));\\n                    if(mt.empty()){\\n                        sum = 0,max_charge = 0;\\n                        i++;\\n                    }\\n                    else{\\n                        max_charge = *mt.rbegin();\\n                        sum -= costs[i];\\n                        i++;\\n                    }\\n                }\\n                ans = max(ans,j-i+1);\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2915634,
                "title": "sparse-table-range-maximum-query-and-binary-search-o-nlogn",
                "content": "```\\nint maximumRobots(vector<int>& charge, vector<int>& cost, long long budget) {\\n        // calculating max using sparse table and Range Maximum Query technique\\n        int n = charge.size();\\n        vector<vector<int>> a(n, vector<int>(20));                   // sparse table\\n        for(int i = 0; i < n; ++i){\\n            a[i][0] = charge[i];\\n        }\\n        for(int j = 1; j < 20; ++j){\\n            for(int i = 0; i + (1 << j) - 1 < n; ++i){\\n                a[i][j] = max(a[i][j - 1], a[i + (1 << (j - 1))][j - 1]);\\n            }\\n        }\\n\\t\\t\\n\\t\\t// prefix sums\\n        vector<long long> pref(n);\\n        pref[0] = cost[0];\\n        for(int i = 1; i < n; ++i){\\n            pref[i] = (long long)cost[i] + pref[i - 1];\\n        }\\n        \\n\\t\\t// MAX function gives the MAX in the range [L, R] in LogN time\\n        auto MAX = [&](int L, int R){\\n            // int j = log2(R - L + 1);\\n            int len = R - L + 1;\\n            int j = 0;\\n            while((1LL << (j + 1)) <= len)\\n                j++;\\n            return max(a[L][j], a[R - (1LL << j) + 1][j]);\\n        };\\n        \\n        auto check = [&](int mid){\\n            // check if you can have MID consecutive robots\\n            if(mid == 0)\\n                return true;            // edge vase to avoid MID - 1 segmentation fault\\n            \\n            // for the first MID values\\n            long long val = (long long)mid * pref[mid - 1];\\n            val += MAX(0, mid - 1);\\n            if(val <= budget)\\n                return true;\\n            \\n            \\n            for(int i = mid; i < n; ++i){\\n                val = (long long)mid * (pref[i] - pref[i - mid]);\\n                val += MAX(i - mid + 1, i);\\n                if(val <= budget){\\n                    return true;\\n                }\\n            }\\n            return false;\\n        };\\n        \\n        int lo = 0, hi = n, ans = 0;\\n        // bsearch on the answer\\n        while(lo <= hi){\\n            int mid = (lo + hi) / 2;\\n            bool can = check(mid);\\n            if(can){\\n                ans = mid;\\n                lo = mid + 1;\\n            } else{\\n                hi = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nint maximumRobots(vector<int>& charge, vector<int>& cost, long long budget) {\\n        // calculating max using sparse table and Range Maximum Query technique\\n        int n = charge.size();\\n        vector<vector<int>> a(n, vector<int>(20));                   // sparse table\\n        for(int i = 0; i < n; ++i){\\n            a[i][0] = charge[i];\\n        }\\n        for(int j = 1; j < 20; ++j){\\n            for(int i = 0; i + (1 << j) - 1 < n; ++i){\\n                a[i][j] = max(a[i][j - 1], a[i + (1 << (j - 1))][j - 1]);\\n            }\\n        }\\n\\t\\t\\n\\t\\t// prefix sums\\n        vector<long long> pref(n);\\n        pref[0] = cost[0];\\n        for(int i = 1; i < n; ++i){\\n            pref[i] = (long long)cost[i] + pref[i - 1];\\n        }\\n        \\n\\t\\t// MAX function gives the MAX in the range [L, R] in LogN time\\n        auto MAX = [&](int L, int R){\\n            // int j = log2(R - L + 1);\\n            int len = R - L + 1;\\n            int j = 0;\\n            while((1LL << (j + 1)) <= len)\\n                j++;\\n            return max(a[L][j], a[R - (1LL << j) + 1][j]);\\n        };\\n        \\n        auto check = [&](int mid){\\n            // check if you can have MID consecutive robots\\n            if(mid == 0)\\n                return true;            // edge vase to avoid MID - 1 segmentation fault\\n            \\n            // for the first MID values\\n            long long val = (long long)mid * pref[mid - 1];\\n            val += MAX(0, mid - 1);\\n            if(val <= budget)\\n                return true;\\n            \\n            \\n            for(int i = mid; i < n; ++i){\\n                val = (long long)mid * (pref[i] - pref[i - mid]);\\n                val += MAX(i - mid + 1, i);\\n                if(val <= budget){\\n                    return true;\\n                }\\n            }\\n            return false;\\n        };\\n        \\n        int lo = 0, hi = n, ans = 0;\\n        // bsearch on the answer\\n        while(lo <= hi){\\n            int mid = (lo + hi) / 2;\\n            bool can = check(mid);\\n            if(can){\\n                ans = mid;\\n                lo = mid + 1;\\n            } else{\\n                hi = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1918977,
                "content": [
                    {
                        "username": "layyy",
                        "content": "try sliding window maximum before this\\n"
                    },
                    {
                        "username": "Roshan_10",
                        "content": "Its giving TLE after 82/82 testcases passed\nits showing a testcase where chargeTime list is empty, but according to constraints it shouldn't be thier, what's the problem ? please anyone help!\n\nI have used binary search on answer  + sliding window"
                    },
                    {
                        "username": "ujjwaltyagi888",
                        "content": "ya same"
                    },
                    {
                        "username": "spushkar1526",
                        "content": "[@UltimateBatman](/UltimateBatman) yes but that gives TLE on 82 test case which is empty array"
                    },
                    {
                        "username": "Roshan_10",
                        "content": "[@spushkar1526](/spushkar1526) BS on answer (i.e. number of consecutive days) and after that using sliding window to select consecutive mid number's of days."
                    },
                    {
                        "username": "spushkar1526",
                        "content": "how did you solve this problem? I have the same problem using the same method as you "
                    },
                    {
                        "username": "Ricola",
                        "content": "Why does a monotonic stack work?\\n\\nI see a lot of solutions using a monotonic stack/deque. I get the intuition of why it would work but is there a formal demonstration/explanation?"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "For this, you first need to understand solving problems similar to this. Like, largest subarray having unique chars, largest subarray having freq of any char not > k, etc.... using the \\nSTEPS:\\n1)EXPAND\\n2)CHECK VALIDITY OF THE WINDOW -> IF NOT VALID, THEN CONVERT THE EXPANSION TO MOVING BY INCREMENTING THE LEFT INDEX OF WINDOW\\n\\nIf you use these steps, you end up with largest required window as we dont shrink the window.\\ni.e. we try to expand the window, if window is not valid after expansion, then just move\\n\\nSo, for your question, we know that we just need max of a window in this question,,,,hope i dont need to explain more\\n\\n"
                    },
                    {
                        "username": "user8272RT",
                        "content": "I got here after doing [239. Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/)\\n\\nThis was my initial approach\\n1. This is a sliding window problem, so find maximum charge time within window of width k using monotonic dequeue.\\n2. Use binary search to find maximum valid window width."
                    },
                    {
                        "username": "spushkar1526",
                        "content": "it is showing TLE after 82/82 testcases passed \nit shows the last test case as empty testcase\n\nhow to solve this?"
                    },
                    {
                        "username": "mukundsmith49",
                        "content": "try finding maximum element of a window using map\\n"
                    },
                    {
                        "username": "Alexis12828313",
                        "content": "Why does the following test case return a 4 as result?\\nChargeTimes = [74,46,19,34,7,87,7,40,28,81,53,39,3,46,21,40,76,44,88,93,44,50,22,59,46,60,36,24,50,40,56,5,39,9,24,74,7,14,95,45,36,17,22,12,53,41,2,33,100,73,20,70,81,91,28,98,47,88,79,100,78,38,44,74,48,76,73,92,28,30,95,87]\\n\\nrunningCosts = [11,33,15,40,8,28,97,89,51,42,17,57,45,5,63,53,23,43,76,64,86,86,89,53,94,91,78,12,90,29,79,48,35,6,88,79,82,76,44,93,83,55,65,96,86,24,54,65,94,4,26,73,51,85,47,99,17,14,76,2,39,52,58,5,15,35,79,16,94,16,59,50]\\n\\nbudget = 447\\nI tried a working function from solution and print the index of the possible solution, it showed me the index are 0 and 4. but if we calculate the result based on the question, we have: (11 + 33+15+40)*4 + Max(74,46,19,34) and the result is 470 > 447. Could anyone help me with that?"
                    },
                    {
                        "username": "ingato",
                        "content": "I'm getting the same thing. Everything else seems to pass and I can't see anything wrong in my code. My brute force method does return 4 though, so I must have a bug somewhere. I just don't see it.\n\nEdit: I figured it out. By adding some logging to my brute force approach I was able to find that index 1-5 are the ones that will actually be below budget and 4 long.\n\nI am using sliding window with a dequeue and in my logic when I have a  final cost over budge I remove the front element of the deque if it is equal to the charge time at my current left index, before shrinking the window. My problem was that I simply checked that accidentally against the \"runningCosts\" param instead of the \"chargeTimes\" param."
                    }
                ]
            },
            {
                "id": 1824886,
                "content": [
                    {
                        "username": "layyy",
                        "content": "try sliding window maximum before this\\n"
                    },
                    {
                        "username": "Roshan_10",
                        "content": "Its giving TLE after 82/82 testcases passed\nits showing a testcase where chargeTime list is empty, but according to constraints it shouldn't be thier, what's the problem ? please anyone help!\n\nI have used binary search on answer  + sliding window"
                    },
                    {
                        "username": "ujjwaltyagi888",
                        "content": "ya same"
                    },
                    {
                        "username": "spushkar1526",
                        "content": "[@UltimateBatman](/UltimateBatman) yes but that gives TLE on 82 test case which is empty array"
                    },
                    {
                        "username": "Roshan_10",
                        "content": "[@spushkar1526](/spushkar1526) BS on answer (i.e. number of consecutive days) and after that using sliding window to select consecutive mid number's of days."
                    },
                    {
                        "username": "spushkar1526",
                        "content": "how did you solve this problem? I have the same problem using the same method as you "
                    },
                    {
                        "username": "Ricola",
                        "content": "Why does a monotonic stack work?\\n\\nI see a lot of solutions using a monotonic stack/deque. I get the intuition of why it would work but is there a formal demonstration/explanation?"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "For this, you first need to understand solving problems similar to this. Like, largest subarray having unique chars, largest subarray having freq of any char not > k, etc.... using the \\nSTEPS:\\n1)EXPAND\\n2)CHECK VALIDITY OF THE WINDOW -> IF NOT VALID, THEN CONVERT THE EXPANSION TO MOVING BY INCREMENTING THE LEFT INDEX OF WINDOW\\n\\nIf you use these steps, you end up with largest required window as we dont shrink the window.\\ni.e. we try to expand the window, if window is not valid after expansion, then just move\\n\\nSo, for your question, we know that we just need max of a window in this question,,,,hope i dont need to explain more\\n\\n"
                    },
                    {
                        "username": "user8272RT",
                        "content": "I got here after doing [239. Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/)\\n\\nThis was my initial approach\\n1. This is a sliding window problem, so find maximum charge time within window of width k using monotonic dequeue.\\n2. Use binary search to find maximum valid window width."
                    },
                    {
                        "username": "spushkar1526",
                        "content": "it is showing TLE after 82/82 testcases passed \nit shows the last test case as empty testcase\n\nhow to solve this?"
                    },
                    {
                        "username": "mukundsmith49",
                        "content": "try finding maximum element of a window using map\\n"
                    },
                    {
                        "username": "Alexis12828313",
                        "content": "Why does the following test case return a 4 as result?\\nChargeTimes = [74,46,19,34,7,87,7,40,28,81,53,39,3,46,21,40,76,44,88,93,44,50,22,59,46,60,36,24,50,40,56,5,39,9,24,74,7,14,95,45,36,17,22,12,53,41,2,33,100,73,20,70,81,91,28,98,47,88,79,100,78,38,44,74,48,76,73,92,28,30,95,87]\\n\\nrunningCosts = [11,33,15,40,8,28,97,89,51,42,17,57,45,5,63,53,23,43,76,64,86,86,89,53,94,91,78,12,90,29,79,48,35,6,88,79,82,76,44,93,83,55,65,96,86,24,54,65,94,4,26,73,51,85,47,99,17,14,76,2,39,52,58,5,15,35,79,16,94,16,59,50]\\n\\nbudget = 447\\nI tried a working function from solution and print the index of the possible solution, it showed me the index are 0 and 4. but if we calculate the result based on the question, we have: (11 + 33+15+40)*4 + Max(74,46,19,34) and the result is 470 > 447. Could anyone help me with that?"
                    },
                    {
                        "username": "ingato",
                        "content": "I'm getting the same thing. Everything else seems to pass and I can't see anything wrong in my code. My brute force method does return 4 though, so I must have a bug somewhere. I just don't see it.\n\nEdit: I figured it out. By adding some logging to my brute force approach I was able to find that index 1-5 are the ones that will actually be below budget and 4 long.\n\nI am using sliding window with a dequeue and in my logic when I have a  final cost over budge I remove the front element of the deque if it is equal to the charge time at my current left index, before shrinking the window. My problem was that I simply checked that accidentally against the \"runningCosts\" param instead of the \"chargeTimes\" param."
                    }
                ]
            },
            {
                "id": 1626281,
                "content": [
                    {
                        "username": "layyy",
                        "content": "try sliding window maximum before this\\n"
                    },
                    {
                        "username": "Roshan_10",
                        "content": "Its giving TLE after 82/82 testcases passed\nits showing a testcase where chargeTime list is empty, but according to constraints it shouldn't be thier, what's the problem ? please anyone help!\n\nI have used binary search on answer  + sliding window"
                    },
                    {
                        "username": "ujjwaltyagi888",
                        "content": "ya same"
                    },
                    {
                        "username": "spushkar1526",
                        "content": "[@UltimateBatman](/UltimateBatman) yes but that gives TLE on 82 test case which is empty array"
                    },
                    {
                        "username": "Roshan_10",
                        "content": "[@spushkar1526](/spushkar1526) BS on answer (i.e. number of consecutive days) and after that using sliding window to select consecutive mid number's of days."
                    },
                    {
                        "username": "spushkar1526",
                        "content": "how did you solve this problem? I have the same problem using the same method as you "
                    },
                    {
                        "username": "Ricola",
                        "content": "Why does a monotonic stack work?\\n\\nI see a lot of solutions using a monotonic stack/deque. I get the intuition of why it would work but is there a formal demonstration/explanation?"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "For this, you first need to understand solving problems similar to this. Like, largest subarray having unique chars, largest subarray having freq of any char not > k, etc.... using the \\nSTEPS:\\n1)EXPAND\\n2)CHECK VALIDITY OF THE WINDOW -> IF NOT VALID, THEN CONVERT THE EXPANSION TO MOVING BY INCREMENTING THE LEFT INDEX OF WINDOW\\n\\nIf you use these steps, you end up with largest required window as we dont shrink the window.\\ni.e. we try to expand the window, if window is not valid after expansion, then just move\\n\\nSo, for your question, we know that we just need max of a window in this question,,,,hope i dont need to explain more\\n\\n"
                    },
                    {
                        "username": "user8272RT",
                        "content": "I got here after doing [239. Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/)\\n\\nThis was my initial approach\\n1. This is a sliding window problem, so find maximum charge time within window of width k using monotonic dequeue.\\n2. Use binary search to find maximum valid window width."
                    },
                    {
                        "username": "spushkar1526",
                        "content": "it is showing TLE after 82/82 testcases passed \nit shows the last test case as empty testcase\n\nhow to solve this?"
                    },
                    {
                        "username": "mukundsmith49",
                        "content": "try finding maximum element of a window using map\\n"
                    },
                    {
                        "username": "Alexis12828313",
                        "content": "Why does the following test case return a 4 as result?\\nChargeTimes = [74,46,19,34,7,87,7,40,28,81,53,39,3,46,21,40,76,44,88,93,44,50,22,59,46,60,36,24,50,40,56,5,39,9,24,74,7,14,95,45,36,17,22,12,53,41,2,33,100,73,20,70,81,91,28,98,47,88,79,100,78,38,44,74,48,76,73,92,28,30,95,87]\\n\\nrunningCosts = [11,33,15,40,8,28,97,89,51,42,17,57,45,5,63,53,23,43,76,64,86,86,89,53,94,91,78,12,90,29,79,48,35,6,88,79,82,76,44,93,83,55,65,96,86,24,54,65,94,4,26,73,51,85,47,99,17,14,76,2,39,52,58,5,15,35,79,16,94,16,59,50]\\n\\nbudget = 447\\nI tried a working function from solution and print the index of the possible solution, it showed me the index are 0 and 4. but if we calculate the result based on the question, we have: (11 + 33+15+40)*4 + Max(74,46,19,34) and the result is 470 > 447. Could anyone help me with that?"
                    },
                    {
                        "username": "ingato",
                        "content": "I'm getting the same thing. Everything else seems to pass and I can't see anything wrong in my code. My brute force method does return 4 though, so I must have a bug somewhere. I just don't see it.\n\nEdit: I figured it out. By adding some logging to my brute force approach I was able to find that index 1-5 are the ones that will actually be below budget and 4 long.\n\nI am using sliding window with a dequeue and in my logic when I have a  final cost over budge I remove the front element of the deque if it is equal to the charge time at my current left index, before shrinking the window. My problem was that I simply checked that accidentally against the \"runningCosts\" param instead of the \"chargeTimes\" param."
                    }
                ]
            },
            {
                "id": 2016255,
                "content": [
                    {
                        "username": "layyy",
                        "content": "try sliding window maximum before this\\n"
                    },
                    {
                        "username": "Roshan_10",
                        "content": "Its giving TLE after 82/82 testcases passed\nits showing a testcase where chargeTime list is empty, but according to constraints it shouldn't be thier, what's the problem ? please anyone help!\n\nI have used binary search on answer  + sliding window"
                    },
                    {
                        "username": "ujjwaltyagi888",
                        "content": "ya same"
                    },
                    {
                        "username": "spushkar1526",
                        "content": "[@UltimateBatman](/UltimateBatman) yes but that gives TLE on 82 test case which is empty array"
                    },
                    {
                        "username": "Roshan_10",
                        "content": "[@spushkar1526](/spushkar1526) BS on answer (i.e. number of consecutive days) and after that using sliding window to select consecutive mid number's of days."
                    },
                    {
                        "username": "spushkar1526",
                        "content": "how did you solve this problem? I have the same problem using the same method as you "
                    },
                    {
                        "username": "Ricola",
                        "content": "Why does a monotonic stack work?\\n\\nI see a lot of solutions using a monotonic stack/deque. I get the intuition of why it would work but is there a formal demonstration/explanation?"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "For this, you first need to understand solving problems similar to this. Like, largest subarray having unique chars, largest subarray having freq of any char not > k, etc.... using the \\nSTEPS:\\n1)EXPAND\\n2)CHECK VALIDITY OF THE WINDOW -> IF NOT VALID, THEN CONVERT THE EXPANSION TO MOVING BY INCREMENTING THE LEFT INDEX OF WINDOW\\n\\nIf you use these steps, you end up with largest required window as we dont shrink the window.\\ni.e. we try to expand the window, if window is not valid after expansion, then just move\\n\\nSo, for your question, we know that we just need max of a window in this question,,,,hope i dont need to explain more\\n\\n"
                    },
                    {
                        "username": "user8272RT",
                        "content": "I got here after doing [239. Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/)\\n\\nThis was my initial approach\\n1. This is a sliding window problem, so find maximum charge time within window of width k using monotonic dequeue.\\n2. Use binary search to find maximum valid window width."
                    },
                    {
                        "username": "spushkar1526",
                        "content": "it is showing TLE after 82/82 testcases passed \nit shows the last test case as empty testcase\n\nhow to solve this?"
                    },
                    {
                        "username": "mukundsmith49",
                        "content": "try finding maximum element of a window using map\\n"
                    },
                    {
                        "username": "Alexis12828313",
                        "content": "Why does the following test case return a 4 as result?\\nChargeTimes = [74,46,19,34,7,87,7,40,28,81,53,39,3,46,21,40,76,44,88,93,44,50,22,59,46,60,36,24,50,40,56,5,39,9,24,74,7,14,95,45,36,17,22,12,53,41,2,33,100,73,20,70,81,91,28,98,47,88,79,100,78,38,44,74,48,76,73,92,28,30,95,87]\\n\\nrunningCosts = [11,33,15,40,8,28,97,89,51,42,17,57,45,5,63,53,23,43,76,64,86,86,89,53,94,91,78,12,90,29,79,48,35,6,88,79,82,76,44,93,83,55,65,96,86,24,54,65,94,4,26,73,51,85,47,99,17,14,76,2,39,52,58,5,15,35,79,16,94,16,59,50]\\n\\nbudget = 447\\nI tried a working function from solution and print the index of the possible solution, it showed me the index are 0 and 4. but if we calculate the result based on the question, we have: (11 + 33+15+40)*4 + Max(74,46,19,34) and the result is 470 > 447. Could anyone help me with that?"
                    },
                    {
                        "username": "ingato",
                        "content": "I'm getting the same thing. Everything else seems to pass and I can't see anything wrong in my code. My brute force method does return 4 though, so I must have a bug somewhere. I just don't see it.\n\nEdit: I figured it out. By adding some logging to my brute force approach I was able to find that index 1-5 are the ones that will actually be below budget and 4 long.\n\nI am using sliding window with a dequeue and in my logic when I have a  final cost over budge I remove the front element of the deque if it is equal to the charge time at my current left index, before shrinking the window. My problem was that I simply checked that accidentally against the \"runningCosts\" param instead of the \"chargeTimes\" param."
                    }
                ]
            },
            {
                "id": 1921618,
                "content": [
                    {
                        "username": "layyy",
                        "content": "try sliding window maximum before this\\n"
                    },
                    {
                        "username": "Roshan_10",
                        "content": "Its giving TLE after 82/82 testcases passed\nits showing a testcase where chargeTime list is empty, but according to constraints it shouldn't be thier, what's the problem ? please anyone help!\n\nI have used binary search on answer  + sliding window"
                    },
                    {
                        "username": "ujjwaltyagi888",
                        "content": "ya same"
                    },
                    {
                        "username": "spushkar1526",
                        "content": "[@UltimateBatman](/UltimateBatman) yes but that gives TLE on 82 test case which is empty array"
                    },
                    {
                        "username": "Roshan_10",
                        "content": "[@spushkar1526](/spushkar1526) BS on answer (i.e. number of consecutive days) and after that using sliding window to select consecutive mid number's of days."
                    },
                    {
                        "username": "spushkar1526",
                        "content": "how did you solve this problem? I have the same problem using the same method as you "
                    },
                    {
                        "username": "Ricola",
                        "content": "Why does a monotonic stack work?\\n\\nI see a lot of solutions using a monotonic stack/deque. I get the intuition of why it would work but is there a formal demonstration/explanation?"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "For this, you first need to understand solving problems similar to this. Like, largest subarray having unique chars, largest subarray having freq of any char not > k, etc.... using the \\nSTEPS:\\n1)EXPAND\\n2)CHECK VALIDITY OF THE WINDOW -> IF NOT VALID, THEN CONVERT THE EXPANSION TO MOVING BY INCREMENTING THE LEFT INDEX OF WINDOW\\n\\nIf you use these steps, you end up with largest required window as we dont shrink the window.\\ni.e. we try to expand the window, if window is not valid after expansion, then just move\\n\\nSo, for your question, we know that we just need max of a window in this question,,,,hope i dont need to explain more\\n\\n"
                    },
                    {
                        "username": "user8272RT",
                        "content": "I got here after doing [239. Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/)\\n\\nThis was my initial approach\\n1. This is a sliding window problem, so find maximum charge time within window of width k using monotonic dequeue.\\n2. Use binary search to find maximum valid window width."
                    },
                    {
                        "username": "spushkar1526",
                        "content": "it is showing TLE after 82/82 testcases passed \nit shows the last test case as empty testcase\n\nhow to solve this?"
                    },
                    {
                        "username": "mukundsmith49",
                        "content": "try finding maximum element of a window using map\\n"
                    },
                    {
                        "username": "Alexis12828313",
                        "content": "Why does the following test case return a 4 as result?\\nChargeTimes = [74,46,19,34,7,87,7,40,28,81,53,39,3,46,21,40,76,44,88,93,44,50,22,59,46,60,36,24,50,40,56,5,39,9,24,74,7,14,95,45,36,17,22,12,53,41,2,33,100,73,20,70,81,91,28,98,47,88,79,100,78,38,44,74,48,76,73,92,28,30,95,87]\\n\\nrunningCosts = [11,33,15,40,8,28,97,89,51,42,17,57,45,5,63,53,23,43,76,64,86,86,89,53,94,91,78,12,90,29,79,48,35,6,88,79,82,76,44,93,83,55,65,96,86,24,54,65,94,4,26,73,51,85,47,99,17,14,76,2,39,52,58,5,15,35,79,16,94,16,59,50]\\n\\nbudget = 447\\nI tried a working function from solution and print the index of the possible solution, it showed me the index are 0 and 4. but if we calculate the result based on the question, we have: (11 + 33+15+40)*4 + Max(74,46,19,34) and the result is 470 > 447. Could anyone help me with that?"
                    },
                    {
                        "username": "ingato",
                        "content": "I'm getting the same thing. Everything else seems to pass and I can't see anything wrong in my code. My brute force method does return 4 though, so I must have a bug somewhere. I just don't see it.\n\nEdit: I figured it out. By adding some logging to my brute force approach I was able to find that index 1-5 are the ones that will actually be below budget and 4 long.\n\nI am using sliding window with a dequeue and in my logic when I have a  final cost over budge I remove the front element of the deque if it is equal to the charge time at my current left index, before shrinking the window. My problem was that I simply checked that accidentally against the \"runningCosts\" param instead of the \"chargeTimes\" param."
                    }
                ]
            },
            {
                "id": 1800555,
                "content": [
                    {
                        "username": "layyy",
                        "content": "try sliding window maximum before this\\n"
                    },
                    {
                        "username": "Roshan_10",
                        "content": "Its giving TLE after 82/82 testcases passed\nits showing a testcase where chargeTime list is empty, but according to constraints it shouldn't be thier, what's the problem ? please anyone help!\n\nI have used binary search on answer  + sliding window"
                    },
                    {
                        "username": "ujjwaltyagi888",
                        "content": "ya same"
                    },
                    {
                        "username": "spushkar1526",
                        "content": "[@UltimateBatman](/UltimateBatman) yes but that gives TLE on 82 test case which is empty array"
                    },
                    {
                        "username": "Roshan_10",
                        "content": "[@spushkar1526](/spushkar1526) BS on answer (i.e. number of consecutive days) and after that using sliding window to select consecutive mid number's of days."
                    },
                    {
                        "username": "spushkar1526",
                        "content": "how did you solve this problem? I have the same problem using the same method as you "
                    },
                    {
                        "username": "Ricola",
                        "content": "Why does a monotonic stack work?\\n\\nI see a lot of solutions using a monotonic stack/deque. I get the intuition of why it would work but is there a formal demonstration/explanation?"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "For this, you first need to understand solving problems similar to this. Like, largest subarray having unique chars, largest subarray having freq of any char not > k, etc.... using the \\nSTEPS:\\n1)EXPAND\\n2)CHECK VALIDITY OF THE WINDOW -> IF NOT VALID, THEN CONVERT THE EXPANSION TO MOVING BY INCREMENTING THE LEFT INDEX OF WINDOW\\n\\nIf you use these steps, you end up with largest required window as we dont shrink the window.\\ni.e. we try to expand the window, if window is not valid after expansion, then just move\\n\\nSo, for your question, we know that we just need max of a window in this question,,,,hope i dont need to explain more\\n\\n"
                    },
                    {
                        "username": "user8272RT",
                        "content": "I got here after doing [239. Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/)\\n\\nThis was my initial approach\\n1. This is a sliding window problem, so find maximum charge time within window of width k using monotonic dequeue.\\n2. Use binary search to find maximum valid window width."
                    },
                    {
                        "username": "spushkar1526",
                        "content": "it is showing TLE after 82/82 testcases passed \nit shows the last test case as empty testcase\n\nhow to solve this?"
                    },
                    {
                        "username": "mukundsmith49",
                        "content": "try finding maximum element of a window using map\\n"
                    },
                    {
                        "username": "Alexis12828313",
                        "content": "Why does the following test case return a 4 as result?\\nChargeTimes = [74,46,19,34,7,87,7,40,28,81,53,39,3,46,21,40,76,44,88,93,44,50,22,59,46,60,36,24,50,40,56,5,39,9,24,74,7,14,95,45,36,17,22,12,53,41,2,33,100,73,20,70,81,91,28,98,47,88,79,100,78,38,44,74,48,76,73,92,28,30,95,87]\\n\\nrunningCosts = [11,33,15,40,8,28,97,89,51,42,17,57,45,5,63,53,23,43,76,64,86,86,89,53,94,91,78,12,90,29,79,48,35,6,88,79,82,76,44,93,83,55,65,96,86,24,54,65,94,4,26,73,51,85,47,99,17,14,76,2,39,52,58,5,15,35,79,16,94,16,59,50]\\n\\nbudget = 447\\nI tried a working function from solution and print the index of the possible solution, it showed me the index are 0 and 4. but if we calculate the result based on the question, we have: (11 + 33+15+40)*4 + Max(74,46,19,34) and the result is 470 > 447. Could anyone help me with that?"
                    },
                    {
                        "username": "ingato",
                        "content": "I'm getting the same thing. Everything else seems to pass and I can't see anything wrong in my code. My brute force method does return 4 though, so I must have a bug somewhere. I just don't see it.\n\nEdit: I figured it out. By adding some logging to my brute force approach I was able to find that index 1-5 are the ones that will actually be below budget and 4 long.\n\nI am using sliding window with a dequeue and in my logic when I have a  final cost over budge I remove the front element of the deque if it is equal to the charge time at my current left index, before shrinking the window. My problem was that I simply checked that accidentally against the \"runningCosts\" param instead of the \"chargeTimes\" param."
                    }
                ]
            }
        ]
    }
]