[
    {
        "title": "Integer to Roman",
        "question_content": "Roman numerals are represented by seven different symbols:&nbsp;I, V, X, L, C, D and M.\n\nSymbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\nFor example,&nbsp;2 is written as II&nbsp;in Roman numeral, just two one's added together. 12 is written as&nbsp;XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n\n\tI can be placed before V (5) and X (10) to make 4 and 9.&nbsp;\n\tX can be placed before L (50) and C (100) to make 40 and 90.&nbsp;\n\tC can be placed before D (500) and M (1000) to make 400 and 900.\n\nGiven an integer, convert it to a roman numeral.\n&nbsp;\nExample 1:\n\nInput: num = 3\nOutput: \"III\"\nExplanation: 3 is represented as 3 ones.\n\nExample 2:\n\nInput: num = 58\nOutput: \"LVIII\"\nExplanation: L = 50, V = 5, III = 3.\n\nExample 3:\n\nInput: num = 1994\nOutput: \"MCMXCIV\"\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n\n&nbsp;\nConstraints:\n\n\t1 <= num <= 3999",
        "solutions": [
            {
                "id": 6274,
                "title": "simple-solution",
                "content": "```\\npublic static String intToRoman(int num) {\\n    String M[] = {\"\", \"M\", \"MM\", \"MMM\"};\\n    String C[] = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n    String X[] = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\\n    String I[] = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\\n    return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10];\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic static String intToRoman(int num) {\\n    String M[] = {\"\", \"M\", \"MM\", \"MMM\"};\\n    String C[] = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n    String X[] = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\\n    String I[] = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\\n    return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 6310,
                "title": "my-java-solution-easy-to-understand",
                "content": "Reference:\\nhttp://blog.csdn.net/beiyeqingteng/article/details/8547565\\n\\npublic class Solution {\\n    public String intToRoman(int num) {\\n        \\n        int[] values = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        String[] strs = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(int i=0;i<values.length;i++) {\\n            while(num >= values[i]) {\\n                num -= values[i];\\n                sb.append(strs[i]);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String intToRoman(int num) {\\n        \\n        int[] values = {1000,900,500,400,100,90,50,40,10,9,5,4,1}",
                "codeTag": "Java"
            },
            {
                "id": 1293176,
                "title": "c-easy-solution-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ones[] = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        string tens[] = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        string hrns[] = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        string ths[]={\"\",\"M\",\"MM\",\"MMM\"};\\n        \\n        return ths[num/1000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ones[] = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        string tens[] = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        string hrns[] = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        string ths[]={\"\",\"M\",\"MM\",\"MMM\"};\\n        \\n        return ths[num/1000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962674,
                "title": "easiest-o-1-faang-method-ever",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ones[] = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        string tens[] = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        string hrns[] = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        string ths[]={\"\",\"M\",\"MM\",\"MMM\"};\\n        \\n        return ths[num/1000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\\n    }\\n};\\n```\\n\\n# ***Please Upvote if it helps \\u2764\\uFE0F***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Hash Table",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ones[] = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        string tens[] = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        string hrns[] = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        string ths[]={\"\",\"M\",\"MM\",\"MMM\"};\\n        \\n        return ths[num/1000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 6382,
                "title": "my-simple-cpp-solution",
                "content": "    class Solution {\\n    public:\\n        string intToRoman(int num) \\n        {\\n            string res;\\n            string sym[] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n            int val[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n            \\n            for(int i=0; num != 0; i++)\\n            {\\n                while(num >= val[i])\\n                {\\n                    num -= val[i];\\n                    res += sym[i];\\n                }\\n            }\\n            \\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string intToRoman(int num) \\n        {\\n            string res;\\n            string sym[] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"}",
                "codeTag": "Java"
            },
            {
                "id": 6304,
                "title": "python-simple-solution",
                "content": "        \\n    def intToRoman1(self, num):\\n        values = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ]\\n        numerals = [ \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" ]\\n        res, i = \"\", 0\\n        while num:\\n            res += (num//values[i]) * numerals[i]\\n            num %= values[i]\\n            i += 1\\n        return res\\n        \\n    def intToRoman(self, num):\\n        values = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ]\\n        numerals = [ \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" ]\\n        res = \"\"\\n        for i, v in enumerate(values):\\n            res += (num//v) * numerals[i]\\n            num %= v\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "        \\n    def intToRoman1(self, num):\\n        values = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ]\\n        numerals = [ \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" ]\\n        res, i = \"\", 0\\n        while num:\\n            res += (num//values[i]) * numerals[i]\\n            num %= values[i]\\n            i += 1\\n        return res\\n        \\n    def intToRoman(self, num):\\n        values = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ]\\n        numerals = [ \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" ]\\n        res = \"\"\\n        for i, v in enumerate(values):\\n            res += (num//v) * numerals[i]\\n            num %= v\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 3216797,
                "title": "easiest-beginner-friendly-sol-c-java-python",
                "content": "# Intuition of this Problem:\\nThis code takes a non-negative integer as input and converts it into its corresponding Roman numeral representation. The approach used here is to store the Roman numeral values and their corresponding symbols in a vector of pairs. The algorithm then iterates through the vector and repeatedly adds the corresponding symbols to the result string while subtracting the corresponding value from the input integer until the input integer becomes zero.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**NOTE - PLEASE READ APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Approach for this Problem:\\n1. Initialize an empty string called Roman to store the resulting Roman numeral.\\n2. Create a vector of pairs called storeIntRoman, to store the Roman numeral values and their corresponding symbols.\\n3. Iterate through the storeIntRoman vector using a for loop.\\n4. For each pair, check if the input integer is greater than or equal to the Roman numeral value.\\n5. If it is, add the corresponding symbol to the Roman string and subtract the corresponding value from the input integer.\\n6. Repeat steps 4-5 until the input integer becomes zero.\\n7. Return the Roman string.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Humble Request:\\n- If my solution is helpful to you then please **UPVOTE** my solution, your **UPVOTE** motivates me to post such kind of solution.\\n- Please let me know in comments if there is need to do any improvement in my approach, code....anything.\\n- **Let\\'s connect on** https://www.linkedin.com/in/abhinash-singh-1b851b188\\n\\n![57jfh9.jpg](https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg)\\n\\n# Code:\\n```C++ []\\n//Approach 1 : \\n//time complexity - O(1) since the algorithm always iterates through a constant number of values (13 in this case).\\n//O(1) since the amount of extra space used is constant (the size of the storeIntRoman vector, which is also 13 in this case\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string Roman = \"\";\\n        // Creating vector of pairs to store the Roman numeral values and their corresponding symbols\\n        vector<pair<int, string>> storeIntRoman = {{1000, \"M\"}, {900, \"CM\"}, {500, \"D\"}, {400, \"CD\"}, {100, \"C\"}, {90, \"XC\"}, {50, \"L\"}, {40, \"XL\"}, {10, \"X\"}, {9, \"IX\"}, {5, \"V\"}, {4, \"IV\"}, {1, \"I\"}};\\n        // Iterating through the vector and repeatedly adds the corresponding symbols to the result string while subtracting the corresponding value from the input integer until the input integer becomes zero.\\n        for (int i = 0; i < storeIntRoman.size(); i++) {\\n            while (num >= storeIntRoman[i].first) {\\n                Roman += storeIntRoman[i].second;\\n                num -= storeIntRoman[i].first;\\n            }\\n        }\\n        return Roman;\\n    }\\n};\\n```\\n```C++ []\\n//Approach 2\\n//time complexity - O(1) since the algorithm always iterates through a constant number of values (13 in this case).\\n//O(1) since the amount of extra space used is constant (the size of the storeIntRoman vector, which is also 13 in this case\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ones[] = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\\n        string tens[] = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\\n        string hundreds[] = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n        string thousands[]= {\"\", \"M\", \"MM\", \"MMM\"};\\n        \\n        string Roman =  thousands[num / 1000] + hundreds[(num % 1000) / 100] + tens[(num % 100) / 10] + ones[num % 10];\\n        return Roman;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public String intToRoman(int num) {\\n        String Roman = \"\";\\n        int[][] storeIntRoman = {{1000, \"M\"}, {900, \"CM\"}, {500, \"D\"}, {400, \"CD\"}, {100, \"C\"}, {90, \"XC\"}, {50, \"L\"}, {40, \"XL\"}, {10, \"X\"}, {9, \"IX\"}, {5, \"V\"}, {4, \"IV\"}, {1, \"I\"}};\\n        for (int i = 0; i < storeIntRoman.length; i++) {\\n            while (num >= storeIntRoman[i][0]) {\\n                Roman += storeIntRoman[i][1];\\n                num -= storeIntRoman[i][0];\\n            }\\n        }\\n        return Roman;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        Roman = \"\"\\n        storeIntRoman = [[1000, \"M\"], [900, \"CM\"], [500, \"D\"], [400, \"CD\"], [100, \"C\"], [90, \"XC\"], [50, \"L\"], [40, \"XL\"], [10, \"X\"], [9, \"IX\"], [5, \"V\"], [4, \"IV\"], [1, \"I\"]]\\n        for i in range(len(storeIntRoman)):\\n            while num >= storeIntRoman[i][0]:\\n                Roman += storeIntRoman[i][1]\\n                num -= storeIntRoman[i][0]\\n        return Roman\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(13) = O(1)** - Approach 1\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(13) = O(1)** - Approach 1\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Hash Table",
                    "Math"
                ],
                "code": "```C++ []\\n//Approach 1 : \\n//time complexity - O(1) since the algorithm always iterates through a constant number of values (13 in this case).\\n//O(1) since the amount of extra space used is constant (the size of the storeIntRoman vector, which is also 13 in this case\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string Roman = \"\";\\n        // Creating vector of pairs to store the Roman numeral values and their corresponding symbols\\n        vector<pair<int, string>> storeIntRoman = {{1000, \"M\"}, {900, \"CM\"}, {500, \"D\"}, {400, \"CD\"}, {100, \"C\"}, {90, \"XC\"}, {50, \"L\"}, {40, \"XL\"}, {10, \"X\"}, {9, \"IX\"}, {5, \"V\"}, {4, \"IV\"}, {1, \"I\"}};\\n        // Iterating through the vector and repeatedly adds the corresponding symbols to the result string while subtracting the corresponding value from the input integer until the input integer becomes zero.\\n        for (int i = 0; i < storeIntRoman.size(); i++) {\\n            while (num >= storeIntRoman[i].first) {\\n                Roman += storeIntRoman[i].second;\\n                num -= storeIntRoman[i].first;\\n            }\\n        }\\n        return Roman;\\n    }\\n};\\n```\n```C++ []\\n//Approach 2\\n//time complexity - O(1) since the algorithm always iterates through a constant number of values (13 in this case).\\n//O(1) since the amount of extra space used is constant (the size of the storeIntRoman vector, which is also 13 in this case\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ones[] = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\\n        string tens[] = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\\n        string hundreds[] = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n        string thousands[]= {\"\", \"M\", \"MM\", \"MMM\"};\\n        \\n        string Roman =  thousands[num / 1000] + hundreds[(num % 1000) / 100] + tens[(num % 100) / 10] + ones[num % 10];\\n        return Roman;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public String intToRoman(int num) {\\n        String Roman = \"\";\\n        int[][] storeIntRoman = {{1000, \"M\"}, {900, \"CM\"}, {500, \"D\"}, {400, \"CD\"}, {100, \"C\"}, {90, \"XC\"}, {50, \"L\"}, {40, \"XL\"}, {10, \"X\"}, {9, \"IX\"}, {5, \"V\"}, {4, \"IV\"}, {1, \"I\"}};\\n        for (int i = 0; i < storeIntRoman.length; i++) {\\n            while (num >= storeIntRoman[i][0]) {\\n                Roman += storeIntRoman[i][1];\\n                num -= storeIntRoman[i][0];\\n            }\\n        }\\n        return Roman;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        Roman = \"\"\\n        storeIntRoman = [[1000, \"M\"], [900, \"CM\"], [500, \"D\"], [400, \"CD\"], [100, \"C\"], [90, \"XC\"], [50, \"L\"], [40, \"XL\"], [10, \"X\"], [9, \"IX\"], [5, \"V\"], [4, \"IV\"], [1, \"I\"]]\\n        for i in range(len(storeIntRoman)):\\n            while num >= storeIntRoman[i][0]:\\n                Roman += storeIntRoman[i][1]\\n                num -= storeIntRoman[i][0]\\n        return Roman\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1102775,
                "title": "js-python-java-c-simple-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nJust like Roman to Integer, this problem is most easily solved using a **lookup table** for the conversion between digit and numeral. In this case, we can easily deal with the values in descending order and insert the appropriate numeral (or numerals) as many times as we can while reducing the our target number (**N**) by the same amount.\\n\\nOnce **N** runs out, we can **return ans**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nJava\\'s **StringBuilder** can take care of repeated string concatenations without some of the overhead of making string copies.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **124ms / 43.5MB** (beats 100% / 100%).\\n```javascript\\nconst val = [1000,900,500,400,100,90,50,40,10,9,5,4,1]\\nconst rom = [\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"]\\n\\nvar intToRoman = function(N) {\\n    let ans = \"\"\\n    for (let i = 0; N; i++)\\n        while (N >= val[i]) ans += rom[i], N -= val[i]\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **40ms / 14.1MB** (beats 95% / 86%).\\n```python\\nval = [1000,900,500,400,100,90,50,40,10,9,5,4,1]\\nrom = [\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"]\\n\\nclass Solution:\\n    def intToRoman(self, N: int) -> str:\\n        ans = \"\"\\n        for i in range(13):\\n            while N >= val[i]:\\n                ans += rom[i]\\n                N -= val[i]\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **3ms / 38.1MB** (beats 100% / 95%).\\n```java\\nclass Solution {\\n    final static int[] val = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n    final static String[] rom = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n\\n    public String intToRoman(int N) {\\n        StringBuilder ans = new StringBuilder();\\n        for (int i = 0; N > 0; i++)\\n            while (N >= val[i]) {\\n                ans.append(rom[i]);\\n                N -= val[i];\\n            }\\n        return ans.toString();\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 5.8MB** (beats 100% / 98%).\\n```c++\\nclass Solution {\\npublic:\\n    const int val[13] = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n    const string rom[13] = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n\\n    string intToRoman(int N) {\\n        string ans = \"\";\\n        for (int i = 0; N; i++)\\n            while (N >= val[i]) ans += rom[i], N -= val[i];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nconst val = [1000,900,500,400,100,90,50,40,10,9,5,4,1]\\nconst rom = [\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"]\\n\\nvar intToRoman = function(N) {\\n    let ans = \"\"\\n    for (let i = 0; N; i++)\\n        while (N >= val[i]) ans += rom[i], N -= val[i]\\n    return ans\\n};\\n```\n```python\\nval = [1000,900,500,400,100,90,50,40,10,9,5,4,1]\\nrom = [\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"]\\n\\nclass Solution:\\n    def intToRoman(self, N: int) -> str:\\n        ans = \"\"\\n        for i in range(13):\\n            while N >= val[i]:\\n                ans += rom[i]\\n                N -= val[i]\\n        return ans\\n```\n```java\\nclass Solution {\\n    final static int[] val = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n    final static String[] rom = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n\\n    public String intToRoman(int N) {\\n        StringBuilder ans = new StringBuilder();\\n        for (int i = 0; N > 0; i++)\\n            while (N >= val[i]) {\\n                ans.append(rom[i]);\\n                N -= val[i];\\n            }\\n        return ans.toString();\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    const int val[13] = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n    const string rom[13] = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n\\n    string intToRoman(int N) {\\n        string ans = \"\";\\n        for (int i = 0; N; i++)\\n            while (N >= val[i]) ans += rom[i], N -= val[i];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724200,
                "title": "python-s-simple-and-easy-to-understand-solution-99-faster",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n\\nVisit this blog to learn Python tips and techniques and to find a Leetcode solution with an explanation:  https://www.python-techs.com/\\n\\n**Solution:**\\n```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        # Creating Dictionary for Lookup\\n        num_map = {\\n            1: \"I\",\\n            5: \"V\",    4: \"IV\",\\n            10: \"X\",   9: \"IX\",\\n            50: \"L\",   40: \"XL\",\\n            100: \"C\",  90: \"XC\",\\n            500: \"D\",  400: \"CD\",\\n            1000: \"M\", 900: \"CM\",\\n        }\\n        \\n        # Result Variable\\n        r = \\'\\'\\n        \\n        \\n        for n in [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]:\\n            # If n in list then add the roman value to result variable\\n            while n <= num:\\n                r += num_map[n]\\n                num-=n\\n        return r\\n```\\n**Thank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        # Creating Dictionary for Lookup\\n        num_map = {\\n            1: \"I\",\\n            5: \"V\",    4: \"IV\",\\n            10: \"X\",   9: \"IX\",\\n            50: \"L\",   40: \"XL\",\\n            100: \"C\",  90: \"XC\",\\n            500: \"D\",  400: \"CD\",\\n            1000: \"M\", 900: \"CM\",\\n        }\\n        \\n        # Result Variable\\n        r = \\'\\'\\n        \\n        \\n        for n in [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]:\\n            # If n in list then add the roman value to result variable\\n            while n <= num:\\n                r += num_map[n]\\n                num-=n\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2723774,
                "title": "c-simple-and-easy-solution",
                "content": "**Please connect with me if u like my solution**\\n**Please Upvote**\\nhttps://www.linkedin.com/in/shubham-roy-0b71a0220/\\n\\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        int normal[]={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        string roman[]={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        string res;\\n        for(int i=0;i<13;i++){\\n            while(num>=normal[i]){\\n                res.append(roman[i]);\\n                num-=normal[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        int normal[]={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        string roman[]={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        string res;\\n        for(int i=0;i<13;i++){\\n            while(num>=normal[i]){\\n                res.append(roman[i]);\\n                num-=normal[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 6273,
                "title": "share-my-python-solution-96ms",
                "content": "    M = [\"\", \"M\", \"MM\", \"MMM\"];\\n    C = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"];\\n    X = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"];\\n    I = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"];\\n    return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10];",
                "solutionTags": [
                    "Python"
                ],
                "code": "    M = [\"\", \"M\", \"MM\", \"MMM\"];\\n    C = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"];\\n    X = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"];\\n    I = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"];\\n    return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10];",
                "codeTag": "Unknown"
            },
            {
                "id": 292605,
                "title": "python-solution-44ms",
                "content": "if this helps, please upvote! Thanks!\\n\\n```class Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d = {1000: \\'M\\', 900: \\'CM\\', 500: \\'D\\', 400: \\'CD\\', 100: \\'C\\', 90: \\'XC\\', 50: \\'L\\', 40: \\'XL\\', 10: \\'X\\', 9: \\'IX\\', 5: \\'V\\', 4: \\'IV\\', 1: \\'I\\'}\\n        res = \\'\\'\\n        for k in d:\\n            while num >= k:\\n                res += d[k]\\n                num -= k\\n        return res\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d = {1000: \\'M\\', 900: \\'CM\\', 500: \\'D\\', 400: \\'CD\\', 100: \\'C\\', 90: \\'XC\\', 50: \\'L\\', 40: \\'XL\\', 10: \\'X\\', 9: \\'IX\\', 5: \\'V\\', 4: \\'IV\\', 1: \\'I\\'}",
                "codeTag": "Java"
            },
            {
                "id": 6361,
                "title": "a-simple-python-code-easy-to-understand",
                "content": "```python\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        dict = [\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"]\\n        nums = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\\n        result = \"\"\\n        for letter, n in zip(dict, nums):\\n            result += letter * int(num / n)\\n            num %= n\\n        return result\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        dict = [\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"]\\n        nums = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\\n        result = \"\"\\n        for letter, n in zip(dict, nums):\\n            result += letter * int(num / n)\\n            num %= n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 462641,
                "title": "python-pythonic-simple-solution-88-9-100-0",
                "content": "If you like, please upvote!\\n```\\ndef intToRoman(num: int):\\n    roman = {\\n        1000: \\'M\\',\\n        900: \\'CM\\',\\n        500: \\'D\\',\\n        400: \\'CD\\',\\n        100: \\'C\\',\\n        90: \\'XC\\',\\n        50: \\'L\\',\\n        40: \\'XL\\',\\n        10: \\'X\\',\\n        9: \\'IX\\',\\n        5: \\'V\\',\\n        4: \\'IV\\',\\n        1: \\'I\\'\\n        }\\n    romanized = \\'\\'\\n\\n    for base, symb in roman.items():\\n        romanized += symb * (num // base)\\n        num %= base\\n    else:\\n        return romanized\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef intToRoman(num: int):\\n    roman = {\\n        1000: \\'M\\',\\n        900: \\'CM\\',\\n        500: \\'D\\',\\n        400: \\'CD\\',\\n        100: \\'C\\',\\n        90: \\'XC\\',\\n        50: \\'L\\',\\n        40: \\'XL\\',\\n        10: \\'X\\',\\n        9: \\'IX\\',\\n        5: \\'V\\',\\n        4: \\'IV\\',\\n        1: \\'I\\'\\n        }\\n    romanized = \\'\\'\\n\\n    for base, symb in roman.items():\\n        romanized += symb * (num // base)\\n        num %= base\\n    else:\\n        return romanized\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 6376,
                "title": "simple-java-solution",
                "content": "    public String intToRoman(int num) {\\n        String M[] = {\"\", \"M\", \"MM\", \"MMM\"};\\n        String C[] = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n        String X[] = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\\n        String I[] = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\\n        return M[num/1000] + C[(num%1000)/100]+ X[(num%100)/10] + I[num%10];\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public String intToRoman(int num) {\\n        String M[] = {\"\", \"M\", \"MM\", \"MMM\"};\\n        String C[] = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n        String X[] = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\\n        String I[] = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\\n        return M[num/1000] + C[(num%1000)/100]+ X[(num%100)/10] + I[num%10];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 6489,
                "title": "sharing-my-really-simple-solution-with-explanation",
                "content": "    string intToRoman(int num) {\\n        string table[4][10] = {{\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"},\\n                               {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"},\\n                               {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"},\\n                               {\"\", \"M\", \"MM\", \"MMM\"}\\n                              };\\n        string result;\\n        int count = 0;\\n        while(num > 0){\\n            int temp = num % 10;\\n            result = table[count][temp] + result;\\n            num /= 10;\\n            count++;\\n        }\\n        return result;\\n    }\\n\\nThe basic idea is really simple: replace every digit in num by roman numerals.\\n\\nFor example, we have a num: 2438.\\n\\n2 --> \"MM\"\\n\\n4 --> \"CD\"\\n\\n3 --> \"XXX\"\\n\\n8 --> \"VIII\"\\n\\nThen the result is \"MMCDXXXVIII\".",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "    string intToRoman(int num) {\\n        string table[4][10] = {{\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"},\\n                               {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"},\\n                               {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"},\\n                               {\"\", \"M\", \"MM\", \"MMM\"}\\n                              };\\n        string result;\\n        int count = 0;\\n        while(num > 0){\\n            int temp = num % 10;\\n            result = table[count][temp] + result;\\n            num /= 10;\\n            count++;\\n        }\\n        return result;\\n    }\\n\\nThe basic idea is really simple: replace every digit in num by roman numerals.\\n\\nFor example, we have a num: 2438.\\n\\n2 --> \"MM\"\\n\\n4 --> \"CD\"\\n\\n3 --> \"XXX\"\\n\\n8 --> \"VIII\"\\n\\nThen the result is \"MMCDXXXVIII\".",
                "codeTag": "Unknown"
            },
            {
                "id": 1144148,
                "title": "accepted-solution-for-swift",
                "content": "<blockquote>\\n<b>Disclaimer:</b> By using any content from this post or thread, you release the author(s) from all liability and warranty of any kind. You are free to use the content freely and as you see fit. Any suggestions for improvement are welcome and greatly appreciated! Happy coding!\\n</blockquote>\\n\\n```swift\\nclass Solution {\\n    \\n    private let values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\\n    private let symbols = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\\n    \\n    func intToRoman(_ num: Int) -> String {\\n        \\n        var int = num\\n        var sym = \"\"\\n        \\n        while int > 0 {\\n            for (i, d) in values.enumerated() where int - d >= 0 {\\n                int -= d\\n                sym += symbols[i]\\n                break\\n            }\\n        }\\n        return sym\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 3 tests, with 0 failures (0 unexpected) in 0.013 (0.015) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // 3 is represented as 3 ones.\\n    func test0() {\\n        let value = solution.intToRoman(3)\\n        XCTAssertEqual(value, \"III\")\\n    }\\n    \\n    // L = 50, V = 5, III = 3.\\n    func test1() {\\n        let value = solution.intToRoman(58)\\n        XCTAssertEqual(value, \"LVIII\")\\n    }\\n    \\n    // M = 1000, CM = 900, XC = 90 and IV = 4.\\n    func test2() {\\n        let value = solution.intToRoman(1994)\\n        XCTAssertEqual(value, \"MCMXCIV\")\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    \\n    private let values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\\n    private let symbols = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\\n    \\n    func intToRoman(_ num: Int) -> String {\\n        \\n        var int = num\\n        var sym = \"\"\\n        \\n        while int > 0 {\\n            for (i, d) in values.enumerated() where int - d >= 0 {\\n                int -= d\\n                sym += symbols[i]\\n                break\\n            }\\n        }\\n        return sym\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // 3 is represented as 3 ones.\\n    func test0() {\\n        let value = solution.intToRoman(3)\\n        XCTAssertEqual(value, \"III\")\\n    }\\n    \\n    // L = 50, V = 5, III = 3.\\n    func test1() {\\n        let value = solution.intToRoman(58)\\n        XCTAssertEqual(value, \"LVIII\")\\n    }\\n    \\n    // M = 1000, CM = 900, XC = 90 and IV = 4.\\n    func test2() {\\n        let value = solution.intToRoman(1994)\\n        XCTAssertEqual(value, \"MCMXCIV\")\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 401764,
                "title": "clean-javascript-solution-using-map",
                "content": "Here\\'s clean javascript solution:\\n\\nFirst version using ```forEach```:\\n```\\nfunction intToRoman(num) {\\n    const map = { M: 1000, CM: 900, D: 500, CD: 400, C: 100, XC: 90, L: 50, XL: 40, X: 10, IX: 9, V: 5, IV: 4, I: 1 };\\n    let result = \\'\\';\\n    Object.entries(map).forEach(([letter, n]) => {\\n        result += letter.repeat(Math.floor(num / n));\\n        num %= n;\\n    });\\n    return result;\\n}\\n```\\n\\nSecond version with ```reduce```:\\n\\n```\\nfunction intToRoman(num) {\\n    const map = { M: 1000, CM: 900, D: 500, CD: 400, C: 100, XC: 90, L: 50, XL: 40, X: 10, IX: 9, V: 5, IV: 4, I: 1 };\\n    return Object.entries(map).reduce((result, [letter, n]) => {\\n        result += letter.repeat(Math.floor(num / n));\\n        num %= n;\\n        return result;\\n    }, \\'\\');\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```forEach```\n```\\nfunction intToRoman(num) {\\n    const map = { M: 1000, CM: 900, D: 500, CD: 400, C: 100, XC: 90, L: 50, XL: 40, X: 10, IX: 9, V: 5, IV: 4, I: 1 };\\n    let result = \\'\\';\\n    Object.entries(map).forEach(([letter, n]) => {\\n        result += letter.repeat(Math.floor(num / n));\\n        num %= n;\\n    });\\n    return result;\\n}\\n```\n```reduce```\n```\\nfunction intToRoman(num) {\\n    const map = { M: 1000, CM: 900, D: 500, CD: 400, C: 100, XC: 90, L: 50, XL: 40, X: 10, IX: 9, V: 5, IV: 4, I: 1 };\\n    return Object.entries(map).reduce((result, [letter, n]) => {\\n        result += letter.repeat(Math.floor(num / n));\\n        num %= n;\\n        return result;\\n    }, \\'\\');\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 6309,
                "title": "more-generalizable-solution-can-be-extended-to-any-roman-to-integer-conversion",
                "content": "This solution includes generalizability. Even if the number to be converted is > 3999, it works without making extra effort for finding cases.\\n```\\nbool isMul(int n) {\\n        return (n + 1) % 5 == 0;\\n    }\\n    int getMult(const int & n) {\\n        if(n / 1000 > 0) return 1000;\\n        if(n / 100 > 0) return 100;\\n        if(n / 10 > 0) return 10;\\n        return 1;\\n    }\\n    string subProb(int &num) {\\n        map<int,string> val;\\n        val[1] = \"I\";\\n        val[5] = \"V\";\\n        val[10] = \"X\";\\n        val[50] = \"L\";\\n        val[100] = \"C\";\\n        val[500] = \"D\";\\n        val[1000] = \"M\";\\n        int multiple = getMult(num);\\n        string ans = \"\";\\n        int value = num / multiple;\\n        if(value == 4) ans += (val[multiple] + val[5 * multiple]), value -=4;\\n        else if(value == 9) ans += (val[multiple] + val[10 * multiple]), value -=9;\\n        else if(value >= 5) {\\n            ans += val[5 * multiple];\\n            value -= 5;\\n        }\\n        for(int i = 0; i < value; i ++) ans += val[multiple];\\n        num %= multiple;\\n        return ans;\\n    }\\n    string intToRoman(int num) {\\n        string ans = \"\";\\n        while(num > 0) ans += subProb(num);\\n        return ans;\\n        \\n    }\\n```\\n\\nHope you like the solution",
                "solutionTags": [],
                "code": "```\\nbool isMul(int n) {\\n        return (n + 1) % 5 == 0;\\n    }\\n    int getMult(const int & n) {\\n        if(n / 1000 > 0) return 1000;\\n        if(n / 100 > 0) return 100;\\n        if(n / 10 > 0) return 10;\\n        return 1;\\n    }\\n    string subProb(int &num) {\\n        map<int,string> val;\\n        val[1] = \"I\";\\n        val[5] = \"V\";\\n        val[10] = \"X\";\\n        val[50] = \"L\";\\n        val[100] = \"C\";\\n        val[500] = \"D\";\\n        val[1000] = \"M\";\\n        int multiple = getMult(num);\\n        string ans = \"\";\\n        int value = num / multiple;\\n        if(value == 4) ans += (val[multiple] + val[5 * multiple]), value -=4;\\n        else if(value == 9) ans += (val[multiple] + val[10 * multiple]), value -=9;\\n        else if(value >= 5) {\\n            ans += val[5 * multiple];\\n            value -= 5;\\n        }\\n        for(int i = 0; i < value; i ++) ans += val[multiple];\\n        num %= multiple;\\n        return ans;\\n    }\\n    string intToRoman(int num) {\\n        string ans = \"\";\\n        while(num > 0) ans += subProb(num);\\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 6281,
                "title": "two-lines-can-do-the-job",
                "content": "String[] romanPieces={\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\",\\n\\t\\t\\t\\t\\t\\t\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\",\\n\\t\\t\\t\\t\\t\\t\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\",\\n\\t\\t\\t\\t\\t\\t\"\",\"M\",\"MM\",\"MMM\",\"MMMM\"};\\nreturn romanPieces[num/1000+30]+romanPieces[(num/100)%10+20]\\n\\t\\t\\t\\t\\t+romanPieces[(num/10)%10+10]+romanPieces[num%10];",
                "solutionTags": [],
                "code": "String[] romanPieces={\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\",\\n\\t\\t\\t\\t\\t\\t\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\",\\n\\t\\t\\t\\t\\t\\t\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\",\\n\\t\\t\\t\\t\\t\\t\"\",\"M\",\"MM\",\"MMM\",\"MMMM\"};\\nreturn romanPieces[num/1000+30]+romanPieces[(num/100)%10+20]\\n\\t\\t\\t\\t\\t+romanPieces[(num/10)%10+10]+romanPieces[num%10];",
                "codeTag": "Unknown"
            },
            {
                "id": 6432,
                "title": "easy-to-understand-java-solution",
                "content": "public class Solution {\\n\\n    public enum Type{\\n        M(1000),CM(900),D(500),CD(400),C(100),XC(90),L(50),XL(40),X(10),IX(9),V(5),IV(4),I(1);\\n        private final int value;\\n        Type(int value) {\\n            this.value = value;\\n        }\\n    };\\n    public String intToRoman(int num) {\\n        StringBuilder output = new StringBuilder();\\n        for (Type t:Type.values()) {\\n            while (num>=t.value) {\\n                output.append(t);\\n                num -= t.value;\\n            }\\n        }\\n        return output.toString();\\n    }\\n\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public enum Type{\\n        M(1000),CM(900),D(500),CD(400),C(100),XC(90),L(50),XL(40),X(10),IX(9),V(5),IV(4),I(1);\\n        private final int value;\\n        Type(int value) {\\n            this.value = value;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3512574,
                "title": "c-java-python-javascript-5-lines-of-code-100-simple-solution",
                "content": "# Intuition:\\nThe given problem is about converting an integer into a Roman numeral. To do this, we can create arrays that represent the Roman numeral symbols for each place value (ones, tens, hundreds, thousands). Then, we can divide the given number into its respective place values and concatenate the corresponding Roman numeral symbols.\\n\\n# Approach:\\n1. Create four arrays: `ones`, `tens`, `hrns`, and `ths`, representing the Roman numeral symbols for ones, tens, hundreds, and thousands respectively. Each array contains the symbols for the numbers from 0 to 9 in their respective place value.\\n2. Divide the given number `num` into its respective place values:\\n   - `thousands = num / 1000`\\n   - `hundreds = (num % 1000) / 100`\\n   - `tens = (num % 100) / 10`\\n   - `ones = num % 10`\\n3. Concatenate the Roman numeral symbols based on the place values:\\n   - `ths[num/1000]` represents the Roman numeral for thousands place.\\n   - `hrns[(num%1000)/100]` represents the Roman numeral for hundreds place.\\n   - `tens[(num%100)/10]` represents the Roman numeral for tens place.\\n   - `ones[num%10]` represents the Roman numeral for ones place.\\n4. Return the concatenation of the Roman numeral symbols obtained from step 3.\\n\\n# Complexity:\\n- Time complexity: O(1) because the number of digits in the given number is constant (up to 4 digits for the given range).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) because the arrays storing the Roman numeral values have fixed sizes.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ones[] = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        string tens[] = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        string hrns[] = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        string ths[]={\"\",\"M\",\"MM\",\"MMM\"};\\n        \\n        return ths[num/1000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\\n    }\\n};\\n```\\n\\n---\\n# JAVA\\n```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        String[] ones = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\\n        String[] tens = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\\n        String[] hrns = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n        String[] ths = {\"\", \"M\", \"MM\", \"MMM\"};\\n\\n        return ths[num / 1000] + hrns[(num % 1000) / 100] + tens[(num % 100) / 10] + ones[num % 10];\\n    }\\n}\\n\\n```\\n\\n---\\n# JavaScript\\n```\\nvar intToRoman = function(num) {\\n    const ones = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"];\\n    const tens = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"];\\n    const hrns = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"];\\n    const ths = [\"\", \"M\", \"MM\", \"MMM\"];\\n    return ths[Math.floor(num / 1000)] + hrns[Math.floor((num % 1000) / 100)] + tens[Math.floor((num % 100) / 10)] + ones[num % 10];\\n};\\n```\\n---\\n# Python\\n```\\nclass Solution:\\n    def intToRoman(self, num):\\n        ones = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"]\\n        tens = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"]\\n        hrns = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"]\\n        ths = [\"\", \"M\", \"MM\", \"MMM\"]\\n\\n        return ths[num / 1000] + hrns[(num % 1000) / 100] + tens[(num % 100) / 10] + ones[num % 10]\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ones[] = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        string tens[] = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        string hrns[] = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        string ths[]={\"\",\"M\",\"MM\",\"MMM\"};\\n        \\n        return ths[num/1000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        String[] ones = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\\n        String[] tens = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\\n        String[] hrns = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n        String[] ths = {\"\", \"M\", \"MM\", \"MMM\"};\\n\\n        return ths[num / 1000] + hrns[(num % 1000) / 100] + tens[(num % 100) / 10] + ones[num % 10];\\n    }\\n}\\n\\n```\n```\\nvar intToRoman = function(num) {\\n    const ones = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"];\\n    const tens = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"];\\n    const hrns = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"];\\n    const ths = [\"\", \"M\", \"MM\", \"MMM\"];\\n    return ths[Math.floor(num / 1000)] + hrns[Math.floor((num % 1000) / 100)] + tens[Math.floor((num % 100) / 10)] + ones[num % 10];\\n};\\n```\n```\\nclass Solution:\\n    def intToRoman(self, num):\\n        ones = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"]\\n        tens = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"]\\n        hrns = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"]\\n        ths = [\"\", \"M\", \"MM\", \"MMM\"]\\n\\n        return ths[num / 1000] + hrns[(num % 1000) / 100] + tens[(num % 100) / 10] + ones[num % 10]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1422472,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        int intCode[]={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        string code[]={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        \\n        string s;\\n        for(int i=0; i<13; ++i){\\n            while(num>=intCode[i]){\\n                s.append(code[i]);\\n                num-=intCode[i];\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        int intCode[]={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        string code[]={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        \\n        string s;\\n        for(int i=0; i<13; ++i){\\n            while(num>=intCode[i]){\\n                s.append(code[i]);\\n                num-=intCode[i];\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2723782,
                "title": "java-explained-in-detail-simple-fast-solution-dictionary",
                "content": "I do my best everyday to give a clear explanation, so to help everyone improve their skills.\\n\\nIf you find this **helpful**, please \\uD83D\\uDC4D **upvote** this post and watch my [Github Repository](https://github.com/cheehwatang/leetcode-java).\\n\\nThank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.\\n\\n---\\n\\n#### Java - Using Dictionary - Approach 1\\n\\n```\\npublic String intToRoman(int num) {\\n\\n        // Approach:\\n        // This method uses two arrays with the corresponding integer-roman map, in descending order.\\n\\n        int[] value = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        String[] roman = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n\\n        StringBuilder romanNumeral = new StringBuilder();\\n\\n        for (int i = 0; i < value.length && num > 0; i++) {\\n            // Check from the highest value, 1000 to the smallest.\\n            // If it is possible to subtract, for example 400, we know the roman numeral next is \"CD\".\\n            while (num >= value[i]) {\\n                romanNumeral.append(roman[i]);\\n                num -= value[i];\\n            }\\n        }\\n        return romanNumeral.toString();\\n    }\\n```\\n---\\n\\n#### Java - Without Dictionary - Approach 2\\n```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        String romanNumeral = \"\";\\n        while (num >= 1000) {\\n            romanNumeral += \"M\";\\n            num -= 1000;\\n        }\\n        while (num >= 900) {\\n            romanNumeral += \"CM\";\\n            num -= 900;\\n        }\\n        while (num >= 500) {\\n            romanNumeral += \"D\";\\n            num -= 500;\\n        }\\n        while (num >= 400) {\\n            romanNumeral += \"CD\";\\n            num -= 400;\\n        }\\n        while (num >= 100) {\\n            romanNumeral += \"C\";\\n            num -= 100;\\n        }\\n        while (num >= 90) {\\n            romanNumeral += \"XC\";\\n            num -= 90;\\n        }\\n        while (num >= 50) {\\n            romanNumeral += \"L\";\\n            num -= 50;\\n        }\\n        while (num >= 40) {\\n            romanNumeral += \"XL\";\\n            num -= 40;\\n        }\\n        while (num >= 10) {\\n            romanNumeral += \"X\";\\n            num -= 10;\\n        }\\n        while (num >= 9) {\\n            romanNumeral += \"IX\";\\n            num -= 9;\\n        }\\n        while (num >= 5) {\\n            romanNumeral += \"V\";\\n            num -= 5;\\n        }\\n        while (num >= 4) {\\n            romanNumeral += \"IV\";\\n            num -= 4;\\n        }\\n        while (num >= 1) {\\n            romanNumeral += \"I\";\\n            num -= 1;\\n        }\\n\\n        return romanNumeral;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String intToRoman(int num) {\\n\\n        // Approach:\\n        // This method uses two arrays with the corresponding integer-roman map, in descending order.\\n\\n        int[] value = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        String[] roman = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n\\n        StringBuilder romanNumeral = new StringBuilder();\\n\\n        for (int i = 0; i < value.length && num > 0; i++) {\\n            // Check from the highest value, 1000 to the smallest.\\n            // If it is possible to subtract, for example 400, we know the roman numeral next is \"CD\".\\n            while (num >= value[i]) {\\n                romanNumeral.append(roman[i]);\\n                num -= value[i];\\n            }\\n        }\\n        return romanNumeral.toString();\\n    }\\n```\n```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        String romanNumeral = \"\";\\n        while (num >= 1000) {\\n            romanNumeral += \"M\";\\n            num -= 1000;\\n        }\\n        while (num >= 900) {\\n            romanNumeral += \"CM\";\\n            num -= 900;\\n        }\\n        while (num >= 500) {\\n            romanNumeral += \"D\";\\n            num -= 500;\\n        }\\n        while (num >= 400) {\\n            romanNumeral += \"CD\";\\n            num -= 400;\\n        }\\n        while (num >= 100) {\\n            romanNumeral += \"C\";\\n            num -= 100;\\n        }\\n        while (num >= 90) {\\n            romanNumeral += \"XC\";\\n            num -= 90;\\n        }\\n        while (num >= 50) {\\n            romanNumeral += \"L\";\\n            num -= 50;\\n        }\\n        while (num >= 40) {\\n            romanNumeral += \"XL\";\\n            num -= 40;\\n        }\\n        while (num >= 10) {\\n            romanNumeral += \"X\";\\n            num -= 10;\\n        }\\n        while (num >= 9) {\\n            romanNumeral += \"IX\";\\n            num -= 9;\\n        }\\n        while (num >= 5) {\\n            romanNumeral += \"V\";\\n            num -= 5;\\n        }\\n        while (num >= 4) {\\n            romanNumeral += \"IV\";\\n            num -= 4;\\n        }\\n        while (num >= 1) {\\n            romanNumeral += \"I\";\\n            num -= 1;\\n        }\\n\\n        return romanNumeral;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975240,
                "title": "java-runtime-3ms-beats-98-91-o-1",
                "content": "# Intuition\\nMy initial approach to solving this problem involves converting an integer to its Roman numeral representation using a predefined set of values and corresponding Roman numeral symbols.\\n\\n# Approach\\nTo achieve this, I utilize a greedy approach where I repeatedly subtract the largest possible value from the given number while appending the corresponding Roman numeral symbol to the result string. I maintain two arrays: `values`, which contains the integer values corresponding to Roman numerals, and `romanNumerals`, which contains the corresponding Roman numeral symbols.\\n\\nStarting with the largest value, I iterate through the `values` array and at each step, I check if the current value can be subtracted from the given number. If it can be, I append the corresponding Roman numeral symbol to the result string and subtract the value from the number. If not, I move on to the next smaller value.\\n\\nI continue this process until the given number becomes zero, and the result string represents the Roman numeral equivalent of the original number.\\n\\n# Complexity\\n- Time complexity: O(1)\\n  The algorithm performs a constant number of operations regardless of the magnitude of the input number. The iteration through the `values` array and the subsequent calculations are independent of the value of the input.\\n\\n- Space complexity: O(1)\\n  The algorithm uses a fixed amount of additional memory space for variables and arrays, leading to a constant space complexity.\\n\\n# Code\\n```java\\nclass Solution {\\n    public String intToRoman(int num) {\\n     \\n        int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        String[] romanNumerals = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n\\n        StringBuilder sb = new StringBuilder();\\n\\n        int i = 0;\\n    \\n        while (num > 0) {\\n            if (num >= values[i]) {\\n                \\n                sb.append(romanNumerals[i]);\\n                num -= values[i];\\n            } else {\\n                i++;\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n\\n```\\n![c0504eaf-5fb8-4a1d-a769-833262d1b86e_1674433591.3836212.webp](https://assets.leetcode.com/users/images/8a3b41d1-f0ca-472f-a9f7-8346b34a824e_1693297402.2918687.webp)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public String intToRoman(int num) {\\n     \\n        int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        String[] romanNumerals = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n\\n        StringBuilder sb = new StringBuilder();\\n\\n        int i = 0;\\n    \\n        while (num > 0) {\\n            if (num >= values[i]) {\\n                \\n                sb.append(romanNumerals[i]);\\n                num -= values[i];\\n            } else {\\n                i++;\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421938,
                "title": "awesome-python-solution",
                "content": "\\n\\n# Python Solution\\n```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        M=[\"\",\"M\",\"MM\",\"MMM\"]\\n        C=[\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"]\\n        X=[\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"]\\n        I=[\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"]\\n        return M[num//1000]+C[num%1000//100]+X[num%1000%100//10]+I[num%1000%100%10]\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        M=[\"\",\"M\",\"MM\",\"MMM\"]\\n        C=[\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"]\\n        X=[\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"]\\n        I=[\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"]\\n        return M[num//1000]+C[num%1000//100]+X[num%1000%100//10]+I[num%1000%100%10]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531193,
                "title": "python-solution-without-big-table",
                "content": "I think my solution is good in terms of scalability -- No need to create big table :)\\n\\n``` python\\ndef intToRoman(self, num: int) -> str:\\n\\tones = [\\'I\\', \\'X\\', \\'C\\', \\'M\\']\\n\\tfives = [\\'V\\', \\'L\\', \\'D\\']\\n\\ti = 0\\n\\tans = []\\n\\n\\twhile num > 0:\\n\\t\\tn = num % 10\\n\\t\\tif 1 <= n <= 3:\\n\\t\\t\\tans.append(ones[i] * n) \\n\\t\\telif n == 4:\\n\\t\\t\\tans.append(ones[i] + fives[i])\\n\\t\\telif 5 <= n <= 8:\\n\\t\\t\\tans.append(fives[i] + ones[i] * (n - 5))\\n\\t\\telif n == 9:\\n\\t\\t\\tans.append(ones[i] + ones[i+1])\\n\\n\\t\\ti += 1\\n\\t\\tnum //= 10\\n\\n\\treturn \"\".join(ans[::-1])",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "I think my solution is good in terms of scalability -- No need to create big table :)\\n\\n``` python\\ndef intToRoman(self, num: int) -> str:\\n\\tones = [\\'I\\', \\'X\\', \\'C\\', \\'M\\']\\n\\tfives = [\\'V\\', \\'L\\', \\'D\\']\\n\\ti = 0\\n\\tans = []\\n\\n\\twhile num > 0:\\n\\t\\tn = num % 10\\n\\t\\tif 1 <= n <= 3:\\n\\t\\t\\tans.append(ones[i] * n) \\n\\t\\telif n == 4:\\n\\t\\t\\tans.append(ones[i] + fives[i])\\n\\t\\telif 5 <= n <= 8:\\n\\t\\t\\tans.append(fives[i] + ones[i] * (n - 5))\\n\\t\\telif n == 9:\\n\\t\\t\\tans.append(ones[i] + ones[i+1])\\n\\n\\t\\ti += 1\\n\\t\\tnum //= 10\\n\\n\\treturn \"\".join(ans[::-1])",
                "codeTag": "Python3"
            },
            {
                "id": 1102673,
                "title": "python-short-solution-explained",
                "content": "Let us look at Roman representation digit by digit and see how it works.\\nFor last digit we can have \\n`\" \", I, II, III, IV, V, VI, VII, VIII, IX`\\nFor next digit we can have \\n`\" \", X, XX, XXX, XL, L, LX, LXX, LXXX, XC`\\nand so on.\\n\\nNotice, that we have exactly the same pattern here, but instead of `I, V, X`, we have `X, L, C` symbols. Let us use this idea and function `digit` to construct our number. We find last digit of integer representation of our number, create corresponding roman part and add it to the beginning of our answer.\\n\\n**Complexity**: time complexity is just `O(1)`, because length is restricted by `15`. Space complexity is `O(1)` as well.\\n\\n```\\nclass Solution:\\n    def intToRoman(self, num):\\n        def digit(a,b,c,dig):\\n            return [\"\",a,2*a,3*a,a+b,b,b+a,b+2*a,b+3*a,a+c][dig]\\n        \\n        l = [\"I\",\"V\",\"X\",\"L\",\"C\",\"D\",\"M\",\"!\",\"!\"]\\n        out, i = \"\", 0\\n\\n        while num != 0:\\n            num, last = divmod(num, 10)\\n            out = digit(l[i], l[i+1], l[i+2], last) + out\\n            i += 2\\n        return out\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num):\\n        def digit(a,b,c,dig):\\n            return [\"\",a,2*a,3*a,a+b,b,b+a,b+2*a,b+3*a,a+c][dig]\\n        \\n        l = [\"I\",\"V\",\"X\",\"L\",\"C\",\"D\",\"M\",\"!\",\"!\"]\\n        out, i = \"\", 0\\n\\n        while num != 0:\\n            num, last = divmod(num, 10)\\n            out = digit(l[i], l[i+1], l[i+2], last) + out\\n            i += 2\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 341297,
                "title": "easiest-and-fastest-0-ms-c-solution-a-little-bit-more-memory-for-simplicity",
                "content": "```\\nclass Solution {\\nprivate:\\n    const vector<pair<int, char*>> conv = {{1000, \"M\"},\\n                                            {900, \"CM\"},\\n                                            {500, \"D\"},\\n                                            {400, \"CD\"},\\n                                            {100, \"C\"},\\n                                            {90, \"XC\"},\\n                                            {50, \"L\"},\\n                                            {40, \"XL\"},\\n                                            {10, \"X\"},\\n                                            {9, \"IX\"},\\n                                            {5, \"V\"},\\n                                            {4, \"IV\"},\\n                                            {1, \"I\"}};\\npublic:\\n    string intToRoman(int num) {\\n        string res;\\n        auto it = conv.begin();\\n        while (num > 0 && it != conv.end()) {\\n            if (num >= it->first) {\\n                num -= it->first;\\n                res += it->second;\\n            } else {\\n                ++it;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    const vector<pair<int, char*>> conv = {{1000, \"M\"},\\n                                            {900, \"CM\"},\\n                                            {500, \"D\"},\\n                                            {400, \"CD\"},\\n                                            {100, \"C\"},\\n                                            {90, \"XC\"},\\n                                            {50, \"L\"},\\n                                            {40, \"XL\"},\\n                                            {10, \"X\"},\\n                                            {9, \"IX\"},\\n                                            {5, \"V\"},\\n                                            {4, \"IV\"},\\n                                            {1, \"I\"}};\\npublic:\\n    string intToRoman(int num) {\\n        string res;\\n        auto it = conv.begin();\\n        while (num > 0 && it != conv.end()) {\\n            if (num >= it->first) {\\n                num -= it->first;\\n                res += it->second;\\n            } else {\\n                ++it;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2057323,
                "title": "0ms-1liner-100-fastest-solution-explained-o-n-time-complexity-o-n-space-complexity",
                "content": "**As a professional with a passion for problem-solving and collaboration, I am always looking to expand my network of like-minded individuals on LinkedIn. By connecting with me, we can work together to tackle complex challenges, share ideas, and grow both professionally and personally.**\\n\\n**Whether you\\'re an expert in your field or just starting out, I welcome connections from all backgrounds and experiences. By building a diverse and collaborative network, we can leverage our unique perspectives and skill sets to push the boundaries of what\\'s possible.**\\n\\n**So, if you\\'re interested in connecting and exploring the potential for future collaborations, please don\\'t hesitate to reach out. Let\\'s start a conversation and see where it takes us!**\\n\\n---\\n\\nhttps://www.linkedin.com/in/cucerdariancatalin/\\nhttps://www.linkedin.com/in/cucerdariancatalin/\\nhttps://www.linkedin.com/in/cucerdariancatalin/\\n\\n---\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* *** Java ***\\n\\n```\\n\\nclass Solution {\\n    final static int[] val = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n    final static String[] rom = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n\\n    public String intToRoman(int N) {\\n        StringBuilder ans = new StringBuilder();\\n        for (int i = 0; N > 0; i++)\\n            while (N >= val[i]) {\\n                ans.append(rom[i]);\\n                N -= val[i];\\n            }\\n        return ans.toString();\\n    }\\n}\\n\\n```\\n\\n```\\n```\\n\\n```\\n```\\n***\"We are Anonymous. We are legion. We do not forgive. We do not forget. Expect us. Open your eyes..\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin",
                    "PHP"
                ],
                "code": "```\\n```\n```\\n\\nclass Solution {\\n    final static int[] val = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n    final static String[] rom = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n\\n    public String intToRoman(int N) {\\n        StringBuilder ans = new StringBuilder();\\n        for (int i = 0; N > 0; i++)\\n            while (N >= val[i]) {\\n                ans.append(rom[i]);\\n                N -= val[i];\\n            }\\n        return ans.toString();\\n    }\\n}\\n\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2725325,
                "title": "short-c-explained-solution-beginner-friendly-by-mr-coder",
                "content": "[Watch](https://www.youtube.com/watch?v=RckYHjMJLNI)\\nhttps://www.youtube.com/watch?v=RckYHjMJLNI\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<pair<int, string>> vm = {{1000, \"M\"},{900, \"CM\"} , {500, \"D\"},{400, \"CD\"} , {100, \"C\"} , {90, \"XC\"}, {50, \"L\"}, {40, \"XL\"},{10, \"X\"}, {9, \"IX\"},{5, \"V\"} , {4, \"IV\"},{1, \"I\"} };\\n        string s_ans = \"\";\\n        while(num > 0){\\n            for(auto x : vm){\\n                if(num >= x.first){\\n                    s_ans += x.second;\\n                    num = num - x.first;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return s_ans;\\n    }\\n};\\n```\\n**If you find my solution helpful please upvote it.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<pair<int, string>> vm = {{1000, \"M\"},{900, \"CM\"} , {500, \"D\"},{400, \"CD\"} , {100, \"C\"} , {90, \"XC\"}, {50, \"L\"}, {40, \"XL\"},{10, \"X\"}, {9, \"IX\"},{5, \"V\"} , {4, \"IV\"},{1, \"I\"} };\\n        string s_ans = \"\";\\n        while(num > 0){\\n            for(auto x : vm){\\n                if(num >= x.first){\\n                    s_ans += x.second;\\n                    num = num - x.first;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return s_ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 704000,
                "title": "javascript",
                "content": "```\\nvar intToRoman = function(num) {\\n    let res = \"\";\\n    if (num < 1 || num > 3999) return res;\\n    let weight = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\\n   let token = [\\'M\\', \\'CM\\', \\'D\\', \\'CD\\', \\'C\\', \\'XC\\', \\'L\\', \\'XL\\', \\'X\\', \\'IX\\', \\'V\\', \\'IV\\', \\'I\\'];\\n    let i = 0;\\n    while (num > 0){\\n        if (num - weight[i] >= 0){\\n            res += token[i];\\n            num -= weight[i];\\n        }\\n        else{\\n            i++;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar intToRoman = function(num) {\\n    let res = \"\";\\n    if (num < 1 || num > 3999) return res;\\n    let weight = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\\n   let token = [\\'M\\', \\'CM\\', \\'D\\', \\'CD\\', \\'C\\', \\'XC\\', \\'L\\', \\'XL\\', \\'X\\', \\'IX\\', \\'V\\', \\'IV\\', \\'I\\'];\\n    let i = 0;\\n    while (num > 0){\\n        if (num - weight[i] >= 0){\\n            res += token[i];\\n            num -= weight[i];\\n        }\\n        else{\\n            i++;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 6473,
                "title": "esay-c-solution-43ms",
                "content": "    class Solution {\\n    public:\\n    \\tconst static string THOUS[];\\n    \\tconst static string HUNDS[];\\n    \\tconst static string TENS[];\\n    \\tconst static string ONES[];\\n        string intToRoman(int num) {\\n    \\t\\tstring result;\\n    \\t\\tresult += THOUS[(int)(num/1000)%10];\\n    \\t\\tresult += HUNDS[(int)(num/100)%10];\\n    \\t\\tresult += TENS[(int)(num/10)%10];\\n    \\t\\tresult += ONES[num%10];\\n    \\t\\treturn result;\\n        }\\n    };\\n    \\n    const string Solution::THOUS[]\\t= {\"\",\"M\",\"MM\",\"MMM\"};\\n    const string Solution::HUNDS[]\\t= {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n    const string Solution::TENS[]\\t= {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n    const string Solution::ONES[]\\t= {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tconst static string THOUS[];\\n    \\tconst static string HUNDS[];\\n    \\tconst static string TENS[];\\n    \\tconst static string ONES[];\\n        string intToRoman(int num) {\\n    \\t\\tstring result;\\n    \\t\\tresult += THOUS[(int)(num/1000)%10];\\n    \\t\\tresult += HUNDS[(int)(num/100)%10];\\n    \\t\\tresult += TENS[(int)(num/10)%10];\\n    \\t\\tresult += ONES[num%10];\\n    \\t\\treturn result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2724006,
                "title": "c-integer-to-roman-just-8-lines-of-code",
                "content": "```\\nstring intToRoman(int num) {\\n    string str[13] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n    int val[13] = {1000, 900, 500, 400, 100,  90,  50,  40, 10,   9,   5,   4,  1};\\n    string ans;\\n    for (int i=0; i<13; i++) {\\n        for (int j=0; j<(num/val[i]); j++) {\\n            ans += str[i];\\n        }\\n        num %= val[i];\\n    }\\n    return ans;\\n}\\n```\\nHelpful?",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring intToRoman(int num) {\\n    string str[13] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n    int val[13] = {1000, 900, 500, 400, 100,  90,  50,  40, 10,   9,   5,   4,  1};\\n    string ans;\\n    for (int i=0; i<13; i++) {\\n        for (int j=0; j<(num/val[i]); j++) {\\n            ans += str[i];\\n        }\\n        num %= val[i];\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2521374,
                "title": "no-loop-no-conditions-used",
                "content": "String[] Thousands={\"\",\"M\",\"MM\",\"MMM\"};\\n        String[] Hundreds={\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        String[] Tens={\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        String[] Units={\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        return Thousands[num/1000]+Hundreds[(num%1000)/100]+Tens[(num%100)/10]+Units[(num%10)];",
                "solutionTags": [],
                "code": "String[] Thousands={\"\",\"M\",\"MM\",\"MMM\"};\\n        String[] Hundreds={\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        String[] Tens={\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        String[] Units={\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        return Thousands[num/1000]+Hundreds[(num%1000)/100]+Tens[(num%100)/10]+Units[(num%10)];",
                "codeTag": "Unknown"
            },
            {
                "id": 255369,
                "title": "c-100",
                "content": "```\\npublic class Solution {\\n    public string IntToRoman(int num) {\\n        if (num >= 1000) return \"M\" + IntToRoman(num - 1000);\\n\\n        if (num >= 500) return num >= 900 ? (\"CM\" + IntToRoman(num - 900)) : (\"D\" + IntToRoman(num - 500));\\n\\n        if (num >= 100) return num >= 400 ? (\"CD\" + IntToRoman(num - 400)) : (\"C\" + IntToRoman(num - 100));\\n\\n        if (num >= 50) return num >= 90 ? (\"XC\" + IntToRoman(num - 90)) : (\"L\" + IntToRoman(num - 50));\\n\\n        if (num >= 10) return num >= 40 ? (\"XL\" + IntToRoman(num - 40)): (\"X\" + IntToRoman(num - 10));\\n\\n        if (num >= 5) return num == 9 ? \"IX\" : \"V\" + IntToRoman(num - 5);\\n\\n        if (num > 0) return num == 4 ? \"IV\" : \"I\" + IntToRoman(num - 1);\\n\\n        return \"\";\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string IntToRoman(int num) {\\n        if (num >= 1000) return \"M\" + IntToRoman(num - 1000);\\n\\n        if (num >= 500) return num >= 900 ? (\"CM\" + IntToRoman(num - 900)) : (\"D\" + IntToRoman(num - 500));\\n\\n        if (num >= 100) return num >= 400 ? (\"CD\" + IntToRoman(num - 400)) : (\"C\" + IntToRoman(num - 100));\\n\\n        if (num >= 50) return num >= 90 ? (\"XC\" + IntToRoman(num - 90)) : (\"L\" + IntToRoman(num - 50));\\n\\n        if (num >= 10) return num >= 40 ? (\"XL\" + IntToRoman(num - 40)): (\"X\" + IntToRoman(num - 10));\\n\\n        if (num >= 5) return num == 9 ? \"IX\" : \"V\" + IntToRoman(num - 5);\\n\\n        if (num > 0) return num == 4 ? \"IV\" : \"I\" + IntToRoman(num - 1);\\n\\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425736,
                "title": "best-and-easy-beginners-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n                Easiest Approaah using arrays \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n                  store the info and use it\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n                  O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n                  O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        String[] s={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        int[] values={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        String t=\"\";\\n       int i=0;\\n       while(num>0){\\n           if(num>=values[i]){\\n               t+=s[i];\\n               num-=values[i];\\n           }\\n            else\\n           i++;\\n       }\\n        return t;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        String[] s={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        int[] values={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        String t=\"\";\\n       int i=0;\\n       while(num>0){\\n           if(num>=values[i]){\\n               t+=s[i];\\n               num-=values[i];\\n           }\\n            else\\n           i++;\\n       }\\n        return t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1536553,
                "title": "java-easy-solution-using-a-linkedhashmap",
                "content": "I noticed most of the solutions to this problem are using multiple arrays, instead I used a single LinkedHashMap to solve it.\\n\\n**Q. Why use LinkedHashMap instead of HashMap?\\nA. LinkedHashMap is ordered, HashMap is unordered.**\\n\\nsource: https://docs.oracle.com/javase/6/docs/api/java/util/LinkedHashMap.html\\n\\n```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        LinkedHashMap<Integer, String> map = new LinkedHashMap<>();\\n        map.put(1000, \"M\");\\n        map.put(900, \"CM\");\\n        map.put(500, \"D\");\\n        map.put(400, \"CD\");\\n        map.put(100, \"C\");\\n        map.put(90, \"XC\");\\n        map.put(50, \"L\");\\n        map.put(40, \"XL\");\\n        map.put(10, \"X\");\\n        map.put(9, \"IX\");\\n        map.put(5, \"V\");\\n        map.put(4, \"IV\");\\n        map.put(1, \"I\");\\n        StringBuilder sb = new StringBuilder();\\n        for (Map.Entry<Integer, String> entry : map.entrySet()) {\\n            while (num >= entry.getKey()) {\\n                num -= entry.getKey();\\n                sb.append(entry.getValue());\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        LinkedHashMap<Integer, String> map = new LinkedHashMap<>();\\n        map.put(1000, \"M\");\\n        map.put(900, \"CM\");\\n        map.put(500, \"D\");\\n        map.put(400, \"CD\");\\n        map.put(100, \"C\");\\n        map.put(90, \"XC\");\\n        map.put(50, \"L\");\\n        map.put(40, \"XL\");\\n        map.put(10, \"X\");\\n        map.put(9, \"IX\");\\n        map.put(5, \"V\");\\n        map.put(4, \"IV\");\\n        map.put(1, \"I\");\\n        StringBuilder sb = new StringBuilder();\\n        for (Map.Entry<Integer, String> entry : map.entrySet()) {\\n            while (num >= entry.getKey()) {\\n                num -= entry.getKey();\\n                sb.append(entry.getValue());\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2723880,
                "title": "fastest-python-solution-using-mapping",
                "content": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        i=1\\n        dic={1:\\'I\\',5:\\'V\\',10:\\'X\\',50:\\'L\\',100:\\'C\\',500:\\'D\\',1000:\\'M\\'}\\n        s=\"\"\\n        while num!=0:\\n            y=num%pow(10,i)//pow(10,i-1)\\n            if y==5:\\n                s=dic[y*pow(10,i-1)]+s\\n            elif y==1:\\n                s=dic[y*pow(10,i-1)]+s\\n            elif y==4:\\n                s=dic[1*pow(10,i-1)]+dic[5*pow(10,i-1)]+s\\n            elif y==9:\\n                s=dic[1*pow(10,i-1)]+dic[1*pow(10,i)]+s\\n            elif y<4:\\n                s=dic[pow(10,i-1)]*y+s\\n            elif y>5 and y<9:\\n                y-=5\\n                s=dic[5*pow(10,i-1)]+dic[pow(10,i-1)]*y+s\\n            num=num//pow(10,i)\\n            num*=pow(10,i)\\n            i+=1\\n        return s\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        i=1\\n        dic={1:\\'I\\',5:\\'V\\',10:\\'X\\',50:\\'L\\',100:\\'C\\',500:\\'D\\',1000:\\'M\\'}\\n        s=\"\"\\n        while num!=0:\\n            y=num%pow(10,i)//pow(10,i-1)\\n            if y==5:\\n                s=dic[y*pow(10,i-1)]+s\\n            elif y==1:\\n                s=dic[y*pow(10,i-1)]+s\\n            elif y==4:\\n                s=dic[1*pow(10,i-1)]+dic[5*pow(10,i-1)]+s\\n            elif y==9:\\n                s=dic[1*pow(10,i-1)]+dic[1*pow(10,i)]+s\\n            elif y<4:\\n                s=dic[pow(10,i-1)]*y+s\\n            elif y>5 and y<9:\\n                y-=5\\n                s=dic[5*pow(10,i-1)]+dic[pow(10,i-1)]*y+s\\n            num=num//pow(10,i)\\n            num*=pow(10,i)\\n            i+=1\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 971772,
                "title": "c-0ms-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string romans[] = {\"I\",\"IV\",\"V\",\"IX\",\"X\",\"XL\",\"L\",\"XC\",\"C\",\"CD\",\"D\",\"CM\",\"M\"};\\n        int numerals[]={1,4,5,9,10,40,50,90,100,400,500,900,1000};\\n        string res;\\n        while(num)\\n        {\\n            for(int i=12;i>=0;i--)\\n            {\\n                int x = num/numerals[i];\\n                if(x)\\n                {\\n                    while(x--)\\n                    {\\n                        res += romans[i];\\n                    }\\n                    num %= numerals[i];\\n                    break;\\n                }\\n            }\\n        }   \\n        return res;\\n    }\\n};\\n```\\n\\n\\n**Runtime: 0 ms, faster than 100.00% of C++ online submissions for Integer to Roman.\\nMemory Usage: 6 MB, less than 99.00% of C++ online submissions for Integer to Roman.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string romans[] = {\"I\",\"IV\",\"V\",\"IX\",\"X\",\"XL\",\"L\",\"XC\",\"C\",\"CD\",\"D\",\"CM\",\"M\"};\\n        int numerals[]={1,4,5,9,10,40,50,90,100,400,500,900,1000};\\n        string res;\\n        while(num)\\n        {\\n            for(int i=12;i>=0;i--)\\n            {\\n                int x = num/numerals[i];\\n                if(x)\\n                {\\n                    while(x--)\\n                    {\\n                        res += romans[i];\\n                    }\\n                    num %= numerals[i];\\n                    break;\\n                }\\n            }\\n        }   \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202670,
                "title": "best-c-2-solution-hash-table-math-string-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem using String + Hash Table + Math.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the all the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(1), We are scanning Array(val) of the number one by one therefore, the maximum time can\\n    be used to iterate over Array(val) is O(1) which is constant because we can maximum do around 18 iteration\\n    which is constant.\\n\\n    Space Complexity : O(1), We are using integer arrays and one string array whose sizes don\\u2019t depend on the\\n    input size hence the space complexity will be O(1).\\n\\n    Solved using String + Hash Table + Math.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string res;\\n        string sym[] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        int val[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n\\n        for(int i=0; num != 0; i++){\\n            while(num >= val[i]){\\n                num -= val[i];\\n                res += sym[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(1), We are scanning each digit of the number one by one therefore, the time complexity\\n    will be O(log10N). But N cannot be grater than 3999, therefore, the maximum time can be O(loh103999) ~= \\n    O(3.60) which is constant hence the overall time complexity will be O(1).\\n\\n    Space Complexity : O(1), We are using four arrays whose sizes don\\u2019t depend on the input size hence the space\\n    complexity will be O(1).\\n\\n    Solved using String + Hash Table + Math.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<string> ones = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\\n        vector<string> tens = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\\n        vector<string> hundred = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n        vector<string> thousand = {\"\", \"M\", \"MM\", \"MMM\"};\\n        \\n        string ans = \"\";\\n        \\n        ans += thousand[num/1000] + hundred[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math",
                    "String"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(1), We are scanning Array(val) of the number one by one therefore, the maximum time can\\n    be used to iterate over Array(val) is O(1) which is constant because we can maximum do around 18 iteration\\n    which is constant.\\n\\n    Space Complexity : O(1), We are using integer arrays and one string array whose sizes don\\u2019t depend on the\\n    input size hence the space complexity will be O(1).\\n\\n    Solved using String + Hash Table + Math.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string res;\\n        string sym[] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        int val[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n\\n        for(int i=0; num != 0; i++){\\n            while(num >= val[i]){\\n                num -= val[i];\\n                res += sym[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(1), We are scanning each digit of the number one by one therefore, the time complexity\\n    will be O(log10N). But N cannot be grater than 3999, therefore, the maximum time can be O(loh103999) ~= \\n    O(3.60) which is constant hence the overall time complexity will be O(1).\\n\\n    Space Complexity : O(1), We are using four arrays whose sizes don\\u2019t depend on the input size hence the space\\n    complexity will be O(1).\\n\\n    Solved using String + Hash Table + Math.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<string> ones = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\\n        vector<string> tens = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\\n        vector<string> hundred = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n        vector<string> thousand = {\"\", \"M\", \"MM\", \"MMM\"};\\n        \\n        string ans = \"\";\\n        \\n        ans += thousand[num/1000] + hundred[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724009,
                "title": "java-easy-solution-100-faster-code",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    private static final StringBuilder sb = new StringBuilder(15);\\n    \\n    private static final String[] thou = {\"\", \"M\", \"MM\", \"MMM\"};\\n    private static final String[] hund = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\",\"DCCC\",\"CM\"};\\n    private static final String[] tens = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n    private static final String[] ones = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\",\"VII\",\"VIII\",\"IX\"};\\n    \\n    public String intToRoman(int num) {\\n        sb.setLength(0);\\n        \\n        sb.append(thou[num/1000]);\\n        sb.append(hund[(num%1000)/100]);\\n        sb.append(tens[(num%100)/10]);\\n        sb.append(ones[num%10]);\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private static final StringBuilder sb = new StringBuilder(15);\\n    \\n    private static final String[] thou = {\"\", \"M\", \"MM\", \"MMM\"};\\n    private static final String[] hund = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\",\"DCCC\",\"CM\"};\\n    private static final String[] tens = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n    private static final String[] ones = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\",\"VII\",\"VIII\",\"IX\"};\\n    \\n    public String intToRoman(int num) {\\n        sb.setLength(0);\\n        \\n        sb.append(thou[num/1000]);\\n        sb.append(hund[(num%1000)/100]);\\n        sb.append(tens[(num%100)/10]);\\n        sb.append(ones[num%10]);\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 245498,
                "title": "c-greedy",
                "content": "Decrement large to small ```val``` from value vector by the largest possible amount each time  from ```num```\\n\\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string res = \"\";\\n        vector<int> val{1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        vector<string> str{\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        for (int i = 0; i < val.size(); ++i) {\\n            while (num >= val[i]) {\\n                num -= val[i];\\n                res += str[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```val```\n```num```\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string res = \"\";\\n        vector<int> val{1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        vector<string> str{\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        for (int i = 0; i < val.size(); ++i) {\\n            while (num >= val[i]) {\\n                num -= val[i];\\n                res += str[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 444278,
                "title": "java-runtime-3s-and-greater-than-100-100",
                "content": "```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        StringBuilder result = new StringBuilder();\\n        int[] div = {1000, 900, 500, 400, 100, 90, \\n                     50, 40, 10, 9, 5, 4, 1};\\n        String[] roman = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \\n                          \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        for (int i = 0; i < div.length;) {\\n            if (num >= div[i]) {\\n                result.append(roman[i]);\\n                num -= div[i];\\n            } else {\\n                i++;\\n            }\\n        }\\n        \\n        return result.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        StringBuilder result = new StringBuilder();\\n        int[] div = {1000, 900, 500, 400, 100, 90, \\n                     50, 40, 10, 9, 5, 4, 1};\\n        String[] roman = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \\n                          \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        for (int i = 0; i < div.length;) {\\n            if (num >= div[i]) {\\n                result.append(roman[i]);\\n                num -= div[i];\\n            } else {\\n                i++;\\n            }\\n        }\\n        \\n        return result.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 6469,
                "title": "share-my-iterative-solution",
                "content": "    public String intToRoman(int num) {\\n        int[] weights={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        String[] tokens={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        StringBuilder rs=new StringBuilder(\"\");\\n        int start=0;\\n        while(num>0){\\n            for(int i=start;i<13;i++){\\n                if(num>=weights[i]){\\n                    num-=weights[i];\\n                    rs.append(tokens[i]);\\n                    break;\\n                }\\n                start=i+1; // skip those impossible check, make it faster\\n            }\\n        }\\n        return rs.toString();\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public String intToRoman(int num) {\\n        int[] weights={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        String[] tokens={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        StringBuilder rs=new StringBuilder(\"\");\\n        int start=0;\\n        while(num>0){\\n            for(int i=start;i<13;i++){\\n                if(num>=weights[i]){\\n                    num-=weights[i];\\n                    rs.append(tokens[i]);\\n                    break;\\n                }\\n                start=i+1; // skip those impossible check, make it faster\\n            }\\n        }\\n        return rs.toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1102756,
                "title": "python-stack-solution",
                "content": "My code:\\n\\n```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        dct = {1: \\'I\\', 4: \\'IV\\', 5: \\'V\\', 9: \\'IX\\', 10: \\'X\\', 40: \\'XL\\', 50: \\'L\\', 90: \\'XC\\', 100: \\'C\\', 400: \\'CD\\', 500: \\'D\\', 900: \\'CM\\', 1000: \\'M\\'}\\n        stack = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\\n        ans = []\\n        while num > 0:\\n            if stack[-1] > num:\\n                stack.pop()\\n            else:\\n                num -= stack[-1]\\n                ans.append(dct[stack[-1]])\\n        return \"\".join(map(str, ans))\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        dct = {1: \\'I\\', 4: \\'IV\\', 5: \\'V\\', 9: \\'IX\\', 10: \\'X\\', 40: \\'XL\\', 50: \\'L\\', 90: \\'XC\\', 100: \\'C\\', 400: \\'CD\\', 500: \\'D\\', 900: \\'CM\\', 1000: \\'M\\'}\\n        stack = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\\n        ans = []\\n        while num > 0:\\n            if stack[-1] > num:\\n                stack.pop()\\n            else:\\n                num -= stack[-1]\\n                ans.append(dct[stack[-1]])\\n        return \"\".join(map(str, ans))\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 6405,
                "title": "my-solutions-in-java",
                "content": "\\n    public String intToRoman(int num) {\\n        String data[] = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        int value[] = {1000,900,500,400,100,90,50,40,10,9,5,4,1}, base = -1;\\n        StringBuilder result = new StringBuilder();\\n\\n        for(int i = 0;i < data.length;i++){\\n            if((base=num/value[i])!=0){\\n                while(base--!=0)result.append(data[i]);\\n                num=num%value[i];\\n            }\\n        }\\n        return result.toString();\\n    }",
                "solutionTags": [],
                "code": "\\n    public String intToRoman(int num) {\\n        String data[] = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        int value[] = {1000,900,500,400,100,90,50,40,10,9,5,4,1}, base = -1;\\n        StringBuilder result = new StringBuilder();\\n\\n        for(int i = 0;i < data.length;i++){\\n            if((base=num/value[i])!=0){\\n                while(base--!=0)result.append(data[i]);\\n                num=num%value[i];\\n            }\\n        }\\n        return result.toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1102727,
                "title": "python-java-clean-concise",
                "content": "**Python**\\n```python\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        digits = [(1000, \"M\"), (900, \"CM\"), (500, \"D\"), (400, \"CD\"), (100, \"C\"), (90, \"XC\"), (50, \"L\"), (40, \"XL\"),\\n               (10, \"X\"), (9, \"IX\"), (5, \"V\"), (4, \"IV\"), (1, \"I\")]\\n\\n        ans = \"\"\\n        for n, s in digits:  # Maximum 13 operations\\n            while num >= n:  # Each while loop, maximum 3 operations, imagine case num=3\\n                ans += s\\n                num -= n\\n        return ans\\n```\\n\\n**Java**\\n```java\\nclass Solution {\\n    public String intToRoman(int num) {\\n        int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        String[] symbols = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < values.length; i++) {\\n            while (num >= values[i]) {\\n                num -= values[i];\\n                sb.append(symbols[i]);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n**Complexity:**\\n- Time & Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        digits = [(1000, \"M\"), (900, \"CM\"), (500, \"D\"), (400, \"CD\"), (100, \"C\"), (90, \"XC\"), (50, \"L\"), (40, \"XL\"),\\n               (10, \"X\"), (9, \"IX\"), (5, \"V\"), (4, \"IV\"), (1, \"I\")]\\n\\n        ans = \"\"\\n        for n, s in digits:  # Maximum 13 operations\\n            while num >= n:  # Each while loop, maximum 3 operations, imagine case num=3\\n                ans += s\\n                num -= n\\n        return ans\\n```\n```java\\nclass Solution {\\n    public String intToRoman(int num) {\\n        int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        String[] symbols = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < values.length; i++) {\\n            while (num >= values[i]) {\\n                num -= values[i];\\n                sb.append(symbols[i]);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 689156,
                "title": "python3-smart-work-soln-4-line",
                "content": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        M=[\"\",\"M\",\"MM\",\"MMM\"]\\n        C=[\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"]\\n        X=[\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"]\\n        I=[\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"]\\n        \\n        return M[num//1000]+C[(num//100)%10]+X[(num//10)%10]+I[num%10]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        M=[\"\",\"M\",\"MM\",\"MMM\"]\\n        C=[\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"]\\n        X=[\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"]\\n        I=[\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"]\\n        \\n        return M[num//1000]+C[(num//100)%10]+X[(num//10)%10]+I[num%10]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 492037,
                "title": "java-easiest-solution-must-read",
                "content": "```\\npublic String intToRoman(int num) {\\n\\n\\tString[] thousands = {\"\",\"M\",\"MM\",\"MMM\"};\\n\\tString[] hundreds = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n\\tString[] tens = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n\\tString[] ones = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n\\n\\tStringBuilder sol = new StringBuilder();\\n\\tsol.append(thousands[num/1000])\\n\\t\\t.append(hundreds[(num%1000)/100])\\n\\t\\t.append(tens[(num%100)/10])\\n\\t\\t.append(ones[num%10]);\\n\\t\\t\\n\\treturn  sol.toString();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic String intToRoman(int num) {\\n\\n\\tString[] thousands = {\"\",\"M\",\"MM\",\"MMM\"};\\n\\tString[] hundreds = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n\\tString[] tens = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n\\tString[] ones = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n\\n\\tStringBuilder sol = new StringBuilder();\\n\\tsol.append(thousands[num/1000])\\n\\t\\t.append(hundreds[(num%1000)/100])\\n\\t\\t.append(tens[(num%100)/10])\\n\\t\\t.append(ones[num%10]);\\n\\t\\t\\n\\treturn  sol.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2289110,
                "title": "very-easy-100-c-java-javascript-fully-explained-line-by-line",
                "content": "# **C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        //first we create a table of roman word and their values..\\n        vector<string> romanWord = {\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"};\\n        vector<int> value = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000};\\n        //initialize and set the index i...\\n        int i = romanWord.size() - 1;\\n        //create the solution which will be in string format...\\n        string sol = \"\";\\n        //a loop will be made to begin the procedure...\\n        while(num>0){\\n            //this loop is working untill the the vslue of integer is less or equal to num...\\n            while(value[i]<=num){\\n                //Append the roman numeral into an solution string...\\n                sol += romanWord[i];\\n                //subtract the integral value from the given integer...\\n                //Subtract the current number until the given integer is greater than the current number.\\n                num -= value[i];\\n            }\\n            i--;\\n        }\\n        //Once we are done with all the roman numerals, we return the solution.\\n        return sol;\\n    }\\n};\\n```\\n\\n# **Java Solution:**\\n```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        //first we create a table of roman word and their values..\\n        String romanWord[] = {\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"};\\n        int value[] = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000};\\n        //initialize and set the index i...\\n        int i = romanWord.length - 1;\\n        //create the solution which will be in string format...\\n        String sol = \"\";\\n        //a loop will be made to begin the procedure...\\n        while(num>0){\\n            //this loop is working untill the the vslue of integer is less or equal to num...\\n            while(value[i]<=num){\\n                //Append the roman numeral into an solution string...\\n                sol += romanWord[i];\\n                //subtract the integral value from the given integer...\\n                //Subtract the current number until the given integer is greater than the current number.\\n                num -= value[i];\\n            }\\n            i--;\\n        }\\n        //Once we are done with all the roman numerals, we return the solution.\\n        return sol;\\n    }\\n}\\n```\\n\\n# **Javascript Solution:**\\n```\\n//Another approach is here..\\nvar intToRoman = function(num) {\\n    //create the list..\\n    const M = [\"\", \"M\", \"MM\", \"MMM\"];\\n    const C = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"];\\n    const X = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"];\\n    const I = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"];\\n    //return solution with this procedure...\\n    return M[Math.floor(num / 1000)] + C[Math.floor((num % 1000) / 100)] + X[Math.floor((num % 100) / 10)] + I[num % 10];\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        //first we create a table of roman word and their values..\\n        vector<string> romanWord = {\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"};\\n        vector<int> value = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000};\\n        //initialize and set the index i...\\n        int i = romanWord.size() - 1;\\n        //create the solution which will be in string format...\\n        string sol = \"\";\\n        //a loop will be made to begin the procedure...\\n        while(num>0){\\n            //this loop is working untill the the vslue of integer is less or equal to num...\\n            while(value[i]<=num){\\n                //Append the roman numeral into an solution string...\\n                sol += romanWord[i];\\n                //subtract the integral value from the given integer...\\n                //Subtract the current number until the given integer is greater than the current number.\\n                num -= value[i];\\n            }\\n            i--;\\n        }\\n        //Once we are done with all the roman numerals, we return the solution.\\n        return sol;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        //first we create a table of roman word and their values..\\n        String romanWord[] = {\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"};\\n        int value[] = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000};\\n        //initialize and set the index i...\\n        int i = romanWord.length - 1;\\n        //create the solution which will be in string format...\\n        String sol = \"\";\\n        //a loop will be made to begin the procedure...\\n        while(num>0){\\n            //this loop is working untill the the vslue of integer is less or equal to num...\\n            while(value[i]<=num){\\n                //Append the roman numeral into an solution string...\\n                sol += romanWord[i];\\n                //subtract the integral value from the given integer...\\n                //Subtract the current number until the given integer is greater than the current number.\\n                num -= value[i];\\n            }\\n            i--;\\n        }\\n        //Once we are done with all the roman numerals, we return the solution.\\n        return sol;\\n    }\\n}\\n```\n```\\n//Another approach is here..\\nvar intToRoman = function(num) {\\n    //create the list..\\n    const M = [\"\", \"M\", \"MM\", \"MMM\"];\\n    const C = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"];\\n    const X = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"];\\n    const I = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"];\\n    //return solution with this procedure...\\n    return M[Math.floor(num / 1000)] + C[Math.floor((num % 1000) / 100)] + X[Math.floor((num % 100) / 10)] + I[num % 10];\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 928027,
                "title": "don-t-spend-too-much-time-on-this-problem-if-you-don-t-understand-the-logic-behind-roman-numerals",
                "content": "class Solution {\\n    public String intToRoman(int num) {\\n        \\n        // 42\\n        int[] values = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        String[] romanNumerals ={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        for (int i = 0; i < values.length; i++) {\\n            \\n            while(num >= values[i]) {\\n                \\n                num -= values[i];\\n                sb.append(romanNumerals[i]);\\n            }\\n        }\\n        \\n        return sb.toString();\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String intToRoman(int num) {\\n        \\n        // 42\\n        int[] values = {1000,900,500,400,100,90,50,40,10,9,5,4,1}",
                "codeTag": "Java"
            },
            {
                "id": 323502,
                "title": "a-simple-javascript-solution",
                "content": "```js\\n// build a roman set\\n// build a number set correspond roman set\\n// traverse set ,Decrease num\\nvar intToRoman = function(num) {\\n    var list = [\\'M\\', \\'CM\\', \\'D\\', \\'CD\\',\\'C\\',\\'XC\\',\\'L\\', \\'XL\\',\\'X\\',\\'IX\\',\\'V\\',\\'IV\\',\\'I\\']\\n    var valueList = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\\n    var result = \\'\\'\\n    while(num !== 0) {\\n        for(var i = 0 ; i < valueList.length ; i++) {\\n            if(num >= valueList[i]){\\n                result += list[i]\\n                num -= valueList[i]\\n                break\\n            }\\n        }\\n    }\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n// build a roman set\\n// build a number set correspond roman set\\n// traverse set ,Decrease num\\nvar intToRoman = function(num) {\\n    var list = [\\'M\\', \\'CM\\', \\'D\\', \\'CD\\',\\'C\\',\\'XC\\',\\'L\\', \\'XL\\',\\'X\\',\\'IX\\',\\'V\\',\\'IV\\',\\'I\\']\\n    var valueList = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\\n    var result = \\'\\'\\n    while(num !== 0) {\\n        for(var i = 0 ; i < valueList.length ; i++) {\\n            if(num >= valueList[i]){\\n                result += list[i]\\n                num -= valueList[i]\\n                break\\n            }\\n        }\\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 6438,
                "title": "straight-forward-java-recursive-solution",
                "content": "    public class Solution {\\n        public String intToRoman(int num) {\\n            if (num>=1000) {\\n                return (\"M\"+intToRoman(num-1000));\\n            } else if (num>=900) {\\n                return (\"CM\"+intToRoman(num-900));\\n            } else if (num>=500) {\\n                return (\"D\"+intToRoman(num-500));\\n            } else if (num>=400) {\\n                return (\"CD\"+intToRoman(num-400));\\n            } else if (num>=100) {\\n                return (\"C\"+intToRoman(num-100));\\n            } else if (num>=90) {\\n                return (\"XC\"+intToRoman(num-90));\\n            } else if (num>=50) {\\n                return (\"L\"+intToRoman(num-50));\\n            } else if (num>=40) {\\n                return (\"XL\"+intToRoman(num-40));\\n            } else if (num>=10) {\\n                return (\"X\"+intToRoman(num-10));\\n            } else if (num>=9) {\\n                return (\"IX\"+intToRoman(num-9));\\n            } else if (num>=5) {\\n                return (\"V\"+intToRoman(num-5));\\n            } else if (num>=4) {\\n                return (\"IV\"+intToRoman(num-4));\\n            } else if (num>=1) {\\n                return (\"I\"+intToRoman(num-1));\\n            }\\n            return (\"\");\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public String intToRoman(int num) {\\n            if (num>=1000) {\\n                return (\"M\"+intToRoman(num-1000));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3968557,
                "title": "java-simple-solution-runtime-9ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.Enumeration;\\nimport java.util.Hashtable;\\n\\nclass Solution {\\n     public static String intToRoman(int num)\\n    {\\n        StringBuilder s = new StringBuilder();\\n\\n        Hashtable<Integer , String > list = new Hashtable<>();\\n        list.put(1 , \"I\");\\n        list.put(4 , \"IV\");\\n        list.put(5 , \"V\");\\n        list.put(9 , \"IX\");\\n        list.put(10 , \"X\");\\n        list.put(40 , \"XL\");\\n        list.put(50 , \"L\");\\n        list.put(90 , \"XC\");\\n        list.put(100 , \"C\");\\n        list.put(400 , \"CD\");\\n        list.put(500 , \"D\");\\n        list.put(900 , \"CM\");\\n        list.put(1000 , \"M\");\\n        \\n        while (num > 0)\\n        {\\n            int maxkey = getMaxKey(list , num);\\n            s.append(list.get(maxkey));\\n            num -= maxkey;\\n        }\\n        return s.toString();\\n    }\\n\\n    public static int getMaxKey(Hashtable list , int target)\\n    {\\n        int maxKey = -1;\\n\\n        Enumeration<Integer> keys = list.keys();\\n        while (keys.hasMoreElements()) {\\n            int key = keys.nextElement();\\n            if (key <= target && key > maxKey) {\\n                maxKey = key;\\n            }\\n        }\\n        return maxKey;\\n    }\\n}\\n```\\n\\n\\n![e78315ef-8a9d-492b-9908-e3917f23eb31_1674946036.087042.jpeg](https://assets.leetcode.com/users/images/8e0d7970-b648-4a25-9abb-98529499d16b_1693157592.6218796.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.Enumeration;\\nimport java.util.Hashtable;\\n\\nclass Solution {\\n     public static String intToRoman(int num)\\n    {\\n        StringBuilder s = new StringBuilder();\\n\\n        Hashtable<Integer , String > list = new Hashtable<>();\\n        list.put(1 , \"I\");\\n        list.put(4 , \"IV\");\\n        list.put(5 , \"V\");\\n        list.put(9 , \"IX\");\\n        list.put(10 , \"X\");\\n        list.put(40 , \"XL\");\\n        list.put(50 , \"L\");\\n        list.put(90 , \"XC\");\\n        list.put(100 , \"C\");\\n        list.put(400 , \"CD\");\\n        list.put(500 , \"D\");\\n        list.put(900 , \"CM\");\\n        list.put(1000 , \"M\");\\n        \\n        while (num > 0)\\n        {\\n            int maxkey = getMaxKey(list , num);\\n            s.append(list.get(maxkey));\\n            num -= maxkey;\\n        }\\n        return s.toString();\\n    }\\n\\n    public static int getMaxKey(Hashtable list , int target)\\n    {\\n        int maxKey = -1;\\n\\n        Enumeration<Integer> keys = list.keys();\\n        while (keys.hasMoreElements()) {\\n            int key = keys.nextElement();\\n            if (key <= target && key > maxKey) {\\n                maxKey = key;\\n            }\\n        }\\n        return maxKey;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311278,
                "title": "c-java-c-python3-simple-easy-to-understand-efficient-clean-code",
                "content": "# Frequently encountered in technical interviews\\n```\\nstd::vector<std::pair<std::string, int>> interview_frequency= {\\n    {\"Amazon\", 27},\\n    {\"Microsoft\", 5},\\n    {\"Bloomberg\", 5},\\n    {\"Apple\", 3},\\n    {\"Capital One\", 3},\\n    {\"Adobe\", 2},\\n    {\"Google\", 2},\\n    {\"tiktok\", 2}\\n};\\n```\\n\\n# Solution\\n\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        return convertRoman(num/1000, 4) + convertRoman((num%1000)/100, 3) + convertRoman((num%100)/10, 2) + convertRoman(num%10, 1);      \\n    }\\n\\nprivate:\\n    int values[7] { 1000, 500, 100, 50, 10, 5, 1 };\\n    string strs[7] { \"M\", \"D\", \"C\", \"L\", \"X\", \"V\", \"I\" };\\n    unordered_map<int, int> myDict {{4, 0}, {3, 2}, {2, 4}, {1, 6}};\\n\\n    string convertRoman(int digit, int value) {\\n        string res = \"\";\\n        int temp = myDict[value];\\n        if (temp == 0) \\n            res = repeat(strs[temp], digit);\\n        else {\\n            if (digit >= 1 && digit < 4) \\n                res += repeat(strs[temp], digit);\\n            else if (digit == 4) \\n                res += strs[temp] + strs[temp - 1];\\n            else if (digit >= 5 && digit < 9) \\n                res += strs[temp - 1] + repeat(strs[temp], (digit - 5));\\n            else if (digit == 9) \\n                res += strs[temp] + strs[temp - 2];\\n        }\\n        return res;\\n    }\\n\\n    string repeat(string repeatVal, int num) {\\n        string ret = \"\";\\n        while (num--) \\n            ret += repeatVal;\\n        return ret;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    private int[] values = {1000, 500, 100, 50, 10, 5, 1};\\n    private String[] strs = {\"M\", \"D\", \"C\", \"L\", \"X\", \"V\", \"I\"};\\n    private Map<Integer, Integer> myDict = new HashMap<Integer, Integer>() {{\\n        put(4, 0);\\n        put(3, 2);\\n        put(2, 4);\\n        put(1, 6);\\n    }};\\n\\n    public String intToRoman(int num) {\\n        return convertRoman(num/1000, 4) + convertRoman((num%1000)/100, 3) + convertRoman((num%100)/10, 2) + convertRoman(num%10, 1);      \\n    }\\n\\n    private String convertRoman(int digit, int value) {\\n        String res = \"\";\\n        int temp = myDict.get(value);\\n        if (temp == 0) \\n            res = repeat(strs[temp], digit);\\n        else {\\n            if (digit >= 1 && digit < 4) \\n                res += repeat(strs[temp], digit);\\n            else if (digit == 4) \\n                res += strs[temp] + strs[temp - 1];\\n            else if (digit >= 5 && digit < 9) \\n                res += strs[temp - 1] + repeat(strs[temp], (digit - 5));\\n            else if (digit == 9) \\n                res += strs[temp] + strs[temp - 2];\\n        }\\n        return res;\\n    }\\n\\n    private String repeat(String repeatVal, int num) {\\n        String ret = \"\";\\n        while (num-- > 0) \\n            ret += repeatVal;\\n        return ret;\\n    }\\n}\\n```\\n```csharp []\\npublic class Solution {\\n    private int[] values = {1000, 500, 100, 50, 10, 5, 1};\\n    private string[] strs = {\"M\", \"D\", \"C\", \"L\", \"X\", \"V\", \"I\"};\\n    private Dictionary<int, int> myDict = new Dictionary<int, int> {\\n        {4, 0},\\n        {3, 2},\\n        {2, 4},\\n        {1, 6}\\n    };\\n\\n    public string IntToRoman(int num) {\\n        return convertRoman(num/1000, 4) + convertRoman((num%1000)/100, 3) + convertRoman((num%100)/10, 2) + convertRoman(num%10, 1);      \\n    }\\n\\n    private string convertRoman(int digit, int value) {\\n        string res = \"\";\\n        int temp = myDict[value];\\n        if (temp == 0) \\n            res = repeat(strs[temp], digit);\\n        else {\\n            if (digit >= 1 && digit < 4) \\n                res += repeat(strs[temp], digit);\\n            else if (digit == 4) \\n                res += strs[temp] + strs[temp - 1];\\n            else if (digit >= 5 && digit < 9) \\n                res += strs[temp - 1] + repeat(strs[temp], (digit - 5));\\n            else if (digit == 9) \\n                res += strs[temp] + strs[temp - 2];\\n        }\\n        return res;\\n    }\\n\\n    private string repeat(string repeatVal, int num) {\\n        string ret = \"\";\\n        while (num-- > 0) \\n            ret += repeatVal;\\n        return ret;\\n    }\\n}\\n```\\n```python3 []\\nclass Solution:\\n    def __init__(self):\\n        self.values = [1000, 500, 100, 50, 10, 5, 1]\\n        self.strs = [\"M\", \"D\", \"C\", \"L\", \"X\", \"V\", \"I\"]\\n        self.myDict = {4: 0, 3: 2, 2: 4, 1: 6}\\n\\n    def intToRoman(self, num: int) -> str:\\n        return self.convertRoman(num//1000, 4) + self.convertRoman((num%1000)//100, 3) + self.convertRoman((num%100)//10, 2) + self.convertRoman(num%10, 1)\\n\\n    def convertRoman(self, digit: int, value: int) -> str:\\n        res = \"\"\\n        temp = self.myDict[value]\\n        if temp == 0:\\n            res = self.repeat(self.strs[temp], digit)\\n        else:\\n            if digit >= 1 and digit < 4:\\n                res += self.repeat(self.strs[temp], digit)\\n            elif digit == 4:\\n                res += self.strs[temp] + self.strs[temp - 1]\\n            elif digit >= 5 and digit < 9:\\n                res += self.strs[temp - 1] + self.repeat(self.strs[temp], (digit - 5))\\n            elif digit == 9:\\n                res += self.strs[temp] + self.strs[temp - 2]\\n        return res\\n\\n    def repeat(self, repeatVal: str, num: int) -> str:\\n        ret = \"\"\\n        while num > 0:\\n            ret += repeatVal\\n            num -= 1\\n        return ret\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nstd::vector<std::pair<std::string, int>> interview_frequency= {\\n    {\"Amazon\", 27},\\n    {\"Microsoft\", 5},\\n    {\"Bloomberg\", 5},\\n    {\"Apple\", 3},\\n    {\"Capital One\", 3},\\n    {\"Adobe\", 2},\\n    {\"Google\", 2},\\n    {\"tiktok\", 2}\\n};\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        return convertRoman(num/1000, 4) + convertRoman((num%1000)/100, 3) + convertRoman((num%100)/10, 2) + convertRoman(num%10, 1);      \\n    }\\n\\nprivate:\\n    int values[7] { 1000, 500, 100, 50, 10, 5, 1 };\\n    string strs[7] { \"M\", \"D\", \"C\", \"L\", \"X\", \"V\", \"I\" };\\n    unordered_map<int, int> myDict {{4, 0}, {3, 2}, {2, 4}, {1, 6}};\\n\\n    string convertRoman(int digit, int value) {\\n        string res = \"\";\\n        int temp = myDict[value];\\n        if (temp == 0) \\n            res = repeat(strs[temp], digit);\\n        else {\\n            if (digit >= 1 && digit < 4) \\n                res += repeat(strs[temp], digit);\\n            else if (digit == 4) \\n                res += strs[temp] + strs[temp - 1];\\n            else if (digit >= 5 && digit < 9) \\n                res += strs[temp - 1] + repeat(strs[temp], (digit - 5));\\n            else if (digit == 9) \\n                res += strs[temp] + strs[temp - 2];\\n        }\\n        return res;\\n    }\\n\\n    string repeat(string repeatVal, int num) {\\n        string ret = \"\";\\n        while (num--) \\n            ret += repeatVal;\\n        return ret;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    private int[] values = {1000, 500, 100, 50, 10, 5, 1};\\n    private String[] strs = {\"M\", \"D\", \"C\", \"L\", \"X\", \"V\", \"I\"};\\n    private Map<Integer, Integer> myDict = new HashMap<Integer, Integer>() {{\\n        put(4, 0);\\n        put(3, 2);\\n        put(2, 4);\\n        put(1, 6);\\n    }};\\n\\n    public String intToRoman(int num) {\\n        return convertRoman(num/1000, 4) + convertRoman((num%1000)/100, 3) + convertRoman((num%100)/10, 2) + convertRoman(num%10, 1);      \\n    }\\n\\n    private String convertRoman(int digit, int value) {\\n        String res = \"\";\\n        int temp = myDict.get(value);\\n        if (temp == 0) \\n            res = repeat(strs[temp], digit);\\n        else {\\n            if (digit >= 1 && digit < 4) \\n                res += repeat(strs[temp], digit);\\n            else if (digit == 4) \\n                res += strs[temp] + strs[temp - 1];\\n            else if (digit >= 5 && digit < 9) \\n                res += strs[temp - 1] + repeat(strs[temp], (digit - 5));\\n            else if (digit == 9) \\n                res += strs[temp] + strs[temp - 2];\\n        }\\n        return res;\\n    }\\n\\n    private String repeat(String repeatVal, int num) {\\n        String ret = \"\";\\n        while (num-- > 0) \\n            ret += repeatVal;\\n        return ret;\\n    }\\n}\\n```\n```csharp []\\npublic class Solution {\\n    private int[] values = {1000, 500, 100, 50, 10, 5, 1};\\n    private string[] strs = {\"M\", \"D\", \"C\", \"L\", \"X\", \"V\", \"I\"};\\n    private Dictionary<int, int> myDict = new Dictionary<int, int> {\\n        {4, 0},\\n        {3, 2},\\n        {2, 4},\\n        {1, 6}\\n    };\\n\\n    public string IntToRoman(int num) {\\n        return convertRoman(num/1000, 4) + convertRoman((num%1000)/100, 3) + convertRoman((num%100)/10, 2) + convertRoman(num%10, 1);      \\n    }\\n\\n    private string convertRoman(int digit, int value) {\\n        string res = \"\";\\n        int temp = myDict[value];\\n        if (temp == 0) \\n            res = repeat(strs[temp], digit);\\n        else {\\n            if (digit >= 1 && digit < 4) \\n                res += repeat(strs[temp], digit);\\n            else if (digit == 4) \\n                res += strs[temp] + strs[temp - 1];\\n            else if (digit >= 5 && digit < 9) \\n                res += strs[temp - 1] + repeat(strs[temp], (digit - 5));\\n            else if (digit == 9) \\n                res += strs[temp] + strs[temp - 2];\\n        }\\n        return res;\\n    }\\n\\n    private string repeat(string repeatVal, int num) {\\n        string ret = \"\";\\n        while (num-- > 0) \\n            ret += repeatVal;\\n        return ret;\\n    }\\n}\\n```\n```python3 []\\nclass Solution:\\n    def __init__(self):\\n        self.values = [1000, 500, 100, 50, 10, 5, 1]\\n        self.strs = [\"M\", \"D\", \"C\", \"L\", \"X\", \"V\", \"I\"]\\n        self.myDict = {4: 0, 3: 2, 2: 4, 1: 6}\\n\\n    def intToRoman(self, num: int) -> str:\\n        return self.convertRoman(num//1000, 4) + self.convertRoman((num%1000)//100, 3) + self.convertRoman((num%100)//10, 2) + self.convertRoman(num%10, 1)\\n\\n    def convertRoman(self, digit: int, value: int) -> str:\\n        res = \"\"\\n        temp = self.myDict[value]\\n        if temp == 0:\\n            res = self.repeat(self.strs[temp], digit)\\n        else:\\n            if digit >= 1 and digit < 4:\\n                res += self.repeat(self.strs[temp], digit)\\n            elif digit == 4:\\n                res += self.strs[temp] + self.strs[temp - 1]\\n            elif digit >= 5 and digit < 9:\\n                res += self.strs[temp - 1] + self.repeat(self.strs[temp], (digit - 5))\\n            elif digit == 9:\\n                res += self.strs[temp] + self.strs[temp - 2]\\n        return res\\n\\n    def repeat(self, repeatVal: str, num: int) -> str:\\n        ret = \"\"\\n        while num > 0:\\n            ret += repeatVal\\n            num -= 1\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2725198,
                "title": "python-rust-c-three-easy-concise-solutions-with-detailed-comments",
                "content": "**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n**** \\n**Python.** This [**solution**](https://leetcode.com/submissions/detail/826490173/) employs a repetition of Roman digits. It demonstrated **47 ms runtime (96.77%)** and used **13.9 MB memory (35.57%)**. Time complexity is contstant: **O(1)**. Space complexity is constant: **O(1)**.\\n```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        \\n\\t\\t# Starting from Python 3.7, dictionary order is guaranteed \\n\\t\\t# to be insertion order\\n        num_to_roman = { 1000 : \"M\", 900 : \"CM\", 500 : \"D\", 400 : \"CD\",\\n                          100 : \"C\",  90 : \"XC\",  50 : \"L\",  40 : \"XL\",\\n                           10 : \"X\",   9 : \"IX\",   5 : \"V\",   4 : \"IV\",\\n                            1 : \"I\" }\\n        roman: str = \"\"\\n\\n        # The idea is to repeat each of Roman digits as many times\\n        # as needed to cover the decimal representation.\\n        for i, r in num_to_roman.items():\\n            roman += r * (num // i)\\n            num   %= i\\n        else:\\n            return roman\\n```\\n**** \\n**Rust.** This [**solution**](https://leetcode.com/submissions/detail/826504889/) employs a brute force digit substitution. It demonstrated **0 ms runtime (100.00%)** and used **2.0 MB memory (94.20%)**. Time complexity is constant: **O(1)**. Space complexity is constant: **O(1)**.\\n```\\nconst ONES : [&str;10] = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"];\\nconst TENS : [&str;10] = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"];\\nconst CENT : [&str;10] = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"];\\nconst MILS : [&str;4]  = [\"\", \"M\", \"MM\", \"MMM\"];\\n\\nimpl Solution \\n{\\n    pub fn int_to_roman(num: i32) -> String \\n    {\\n        // Given that the number of outcomes is small, a brute force\\n\\t\\t// substituion for each power of ten is a viable solution...\\n\\t\\tformat!(\"{}{}{}{}\", MILS[(num / 1000 % 10) as usize],\\n                            CENT[(num / 100  % 10) as usize],\\n                            TENS[(num / 10   % 10) as usize],\\n                            ONES[(num        % 10) as usize])\\n    }\\n}\\n```\\n**** \\n**\\u0421++.** This [**solution**](https://leetcode.com/submissions/detail/826509511/) employs an iterative build-up of a Roman number. It demonstrated **0 ms runtime (100.0%)** and used **6.1 MB memory (47.60%)**. Time complexity is constant: **O(1)**. Space complexity is constant: **O(1)**.\\n```\\nclass Solution \\n{\\n    const int    intgr[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n    const string roman[13] = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n\\npublic:\\n    string intToRoman(int num)\\n    {\\n        string rom = \"\";\\n\\t\\t\\n        for (int i = 0; num > 0; i++)\\n\\t\\t    // each digit is repeated as many times as needed to \\n\\t\\t\\t// completely cover the decimal representation \\n            while (num >= intgr[i]) rom += roman[i], num -= intgr[i];\\n        return rom;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Python",
                    "C",
                    "Rust"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        \\n\\t\\t# Starting from Python 3.7, dictionary order is guaranteed \\n\\t\\t# to be insertion order\\n        num_to_roman = { 1000 : \"M\", 900 : \"CM\", 500 : \"D\", 400 : \"CD\",\\n                          100 : \"C\",  90 : \"XC\",  50 : \"L\",  40 : \"XL\",\\n                           10 : \"X\",   9 : \"IX\",   5 : \"V\",   4 : \"IV\",\\n                            1 : \"I\" }\\n        roman: str = \"\"\\n\\n        # The idea is to repeat each of Roman digits as many times\\n        # as needed to cover the decimal representation.\\n        for i, r in num_to_roman.items():\\n            roman += r * (num // i)\\n            num   %= i\\n        else:\\n            return roman\\n```\n```\\nconst ONES : [&str;10] = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"];\\nconst TENS : [&str;10] = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"];\\nconst CENT : [&str;10] = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"];\\nconst MILS : [&str;4]  = [\"\", \"M\", \"MM\", \"MMM\"];\\n\\nimpl Solution \\n{\\n    pub fn int_to_roman(num: i32) -> String \\n    {\\n        // Given that the number of outcomes is small, a brute force\\n\\t\\t// substituion for each power of ten is a viable solution...\\n\\t\\tformat!(\"{}{}{}{}\", MILS[(num / 1000 % 10) as usize],\\n                            CENT[(num / 100  % 10) as usize],\\n                            TENS[(num / 10   % 10) as usize],\\n                            ONES[(num        % 10) as usize])\\n    }\\n}\\n```\n```\\nclass Solution \\n{\\n    const int    intgr[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n    const string roman[13] = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n\\npublic:\\n    string intToRoman(int num)\\n    {\\n        string rom = \"\";\\n\\t\\t\\n        for (int i = 0; num > 0; i++)\\n\\t\\t    // each digit is repeated as many times as needed to \\n\\t\\t\\t// completely cover the decimal representation \\n            while (num >= intgr[i]) rom += roman[i], num -= intgr[i];\\n        return rom;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724059,
                "title": "python-3-8-lines-w-example-t-m-99-5-46",
                "content": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str: \\n\\n        mils = [\"\", \"M\", \"MM\", \"MMM\"]\\n\\n        cens = [ \"\",  \"C\",  \"CC\",  \"CCC\", \"CD\",\\n                \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"]\\n\\n        decs = [ \"\",  \"X\",  \"XX\",  \"XXX\", \"XL\",\\n                \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"]\\n\\n        unes = [ \"\",  \"I\",  \"II\",  \"III\", \"IV\",\\n                \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"]    #    EX:  num = 2579\\n\\n        m, num = divmod(num,1000)                  #  m = 2  num =  579\\n        c, num = divmod(num,100 )                  #  m = 5  num =   79\\n        d, u   = divmod(num,10  )                  #  m = 7  u   =    9\\n\\n        return mils[m]+cens[c]+decs[d]+unes[u]     #  mils[2]+cens[5]+decs[7]+unes[9] = MM + D + LXX + IX = MMDLXXIX \\n```\\n[https://leetcode.com/submissions/detail/826328411/](http://)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str: \\n\\n        mils = [\"\", \"M\", \"MM\", \"MMM\"]\\n\\n        cens = [ \"\",  \"C\",  \"CC\",  \"CCC\", \"CD\",\\n                \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"]\\n\\n        decs = [ \"\",  \"X\",  \"XX\",  \"XXX\", \"XL\",\\n                \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"]\\n\\n        unes = [ \"\",  \"I\",  \"II\",  \"III\", \"IV\",\\n                \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"]    #    EX:  num = 2579\\n\\n        m, num = divmod(num,1000)                  #  m = 2  num =  579\\n        c, num = divmod(num,100 )                  #  m = 5  num =   79\\n        d, u   = divmod(num,10  )                  #  m = 7  u   =    9\\n\\n        return mils[m]+cens[c]+decs[d]+unes[u]     #  mils[2]+cens[5]+decs[7]+unes[9] = MM + D + LXX + IX = MMDLXXIX \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1744490,
                "title": "easy-c-solution-with-full-explanation",
                "content": "\\n> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Basic approach, taking all possible cases that can happen and making a while loop for every case.\\n- We\\u2019ll calculate from a large value and will continue until it\\u2019s reduced to any other cases.\\n- Add the character to the last of the ans string.\\n- **Time complexity:** O(n^2).\\n\\n### Solution 02\\n\\n- Here we store the values of all cases in a string and int variable.\\n- Here 13 possible cases can happen, so we run a loop for 13 indexes.\\n- Similar to the previous approach runs a while loop until num is greater or equal to current number of our array & add this to our ans array.\\n- **Time complexity:** O(n^2).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num >= 1000){\\n            ans += \"M\";\\n            num -= 1000;\\n        }\\n        if(num >= 900){\\n            ans += \"CM\";\\n            num -= 900;\\n        }\\n        while(num >= 500){\\n            ans += \"D\";\\n            num -= 500;\\n        }\\n        if(num >= 400){\\n            ans += \"CD\";\\n            num -= 400;\\n        }\\n        while(num >= 100){\\n            ans += \"C\";\\n            num -= 100;\\n        }\\n        if(num >= 90){\\n            ans += \"XC\";\\n            num -= 90;\\n        }\\n        while(num >= 50){\\n            ans += \"L\";\\n            num -= 50;\\n        }\\n        if(num >= 40){\\n            ans += \"XL\";\\n            num -= 40;\\n        }\\n        while(num >= 10){\\n            ans += \"X\";\\n            num -= 10;\\n        }\\n        if(num >= 9){\\n            ans += \"IX\";\\n            num -= 9;\\n        }\\n        while(num >= 5){\\n            ans += \"V\";\\n            num -= 5;\\n        }\\n        if(num >= 4){\\n            ans += \"IV\";\\n            num -= 4;\\n        }\\n        while(num >= 1){\\n            ans += \"I\";\\n            num -= 1;\\n        }\\n        return ans;\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string valr[]={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        int vali[]={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        \\n        string ans;\\n        \\n        for(int i=0; i<13; i++){\\n            while(num >= vali[i]){\\n                ans.append(valr[i]);\\n                num -= vali[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num >= 1000){\\n            ans += \"M\";\\n            num -= 1000;\\n        }\\n        if(num >= 900){\\n            ans += \"CM\";\\n            num -= 900;\\n        }\\n        while(num >= 500){\\n            ans += \"D\";\\n            num -= 500;\\n        }\\n        if(num >= 400){\\n            ans += \"CD\";\\n            num -= 400;\\n        }\\n        while(num >= 100){\\n            ans += \"C\";\\n            num -= 100;\\n        }\\n        if(num >= 90){\\n            ans += \"XC\";\\n            num -= 90;\\n        }\\n        while(num >= 50){\\n            ans += \"L\";\\n            num -= 50;\\n        }\\n        if(num >= 40){\\n            ans += \"XL\";\\n            num -= 40;\\n        }\\n        while(num >= 10){\\n            ans += \"X\";\\n            num -= 10;\\n        }\\n        if(num >= 9){\\n            ans += \"IX\";\\n            num -= 9;\\n        }\\n        while(num >= 5){\\n            ans += \"V\";\\n            num -= 5;\\n        }\\n        if(num >= 4){\\n            ans += \"IV\";\\n            num -= 4;\\n        }\\n        while(num >= 1){\\n            ans += \"I\";\\n            num -= 1;\\n        }\\n        return ans;\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string valr[]={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        int vali[]={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        \\n        string ans;\\n        \\n        for(int i=0; i<13; i++){\\n            while(num >= vali[i]){\\n                ans.append(valr[i]);\\n                num -= vali[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119875,
                "title": "solution-in-java-100-faster",
                "content": "```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        int[] v = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        String[] s = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        StringBuilder sb=new StringBuilder();\\n        \\n        for(int i=0;i<v.length;i++){\\n            while(num>=v[i]){\\n                sb.append(s[i]);\\n                num-=v[i];\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\nPlease **upvote**, if you like the solution:)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        int[] v = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        String[] s = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        StringBuilder sb=new StringBuilder();\\n        \\n        for(int i=0;i<v.length;i++){\\n            while(num>=v[i]){\\n                sb.append(s[i]);\\n                num-=v[i];\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1102909,
                "title": "c-simplest-straight-forward-solution-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<string> roman = {\"M\", \"D\", \"C\", \"L\", \"X\", \"V\", \"I\"};\\n        vector<int> integers = {1000, 500, 100, 50, 10, 5, 1};\\n        vector<int> carry = {100, 100, 10, 10, 1, 1, 0};\\n        \\n        string res = \"\";\\n        int next;\\n        \\n        for (int i = 0; num; i++) {\\n            \\n            int temp = num / integers[i];\\n            while (temp--) res += roman[i];\\n            num %= integers[i];\\n            \\n            if (i == 6) return res;\\n            \\n            next = carry[i];\\n            if ((num - num % next) == (integers[i] - next)) {\\n                res += i % 2 ? roman[i+1] + roman[i] : roman[i+2] + roman[i];\\n                num -= integers[i] - next;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<string> roman = {\"M\", \"D\", \"C\", \"L\", \"X\", \"V\", \"I\"};\\n        vector<int> integers = {1000, 500, 100, 50, 10, 5, 1};\\n        vector<int> carry = {100, 100, 10, 10, 1, 1, 0};\\n        \\n        string res = \"\";\\n        int next;\\n        \\n        for (int i = 0; num; i++) {\\n            \\n            int temp = num / integers[i];\\n            while (temp--) res += roman[i];\\n            num %= integers[i];\\n            \\n            if (i == 6) return res;\\n            \\n            next = carry[i];\\n            if ((num - num % next) == (integers[i] - next)) {\\n                res += i % 2 ? roman[i+1] + roman[i] : roman[i+2] + roman[i];\\n                num -= integers[i] - next;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 204750,
                "title": "easy-with-javascript",
                "content": "```\\nfunction intToRoman(num) {\\n    var hash = [\\n        [\\'\\', \\'I\\', \\'II\\', \\'III\\', \\'IV\\', \\'V\\', \\'VI\\', \\'VII\\', \\'VIII\\', \\'IX\\'],\\n        [\\'\\', \\'X\\', \\'XX\\', \\'XXX\\', \\'XL\\', \\'L\\', \\'LX\\', \\'LXX\\', \\'LXXX\\', \\'XC\\'],\\n        [\\'\\', \\'C\\', \\'CC\\', \\'CCC\\', \\'CD\\', \\'D\\', \\'DC\\', \\'DCC\\', \\'DCCC\\', \\'CM\\'],\\n        [\\'\\', \\'M\\', \\'MM\\', \\'MMM\\']\\n    ];\\n    \\n    var result = \\'\\';\\n    var counter = 0;\\n    while (num > 0) {\\n        result = hash[counter++][num % 10] + result;\\n        num = Math.floor(num / 10);\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfunction intToRoman(num) {\\n    var hash = [\\n        [\\'\\', \\'I\\', \\'II\\', \\'III\\', \\'IV\\', \\'V\\', \\'VI\\', \\'VII\\', \\'VIII\\', \\'IX\\'],\\n        [\\'\\', \\'X\\', \\'XX\\', \\'XXX\\', \\'XL\\', \\'L\\', \\'LX\\', \\'LXX\\', \\'LXXX\\', \\'XC\\'],\\n        [\\'\\', \\'C\\', \\'CC\\', \\'CCC\\', \\'CD\\', \\'D\\', \\'DC\\', \\'DCC\\', \\'DCCC\\', \\'CM\\'],\\n        [\\'\\', \\'M\\', \\'MM\\', \\'MMM\\']\\n    ];\\n    \\n    var result = \\'\\';\\n    var counter = 0;\\n    while (num > 0) {\\n        result = hash[counter++][num % 10] + result;\\n        num = Math.floor(num / 10);\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 169178,
                "title": "simple-java-solution-with-treemap",
                "content": "```\\nimport java.util.HashMap;\\nimport java.util.Map;\\nimport java.util.TreeMap;\\n\\nclass Solution {\\n\\n    public static TreeMap<Integer, String> map = new TreeMap<>();\\n\\n    static {\\n\\n        map.put(1,\"I\");\\n        map.put(5, \"V\");\\n        map.put(10, \"X\");\\n        map.put(50, \"L\");\\n        map.put(100, \"C\");\\n        map.put(500, \"D\");\\n        map.put(1000, \"M\");\\n        map.put(4, \"IV\");\\n        map.put(9, \"IX\");\\n        map.put(40, \"XL\");\\n        map.put(90, \"XC\");\\n        map.put(400, \"CD\");\\n        map.put(900, \"CM\");\\n    }\\n    public static String intToRoman(int num) {\\n        StringBuilder ans = new StringBuilder();\\n        while (num != 0) {\\n            Map.Entry<Integer, String> entry = map.floorEntry(num);\\n            ans.append(entry.getValue());\\n            num -= entry.getKey();\\n        }\\n        return ans.toString();\\n\\n    }\\n\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.HashMap;\\nimport java.util.Map;\\nimport java.util.TreeMap;\\n\\nclass Solution {\\n\\n    public static TreeMap<Integer, String> map = new TreeMap<>();\\n\\n    static {\\n\\n        map.put(1,\"I\");\\n        map.put(5, \"V\");\\n        map.put(10, \"X\");\\n        map.put(50, \"L\");\\n        map.put(100, \"C\");\\n        map.put(500, \"D\");\\n        map.put(1000, \"M\");\\n        map.put(4, \"IV\");\\n        map.put(9, \"IX\");\\n        map.put(40, \"XL\");\\n        map.put(90, \"XC\");\\n        map.put(400, \"CD\");\\n        map.put(900, \"CM\");\\n    }\\n    public static String intToRoman(int num) {\\n        StringBuilder ans = new StringBuilder();\\n        while (num != 0) {\\n            Map.Entry<Integer, String> entry = map.floorEntry(num);\\n            ans.append(entry.getValue());\\n            num -= entry.getKey();\\n        }\\n        return ans.toString();\\n\\n    }\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3114050,
                "title": "js-ts-clean-and-easy-solution-beats-98-5",
                "content": "```\\nfunction intToRoman(num: number): string {\\n    const rNums: Record<string,number> = {\\n      M:1000,\\n      CM:900,\\n      D:500,\\n      CD:400,\\n      C:100,\\n      XC:90,\\n      L:50,\\n      XL:40,\\n      X:10,\\n      IX:9,\\n      V:5,\\n      IV:4,\\n      I:1\\n    };\\n    let result = \\'\\';\\n    for(let rN in rNums){\\n        let count = num / rNums[rN];\\n        if(count>0) {\\n            result+= rN.repeat(count);\\n            num = num % rNums[rN];\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction intToRoman(num: number): string {\\n    const rNums: Record<string,number> = {\\n      M:1000,\\n      CM:900,\\n      D:500,\\n      CD:400,\\n      C:100,\\n      XC:90,\\n      L:50,\\n      XL:40,\\n      X:10,\\n      IX:9,\\n      V:5,\\n      IV:4,\\n      I:1\\n    };\\n    let result = \\'\\';\\n    for(let rN in rNums){\\n        let count = num / rNums[rN];\\n        if(count>0) {\\n            result+= rN.repeat(count);\\n            num = num % rNums[rN];\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2613942,
                "title": "python-solution",
                "content": "```\\ndef intToRoman(self, num: int) -> str:\\n\\tdic = {\"M\": 1000, \"CM\": 900, \"D\": 500, \"CD\": 400,\\n\\t   \"C\": 100, \"XC\": 90, \"L\": 50, \"XL\": 40, \"X\": 10,\\n\\t   \"IX\": 9, \"V\": 5, \"IV\": 4, \"I\": 1}\\n\\n\\toutput = \"\"\\n\\tfor key, value in dic.items():\\n\\t\\toutput += key * (num // value)\\n\\t\\tif num // value != 0:\\n\\t\\t\\tnum -= (value * (num // value))\\n\\n\\treturn output\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef intToRoman(self, num: int) -> str:\\n\\tdic = {\"M\": 1000, \"CM\": 900, \"D\": 500, \"CD\": 400,\\n\\t   \"C\": 100, \"XC\": 90, \"L\": 50, \"XL\": 40, \"X\": 10,\\n\\t   \"IX\": 9, \"V\": 5, \"IV\": 4, \"I\": 1}\\n\\n\\toutput = \"\"\\n\\tfor key, value in dic.items():\\n\\t\\toutput += key * (num // value)\\n\\t\\tif num // value != 0:\\n\\t\\t\\tnum -= (value * (num // value))\\n\\n\\treturn output\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2568037,
                "title": "javascript-simple-solution",
                "content": "```\\nvar intToRoman = function(num) {\\n    let roman = {\\n        \\'M\\':  1000, \\'CM\\': 900, \\'D\\':  500, \\'CD\\': 400,\\n        \\'C\\':  100,  \\'XC\\': 90,  \\'L\\':  50,  \\'XL\\': 40,\\n        \\'X\\':  10,   \\'IX\\': 9,   \\'V\\':  5,   \\'IV\\': 4, \\'I\\':  1\\n    },  \\n\\tromanNum = \\'\\';\\n\\t\\n    for(let i in roman){\\n        while(num >= roman[i]){\\n            romanNum += i;\\n            num -= roman[i];\\n        }\\n    }\\n    return romanNum; \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar intToRoman = function(num) {\\n    let roman = {\\n        \\'M\\':  1000, \\'CM\\': 900, \\'D\\':  500, \\'CD\\': 400,\\n        \\'C\\':  100,  \\'XC\\': 90,  \\'L\\':  50,  \\'XL\\': 40,\\n        \\'X\\':  10,   \\'IX\\': 9,   \\'V\\':  5,   \\'IV\\': 4, \\'I\\':  1\\n    },  \\n\\tromanNum = \\'\\';\\n\\t\\n    for(let i in roman){\\n        while(num >= roman[i]){\\n            romanNum += i;\\n            num -= roman[i];\\n        }\\n    }\\n    return romanNum; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2240419,
                "title": "c-2methods-easy-and-fast",
                "content": "**METHOD 1: Short and easy**\\n\\nEach quotient will tell how much is the value / what should be the Roman Symbol\\n\\n//KHELO DIMAAG SE XD\\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ones[] = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        string tens[] = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        string hrns[] = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        string ths[]={\"\",\"M\",\"MM\",\"MMM\"};\\n        \\n        return ths[num/1000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\\n    }\\n};\\n\\n```\\n\\n**Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F\\nIf you have some \\uD83E\\uDD14 doubts feel free to bug me (^~^)***\\n```\\n\\n```\\n\\n**METHOD 2: correct but quite bulky ;)**\\n\\nSuppose num = 1984\\nwe split it as : 1000 + 900 + 80 + 4 \\nand at each iteration compare it\\'s value.\\n\\nSpecial cases are dealt separately. (4,9,40,90,400,90)\\n\\n80 is internally split as : 50 + 10 +10 +10\\nSEE RANGES of num in the if-else ladder \\n\\nand atlast we do num = num - val;\\n\\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        int val=1;\\n        while(num>0){\\n            string ch=\"\";\\n            if(num>=1000)\\n                val=1000;\\n            else if(num>=900)\\n                val=900;\\n            else if(num>=500)\\n                val=500;\\n            else if(num>=400)\\n                val=400;\\n            else if(num>=100)\\n                val=100;\\n            else if(num>=90)\\n                val=90;\\n            else if(num>=50)\\n                val=50;\\n            else if(num>=40)\\n                val=40;\\n            else if(num>=10)\\n                val=10;\\n            else if(num==9)\\n                val=9;\\n            else if(num>=5)\\n                val=5;\\n            else if(num==4)\\n                val=4;\\n            else if(num>=1)\\n                val=1;\\n            \\n            switch(val){\\n                case 1: ch=\"I\";break;\\n                case 5: ch=\"V\";break;\\n                case 10: ch=\"X\";break;\\n                case 50: ch=\"L\";break;\\n                case 100: ch=\"C\";break;\\n                case 500: ch=\"D\";break;\\n                case 1000: ch=\"M\";break;\\n                case 4: ch=\"IV\";break;\\n                case 9: ch=\"IX\";break;\\n                case 40: ch=\"XL\";break;\\n                case 90: ch=\"XC\";break;\\n                case 400: ch=\"CD\";break;\\n                case 900: ch=\"CM\";break;\\n            }\\n            ans+=ch;\\n            num=num-val;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ones[] = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        string tens[] = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        string hrns[] = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        string ths[]={\"\",\"M\",\"MM\",\"MMM\"};\\n        \\n        return ths[num/1000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\\n    }\\n};\\n\\n```\n```\\n\\n```\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        int val=1;\\n        while(num>0){\\n            string ch=\"\";\\n            if(num>=1000)\\n                val=1000;\\n            else if(num>=900)\\n                val=900;\\n            else if(num>=500)\\n                val=500;\\n            else if(num>=400)\\n                val=400;\\n            else if(num>=100)\\n                val=100;\\n            else if(num>=90)\\n                val=90;\\n            else if(num>=50)\\n                val=50;\\n            else if(num>=40)\\n                val=40;\\n            else if(num>=10)\\n                val=10;\\n            else if(num==9)\\n                val=9;\\n            else if(num>=5)\\n                val=5;\\n            else if(num==4)\\n                val=4;\\n            else if(num>=1)\\n                val=1;\\n            \\n            switch(val){\\n                case 1: ch=\"I\";break;\\n                case 5: ch=\"V\";break;\\n                case 10: ch=\"X\";break;\\n                case 50: ch=\"L\";break;\\n                case 100: ch=\"C\";break;\\n                case 500: ch=\"D\";break;\\n                case 1000: ch=\"M\";break;\\n                case 4: ch=\"IV\";break;\\n                case 9: ch=\"IX\";break;\\n                case 40: ch=\"XL\";break;\\n                case 90: ch=\"XC\";break;\\n                case 400: ch=\"CD\";break;\\n                case 900: ch=\"CM\";break;\\n            }\\n            ans+=ch;\\n            num=num-val;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1311405,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        int[] no={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        String[] code={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        \\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<no.length;i++)\\n        {\\n            while(num >= no[i])\\n            {\\n                sb.append(code[i]);\\n                num-=no[i];\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        int[] no={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        String[] code={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        \\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<no.length;i++)\\n        {\\n            while(num >= no[i])\\n            {\\n                sb.append(code[i]);\\n                num-=no[i];\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1168743,
                "title": "go-4ms-3-3mb-solution-with-0-b-op-and-0-aloc-op",
                "content": "```go\\nvar (\\n\\tr0 = []string{\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"}\\n\\tr1 = []string{\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"}\\n\\tr2 = []string{\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"}\\n\\tr3 = []string{\"\", \"M\", \"MM\", \"MMM\"}\\n)\\n\\nfunc intToRoman(num int) string {\\n\\t// This is efficient in Go. The 4 operands are evaluated,\\n\\t// then a single allocation is made of the exact size needed for the result.\\n\\treturn r3[num%1e4/1e3] + r2[num%1e3/1e2] + r1[num%100/10] + r0[num%10]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nvar (\\n\\tr0 = []string{\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"}\\n\\tr1 = []string{\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"}\\n\\tr2 = []string{\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"}\\n\\tr3 = []string{\"\", \"M\", \"MM\", \"MMM\"}\\n)\\n\\nfunc intToRoman(num int) string {\\n\\t// This is efficient in Go. The 4 operands are evaluated,\\n\\t// then a single allocation is made of the exact size needed for the result.\\n\\treturn r3[num%1e4/1e3] + r2[num%1e3/1e2] + r1[num%100/10] + r0[num%10]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1103708,
                "title": "java-simple-and-easy-to-understand-solution-3-ms-faster-than-100-00-with-efficient-memory-usage",
                "content": "# PLEASE UPVOTE IF YOU LIKE THIS SOLUTION\\n\\n```\\nclass Solution {\\n    static String[] symbol = new String[]{\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"};\\n    static int[] value = new int[]{1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000};\\n    \\n    public String intToRoman(int num) {\\n\\n        \\n        StringBuilder sb = new StringBuilder();\\n        int i = value.length - 1;\\n        \\n        //Logic\\n        //Subtract num with value[i] till num is greater than Zero, \\n        // if num is greater/equal to value[i], and append Corresponding symbol\\n        // else just move lower value\\n         \\n        while(num > 0 && i >= 0){\\n            \\n            if(num < value[i]){\\n                //just move to lower value\\n                i--;\\n            } else {\\n                //decreament num with Current value\\n                num -= value[i];\\n                \\n                //now append the corresponding symbol\\n                sb.append(symbol[i]);\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    static String[] symbol = new String[]{\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"};\\n    static int[] value = new int[]{1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000};\\n    \\n    public String intToRoman(int num) {\\n\\n        \\n        StringBuilder sb = new StringBuilder();\\n        int i = value.length - 1;\\n        \\n        //Logic\\n        //Subtract num with value[i] till num is greater than Zero, \\n        // if num is greater/equal to value[i], and append Corresponding symbol\\n        // else just move lower value\\n         \\n        while(num > 0 && i >= 0){\\n            \\n            if(num < value[i]){\\n                //just move to lower value\\n                i--;\\n            } else {\\n                //decreament num with Current value\\n                num -= value[i];\\n                \\n                //now append the corresponding symbol\\n                sb.append(symbol[i]);\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 491557,
                "title": "python-o-log-n-o-1-100-100-simple-intuitive",
                "content": "```\\nclass Solution:\\n\\tdef intToRoman(self, num: int) -> str:\\n\\t\\tres = \"\"\\n\\t\\ts=1000\\n\\n\\t\\td = {1:\"I\", 5:\"V\", 10:\"X\", 50:\"L\", 100:\"C\", 500:\"D\", 1000:\"M\"}\\n\\n\\t\\twhile num!=0:\\n\\t\\t\\tr, temp = divmod(num, s)\\n\\n\\t\\t\\tif r==9:\\n\\t\\t\\t\\tres+=d[s]+d[s*10]\\n\\t\\t\\telif r==4:\\n\\t\\t\\t\\tres+=d[s]+d[s*5]\\n\\t\\t\\telif r>=5:\\n\\t\\t\\t\\tres+=d[s*5] + d[s]*(r-5) \\n\\t\\t\\telse:\\n\\t\\t\\t\\tres += d[s]*r\\n\\n\\t\\t\\ts=s//10\\n\\t\\t\\tnum=temp\\n\\n\\t\\treturn res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\tdef intToRoman(self, num: int) -> str:\\n\\t\\tres = \"\"\\n\\t\\ts=1000\\n\\n\\t\\td = {1:\"I\", 5:\"V\", 10:\"X\", 50:\"L\", 100:\"C\", 500:\"D\", 1000:\"M\"}\\n\\n\\t\\twhile num!=0:\\n\\t\\t\\tr, temp = divmod(num, s)\\n\\n\\t\\t\\tif r==9:\\n\\t\\t\\t\\tres+=d[s]+d[s*10]\\n\\t\\t\\telif r==4:\\n\\t\\t\\t\\tres+=d[s]+d[s*5]\\n\\t\\t\\telif r>=5:\\n\\t\\t\\t\\tres+=d[s*5] + d[s]*(r-5) \\n\\t\\t\\telse:\\n\\t\\t\\t\\tres += d[s]*r\\n\\n\\t\\t\\ts=s//10\\n\\t\\t\\tnum=temp\\n\\n\\t\\treturn res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 389377,
                "title": "easy-to-understand-python3",
                "content": "We are basically creating a dict for mapping the numerals, and then substracting the values from the `num` variable, starting with the highest, and on every substraction we add the corresponding roman numeral.\\n\\nYou can use an `OrderedDict` instead of having the extra list `arr` that i\\'m using, but I don\\'t think theres much of a performance difference.\\n```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        mapping = {\\n            1: \"I\",\\n            4: \"IV\",\\n            5: \"V\",\\n            9: \"IX\",\\n            10: \"X\",\\n            40: \"XL\",\\n            50: \"L\",\\n            90: \"XC\",\\n            100: \"C\",\\n            400: \"CD\",\\n            500: \"D\",\\n            900: \"CM\",\\n            1000: \"M\",\\n        }\\n        arr = [1000,900,500,400,100,90,50,40,10,9,5,4,1]\\n        result = \"\"\\n        for a in arr:\\n            while num >= a:\\n                num = num - a\\n                result = result + mapping[a]\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        mapping = {\\n            1: \"I\",\\n            4: \"IV\",\\n            5: \"V\",\\n            9: \"IX\",\\n            10: \"X\",\\n            40: \"XL\",\\n            50: \"L\",\\n            90: \"XC\",\\n            100: \"C\",\\n            400: \"CD\",\\n            500: \"D\",\\n            900: \"CM\",\\n            1000: \"M\",\\n        }\\n        arr = [1000,900,500,400,100,90,50,40,10,9,5,4,1]\\n        result = \"\"\\n        for a in arr:\\n            while num >= a:\\n                num = num - a\\n                result = result + mapping[a]\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 241683,
                "title": "simple-python-beats-99",
                "content": "```\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        \"\"\"\\n        :type num: int\\n        :rtype: str\\n        \"\"\"\\n        if not num: return\\n        \\n        out = \\'\\'\\n        \\n        values = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ]\\n        Roman = [ \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" ]\\n        \\n        for i in range (len(values)):\\n            while num >= values[i]:\\n                num -= values[i]\\n                out += Roman[i]\\n        return out\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        \"\"\"\\n        :type num: int\\n        :rtype: str\\n        \"\"\"\\n        if not num: return\\n        \\n        out = \\'\\'\\n        \\n        values = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ]\\n        Roman = [ \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" ]\\n        \\n        for i in range (len(values)):\\n            while num >= values[i]:\\n                num -= values[i]\\n                out += Roman[i]\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 233083,
                "title": "95-python-solution-that-s-easy-to-grok",
                "content": "While looking through the Python solutions trying to figure out how to get mine faster I was surprised that none were similar to mine, so...\\n\\n```python\\nret = \"\" \\nroman_to_int = [ \\n    (\"M\", 1000),\\n    (\"CM\", 900),\\n    (\"D\", 500),\\n    (\"CD\", 400),\\n    (\"C\", 100),\\n    (\"XC\", 90),\\n    (\"L\", 50),\\n    (\"XL\", 40),\\n    (\"X\", 10),\\n    (\"IX\", 9),\\n    (\"V\", 5),\\n    (\"IV\", 4),\\n    (\"I\", 1),\\n]\\n\\nfor roman, value in roman_to_int:\\n    while num >= value:\\n        ret += roman \\n        num -= value\\n    \\nreturn ret\\n```\\n",
                "solutionTags": [],
                "code": "```python\\nret = \"\" \\nroman_to_int = [ \\n    (\"M\", 1000),\\n    (\"CM\", 900),\\n    (\"D\", 500),\\n    (\"CD\", 400),\\n    (\"C\", 100),\\n    (\"XC\", 90),\\n    (\"L\", 50),\\n    (\"XL\", 40),\\n    (\"X\", 10),\\n    (\"IX\", 9),\\n    (\"V\", 5),\\n    (\"IV\", 4),\\n    (\"I\", 1),\\n]\\n\\nfor roman, value in roman_to_int:\\n    while num >= value:\\n        ret += roman \\n        num -= value\\n    \\nreturn ret\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3752772,
                "title": "beats-99-55-brute-force-easy-to-understand-beginner-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/207d1a5c-ba36-4766-bf5d-574a7adbc53e_1690968849.1358607.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        x = \\'\\'\\n        while num!=0:\\n            if num>= 1000:\\n                x+=\\'M\\'\\n                num-=1000\\n            elif num>= 900:\\n                x+=\\'CM\\'\\n                num-=900\\n            elif num>= 500:\\n                x+=\\'D\\'\\n                num-= 500\\n            elif num>= 400: \\n                x+=\\'CD\\' \\n                num-= 400\\n            elif num>= 100:\\n                x+=\\'C\\'\\n                num-=100\\n            elif num>= 90:\\n                x+=\\'XC\\' \\n                num-=90\\n            elif num>= 50:\\n                x+=\\'L\\' \\n                num-=50\\n            elif num>= 40:\\n                x+=\\'XL\\' \\n                num-=40\\n            elif num>= 10:\\n                x+=\\'X\\' \\n                num-=10\\n            elif num>= 9:\\n                x+=\\'IX\\' \\n                num-=9\\n            elif num>= 5:\\n                x+=\\'V\\' \\n                num-=5\\n            elif num>= 4:\\n                x+=\\'IV\\' \\n                num-=4\\n            else:\\n                x+=\\'I\\'\\n                num-=1\\n        return x\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        x = \\'\\'\\n        while num!=0:\\n            if num>= 1000:\\n                x+=\\'M\\'\\n                num-=1000\\n            elif num>= 900:\\n                x+=\\'CM\\'\\n                num-=900\\n            elif num>= 500:\\n                x+=\\'D\\'\\n                num-= 500\\n            elif num>= 400: \\n                x+=\\'CD\\' \\n                num-= 400\\n            elif num>= 100:\\n                x+=\\'C\\'\\n                num-=100\\n            elif num>= 90:\\n                x+=\\'XC\\' \\n                num-=90\\n            elif num>= 50:\\n                x+=\\'L\\' \\n                num-=50\\n            elif num>= 40:\\n                x+=\\'XL\\' \\n                num-=40\\n            elif num>= 10:\\n                x+=\\'X\\' \\n                num-=10\\n            elif num>= 9:\\n                x+=\\'IX\\' \\n                num-=9\\n            elif num>= 5:\\n                x+=\\'V\\' \\n                num-=5\\n            elif num>= 4:\\n                x+=\\'IV\\' \\n                num-=4\\n            else:\\n                x+=\\'I\\'\\n                num-=1\\n        return x\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724066,
                "title": "c-solution-easy-5-line-function",
                "content": "# Looking for Contribution in Hacktoberfest\\n## You are welcomed to contribute in my Repos:-\\n# GITHUB LINK --> [Yaduttam95](https://github.com/Yaduttam95)\\n\\n# If you liked the solution please UPVOTE \\uD83D\\uDC4D\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    string intToRoman(int A) {\\n\\n    string ones[] = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n\\n    string tens[] = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n\\n    string hrns[] = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n\\n    string thns[] = {\"\",\"M\",\"MM\",\"MMM\"};\\n\\n    \\n\\n    return thns[A/1000] + hrns[(A%1000)/100] + tens[(A%100)/10] + ones[A%10];\\n\\n}\\n};\\n```\\n\\n\\n## if you reached till here and solution worked for you kindly upvote the solution",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    string intToRoman(int A) {\\n\\n    string ones[] = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n\\n    string tens[] = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n\\n    string hrns[] = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n\\n    string thns[] = {\"\",\"M\",\"MM\",\"MMM\"};\\n\\n    \\n\\n    return thns[A/1000] + hrns[(A%1000)/100] + tens[(A%100)/10] + ones[A%10];\\n\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2723812,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        int Value[]={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        string Symbol[]={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        for(int i=0;num!=0;i++)\\n        {\\n            while(num>=Value[i])\\n            {\\n                ans+=Symbol[i];\\n                num-=Value[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        int Value[]={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        string Symbol[]={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        for(int i=0;num!=0;i++)\\n        {\\n            while(num>=Value[i])\\n            {\\n                ans+=Symbol[i];\\n                num-=Value[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489093,
                "title": "simple-solution-no-loop",
                "content": "```\\nclass Solution {\\n    public String intToRoman(int n) {\\n     \\n    String units[]={\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        \\n String tens[]={\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        \\nString hundreds[]=  {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n        \\nString thousands[]={\"\",\"M\",\"MM\",\"MMM\"};\\n\\n        \\n        return (thousands[n/1000]+\\n               hundreds[(n % 1000)/100]+\\n                tens[(n%100)/10]+\\n               units[n%10]);\\n        \\n        \\n    }\\n}  \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String intToRoman(int n) {\\n     \\n    String units[]={\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        \\n String tens[]={\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        \\nString hundreds[]=  {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n        \\nString thousands[]={\"\",\"M\",\"MM\",\"MMM\"};\\n\\n        \\n        return (thousands[n/1000]+\\n               hundreds[(n % 1000)/100]+\\n                tens[(n%100)/10]+\\n               units[n%10]);\\n        \\n        \\n    }\\n}  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2427934,
                "title": "java-solution-using-treemap",
                "content": "```\\n\\tpublic String intToRoman(int num) {\\n        TreeMap<Integer, String> tm = new TreeMap<Integer, String>();\\n        tm.put(1,\"I\");\\n        tm.put(5,\"V\");\\n        tm.put(10,\"X\");\\n        tm.put(50,\"L\");\\n        tm.put(100,\"C\");\\n        tm.put(500,\"D\");\\n        tm.put(1000,\"M\");\\n        tm.put(4,\"IV\");\\n        tm.put(9,\"IX\");\\n        tm.put(40,\"XL\");\\n        tm.put(90,\"XC\");\\n        tm.put(400,\"CD\");\\n        tm.put(900,\"CM\");\\n        \\n        StringBuilder romanNumeral = new StringBuilder(\"\");\\n        while(num > 0){\\n            int nearestNum = tm.floorKey(num);\\n            romanNumeral.append(tm.get(nearestNum));\\n            num = num - nearestNum;\\n        }\\n        \\n        return romanNumeral.toString();\\n        \\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\n\\tpublic String intToRoman(int num) {\\n        TreeMap<Integer, String> tm = new TreeMap<Integer, String>();\\n        tm.put(1,\"I\");\\n        tm.put(5,\"V\");\\n        tm.put(10,\"X\");\\n        tm.put(50,\"L\");\\n        tm.put(100,\"C\");\\n        tm.put(500,\"D\");\\n        tm.put(1000,\"M\");\\n        tm.put(4,\"IV\");\\n        tm.put(9,\"IX\");\\n        tm.put(40,\"XL\");\\n        tm.put(90,\"XC\");\\n        tm.put(400,\"CD\");\\n        tm.put(900,\"CM\");\\n        \\n        StringBuilder romanNumeral = new StringBuilder(\"\");\\n        while(num > 0){\\n            int nearestNum = tm.floorKey(num);\\n            romanNumeral.append(tm.get(nearestNum));\\n            num = num - nearestNum;\\n        }\\n        \\n        return romanNumeral.toString();\\n        \\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2140059,
                "title": "rust-o-1-super-efficient-simple-with-thorough-explanation-0ms",
                "content": "Conversion to Roman numerals is O(1) time-complexity and space complexity is also constant.\\n\\nExplanation: The array of Roman numerals from 0 to 3999 is indexed by the input value, `num`.\\n\\n\\u2728\\uD83D\\uDE01 \\u2728\\n\\n```rust\\n\\nimpl Solution {\\n    pub fn int_to_roman(num: i32) -> String {\\n        NUMERALS[num as usize].to_string()\\n    }\\n}\\n\\nconst NUMERALS: [&str; 4000] = [\\n    \"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\",\"VIII\", \"IX\", \"X\", \"XI\", \\n    \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\",\\n    \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \\n    \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \\n    \"XXXVIII\", \"XXXIX\", \"XL\", \"XLI\", \"XLII\", \"XLIII\", \"XLIV\", \"XLV\", \"XLVI\",\\n    \"XLVII\", \"XLVIII\", \"XLIX\", \"L\", \"LI\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\",\\n    \"LVII\", \"LVIII\", \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \\n    \"LXVI\", \"LXVII\", \"LXVIII\", \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \\n    \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\",\\n    \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\",\\n    \"LXXXIX\", \"XC\", \"XCI\", \"XCII\", \"XCIII\", \"XCIV\", \"XCV\", \"XCVI\", \"XCVII\", \\n    \"XCVIII\", \"XCIX\", \"C\", \"CI\", \"CII\", \"CIII\", \"CIV\", \"CV\", \"CVI\", \"CVII\", \\n    \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \\n    \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\", \"CXXII\", \"CXXIII\", \"CXXIV\", \\n    \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\", \"CXXIX\", \"CXXX\", \"CXXXI\", \\n    \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\", \"CXXXVII\", \"CXXXVIII\",\\n    \"CXXXIX\", \"CXL\", \"CXLI\", \"CXLII\", \"CXLIII\", \"CXLIV\", \"CXLV\", \"CXLVI\", \\n    \"CXLVII\", \"CXLVIII\", \"CXLIX\", \"CL\", \"CLI\", \"CLII\", \"CLIII\", \"CLIV\", \\n    \"CLV\", \"CLVI\", \"CLVII\", \"CLVIII\", \"CLIX\", \"CLX\", \"CLXI\", \"CLXII\", \\n    \"CLXIII\", \"CLXIV\", \"CLXV\", \"CLXVI\", \"CLXVII\", \"CLXVIII\", \"CLXIX\", \\n    \"CLXX\", \"CLXXI\", \"CLXXII\", \"CLXXIII\", \"CLXXIV\", \"CLXXV\", \"CLXXVI\", \\n    \"CLXXVII\", \"CLXXVIII\", \"CLXXIX\", \"CLXXX\", \"CLXXXI\", \"CLXXXII\", \\n    \"CLXXXIII\", \"CLXXXIV\", \"CLXXXV\", \"CLXXXVI\", \"CLXXXVII\", \"CLXXXVIII\", \\n    \"CLXXXIX\", \"CXC\", \"CXCI\", \"CXCII\", \"CXCIII\", \"CXCIV\", \"CXCV\", \"CXCVI\", \\n    \"CXCVII\", \"CXCVIII\", \"CXCIX\", \"CC\", \"CCI\", \"CCII\", \"CCIII\", \"CCIV\", \\n    \"CCV\", \"CCVI\", \"CCVII\", \"CCVIII\", \"CCIX\", \"CCX\", \"CCXI\", \"CCXII\", \\n    \"CCXIII\", \"CCXIV\", \"CCXV\", \"CCXVI\", \"CCXVII\", \"CCXVIII\", \"CCXIX\", \\n    \"CCXX\", \"CCXXI\", \"CCXXII\", \"CCXXIII\", \"CCXXIV\", \"CCXXV\", \"CCXXVI\", \\n    \"CCXXVII\", \"CCXXVIII\", \"CCXXIX\", \"CCXXX\", \"CCXXXI\", \"CCXXXII\", \\n    \"CCXXXIII\", \"CCXXXIV\", \"CCXXXV\", \"CCXXXVI\", \"CCXXXVII\", \"CCXXXVIII\", \\n    \"CCXXXIX\", \"CCXL\", \"CCXLI\", \"CCXLII\", \"CCXLIII\", \"CCXLIV\", \"CCXLV\", \\n    \"CCXLVI\", \"CCXLVII\", \"CCXLVIII\", \"CCXLIX\", \"CCL\", \"CCLI\", \"CCLII\", \\n    \"CCLIII\", \"CCLIV\", \"CCLV\", \"CCLVI\", \"CCLVII\", \"CCLVIII\", \"CCLIX\", \\n    \"CCLX\", \"CCLXI\", \"CCLXII\", \"CCLXIII\", \"CCLXIV\", \"CCLXV\", \"CCLXVI\", \\n    \"CCLXVII\", \"CCLXVIII\", \"CCLXIX\", \"CCLXX\", \"CCLXXI\", \"CCLXXII\", \\n    \"CCLXXIII\", \"CCLXXIV\", \"CCLXXV\", \"CCLXXVI\", \"CCLXXVII\", \"CCLXXVIII\", \\n    \"CCLXXIX\", \"CCLXXX\", \"CCLXXXI\", \"CCLXXXII\", \"CCLXXXIII\", \"CCLXXXIV\", \\n    \"CCLXXXV\", \"CCLXXXVI\", \"CCLXXXVII\", \"CCLXXXVIII\", \"CCLXXXIX\", \"CCXC\", \\n    \"CCXCI\", \"CCXCII\", \"CCXCIII\", \"CCXCIV\", \"CCXCV\", \"CCXCVI\", \"CCXCVII\", \\n    \"CCXCVIII\", \"CCXCIX\", \"CCC\", \"CCCI\", \"CCCII\", \"CCCIII\", \"CCCIV\", \"CCCV\",\\n    \"CCCVI\", \"CCCVII\", \"CCCVIII\", \"CCCIX\", \"CCCX\", \"CCCXI\", \"CCCXII\", \\n    \"CCCXIII\", \"CCCXIV\", \"CCCXV\", \"CCCXVI\", \"CCCXVII\", \"CCCXVIII\", \"CCCXIX\", \\n    \"CCCXX\", \"CCCXXI\", \"CCCXXII\", \"CCCXXIII\", \"CCCXXIV\", \"CCCXXV\", \\n    \"CCCXXVI\", \"CCCXXVII\", \"CCCXXVIII\", \"CCCXXIX\", \"CCCXXX\", \"CCCXXXI\", \\n    \"CCCXXXII\", \"CCCXXXIII\", \"CCCXXXIV\", \"CCCXXXV\", \"CCCXXXVI\", \"CCCXXXVII\", \\n    \"CCCXXXVIII\", \"CCCXXXIX\", \"CCCXL\", \"CCCXLI\", \"CCCXLII\", \"CCCXLIII\", \\n    \"CCCXLIV\", \"CCCXLV\", \"CCCXLVI\", \"CCCXLVII\", \"CCCXLVIII\", \"CCCXLIX\", \\n    \"CCCL\", \"CCCLI\", \"CCCLII\", \"CCCLIII\", \"CCCLIV\", \"CCCLV\", \"CCCLVI\", \\n    \"CCCLVII\", \"CCCLVIII\", \"CCCLIX\", \"CCCLX\", \"CCCLXI\", \"CCCLXII\", \\n    \"CCCLXIII\", \"CCCLXIV\", \"CCCLXV\", \"CCCLXVI\", \"CCCLXVII\", \"CCCLXVIII\", \\n    \"CCCLXIX\", \"CCCLXX\", \"CCCLXXI\", \"CCCLXXII\", \"CCCLXXIII\", \"CCCLXXIV\", \\n    \"CCCLXXV\", \"CCCLXXVI\", \"CCCLXXVII\", \"CCCLXXVIII\", \"CCCLXXIX\", \"CCCLXXX\", \\n    \"CCCLXXXI\", \"CCCLXXXII\", \"CCCLXXXIII\", \"CCCLXXXIV\", \"CCCLXXXV\", \\n    \"CCCLXXXVI\", \"CCCLXXXVII\", \"CCCLXXXVIII\", \"CCCLXXXIX\", \"CCCXC\", \\n    \"CCCXCI\", \"CCCXCII\", \"CCCXCIII\", \"CCCXCIV\", \"CCCXCV\", \"CCCXCVI\", \\n    \"CCCXCVII\", \"CCCXCVIII\", \"CCCXCIX\", \"CD\", \"CDI\", \"CDII\", \"CDIII\", \\n    \"CDIV\", \"CDV\", \"CDVI\", \"CDVII\", \"CDVIII\", \"CDIX\", \"CDX\", \"CDXI\", \\n    \"CDXII\", \"CDXIII\", \"CDXIV\", \"CDXV\", \"CDXVI\", \"CDXVII\", \"CDXVIII\", \\n    \"CDXIX\", \"CDXX\", \"CDXXI\", \"CDXXII\", \"CDXXIII\", \"CDXXIV\", \"CDXXV\", \\n    \"CDXXVI\", \"CDXXVII\", \"CDXXVIII\", \"CDXXIX\", \"CDXXX\", \"CDXXXI\", \"CDXXXII\",\\n    \"CDXXXIII\", \"CDXXXIV\", \"CDXXXV\", \"CDXXXVI\", \"CDXXXVII\", \"CDXXXVIII\", \\n    \"CDXXXIX\", \"CDXL\", \"CDXLI\", \"CDXLII\", \"CDXLIII\", \"CDXLIV\", \"CDXLV\", \\n    \"CDXLVI\", \"CDXLVII\", \"CDXLVIII\", \"CDXLIX\", \"CDL\", \"CDLI\", \"CDLII\", \\n    \"CDLIII\", \"CDLIV\", \"CDLV\", \"CDLVI\", \"CDLVII\", \"CDLVIII\", \"CDLIX\", \\n    \"CDLX\", \"CDLXI\", \"CDLXII\", \"CDLXIII\", \"CDLXIV\", \"CDLXV\", \"CDLXVI\", \\n    \"CDLXVII\", \"CDLXVIII\", \"CDLXIX\", \"CDLXX\", \"CDLXXI\", \"CDLXXII\", \\n    \"CDLXXIII\", \"CDLXXIV\", \"CDLXXV\", \"CDLXXVI\", \"CDLXXVII\", \"CDLXXVIII\", \\n    \"CDLXXIX\", \"CDLXXX\", \"CDLXXXI\", \"CDLXXXII\", \"CDLXXXIII\", \"CDLXXXIV\", \\n    \"CDLXXXV\", \"CDLXXXVI\", \"CDLXXXVII\", \"CDLXXXVIII\", \"CDLXXXIX\", \"CDXC\", \\n    \"CDXCI\", \"CDXCII\", \"CDXCIII\", \"CDXCIV\", \"CDXCV\", \"CDXCVI\", \"CDXCVII\", \\n    \"CDXCVIII\", \"CDXCIX\", \"D\", \"DI\", \"DII\", \"DIII\", \"DIV\", \"DV\", \"DVI\", \\n    \"DVII\", \"DVIII\", \"DIX\", \"DX\", \"DXI\", \"DXII\", \"DXIII\", \"DXIV\", \"DXV\", \\n    \"DXVI\", \"DXVII\", \"DXVIII\", \"DXIX\", \"DXX\", \"DXXI\", \"DXXII\", \"DXXIII\", \\n    \"DXXIV\", \"DXXV\", \"DXXVI\", \"DXXVII\", \"DXXVIII\", \"DXXIX\", \"DXXX\", \"DXXXI\", \\n    \"DXXXII\", \"DXXXIII\", \"DXXXIV\", \"DXXXV\", \"DXXXVI\", \"DXXXVII\", \"DXXXVIII\", \\n    \"DXXXIX\", \"DXL\", \"DXLI\", \"DXLII\", \"DXLIII\", \"DXLIV\", \"DXLV\", \"DXLVI\", \\n    \"DXLVII\", \"DXLVIII\", \"DXLIX\", \"DL\", \"DLI\", \"DLII\", \"DLIII\", \"DLIV\", \\n    \"DLV\", \"DLVI\", \"DLVII\", \"DLVIII\", \"DLIX\", \"DLX\", \"DLXI\", \"DLXII\", \\n    \"DLXIII\", \"DLXIV\", \"DLXV\", \"DLXVI\", \"DLXVII\", \"DLXVIII\", \"DLXIX\", \\n    \"DLXX\", \"DLXXI\", \"DLXXII\", \"DLXXIII\", \"DLXXIV\", \"DLXXV\", \"DLXXVI\", \\n    \"DLXXVII\", \"DLXXVIII\", \"DLXXIX\", \"DLXXX\", \"DLXXXI\", \"DLXXXII\", \\n    \"DLXXXIII\", \"DLXXXIV\", \"DLXXXV\", \"DLXXXVI\", \"DLXXXVII\", \"DLXXXVIII\", \\n    \"DLXXXIX\", \"DXC\", \"DXCI\", \"DXCII\", \"DXCIII\", \"DXCIV\", \"DXCV\", \"DXCVI\", \\n    \"DXCVII\", \"DXCVIII\", \"DXCIX\", \"DC\", \"DCI\", \"DCII\", \"DCIII\", \"DCIV\", \\n    \"DCV\", \"DCVI\", \"DCVII\", \"DCVIII\", \"DCIX\", \"DCX\", \"DCXI\", \"DCXII\", \\n    \"DCXIII\", \"DCXIV\", \"DCXV\", \"DCXVI\", \"DCXVII\", \"DCXVIII\", \"DCXIX\", \\n    \"DCXX\", \"DCXXI\", \"DCXXII\", \"DCXXIII\", \"DCXXIV\", \"DCXXV\", \"DCXXVI\", \\n    \"DCXXVII\", \"DCXXVIII\", \"DCXXIX\", \"DCXXX\", \"DCXXXI\", \"DCXXXII\", \\n    \"DCXXXIII\", \"DCXXXIV\", \"DCXXXV\", \"DCXXXVI\", \"DCXXXVII\", \"DCXXXVIII\", \\n    \"DCXXXIX\", \"DCXL\", \"DCXLI\", \"DCXLII\", \"DCXLIII\", \"DCXLIV\", \"DCXLV\", \\n    \"DCXLVI\", \"DCXLVII\", \"DCXLVIII\", \"DCXLIX\", \"DCL\", \"DCLI\", \"DCLII\", \\n    \"DCLIII\", \"DCLIV\", \"DCLV\", \"DCLVI\", \"DCLVII\", \"DCLVIII\", \"DCLIX\", \\n    \"DCLX\", \"DCLXI\", \"DCLXII\", \"DCLXIII\", \"DCLXIV\", \"DCLXV\", \"DCLXVI\", \\n    \"DCLXVII\", \"DCLXVIII\", \"DCLXIX\", \"DCLXX\", \"DCLXXI\", \"DCLXXII\", \\n    \"DCLXXIII\", \"DCLXXIV\", \"DCLXXV\", \"DCLXXVI\", \"DCLXXVII\", \"DCLXXVIII\", \\n    \"DCLXXIX\", \"DCLXXX\", \"DCLXXXI\", \"DCLXXXII\", \"DCLXXXIII\", \"DCLXXXIV\", \\n    \"DCLXXXV\", \"DCLXXXVI\", \"DCLXXXVII\", \"DCLXXXVIII\", \"DCLXXXIX\", \"DCXC\", \\n    \"DCXCI\", \"DCXCII\", \"DCXCIII\", \"DCXCIV\", \"DCXCV\", \"DCXCVI\", \"DCXCVII\", \\n    \"DCXCVIII\", \"DCXCIX\", \"DCC\", \"DCCI\", \"DCCII\", \"DCCIII\", \"DCCIV\", \\n    \"DCCV\", \"DCCVI\", \"DCCVII\", \"DCCVIII\", \"DCCIX\", \"DCCX\", \"DCCXI\", \\n    \"DCCXII\", \"DCCXIII\", \"DCCXIV\", \"DCCXV\", \"DCCXVI\", \"DCCXVII\", \"DCCXVIII\",\\n    \"DCCXIX\", \"DCCXX\", \"DCCXXI\", \"DCCXXII\", \"DCCXXIII\", \"DCCXXIV\", \"DCCXXV\", \\n    \"DCCXXVI\", \"DCCXXVII\", \"DCCXXVIII\", \"DCCXXIX\", \"DCCXXX\", \"DCCXXXI\", \\n    \"DCCXXXII\", \"DCCXXXIII\", \"DCCXXXIV\", \"DCCXXXV\", \"DCCXXXVI\", \"DCCXXXVII\", \\n                        :\\n\\t\\t\\t            :   // Edited to reduce size of post, but you get the idea...\\n\\t\\t\\t\\t\\t\\t:\\n    \"MMMCMXCII\", \"MMMCMXCIII\", \"MMMCMXCIV\", \"MMMCMXCV\", \"MMMCMXCVI\",\\n    \"MMMCMXCVII\", \"MMMCMXCVIII\", \"MMMCMXCIX\"];\\n ```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\n\\nimpl Solution {\\n    pub fn int_to_roman(num: i32) -> String {\\n        NUMERALS[num as usize].to_string()\\n    }\\n}\\n\\nconst NUMERALS: [&str; 4000] = [\\n    \"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\",\"VIII\", \"IX\", \"X\", \"XI\", \\n    \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\",\\n    \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \\n    \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \\n    \"XXXVIII\", \"XXXIX\", \"XL\", \"XLI\", \"XLII\", \"XLIII\", \"XLIV\", \"XLV\", \"XLVI\",\\n    \"XLVII\", \"XLVIII\", \"XLIX\", \"L\", \"LI\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\",\\n    \"LVII\", \"LVIII\", \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \\n    \"LXVI\", \"LXVII\", \"LXVIII\", \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \\n    \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\",\\n    \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\",\\n    \"LXXXIX\", \"XC\", \"XCI\", \"XCII\", \"XCIII\", \"XCIV\", \"XCV\", \"XCVI\", \"XCVII\", \\n    \"XCVIII\", \"XCIX\", \"C\", \"CI\", \"CII\", \"CIII\", \"CIV\", \"CV\", \"CVI\", \"CVII\", \\n    \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \\n    \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\", \"CXXII\", \"CXXIII\", \"CXXIV\", \\n    \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\", \"CXXIX\", \"CXXX\", \"CXXXI\", \\n    \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\", \"CXXXVII\", \"CXXXVIII\",\\n    \"CXXXIX\", \"CXL\", \"CXLI\", \"CXLII\", \"CXLIII\", \"CXLIV\", \"CXLV\", \"CXLVI\", \\n    \"CXLVII\", \"CXLVIII\", \"CXLIX\", \"CL\", \"CLI\", \"CLII\", \"CLIII\", \"CLIV\", \\n    \"CLV\", \"CLVI\", \"CLVII\", \"CLVIII\", \"CLIX\", \"CLX\", \"CLXI\", \"CLXII\", \\n    \"CLXIII\", \"CLXIV\", \"CLXV\", \"CLXVI\", \"CLXVII\", \"CLXVIII\", \"CLXIX\", \\n    \"CLXX\", \"CLXXI\", \"CLXXII\", \"CLXXIII\", \"CLXXIV\", \"CLXXV\", \"CLXXVI\", \\n    \"CLXXVII\", \"CLXXVIII\", \"CLXXIX\", \"CLXXX\", \"CLXXXI\", \"CLXXXII\", \\n    \"CLXXXIII\", \"CLXXXIV\", \"CLXXXV\", \"CLXXXVI\", \"CLXXXVII\", \"CLXXXVIII\", \\n    \"CLXXXIX\", \"CXC\", \"CXCI\", \"CXCII\", \"CXCIII\", \"CXCIV\", \"CXCV\", \"CXCVI\", \\n    \"CXCVII\", \"CXCVIII\", \"CXCIX\", \"CC\", \"CCI\", \"CCII\", \"CCIII\", \"CCIV\", \\n    \"CCV\", \"CCVI\", \"CCVII\", \"CCVIII\", \"CCIX\", \"CCX\", \"CCXI\", \"CCXII\", \\n    \"CCXIII\", \"CCXIV\", \"CCXV\", \"CCXVI\", \"CCXVII\", \"CCXVIII\", \"CCXIX\", \\n    \"CCXX\", \"CCXXI\", \"CCXXII\", \"CCXXIII\", \"CCXXIV\", \"CCXXV\", \"CCXXVI\", \\n    \"CCXXVII\", \"CCXXVIII\", \"CCXXIX\", \"CCXXX\", \"CCXXXI\", \"CCXXXII\", \\n    \"CCXXXIII\", \"CCXXXIV\", \"CCXXXV\", \"CCXXXVI\", \"CCXXXVII\", \"CCXXXVIII\", \\n    \"CCXXXIX\", \"CCXL\", \"CCXLI\", \"CCXLII\", \"CCXLIII\", \"CCXLIV\", \"CCXLV\", \\n    \"CCXLVI\", \"CCXLVII\", \"CCXLVIII\", \"CCXLIX\", \"CCL\", \"CCLI\", \"CCLII\", \\n    \"CCLIII\", \"CCLIV\", \"CCLV\", \"CCLVI\", \"CCLVII\", \"CCLVIII\", \"CCLIX\", \\n    \"CCLX\", \"CCLXI\", \"CCLXII\", \"CCLXIII\", \"CCLXIV\", \"CCLXV\", \"CCLXVI\", \\n    \"CCLXVII\", \"CCLXVIII\", \"CCLXIX\", \"CCLXX\", \"CCLXXI\", \"CCLXXII\", \\n    \"CCLXXIII\", \"CCLXXIV\", \"CCLXXV\", \"CCLXXVI\", \"CCLXXVII\", \"CCLXXVIII\", \\n    \"CCLXXIX\", \"CCLXXX\", \"CCLXXXI\", \"CCLXXXII\", \"CCLXXXIII\", \"CCLXXXIV\", \\n    \"CCLXXXV\", \"CCLXXXVI\", \"CCLXXXVII\", \"CCLXXXVIII\", \"CCLXXXIX\", \"CCXC\", \\n    \"CCXCI\", \"CCXCII\", \"CCXCIII\", \"CCXCIV\", \"CCXCV\", \"CCXCVI\", \"CCXCVII\", \\n    \"CCXCVIII\", \"CCXCIX\", \"CCC\", \"CCCI\", \"CCCII\", \"CCCIII\", \"CCCIV\", \"CCCV\",\\n    \"CCCVI\", \"CCCVII\", \"CCCVIII\", \"CCCIX\", \"CCCX\", \"CCCXI\", \"CCCXII\", \\n    \"CCCXIII\", \"CCCXIV\", \"CCCXV\", \"CCCXVI\", \"CCCXVII\", \"CCCXVIII\", \"CCCXIX\", \\n    \"CCCXX\", \"CCCXXI\", \"CCCXXII\", \"CCCXXIII\", \"CCCXXIV\", \"CCCXXV\", \\n    \"CCCXXVI\", \"CCCXXVII\", \"CCCXXVIII\", \"CCCXXIX\", \"CCCXXX\", \"CCCXXXI\", \\n    \"CCCXXXII\", \"CCCXXXIII\", \"CCCXXXIV\", \"CCCXXXV\", \"CCCXXXVI\", \"CCCXXXVII\", \\n    \"CCCXXXVIII\", \"CCCXXXIX\", \"CCCXL\", \"CCCXLI\", \"CCCXLII\", \"CCCXLIII\", \\n    \"CCCXLIV\", \"CCCXLV\", \"CCCXLVI\", \"CCCXLVII\", \"CCCXLVIII\", \"CCCXLIX\", \\n    \"CCCL\", \"CCCLI\", \"CCCLII\", \"CCCLIII\", \"CCCLIV\", \"CCCLV\", \"CCCLVI\", \\n    \"CCCLVII\", \"CCCLVIII\", \"CCCLIX\", \"CCCLX\", \"CCCLXI\", \"CCCLXII\", \\n    \"CCCLXIII\", \"CCCLXIV\", \"CCCLXV\", \"CCCLXVI\", \"CCCLXVII\", \"CCCLXVIII\", \\n    \"CCCLXIX\", \"CCCLXX\", \"CCCLXXI\", \"CCCLXXII\", \"CCCLXXIII\", \"CCCLXXIV\", \\n    \"CCCLXXV\", \"CCCLXXVI\", \"CCCLXXVII\", \"CCCLXXVIII\", \"CCCLXXIX\", \"CCCLXXX\", \\n    \"CCCLXXXI\", \"CCCLXXXII\", \"CCCLXXXIII\", \"CCCLXXXIV\", \"CCCLXXXV\", \\n    \"CCCLXXXVI\", \"CCCLXXXVII\", \"CCCLXXXVIII\", \"CCCLXXXIX\", \"CCCXC\", \\n    \"CCCXCI\", \"CCCXCII\", \"CCCXCIII\", \"CCCXCIV\", \"CCCXCV\", \"CCCXCVI\", \\n    \"CCCXCVII\", \"CCCXCVIII\", \"CCCXCIX\", \"CD\", \"CDI\", \"CDII\", \"CDIII\", \\n    \"CDIV\", \"CDV\", \"CDVI\", \"CDVII\", \"CDVIII\", \"CDIX\", \"CDX\", \"CDXI\", \\n    \"CDXII\", \"CDXIII\", \"CDXIV\", \"CDXV\", \"CDXVI\", \"CDXVII\", \"CDXVIII\", \\n    \"CDXIX\", \"CDXX\", \"CDXXI\", \"CDXXII\", \"CDXXIII\", \"CDXXIV\", \"CDXXV\", \\n    \"CDXXVI\", \"CDXXVII\", \"CDXXVIII\", \"CDXXIX\", \"CDXXX\", \"CDXXXI\", \"CDXXXII\",\\n    \"CDXXXIII\", \"CDXXXIV\", \"CDXXXV\", \"CDXXXVI\", \"CDXXXVII\", \"CDXXXVIII\", \\n    \"CDXXXIX\", \"CDXL\", \"CDXLI\", \"CDXLII\", \"CDXLIII\", \"CDXLIV\", \"CDXLV\", \\n    \"CDXLVI\", \"CDXLVII\", \"CDXLVIII\", \"CDXLIX\", \"CDL\", \"CDLI\", \"CDLII\", \\n    \"CDLIII\", \"CDLIV\", \"CDLV\", \"CDLVI\", \"CDLVII\", \"CDLVIII\", \"CDLIX\", \\n    \"CDLX\", \"CDLXI\", \"CDLXII\", \"CDLXIII\", \"CDLXIV\", \"CDLXV\", \"CDLXVI\", \\n    \"CDLXVII\", \"CDLXVIII\", \"CDLXIX\", \"CDLXX\", \"CDLXXI\", \"CDLXXII\", \\n    \"CDLXXIII\", \"CDLXXIV\", \"CDLXXV\", \"CDLXXVI\", \"CDLXXVII\", \"CDLXXVIII\", \\n    \"CDLXXIX\", \"CDLXXX\", \"CDLXXXI\", \"CDLXXXII\", \"CDLXXXIII\", \"CDLXXXIV\", \\n    \"CDLXXXV\", \"CDLXXXVI\", \"CDLXXXVII\", \"CDLXXXVIII\", \"CDLXXXIX\", \"CDXC\", \\n    \"CDXCI\", \"CDXCII\", \"CDXCIII\", \"CDXCIV\", \"CDXCV\", \"CDXCVI\", \"CDXCVII\", \\n    \"CDXCVIII\", \"CDXCIX\", \"D\", \"DI\", \"DII\", \"DIII\", \"DIV\", \"DV\", \"DVI\", \\n    \"DVII\", \"DVIII\", \"DIX\", \"DX\", \"DXI\", \"DXII\", \"DXIII\", \"DXIV\", \"DXV\", \\n    \"DXVI\", \"DXVII\", \"DXVIII\", \"DXIX\", \"DXX\", \"DXXI\", \"DXXII\", \"DXXIII\", \\n    \"DXXIV\", \"DXXV\", \"DXXVI\", \"DXXVII\", \"DXXVIII\", \"DXXIX\", \"DXXX\", \"DXXXI\", \\n    \"DXXXII\", \"DXXXIII\", \"DXXXIV\", \"DXXXV\", \"DXXXVI\", \"DXXXVII\", \"DXXXVIII\", \\n    \"DXXXIX\", \"DXL\", \"DXLI\", \"DXLII\", \"DXLIII\", \"DXLIV\", \"DXLV\", \"DXLVI\", \\n    \"DXLVII\", \"DXLVIII\", \"DXLIX\", \"DL\", \"DLI\", \"DLII\", \"DLIII\", \"DLIV\", \\n    \"DLV\", \"DLVI\", \"DLVII\", \"DLVIII\", \"DLIX\", \"DLX\", \"DLXI\", \"DLXII\", \\n    \"DLXIII\", \"DLXIV\", \"DLXV\", \"DLXVI\", \"DLXVII\", \"DLXVIII\", \"DLXIX\", \\n    \"DLXX\", \"DLXXI\", \"DLXXII\", \"DLXXIII\", \"DLXXIV\", \"DLXXV\", \"DLXXVI\", \\n    \"DLXXVII\", \"DLXXVIII\", \"DLXXIX\", \"DLXXX\", \"DLXXXI\", \"DLXXXII\", \\n    \"DLXXXIII\", \"DLXXXIV\", \"DLXXXV\", \"DLXXXVI\", \"DLXXXVII\", \"DLXXXVIII\", \\n    \"DLXXXIX\", \"DXC\", \"DXCI\", \"DXCII\", \"DXCIII\", \"DXCIV\", \"DXCV\", \"DXCVI\", \\n    \"DXCVII\", \"DXCVIII\", \"DXCIX\", \"DC\", \"DCI\", \"DCII\", \"DCIII\", \"DCIV\", \\n    \"DCV\", \"DCVI\", \"DCVII\", \"DCVIII\", \"DCIX\", \"DCX\", \"DCXI\", \"DCXII\", \\n    \"DCXIII\", \"DCXIV\", \"DCXV\", \"DCXVI\", \"DCXVII\", \"DCXVIII\", \"DCXIX\", \\n    \"DCXX\", \"DCXXI\", \"DCXXII\", \"DCXXIII\", \"DCXXIV\", \"DCXXV\", \"DCXXVI\", \\n    \"DCXXVII\", \"DCXXVIII\", \"DCXXIX\", \"DCXXX\", \"DCXXXI\", \"DCXXXII\", \\n    \"DCXXXIII\", \"DCXXXIV\", \"DCXXXV\", \"DCXXXVI\", \"DCXXXVII\", \"DCXXXVIII\", \\n    \"DCXXXIX\", \"DCXL\", \"DCXLI\", \"DCXLII\", \"DCXLIII\", \"DCXLIV\", \"DCXLV\", \\n    \"DCXLVI\", \"DCXLVII\", \"DCXLVIII\", \"DCXLIX\", \"DCL\", \"DCLI\", \"DCLII\", \\n    \"DCLIII\", \"DCLIV\", \"DCLV\", \"DCLVI\", \"DCLVII\", \"DCLVIII\", \"DCLIX\", \\n    \"DCLX\", \"DCLXI\", \"DCLXII\", \"DCLXIII\", \"DCLXIV\", \"DCLXV\", \"DCLXVI\", \\n    \"DCLXVII\", \"DCLXVIII\", \"DCLXIX\", \"DCLXX\", \"DCLXXI\", \"DCLXXII\", \\n    \"DCLXXIII\", \"DCLXXIV\", \"DCLXXV\", \"DCLXXVI\", \"DCLXXVII\", \"DCLXXVIII\", \\n    \"DCLXXIX\", \"DCLXXX\", \"DCLXXXI\", \"DCLXXXII\", \"DCLXXXIII\", \"DCLXXXIV\", \\n    \"DCLXXXV\", \"DCLXXXVI\", \"DCLXXXVII\", \"DCLXXXVIII\", \"DCLXXXIX\", \"DCXC\", \\n    \"DCXCI\", \"DCXCII\", \"DCXCIII\", \"DCXCIV\", \"DCXCV\", \"DCXCVI\", \"DCXCVII\", \\n    \"DCXCVIII\", \"DCXCIX\", \"DCC\", \"DCCI\", \"DCCII\", \"DCCIII\", \"DCCIV\", \\n    \"DCCV\", \"DCCVI\", \"DCCVII\", \"DCCVIII\", \"DCCIX\", \"DCCX\", \"DCCXI\", \\n    \"DCCXII\", \"DCCXIII\", \"DCCXIV\", \"DCCXV\", \"DCCXVI\", \"DCCXVII\", \"DCCXVIII\",\\n    \"DCCXIX\", \"DCCXX\", \"DCCXXI\", \"DCCXXII\", \"DCCXXIII\", \"DCCXXIV\", \"DCCXXV\", \\n    \"DCCXXVI\", \"DCCXXVII\", \"DCCXXVIII\", \"DCCXXIX\", \"DCCXXX\", \"DCCXXXI\", \\n    \"DCCXXXII\", \"DCCXXXIII\", \"DCCXXXIV\", \"DCCXXXV\", \"DCCXXXVI\", \"DCCXXXVII\", \\n                        :\\n\\t\\t\\t            :   // Edited to reduce size of post, but you get the idea...\\n\\t\\t\\t\\t\\t\\t:\\n    \"MMMCMXCII\", \"MMMCMXCIII\", \"MMMCMXCIV\", \"MMMCMXCV\", \"MMMCMXCVI\",\\n    \"MMMCMXCVII\", \"MMMCMXCVIII\", \"MMMCMXCIX\"];\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 2018967,
                "title": "very-easy-c-solution-please-upvote",
                "content": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<int> in={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        vector<string> roman={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        string res=\"\";\\n        for(int i=0;i<(int)in.size();i++)\\n        {\\n            int count=num/in[i];\\n            while(count--)\\n            {\\n                res+=roman[i];\\n            }\\n            num=num%in[i];\\n        }\\n        return res;\\n    }\\n};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<int> in={1000,900,500,400,100,90,50,40,10,9,5,4,1}",
                "codeTag": "Java"
            },
            {
                "id": 1980870,
                "title": "java-c-python-javascript-kotlin-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "***Hello it would be my pleasure to introduce myself Darian.***\\n\\n<iframe src=\"https://leetcode.com/playground/6KqgMr3S/shared\" frameBorder=\"0\" width=\"1000\" height=\"1000\"></iframe>\\n\\n***Consider upvote if useful! Hopefully it can be used in your advantage!***\\n***Take care brother, peace, love!***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Kotlin"
                ],
                "code": "***Hello it would be my pleasure to introduce myself Darian.***\\n\\n<iframe src=\"https://leetcode.com/playground/6KqgMr3S/shared\" frameBorder=\"0\" width=\"1000\" height=\"1000\"></iframe>\\n\\n***Consider upvote if useful! Hopefully it can be used in your advantage!***\\n***Take care brother, peace, love!***",
                "codeTag": "Unknown"
            },
            {
                "id": 1847281,
                "title": "python-solution",
                "content": "Please Upvote\\n\\n```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        \\n        d = {1000: \\'M\\', 900: \\'CM\\', 500: \\'D\\', 400: \\'CD\\', 100: \\'C\\', 90: \\'XC\\', 50: \\'L\\', 40: \\'XL\\', 10: \\'X\\', 9: \\'IX\\', 5: \\'V\\', 4: \\'IV\\', 1: \\'I\\'}\\n        result = \\'\\'\\n        \\n        for k in d.keys():\\n            result += (num // k) * d[k]\\n            num %= k\\n                \\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        \\n        d = {1000: \\'M\\', 900: \\'CM\\', 500: \\'D\\', 400: \\'CD\\', 100: \\'C\\', 90: \\'XC\\', 50: \\'L\\', 40: \\'XL\\', 10: \\'X\\', 9: \\'IX\\', 5: \\'V\\', 4: \\'IV\\', 1: \\'I\\'}\\n        result = \\'\\'\\n        \\n        for k in d.keys():\\n            result += (num // k) * d[k]\\n            num %= k\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1759934,
                "title": "python3-solution-100-faster",
                "content": "**Solution - 1**\\n```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        M = [\"\", \"M\", \"MM\", \"MMM\"]\\n        C = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"]\\n        X = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"]\\n        I = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"]\\n        return M[num//1000] + C[(num%1000)//100] + X[(num%100)//10] + I[num%10]\\n```\\n\\n**Solution - 2**\\n```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        values = [\\'I\\',\\'V\\',\\'X\\',\\'L\\',\\'C\\',\\'D\\',\\'M\\',\\'\\']\\n        ans,i = \\'\\',0\\n        while num:\\n            digit = num%10\\n            if digit%5 == 4: ans = values[i] + values[i + 1 + int(digit==9)] + ans\\n            else: ans = values[i+1]*int(digit>=5) + values[i]*(digit%5) + ans\\n            num //= 10\\n            i += 2\\n        return ans\\n```\\n\\n**Solution - 3**\\n```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        values = [\\'I\\',\\'V\\',\\'X\\',\\'L\\',\\'C\\',\\'D\\',\\'M\\']\\n        ans,i = \\'\\',0\\n        while num:\\n            digit = num%10\\n            if digit == 4: ans = values[i] + values[i + 1] + ans\\n            elif digit == 9: ans = values[i] + values[i + 2] + ans\\n            elif digit >= 5: ans = values[i+1] + values[i]*(digit-5) + ans\\n            else: ans = values[i]*digit + ans\\n            num //= 10\\n            i += 2\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        M = [\"\", \"M\", \"MM\", \"MMM\"]\\n        C = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"]\\n        X = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"]\\n        I = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"]\\n        return M[num//1000] + C[(num%1000)//100] + X[(num%100)//10] + I[num%10]\\n```\n```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        values = [\\'I\\',\\'V\\',\\'X\\',\\'L\\',\\'C\\',\\'D\\',\\'M\\',\\'\\']\\n        ans,i = \\'\\',0\\n        while num:\\n            digit = num%10\\n            if digit%5 == 4: ans = values[i] + values[i + 1 + int(digit==9)] + ans\\n            else: ans = values[i+1]*int(digit>=5) + values[i]*(digit%5) + ans\\n            num //= 10\\n            i += 2\\n        return ans\\n```\n```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        values = [\\'I\\',\\'V\\',\\'X\\',\\'L\\',\\'C\\',\\'D\\',\\'M\\']\\n        ans,i = \\'\\',0\\n        while num:\\n            digit = num%10\\n            if digit == 4: ans = values[i] + values[i + 1] + ans\\n            elif digit == 9: ans = values[i] + values[i + 2] + ans\\n            elif digit >= 5: ans = values[i+1] + values[i]*(digit-5) + ans\\n            else: ans = values[i]*digit + ans\\n            num //= 10\\n            i += 2\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1410013,
                "title": "0-ms-faster-than-100-00-of-c-online-submissions-for-integer-to-roman",
                "content": "# Simple and elegant solution\\n```\\nstring intToRoman(int number) {\\n        int num[] = {1,4,5,9,10,40,50,90,100,400,500,900,1000};\\n    string sym[] = {\"I\",\"IV\",\"V\",\"IX\",\"X\",\"XL\",\"L\",\"XC\",\"C\",\"CD\",\"D\",\"CM\",\"M\"};\\n    int i=12;  \\n    int d;\\n    string ans=\"\";\\n    while(number>0)\\n    {\\n        d = number/num[i];\\n      number = number%num[i];\\n      while(d--)\\n      {\\n        ans+=sym[i];\\n      }\\n      i--;\\n    }\\n     return ans;   \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nstring intToRoman(int number) {\\n        int num[] = {1,4,5,9,10,40,50,90,100,400,500,900,1000};\\n    string sym[] = {\"I\",\"IV\",\"V\",\"IX\",\"X\",\"XL\",\"L\",\"XC\",\"C\",\"CD\",\"D\",\"CM\",\"M\"};\\n    int i=12;  \\n    int d;\\n    string ans=\"\";\\n    while(number>0)\\n    {\\n        d = number/num[i];\\n      number = number%num[i];\\n      while(d--)\\n      {\\n        ans+=sym[i];\\n      }\\n      i--;\\n    }\\n     return ans;   \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1354615,
                "title": "simple-java-solution-100-faster",
                "content": "``` class Solution {\\n    private static int[] keys = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};      \\n    private static String[] values = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n    \\n    public String intToRoman(int num) {\\n        StringBuilder s = new StringBuilder();\\n        int counter = 0;\\n        \\n        \\n        while(num > 0){\\n            if(num >= keys[counter]){\\n                s.append(values[counter]);\\n                num -= keys[counter];\\n            }\\n            else\\n                counter++;\\n        }\\n        \\n        return s.toString();\\n        \\n    }\\n}```",
                "solutionTags": [],
                "code": "``` class Solution {\\n    private static int[] keys = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};      \\n    private static String[] values = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n    \\n    public String intToRoman(int num) {\\n        StringBuilder s = new StringBuilder();\\n        int counter = 0;\\n        \\n        \\n        while(num > 0){\\n            if(num >= keys[counter]){\\n                s.append(values[counter]);\\n                num -= keys[counter];\\n            }\\n            else\\n                counter++;\\n        }\\n        \\n        return s.toString();\\n        \\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 1202412,
                "title": "easy-c-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        \\n        int numbers[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        string romans[] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        \\n        string res;\\n        \\n        for(int i=0; i<13; i++)\\n        {\\n            while(num >= numbers[i])\\n            {\\n                num -= numbers[i];\\n                res += romans[i];\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        \\n        int numbers[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        string romans[] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        \\n        string res;\\n        \\n        for(int i=0; i<13; i++)\\n        {\\n            while(num >= numbers[i])\\n            {\\n                num -= numbers[i];\\n                res += romans[i];\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 216081,
                "title": "swift-solution",
                "content": "class Solution {\\n    func intToRoman(_ num: Int) -> String {\\n        if num == 0 {\\n            return \"\"\\n        } else if num >= 1000 {\\n            return \"M\" + intToRoman(num - 1000)\\n        } else if num >= 900 {\\n            return \"CM\" + intToRoman(num - 900)\\n        } else if num >= 500 {\\n            return \"D\" + intToRoman(num - 500)\\n        } else if num >= 400 {\\n            return \"CD\" + intToRoman(num - 400)\\n        } else if num >= 100 {\\n            return \"C\" + intToRoman(num - 100)\\n        } else if num >= 90 {\\n            return \"XC\" + intToRoman(num - 90)\\n        } else if num >= 50 {\\n            return \"L\" + intToRoman(num - 50)\\n        } else if num >= 40 {\\n            return \"XL\" + intToRoman(num - 40)\\n        } else if num >= 10 {\\n            return \"X\" + intToRoman(num - 10)\\n        } else if num >= 9 {\\n            return \"IX\" + intToRoman(num - 9)\\n        } else if num >= 5 {\\n            return \"V\" + intToRoman(num - 5)\\n        } else if num >= 4 {\\n            return \"IV\" + intToRoman(num - 4)\\n        } else if num > 0 {\\n            return \"I\" + intToRoman(num - 1)\\n        }\\n        \\n        return \"\"\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    func intToRoman(_ num: Int) -> String {\\n        if num == 0 {\\n            return \"\"\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 188598,
                "title": "easy-to-understand-java-solution",
                "content": "```\\n  public String intToRoman(int num) {\\n        \\n        return convert(num,new String());\\n        \\n    }\\n    \\n   public String convert(int num, String res){\\n        \\n        if(num == 0) return res;\\n        else if(num >= 1000) return convert(num - 1000, res +\"M\");\\n        else if(num >= 900) return convert(num - 900, res +\"CM\");\\n        else if(num >= 500) return convert(num - 500, res +\"D\");\\n        else if(num >= 400) return convert(num - 400, res +\"CD\");\\n        else if(num >= 100) return convert(num - 100, res +\"C\");\\n        else if(num >= 90) return convert(num - 90, res +\"XC\");\\n        else if(num >= 50) return convert(num - 50, res +\"L\");\\n        else if(num >= 40) return convert(num - 40, res +\"XL\");\\n        else if(num >= 10) return convert(num - 10, res +\"X\");\\n        else if(num >= 9) return convert(num - 9, res +\"IX\");\\n        else if(num >= 5) return convert(num - 5, res +\"V\");\\n        else if(num >= 4) return convert(num - 4, res +\"IV\");\\n        else if(num == 3) return convert(num - 3, res +\"III\");\\n        else if(num == 2) return convert(num - 2, res +\"II\");\\n        else if(num == 1) return convert(num - 1, res +\"I\");\\n        \\n        return null;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  public String intToRoman(int num) {\\n        \\n        return convert(num,new String());\\n        \\n    }\\n    \\n   public String convert(int num, String res){\\n        \\n        if(num == 0) return res;\\n        else if(num >= 1000) return convert(num - 1000, res +\"M\");\\n        else if(num >= 900) return convert(num - 900, res +\"CM\");\\n        else if(num >= 500) return convert(num - 500, res +\"D\");\\n        else if(num >= 400) return convert(num - 400, res +\"CD\");\\n        else if(num >= 100) return convert(num - 100, res +\"C\");\\n        else if(num >= 90) return convert(num - 90, res +\"XC\");\\n        else if(num >= 50) return convert(num - 50, res +\"L\");\\n        else if(num >= 40) return convert(num - 40, res +\"XL\");\\n        else if(num >= 10) return convert(num - 10, res +\"X\");\\n        else if(num >= 9) return convert(num - 9, res +\"IX\");\\n        else if(num >= 5) return convert(num - 5, res +\"V\");\\n        else if(num >= 4) return convert(num - 4, res +\"IV\");\\n        else if(num == 3) return convert(num - 3, res +\"III\");\\n        else if(num == 2) return convert(num - 2, res +\"II\");\\n        else if(num == 1) return convert(num - 1, res +\"I\");\\n        \\n        return null;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 6388,
                "title": "my-java-solution",
                "content": "\\n\\n\\n        String res = \"\";\\n        String[] c = new String[]{\"I\",\"IV\",\"V\",\"IX\",\"X\",\"XL\",\"L\",\"XC\",\"C\",\"CD\",\"D\",\"CM\",\"M\"};\\n        int[] n = new int[]{1,4,5,9,10,40,50,90,100,400,500,900,1000};\\n        int i = 12;\\n        while(num > 0 && i>=0){\\n            if(num >= n[i]){\\n                res += c[i];\\n                num -= n[i];\\n            }else{\\n                i--;\\n            }\\n        }\\n        return res;",
                "solutionTags": [],
                "code": "\\n\\n\\n        String res = \"\";\\n        String[] c = new String[]{\"I\",\"IV\",\"V\",\"IX\",\"X\",\"XL\",\"L\",\"XC\",\"C\",\"CD\",\"D\",\"CM\",\"M\"};\\n        int[] n = new int[]{1,4,5,9,10,40,50,90,100,400,500,900,1000};\\n        int i = 12;\\n        while(num > 0 && i>=0){\\n            if(num >= n[i]){\\n                res += c[i];\\n                num -= n[i];\\n            }else{\\n                i--;\\n            }\\n        }\\n        return res;",
                "codeTag": "Unknown"
            },
            {
                "id": 6451,
                "title": "my-easy-understanding-solution",
                "content": "\\n    string intToRoman(int num) \\n    {   \\n        string s;  \\n    \\n        while (num > 0)\\n        {   \\n            if (num >= 1000) {s += \"M\"; num-=1000; continue;}\\n            if (num >= 900)  {s += \"CM\"; num-=900; continue;}\\n            if (num >= 500)  {s += \"D\"; num-=500; continue;}\\n            if (num >= 400)  {s += \"CD\"; num-=400; continue;}\\n            if (num >= 100)  {s += \"C\"; num-=100; continue;}\\n            if (num >= 90)   {s += \"XC\"; num-=90; continue;}\\n            if (num >= 50)   {s += \"L\"; num-=50; continue;}\\n            if (num >= 40)   {s += \"XL\"; num-=40; continue;}\\n            if (num >= 10)   {s += \"X\"; num-=10; continue;}\\n            if (num >= 9)    {s += \"IX\"; num-=9; continue;}\\n            if (num >= 5)    {s += \"V\"; num-=5; continue;}\\n            if (num >= 4)    {s += \"IV\"; num-=4; continue;}\\n            if (num == 3)    {s += \"III\"; num-=3; continue;}\\n            if (num == 2)    {s += \"II\"; num-=2; continue;}\\n            if (num == 1)    {s += \"I\"; num-=1; continue;}\\n        }   \\n    \\n        return s;\\n    }",
                "solutionTags": [],
                "code": "\\n    string intToRoman(int num) \\n    {   \\n        string s;  \\n    \\n        while (num > 0)\\n        {   \\n            if (num >= 1000) {s += \"M\"; num-=1000; continue;}\\n            if (num >= 900)  {s += \"CM\"; num-=900; continue;}\\n            if (num >= 500)  {s += \"D\"; num-=500; continue;}\\n            if (num >= 400)  {s += \"CD\"; num-=400; continue;}\\n            if (num >= 100)  {s += \"C\"; num-=100; continue;}\\n            if (num >= 90)   {s += \"XC\"; num-=90; continue;}\\n            if (num >= 50)   {s += \"L\"; num-=50; continue;}\\n            if (num >= 40)   {s += \"XL\"; num-=40; continue;}\\n            if (num >= 10)   {s += \"X\"; num-=10; continue;}\\n            if (num >= 9)    {s += \"IX\"; num-=9; continue;}\\n            if (num >= 5)    {s += \"V\"; num-=5; continue;}\\n            if (num >= 4)    {s += \"IV\"; num-=4; continue;}\\n            if (num == 3)    {s += \"III\"; num-=3; continue;}\\n            if (num == 2)    {s += \"II\"; num-=2; continue;}\\n            if (num == 1)    {s += \"I\"; num-=1; continue;}\\n        }   \\n    \\n        return s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3618408,
                "title": "beats-100-by-using-subtraction-method",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<string> v1={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\\n                           \"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        vector<int> v2={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        string res=\"\";\\n        for(int i=0; num>0; i++){\\n            while(num>=v2[i]){\\n                res=res+v1[i];\\n                num=num-v2[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<string> v1={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\\n                           \"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        vector<int> v2={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        string res=\"\";\\n        for(int i=0; num>0; i++){\\n            while(num>=v2[i]){\\n                res=res+v1[i];\\n                num=num-v2[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724994,
                "title": "java-without-extended-dictionary",
                "content": "```\\npublic String intToRoman(int number) {\\n        Map<Integer, Character> map = Map.of(1, \\'I\\', 5, \\'V\\', 10, \\'X\\', 50, \\'L\\', 100, \\'C\\', 500, \\'D\\', 1000, \\'M\\');\\n        StringBuilder roman = new StringBuilder();\\n\\n        int multiplier = 1;\\n        while (number > 0) {\\n            int digit = number % 10;\\n\\n            if (digit == 4 || digit == 9)\\n                roman.insert(0, \"\" + map.get(multiplier) + map.get((digit + 1) * multiplier));\\n            else\\n                roman.insert(0,  (digit >= 5 ? map.get(5 * multiplier) : \"\") + (map.get(multiplier).toString().repeat(digit >= 5 ? digit - 5 : digit)));\\n\\n            number = number / 10; multiplier *= 10;\\n        }\\n\\n        return roman.toString();\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String intToRoman(int number) {\\n        Map<Integer, Character> map = Map.of(1, \\'I\\', 5, \\'V\\', 10, \\'X\\', 50, \\'L\\', 100, \\'C\\', 500, \\'D\\', 1000, \\'M\\');\\n        StringBuilder roman = new StringBuilder();\\n\\n        int multiplier = 1;\\n        while (number > 0) {\\n            int digit = number % 10;\\n\\n            if (digit == 4 || digit == 9)\\n                roman.insert(0, \"\" + map.get(multiplier) + map.get((digit + 1) * multiplier));\\n            else\\n                roman.insert(0,  (digit >= 5 ? map.get(5 * multiplier) : \"\") + (map.get(multiplier).toString().repeat(digit >= 5 ? digit - 5 : digit)));\\n\\n            number = number / 10; multiplier *= 10;\\n        }\\n\\n        return roman.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2724574,
                "title": "go-simple-recursion",
                "content": "Please Upvote if you like the solution \\n\\n```\\nfunc intToRoman(num int) string {\\n    return getRoman(num, \"\")\\n}\\n\\nfunc getRoman(num int, roman string) string {\\n    if num == 0 {\\n        return roman\\n    }\\n    \\n    if num - 1000 >= 0 {\\n        return getRoman(num-1000, roman + \"M\")\\n    }\\n    \\n    if num - 900 >= 0 {\\n        return getRoman(num-900, roman + \"CM\")\\n    }\\n    \\n    if num - 500 >= 0 {\\n        return getRoman(num-500, roman + \"D\")\\n    }\\n    \\n    if num - 400 >= 0 {\\n        return getRoman(num-400, roman + \"CD\")\\n    }\\n    \\n    if num - 100 >= 0 {\\n        return getRoman(num-100, roman + \"C\")\\n    }\\n    \\n    if num - 90 >= 0 {\\n        return getRoman(num-90, roman + \"XC\")\\n    }\\n    \\n    if num - 50 >= 0 {\\n        return getRoman(num-50, roman + \"L\")\\n    }\\n    \\n    if num - 40 >= 0 {\\n        return getRoman(num-40, roman + \"XL\")\\n    }\\n    \\n    if num - 10 >= 0 {\\n        return getRoman(num-10, roman + \"X\")\\n    }\\n    \\n    if num - 9 >= 0 {\\n        return getRoman(num-9, roman + \"IX\")\\n    }\\n    \\n    if num - 5 >= 0 {\\n        return getRoman(num-5, roman + \"V\")\\n    }\\n    \\n    if num - 4 >= 0 {\\n        return getRoman(num-4, roman + \"IV\")\\n    }\\n    \\n    if num - 1 >= 0 {\\n        return getRoman(num-1, roman + \"I\")\\n    }\\n     \\n    return roman\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Recursion"
                ],
                "code": "```\\nfunc intToRoman(num int) string {\\n    return getRoman(num, \"\")\\n}\\n\\nfunc getRoman(num int, roman string) string {\\n    if num == 0 {\\n        return roman\\n    }\\n    \\n    if num - 1000 >= 0 {\\n        return getRoman(num-1000, roman + \"M\")\\n    }\\n    \\n    if num - 900 >= 0 {\\n        return getRoman(num-900, roman + \"CM\")\\n    }\\n    \\n    if num - 500 >= 0 {\\n        return getRoman(num-500, roman + \"D\")\\n    }\\n    \\n    if num - 400 >= 0 {\\n        return getRoman(num-400, roman + \"CD\")\\n    }\\n    \\n    if num - 100 >= 0 {\\n        return getRoman(num-100, roman + \"C\")\\n    }\\n    \\n    if num - 90 >= 0 {\\n        return getRoman(num-90, roman + \"XC\")\\n    }\\n    \\n    if num - 50 >= 0 {\\n        return getRoman(num-50, roman + \"L\")\\n    }\\n    \\n    if num - 40 >= 0 {\\n        return getRoman(num-40, roman + \"XL\")\\n    }\\n    \\n    if num - 10 >= 0 {\\n        return getRoman(num-10, roman + \"X\")\\n    }\\n    \\n    if num - 9 >= 0 {\\n        return getRoman(num-9, roman + \"IX\")\\n    }\\n    \\n    if num - 5 >= 0 {\\n        return getRoman(num-5, roman + \"V\")\\n    }\\n    \\n    if num - 4 >= 0 {\\n        return getRoman(num-4, roman + \"IV\")\\n    }\\n    \\n    if num - 1 >= 0 {\\n        return getRoman(num-1, roman + \"I\")\\n    }\\n     \\n    return roman\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2336437,
                "title": "easy-explanation-commented-c",
                "content": "Initially we need to store all the integer values which have specific roman values.\\nThen we will extract the key in sorted order (biggest to smallest) and check again and again if number is greater than the key then subtract the key from number and also add the roman in the answer.\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        // map is decreasing sorted by key\\n        map<int, string, greater<int>> m;\\n        m[1000] = \"M\";\\n        m[900] = \"CM\";\\n        m[500] = \"D\";\\n        m[400] = \"CD\";\\n        m[100] = \"C\";\\n        m[90] = \"XC\";\\n        m[50] = \"L\";\\n        m[40] = \"XL\";\\n        m[10] = \"X\";\\n        m[9] = \"IX\";\\n        m[5] = \"V\";\\n        m[4] = \"IV\";\\n        m[1] = \"I\";\\n        \\n        string ans = \"\";\\n\\t\\t// take pair from map\\n        for(auto p: m)\\n        {\\n            // if number is lesser or equal to key then add\\n            while(num >= p.first)\\n            {\\n                ans += p.second;\\n                num -= p.first;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        // map is decreasing sorted by key\\n        map<int, string, greater<int>> m;\\n        m[1000] = \"M\";\\n        m[900] = \"CM\";\\n        m[500] = \"D\";\\n        m[400] = \"CD\";\\n        m[100] = \"C\";\\n        m[90] = \"XC\";\\n        m[50] = \"L\";\\n        m[40] = \"XL\";\\n        m[10] = \"X\";\\n        m[9] = \"IX\";\\n        m[5] = \"V\";\\n        m[4] = \"IV\";\\n        m[1] = \"I\";\\n        \\n        string ans = \"\";\\n\\t\\t// take pair from map\\n        for(auto p: m)\\n        {\\n            // if number is lesser or equal to key then add\\n            while(num >= p.first)\\n            {\\n                ans += p.second;\\n                num -= p.first;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2162067,
                "title": "easy-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans;\\n        int val[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        string sym[] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        \\n        int i=0;\\n        while(num){\\n            \\n            while(val[i]<=num){\\n                num-=val[i];\\n                ans+=sym[i];\\n            }\\n            \\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Please Upvote and thank you**\\n\\n**Feel Free to ask questions**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans;\\n        int val[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        string sym[] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        \\n        int i=0;\\n        while(num){\\n            \\n            while(val[i]<=num){\\n                num-=val[i];\\n                ans+=sym[i];\\n            }\\n            \\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1371192,
                "title": "c-no-recursion",
                "content": "```\\nstring intToRoman(int num) {\\n     vector<string> ones ={\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        vector<string>tens = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        vector<string>hundreds = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        vector<string>thousand = {\"\",\"M\",\"MM\",\"MMM\"};\\n        return thousand[num/1000]+hundreds[num%1000/100]+tens[num%100/10]+ones[num%10];\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring intToRoman(int num) {\\n     vector<string> ones ={\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        vector<string>tens = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        vector<string>hundreds = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        vector<string>thousand = {\"\",\"M\",\"MM\",\"MMM\"};\\n        return thousand[num/1000]+hundreds[num%1000/100]+tens[num%100/10]+ones[num%10];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1316412,
                "title": "simple-javascript-solution-beats-99-5",
                "content": "```\\n// 124ms 99.5%, 44MB 97.8%\\nconst symbolToValue = {\\n    \"M\" : 1000,\\n    \"CM\": 900,\\n    \"D\" : 500,\\n    \"CD\": 400,\\n    \"C\" : 100,\\n    \"XC\": 90,\\n    \"L\" : 50,\\n    \"XL\": 40,\\n    \"X\" : 10,\\n    \"IX\": 9,\\n    \"V\" : 5,\\n    \"IV\": 4,\\n    \"I\" : 1,\\n}\\n\\nvar intToRoman = function(num) {\\n    let finalStr = \"\";\\n    for (s in symbolToValue){\\n        const v = symbolToValue[s];\\n        while (num >= v){\\n            num -= v;\\n            finalStr += s;\\n        }    \\n    }\\n    return finalStr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// 124ms 99.5%, 44MB 97.8%\\nconst symbolToValue = {\\n    \"M\" : 1000,\\n    \"CM\": 900,\\n    \"D\" : 500,\\n    \"CD\": 400,\\n    \"C\" : 100,\\n    \"XC\": 90,\\n    \"L\" : 50,\\n    \"XL\": 40,\\n    \"X\" : 10,\\n    \"IX\": 9,\\n    \"V\" : 5,\\n    \"IV\": 4,\\n    \"I\" : 1,\\n}\\n\\nvar intToRoman = function(num) {\\n    let finalStr = \"\";\\n    for (s in symbolToValue){\\n        const v = symbolToValue[s];\\n        while (num >= v){\\n            num -= v;\\n            finalStr += s;\\n        }    \\n    }\\n    return finalStr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 812398,
                "title": "java-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        String units[]={\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        String tens[]={\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        String hundreds[]={\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        String thousands[]={\"\",\"M\",\"MM\",\"MMM\"};\\n        \\n        return thousands[num/1000]+\\n                hundreds[(num%1000)/100]+\\n                tens[(num%100)/10]+\\n                units[num%10];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        String units[]={\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        String tens[]={\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        String hundreds[]={\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        String thousands[]={\"\",\"M\",\"MM\",\"MMM\"};\\n        \\n        return thousands[num/1000]+\\n                hundreds[(num%1000)/100]+\\n                tens[(num%100)/10]+\\n                units[num%10];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 757248,
                "title": "c-solution",
                "content": "```\\nstring intToRoman(int num) {\\n\\tvector<string> roman {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n\\tvector<int> no {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n\\tstring ans = \"\";\\n\\tfor(int i=0; num != 0; i++){\\n\\t\\twhile(num >= no[i]){\\n\\t\\t\\tnum -= no[i];\\n\\t\\t\\tans += roman[i];\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstring intToRoman(int num) {\\n\\tvector<string> roman {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n\\tvector<int> no {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n\\tstring ans = \"\";\\n\\tfor(int i=0; num != 0; i++){\\n\\t\\twhile(num >= no[i]){\\n\\t\\t\\tnum -= no[i];\\n\\t\\t\\tans += roman[i];\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 657354,
                "title": "java-beatiful-solution",
                "content": "```\\n    public String intToRoman(int num) {\\n        StringBuilder sb = new StringBuilder();\\n        String[] romanNums = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        int[] arabNums = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        int index = 0;\\n        \\n        while (num > 0) {\\n            int mult = num / arabNums[index];\\n            \\n            if (mult > 0) {\\n                num %= arabNums[index];\\n                sb.append(romanNums[index].repeat(mult));\\n                // sb.append(String.join(\"\", Collections.nCopies(mult, romanNums[index])));\\n            }\\n            \\n            index++;\\n        }\\n        \\n        return sb.toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String intToRoman(int num) {\\n        StringBuilder sb = new StringBuilder();\\n        String[] romanNums = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        int[] arabNums = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        int index = 0;\\n        \\n        while (num > 0) {\\n            int mult = num / arabNums[index];\\n            \\n            if (mult > 0) {\\n                num %= arabNums[index];\\n                sb.append(romanNums[index].repeat(mult));\\n                // sb.append(String.join(\"\", Collections.nCopies(mult, romanNums[index])));\\n            }\\n            \\n            index++;\\n        }\\n        \\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 657129,
                "title": "my-c-solution-without-hardcoding-all-the-numerals",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    string intToRoman(int num)\\n    {       \\n        string res = \"\";\\n        string s[] = {\"I\", \"X\", \"C\", \"M\", \"V\", \"L\", \"D\", \"\"};\\n        int i = 0;\\n        while (num)\\n        {\\n            switch(num % 10)\\n            {\\n                case 1: res.insert(0, s[i]); break;\\n                case 2: res.insert(0, s[i] + s[i]); break;\\n                case 3: res.insert(0, s[i] + s[i] + s[i]); break;\\n                case 4: res.insert(0, s[i] + s[i + 4]); break;\\n                case 5: res.insert(0, s[i + 4]); break;\\n                case 6: res.insert(0, s[i + 4] + s[i]); break;\\n                case 7: res.insert(0, s[i + 4] + s[i] + s[i]); break;\\n                case 8: res.insert(0, s[i + 4] + s[i] + s[i] + s[i]); break;\\n                case 9: res.insert(0, s[i] + s[i + 1]); break;  \\n            }\\n            num /= 10;\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    string intToRoman(int num)\\n    {       \\n        string res = \"\";\\n        string s[] = {\"I\", \"X\", \"C\", \"M\", \"V\", \"L\", \"D\", \"\"};\\n        int i = 0;\\n        while (num)\\n        {\\n            switch(num % 10)\\n            {\\n                case 1: res.insert(0, s[i]); break;\\n                case 2: res.insert(0, s[i] + s[i]); break;\\n                case 3: res.insert(0, s[i] + s[i] + s[i]); break;\\n                case 4: res.insert(0, s[i] + s[i + 4]); break;\\n                case 5: res.insert(0, s[i + 4]); break;\\n                case 6: res.insert(0, s[i + 4] + s[i]); break;\\n                case 7: res.insert(0, s[i + 4] + s[i] + s[i]); break;\\n                case 8: res.insert(0, s[i + 4] + s[i] + s[i] + s[i]); break;\\n                case 9: res.insert(0, s[i] + s[i + 1]); break;  \\n            }\\n            num /= 10;\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 389923,
                "title": "faster-than-98-6-javascript",
                "content": "```\\nvar intToRoman = function(num) {\\n    var digit, r = \\'\\';\\n    var convert = (digit, tens, fives, ones) => {\\n        if(digit === 9) { r = r.concat(ones + tens); }\\n        else if(digit > 5) { r = r.concat(fives + ones.repeat(digit % 5)); }\\n        else if(digit === 5) { r = r.concat(fives); }\\n        else if(digit === 4) { r = r.concat(ones + fives); }\\n        else if(digit > 0) { r = r.concat(ones.repeat(digit)) }\\n    };\\n    \\n    if(num > 999) { convert(Math.floor(num/1000), \\'\\', \\'\\', \\'M\\');\\n        num = Math.floor(num%1000);\\n    }\\n    if(num > 99) { convert(Math.floor(num/100), \\'M\\', \\'D\\', \\'C\\');\\n        num = Math.floor(num%100);\\n    }\\n    if(num > 9) { convert(Math.floor(num/10), \\'C\\', \\'L\\', \\'X\\');\\n        num = Math.floor(num%10);\\n    }\\n    convert(num, \\'X\\', \\'V\\', \\'I\\');\\n    return r;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar intToRoman = function(num) {\\n    var digit, r = \\'\\';\\n    var convert = (digit, tens, fives, ones) => {\\n        if(digit === 9) { r = r.concat(ones + tens); }\\n        else if(digit > 5) { r = r.concat(fives + ones.repeat(digit % 5)); }\\n        else if(digit === 5) { r = r.concat(fives); }\\n        else if(digit === 4) { r = r.concat(ones + fives); }\\n        else if(digit > 0) { r = r.concat(ones.repeat(digit)) }\\n    };\\n    \\n    if(num > 999) { convert(Math.floor(num/1000), \\'\\', \\'\\', \\'M\\');\\n        num = Math.floor(num%1000);\\n    }\\n    if(num > 99) { convert(Math.floor(num/100), \\'M\\', \\'D\\', \\'C\\');\\n        num = Math.floor(num%100);\\n    }\\n    if(num > 9) { convert(Math.floor(num/10), \\'C\\', \\'L\\', \\'X\\');\\n        num = Math.floor(num%10);\\n    }\\n    convert(num, \\'X\\', \\'V\\', \\'I\\');\\n    return r;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 342992,
                "title": "java-solution-beats-100-100",
                "content": "```\\npublic String intToRoman(int num) {        \\n\\tString[] romans = new String[]{\"M\", \"CM\", \"D\", \"CD\", \\n\\t\\t\\t\\t\\t\\t\\t\\t   \"C\", \"XC\", \"L\", \"XL\",\\n\\t\\t\\t\\t\\t\\t\\t\\t  \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n\\tint[] numbers = new int[]{1000, 900, 500, 400,\\n\\t\\t\\t\\t\\t\\t\\t 100, 90, 50, 40,\\n\\t\\t\\t\\t\\t\\t\\t 10, 9, 5, 4, 1};\\n\\tStringBuilder romanRes = new StringBuilder();\\n\\tfor (int i = 0; i < romans.length; i++) {\\n\\t\\tif (num == 0) break;\\n\\t\\tint count = num/numbers[i];\\n\\t\\twhile (count > 0) {\\n\\t\\t\\tromanRes.append(romans[i]);\\n\\t\\t\\tcount--;\\n\\t\\t}\\n\\t\\tnum = num % numbers[i];\\n\\t}\\n\\n\\treturn romanRes.toString();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic String intToRoman(int num) {        \\n\\tString[] romans = new String[]{\"M\", \"CM\", \"D\", \"CD\", \\n\\t\\t\\t\\t\\t\\t\\t\\t   \"C\", \"XC\", \"L\", \"XL\",\\n\\t\\t\\t\\t\\t\\t\\t\\t  \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n\\tint[] numbers = new int[]{1000, 900, 500, 400,\\n\\t\\t\\t\\t\\t\\t\\t 100, 90, 50, 40,\\n\\t\\t\\t\\t\\t\\t\\t 10, 9, 5, 4, 1};\\n\\tStringBuilder romanRes = new StringBuilder();\\n\\tfor (int i = 0; i < romans.length; i++) {\\n\\t\\tif (num == 0) break;\\n\\t\\tint count = num/numbers[i];\\n\\t\\twhile (count > 0) {\\n\\t\\t\\tromanRes.append(romans[i]);\\n\\t\\t\\tcount--;\\n\\t\\t}\\n\\t\\tnum = num % numbers[i];\\n\\t}\\n\\n\\treturn romanRes.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 279026,
                "title": "c-solution-12ms-and-7-4mb-beats-100",
                "content": "```\\n#define ROMAN_SUM_TYPE_COUNT 13\\n\\nstruct RomanItem\\n{\\n\\tint interSum;\\n    char *romanStr;\\n};\\n\\nchar* intToRoman(int num) {\\n    char *answer = (char *)malloc(sizeof(char) * 50);\\n    answer[0] = \\'\\\\0\\';\\n    int quotient = 0;\\n    struct RomanItem romanArray[ROMAN_SUM_TYPE_COUNT] = {{1, \"I\"}, {4, \"IV\"}, {5, \"V\"}, {9, \"IX\"}, {10, \"X\"}, {40, \"XL\"}, {50, \"L\"}, {90, \"XC\"}, {100, \"C\"}, {400, \"CD\"}, {500, \"D\"},\\n        {900, \"CM\"}, {1000, \"M\"}};\\n    \\n    for (int i = ROMAN_SUM_TYPE_COUNT - 1; i >= 0; i--)\\n    {\\n        quotient = num/romanArray[i].interSum;\\n        while(quotient > 0)\\n        {\\n            strcat(answer, romanArray[i].romanStr);\\n            quotient--;\\n        }\\n        num = num % romanArray[i].interSum;\\n    }\\n    return answer;\\n}\\n```\\n\\ni had tried to solve this solution without enumeration but it\\'s more clearer and eaiser by enumeration...",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define ROMAN_SUM_TYPE_COUNT 13\\n\\nstruct RomanItem\\n{\\n\\tint interSum;\\n    char *romanStr;\\n};\\n\\nchar* intToRoman(int num) {\\n    char *answer = (char *)malloc(sizeof(char) * 50);\\n    answer[0] = \\'\\\\0\\';\\n    int quotient = 0;\\n    struct RomanItem romanArray[ROMAN_SUM_TYPE_COUNT] = {{1, \"I\"}, {4, \"IV\"}, {5, \"V\"}, {9, \"IX\"}, {10, \"X\"}, {40, \"XL\"}, {50, \"L\"}, {90, \"XC\"}, {100, \"C\"}, {400, \"CD\"}, {500, \"D\"},\\n        {900, \"CM\"}, {1000, \"M\"}};\\n    \\n    for (int i = ROMAN_SUM_TYPE_COUNT - 1; i >= 0; i--)\\n    {\\n        quotient = num/romanArray[i].interSum;\\n        while(quotient > 0)\\n        {\\n            strcat(answer, romanArray[i].romanStr);\\n            quotient--;\\n        }\\n        num = num % romanArray[i].interSum;\\n    }\\n    return answer;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 256455,
                "title": "a-top-1-10-concise-c-solution",
                "content": "The speed of this solution varies depending on run, but it\\'s always in top 10%.\\nNote: order by key in descending order in \\'foreach\\' is not required by this runtime \\u2014 it follows declaration order.\\n\\n```\\npublic class Solution \\n{\\n    public string IntToRoman(int num) \\n    {\\n        var result = new StringBuilder();\\n        var map = new Dictionary<int, string>\\n        {\\n            { 1000, \"M\" },\\n            { 900, \"CM\" },\\n            { 500, \"D\" },\\n            { 400, \"CD\" },\\n            { 100, \"C\" },\\n            { 90, \"XC\" },\\n            { 50, \"L\" },\\n            { 40, \"XL\" },\\n            { 10, \"X\" },\\n            { 9, \"IX\" },\\n            { 5, \"V\" },\\n            { 4, \"IV\" },\\n            { 1, \"I\" },\\n        };\\n        \\n        foreach (var kv in map)  \\n        {\\n            while (num >= kv.Key)\\n            {\\n                num -= kv.Key;\\n                result.Append(kv.Value);\\n            }\\n        }\\n        \\n        return result.ToString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public string IntToRoman(int num) \\n    {\\n        var result = new StringBuilder();\\n        var map = new Dictionary<int, string>\\n        {\\n            { 1000, \"M\" },\\n            { 900, \"CM\" },\\n            { 500, \"D\" },\\n            { 400, \"CD\" },\\n            { 100, \"C\" },\\n            { 90, \"XC\" },\\n            { 50, \"L\" },\\n            { 40, \"XL\" },\\n            { 10, \"X\" },\\n            { 9, \"IX\" },\\n            { 5, \"V\" },\\n            { 4, \"IV\" },\\n            { 1, \"I\" },\\n        };\\n        \\n        foreach (var kv in map)  \\n        {\\n            while (num >= kv.Key)\\n            {\\n                num -= kv.Key;\\n                result.Append(kv.Value);\\n            }\\n        }\\n        \\n        return result.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 196579,
                "title": "javascript-98",
                "content": "```\\n/**\\n * @param {number} num\\n * @return {string}\\n */\\n\\n /* value, str mapping */\\n const mapping = [\\n    [1000, \\'M\\'], [900, \\'CM\\'], [500, \\'D\\'], [400, \\'CD\\'], [100, \\'C\\'], [90, \\'XC\\'], [50, \\'L\\'], [40, \\'XL\\'], [10, \\'X\\'], [9, \\'IX\\'], [5, \\'V\\'], [4, \\'IV\\'], [1, \\'I\\']\\n];\\n\\nvar intToRoman = function(num) {\\n    let str = \\'\\';\\n\\n    for (let i = 0; i < mapping.length; i++) {\\n        const [val, char] = mapping[i];\\n\\n        if (num >= val) {\\n            while (num >= val) {\\n                num -= val;\\n                str += char;\\n            }\\n        }\\n    }\\n\\n    return str;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} num\\n * @return {string}\\n */\\n\\n /* value, str mapping */\\n const mapping = [\\n    [1000, \\'M\\'], [900, \\'CM\\'], [500, \\'D\\'], [400, \\'CD\\'], [100, \\'C\\'], [90, \\'XC\\'], [50, \\'L\\'], [40, \\'XL\\'], [10, \\'X\\'], [9, \\'IX\\'], [5, \\'V\\'], [4, \\'IV\\'], [1, \\'I\\']\\n];\\n\\nvar intToRoman = function(num) {\\n    let str = \\'\\';\\n\\n    for (let i = 0; i < mapping.length; i++) {\\n        const [val, char] = mapping[i];\\n\\n        if (num >= val) {\\n            while (num >= val) {\\n                num -= val;\\n                str += char;\\n            }\\n        }\\n    }\\n\\n    return str;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4059438,
                "title": "best-o-1-solution",
                "content": "# Approach 1\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector <string> s = {\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"};\\n        vector <int> value = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000};\\n        string ans = \"\";\\n        int i = value.size() - 1; \\n        while (i >= 0 ) {\\n            if (num < value[i]) {\\n                i--;\\n            } else {\\n                ans += s[i];\\n                num -= value[i];\\n            }    \\n        }\\n        return ans;\\n};\\n```\\n\\n# Approach 2\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector <string> ones = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\\n        vector <string> tens = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\\n        vector <string> hrns = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n        vector <string> ths = {\"\", \"M\", \"MM\", \"MMM\"};\\n        \\n        return ths[num/1000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector <string> s = {\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"};\\n        vector <int> value = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000};\\n        string ans = \"\";\\n        int i = value.size() - 1; \\n        while (i >= 0 ) {\\n            if (num < value[i]) {\\n                i--;\\n            } else {\\n                ans += s[i];\\n                num -= value[i];\\n            }    \\n        }\\n        return ans;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector <string> ones = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\\n        vector <string> tens = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\\n        vector <string> hrns = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n        vector <string> ths = {\"\", \"M\", \"MM\", \"MMM\"};\\n        \\n        return ths[num/1000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3722581,
                "title": "take-this-simple-sol-with-python",
                "content": "# Code\\n```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        roman_mapping = {\\n            1000: \\'M\\',\\n            900: \\'CM\\',\\n            500: \\'D\\',\\n            400: \\'CD\\',\\n            100: \\'C\\',\\n            90: \\'XC\\',\\n            50: \\'L\\',\\n            40: \\'XL\\',\\n            10: \\'X\\',\\n            9: \\'IX\\',\\n            5: \\'V\\',\\n            4: \\'IV\\',\\n            1: \\'I\\'\\n        }\\n        result = \"\"\\n        for value, symbol in roman_mapping.items():\\n            while num >= value:\\n                result += symbol\\n                num -= value\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        roman_mapping = {\\n            1000: \\'M\\',\\n            900: \\'CM\\',\\n            500: \\'D\\',\\n            400: \\'CD\\',\\n            100: \\'C\\',\\n            90: \\'XC\\',\\n            50: \\'L\\',\\n            40: \\'XL\\',\\n            10: \\'X\\',\\n            9: \\'IX\\',\\n            5: \\'V\\',\\n            4: \\'IV\\',\\n            1: \\'I\\'\\n        }\\n        result = \"\"\\n        for value, symbol in roman_mapping.items():\\n            while num >= value:\\n                result += symbol\\n                num -= value\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423552,
                "title": "simple-c-solution-comments-added",
                "content": "```\\nclass Solution {\\npublic:\\n    // creating int to roman map.\\n    unordered_map<int,char>itor={\\n        {1,\\'I\\'},{5,\\'V\\'},{10,\\'X\\'},{50,\\'L\\'},{100,\\'C\\'},{500,\\'D\\'},{1000,\\'M\\'}\\n    };\\n    // reverse the string.\\n    void reverse(string &s)\\n    {\\n        int i=0,j=s.length()-1;\\n        while(i<j)\\n        {\\n            swap(s[i],s[j]);\\n            i++;j--;\\n        }\\n    }\\n    // main function.\\n    string intToRoman(int num) {\\n        \\n        string res=\"\";\\n        //Multiplier to determine once,tens... places\\n        int mul=1;\\n        while(num)\\n        {\\n            int x=num%10; //last digit\\n            num/=10; //removing last digit from num.\\n            if(x==0) //if zero then move to next digit (with increasing multiplier).\\n            {\\n                mul*=10;\\n                continue;\\n            }\\n            // we have two cases 4 and 9 then make b=5 || 10.\\n            int b=-1;\\n            if(x==4)\\n                b=5;\\n            else if(x==9)\\n                b=10;\\n            \\n            if(b==-1) //if last digit is not 4||9 then simply add I. for 3= III\\n            {\\n                while(x)\\n                {\\n                    if(x==5)\\n                    {\\n                        res+=itor[5*mul];\\n                        x-=5;\\n                    }\\n                    else\\n                    {\\n                        res+=itor[1*mul];\\n                        x-=1;\\n                    }\\n                }\\n            }\\n            else // if(last digit is 4||9) then add IV or IX to res.\\n            {\\n                res+=itor[b*mul];\\n                res+=itor[1*mul];\\n            }\\n            mul*=10;\\n        }\\n        //we traversed from lsb to msb so reverse the string.\\n        reverse(res);\\n        return res;\\n        // remember if 4 comes then we add VI to res so that reverse will be IV.\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // creating int to roman map.\\n    unordered_map<int,char>itor={\\n        {1,\\'I\\'},{5,\\'V\\'},{10,\\'X\\'},{50,\\'L\\'},{100,\\'C\\'},{500,\\'D\\'},{1000,\\'M\\'}\\n    };\\n    // reverse the string.\\n    void reverse(string &s)\\n    {\\n        int i=0,j=s.length()-1;\\n        while(i<j)\\n        {\\n            swap(s[i],s[j]);\\n            i++;j--;\\n        }\\n    }\\n    // main function.\\n    string intToRoman(int num) {\\n        \\n        string res=\"\";\\n        //Multiplier to determine once,tens... places\\n        int mul=1;\\n        while(num)\\n        {\\n            int x=num%10; //last digit\\n            num/=10; //removing last digit from num.\\n            if(x==0) //if zero then move to next digit (with increasing multiplier).\\n            {\\n                mul*=10;\\n                continue;\\n            }\\n            // we have two cases 4 and 9 then make b=5 || 10.\\n            int b=-1;\\n            if(x==4)\\n                b=5;\\n            else if(x==9)\\n                b=10;\\n            \\n            if(b==-1) //if last digit is not 4||9 then simply add I. for 3= III\\n            {\\n                while(x)\\n                {\\n                    if(x==5)\\n                    {\\n                        res+=itor[5*mul];\\n                        x-=5;\\n                    }\\n                    else\\n                    {\\n                        res+=itor[1*mul];\\n                        x-=1;\\n                    }\\n                }\\n            }\\n            else // if(last digit is 4||9) then add IV or IX to res.\\n            {\\n                res+=itor[b*mul];\\n                res+=itor[1*mul];\\n            }\\n            mul*=10;\\n        }\\n        //we traversed from lsb to msb so reverse the string.\\n        reverse(res);\\n        return res;\\n        // remember if 4 comes then we add VI to res so that reverse will be IV.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2366255,
                "title": "c-simple-and-clean-solution",
                "content": "Please Upvote if it helped you !!!\\nHappy Coding :)\\n```\\nstring intToRoman(int num) \\n    {\\n        string answer=\"\";\\n        string ones[]={\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        string tens[]={\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        string hundreds[] ={\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        string thousands[]={\"\",\"M\",\"MM\",\"MMM\"};\\n        answer=thousands[num/1000]+hundreds[(num%1000)/100]+tens[(num%100)/10]+ones[num%10];\\n        return answer;\\n    }\\n```\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring intToRoman(int num) \\n    {\\n        string answer=\"\";\\n        string ones[]={\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        string tens[]={\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        string hundreds[] ={\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        string thousands[]={\"\",\"M\",\"MM\",\"MMM\"};\\n        answer=thousands[num/1000]+hundreds[(num%1000)/100]+tens[(num%100)/10]+ones[num%10];\\n        return answer;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1924307,
                "title": "java-intuitive-easy-to-understand-and-remember-solution-100-faster-fully-extensible-too",
                "content": "There are two solutions in this post. The second approach is based on the first approach. \\nThe second approach supports adding new symbols or loading them in runtime without changing the code, one important aspect in code design. (e.g. S.O.L.I.D)\\n\\nThe main idea is to get each digit from left to right of the input `num`, convert each digit to Roman numeral(s) according to the Substraction rules and Mappings at the bottom of the post, and combine them as the final result.\\n\\nFor example: the mappings below are examples for [1,10).\\n\\n```\\n1  -> I\\n2  -> II\\n3  -> III\\n4  -> IV (not IIII)\\n5  -> V\\n6  -> VI\\n7  -> VII\\n8  -> VIII\\n9  -> IX (not VIIII)\\n```\\nThe mappings above are coded in the method `intToRoman` below, with \"I\", \"V\", \"X\" passed as arguments for the case of [1,10).\\n\\t`intToRoman(rs, num % 10, \"I\", \"V\", \"X\"); //get 4 in 1234`\\n\\nThe same principle applies to tens, hundreds, and thousands when a single digit is considered and mapped to its respective Roman symbols. \\n\\nSee the mappings at the bottom of the post for tens, hundreds, and thousands.\\n\\nThe solution below is intuitive and easy to understand and remember, which is what matters during interviews.\\n\\n\\n```\\nclass Solution {\\n\\tpublic String intToRoman(int num) {\\n\\t\\tStringBuilder rs = new StringBuilder();\\n\\t\\tintToRoman(rs, num / 1000, \"M\", \"\", \"\"); //get 1 in 1234\\n\\t\\tintToRoman(rs, num / 100 % 10, \"C\", \"D\", \"M\"); //get 2 in 1234\\n\\t\\tintToRoman(rs, num / 10 % 10, \"X\", \"L\", \"C\");  //get 3 in 1234\\n\\t\\tintToRoman(rs, num % 10, \"I\", \"V\", \"X\"); //get 4 in 1234\\n\\t\\treturn rs.toString();\\n\\t}\\n\\n //Comments are an example of [1,10)\\n  private void intToRoman(StringBuilder sb, int num, String one, String five, String ten) {\\n\\t\\tif (1 <= num) {\\n\\t\\t\\tif (num < 4) {\\n\\t\\t\\t\\tsb.append(one.repeat(num)); //this is I, or II, or III, one could be I, X C, M depending on whether it is under tens, tens, hundreds, or thousands\\n\\t\\t\\t} else if (num < 5) { // num >= 4 && num < 5)\\n\\t\\t\\t\\tsb.append(one).append(five); //this is IV\\n\\t\\t\\t} else if (num == 5) {\\n\\t\\t\\t\\tsb.append(five); //this V\\n\\t\\t\\t} else if (num < 9) { // num > 5 && num < 9\\n\\t\\t\\t\\tsb.append(five).append(one.repeat(num - 5)); //this is VI, or VII, or VIII\\n\\t\\t\\t} else { // num >= 9 && num < 10\\n\\t\\t\\t\\tsb.append(one).append(ten); //this is IX\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```\\n\\nHope it helps.\\n\\nPlease upvote if it does.\\n\\nFor completeness, below are the references\\n**The Substraction Rules:**\\n```\\n There are six instances where subtraction is used:\\nI can be placed before V (5) and X (10) to make 4 and 9. \\nX can be placed before L (50) and C (100) to make 40 and 90. \\nC can be placed before D (500) and M (1000) to make 400 and 900.\\n```\\n**The Mappings:**\\n```\\n(\\'I\\', 1)\\n(\\'V\\', 5)\\n(\\'X\\', 10)\\n(\\'L\\', 50)\\n(\\'C\\', 100)\\n(\\'D\\', 500)\\n(\\'M\\', 1000)\\n```\\n\\nExamples\\n```\\n3 -> III\\n58- > LVIII\\n1994 -> MCMXCIV\\n```\\nScore (the score is not constant for some reason)\\n![image](https://assets.leetcode.com/users/images/bef342b3-9f4d-4769-8315-5cc924e5c8ff_1649363126.5775585.jpeg)\\n\\n**Follow Up**\\nThe benefit of this method is fully extensible. If it has to support larger number over the current limit, new mappings can be added in `map` variable, even during runtime, the rest of the code remains unchanged.\\n\\nFor example, adding new symbols or loading them in runtime is like below:\\n   \\n   `itr.map.add(new String[] { \"M\", \"\", \"\" });`\\n   \\nThis is the important and bonus point if asked during an interview.\\n\\n```\\nclass Solution {\\n\\n\\tpublic static List<String[]> map = new ArrayList<String[]>();//public for runtime call\\n\\tstatic {\\n\\t\\tmap.add(new String[] { \"I\", \"V\", \"X\" });\\n\\t\\tmap.add(new String[] { \"X\", \"L\", \"C\" });\\n\\t\\tmap.add(new String[] { \"C\", \"D\", \"M\" });\\n\\t\\tmap.add(new String[] { \"M\", \"\", \"\" });\\n\\t}\\n\\n\\tpublic String intToRoman(int num) {\\n\\t\\tStringBuilder rs = new StringBuilder();\\n\\t\\tint n = map.size();\\n\\t\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\t\\tintToRoman(rs, num / ((int) Math.pow(10, i)) % 10, map.get(i)[0], map.get(i)[1], map.get(i)[2]);\\n\\t\\t}\\n\\t\\treturn rs.toString();\\n\\t}\\n\\n\\tprivate void intToRoman(StringBuilder sb, int num, String one, String five, String ten) {\\n\\t\\tif (1 <= num) {\\n\\t\\t\\tif (num < 4) {\\n\\t\\t\\t\\tsb.append(one.repeat(num));\\n\\t\\t\\t} else if (num < 5) { // num >= 4 && num < 5)\\n\\t\\t\\t\\tsb.append(one).append(five);\\n\\t\\t\\t} else if (num == 5) {\\n\\t\\t\\t\\tsb.append(five);\\n\\t\\t\\t} else if (num < 9) { // num > 5 && num < 9\\n\\t\\t\\t\\tsb.append(five).append(one.repeat(num - 5));\\n\\t\\t\\t} else { // num >= 9 && num < 10\\n\\t\\t\\t\\tsb.append(one).append(ten);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```\\nPlease upvote if it helps.\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n1  -> I\\n2  -> II\\n3  -> III\\n4  -> IV (not IIII)\\n5  -> V\\n6  -> VI\\n7  -> VII\\n8  -> VIII\\n9  -> IX (not VIIII)\\n```\n```\\nclass Solution {\\n\\tpublic String intToRoman(int num) {\\n\\t\\tStringBuilder rs = new StringBuilder();\\n\\t\\tintToRoman(rs, num / 1000, \"M\", \"\", \"\"); //get 1 in 1234\\n\\t\\tintToRoman(rs, num / 100 % 10, \"C\", \"D\", \"M\"); //get 2 in 1234\\n\\t\\tintToRoman(rs, num / 10 % 10, \"X\", \"L\", \"C\");  //get 3 in 1234\\n\\t\\tintToRoman(rs, num % 10, \"I\", \"V\", \"X\"); //get 4 in 1234\\n\\t\\treturn rs.toString();\\n\\t}\\n\\n //Comments are an example of [1,10)\\n  private void intToRoman(StringBuilder sb, int num, String one, String five, String ten) {\\n\\t\\tif (1 <= num) {\\n\\t\\t\\tif (num < 4) {\\n\\t\\t\\t\\tsb.append(one.repeat(num)); //this is I, or II, or III, one could be I, X C, M depending on whether it is under tens, tens, hundreds, or thousands\\n\\t\\t\\t} else if (num < 5) { // num >= 4 && num < 5)\\n\\t\\t\\t\\tsb.append(one).append(five); //this is IV\\n\\t\\t\\t} else if (num == 5) {\\n\\t\\t\\t\\tsb.append(five); //this V\\n\\t\\t\\t} else if (num < 9) { // num > 5 && num < 9\\n\\t\\t\\t\\tsb.append(five).append(one.repeat(num - 5)); //this is VI, or VII, or VIII\\n\\t\\t\\t} else { // num >= 9 && num < 10\\n\\t\\t\\t\\tsb.append(one).append(ten); //this is IX\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```\n```\\n There are six instances where subtraction is used:\\nI can be placed before V (5) and X (10) to make 4 and 9. \\nX can be placed before L (50) and C (100) to make 40 and 90. \\nC can be placed before D (500) and M (1000) to make 400 and 900.\\n```\n```\\n(\\'I\\', 1)\\n(\\'V\\', 5)\\n(\\'X\\', 10)\\n(\\'L\\', 50)\\n(\\'C\\', 100)\\n(\\'D\\', 500)\\n(\\'M\\', 1000)\\n```\n```\\n3 -> III\\n58- > LVIII\\n1994 -> MCMXCIV\\n```\n```\\nclass Solution {\\n\\n\\tpublic static List<String[]> map = new ArrayList<String[]>();//public for runtime call\\n\\tstatic {\\n\\t\\tmap.add(new String[] { \"I\", \"V\", \"X\" });\\n\\t\\tmap.add(new String[] { \"X\", \"L\", \"C\" });\\n\\t\\tmap.add(new String[] { \"C\", \"D\", \"M\" });\\n\\t\\tmap.add(new String[] { \"M\", \"\", \"\" });\\n\\t}\\n\\n\\tpublic String intToRoman(int num) {\\n\\t\\tStringBuilder rs = new StringBuilder();\\n\\t\\tint n = map.size();\\n\\t\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\t\\tintToRoman(rs, num / ((int) Math.pow(10, i)) % 10, map.get(i)[0], map.get(i)[1], map.get(i)[2]);\\n\\t\\t}\\n\\t\\treturn rs.toString();\\n\\t}\\n\\n\\tprivate void intToRoman(StringBuilder sb, int num, String one, String five, String ten) {\\n\\t\\tif (1 <= num) {\\n\\t\\t\\tif (num < 4) {\\n\\t\\t\\t\\tsb.append(one.repeat(num));\\n\\t\\t\\t} else if (num < 5) { // num >= 4 && num < 5)\\n\\t\\t\\t\\tsb.append(one).append(five);\\n\\t\\t\\t} else if (num == 5) {\\n\\t\\t\\t\\tsb.append(five);\\n\\t\\t\\t} else if (num < 9) { // num > 5 && num < 9\\n\\t\\t\\t\\tsb.append(five).append(one.repeat(num - 5));\\n\\t\\t\\t} else { // num >= 9 && num < 10\\n\\t\\t\\t\\tsb.append(one).append(ten);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1872499,
                "title": "c-java-solution-greedy",
                "content": "**Intuition**\\nGreedily always subtract the maximal roman number equivalent value from ```num```.\\n\\n**Complexity**\\n- Time: O(1)\\n- Space: O(1)\\n\\n**Implementation**\\n- C#\\n```\\npublic class Solution {\\n    public string IntToRoman(int num) {\\n        \\n        if(num < 1)\\n            throw new ArgumentException(\"Invaid Input.\");\\n        \\n        string[] roman = new string[]{\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        int[] nums = new int[]{1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        \\n        string res = \"\";\\n        int i = 0;\\n        \\n        while(num > 0)\\n        {\\n            while(num >= nums[i])\\n            {\\n                res += roman[i];\\n                num -= nums[i];\\n            }            \\n            i++;  \\n        }\\n\\n        return res;\\n    }\\n}\\n```\\n\\n- Java\\n```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        \\n        String[] roman = new String[]{\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        int[] nums = new int[]{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        \\n        String res = \"\";\\n        int i = 0;\\n        while(num > 0)\\n        {\\n            while(num >= nums[i])\\n            {\\n                res += roman[i];\\n                num -= nums[i];\\n            }\\n            i++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```num```\n```\\npublic class Solution {\\n    public string IntToRoman(int num) {\\n        \\n        if(num < 1)\\n            throw new ArgumentException(\"Invaid Input.\");\\n        \\n        string[] roman = new string[]{\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        int[] nums = new int[]{1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        \\n        string res = \"\";\\n        int i = 0;\\n        \\n        while(num > 0)\\n        {\\n            while(num >= nums[i])\\n            {\\n                res += roman[i];\\n                num -= nums[i];\\n            }            \\n            i++;  \\n        }\\n\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        \\n        String[] roman = new String[]{\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        int[] nums = new int[]{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        \\n        String res = \"\";\\n        int i = 0;\\n        while(num > 0)\\n        {\\n            while(num >= nums[i])\\n            {\\n                res += roman[i];\\n                num -= nums[i];\\n            }\\n            i++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1799449,
                "title": "clear-c-solution-6-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        int integer[13]={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        string roman[13]={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        string res=\"\";\\n        for(int i=0;i<13;i++){\\n            while(num>=integer[i]){\\n                res+=roman[i];\\n                num-=integer[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        int integer[13]={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        string roman[13]={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        string res=\"\";\\n        for(int i=0;i<13;i++){\\n            while(num>=integer[i]){\\n                res+=roman[i];\\n                num-=integer[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1776923,
                "title": "go-simple-solution",
                "content": "```   \\nfunc intToRoman(num int) string {\\n    symbol := []string{\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"}\\n    value := []int{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}\\n    \\n    result := \"\"\\n    \\n    for num > 0{\\n        for i := range value{\\n            if num >= value[i]{\\n                result += symbol[i] \\n                num -= value[i]\\n                break\\n            }\\n        }\\n    }\\n    return result\\n    \\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```   \\nfunc intToRoman(num int) string {\\n    symbol := []string{\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"}\\n    value := []int{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}\\n    \\n    result := \"\"\\n    \\n    for num > 0{\\n        for i := range value{\\n            if num >= value[i]{\\n                result += symbol[i] \\n                num -= value[i]\\n                break\\n            }\\n        }\\n    }\\n    return result\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1644959,
                "title": "optimised-solution-3ms-38-3mb",
                "content": "class Solution {\\n\\n    public String intToRoman(int num) {\\n       StringBuilder result = new StringBuilder();\\n        int[] div = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        String[] roman = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        for (int i = 0; i < div.length;) {\\n            if (num >= div[i]) {\\n                result.append(roman[i]);\\n                num -= div[i];\\n            } \\n            else i++;\\n        }\\n        \\n        return result.toString();  \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n\\n    public String intToRoman(int num) {\\n       StringBuilder result = new StringBuilder();\\n        int[] div = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}",
                "codeTag": "Java"
            },
            {
                "id": 1511574,
                "title": "cpp-solution-easy-to-understand",
                "content": "**Please upvote if you like the solution** \\n\\nCode ->\\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) \\n    {\\n        string ans;\\nstring symbol[] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        int val[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        \\n        for(int i=0; num != 0; i++)\\n        {\\n            while(num >= val[i])\\n            {\\n                num -= val[i];\\n                ans += symbol[i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) \\n    {\\n        string ans;\\nstring symbol[] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        int val[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        \\n        for(int i=0; num != 0; i++)\\n        {\\n            while(num >= val[i])\\n            {\\n                num -= val[i];\\n                ans += symbol[i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1448993,
                "title": "python-easiest-dictionary-solution",
                "content": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        translation = {\\n            \\'M\\': 1000,\\n            \\'CM\\': 900,\\n            \\'D\\': 500,\\n            \\'CD\\': 400,\\n            \\'C\\': 100,\\n            \\'XC\\': 90,\\n            \\'L\\': 50,\\n            \\'XL\\': 40,\\n            \\'X\\': 10,\\n            \\'IX\\': 9,\\n            \\'V\\': 5,\\n            \\'IV\\': 4,\\n            \\'I\\': 1,\\n        }\\n        out = \\'\\'\\n        for s,n in translation.items():\\n            out += num // n * s\\n            num %= n\\n        \\n        return out\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        translation = {\\n            \\'M\\': 1000,\\n            \\'CM\\': 900,\\n            \\'D\\': 500,\\n            \\'CD\\': 400,\\n            \\'C\\': 100,\\n            \\'XC\\': 90,\\n            \\'L\\': 50,\\n            \\'XL\\': 40,\\n            \\'X\\': 10,\\n            \\'IX\\': 9,\\n            \\'V\\': 5,\\n            \\'IV\\': 4,\\n            \\'I\\': 1,\\n        }\\n        out = \\'\\'\\n        for s,n in translation.items():\\n            out += num // n * s\\n            num %= n\\n        \\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1396382,
                "title": "python-95-faster-easy-solution",
                "content": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        roman_dict = {\"M\": 1000, \"CM\": 900, \"D\": 500, \"CD\": 400, \"C\": 100,\\n                     \"XC\": 90, \"L\": 50, \"XL\": 40, \"X\": 10, \"IX\": 9, \"V\": 5,\\n                     \"IV\": 4, \"I\": 1}\\n        output = \"\"\\n        while num >= 1:\\n            for key in roman_dict.keys():\\n                if num - roman_dict[key] >= 0:\\n                    output += key\\n                    num -= roman_dict[key]\\n                    break\\n        return output\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        roman_dict = {\"M\": 1000, \"CM\": 900, \"D\": 500, \"CD\": 400, \"C\": 100,\\n                     \"XC\": 90, \"L\": 50, \"XL\": 40, \"X\": 10, \"IX\": 9, \"V\": 5,\\n                     \"IV\": 4, \"I\": 1}\\n        output = \"\"\\n        while num >= 1:\\n            for key in roman_dict.keys():\\n                if num - roman_dict[key] >= 0:\\n                    output += key\\n                    num -= roman_dict[key]\\n                    break\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343815,
                "title": "c-solution-simple-short-and-clear",
                "content": "```\\nstring intToRoman(int num)\\n    {\\n        string symbol[13] = {\"I\",\"IV\",\"V\",\"IX\",\"X\",\"XL\",\"L\",\"XC\",\"C\",\"CD\",\"D\",\"CM\",\"M\"};\\n        int number[13] = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000}; \\n        int i = 12;\\n        string ans = \"\";\\n        \\n        while(num > 0)\\n        {\\n            int count = num / number[i];\\n            num = num % number[i];\\n            \\n            while(count--)\\n            {\\n                ans = ans + symbol[i];\\n            }\\n            \\n            i--;\\n        }\\n        \\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "```\\nstring intToRoman(int num)\\n    {\\n        string symbol[13] = {\"I\",\"IV\",\"V\",\"IX\",\"X\",\"XL\",\"L\",\"XC\",\"C\",\"CD\",\"D\",\"CM\",\"M\"};\\n        int number[13] = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000}; \\n        int i = 12;\\n        string ans = \"\";\\n        \\n        while(num > 0)\\n        {\\n            int count = num / number[i];\\n            num = num % number[i];\\n            \\n            while(count--)\\n            {\\n                ans = ans + symbol[i];\\n            }\\n            \\n            i--;\\n        }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1250878,
                "title": "easy-python-logic",
                "content": "Instead of the dictionary you can also use two lists.\\n```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d={\\n            1000:\\'M\\',\\n            900:\\'CM\\',\\n            500:\\'D\\',\\n            400:\\'CD\\',\\n            100:\\'C\\',\\n            90:\\'XC\\',\\n            50:\\'L\\',\\n            40:\\'XL\\',\\n            10:\\'X\\',\\n            9:\\'IX\\',\\n            5:\\'V\\',\\n            4:\\'IV\\',\\n            1:\\'I\\'\\n        }\\n        s=\"\"\\n        while num!=0:\\n            for i in d.keys():\\n                if num>=i:\\n                    s+=d[i]\\n                    num-=i\\n                    break\\n        return s",
                "solutionTags": [],
                "code": "class Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d={\\n            1000:\\'M\\',\\n            900:\\'CM\\',\\n            500:\\'D\\',\\n            400:\\'CD\\',\\n            100:\\'C\\',\\n            90:\\'XC\\',\\n            50:\\'L\\',\\n            40:\\'XL\\',\\n            10:\\'X\\',\\n            9:\\'IX\\',\\n            5:\\'V\\',\\n            4:\\'IV\\',\\n            1:\\'I\\'\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1210718,
                "title": "c-upper-bound-clean-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        \\n        map<int, string> mp = {{1,\"I\"}, \\n                               {5,\"V\"}, \\n                               {10,\"X\"}, \\n                               {50,\"L\"}, \\n                               {100,\"C\"}, \\n                               {500,\"D\"}, \\n                               {1000,\"M\"}, \\n                               {4,\"IV\"}, \\n                               {9,\"IX\"}, \\n                               {40,\"XL\"},\\n                               {90,\"XC\"},\\n                               {400,\"CD\"},\\n                               {900,\"CM\"}};   \\n        string ans;\\n        while(num > 0){\\n            auto it = --mp.upper_bound(num);\\n            num -= (it->first);\\n            ans += (it->second);\\n        }\\n        return ans;      \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        \\n        map<int, string> mp = {{1,\"I\"}, \\n                               {5,\"V\"}, \\n                               {10,\"X\"}, \\n                               {50,\"L\"}, \\n                               {100,\"C\"}, \\n                               {500,\"D\"}, \\n                               {1000,\"M\"}, \\n                               {4,\"IV\"}, \\n                               {9,\"IX\"}, \\n                               {40,\"XL\"},\\n                               {90,\"XC\"},\\n                               {400,\"CD\"},\\n                               {900,\"CM\"}};   \\n        string ans;\\n        while(num > 0){\\n            auto it = --mp.upper_bound(num);\\n            num -= (it->first);\\n            ans += (it->second);\\n        }\\n        return ans;      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1184992,
                "title": "python3-simple-and-easy-to-understand-solution-using-dictionary",
                "content": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d = {1000: \\'M\\', 900: \\'CM\\', 500: \\'D\\', 400: \\'CD\\', 100: \\'C\\', 90: \\'XC\\', 50: \\'L\\', 40: \\'XL\\', 10: \\'X\\', 9: \\'IX\\', 5: \\'V\\', 4: \\'IV\\', 1: \\'I\\'}\\n        s = \\'\\'\\n        for i in d.keys():\\n            s += (num//i)*d[i]\\n            num %= i\\n        return s\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d = {1000: \\'M\\', 900: \\'CM\\', 500: \\'D\\', 400: \\'CD\\', 100: \\'C\\', 90: \\'XC\\', 50: \\'L\\', 40: \\'XL\\', 10: \\'X\\', 9: \\'IX\\', 5: \\'V\\', 4: \\'IV\\', 1: \\'I\\'}\\n        s = \\'\\'\\n        for i in d.keys():\\n            s += (num//i)*d[i]\\n            num %= i\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1103918,
                "title": "c-simple-and-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<int> values{1,4,5,9,10,40,50,90,100,400,500,900,1000};\\n        vector<string> roman{\"I\",\"IV\",\"V\",\"IX\",\"X\",\"XL\",\"L\",\"XC\",\"C\",\"CD\",\"D\",\"CM\",\"M\"};\\n        int idx=roman.size()-1;\\n        \\n        string ans;\\n        while(num>0){\\n            while(num<values[idx])\\n                idx--;\\n            int count=num/values[idx];\\n            num=num-count*values[idx];\\n            while(count--){\\n                ans+=roman[idx];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Time Complexity:** \\nO(1) as num is limited to 3999 only. \\nO(n) if num is very very large and we need add \"M\" to string multiple times (Not given in constraints).\\n\\nWhy O(1) ? \\nReason - In worst case it will take constant(3) calls for some values[i] and value size is also constant to 13. \\nSo runtime will be < 13 * 3 only => *O(39) ~ O(1)*\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<int> values{1,4,5,9,10,40,50,90,100,400,500,900,1000};\\n        vector<string> roman{\"I\",\"IV\",\"V\",\"IX\",\"X\",\"XL\",\"L\",\"XC\",\"C\",\"CD\",\"D\",\"CM\",\"M\"};\\n        int idx=roman.size()-1;\\n        \\n        string ans;\\n        while(num>0){\\n            while(num<values[idx])\\n                idx--;\\n            int count=num/values[idx];\\n            num=num-count*values[idx];\\n            while(count--){\\n                ans+=roman[idx];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1103010,
                "title": "clean-correct-python-solution",
                "content": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        \\n        vals = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ]\\n        romans = [ \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" ]\\n        \\n        res=\\'\\'\\n        \\n        for i,v in enumerate(vals):\\n            \\n            res += (num//v) * romans[i];\\n            num %= v\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        \\n        vals = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ]\\n        romans = [ \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" ]\\n        \\n        res=\\'\\'\\n        \\n        for i,v in enumerate(vals):\\n            \\n            res += (num//v) * romans[i];\\n            num %= v\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 625791,
                "title": "golang-8ms",
                "content": "```go\\nimport \"strings\"\\n\\ntype node struct {\\n    val int\\n    s string\\n}\\n\\nvar romanNodes = []node{\\n    {1000, \"M\"},\\n    {900, \"CM\"},\\n    {500, \"D\"},\\n    {400, \"CD\"},\\n    {100, \"C\"},\\n    {90, \"XC\"},\\n    {50, \"L\"},\\n    {40, \"XL\"},\\n    {10, \"X\"},\\n    {9, \"IX\"},\\n    {5, \"V\"},\\n    {4, \"IV\"},\\n    {1, \"I\"},\\n}\\n\\nfunc intToRoman(num int) string {\\n    sb := strings.Builder{}\\n    \\n    for _, n := range romanNodes {\\n        for num >= n.val {\\n            sb.WriteString(n.s)\\n            num -= n.val\\n        }   \\n    }\\n    \\n    return sb.String()\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nimport \"strings\"\\n\\ntype node struct {\\n    val int\\n    s string\\n}\\n\\nvar romanNodes = []node{\\n    {1000, \"M\"},\\n    {900, \"CM\"},\\n    {500, \"D\"},\\n    {400, \"CD\"},\\n    {100, \"C\"},\\n    {90, \"XC\"},\\n    {50, \"L\"},\\n    {40, \"XL\"},\\n    {10, \"X\"},\\n    {9, \"IX\"},\\n    {5, \"V\"},\\n    {4, \"IV\"},\\n    {1, \"I\"},\\n}\\n\\nfunc intToRoman(num int) string {\\n    sb := strings.Builder{}\\n    \\n    for _, n := range romanNodes {\\n        for num >= n.val {\\n            sb.WriteString(n.s)\\n            num -= n.val\\n        }   \\n    }\\n    \\n    return sb.String()\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 544197,
                "title": "easy-java-solution-self-explanatory",
                "content": "class Solution {\\n    public String intToRoman(int num) {\\n    int[] values = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n     String[] romanLiterals = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n    StringBuilder roman = new StringBuilder();\\n        for(int i=0;i<values.length;i++){\\n            while(num>=values[i]){\\n                roman.append(romanLiterals[i]);\\n                    num-=values[i];\\n            }\\n            \\n        }\\n        return roman.toString();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String intToRoman(int num) {\\n    int[] values = {1000,900,500,400,100,90,50,40,10,9,5,4,1}",
                "codeTag": "Java"
            },
            {
                "id": 318386,
                "title": "java-4-ms-faster-than-69-85-36-1-mb-less-than-99-98",
                "content": "```\\nclass Solution {\\n    public String intToRoman(int n) {\\n       String M[] = {\"\", \"M\", \"MM\", \"MMM\"};\\n        String C[] = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n        String X[] = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\\n        String I[] = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\\n        return M[n / 1000] + C[(n / 100) % 10] + X[(n / 10) % 10] + I[n % 10];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String intToRoman(int n) {\\n       String M[] = {\"\", \"M\", \"MM\", \"MMM\"};\\n        String C[] = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n        String X[] = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\\n        String I[] = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\\n        return M[n / 1000] + C[(n / 100) % 10] + X[(n / 10) % 10] + I[n % 10];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 262432,
                "title": "faster-than-100-00-of-java",
                "content": "Runtime: 4 ms, faster than 100.00% of Java online submissions for Integer to Roman.\\nMemory Usage: 37.6 MB, less than 100.00% of Java online submissions for Integer to Roman.\\n```java \\nclass Solution {\\n    public String intToRoman(int num) {\\n        StringBuilder  result = new StringBuilder();\\n        int[] nums = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        String[] chars= {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        while(num!=0){\\n            for(int i =0; i<nums.length;i++){\\n                if(num>=nums[i]){\\n                    result.append(chars[i]);\\n                    num-=nums[i];\\n                    break;\\n                }\\n            }\\n        }\\n        return result.toString();\\n    }\\n}\\n```\\n\\u8FD9\\u9898\\u6CA1\\u5565\\u610F\\u4E49\\u554A",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java \\nclass Solution {\\n    public String intToRoman(int num) {\\n        StringBuilder  result = new StringBuilder();\\n        int[] nums = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        String[] chars= {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        while(num!=0){\\n            for(int i =0; i<nums.length;i++){\\n                if(num>=nums[i]){\\n                    result.append(chars[i]);\\n                    num-=nums[i];\\n                    break;\\n                }\\n            }\\n        }\\n        return result.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 222715,
                "title": "java-57-ms-beats-95-5-no-map-used-easy-understand",
                "content": "```\\nclass Solution {\\n    int[] nums = new int[] {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n    String[] symbols = new String[] {\\n        \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"\\n    };\\n    public String intToRoman(int num) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < nums.length && num > 0; i++) {\\n            int cnt = num / nums[i];\\n            while (cnt-- > 0) {\\n                sb.append(symbols[i]);\\n            }\\n            num %= nums[i];\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] nums = new int[] {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n    String[] symbols = new String[] {\\n        \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"\\n    };\\n    public String intToRoman(int num) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < nums.length && num > 0; i++) {\\n            int cnt = num / nums[i];\\n            while (cnt-- > 0) {\\n                sb.append(symbols[i]);\\n            }\\n            num %= nums[i];\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 6343,
                "title": "my-c-solution-beat-95",
                "content": "```\\nstring intToRoman(int num) {\\n        int i=0;\\n        string a = \"IVXLCDM\", res = \"\";\\n        while(num)\\n        {\\n            int temp = num%10;\\n            if(temp<=3) res = string(temp,a[i])+res;\\n            else if(temp==4) res = string(1,a[i])+string(1,a[i+1])+res;\\n            else if(temp==5) res = string(1,a[i+1])+res;\\n            else if(temp<=8) res = string(1,a[i+1])+string(temp-5,a[i])+res;\\n            else if(temp==9) res = string(1,a[i])+string(1,a[i+2])+res;\\n            num = num/10;\\n            i += 2;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nstring intToRoman(int num) {\\n        int i=0;\\n        string a = \"IVXLCDM\", res = \"\";\\n        while(num)\\n        {\\n            int temp = num%10;\\n            if(temp<=3) res = string(temp,a[i])+res;\\n            else if(temp==4) res = string(1,a[i])+string(1,a[i+1])+res;\\n            else if(temp==5) res = string(1,a[i+1])+res;\\n            else if(temp<=8) res = string(1,a[i+1])+string(temp-5,a[i])+res;\\n            else if(temp==9) res = string(1,a[i])+string(1,a[i+2])+res;\\n            num = num/10;\\n            i += 2;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 6315,
                "title": "please-laugh-at-me",
                "content": "\\n```\\npublic class Solution {\\n    public String intToRoman(int num) {\\n        StringBuffer res = new StringBuffer();\\n        while(num >= 1000){\\n            res.append(\"M\");\\n            num -= 1000;\\n        }\\n        int temp = num / 100;\\n        switch(temp){\\n            case 9: res.append(\"CM\"); break;\\n            case 8: res.append(\"DCCC\"); break;\\n            case 7: res.append(\"DCC\"); break;\\n            case 6: res.append(\"DC\"); break;\\n            case 5: res.append(\"D\"); break;\\n            case 4: res.append(\"CD\"); break;\\n            case 3: res.append(\"CCC\"); break;\\n            case 2: res.append(\"CC\"); break;\\n            case 1: res.append(\"C\"); break;\\n            case 0: break;\\n        }\\n        num -= temp*100;\\n        temp = num / 10;\\n        switch(temp){\\n            case 9: res.append(\"XC\"); break;\\n            case 8: res.append(\"LXXX\"); break;\\n            case 7: res.append(\"LXX\"); break;\\n            case 6: res.append(\"LX\"); break;\\n            case 5: res.append(\"L\"); break;\\n            case 4: res.append(\"XL\"); break;\\n            case 3: res.append(\"XXX\"); break;\\n            case 2: res.append(\"XX\"); break;\\n            case 1: res.append(\"X\"); break;\\n            case 0: break;\\n        }\\n        num -= temp*10;\\n        switch(num){\\n            case 9: res.append(\"IX\"); break;\\n            case 8: res.append(\"VIII\"); break;\\n            case 7: res.append(\"VII\"); break;\\n            case 6: res.append(\"VI\"); break;\\n            case 5: res.append(\"V\"); break;\\n            case 4: res.append(\"IV\"); break;\\n            case 3: res.append(\"III\"); break;\\n            case 2: res.append(\"II\"); break;\\n            case 1: res.append(\"I\"); break;\\n            case 0: break;\\n        }\\n        \\n        return res.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public String intToRoman(int num) {\\n        StringBuffer res = new StringBuffer();\\n        while(num >= 1000){\\n            res.append(\"M\");\\n            num -= 1000;\\n        }\\n        int temp = num / 100;\\n        switch(temp){\\n            case 9: res.append(\"CM\"); break;\\n            case 8: res.append(\"DCCC\"); break;\\n            case 7: res.append(\"DCC\"); break;\\n            case 6: res.append(\"DC\"); break;\\n            case 5: res.append(\"D\"); break;\\n            case 4: res.append(\"CD\"); break;\\n            case 3: res.append(\"CCC\"); break;\\n            case 2: res.append(\"CC\"); break;\\n            case 1: res.append(\"C\"); break;\\n            case 0: break;\\n        }\\n        num -= temp*100;\\n        temp = num / 10;\\n        switch(temp){\\n            case 9: res.append(\"XC\"); break;\\n            case 8: res.append(\"LXXX\"); break;\\n            case 7: res.append(\"LXX\"); break;\\n            case 6: res.append(\"LX\"); break;\\n            case 5: res.append(\"L\"); break;\\n            case 4: res.append(\"XL\"); break;\\n            case 3: res.append(\"XXX\"); break;\\n            case 2: res.append(\"XX\"); break;\\n            case 1: res.append(\"X\"); break;\\n            case 0: break;\\n        }\\n        num -= temp*10;\\n        switch(num){\\n            case 9: res.append(\"IX\"); break;\\n            case 8: res.append(\"VIII\"); break;\\n            case 7: res.append(\"VII\"); break;\\n            case 6: res.append(\"VI\"); break;\\n            case 5: res.append(\"V\"); break;\\n            case 4: res.append(\"IV\"); break;\\n            case 3: res.append(\"III\"); break;\\n            case 2: res.append(\"II\"); break;\\n            case 1: res.append(\"I\"); break;\\n            case 0: break;\\n        }\\n        \\n        return res.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 6411,
                "title": "share-my-c-solution-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        string intToRoman(int num) {\\n            string ret = \"\";\\n            if (num <= 0) return ret;\\n            //{ {1, 2, 3, 4, 5, 6, 7, 8, 9},\\n            //  {10, 20, 30, 40, 50, 60, 70, 80, 90},\\n            //  {100, 200, 300, 400, 500, 600, 700, 800, 900},\\n            //  {1000, 2000, 3000} }\\n            string roman[4][10] = {{\"0\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"},\\n                                   {\"0\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"},\\n                                   {\"0\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"},\\n                                   {\"0\", \"M\", \"MM\", \"MMM\"}};\\n            int i = 0, k = 1000;\\n            \\n            for (i = 3; i >= 0; --i)\\n            {\\n                if (num / k != 0)\\n                    ret += roman[i][num/k];\\n                num %= k;\\n                k /= 10;\\n            }\\n            \\n            return ret;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string intToRoman(int num) {\\n            string ret = \"\";\\n            if (num <= 0) return ret;\\n            //{ {1, 2, 3, 4, 5, 6, 7, 8, 9}",
                "codeTag": "Java"
            },
            {
                "id": 6455,
                "title": "my-short-java-code",
                "content": "    public class Solution {\\n        \\n        String[][] base = new String[][]{{\"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"},\\n                                    {\"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"},\\n                                    {\"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"},\\n                                    {\"M\", \"MM\", \"MMM\", \"\", \"\", \"\", \"\", \"\", \"\"}};\\n        \\n        public String intToRoman(int num) {\\n            String r = \"\";\\n            for (int i = 0; num != 0; num /= 10, i++) {\\n                if (num % 10 == 0)\\n                    continue;\\n                r = base[i][num % 10-1] + r;\\n            }\\n            return r;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        \\n        String[][] base = new String[][]{{\"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"}",
                "codeTag": "Java"
            },
            {
                "id": 6482,
                "title": "a-solution-applies-to-numbers-in-any-range",
                "content": "    public class Solution {\\n        public String intToRoman(int num) {\\n            return (romanDigit((num / 1000) % 10, \"M\", \"XX\", \"XX\")) + \\n                   (romanDigit((num / 100) % 10, \"C\", \"D\", \"M\")) +\\n                   (romanDigit((num / 10) % 10, \"X\", \"L\", \"C\")) +\\n                   (romanDigit(num % 10, \"I\", \"V\", \"X\"));\\n        }\\n        \\n        public String romanDigit(int n, String onechar, String fivechar, String tenchar) {\\n            if (n == 0) return \"\";\\n            if (n == 1) return onechar;\\n            if (n == 2) return onechar + onechar;\\n            if (n == 3) return onechar + onechar + onechar;\\n            if (n == 4) return onechar + fivechar;\\n            if (n == 5) return fivechar;\\n            if (n == 6) return fivechar + onechar;\\n            if (n == 7) return fivechar + onechar + onechar;\\n            if (n == 8) return fivechar + onechar + onechar + onechar;\\n            if (n == 9) return onechar + tenchar;\\n            \\n            return null;\\n        }\\n    }\\n\\n\\nI know the listing way is not so good, but just realized that the patterns are the same and can be summarized as \"onechar\", \"fivechar\" and \"tenchar\", which will simplify the solution a little bit.",
                "solutionTags": [],
                "code": "class Solution {\\n        public String intToRoman(int num) {\\n            return (romanDigit((num / 1000) % 10, \"M\", \"XX\", \"XX\")) + \\n                   (romanDigit((num / 100) % 10, \"C\", \"D\", \"M\")) +\\n                   (romanDigit((num / 10) % 10, \"X\", \"L\", \"C\")) +\\n                   (romanDigit(num % 10, \"I\", \"V\", \"X\"));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 6486,
                "title": "an-accepted-answer-in-python-using-s-replace",
                "content": "runtime:168 ms\\n\\n    class Solution:\\n   \\n        # @return a string\\n        def intToRoman(self, num):\\n            result = num//1000 *'M' + num%1000//100*'C' + \\\\\\n                         num%1000%100//10*'X' + num%1000%100%10*'I'\\n\\n            result = result.replace('IIIIIIIII', 'IX')\\n            result = result.replace('IIIII','V')\\n            result = result.replace('IIII' , 'IV')\\n            result = result.replace('XXXXXXXXX', 'XC')\\n            result = result.replace('XXXXX' , 'L')\\n            result = result.replace('XXXX' , 'XL')\\n            result = result.replace('CCCCCCCCC', 'CM')\\n            result = result.replace('CCCCC', 'D')\\n            result = result.replace('CCCC', 'CD')\\n            return (result)",
                "solutionTags": [],
                "code": "runtime:168 ms\\n\\n    class Solution:\\n   \\n        # @return a string\\n        def intToRoman(self, num):\\n            result = num//1000 *'M' + num%1000//100*'C' + \\\\\\n                         num%1000%100//10*'X' + num%1000%100%10*'I'\\n\\n            result = result.replace('IIIIIIIII', 'IX')\\n            result = result.replace('IIIII','V')\\n            result = result.replace('IIII' , 'IV')\\n            result = result.replace('XXXXXXXXX', 'XC')\\n            result = result.replace('XXXXX' , 'L')\\n            result = result.replace('XXXX' , 'XL')\\n            result = result.replace('CCCCCCCCC', 'CM')\\n            result = result.replace('CCCCC', 'D')\\n            result = result.replace('CCCC', 'CD')\\n            return (result)",
                "codeTag": "Java"
            },
            {
                "id": 6495,
                "title": "my-accepted-solution-in-java-using-array",
                "content": "The key of my solution is count the num of every digits,and using array to append it.\\n\\n    public class Solution {\\n        public String intToRoman(int num) {\\n            StringBuffer res=new StringBuffer();\\n            String[] aryC={\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n            String[] aryX={\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n            String[] aryI={\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n            int Mnums=num/1000;        //1000\\n            int Cnums=(num%1000)/100;  //100\\n            int Xnums=(num%100)/10;    //10\\n            int Inums=num%10;          //1\\n            for(int i=Mnums;i>0;i--)\\n            {\\n                res.append(\"M\");\\n            }\\n            res.append(aryC[Cnums]);\\n            res.append(aryX[Xnums]);\\n            res.append(aryI[Inums]);\\n            return res.toString();\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public String intToRoman(int num) {\\n            StringBuffer res=new StringBuffer();\\n            String[] aryC={\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"}",
                "codeTag": "Java"
            },
            {
                "id": 3985674,
                "title": "beats-98-very-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thougStringhts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create two arrays, one to store the Roman numerals and the other to store their corresponding values.\\n2. Initialize a StringBuilder to store the Roman numeral representation of the integer.\\n3. Iterate over the arrays in parallel.\\n4. While the integer is greater than or equal to the value at the current index of the values array, append the Roman numeral at the corresponding index of the notations array to the StringBuilder.\\n5. Decrement the integer by the value at the current index of the values array.\\n6. Repeat steps 4 and 5 until the integer is less than the value at the first index of the values array.\\n7. Return the String representation of the StringBuilder\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        int []values={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        String []notations={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        StringBuilder sb=new StringBuilder();\\n\\n        for(int i=0;i<values.length;i++){\\n            while(num>=values[i])\\n            {\\n                num-=values[i];\\n                sb.append(notations[i]);\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        int []values={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        String []notations={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        StringBuilder sb=new StringBuilder();\\n\\n        for(int i=0;i<values.length;i++){\\n            while(num>=values[i])\\n            {\\n                num-=values[i];\\n                sb.append(notations[i]);\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113157,
                "title": "most-optimised-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) \\n    {\\n        int normal[]={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        string roman[]={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        string rom;\\n        for(int i=0;i<13;i++){\\n            while(num>=normal[i]){\\n                rom.append(roman[i]);\\n                num-=normal[i];\\n            }\\n        }\\n        return rom;\\n        }};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) \\n    {\\n        int normal[]={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        string roman[]={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        string rom;\\n        for(int i=0;i<13;i++){\\n            while(num>=normal[i]){\\n                rom.append(roman[i]);\\n                num-=normal[i];\\n            }\\n        }\\n        return rom;\\n        }};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991683,
                "title": "c",
                "content": "# Code\\n```\\npublic class Solution {\\n    public string IntToRoman(int num) {\\n        if (num >= 1000) return \"M\" + IntToRoman(num - 1000);\\n\\n        if (num >= 500) return num >= 900 ? (\"CM\" + IntToRoman(num - 900)) : (\"D\" + IntToRoman(num - 500));\\n\\n        if (num >= 100) return num >= 400 ? (\"CD\" + IntToRoman(num - 400)) : (\"C\" + IntToRoman(num - 100));\\n\\n        if (num >= 50) return num >= 90 ? (\"XC\" + IntToRoman(num - 90)) : (\"L\" + IntToRoman(num - 50));\\n\\n        if (num >= 10) return num >= 40 ? (\"XL\" + IntToRoman(num - 40)): (\"X\" + IntToRoman(num - 10));\\n\\n        if (num >= 5) return num == 9 ? \"IX\" : \"V\" + IntToRoman(num - 5);\\n\\n        if (num > 0) return num == 4 ? \"IV\" : \"I\" + IntToRoman(num - 1);\\n\\n        return \"\";   \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string IntToRoman(int num) {\\n        if (num >= 1000) return \"M\" + IntToRoman(num - 1000);\\n\\n        if (num >= 500) return num >= 900 ? (\"CM\" + IntToRoman(num - 900)) : (\"D\" + IntToRoman(num - 500));\\n\\n        if (num >= 100) return num >= 400 ? (\"CD\" + IntToRoman(num - 400)) : (\"C\" + IntToRoman(num - 100));\\n\\n        if (num >= 50) return num >= 90 ? (\"XC\" + IntToRoman(num - 90)) : (\"L\" + IntToRoman(num - 50));\\n\\n        if (num >= 10) return num >= 40 ? (\"XL\" + IntToRoman(num - 40)): (\"X\" + IntToRoman(num - 10));\\n\\n        if (num >= 5) return num == 9 ? \"IX\" : \"V\" + IntToRoman(num - 5);\\n\\n        if (num > 0) return num == 4 ? \"IV\" : \"I\" + IntToRoman(num - 1);\\n\\n        return \"\";   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724944,
                "title": "c-use-hashmap-easy-approach",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    string intToRoman(int num) \\n    {\\n        vector<pair<int, string>> roman = {{1000, \"M\"}, {900, \"CM\"}, {500, \"D\"}, {400, \"CD\"}, {100, \"C\"},\\n                                         {90, \"XC\"}, {50, \"L\"}, {40, \"XL\"}, {10, \"X\"}, {9, \"IX\"},\\n                                         {5, \"V\"}, {4, \"IV\"}, {1, \"I\"}};\\n        \\n        string res=\"\";\\n        \\n        for(auto it:roman)\\n        {\\n            while(num >= it.first)\\n            {\\n                res += it.second;\\n                num -= it.first;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    string intToRoman(int num) \\n    {\\n        vector<pair<int, string>> roman = {{1000, \"M\"}, {900, \"CM\"}, {500, \"D\"}, {400, \"CD\"}, {100, \"C\"},\\n                                         {90, \"XC\"}, {50, \"L\"}, {40, \"XL\"}, {10, \"X\"}, {9, \"IX\"},\\n                                         {5, \"V\"}, {4, \"IV\"}, {1, \"I\"}};\\n        \\n        string res=\"\";\\n        \\n        for(auto it:roman)\\n        {\\n            while(num >= it.first)\\n            {\\n                res += it.second;\\n                num -= it.first;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724475,
                "title": "java-and-c-simple-and-concise-solution-with-detailed-explanation",
                "content": "# Explanation:\\nInitialize two arrays with all possible roman string and number combinations in descending order. Following are the legitamate possible roman symbols and number combinations.  (*I\\'ve used a vector of pairs in C++ implementation*)\\n```\\n String [] romans = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n Integer [] nums = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n```\\n\\nThe goal here is to check how many times each number is divisible by the roman symbols and convert the number to roman symbol greedily.  \\n\\n` Example :3888`\\n            \\nWe start with 1000 and check if the given number is greater than 1000. In this case, it is greater than 1000. We need to know exactly how many times the number is divisible by 1000 because we need to replace 1000 with M that many number of times.   So we know 3000 can be represented with 3 Ms (`MMM`) as floor(3888 / 1000) is 3. Now since we have converted 3000 to roman number, we need to convert the reminder ie 888.\\n\\nWe know for sure the reminder from the previous operation is less than the previous divisor, so we don\\'t have to loop through the numbers array from the start every time. We can start traversing nums array with the index after the previous divisor, as it is sorted in descending order.  888 < 900, so we continue traversing the nums array. the next element in the array is 500. 888 > 500, so we break out of the first for loop below. Now 888 / 500 = 1. so we append the roman notation for 1 500 i.e D to our result.  Now the result so far is `MMMD` and reminder is 388. After solving for the reminder in the similar manner, we get the answer `MMMMDCCCLXXXVIII`.\\n\\n**Complexity**\\n\\n```\\n Time Complexity: O(1)\\n Space Complexity: O(1)\\n```\\n            \\nThis is because we use two arrays of fixed size 13 to store the roman and binary numbers. And no matter what the number is we know the below operations are in the worst case constant space as array size is constant and we are just iterating a constant sized array and we can guarantee in the worst case iterates through every element at the most once. The divisorcan at the most be O(8) which is constant. And all the operations in the below loop are constant operations.  \\n\\n```\\n \\n        while(num > 0) {\\n            for(;num < nums[i]; i++);\\n            int count = (num / nums[i]);\\n            for(int j = 0; j < count; j++)\\n                result.append(romans[i]);\\n            num = num - count * nums[i];\\n        }\\n```\\n\\n# Java Solution\\n```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        String [] romans = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        Integer [] nums = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        int i = 0;\\n        StringBuilder result = new StringBuilder();\\n        \\n        while(num > 0) {\\n            for(;num < nums[i]; i++);\\n            int count = (num / nums[i]);\\n            for(int j = 0; j < count; j++)\\n                result.append(romans[i]);\\n            num = num - count * nums[i];\\n        }\\n        \\n        return result.toString();\\n    }\\n}\\n```\\n\\n# C++ Solution\\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<pair<int,string>> romanPairs = {\\n            {1000, \"M\"}, {900, \"CM\"}, {500, \"D\"}, {400, \"CD\"}, {100, \"C\"}, {90, \"XC\"}, \\n            {50, \"L\"}, {40, \"XL\"}, {10, \"X\"}, {9, \"IX\"}, {5, \"V\"}, {4, \"IV\"}, {1, \"I\"}\\n        };\\n        \\n        int i = 0;\\n        string result = \"\";\\n        \\n        while(num > 0) {\\n            for(;num < romanPairs[i].first; i++);\\n            string roman = romanPairs[i].second;\\n            int number = romanPairs[i].first; \\n            int count = (num / number);\\n            \\n            for(int j = 0; j < count; j++)\\n                result += roman;\\n            num = num - count * number;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n String [] romans = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n Integer [] nums = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n```\n```\\n Time Complexity: O(1)\\n Space Complexity: O(1)\\n```\n```\\n \\n        while(num > 0) {\\n            for(;num < nums[i]; i++);\\n            int count = (num / nums[i]);\\n            for(int j = 0; j < count; j++)\\n                result.append(romans[i]);\\n            num = num - count * nums[i];\\n        }\\n```\n```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        String [] romans = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        Integer [] nums = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        int i = 0;\\n        StringBuilder result = new StringBuilder();\\n        \\n        while(num > 0) {\\n            for(;num < nums[i]; i++);\\n            int count = (num / nums[i]);\\n            for(int j = 0; j < count; j++)\\n                result.append(romans[i]);\\n            num = num - count * nums[i];\\n        }\\n        \\n        return result.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<pair<int,string>> romanPairs = {\\n            {1000, \"M\"}, {900, \"CM\"}, {500, \"D\"}, {400, \"CD\"}, {100, \"C\"}, {90, \"XC\"}, \\n            {50, \"L\"}, {40, \"XL\"}, {10, \"X\"}, {9, \"IX\"}, {5, \"V\"}, {4, \"IV\"}, {1, \"I\"}\\n        };\\n        \\n        int i = 0;\\n        string result = \"\";\\n        \\n        while(num > 0) {\\n            for(;num < romanPairs[i].first; i++);\\n            string roman = romanPairs[i].second;\\n            int number = romanPairs[i].first; \\n            int count = (num / number);\\n            \\n            for(int j = 0; j < count; j++)\\n                result += roman;\\n            num = num - count * number;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724333,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        symbolMap = {\\n            1 : \"I\", \\n            5 : \\'V\\', \\n            10 : \"X\", \\n            50 : \"L\", \\n            100 : \"C\", \\n            500 : \"D\", \\n            1000 : \"M\"\\n        }\\n        \\n        res = [] \\n        while num >= 1000: \\n            res.append(symbolMap[1000])\\n            num -= 1000 \\n        \\n        while num >= 900: \\n            res.append(symbolMap[100])\\n            res.append(symbolMap[1000])\\n            num -= 900        \\n            \\n        while num >= 500: \\n            res.append(symbolMap[500])\\n            num -= 500\\n        \\n        while num >= 400: \\n            res.append(symbolMap[100])\\n            res.append(symbolMap[500])\\n            num -= 400  \\n        \\n        while num >= 100: \\n            res.append(symbolMap[100])\\n            num -= 100 \\n        \\n        while num >= 90: \\n            res.append(symbolMap[10])\\n            res.append(symbolMap[100])\\n            num -= 90  \\n            \\n        while num >= 50: \\n            res.append(symbolMap[50])\\n            num -= 50 \\n            \\n        while num >= 40: \\n            res.append(symbolMap[10])\\n            res.append(symbolMap[50])\\n            num -= 40 \\n        \\n        while num >= 10: \\n            res.append(symbolMap[10])\\n            num -= 10\\n            \\n        while num >= 9: \\n            res.append(symbolMap[1])\\n            res.append(symbolMap[10])\\n            num -= 400  \\n        \\n        while num >= 5:\\n            res.append(symbolMap[5])\\n            num -= 5 \\n            \\n        while num >= 4: \\n            res.append(symbolMap[1])\\n            res.append(symbolMap[5])\\n            num -= 400  \\n        \\n        while num >= 1: \\n            res.append(symbolMap[1])\\n            num -= 1 \\n            \\n        return \"\".join(res)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        symbolMap = {\\n            1 : \"I\", \\n            5 : \\'V\\', \\n            10 : \"X\", \\n            50 : \"L\", \\n            100 : \"C\", \\n            500 : \"D\", \\n            1000 : \"M\"\\n        }\\n        \\n        res = [] \\n        while num >= 1000: \\n            res.append(symbolMap[1000])\\n            num -= 1000 \\n        \\n        while num >= 900: \\n            res.append(symbolMap[100])\\n            res.append(symbolMap[1000])\\n            num -= 900        \\n            \\n        while num >= 500: \\n            res.append(symbolMap[500])\\n            num -= 500\\n        \\n        while num >= 400: \\n            res.append(symbolMap[100])\\n            res.append(symbolMap[500])\\n            num -= 400  \\n        \\n        while num >= 100: \\n            res.append(symbolMap[100])\\n            num -= 100 \\n        \\n        while num >= 90: \\n            res.append(symbolMap[10])\\n            res.append(symbolMap[100])\\n            num -= 90  \\n            \\n        while num >= 50: \\n            res.append(symbolMap[50])\\n            num -= 50 \\n            \\n        while num >= 40: \\n            res.append(symbolMap[10])\\n            res.append(symbolMap[50])\\n            num -= 40 \\n        \\n        while num >= 10: \\n            res.append(symbolMap[10])\\n            num -= 10\\n            \\n        while num >= 9: \\n            res.append(symbolMap[1])\\n            res.append(symbolMap[10])\\n            num -= 400  \\n        \\n        while num >= 5:\\n            res.append(symbolMap[5])\\n            num -= 5 \\n            \\n        while num >= 4: \\n            res.append(symbolMap[1])\\n            res.append(symbolMap[5])\\n            num -= 400  \\n        \\n        while num >= 1: \\n            res.append(symbolMap[1])\\n            num -= 1 \\n            \\n        return \"\".join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2723932,
                "title": "c-no-hard-code-simple-way",
                "content": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<pair<int, string>> map{{1, \"I\"}, {4, \"IV\"}, {5, \"V\"}, {9, \"IX\"}, {10, \"X\"}, {40, \"XL\"}, {50, \"L\"}, \\n\\t\\t{90, \"XC\"}, {100, \"C\"}, {400, \"CD\"}, {500, \"D\"}, {900, \"CM\"}, {1000, \"M\"}};\\n        int l = map.size()-1;\\n        string s=\"\";\\n        \\n        while(num!=0){\\n            while(map[l].first>num){\\n                l--;\\n            }\\n            s += map[l].second;\\n            num -= map[l].first;\\n        }\\n        return s;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<pair<int, string>> map{{1, \"I\"}, {4, \"IV\"}, {5, \"V\"}, {9, \"IX\"}, {10, \"X\"}, {40, \"XL\"}, {50, \"L\"}, \\n\\t\\t{90, \"XC\"}, {100, \"C\"}, {400, \"CD\"}, {500, \"D\"}, {900, \"CM\"}, {1000, \"M\"}};\\n        int l = map.size()-1;\\n        string s=\"\";\\n        \\n        while(num!=0){\\n            while(map[l].first>num){\\n                l--;\\n            }\\n            s += map[l].second;\\n            num -= map[l].first;\\n        }\\n        return s;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2723735,
                "title": "daily-leetcoding-challenge-october-day-20",
                "content": "This problem is the Daily LeetCoding Challenge for October, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/integer-to-roman/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Greedy\n\n  \n**Approach 2:** Hardcode Digits\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/integer-to-roman/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2501930,
                "title": "moms-spaghetti",
                "content": "```\\n\\n   let m = Math.floor(num/1000)\\n  num%=1000\\n  let cm = Math.floor(num / 900)\\n  num%=900\\n  let d = Math.floor(num/500)\\n  num%=500\\nlet cd = Math.floor(num/400)\\nnum%=400\\nlet c = Math.floor(num/100)\\nnum%=100\\nlet xc = Math.floor(num/90)\\nnum%=90\\nlet l = Math.floor(num/50)\\n  num%=50\\nlet xl = Math.floor(num/40)\\nnum%=40\\nlet x = Math.floor(num/10)\\nnum%=10\\nlet ix = Math.floor(num/9)\\nnum%=9\\nlet v = Math.floor(num/5)\\nnum%=5\\nlet iv = Math.floor(num/4)\\nnum%=4\\nlet i = Math.floor(num/1)\\n\\n\\nreturn \"M\".repeat(m)+\"CM\".repeat(cm)+\"D\".repeat(d)+\"CD\".repeat(cd)+\"C\".repeat(c)+\"XC\".repeat(xc)+\"L\".repeat(l)+\"XL\".repeat(xl)+\"X\".repeat(x)+\"IX\".repeat(ix)+\"V\".repeat(v)+\"IV\".repeat(iv)+\"I\".repeat(i)\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\n\\n   let m = Math.floor(num/1000)\\n  num%=1000\\n  let cm = Math.floor(num / 900)\\n  num%=900\\n  let d = Math.floor(num/500)\\n  num%=500\\nlet cd = Math.floor(num/400)\\nnum%=400\\nlet c = Math.floor(num/100)\\nnum%=100\\nlet xc = Math.floor(num/90)\\nnum%=90\\nlet l = Math.floor(num/50)\\n  num%=50\\nlet xl = Math.floor(num/40)\\nnum%=40\\nlet x = Math.floor(num/10)\\nnum%=10\\nlet ix = Math.floor(num/9)\\nnum%=9\\nlet v = Math.floor(num/5)\\nnum%=5\\nlet iv = Math.floor(num/4)\\nnum%=4\\nlet i = Math.floor(num/1)\\n\\n\\nreturn \"M\".repeat(m)+\"CM\".repeat(cm)+\"D\".repeat(d)+\"CD\".repeat(cd)+\"C\".repeat(c)+\"XC\".repeat(xc)+\"L\".repeat(l)+\"XL\".repeat(xl)+\"X\".repeat(x)+\"IX\".repeat(ix)+\"V\".repeat(v)+\"IV\".repeat(iv)+\"I\".repeat(i)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2497457,
                "title": "thous-hunds-tens-ones-by-mdeakyne",
                "content": "**Please upvote if it was helpful!**\\n\\nThe old elegant solution without a loop.\\n```\\nclass Solution {\\n  String intToRoman(int num) {\\n    final ones = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"];\\n    final tens = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"];\\n    final hunds = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"];\\n    final thous = [\"\", \"M\", \"MM\", \"MMM\", \"MMMM\"];\\n\\n    final t = thous[num  ~/ 1000];\\n    final h = hunds[num ~/ 100 % 10];\\n    final te = tens[num ~/ 10 % 10];\\n    final o = ones[num % 10];\\n\\n    return t + h + te + o;\\n  }\\n}\\n```\\n[Submission Detail](https://leetcode.com/submissions/detail/785763057/)",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  String intToRoman(int num) {\\n    final ones = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"];\\n    final tens = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"];\\n    final hunds = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"];\\n    final thous = [\"\", \"M\", \"MM\", \"MMM\", \"MMMM\"];\\n\\n    final t = thous[num  ~/ 1000];\\n    final h = hunds[num ~/ 100 % 10];\\n    final te = tens[num ~/ 10 % 10];\\n    final o = ones[num % 10];\\n\\n    return t + h + te + o;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2294406,
                "title": "c-complete-dry-run-digit-by-digit-solution-right-to-left-single-hashmap",
                "content": "After Reading this post definetely you will be crystal clear with the Approach and as well as with Code.\\n***\\nBefore copying the code please once understand completely then you can copy !!\\n```\\nclass Solution {\\npublic:\\n    \\n    //  Dry run some exmaples \\n    /*\\n        3999 = 3000 + 900 + 90 + 9 = MMM + CM + XC + IX\\n        // Go backward only one positions\\n        2835 = 2000 + 800 + 30 + 5 = MM + DCC + XXX + V  (WRONG WAY : MM + CCM + XXX + V)\\n        4000 = MMMM\\n\\n    */\\n    \\n    // DRY RUN of num = 249 for the below code\\n    // 249 = 200 + 40 + 9 = \\n    /* \\n        Ist Pass :\\n        --------\\n        last digit = 9 , place value = x = 1\\n        1. multiply by place value = 9*1 = 9 \\n        2  9 is not found in map\\n        3. Its nearest by place value x=1, 9+1 = 10, 10 is present in map\\n        4. write mp[1]+mp[10] = \"IX\" for \\'9\\'\\n        5. ans = \"IX\"\\n        \\n        IInd Pass :\\n        ---------\\n        last digit = 4 , place value = x = 10\\n        1. multiply by place value = 4*10 = 40\\n        2  40 is not found in map\\n        3. Its nearest by place value x=10, 40+10 = 50, 50 is present in map\\n        4. write mp[10]+mp[50] = \"XL\" for \\'40\\'\\n        5. ans = \"XLIX\"\\n        \\n        IIIrd Pass :\\n        ---------\\n        last digit = 2 , place value = x = 100\\n        1. multiply by place value = 2*100 = 200\\n        2  200 is not found in map\\n        3. Its nearest by place value x=100, 200+100 = 300, 300 is not present in map\\n        4. So perform subtraction by place value x=100, 200-100 = 100, 100 is present in map\\n        5. write mp[100]+mp[100] = \"CC\" for \\'200\\'\\n        6. ans = \"CCXLIX\"\\n        \\n        DONE !\\n    */\\n    string intToRoman(int num) \\n    {\\n        unordered_map<int,string>mp = {{1,\"I\"},{5,\"V\"},{10,\"X\"},{50,\"L\"},{100,\"C\"},{500,\"D\"},{1000,\"M\"}};\\n        \\n        int x=1;\\n        string ans=\"\";\\n        while(num>0)\\n        {\\n            int d=num%10;                           // Last digit of a number\\n            d*=x;                                   // Multiply by its place value (like 1, 10, 100, 1000)\\n            while(d>0)\\n            {\\n                if(mp.find(d)!=mp.end()){           // find the digit in the map - direct \\n                    ans = mp[d] + ans;\\n                    d = 0;\\n                } \\n                else if(mp.find(d+x)!=mp.end())      // or find the approx nearest in the map. // like 40 nearest to 50\\n                {\\n                    ans = mp[x] + mp[d+x] + ans;\\n                    d = 0;\\n                }\\n                else                            // iterate the place value mapped value until it matches the map value\\n                {\\n                    ans = mp[x] + ans;\\n                    d -= x;\\n                } \\n            }\\n            num/=10; // remove the last digit from the number\\n            x*=10; // increment the place value.\\n        }\\n        return ans;\\n    }\\n};\\n```\\n***Thanks for Upvoting !***\\n\\uD83D\\uDE42",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    //  Dry run some exmaples \\n    /*\\n        3999 = 3000 + 900 + 90 + 9 = MMM + CM + XC + IX\\n        // Go backward only one positions\\n        2835 = 2000 + 800 + 30 + 5 = MM + DCC + XXX + V  (WRONG WAY : MM + CCM + XXX + V)\\n        4000 = MMMM\\n\\n    */\\n    \\n    // DRY RUN of num = 249 for the below code\\n    // 249 = 200 + 40 + 9 = \\n    /* \\n        Ist Pass :\\n        --------\\n        last digit = 9 , place value = x = 1\\n        1. multiply by place value = 9*1 = 9 \\n        2  9 is not found in map\\n        3. Its nearest by place value x=1, 9+1 = 10, 10 is present in map\\n        4. write mp[1]+mp[10] = \"IX\" for \\'9\\'\\n        5. ans = \"IX\"\\n        \\n        IInd Pass :\\n        ---------\\n        last digit = 4 , place value = x = 10\\n        1. multiply by place value = 4*10 = 40\\n        2  40 is not found in map\\n        3. Its nearest by place value x=10, 40+10 = 50, 50 is present in map\\n        4. write mp[10]+mp[50] = \"XL\" for \\'40\\'\\n        5. ans = \"XLIX\"\\n        \\n        IIIrd Pass :\\n        ---------\\n        last digit = 2 , place value = x = 100\\n        1. multiply by place value = 2*100 = 200\\n        2  200 is not found in map\\n        3. Its nearest by place value x=100, 200+100 = 300, 300 is not present in map\\n        4. So perform subtraction by place value x=100, 200-100 = 100, 100 is present in map\\n        5. write mp[100]+mp[100] = \"CC\" for \\'200\\'\\n        6. ans = \"CCXLIX\"\\n        \\n        DONE !\\n    */\\n    string intToRoman(int num) \\n    {\\n        unordered_map<int,string>mp = {{1,\"I\"},{5,\"V\"},{10,\"X\"},{50,\"L\"},{100,\"C\"},{500,\"D\"},{1000,\"M\"}};\\n        \\n        int x=1;\\n        string ans=\"\";\\n        while(num>0)\\n        {\\n            int d=num%10;                           // Last digit of a number\\n            d*=x;                                   // Multiply by its place value (like 1, 10, 100, 1000)\\n            while(d>0)\\n            {\\n                if(mp.find(d)!=mp.end()){           // find the digit in the map - direct \\n                    ans = mp[d] + ans;\\n                    d = 0;\\n                } \\n                else if(mp.find(d+x)!=mp.end())      // or find the approx nearest in the map. // like 40 nearest to 50\\n                {\\n                    ans = mp[x] + mp[d+x] + ans;\\n                    d = 0;\\n                }\\n                else                            // iterate the place value mapped value until it matches the map value\\n                {\\n                    ans = mp[x] + ans;\\n                    d -= x;\\n                } \\n            }\\n            num/=10; // remove the last digit from the number\\n            x*=10; // increment the place value.\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2247286,
                "title": "c-integer-to-roman-fast-solution",
                "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string roman[] = {\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"};\\n        int val[] = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000};\\n        int i = 12;\\n        string str = \"\";\\n        while(num > 0) {\\n            int div = num / val[i];\\n            num %= val[i];\\n            while(div--) {\\n                str += roman[i];\\n            }\\n            i--;\\n        }\\n        return str;\\n    }\\n};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string roman[] = {\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"}",
                "codeTag": "Java"
            },
            {
                "id": 2237969,
                "title": "simple-java-recursive-solution-17ms",
                "content": "```\\n\\t\\tpublic String intToRoman(int num) {\\n\\t\\t\\tif(num == 0) return \"\";\\n\\t\\t\\tif(num >= 1000) return \"M\" + intToRoman( num - 1000);\\n\\t\\t\\tif(num >= 900) return \"CM\" + intToRoman(num - 900);\\n\\t\\t\\tif(num >= 500) return \"D\" + intToRoman( num - 500);\\n\\t\\t\\tif(num >= 400) return \"CD\" + intToRoman(num - 400);\\n\\t\\t\\tif(num >= 100) return \"C\" + intToRoman( num - 100);\\n\\t\\t\\tif(num >= 90) return \"XC\" + intToRoman( num - 90);\\n\\t\\t\\tif(num >= 50) return \"L\" + intToRoman( num - 50);\\n\\t\\t\\tif(num >= 40) return \"XL\" + intToRoman( num - 40);\\n\\t\\t\\tif(num >= 10) return \"X\" + intToRoman( num - 10);\\n\\t\\t\\tif(num >= 9) return \"IX\" + intToRoman( num - 9);\\n\\t\\t\\tif(num >= 5) return \"V\" + intToRoman( num - 5);\\n\\t\\t\\tif(num >= 4) return \"IV\" + intToRoman( num - 4);\\n\\t\\t\\tif(num >= 1) return \"I\" + intToRoman( num - 1);\\n\\t\\t\\treturn intToRoman(num);\\n    }\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n\\t\\tpublic String intToRoman(int num) {\\n\\t\\t\\tif(num == 0) return \"\";\\n\\t\\t\\tif(num >= 1000) return \"M\" + intToRoman( num - 1000);\\n\\t\\t\\tif(num >= 900) return \"CM\" + intToRoman(num - 900);\\n\\t\\t\\tif(num >= 500) return \"D\" + intToRoman( num - 500);\\n\\t\\t\\tif(num >= 400) return \"CD\" + intToRoman(num - 400);\\n\\t\\t\\tif(num >= 100) return \"C\" + intToRoman( num - 100);\\n\\t\\t\\tif(num >= 90) return \"XC\" + intToRoman( num - 90);\\n\\t\\t\\tif(num >= 50) return \"L\" + intToRoman( num - 50);\\n\\t\\t\\tif(num >= 40) return \"XL\" + intToRoman( num - 40);\\n\\t\\t\\tif(num >= 10) return \"X\" + intToRoman( num - 10);\\n\\t\\t\\tif(num >= 9) return \"IX\" + intToRoman( num - 9);\\n\\t\\t\\tif(num >= 5) return \"V\" + intToRoman( num - 5);\\n\\t\\t\\tif(num >= 4) return \"IV\" + intToRoman( num - 4);\\n\\t\\t\\tif(num >= 1) return \"I\" + intToRoman( num - 1);\\n\\t\\t\\treturn intToRoman(num);\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1898146,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1576240,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1568266,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1565655,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1565656,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1732820,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1914145,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1652407,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1571035,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1778211,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1898146,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1576240,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1568266,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1565655,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1565656,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1732820,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1914145,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1652407,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1571035,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1778211,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 2071772,
                "content": [
                    {
                        "username": "mukeshgupta_",
                        "content": "I think its easy question. On GFG this is a Basic Question."
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "The intuition behind it is just to go from highest value to the lowest possible and to add some special cases to the hash table.\n\nThat's it"
                    },
                    {
                        "username": "akotb3",
                        "content": "\\nthis is the code I wrote  I believe it should work but evertime i put into leetcode it is  just out putting a bunch of IIIIIIII an example of this is if the input is 58 it would print : \"IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII\"\\n\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        numdict = {1000:\"M\",\\n            900:\"CM\",\\n            500:\"D\",\\n            400:\"CD\",\\n            100:\"C\",\\n            90:\"XC\",\\n            50:\"L\",\\n            40:\"XL\",\\n            10:\"X\",\\n            9:\"IX\",\\n            5:\"V\",\\n            4:\"IV\",\\n            1:\"I\"\\n          }\\n        roman =\"\"\\n        for i in numdict.keys():\\n            while num >= i:\\n                num -= i\\n                roman += numdict[i]\\n            if num == 0:\\n                break\\n        return roman\\n\\nsolution = Solution()\\n\\n\\nresult = solution.intToRoman(1994)\\nprint(result)\\n\\n"
                    },
                    {
                        "username": "megan891685",
                        "content": "If I want to do this in c and not have memory leaks AND keep the compile time down, how should I return an array of char?\\nFor example.\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr =roman;\\n free(roman)\\n return arr; //will cause mem leaks\\n`\\n\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr;\\n  for(int i = 0; i < strlen(roman);i++){\\n arr[i] = roman[i];\\n}//going through for loop sounds like a giant waste.\\n free(roman)\\nreturn arr;\\n`"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Have to give this a like, it deserves the upvote, even though it left me with 3 failed attempts "
                    },
                    {
                        "username": "Nwarr_Desirs",
                        "content": "please bros i don\\'t undestand, what is self?? why do i need it? "
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "Self is something that 'represents' a function as a whole allowing you to access any variable inside the class, it doesn't have to be self (i.e. could be wjf), but is normally stated as it. For example, if we have two functions in the class, and we try to call one variable, this could be messy (if you get it). Take this as an example:\n\nclass Person:\n  def __init__(self, name: str, age: int) -> str:\n    self.name = name\n    self.age = age\n\n  def myfunc(abc):\n    return abc.name\n\nAlso you can refer to here: https://www.w3schools.com/python/gloss_python_self.asp#:~:text=The%20self%20parameter%20is%20a,that%20belongs%20to%20the%20class."
                    },
                    {
                        "username": "jetroll2014",
                        "content": "Idk why this is wrong.\n\nIt is clear that my result is same with the expected.... But it's a wrong answer.\n\nIdk why!!! Please someone help me :( \n\nnum=3, Output:\"III\", Expected:\"III\"\nnum=58, Output:\"LVIII\", Expected:\"LVIII\"\n\n\n `class Solution {\npublic:\n    string intToRoman(int num) {\n        int value = 0;\n        int count=0;\n        string result;\n        result+='M'*(num/1000);\n        num%=1000;\n        int idx = num/100;\n        if(idx ==9){\n            result+=\"CM\";\n        }\n        else if(idx==4){\n            result+=\"CD\";\n        }\n        else\n        {result.append(idx/5, 'D');\n        result.append(idx%5, 'C');\n        }\n        num%=100;\n        idx = num/10;\n        if(idx==9){\n            result+=\"XC\";\n        }\n        else if(idx==4){\n            result+=\"XL\";\n        }\n        else\n        {result.append(idx/5, 'L');\n        result.append(idx%5, 'X');\n        }\n        num%=10;\n        if(num==9){\n            result+=\"IX\";\n        }\n        else if(num==4){\n            result+=\"IV\";\n        }\n        else\n        {\n            result.append(num/5, 'V');\n            result.append(num%5, 'I');\n        }\n        return result;\n    }\n};`"
                    },
                    {
                        "username": "EmreArslan",
                        "content": "As I said in this code's comment sections, your code sets 0th index of result string as null. If the value is smaller than 1000. Also, your code doesn't multiplicate the 'M' if the number is bigger than 1000.\n\nHere is the fixed code with comment sections that explains the situation:\n\n```\nclass Solution { \n    public: string intToRoman(int num) \n    { \n        int value = 0; \n        int count=0; \n        string result;\n\n        //In this line, the initial char of 'result' string can be Null\n        // result+='M'*(num/1000); \n\n        //So that, I deactivated this line and wrote this if conditional and while loop\n        if(num/1000){\n            while(num >= 1000){\n                result += 'M';\n                num-=1000;\n            }\n        };\n        \n        // num%=1000; \n        int idx = num/100; \n        if(idx ==9){ result+=\"CM\"; } \n        else if(idx==4){ result+=\"CD\"; } \n        else {\n            result.append(idx/5, 'D'); \n            result.append(idx%5, 'C'); \n        } \n        num%=100; \n        idx = num/10; \n        if(idx==9){ \n            result+=\"XC\"; \n        } \n        else if(idx==4){ \n            result+=\"XL\"; \n        } \n        else {\n            result.append(idx/5, 'L'); \n            result.append(idx%5, 'X'); \n        } \n        num%=10; \n        if(num==9){ \n            result+=\"IX\"; \n        } \n        else if(num==4){ \n            result+=\"IV\"; \n        } \n        else { \n            result.append(num/5, 'V'); \n            result.append(num%5, 'I'); \n        } \n        return result; \n    } \n};\n```\n\nI hope it helps you "
                    },
                    {
                        "username": "arpitagrawal09",
                        "content": "Quite interesting question! "
                    },
                    {
                        "username": "anamrani17",
                        "content": "/**\\n * @param {number} num\\n * @return {string}\\n */\\nvar intToRoman = function(num) {\\n    // step 1: create a lookup table\\n    const lookupTable = {\\n       O: [\\'\\', \\'I\\', \\'II\\', \\'III\\', \\'IV\\', \\'V\\', \\'VI\\', \\'VII\\', \\'VIII\\', \\'IX\\'],\\n        T: [\\'\\', \\'X\\', \\'XX\\', \\'XXX\\', \\'XL\\', \\'L\\', \\'LX\\', \\'LXX\\', \\'LXXX\\', \\'XC\\'],\\n        H : [\\'\\', \\'C\\', \\'CC\\', \\'CCC\\', \\'CD\\', \\'D\\', \\'DC\\', \\'DCC\\', \\'DCCC\\', \\'CM\\'],\\n        Th : [\\'\\', \\'M\\', \\'MM\\', \\'MMM\\']\\n    }\\nreturn lookupTable.Th[Math.floor(num/1000)] + lookupTable.H[Math.floor((num%1000)/100)] + lookupTable.T[Math.floor((num%100)/10)] + lookupTable.O[num%10];\\n    \\n};\\n\\nhere is my solution of JavaScript code.\\nthe main line of code is return statement the expands the number then extract each digit one by one.\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zbraven",
                        "content": "int bul(char ch,int value)\\n{\\n\\nswitch (ch)\\n{\\n    case \\'I\\':\\n        value += 1;\\n        break;\\n    case \\'V\\':\\n        value += 5;\\n        break;\\n    case \\'X\\':\\n        value += 10;\\n        break;\\n    case \\'L\\':\\n        value += 50;\\n        break;\\n    case \\'C\\':\\n        value += 100;\\n        break;\\n    case \\'D\\':\\n        value += 500;\\n        break;\\n    case \\'M\\':\\n        value += 1000;\\n            break;\\n }\\n    return value;\\n\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n\\nconsole.log(romanToInt(\"MCMXCIV\"));"
                    }
                ]
            },
            {
                "id": 2071582,
                "content": [
                    {
                        "username": "mukeshgupta_",
                        "content": "I think its easy question. On GFG this is a Basic Question."
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "The intuition behind it is just to go from highest value to the lowest possible and to add some special cases to the hash table.\n\nThat's it"
                    },
                    {
                        "username": "akotb3",
                        "content": "\\nthis is the code I wrote  I believe it should work but evertime i put into leetcode it is  just out putting a bunch of IIIIIIII an example of this is if the input is 58 it would print : \"IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII\"\\n\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        numdict = {1000:\"M\",\\n            900:\"CM\",\\n            500:\"D\",\\n            400:\"CD\",\\n            100:\"C\",\\n            90:\"XC\",\\n            50:\"L\",\\n            40:\"XL\",\\n            10:\"X\",\\n            9:\"IX\",\\n            5:\"V\",\\n            4:\"IV\",\\n            1:\"I\"\\n          }\\n        roman =\"\"\\n        for i in numdict.keys():\\n            while num >= i:\\n                num -= i\\n                roman += numdict[i]\\n            if num == 0:\\n                break\\n        return roman\\n\\nsolution = Solution()\\n\\n\\nresult = solution.intToRoman(1994)\\nprint(result)\\n\\n"
                    },
                    {
                        "username": "megan891685",
                        "content": "If I want to do this in c and not have memory leaks AND keep the compile time down, how should I return an array of char?\\nFor example.\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr =roman;\\n free(roman)\\n return arr; //will cause mem leaks\\n`\\n\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr;\\n  for(int i = 0; i < strlen(roman);i++){\\n arr[i] = roman[i];\\n}//going through for loop sounds like a giant waste.\\n free(roman)\\nreturn arr;\\n`"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Have to give this a like, it deserves the upvote, even though it left me with 3 failed attempts "
                    },
                    {
                        "username": "Nwarr_Desirs",
                        "content": "please bros i don\\'t undestand, what is self?? why do i need it? "
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "Self is something that 'represents' a function as a whole allowing you to access any variable inside the class, it doesn't have to be self (i.e. could be wjf), but is normally stated as it. For example, if we have two functions in the class, and we try to call one variable, this could be messy (if you get it). Take this as an example:\n\nclass Person:\n  def __init__(self, name: str, age: int) -> str:\n    self.name = name\n    self.age = age\n\n  def myfunc(abc):\n    return abc.name\n\nAlso you can refer to here: https://www.w3schools.com/python/gloss_python_self.asp#:~:text=The%20self%20parameter%20is%20a,that%20belongs%20to%20the%20class."
                    },
                    {
                        "username": "jetroll2014",
                        "content": "Idk why this is wrong.\n\nIt is clear that my result is same with the expected.... But it's a wrong answer.\n\nIdk why!!! Please someone help me :( \n\nnum=3, Output:\"III\", Expected:\"III\"\nnum=58, Output:\"LVIII\", Expected:\"LVIII\"\n\n\n `class Solution {\npublic:\n    string intToRoman(int num) {\n        int value = 0;\n        int count=0;\n        string result;\n        result+='M'*(num/1000);\n        num%=1000;\n        int idx = num/100;\n        if(idx ==9){\n            result+=\"CM\";\n        }\n        else if(idx==4){\n            result+=\"CD\";\n        }\n        else\n        {result.append(idx/5, 'D');\n        result.append(idx%5, 'C');\n        }\n        num%=100;\n        idx = num/10;\n        if(idx==9){\n            result+=\"XC\";\n        }\n        else if(idx==4){\n            result+=\"XL\";\n        }\n        else\n        {result.append(idx/5, 'L');\n        result.append(idx%5, 'X');\n        }\n        num%=10;\n        if(num==9){\n            result+=\"IX\";\n        }\n        else if(num==4){\n            result+=\"IV\";\n        }\n        else\n        {\n            result.append(num/5, 'V');\n            result.append(num%5, 'I');\n        }\n        return result;\n    }\n};`"
                    },
                    {
                        "username": "EmreArslan",
                        "content": "As I said in this code's comment sections, your code sets 0th index of result string as null. If the value is smaller than 1000. Also, your code doesn't multiplicate the 'M' if the number is bigger than 1000.\n\nHere is the fixed code with comment sections that explains the situation:\n\n```\nclass Solution { \n    public: string intToRoman(int num) \n    { \n        int value = 0; \n        int count=0; \n        string result;\n\n        //In this line, the initial char of 'result' string can be Null\n        // result+='M'*(num/1000); \n\n        //So that, I deactivated this line and wrote this if conditional and while loop\n        if(num/1000){\n            while(num >= 1000){\n                result += 'M';\n                num-=1000;\n            }\n        };\n        \n        // num%=1000; \n        int idx = num/100; \n        if(idx ==9){ result+=\"CM\"; } \n        else if(idx==4){ result+=\"CD\"; } \n        else {\n            result.append(idx/5, 'D'); \n            result.append(idx%5, 'C'); \n        } \n        num%=100; \n        idx = num/10; \n        if(idx==9){ \n            result+=\"XC\"; \n        } \n        else if(idx==4){ \n            result+=\"XL\"; \n        } \n        else {\n            result.append(idx/5, 'L'); \n            result.append(idx%5, 'X'); \n        } \n        num%=10; \n        if(num==9){ \n            result+=\"IX\"; \n        } \n        else if(num==4){ \n            result+=\"IV\"; \n        } \n        else { \n            result.append(num/5, 'V'); \n            result.append(num%5, 'I'); \n        } \n        return result; \n    } \n};\n```\n\nI hope it helps you "
                    },
                    {
                        "username": "arpitagrawal09",
                        "content": "Quite interesting question! "
                    },
                    {
                        "username": "anamrani17",
                        "content": "/**\\n * @param {number} num\\n * @return {string}\\n */\\nvar intToRoman = function(num) {\\n    // step 1: create a lookup table\\n    const lookupTable = {\\n       O: [\\'\\', \\'I\\', \\'II\\', \\'III\\', \\'IV\\', \\'V\\', \\'VI\\', \\'VII\\', \\'VIII\\', \\'IX\\'],\\n        T: [\\'\\', \\'X\\', \\'XX\\', \\'XXX\\', \\'XL\\', \\'L\\', \\'LX\\', \\'LXX\\', \\'LXXX\\', \\'XC\\'],\\n        H : [\\'\\', \\'C\\', \\'CC\\', \\'CCC\\', \\'CD\\', \\'D\\', \\'DC\\', \\'DCC\\', \\'DCCC\\', \\'CM\\'],\\n        Th : [\\'\\', \\'M\\', \\'MM\\', \\'MMM\\']\\n    }\\nreturn lookupTable.Th[Math.floor(num/1000)] + lookupTable.H[Math.floor((num%1000)/100)] + lookupTable.T[Math.floor((num%100)/10)] + lookupTable.O[num%10];\\n    \\n};\\n\\nhere is my solution of JavaScript code.\\nthe main line of code is return statement the expands the number then extract each digit one by one.\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zbraven",
                        "content": "int bul(char ch,int value)\\n{\\n\\nswitch (ch)\\n{\\n    case \\'I\\':\\n        value += 1;\\n        break;\\n    case \\'V\\':\\n        value += 5;\\n        break;\\n    case \\'X\\':\\n        value += 10;\\n        break;\\n    case \\'L\\':\\n        value += 50;\\n        break;\\n    case \\'C\\':\\n        value += 100;\\n        break;\\n    case \\'D\\':\\n        value += 500;\\n        break;\\n    case \\'M\\':\\n        value += 1000;\\n            break;\\n }\\n    return value;\\n\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n\\nconsole.log(romanToInt(\"MCMXCIV\"));"
                    }
                ]
            },
            {
                "id": 2048280,
                "content": [
                    {
                        "username": "mukeshgupta_",
                        "content": "I think its easy question. On GFG this is a Basic Question."
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "The intuition behind it is just to go from highest value to the lowest possible and to add some special cases to the hash table.\n\nThat's it"
                    },
                    {
                        "username": "akotb3",
                        "content": "\\nthis is the code I wrote  I believe it should work but evertime i put into leetcode it is  just out putting a bunch of IIIIIIII an example of this is if the input is 58 it would print : \"IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII\"\\n\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        numdict = {1000:\"M\",\\n            900:\"CM\",\\n            500:\"D\",\\n            400:\"CD\",\\n            100:\"C\",\\n            90:\"XC\",\\n            50:\"L\",\\n            40:\"XL\",\\n            10:\"X\",\\n            9:\"IX\",\\n            5:\"V\",\\n            4:\"IV\",\\n            1:\"I\"\\n          }\\n        roman =\"\"\\n        for i in numdict.keys():\\n            while num >= i:\\n                num -= i\\n                roman += numdict[i]\\n            if num == 0:\\n                break\\n        return roman\\n\\nsolution = Solution()\\n\\n\\nresult = solution.intToRoman(1994)\\nprint(result)\\n\\n"
                    },
                    {
                        "username": "megan891685",
                        "content": "If I want to do this in c and not have memory leaks AND keep the compile time down, how should I return an array of char?\\nFor example.\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr =roman;\\n free(roman)\\n return arr; //will cause mem leaks\\n`\\n\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr;\\n  for(int i = 0; i < strlen(roman);i++){\\n arr[i] = roman[i];\\n}//going through for loop sounds like a giant waste.\\n free(roman)\\nreturn arr;\\n`"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Have to give this a like, it deserves the upvote, even though it left me with 3 failed attempts "
                    },
                    {
                        "username": "Nwarr_Desirs",
                        "content": "please bros i don\\'t undestand, what is self?? why do i need it? "
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "Self is something that 'represents' a function as a whole allowing you to access any variable inside the class, it doesn't have to be self (i.e. could be wjf), but is normally stated as it. For example, if we have two functions in the class, and we try to call one variable, this could be messy (if you get it). Take this as an example:\n\nclass Person:\n  def __init__(self, name: str, age: int) -> str:\n    self.name = name\n    self.age = age\n\n  def myfunc(abc):\n    return abc.name\n\nAlso you can refer to here: https://www.w3schools.com/python/gloss_python_self.asp#:~:text=The%20self%20parameter%20is%20a,that%20belongs%20to%20the%20class."
                    },
                    {
                        "username": "jetroll2014",
                        "content": "Idk why this is wrong.\n\nIt is clear that my result is same with the expected.... But it's a wrong answer.\n\nIdk why!!! Please someone help me :( \n\nnum=3, Output:\"III\", Expected:\"III\"\nnum=58, Output:\"LVIII\", Expected:\"LVIII\"\n\n\n `class Solution {\npublic:\n    string intToRoman(int num) {\n        int value = 0;\n        int count=0;\n        string result;\n        result+='M'*(num/1000);\n        num%=1000;\n        int idx = num/100;\n        if(idx ==9){\n            result+=\"CM\";\n        }\n        else if(idx==4){\n            result+=\"CD\";\n        }\n        else\n        {result.append(idx/5, 'D');\n        result.append(idx%5, 'C');\n        }\n        num%=100;\n        idx = num/10;\n        if(idx==9){\n            result+=\"XC\";\n        }\n        else if(idx==4){\n            result+=\"XL\";\n        }\n        else\n        {result.append(idx/5, 'L');\n        result.append(idx%5, 'X');\n        }\n        num%=10;\n        if(num==9){\n            result+=\"IX\";\n        }\n        else if(num==4){\n            result+=\"IV\";\n        }\n        else\n        {\n            result.append(num/5, 'V');\n            result.append(num%5, 'I');\n        }\n        return result;\n    }\n};`"
                    },
                    {
                        "username": "EmreArslan",
                        "content": "As I said in this code's comment sections, your code sets 0th index of result string as null. If the value is smaller than 1000. Also, your code doesn't multiplicate the 'M' if the number is bigger than 1000.\n\nHere is the fixed code with comment sections that explains the situation:\n\n```\nclass Solution { \n    public: string intToRoman(int num) \n    { \n        int value = 0; \n        int count=0; \n        string result;\n\n        //In this line, the initial char of 'result' string can be Null\n        // result+='M'*(num/1000); \n\n        //So that, I deactivated this line and wrote this if conditional and while loop\n        if(num/1000){\n            while(num >= 1000){\n                result += 'M';\n                num-=1000;\n            }\n        };\n        \n        // num%=1000; \n        int idx = num/100; \n        if(idx ==9){ result+=\"CM\"; } \n        else if(idx==4){ result+=\"CD\"; } \n        else {\n            result.append(idx/5, 'D'); \n            result.append(idx%5, 'C'); \n        } \n        num%=100; \n        idx = num/10; \n        if(idx==9){ \n            result+=\"XC\"; \n        } \n        else if(idx==4){ \n            result+=\"XL\"; \n        } \n        else {\n            result.append(idx/5, 'L'); \n            result.append(idx%5, 'X'); \n        } \n        num%=10; \n        if(num==9){ \n            result+=\"IX\"; \n        } \n        else if(num==4){ \n            result+=\"IV\"; \n        } \n        else { \n            result.append(num/5, 'V'); \n            result.append(num%5, 'I'); \n        } \n        return result; \n    } \n};\n```\n\nI hope it helps you "
                    },
                    {
                        "username": "arpitagrawal09",
                        "content": "Quite interesting question! "
                    },
                    {
                        "username": "anamrani17",
                        "content": "/**\\n * @param {number} num\\n * @return {string}\\n */\\nvar intToRoman = function(num) {\\n    // step 1: create a lookup table\\n    const lookupTable = {\\n       O: [\\'\\', \\'I\\', \\'II\\', \\'III\\', \\'IV\\', \\'V\\', \\'VI\\', \\'VII\\', \\'VIII\\', \\'IX\\'],\\n        T: [\\'\\', \\'X\\', \\'XX\\', \\'XXX\\', \\'XL\\', \\'L\\', \\'LX\\', \\'LXX\\', \\'LXXX\\', \\'XC\\'],\\n        H : [\\'\\', \\'C\\', \\'CC\\', \\'CCC\\', \\'CD\\', \\'D\\', \\'DC\\', \\'DCC\\', \\'DCCC\\', \\'CM\\'],\\n        Th : [\\'\\', \\'M\\', \\'MM\\', \\'MMM\\']\\n    }\\nreturn lookupTable.Th[Math.floor(num/1000)] + lookupTable.H[Math.floor((num%1000)/100)] + lookupTable.T[Math.floor((num%100)/10)] + lookupTable.O[num%10];\\n    \\n};\\n\\nhere is my solution of JavaScript code.\\nthe main line of code is return statement the expands the number then extract each digit one by one.\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zbraven",
                        "content": "int bul(char ch,int value)\\n{\\n\\nswitch (ch)\\n{\\n    case \\'I\\':\\n        value += 1;\\n        break;\\n    case \\'V\\':\\n        value += 5;\\n        break;\\n    case \\'X\\':\\n        value += 10;\\n        break;\\n    case \\'L\\':\\n        value += 50;\\n        break;\\n    case \\'C\\':\\n        value += 100;\\n        break;\\n    case \\'D\\':\\n        value += 500;\\n        break;\\n    case \\'M\\':\\n        value += 1000;\\n            break;\\n }\\n    return value;\\n\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n\\nconsole.log(romanToInt(\"MCMXCIV\"));"
                    }
                ]
            },
            {
                "id": 2038589,
                "content": [
                    {
                        "username": "mukeshgupta_",
                        "content": "I think its easy question. On GFG this is a Basic Question."
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "The intuition behind it is just to go from highest value to the lowest possible and to add some special cases to the hash table.\n\nThat's it"
                    },
                    {
                        "username": "akotb3",
                        "content": "\\nthis is the code I wrote  I believe it should work but evertime i put into leetcode it is  just out putting a bunch of IIIIIIII an example of this is if the input is 58 it would print : \"IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII\"\\n\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        numdict = {1000:\"M\",\\n            900:\"CM\",\\n            500:\"D\",\\n            400:\"CD\",\\n            100:\"C\",\\n            90:\"XC\",\\n            50:\"L\",\\n            40:\"XL\",\\n            10:\"X\",\\n            9:\"IX\",\\n            5:\"V\",\\n            4:\"IV\",\\n            1:\"I\"\\n          }\\n        roman =\"\"\\n        for i in numdict.keys():\\n            while num >= i:\\n                num -= i\\n                roman += numdict[i]\\n            if num == 0:\\n                break\\n        return roman\\n\\nsolution = Solution()\\n\\n\\nresult = solution.intToRoman(1994)\\nprint(result)\\n\\n"
                    },
                    {
                        "username": "megan891685",
                        "content": "If I want to do this in c and not have memory leaks AND keep the compile time down, how should I return an array of char?\\nFor example.\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr =roman;\\n free(roman)\\n return arr; //will cause mem leaks\\n`\\n\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr;\\n  for(int i = 0; i < strlen(roman);i++){\\n arr[i] = roman[i];\\n}//going through for loop sounds like a giant waste.\\n free(roman)\\nreturn arr;\\n`"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Have to give this a like, it deserves the upvote, even though it left me with 3 failed attempts "
                    },
                    {
                        "username": "Nwarr_Desirs",
                        "content": "please bros i don\\'t undestand, what is self?? why do i need it? "
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "Self is something that 'represents' a function as a whole allowing you to access any variable inside the class, it doesn't have to be self (i.e. could be wjf), but is normally stated as it. For example, if we have two functions in the class, and we try to call one variable, this could be messy (if you get it). Take this as an example:\n\nclass Person:\n  def __init__(self, name: str, age: int) -> str:\n    self.name = name\n    self.age = age\n\n  def myfunc(abc):\n    return abc.name\n\nAlso you can refer to here: https://www.w3schools.com/python/gloss_python_self.asp#:~:text=The%20self%20parameter%20is%20a,that%20belongs%20to%20the%20class."
                    },
                    {
                        "username": "jetroll2014",
                        "content": "Idk why this is wrong.\n\nIt is clear that my result is same with the expected.... But it's a wrong answer.\n\nIdk why!!! Please someone help me :( \n\nnum=3, Output:\"III\", Expected:\"III\"\nnum=58, Output:\"LVIII\", Expected:\"LVIII\"\n\n\n `class Solution {\npublic:\n    string intToRoman(int num) {\n        int value = 0;\n        int count=0;\n        string result;\n        result+='M'*(num/1000);\n        num%=1000;\n        int idx = num/100;\n        if(idx ==9){\n            result+=\"CM\";\n        }\n        else if(idx==4){\n            result+=\"CD\";\n        }\n        else\n        {result.append(idx/5, 'D');\n        result.append(idx%5, 'C');\n        }\n        num%=100;\n        idx = num/10;\n        if(idx==9){\n            result+=\"XC\";\n        }\n        else if(idx==4){\n            result+=\"XL\";\n        }\n        else\n        {result.append(idx/5, 'L');\n        result.append(idx%5, 'X');\n        }\n        num%=10;\n        if(num==9){\n            result+=\"IX\";\n        }\n        else if(num==4){\n            result+=\"IV\";\n        }\n        else\n        {\n            result.append(num/5, 'V');\n            result.append(num%5, 'I');\n        }\n        return result;\n    }\n};`"
                    },
                    {
                        "username": "EmreArslan",
                        "content": "As I said in this code's comment sections, your code sets 0th index of result string as null. If the value is smaller than 1000. Also, your code doesn't multiplicate the 'M' if the number is bigger than 1000.\n\nHere is the fixed code with comment sections that explains the situation:\n\n```\nclass Solution { \n    public: string intToRoman(int num) \n    { \n        int value = 0; \n        int count=0; \n        string result;\n\n        //In this line, the initial char of 'result' string can be Null\n        // result+='M'*(num/1000); \n\n        //So that, I deactivated this line and wrote this if conditional and while loop\n        if(num/1000){\n            while(num >= 1000){\n                result += 'M';\n                num-=1000;\n            }\n        };\n        \n        // num%=1000; \n        int idx = num/100; \n        if(idx ==9){ result+=\"CM\"; } \n        else if(idx==4){ result+=\"CD\"; } \n        else {\n            result.append(idx/5, 'D'); \n            result.append(idx%5, 'C'); \n        } \n        num%=100; \n        idx = num/10; \n        if(idx==9){ \n            result+=\"XC\"; \n        } \n        else if(idx==4){ \n            result+=\"XL\"; \n        } \n        else {\n            result.append(idx/5, 'L'); \n            result.append(idx%5, 'X'); \n        } \n        num%=10; \n        if(num==9){ \n            result+=\"IX\"; \n        } \n        else if(num==4){ \n            result+=\"IV\"; \n        } \n        else { \n            result.append(num/5, 'V'); \n            result.append(num%5, 'I'); \n        } \n        return result; \n    } \n};\n```\n\nI hope it helps you "
                    },
                    {
                        "username": "arpitagrawal09",
                        "content": "Quite interesting question! "
                    },
                    {
                        "username": "anamrani17",
                        "content": "/**\\n * @param {number} num\\n * @return {string}\\n */\\nvar intToRoman = function(num) {\\n    // step 1: create a lookup table\\n    const lookupTable = {\\n       O: [\\'\\', \\'I\\', \\'II\\', \\'III\\', \\'IV\\', \\'V\\', \\'VI\\', \\'VII\\', \\'VIII\\', \\'IX\\'],\\n        T: [\\'\\', \\'X\\', \\'XX\\', \\'XXX\\', \\'XL\\', \\'L\\', \\'LX\\', \\'LXX\\', \\'LXXX\\', \\'XC\\'],\\n        H : [\\'\\', \\'C\\', \\'CC\\', \\'CCC\\', \\'CD\\', \\'D\\', \\'DC\\', \\'DCC\\', \\'DCCC\\', \\'CM\\'],\\n        Th : [\\'\\', \\'M\\', \\'MM\\', \\'MMM\\']\\n    }\\nreturn lookupTable.Th[Math.floor(num/1000)] + lookupTable.H[Math.floor((num%1000)/100)] + lookupTable.T[Math.floor((num%100)/10)] + lookupTable.O[num%10];\\n    \\n};\\n\\nhere is my solution of JavaScript code.\\nthe main line of code is return statement the expands the number then extract each digit one by one.\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zbraven",
                        "content": "int bul(char ch,int value)\\n{\\n\\nswitch (ch)\\n{\\n    case \\'I\\':\\n        value += 1;\\n        break;\\n    case \\'V\\':\\n        value += 5;\\n        break;\\n    case \\'X\\':\\n        value += 10;\\n        break;\\n    case \\'L\\':\\n        value += 50;\\n        break;\\n    case \\'C\\':\\n        value += 100;\\n        break;\\n    case \\'D\\':\\n        value += 500;\\n        break;\\n    case \\'M\\':\\n        value += 1000;\\n            break;\\n }\\n    return value;\\n\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n\\nconsole.log(romanToInt(\"MCMXCIV\"));"
                    }
                ]
            },
            {
                "id": 1968531,
                "content": [
                    {
                        "username": "mukeshgupta_",
                        "content": "I think its easy question. On GFG this is a Basic Question."
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "The intuition behind it is just to go from highest value to the lowest possible and to add some special cases to the hash table.\n\nThat's it"
                    },
                    {
                        "username": "akotb3",
                        "content": "\\nthis is the code I wrote  I believe it should work but evertime i put into leetcode it is  just out putting a bunch of IIIIIIII an example of this is if the input is 58 it would print : \"IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII\"\\n\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        numdict = {1000:\"M\",\\n            900:\"CM\",\\n            500:\"D\",\\n            400:\"CD\",\\n            100:\"C\",\\n            90:\"XC\",\\n            50:\"L\",\\n            40:\"XL\",\\n            10:\"X\",\\n            9:\"IX\",\\n            5:\"V\",\\n            4:\"IV\",\\n            1:\"I\"\\n          }\\n        roman =\"\"\\n        for i in numdict.keys():\\n            while num >= i:\\n                num -= i\\n                roman += numdict[i]\\n            if num == 0:\\n                break\\n        return roman\\n\\nsolution = Solution()\\n\\n\\nresult = solution.intToRoman(1994)\\nprint(result)\\n\\n"
                    },
                    {
                        "username": "megan891685",
                        "content": "If I want to do this in c and not have memory leaks AND keep the compile time down, how should I return an array of char?\\nFor example.\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr =roman;\\n free(roman)\\n return arr; //will cause mem leaks\\n`\\n\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr;\\n  for(int i = 0; i < strlen(roman);i++){\\n arr[i] = roman[i];\\n}//going through for loop sounds like a giant waste.\\n free(roman)\\nreturn arr;\\n`"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Have to give this a like, it deserves the upvote, even though it left me with 3 failed attempts "
                    },
                    {
                        "username": "Nwarr_Desirs",
                        "content": "please bros i don\\'t undestand, what is self?? why do i need it? "
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "Self is something that 'represents' a function as a whole allowing you to access any variable inside the class, it doesn't have to be self (i.e. could be wjf), but is normally stated as it. For example, if we have two functions in the class, and we try to call one variable, this could be messy (if you get it). Take this as an example:\n\nclass Person:\n  def __init__(self, name: str, age: int) -> str:\n    self.name = name\n    self.age = age\n\n  def myfunc(abc):\n    return abc.name\n\nAlso you can refer to here: https://www.w3schools.com/python/gloss_python_self.asp#:~:text=The%20self%20parameter%20is%20a,that%20belongs%20to%20the%20class."
                    },
                    {
                        "username": "jetroll2014",
                        "content": "Idk why this is wrong.\n\nIt is clear that my result is same with the expected.... But it's a wrong answer.\n\nIdk why!!! Please someone help me :( \n\nnum=3, Output:\"III\", Expected:\"III\"\nnum=58, Output:\"LVIII\", Expected:\"LVIII\"\n\n\n `class Solution {\npublic:\n    string intToRoman(int num) {\n        int value = 0;\n        int count=0;\n        string result;\n        result+='M'*(num/1000);\n        num%=1000;\n        int idx = num/100;\n        if(idx ==9){\n            result+=\"CM\";\n        }\n        else if(idx==4){\n            result+=\"CD\";\n        }\n        else\n        {result.append(idx/5, 'D');\n        result.append(idx%5, 'C');\n        }\n        num%=100;\n        idx = num/10;\n        if(idx==9){\n            result+=\"XC\";\n        }\n        else if(idx==4){\n            result+=\"XL\";\n        }\n        else\n        {result.append(idx/5, 'L');\n        result.append(idx%5, 'X');\n        }\n        num%=10;\n        if(num==9){\n            result+=\"IX\";\n        }\n        else if(num==4){\n            result+=\"IV\";\n        }\n        else\n        {\n            result.append(num/5, 'V');\n            result.append(num%5, 'I');\n        }\n        return result;\n    }\n};`"
                    },
                    {
                        "username": "EmreArslan",
                        "content": "As I said in this code's comment sections, your code sets 0th index of result string as null. If the value is smaller than 1000. Also, your code doesn't multiplicate the 'M' if the number is bigger than 1000.\n\nHere is the fixed code with comment sections that explains the situation:\n\n```\nclass Solution { \n    public: string intToRoman(int num) \n    { \n        int value = 0; \n        int count=0; \n        string result;\n\n        //In this line, the initial char of 'result' string can be Null\n        // result+='M'*(num/1000); \n\n        //So that, I deactivated this line and wrote this if conditional and while loop\n        if(num/1000){\n            while(num >= 1000){\n                result += 'M';\n                num-=1000;\n            }\n        };\n        \n        // num%=1000; \n        int idx = num/100; \n        if(idx ==9){ result+=\"CM\"; } \n        else if(idx==4){ result+=\"CD\"; } \n        else {\n            result.append(idx/5, 'D'); \n            result.append(idx%5, 'C'); \n        } \n        num%=100; \n        idx = num/10; \n        if(idx==9){ \n            result+=\"XC\"; \n        } \n        else if(idx==4){ \n            result+=\"XL\"; \n        } \n        else {\n            result.append(idx/5, 'L'); \n            result.append(idx%5, 'X'); \n        } \n        num%=10; \n        if(num==9){ \n            result+=\"IX\"; \n        } \n        else if(num==4){ \n            result+=\"IV\"; \n        } \n        else { \n            result.append(num/5, 'V'); \n            result.append(num%5, 'I'); \n        } \n        return result; \n    } \n};\n```\n\nI hope it helps you "
                    },
                    {
                        "username": "arpitagrawal09",
                        "content": "Quite interesting question! "
                    },
                    {
                        "username": "anamrani17",
                        "content": "/**\\n * @param {number} num\\n * @return {string}\\n */\\nvar intToRoman = function(num) {\\n    // step 1: create a lookup table\\n    const lookupTable = {\\n       O: [\\'\\', \\'I\\', \\'II\\', \\'III\\', \\'IV\\', \\'V\\', \\'VI\\', \\'VII\\', \\'VIII\\', \\'IX\\'],\\n        T: [\\'\\', \\'X\\', \\'XX\\', \\'XXX\\', \\'XL\\', \\'L\\', \\'LX\\', \\'LXX\\', \\'LXXX\\', \\'XC\\'],\\n        H : [\\'\\', \\'C\\', \\'CC\\', \\'CCC\\', \\'CD\\', \\'D\\', \\'DC\\', \\'DCC\\', \\'DCCC\\', \\'CM\\'],\\n        Th : [\\'\\', \\'M\\', \\'MM\\', \\'MMM\\']\\n    }\\nreturn lookupTable.Th[Math.floor(num/1000)] + lookupTable.H[Math.floor((num%1000)/100)] + lookupTable.T[Math.floor((num%100)/10)] + lookupTable.O[num%10];\\n    \\n};\\n\\nhere is my solution of JavaScript code.\\nthe main line of code is return statement the expands the number then extract each digit one by one.\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zbraven",
                        "content": "int bul(char ch,int value)\\n{\\n\\nswitch (ch)\\n{\\n    case \\'I\\':\\n        value += 1;\\n        break;\\n    case \\'V\\':\\n        value += 5;\\n        break;\\n    case \\'X\\':\\n        value += 10;\\n        break;\\n    case \\'L\\':\\n        value += 50;\\n        break;\\n    case \\'C\\':\\n        value += 100;\\n        break;\\n    case \\'D\\':\\n        value += 500;\\n        break;\\n    case \\'M\\':\\n        value += 1000;\\n            break;\\n }\\n    return value;\\n\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n\\nconsole.log(romanToInt(\"MCMXCIV\"));"
                    }
                ]
            },
            {
                "id": 1964782,
                "content": [
                    {
                        "username": "mukeshgupta_",
                        "content": "I think its easy question. On GFG this is a Basic Question."
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "The intuition behind it is just to go from highest value to the lowest possible and to add some special cases to the hash table.\n\nThat's it"
                    },
                    {
                        "username": "akotb3",
                        "content": "\\nthis is the code I wrote  I believe it should work but evertime i put into leetcode it is  just out putting a bunch of IIIIIIII an example of this is if the input is 58 it would print : \"IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII\"\\n\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        numdict = {1000:\"M\",\\n            900:\"CM\",\\n            500:\"D\",\\n            400:\"CD\",\\n            100:\"C\",\\n            90:\"XC\",\\n            50:\"L\",\\n            40:\"XL\",\\n            10:\"X\",\\n            9:\"IX\",\\n            5:\"V\",\\n            4:\"IV\",\\n            1:\"I\"\\n          }\\n        roman =\"\"\\n        for i in numdict.keys():\\n            while num >= i:\\n                num -= i\\n                roman += numdict[i]\\n            if num == 0:\\n                break\\n        return roman\\n\\nsolution = Solution()\\n\\n\\nresult = solution.intToRoman(1994)\\nprint(result)\\n\\n"
                    },
                    {
                        "username": "megan891685",
                        "content": "If I want to do this in c and not have memory leaks AND keep the compile time down, how should I return an array of char?\\nFor example.\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr =roman;\\n free(roman)\\n return arr; //will cause mem leaks\\n`\\n\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr;\\n  for(int i = 0; i < strlen(roman);i++){\\n arr[i] = roman[i];\\n}//going through for loop sounds like a giant waste.\\n free(roman)\\nreturn arr;\\n`"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Have to give this a like, it deserves the upvote, even though it left me with 3 failed attempts "
                    },
                    {
                        "username": "Nwarr_Desirs",
                        "content": "please bros i don\\'t undestand, what is self?? why do i need it? "
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "Self is something that 'represents' a function as a whole allowing you to access any variable inside the class, it doesn't have to be self (i.e. could be wjf), but is normally stated as it. For example, if we have two functions in the class, and we try to call one variable, this could be messy (if you get it). Take this as an example:\n\nclass Person:\n  def __init__(self, name: str, age: int) -> str:\n    self.name = name\n    self.age = age\n\n  def myfunc(abc):\n    return abc.name\n\nAlso you can refer to here: https://www.w3schools.com/python/gloss_python_self.asp#:~:text=The%20self%20parameter%20is%20a,that%20belongs%20to%20the%20class."
                    },
                    {
                        "username": "jetroll2014",
                        "content": "Idk why this is wrong.\n\nIt is clear that my result is same with the expected.... But it's a wrong answer.\n\nIdk why!!! Please someone help me :( \n\nnum=3, Output:\"III\", Expected:\"III\"\nnum=58, Output:\"LVIII\", Expected:\"LVIII\"\n\n\n `class Solution {\npublic:\n    string intToRoman(int num) {\n        int value = 0;\n        int count=0;\n        string result;\n        result+='M'*(num/1000);\n        num%=1000;\n        int idx = num/100;\n        if(idx ==9){\n            result+=\"CM\";\n        }\n        else if(idx==4){\n            result+=\"CD\";\n        }\n        else\n        {result.append(idx/5, 'D');\n        result.append(idx%5, 'C');\n        }\n        num%=100;\n        idx = num/10;\n        if(idx==9){\n            result+=\"XC\";\n        }\n        else if(idx==4){\n            result+=\"XL\";\n        }\n        else\n        {result.append(idx/5, 'L');\n        result.append(idx%5, 'X');\n        }\n        num%=10;\n        if(num==9){\n            result+=\"IX\";\n        }\n        else if(num==4){\n            result+=\"IV\";\n        }\n        else\n        {\n            result.append(num/5, 'V');\n            result.append(num%5, 'I');\n        }\n        return result;\n    }\n};`"
                    },
                    {
                        "username": "EmreArslan",
                        "content": "As I said in this code's comment sections, your code sets 0th index of result string as null. If the value is smaller than 1000. Also, your code doesn't multiplicate the 'M' if the number is bigger than 1000.\n\nHere is the fixed code with comment sections that explains the situation:\n\n```\nclass Solution { \n    public: string intToRoman(int num) \n    { \n        int value = 0; \n        int count=0; \n        string result;\n\n        //In this line, the initial char of 'result' string can be Null\n        // result+='M'*(num/1000); \n\n        //So that, I deactivated this line and wrote this if conditional and while loop\n        if(num/1000){\n            while(num >= 1000){\n                result += 'M';\n                num-=1000;\n            }\n        };\n        \n        // num%=1000; \n        int idx = num/100; \n        if(idx ==9){ result+=\"CM\"; } \n        else if(idx==4){ result+=\"CD\"; } \n        else {\n            result.append(idx/5, 'D'); \n            result.append(idx%5, 'C'); \n        } \n        num%=100; \n        idx = num/10; \n        if(idx==9){ \n            result+=\"XC\"; \n        } \n        else if(idx==4){ \n            result+=\"XL\"; \n        } \n        else {\n            result.append(idx/5, 'L'); \n            result.append(idx%5, 'X'); \n        } \n        num%=10; \n        if(num==9){ \n            result+=\"IX\"; \n        } \n        else if(num==4){ \n            result+=\"IV\"; \n        } \n        else { \n            result.append(num/5, 'V'); \n            result.append(num%5, 'I'); \n        } \n        return result; \n    } \n};\n```\n\nI hope it helps you "
                    },
                    {
                        "username": "arpitagrawal09",
                        "content": "Quite interesting question! "
                    },
                    {
                        "username": "anamrani17",
                        "content": "/**\\n * @param {number} num\\n * @return {string}\\n */\\nvar intToRoman = function(num) {\\n    // step 1: create a lookup table\\n    const lookupTable = {\\n       O: [\\'\\', \\'I\\', \\'II\\', \\'III\\', \\'IV\\', \\'V\\', \\'VI\\', \\'VII\\', \\'VIII\\', \\'IX\\'],\\n        T: [\\'\\', \\'X\\', \\'XX\\', \\'XXX\\', \\'XL\\', \\'L\\', \\'LX\\', \\'LXX\\', \\'LXXX\\', \\'XC\\'],\\n        H : [\\'\\', \\'C\\', \\'CC\\', \\'CCC\\', \\'CD\\', \\'D\\', \\'DC\\', \\'DCC\\', \\'DCCC\\', \\'CM\\'],\\n        Th : [\\'\\', \\'M\\', \\'MM\\', \\'MMM\\']\\n    }\\nreturn lookupTable.Th[Math.floor(num/1000)] + lookupTable.H[Math.floor((num%1000)/100)] + lookupTable.T[Math.floor((num%100)/10)] + lookupTable.O[num%10];\\n    \\n};\\n\\nhere is my solution of JavaScript code.\\nthe main line of code is return statement the expands the number then extract each digit one by one.\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zbraven",
                        "content": "int bul(char ch,int value)\\n{\\n\\nswitch (ch)\\n{\\n    case \\'I\\':\\n        value += 1;\\n        break;\\n    case \\'V\\':\\n        value += 5;\\n        break;\\n    case \\'X\\':\\n        value += 10;\\n        break;\\n    case \\'L\\':\\n        value += 50;\\n        break;\\n    case \\'C\\':\\n        value += 100;\\n        break;\\n    case \\'D\\':\\n        value += 500;\\n        break;\\n    case \\'M\\':\\n        value += 1000;\\n            break;\\n }\\n    return value;\\n\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n\\nconsole.log(romanToInt(\"MCMXCIV\"));"
                    }
                ]
            },
            {
                "id": 1956594,
                "content": [
                    {
                        "username": "mukeshgupta_",
                        "content": "I think its easy question. On GFG this is a Basic Question."
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "The intuition behind it is just to go from highest value to the lowest possible and to add some special cases to the hash table.\n\nThat's it"
                    },
                    {
                        "username": "akotb3",
                        "content": "\\nthis is the code I wrote  I believe it should work but evertime i put into leetcode it is  just out putting a bunch of IIIIIIII an example of this is if the input is 58 it would print : \"IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII\"\\n\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        numdict = {1000:\"M\",\\n            900:\"CM\",\\n            500:\"D\",\\n            400:\"CD\",\\n            100:\"C\",\\n            90:\"XC\",\\n            50:\"L\",\\n            40:\"XL\",\\n            10:\"X\",\\n            9:\"IX\",\\n            5:\"V\",\\n            4:\"IV\",\\n            1:\"I\"\\n          }\\n        roman =\"\"\\n        for i in numdict.keys():\\n            while num >= i:\\n                num -= i\\n                roman += numdict[i]\\n            if num == 0:\\n                break\\n        return roman\\n\\nsolution = Solution()\\n\\n\\nresult = solution.intToRoman(1994)\\nprint(result)\\n\\n"
                    },
                    {
                        "username": "megan891685",
                        "content": "If I want to do this in c and not have memory leaks AND keep the compile time down, how should I return an array of char?\\nFor example.\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr =roman;\\n free(roman)\\n return arr; //will cause mem leaks\\n`\\n\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr;\\n  for(int i = 0; i < strlen(roman);i++){\\n arr[i] = roman[i];\\n}//going through for loop sounds like a giant waste.\\n free(roman)\\nreturn arr;\\n`"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Have to give this a like, it deserves the upvote, even though it left me with 3 failed attempts "
                    },
                    {
                        "username": "Nwarr_Desirs",
                        "content": "please bros i don\\'t undestand, what is self?? why do i need it? "
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "Self is something that 'represents' a function as a whole allowing you to access any variable inside the class, it doesn't have to be self (i.e. could be wjf), but is normally stated as it. For example, if we have two functions in the class, and we try to call one variable, this could be messy (if you get it). Take this as an example:\n\nclass Person:\n  def __init__(self, name: str, age: int) -> str:\n    self.name = name\n    self.age = age\n\n  def myfunc(abc):\n    return abc.name\n\nAlso you can refer to here: https://www.w3schools.com/python/gloss_python_self.asp#:~:text=The%20self%20parameter%20is%20a,that%20belongs%20to%20the%20class."
                    },
                    {
                        "username": "jetroll2014",
                        "content": "Idk why this is wrong.\n\nIt is clear that my result is same with the expected.... But it's a wrong answer.\n\nIdk why!!! Please someone help me :( \n\nnum=3, Output:\"III\", Expected:\"III\"\nnum=58, Output:\"LVIII\", Expected:\"LVIII\"\n\n\n `class Solution {\npublic:\n    string intToRoman(int num) {\n        int value = 0;\n        int count=0;\n        string result;\n        result+='M'*(num/1000);\n        num%=1000;\n        int idx = num/100;\n        if(idx ==9){\n            result+=\"CM\";\n        }\n        else if(idx==4){\n            result+=\"CD\";\n        }\n        else\n        {result.append(idx/5, 'D');\n        result.append(idx%5, 'C');\n        }\n        num%=100;\n        idx = num/10;\n        if(idx==9){\n            result+=\"XC\";\n        }\n        else if(idx==4){\n            result+=\"XL\";\n        }\n        else\n        {result.append(idx/5, 'L');\n        result.append(idx%5, 'X');\n        }\n        num%=10;\n        if(num==9){\n            result+=\"IX\";\n        }\n        else if(num==4){\n            result+=\"IV\";\n        }\n        else\n        {\n            result.append(num/5, 'V');\n            result.append(num%5, 'I');\n        }\n        return result;\n    }\n};`"
                    },
                    {
                        "username": "EmreArslan",
                        "content": "As I said in this code's comment sections, your code sets 0th index of result string as null. If the value is smaller than 1000. Also, your code doesn't multiplicate the 'M' if the number is bigger than 1000.\n\nHere is the fixed code with comment sections that explains the situation:\n\n```\nclass Solution { \n    public: string intToRoman(int num) \n    { \n        int value = 0; \n        int count=0; \n        string result;\n\n        //In this line, the initial char of 'result' string can be Null\n        // result+='M'*(num/1000); \n\n        //So that, I deactivated this line and wrote this if conditional and while loop\n        if(num/1000){\n            while(num >= 1000){\n                result += 'M';\n                num-=1000;\n            }\n        };\n        \n        // num%=1000; \n        int idx = num/100; \n        if(idx ==9){ result+=\"CM\"; } \n        else if(idx==4){ result+=\"CD\"; } \n        else {\n            result.append(idx/5, 'D'); \n            result.append(idx%5, 'C'); \n        } \n        num%=100; \n        idx = num/10; \n        if(idx==9){ \n            result+=\"XC\"; \n        } \n        else if(idx==4){ \n            result+=\"XL\"; \n        } \n        else {\n            result.append(idx/5, 'L'); \n            result.append(idx%5, 'X'); \n        } \n        num%=10; \n        if(num==9){ \n            result+=\"IX\"; \n        } \n        else if(num==4){ \n            result+=\"IV\"; \n        } \n        else { \n            result.append(num/5, 'V'); \n            result.append(num%5, 'I'); \n        } \n        return result; \n    } \n};\n```\n\nI hope it helps you "
                    },
                    {
                        "username": "arpitagrawal09",
                        "content": "Quite interesting question! "
                    },
                    {
                        "username": "anamrani17",
                        "content": "/**\\n * @param {number} num\\n * @return {string}\\n */\\nvar intToRoman = function(num) {\\n    // step 1: create a lookup table\\n    const lookupTable = {\\n       O: [\\'\\', \\'I\\', \\'II\\', \\'III\\', \\'IV\\', \\'V\\', \\'VI\\', \\'VII\\', \\'VIII\\', \\'IX\\'],\\n        T: [\\'\\', \\'X\\', \\'XX\\', \\'XXX\\', \\'XL\\', \\'L\\', \\'LX\\', \\'LXX\\', \\'LXXX\\', \\'XC\\'],\\n        H : [\\'\\', \\'C\\', \\'CC\\', \\'CCC\\', \\'CD\\', \\'D\\', \\'DC\\', \\'DCC\\', \\'DCCC\\', \\'CM\\'],\\n        Th : [\\'\\', \\'M\\', \\'MM\\', \\'MMM\\']\\n    }\\nreturn lookupTable.Th[Math.floor(num/1000)] + lookupTable.H[Math.floor((num%1000)/100)] + lookupTable.T[Math.floor((num%100)/10)] + lookupTable.O[num%10];\\n    \\n};\\n\\nhere is my solution of JavaScript code.\\nthe main line of code is return statement the expands the number then extract each digit one by one.\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zbraven",
                        "content": "int bul(char ch,int value)\\n{\\n\\nswitch (ch)\\n{\\n    case \\'I\\':\\n        value += 1;\\n        break;\\n    case \\'V\\':\\n        value += 5;\\n        break;\\n    case \\'X\\':\\n        value += 10;\\n        break;\\n    case \\'L\\':\\n        value += 50;\\n        break;\\n    case \\'C\\':\\n        value += 100;\\n        break;\\n    case \\'D\\':\\n        value += 500;\\n        break;\\n    case \\'M\\':\\n        value += 1000;\\n            break;\\n }\\n    return value;\\n\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n\\nconsole.log(romanToInt(\"MCMXCIV\"));"
                    }
                ]
            },
            {
                "id": 1887061,
                "content": [
                    {
                        "username": "mukeshgupta_",
                        "content": "I think its easy question. On GFG this is a Basic Question."
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "The intuition behind it is just to go from highest value to the lowest possible and to add some special cases to the hash table.\n\nThat's it"
                    },
                    {
                        "username": "akotb3",
                        "content": "\\nthis is the code I wrote  I believe it should work but evertime i put into leetcode it is  just out putting a bunch of IIIIIIII an example of this is if the input is 58 it would print : \"IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII\"\\n\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        numdict = {1000:\"M\",\\n            900:\"CM\",\\n            500:\"D\",\\n            400:\"CD\",\\n            100:\"C\",\\n            90:\"XC\",\\n            50:\"L\",\\n            40:\"XL\",\\n            10:\"X\",\\n            9:\"IX\",\\n            5:\"V\",\\n            4:\"IV\",\\n            1:\"I\"\\n          }\\n        roman =\"\"\\n        for i in numdict.keys():\\n            while num >= i:\\n                num -= i\\n                roman += numdict[i]\\n            if num == 0:\\n                break\\n        return roman\\n\\nsolution = Solution()\\n\\n\\nresult = solution.intToRoman(1994)\\nprint(result)\\n\\n"
                    },
                    {
                        "username": "megan891685",
                        "content": "If I want to do this in c and not have memory leaks AND keep the compile time down, how should I return an array of char?\\nFor example.\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr =roman;\\n free(roman)\\n return arr; //will cause mem leaks\\n`\\n\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr;\\n  for(int i = 0; i < strlen(roman);i++){\\n arr[i] = roman[i];\\n}//going through for loop sounds like a giant waste.\\n free(roman)\\nreturn arr;\\n`"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Have to give this a like, it deserves the upvote, even though it left me with 3 failed attempts "
                    },
                    {
                        "username": "Nwarr_Desirs",
                        "content": "please bros i don\\'t undestand, what is self?? why do i need it? "
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "Self is something that 'represents' a function as a whole allowing you to access any variable inside the class, it doesn't have to be self (i.e. could be wjf), but is normally stated as it. For example, if we have two functions in the class, and we try to call one variable, this could be messy (if you get it). Take this as an example:\n\nclass Person:\n  def __init__(self, name: str, age: int) -> str:\n    self.name = name\n    self.age = age\n\n  def myfunc(abc):\n    return abc.name\n\nAlso you can refer to here: https://www.w3schools.com/python/gloss_python_self.asp#:~:text=The%20self%20parameter%20is%20a,that%20belongs%20to%20the%20class."
                    },
                    {
                        "username": "jetroll2014",
                        "content": "Idk why this is wrong.\n\nIt is clear that my result is same with the expected.... But it's a wrong answer.\n\nIdk why!!! Please someone help me :( \n\nnum=3, Output:\"III\", Expected:\"III\"\nnum=58, Output:\"LVIII\", Expected:\"LVIII\"\n\n\n `class Solution {\npublic:\n    string intToRoman(int num) {\n        int value = 0;\n        int count=0;\n        string result;\n        result+='M'*(num/1000);\n        num%=1000;\n        int idx = num/100;\n        if(idx ==9){\n            result+=\"CM\";\n        }\n        else if(idx==4){\n            result+=\"CD\";\n        }\n        else\n        {result.append(idx/5, 'D');\n        result.append(idx%5, 'C');\n        }\n        num%=100;\n        idx = num/10;\n        if(idx==9){\n            result+=\"XC\";\n        }\n        else if(idx==4){\n            result+=\"XL\";\n        }\n        else\n        {result.append(idx/5, 'L');\n        result.append(idx%5, 'X');\n        }\n        num%=10;\n        if(num==9){\n            result+=\"IX\";\n        }\n        else if(num==4){\n            result+=\"IV\";\n        }\n        else\n        {\n            result.append(num/5, 'V');\n            result.append(num%5, 'I');\n        }\n        return result;\n    }\n};`"
                    },
                    {
                        "username": "EmreArslan",
                        "content": "As I said in this code's comment sections, your code sets 0th index of result string as null. If the value is smaller than 1000. Also, your code doesn't multiplicate the 'M' if the number is bigger than 1000.\n\nHere is the fixed code with comment sections that explains the situation:\n\n```\nclass Solution { \n    public: string intToRoman(int num) \n    { \n        int value = 0; \n        int count=0; \n        string result;\n\n        //In this line, the initial char of 'result' string can be Null\n        // result+='M'*(num/1000); \n\n        //So that, I deactivated this line and wrote this if conditional and while loop\n        if(num/1000){\n            while(num >= 1000){\n                result += 'M';\n                num-=1000;\n            }\n        };\n        \n        // num%=1000; \n        int idx = num/100; \n        if(idx ==9){ result+=\"CM\"; } \n        else if(idx==4){ result+=\"CD\"; } \n        else {\n            result.append(idx/5, 'D'); \n            result.append(idx%5, 'C'); \n        } \n        num%=100; \n        idx = num/10; \n        if(idx==9){ \n            result+=\"XC\"; \n        } \n        else if(idx==4){ \n            result+=\"XL\"; \n        } \n        else {\n            result.append(idx/5, 'L'); \n            result.append(idx%5, 'X'); \n        } \n        num%=10; \n        if(num==9){ \n            result+=\"IX\"; \n        } \n        else if(num==4){ \n            result+=\"IV\"; \n        } \n        else { \n            result.append(num/5, 'V'); \n            result.append(num%5, 'I'); \n        } \n        return result; \n    } \n};\n```\n\nI hope it helps you "
                    },
                    {
                        "username": "arpitagrawal09",
                        "content": "Quite interesting question! "
                    },
                    {
                        "username": "anamrani17",
                        "content": "/**\\n * @param {number} num\\n * @return {string}\\n */\\nvar intToRoman = function(num) {\\n    // step 1: create a lookup table\\n    const lookupTable = {\\n       O: [\\'\\', \\'I\\', \\'II\\', \\'III\\', \\'IV\\', \\'V\\', \\'VI\\', \\'VII\\', \\'VIII\\', \\'IX\\'],\\n        T: [\\'\\', \\'X\\', \\'XX\\', \\'XXX\\', \\'XL\\', \\'L\\', \\'LX\\', \\'LXX\\', \\'LXXX\\', \\'XC\\'],\\n        H : [\\'\\', \\'C\\', \\'CC\\', \\'CCC\\', \\'CD\\', \\'D\\', \\'DC\\', \\'DCC\\', \\'DCCC\\', \\'CM\\'],\\n        Th : [\\'\\', \\'M\\', \\'MM\\', \\'MMM\\']\\n    }\\nreturn lookupTable.Th[Math.floor(num/1000)] + lookupTable.H[Math.floor((num%1000)/100)] + lookupTable.T[Math.floor((num%100)/10)] + lookupTable.O[num%10];\\n    \\n};\\n\\nhere is my solution of JavaScript code.\\nthe main line of code is return statement the expands the number then extract each digit one by one.\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zbraven",
                        "content": "int bul(char ch,int value)\\n{\\n\\nswitch (ch)\\n{\\n    case \\'I\\':\\n        value += 1;\\n        break;\\n    case \\'V\\':\\n        value += 5;\\n        break;\\n    case \\'X\\':\\n        value += 10;\\n        break;\\n    case \\'L\\':\\n        value += 50;\\n        break;\\n    case \\'C\\':\\n        value += 100;\\n        break;\\n    case \\'D\\':\\n        value += 500;\\n        break;\\n    case \\'M\\':\\n        value += 1000;\\n            break;\\n }\\n    return value;\\n\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n\\nconsole.log(romanToInt(\"MCMXCIV\"));"
                    }
                ]
            },
            {
                "id": 1865905,
                "content": [
                    {
                        "username": "mukeshgupta_",
                        "content": "I think its easy question. On GFG this is a Basic Question."
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "The intuition behind it is just to go from highest value to the lowest possible and to add some special cases to the hash table.\n\nThat's it"
                    },
                    {
                        "username": "akotb3",
                        "content": "\\nthis is the code I wrote  I believe it should work but evertime i put into leetcode it is  just out putting a bunch of IIIIIIII an example of this is if the input is 58 it would print : \"IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII\"\\n\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        numdict = {1000:\"M\",\\n            900:\"CM\",\\n            500:\"D\",\\n            400:\"CD\",\\n            100:\"C\",\\n            90:\"XC\",\\n            50:\"L\",\\n            40:\"XL\",\\n            10:\"X\",\\n            9:\"IX\",\\n            5:\"V\",\\n            4:\"IV\",\\n            1:\"I\"\\n          }\\n        roman =\"\"\\n        for i in numdict.keys():\\n            while num >= i:\\n                num -= i\\n                roman += numdict[i]\\n            if num == 0:\\n                break\\n        return roman\\n\\nsolution = Solution()\\n\\n\\nresult = solution.intToRoman(1994)\\nprint(result)\\n\\n"
                    },
                    {
                        "username": "megan891685",
                        "content": "If I want to do this in c and not have memory leaks AND keep the compile time down, how should I return an array of char?\\nFor example.\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr =roman;\\n free(roman)\\n return arr; //will cause mem leaks\\n`\\n\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr;\\n  for(int i = 0; i < strlen(roman);i++){\\n arr[i] = roman[i];\\n}//going through for loop sounds like a giant waste.\\n free(roman)\\nreturn arr;\\n`"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Have to give this a like, it deserves the upvote, even though it left me with 3 failed attempts "
                    },
                    {
                        "username": "Nwarr_Desirs",
                        "content": "please bros i don\\'t undestand, what is self?? why do i need it? "
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "Self is something that 'represents' a function as a whole allowing you to access any variable inside the class, it doesn't have to be self (i.e. could be wjf), but is normally stated as it. For example, if we have two functions in the class, and we try to call one variable, this could be messy (if you get it). Take this as an example:\n\nclass Person:\n  def __init__(self, name: str, age: int) -> str:\n    self.name = name\n    self.age = age\n\n  def myfunc(abc):\n    return abc.name\n\nAlso you can refer to here: https://www.w3schools.com/python/gloss_python_self.asp#:~:text=The%20self%20parameter%20is%20a,that%20belongs%20to%20the%20class."
                    },
                    {
                        "username": "jetroll2014",
                        "content": "Idk why this is wrong.\n\nIt is clear that my result is same with the expected.... But it's a wrong answer.\n\nIdk why!!! Please someone help me :( \n\nnum=3, Output:\"III\", Expected:\"III\"\nnum=58, Output:\"LVIII\", Expected:\"LVIII\"\n\n\n `class Solution {\npublic:\n    string intToRoman(int num) {\n        int value = 0;\n        int count=0;\n        string result;\n        result+='M'*(num/1000);\n        num%=1000;\n        int idx = num/100;\n        if(idx ==9){\n            result+=\"CM\";\n        }\n        else if(idx==4){\n            result+=\"CD\";\n        }\n        else\n        {result.append(idx/5, 'D');\n        result.append(idx%5, 'C');\n        }\n        num%=100;\n        idx = num/10;\n        if(idx==9){\n            result+=\"XC\";\n        }\n        else if(idx==4){\n            result+=\"XL\";\n        }\n        else\n        {result.append(idx/5, 'L');\n        result.append(idx%5, 'X');\n        }\n        num%=10;\n        if(num==9){\n            result+=\"IX\";\n        }\n        else if(num==4){\n            result+=\"IV\";\n        }\n        else\n        {\n            result.append(num/5, 'V');\n            result.append(num%5, 'I');\n        }\n        return result;\n    }\n};`"
                    },
                    {
                        "username": "EmreArslan",
                        "content": "As I said in this code's comment sections, your code sets 0th index of result string as null. If the value is smaller than 1000. Also, your code doesn't multiplicate the 'M' if the number is bigger than 1000.\n\nHere is the fixed code with comment sections that explains the situation:\n\n```\nclass Solution { \n    public: string intToRoman(int num) \n    { \n        int value = 0; \n        int count=0; \n        string result;\n\n        //In this line, the initial char of 'result' string can be Null\n        // result+='M'*(num/1000); \n\n        //So that, I deactivated this line and wrote this if conditional and while loop\n        if(num/1000){\n            while(num >= 1000){\n                result += 'M';\n                num-=1000;\n            }\n        };\n        \n        // num%=1000; \n        int idx = num/100; \n        if(idx ==9){ result+=\"CM\"; } \n        else if(idx==4){ result+=\"CD\"; } \n        else {\n            result.append(idx/5, 'D'); \n            result.append(idx%5, 'C'); \n        } \n        num%=100; \n        idx = num/10; \n        if(idx==9){ \n            result+=\"XC\"; \n        } \n        else if(idx==4){ \n            result+=\"XL\"; \n        } \n        else {\n            result.append(idx/5, 'L'); \n            result.append(idx%5, 'X'); \n        } \n        num%=10; \n        if(num==9){ \n            result+=\"IX\"; \n        } \n        else if(num==4){ \n            result+=\"IV\"; \n        } \n        else { \n            result.append(num/5, 'V'); \n            result.append(num%5, 'I'); \n        } \n        return result; \n    } \n};\n```\n\nI hope it helps you "
                    },
                    {
                        "username": "arpitagrawal09",
                        "content": "Quite interesting question! "
                    },
                    {
                        "username": "anamrani17",
                        "content": "/**\\n * @param {number} num\\n * @return {string}\\n */\\nvar intToRoman = function(num) {\\n    // step 1: create a lookup table\\n    const lookupTable = {\\n       O: [\\'\\', \\'I\\', \\'II\\', \\'III\\', \\'IV\\', \\'V\\', \\'VI\\', \\'VII\\', \\'VIII\\', \\'IX\\'],\\n        T: [\\'\\', \\'X\\', \\'XX\\', \\'XXX\\', \\'XL\\', \\'L\\', \\'LX\\', \\'LXX\\', \\'LXXX\\', \\'XC\\'],\\n        H : [\\'\\', \\'C\\', \\'CC\\', \\'CCC\\', \\'CD\\', \\'D\\', \\'DC\\', \\'DCC\\', \\'DCCC\\', \\'CM\\'],\\n        Th : [\\'\\', \\'M\\', \\'MM\\', \\'MMM\\']\\n    }\\nreturn lookupTable.Th[Math.floor(num/1000)] + lookupTable.H[Math.floor((num%1000)/100)] + lookupTable.T[Math.floor((num%100)/10)] + lookupTable.O[num%10];\\n    \\n};\\n\\nhere is my solution of JavaScript code.\\nthe main line of code is return statement the expands the number then extract each digit one by one.\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zbraven",
                        "content": "int bul(char ch,int value)\\n{\\n\\nswitch (ch)\\n{\\n    case \\'I\\':\\n        value += 1;\\n        break;\\n    case \\'V\\':\\n        value += 5;\\n        break;\\n    case \\'X\\':\\n        value += 10;\\n        break;\\n    case \\'L\\':\\n        value += 50;\\n        break;\\n    case \\'C\\':\\n        value += 100;\\n        break;\\n    case \\'D\\':\\n        value += 500;\\n        break;\\n    case \\'M\\':\\n        value += 1000;\\n            break;\\n }\\n    return value;\\n\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n\\nconsole.log(romanToInt(\"MCMXCIV\"));"
                    }
                ]
            },
            {
                "id": 1818404,
                "content": [
                    {
                        "username": "mukeshgupta_",
                        "content": "I think its easy question. On GFG this is a Basic Question."
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "The intuition behind it is just to go from highest value to the lowest possible and to add some special cases to the hash table.\n\nThat's it"
                    },
                    {
                        "username": "akotb3",
                        "content": "\\nthis is the code I wrote  I believe it should work but evertime i put into leetcode it is  just out putting a bunch of IIIIIIII an example of this is if the input is 58 it would print : \"IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII\"\\n\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        numdict = {1000:\"M\",\\n            900:\"CM\",\\n            500:\"D\",\\n            400:\"CD\",\\n            100:\"C\",\\n            90:\"XC\",\\n            50:\"L\",\\n            40:\"XL\",\\n            10:\"X\",\\n            9:\"IX\",\\n            5:\"V\",\\n            4:\"IV\",\\n            1:\"I\"\\n          }\\n        roman =\"\"\\n        for i in numdict.keys():\\n            while num >= i:\\n                num -= i\\n                roman += numdict[i]\\n            if num == 0:\\n                break\\n        return roman\\n\\nsolution = Solution()\\n\\n\\nresult = solution.intToRoman(1994)\\nprint(result)\\n\\n"
                    },
                    {
                        "username": "megan891685",
                        "content": "If I want to do this in c and not have memory leaks AND keep the compile time down, how should I return an array of char?\\nFor example.\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr =roman;\\n free(roman)\\n return arr; //will cause mem leaks\\n`\\n\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr;\\n  for(int i = 0; i < strlen(roman);i++){\\n arr[i] = roman[i];\\n}//going through for loop sounds like a giant waste.\\n free(roman)\\nreturn arr;\\n`"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Have to give this a like, it deserves the upvote, even though it left me with 3 failed attempts "
                    },
                    {
                        "username": "Nwarr_Desirs",
                        "content": "please bros i don\\'t undestand, what is self?? why do i need it? "
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "Self is something that 'represents' a function as a whole allowing you to access any variable inside the class, it doesn't have to be self (i.e. could be wjf), but is normally stated as it. For example, if we have two functions in the class, and we try to call one variable, this could be messy (if you get it). Take this as an example:\n\nclass Person:\n  def __init__(self, name: str, age: int) -> str:\n    self.name = name\n    self.age = age\n\n  def myfunc(abc):\n    return abc.name\n\nAlso you can refer to here: https://www.w3schools.com/python/gloss_python_self.asp#:~:text=The%20self%20parameter%20is%20a,that%20belongs%20to%20the%20class."
                    },
                    {
                        "username": "jetroll2014",
                        "content": "Idk why this is wrong.\n\nIt is clear that my result is same with the expected.... But it's a wrong answer.\n\nIdk why!!! Please someone help me :( \n\nnum=3, Output:\"III\", Expected:\"III\"\nnum=58, Output:\"LVIII\", Expected:\"LVIII\"\n\n\n `class Solution {\npublic:\n    string intToRoman(int num) {\n        int value = 0;\n        int count=0;\n        string result;\n        result+='M'*(num/1000);\n        num%=1000;\n        int idx = num/100;\n        if(idx ==9){\n            result+=\"CM\";\n        }\n        else if(idx==4){\n            result+=\"CD\";\n        }\n        else\n        {result.append(idx/5, 'D');\n        result.append(idx%5, 'C');\n        }\n        num%=100;\n        idx = num/10;\n        if(idx==9){\n            result+=\"XC\";\n        }\n        else if(idx==4){\n            result+=\"XL\";\n        }\n        else\n        {result.append(idx/5, 'L');\n        result.append(idx%5, 'X');\n        }\n        num%=10;\n        if(num==9){\n            result+=\"IX\";\n        }\n        else if(num==4){\n            result+=\"IV\";\n        }\n        else\n        {\n            result.append(num/5, 'V');\n            result.append(num%5, 'I');\n        }\n        return result;\n    }\n};`"
                    },
                    {
                        "username": "EmreArslan",
                        "content": "As I said in this code's comment sections, your code sets 0th index of result string as null. If the value is smaller than 1000. Also, your code doesn't multiplicate the 'M' if the number is bigger than 1000.\n\nHere is the fixed code with comment sections that explains the situation:\n\n```\nclass Solution { \n    public: string intToRoman(int num) \n    { \n        int value = 0; \n        int count=0; \n        string result;\n\n        //In this line, the initial char of 'result' string can be Null\n        // result+='M'*(num/1000); \n\n        //So that, I deactivated this line and wrote this if conditional and while loop\n        if(num/1000){\n            while(num >= 1000){\n                result += 'M';\n                num-=1000;\n            }\n        };\n        \n        // num%=1000; \n        int idx = num/100; \n        if(idx ==9){ result+=\"CM\"; } \n        else if(idx==4){ result+=\"CD\"; } \n        else {\n            result.append(idx/5, 'D'); \n            result.append(idx%5, 'C'); \n        } \n        num%=100; \n        idx = num/10; \n        if(idx==9){ \n            result+=\"XC\"; \n        } \n        else if(idx==4){ \n            result+=\"XL\"; \n        } \n        else {\n            result.append(idx/5, 'L'); \n            result.append(idx%5, 'X'); \n        } \n        num%=10; \n        if(num==9){ \n            result+=\"IX\"; \n        } \n        else if(num==4){ \n            result+=\"IV\"; \n        } \n        else { \n            result.append(num/5, 'V'); \n            result.append(num%5, 'I'); \n        } \n        return result; \n    } \n};\n```\n\nI hope it helps you "
                    },
                    {
                        "username": "arpitagrawal09",
                        "content": "Quite interesting question! "
                    },
                    {
                        "username": "anamrani17",
                        "content": "/**\\n * @param {number} num\\n * @return {string}\\n */\\nvar intToRoman = function(num) {\\n    // step 1: create a lookup table\\n    const lookupTable = {\\n       O: [\\'\\', \\'I\\', \\'II\\', \\'III\\', \\'IV\\', \\'V\\', \\'VI\\', \\'VII\\', \\'VIII\\', \\'IX\\'],\\n        T: [\\'\\', \\'X\\', \\'XX\\', \\'XXX\\', \\'XL\\', \\'L\\', \\'LX\\', \\'LXX\\', \\'LXXX\\', \\'XC\\'],\\n        H : [\\'\\', \\'C\\', \\'CC\\', \\'CCC\\', \\'CD\\', \\'D\\', \\'DC\\', \\'DCC\\', \\'DCCC\\', \\'CM\\'],\\n        Th : [\\'\\', \\'M\\', \\'MM\\', \\'MMM\\']\\n    }\\nreturn lookupTable.Th[Math.floor(num/1000)] + lookupTable.H[Math.floor((num%1000)/100)] + lookupTable.T[Math.floor((num%100)/10)] + lookupTable.O[num%10];\\n    \\n};\\n\\nhere is my solution of JavaScript code.\\nthe main line of code is return statement the expands the number then extract each digit one by one.\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zbraven",
                        "content": "int bul(char ch,int value)\\n{\\n\\nswitch (ch)\\n{\\n    case \\'I\\':\\n        value += 1;\\n        break;\\n    case \\'V\\':\\n        value += 5;\\n        break;\\n    case \\'X\\':\\n        value += 10;\\n        break;\\n    case \\'L\\':\\n        value += 50;\\n        break;\\n    case \\'C\\':\\n        value += 100;\\n        break;\\n    case \\'D\\':\\n        value += 500;\\n        break;\\n    case \\'M\\':\\n        value += 1000;\\n            break;\\n }\\n    return value;\\n\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n\\nconsole.log(romanToInt(\"MCMXCIV\"));"
                    }
                ]
            },
            {
                "id": 1804156,
                "content": [
                    {
                        "username": "haduong825",
                        "content": "Here is my stupid solution \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\n `class Solution {\\n  String intToRoman(int num) {\\n    final oneMap = {1: \"I\", 10: \"X\", 100: \"C\", 1000: \"M\"};\\n    final fiveMap = {5: \"V\", 50: \"L\", 500: \"D\"};\\n    final inputStr =\\n        num.toString().split(\\'\\').reversed.map((e) => int.parse(e)).toList();\\n    var outputArray = List<String>.empty(growable: true);\\n    for (int i = 0; i < inputStr.length; i++) {\\n      if (inputStr[i] * pow(10, i) < (5 * pow(10, i) - pow(10, i))) {\\n        for (int j = 0; j < inputStr[i]; j++) {\\n          outputArray.add(oneMap[pow(10, i)] ?? \"\");\\n        }\\n      } else if (inputStr[i] * pow(10, i) < 9 * pow(10, i) &&\\n          inputStr[i] * pow(10, i) != (4 * pow(10, i))) {\\n        var tmpStr = \"\";\\n        tmpStr += fiveMap[5 * pow(10, i)] ?? \"\";\\n        for (int j = 0; j < inputStr[i] - 5; j++) {\\n          tmpStr += oneMap[pow(10, i)] ?? \"\";\\n        }\\n\\n        outputArray.add(tmpStr);\\n      } else if (inputStr[i] * pow(10, i) == (4 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${fiveMap[5 * pow(10, i)]}\");\\n      } else if (inputStr[i] * pow(10, i) == (9 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${oneMap[pow(10, i + 1)]}\");\\n      } else if (inputStr[i] * pow(10, (i + 1)) == (5 * pow(10, (i + 1)))) {\\n        outputArray.add(fiveMap[5 * pow(10, i)] ?? \"\");\\n      }\\n    }\\n\\n    return outputArray.reversed.reduce((value, element) => value + element);\\n  }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nAnd here are the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "maj-oliveira",
                        "content": "what is the complexity of this code?\\n\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d = {1000:\\'M\\',900:\\'CM\\',500:\\'D\\',400:\\'CD\\',100:\\'C\\',90:\\'XC\\',50:\\'L\\',40:\\'XL\\',10:\\'X\\',9:\\'IX\\',5:\\'V\\',4:\\'IV\\',1:\\'I\\'}\\n        result = \"\"\\n\\n        while num !=0:\\n            for key in d:\\n                if key<=num or key==1:\\n                    div = num // key\\n                    for i in range(div):\\n                        result = result + d[key]\\n                    num = num % key\\n\\n        return result"
                    },
                    {
                        "username": "boy19970722",
                        "content": "can someone exmplain why 200 is LLLL instead of CC where 20 is XX instead of VVVV?"
                    },
                    {
                        "username": "jamesTheCoder",
                        "content": "200 is CC. Largest possible. "
                    },
                    {
                        "username": "adnanitzer",
                        "content": "Here is an easy way in JS, find the first number >= the result, add its symbol and substract it then continue\n `let roman = \"M\".repeat(parseInt(num/1000));\n    num = num%1000;\n    const nums = ['900', '500','400','100', '90','50',  '40',  '10', '9', '5','4', '1']\n    const rom = [\"CM\", 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n    for (let i in nums){\n        while (num>=nums[i]){\n            roman+=rom[i]\n            num-=nums[i]\n        }\n    }\n    return roman;`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "RASWQQW",
                        "content": "Can we this code but its shown as incorrect in testcase\n\n`\n\n\n        _dict = {1000: \"M\", 500: \"D\", 100: \"C\", 50: \"L\", 10: \"X\", 5: \"V\", 1: \"I\"}\n        # print(dict(reversed(list(_dict.items()))))\n\n        _digitLen = len(str(num))\n        num = str(num)[::-1]\n        dar = 1\n        text = ''\n        for elem in str(num):\n            elem = int(elem) * dar\n            for key, value in _dict.items():\n\n                if int(elem) == key:\n                    text+= value; break\n\n                elif int(elem) % key == 0:\n                    for _ in range(int(elem / dar)):\n                        text+=value\n\n                    break\n\n                elif 3 * dar >= int(elem) % key > 0 and int(elem) % key != elem:\n                    for ss in range(int(int(elem) % key / dar)):\n                        text+=_dict[dar]\n                    text += value\n                    break\n\n                elif int(elem) + dar == key:\n                    text+=value+_dict[dar]; \n                    \n                    break\n\n            dar *= 10\n\n        return text[::-1] `\n\n\n\n\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "hsthanh00",
                        "content": "var roman = \"\";\\nfunction divided(num,romanNum){\\n    roman += romanNum ;\\n    if(num <= 0){\\n        return roman;\\n    }\\n    if( num>=1000){\\n        var romanNumber = \"M\".repeat(num/1000);\\n       return divided(num%1000,romanNumber)\\n    }\\n    if(num >= 900){\\n        var romanNumber = \"CM\".repeat(num/900);\\n       return divided(num%900,romanNumber)\\n    }\\n    if(num>=500){\\n        \\n        var romanNumber = \"D\".repeat(num/500);\\n        return divided(num%500,romanNumber)\\n    }\\n    if(num >= 400){\\n         var romanNumber = \"CD\".repeat(num/400);\\n        return divided(num%400,romanNumber)\\n    }\\n    if(num>=100){\\n        var romanNumber = \"C\".repeat(num/100);\\n        return divided(num%100,romanNumber)\\n    }\\n    if(num>=90){\\n         var romanNumber = \"XC\".repeat(num/90);\\n        return divided(num%90,romanNumber)\\n    }\\n    if(num>=50){\\n        var romanNumber = \"L\".repeat(num/50);\\n        return divided(num%50,romanNumber)\\n    }\\n    if(num>=40){\\n         var romanNumber = \"XL\".repeat(num/40);\\n        return divided(num%40,romanNumber)\\n    }\\n    \\n    if(num>=10){\\n        var romanNumber = \"X\".repeat(num/10);\\n        return divided(num%10,romanNumber)\\n    }\\n    if(num>=9){\\n         var romanNumber = \"IX\".repeat(num/9);\\n        return divided(num%9,romanNumber)\\n    }\\n     if(num>=5){\\n        var romanNumber = \"V\".repeat(num/5);\\n        return  divided(num%5,romanNumber)\\n    }\\n    if(num>=4){\\n         var romanNumber = \"IV\".repeat(num/4);\\n        return divided(num%4,romanNumber)\\n    }\\n     if(num>=1){\\n        var romanNumber = \"I\".repeat(num/1);\\n        return divided(num%1,romanNumber)\\n    }\\n    return roman; \\n}\\n\\nvar intToRoman = function(num) {\\n var roman = divided(num,\"\");\\n return roman \\n};\\n// how does it work when i code it on visual studio code but at \"leetcode\" it\\'s wrong. @@\\n"
                    },
                    {
                        "username": "RohitAgarwal08",
                        "content": "Explanation in Hindi\\n\\nhttps://youtu.be/fh5Q-2TvQwo"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1802501,
                "content": [
                    {
                        "username": "haduong825",
                        "content": "Here is my stupid solution \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\n `class Solution {\\n  String intToRoman(int num) {\\n    final oneMap = {1: \"I\", 10: \"X\", 100: \"C\", 1000: \"M\"};\\n    final fiveMap = {5: \"V\", 50: \"L\", 500: \"D\"};\\n    final inputStr =\\n        num.toString().split(\\'\\').reversed.map((e) => int.parse(e)).toList();\\n    var outputArray = List<String>.empty(growable: true);\\n    for (int i = 0; i < inputStr.length; i++) {\\n      if (inputStr[i] * pow(10, i) < (5 * pow(10, i) - pow(10, i))) {\\n        for (int j = 0; j < inputStr[i]; j++) {\\n          outputArray.add(oneMap[pow(10, i)] ?? \"\");\\n        }\\n      } else if (inputStr[i] * pow(10, i) < 9 * pow(10, i) &&\\n          inputStr[i] * pow(10, i) != (4 * pow(10, i))) {\\n        var tmpStr = \"\";\\n        tmpStr += fiveMap[5 * pow(10, i)] ?? \"\";\\n        for (int j = 0; j < inputStr[i] - 5; j++) {\\n          tmpStr += oneMap[pow(10, i)] ?? \"\";\\n        }\\n\\n        outputArray.add(tmpStr);\\n      } else if (inputStr[i] * pow(10, i) == (4 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${fiveMap[5 * pow(10, i)]}\");\\n      } else if (inputStr[i] * pow(10, i) == (9 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${oneMap[pow(10, i + 1)]}\");\\n      } else if (inputStr[i] * pow(10, (i + 1)) == (5 * pow(10, (i + 1)))) {\\n        outputArray.add(fiveMap[5 * pow(10, i)] ?? \"\");\\n      }\\n    }\\n\\n    return outputArray.reversed.reduce((value, element) => value + element);\\n  }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nAnd here are the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "maj-oliveira",
                        "content": "what is the complexity of this code?\\n\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d = {1000:\\'M\\',900:\\'CM\\',500:\\'D\\',400:\\'CD\\',100:\\'C\\',90:\\'XC\\',50:\\'L\\',40:\\'XL\\',10:\\'X\\',9:\\'IX\\',5:\\'V\\',4:\\'IV\\',1:\\'I\\'}\\n        result = \"\"\\n\\n        while num !=0:\\n            for key in d:\\n                if key<=num or key==1:\\n                    div = num // key\\n                    for i in range(div):\\n                        result = result + d[key]\\n                    num = num % key\\n\\n        return result"
                    },
                    {
                        "username": "boy19970722",
                        "content": "can someone exmplain why 200 is LLLL instead of CC where 20 is XX instead of VVVV?"
                    },
                    {
                        "username": "jamesTheCoder",
                        "content": "200 is CC. Largest possible. "
                    },
                    {
                        "username": "adnanitzer",
                        "content": "Here is an easy way in JS, find the first number >= the result, add its symbol and substract it then continue\n `let roman = \"M\".repeat(parseInt(num/1000));\n    num = num%1000;\n    const nums = ['900', '500','400','100', '90','50',  '40',  '10', '9', '5','4', '1']\n    const rom = [\"CM\", 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n    for (let i in nums){\n        while (num>=nums[i]){\n            roman+=rom[i]\n            num-=nums[i]\n        }\n    }\n    return roman;`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "RASWQQW",
                        "content": "Can we this code but its shown as incorrect in testcase\n\n`\n\n\n        _dict = {1000: \"M\", 500: \"D\", 100: \"C\", 50: \"L\", 10: \"X\", 5: \"V\", 1: \"I\"}\n        # print(dict(reversed(list(_dict.items()))))\n\n        _digitLen = len(str(num))\n        num = str(num)[::-1]\n        dar = 1\n        text = ''\n        for elem in str(num):\n            elem = int(elem) * dar\n            for key, value in _dict.items():\n\n                if int(elem) == key:\n                    text+= value; break\n\n                elif int(elem) % key == 0:\n                    for _ in range(int(elem / dar)):\n                        text+=value\n\n                    break\n\n                elif 3 * dar >= int(elem) % key > 0 and int(elem) % key != elem:\n                    for ss in range(int(int(elem) % key / dar)):\n                        text+=_dict[dar]\n                    text += value\n                    break\n\n                elif int(elem) + dar == key:\n                    text+=value+_dict[dar]; \n                    \n                    break\n\n            dar *= 10\n\n        return text[::-1] `\n\n\n\n\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "hsthanh00",
                        "content": "var roman = \"\";\\nfunction divided(num,romanNum){\\n    roman += romanNum ;\\n    if(num <= 0){\\n        return roman;\\n    }\\n    if( num>=1000){\\n        var romanNumber = \"M\".repeat(num/1000);\\n       return divided(num%1000,romanNumber)\\n    }\\n    if(num >= 900){\\n        var romanNumber = \"CM\".repeat(num/900);\\n       return divided(num%900,romanNumber)\\n    }\\n    if(num>=500){\\n        \\n        var romanNumber = \"D\".repeat(num/500);\\n        return divided(num%500,romanNumber)\\n    }\\n    if(num >= 400){\\n         var romanNumber = \"CD\".repeat(num/400);\\n        return divided(num%400,romanNumber)\\n    }\\n    if(num>=100){\\n        var romanNumber = \"C\".repeat(num/100);\\n        return divided(num%100,romanNumber)\\n    }\\n    if(num>=90){\\n         var romanNumber = \"XC\".repeat(num/90);\\n        return divided(num%90,romanNumber)\\n    }\\n    if(num>=50){\\n        var romanNumber = \"L\".repeat(num/50);\\n        return divided(num%50,romanNumber)\\n    }\\n    if(num>=40){\\n         var romanNumber = \"XL\".repeat(num/40);\\n        return divided(num%40,romanNumber)\\n    }\\n    \\n    if(num>=10){\\n        var romanNumber = \"X\".repeat(num/10);\\n        return divided(num%10,romanNumber)\\n    }\\n    if(num>=9){\\n         var romanNumber = \"IX\".repeat(num/9);\\n        return divided(num%9,romanNumber)\\n    }\\n     if(num>=5){\\n        var romanNumber = \"V\".repeat(num/5);\\n        return  divided(num%5,romanNumber)\\n    }\\n    if(num>=4){\\n         var romanNumber = \"IV\".repeat(num/4);\\n        return divided(num%4,romanNumber)\\n    }\\n     if(num>=1){\\n        var romanNumber = \"I\".repeat(num/1);\\n        return divided(num%1,romanNumber)\\n    }\\n    return roman; \\n}\\n\\nvar intToRoman = function(num) {\\n var roman = divided(num,\"\");\\n return roman \\n};\\n// how does it work when i code it on visual studio code but at \"leetcode\" it\\'s wrong. @@\\n"
                    },
                    {
                        "username": "RohitAgarwal08",
                        "content": "Explanation in Hindi\\n\\nhttps://youtu.be/fh5Q-2TvQwo"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1799735,
                "content": [
                    {
                        "username": "haduong825",
                        "content": "Here is my stupid solution \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\n `class Solution {\\n  String intToRoman(int num) {\\n    final oneMap = {1: \"I\", 10: \"X\", 100: \"C\", 1000: \"M\"};\\n    final fiveMap = {5: \"V\", 50: \"L\", 500: \"D\"};\\n    final inputStr =\\n        num.toString().split(\\'\\').reversed.map((e) => int.parse(e)).toList();\\n    var outputArray = List<String>.empty(growable: true);\\n    for (int i = 0; i < inputStr.length; i++) {\\n      if (inputStr[i] * pow(10, i) < (5 * pow(10, i) - pow(10, i))) {\\n        for (int j = 0; j < inputStr[i]; j++) {\\n          outputArray.add(oneMap[pow(10, i)] ?? \"\");\\n        }\\n      } else if (inputStr[i] * pow(10, i) < 9 * pow(10, i) &&\\n          inputStr[i] * pow(10, i) != (4 * pow(10, i))) {\\n        var tmpStr = \"\";\\n        tmpStr += fiveMap[5 * pow(10, i)] ?? \"\";\\n        for (int j = 0; j < inputStr[i] - 5; j++) {\\n          tmpStr += oneMap[pow(10, i)] ?? \"\";\\n        }\\n\\n        outputArray.add(tmpStr);\\n      } else if (inputStr[i] * pow(10, i) == (4 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${fiveMap[5 * pow(10, i)]}\");\\n      } else if (inputStr[i] * pow(10, i) == (9 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${oneMap[pow(10, i + 1)]}\");\\n      } else if (inputStr[i] * pow(10, (i + 1)) == (5 * pow(10, (i + 1)))) {\\n        outputArray.add(fiveMap[5 * pow(10, i)] ?? \"\");\\n      }\\n    }\\n\\n    return outputArray.reversed.reduce((value, element) => value + element);\\n  }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nAnd here are the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "maj-oliveira",
                        "content": "what is the complexity of this code?\\n\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d = {1000:\\'M\\',900:\\'CM\\',500:\\'D\\',400:\\'CD\\',100:\\'C\\',90:\\'XC\\',50:\\'L\\',40:\\'XL\\',10:\\'X\\',9:\\'IX\\',5:\\'V\\',4:\\'IV\\',1:\\'I\\'}\\n        result = \"\"\\n\\n        while num !=0:\\n            for key in d:\\n                if key<=num or key==1:\\n                    div = num // key\\n                    for i in range(div):\\n                        result = result + d[key]\\n                    num = num % key\\n\\n        return result"
                    },
                    {
                        "username": "boy19970722",
                        "content": "can someone exmplain why 200 is LLLL instead of CC where 20 is XX instead of VVVV?"
                    },
                    {
                        "username": "jamesTheCoder",
                        "content": "200 is CC. Largest possible. "
                    },
                    {
                        "username": "adnanitzer",
                        "content": "Here is an easy way in JS, find the first number >= the result, add its symbol and substract it then continue\n `let roman = \"M\".repeat(parseInt(num/1000));\n    num = num%1000;\n    const nums = ['900', '500','400','100', '90','50',  '40',  '10', '9', '5','4', '1']\n    const rom = [\"CM\", 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n    for (let i in nums){\n        while (num>=nums[i]){\n            roman+=rom[i]\n            num-=nums[i]\n        }\n    }\n    return roman;`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "RASWQQW",
                        "content": "Can we this code but its shown as incorrect in testcase\n\n`\n\n\n        _dict = {1000: \"M\", 500: \"D\", 100: \"C\", 50: \"L\", 10: \"X\", 5: \"V\", 1: \"I\"}\n        # print(dict(reversed(list(_dict.items()))))\n\n        _digitLen = len(str(num))\n        num = str(num)[::-1]\n        dar = 1\n        text = ''\n        for elem in str(num):\n            elem = int(elem) * dar\n            for key, value in _dict.items():\n\n                if int(elem) == key:\n                    text+= value; break\n\n                elif int(elem) % key == 0:\n                    for _ in range(int(elem / dar)):\n                        text+=value\n\n                    break\n\n                elif 3 * dar >= int(elem) % key > 0 and int(elem) % key != elem:\n                    for ss in range(int(int(elem) % key / dar)):\n                        text+=_dict[dar]\n                    text += value\n                    break\n\n                elif int(elem) + dar == key:\n                    text+=value+_dict[dar]; \n                    \n                    break\n\n            dar *= 10\n\n        return text[::-1] `\n\n\n\n\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "hsthanh00",
                        "content": "var roman = \"\";\\nfunction divided(num,romanNum){\\n    roman += romanNum ;\\n    if(num <= 0){\\n        return roman;\\n    }\\n    if( num>=1000){\\n        var romanNumber = \"M\".repeat(num/1000);\\n       return divided(num%1000,romanNumber)\\n    }\\n    if(num >= 900){\\n        var romanNumber = \"CM\".repeat(num/900);\\n       return divided(num%900,romanNumber)\\n    }\\n    if(num>=500){\\n        \\n        var romanNumber = \"D\".repeat(num/500);\\n        return divided(num%500,romanNumber)\\n    }\\n    if(num >= 400){\\n         var romanNumber = \"CD\".repeat(num/400);\\n        return divided(num%400,romanNumber)\\n    }\\n    if(num>=100){\\n        var romanNumber = \"C\".repeat(num/100);\\n        return divided(num%100,romanNumber)\\n    }\\n    if(num>=90){\\n         var romanNumber = \"XC\".repeat(num/90);\\n        return divided(num%90,romanNumber)\\n    }\\n    if(num>=50){\\n        var romanNumber = \"L\".repeat(num/50);\\n        return divided(num%50,romanNumber)\\n    }\\n    if(num>=40){\\n         var romanNumber = \"XL\".repeat(num/40);\\n        return divided(num%40,romanNumber)\\n    }\\n    \\n    if(num>=10){\\n        var romanNumber = \"X\".repeat(num/10);\\n        return divided(num%10,romanNumber)\\n    }\\n    if(num>=9){\\n         var romanNumber = \"IX\".repeat(num/9);\\n        return divided(num%9,romanNumber)\\n    }\\n     if(num>=5){\\n        var romanNumber = \"V\".repeat(num/5);\\n        return  divided(num%5,romanNumber)\\n    }\\n    if(num>=4){\\n         var romanNumber = \"IV\".repeat(num/4);\\n        return divided(num%4,romanNumber)\\n    }\\n     if(num>=1){\\n        var romanNumber = \"I\".repeat(num/1);\\n        return divided(num%1,romanNumber)\\n    }\\n    return roman; \\n}\\n\\nvar intToRoman = function(num) {\\n var roman = divided(num,\"\");\\n return roman \\n};\\n// how does it work when i code it on visual studio code but at \"leetcode\" it\\'s wrong. @@\\n"
                    },
                    {
                        "username": "RohitAgarwal08",
                        "content": "Explanation in Hindi\\n\\nhttps://youtu.be/fh5Q-2TvQwo"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1776009,
                "content": [
                    {
                        "username": "haduong825",
                        "content": "Here is my stupid solution \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\n `class Solution {\\n  String intToRoman(int num) {\\n    final oneMap = {1: \"I\", 10: \"X\", 100: \"C\", 1000: \"M\"};\\n    final fiveMap = {5: \"V\", 50: \"L\", 500: \"D\"};\\n    final inputStr =\\n        num.toString().split(\\'\\').reversed.map((e) => int.parse(e)).toList();\\n    var outputArray = List<String>.empty(growable: true);\\n    for (int i = 0; i < inputStr.length; i++) {\\n      if (inputStr[i] * pow(10, i) < (5 * pow(10, i) - pow(10, i))) {\\n        for (int j = 0; j < inputStr[i]; j++) {\\n          outputArray.add(oneMap[pow(10, i)] ?? \"\");\\n        }\\n      } else if (inputStr[i] * pow(10, i) < 9 * pow(10, i) &&\\n          inputStr[i] * pow(10, i) != (4 * pow(10, i))) {\\n        var tmpStr = \"\";\\n        tmpStr += fiveMap[5 * pow(10, i)] ?? \"\";\\n        for (int j = 0; j < inputStr[i] - 5; j++) {\\n          tmpStr += oneMap[pow(10, i)] ?? \"\";\\n        }\\n\\n        outputArray.add(tmpStr);\\n      } else if (inputStr[i] * pow(10, i) == (4 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${fiveMap[5 * pow(10, i)]}\");\\n      } else if (inputStr[i] * pow(10, i) == (9 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${oneMap[pow(10, i + 1)]}\");\\n      } else if (inputStr[i] * pow(10, (i + 1)) == (5 * pow(10, (i + 1)))) {\\n        outputArray.add(fiveMap[5 * pow(10, i)] ?? \"\");\\n      }\\n    }\\n\\n    return outputArray.reversed.reduce((value, element) => value + element);\\n  }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nAnd here are the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "maj-oliveira",
                        "content": "what is the complexity of this code?\\n\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d = {1000:\\'M\\',900:\\'CM\\',500:\\'D\\',400:\\'CD\\',100:\\'C\\',90:\\'XC\\',50:\\'L\\',40:\\'XL\\',10:\\'X\\',9:\\'IX\\',5:\\'V\\',4:\\'IV\\',1:\\'I\\'}\\n        result = \"\"\\n\\n        while num !=0:\\n            for key in d:\\n                if key<=num or key==1:\\n                    div = num // key\\n                    for i in range(div):\\n                        result = result + d[key]\\n                    num = num % key\\n\\n        return result"
                    },
                    {
                        "username": "boy19970722",
                        "content": "can someone exmplain why 200 is LLLL instead of CC where 20 is XX instead of VVVV?"
                    },
                    {
                        "username": "jamesTheCoder",
                        "content": "200 is CC. Largest possible. "
                    },
                    {
                        "username": "adnanitzer",
                        "content": "Here is an easy way in JS, find the first number >= the result, add its symbol and substract it then continue\n `let roman = \"M\".repeat(parseInt(num/1000));\n    num = num%1000;\n    const nums = ['900', '500','400','100', '90','50',  '40',  '10', '9', '5','4', '1']\n    const rom = [\"CM\", 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n    for (let i in nums){\n        while (num>=nums[i]){\n            roman+=rom[i]\n            num-=nums[i]\n        }\n    }\n    return roman;`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "RASWQQW",
                        "content": "Can we this code but its shown as incorrect in testcase\n\n`\n\n\n        _dict = {1000: \"M\", 500: \"D\", 100: \"C\", 50: \"L\", 10: \"X\", 5: \"V\", 1: \"I\"}\n        # print(dict(reversed(list(_dict.items()))))\n\n        _digitLen = len(str(num))\n        num = str(num)[::-1]\n        dar = 1\n        text = ''\n        for elem in str(num):\n            elem = int(elem) * dar\n            for key, value in _dict.items():\n\n                if int(elem) == key:\n                    text+= value; break\n\n                elif int(elem) % key == 0:\n                    for _ in range(int(elem / dar)):\n                        text+=value\n\n                    break\n\n                elif 3 * dar >= int(elem) % key > 0 and int(elem) % key != elem:\n                    for ss in range(int(int(elem) % key / dar)):\n                        text+=_dict[dar]\n                    text += value\n                    break\n\n                elif int(elem) + dar == key:\n                    text+=value+_dict[dar]; \n                    \n                    break\n\n            dar *= 10\n\n        return text[::-1] `\n\n\n\n\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "hsthanh00",
                        "content": "var roman = \"\";\\nfunction divided(num,romanNum){\\n    roman += romanNum ;\\n    if(num <= 0){\\n        return roman;\\n    }\\n    if( num>=1000){\\n        var romanNumber = \"M\".repeat(num/1000);\\n       return divided(num%1000,romanNumber)\\n    }\\n    if(num >= 900){\\n        var romanNumber = \"CM\".repeat(num/900);\\n       return divided(num%900,romanNumber)\\n    }\\n    if(num>=500){\\n        \\n        var romanNumber = \"D\".repeat(num/500);\\n        return divided(num%500,romanNumber)\\n    }\\n    if(num >= 400){\\n         var romanNumber = \"CD\".repeat(num/400);\\n        return divided(num%400,romanNumber)\\n    }\\n    if(num>=100){\\n        var romanNumber = \"C\".repeat(num/100);\\n        return divided(num%100,romanNumber)\\n    }\\n    if(num>=90){\\n         var romanNumber = \"XC\".repeat(num/90);\\n        return divided(num%90,romanNumber)\\n    }\\n    if(num>=50){\\n        var romanNumber = \"L\".repeat(num/50);\\n        return divided(num%50,romanNumber)\\n    }\\n    if(num>=40){\\n         var romanNumber = \"XL\".repeat(num/40);\\n        return divided(num%40,romanNumber)\\n    }\\n    \\n    if(num>=10){\\n        var romanNumber = \"X\".repeat(num/10);\\n        return divided(num%10,romanNumber)\\n    }\\n    if(num>=9){\\n         var romanNumber = \"IX\".repeat(num/9);\\n        return divided(num%9,romanNumber)\\n    }\\n     if(num>=5){\\n        var romanNumber = \"V\".repeat(num/5);\\n        return  divided(num%5,romanNumber)\\n    }\\n    if(num>=4){\\n         var romanNumber = \"IV\".repeat(num/4);\\n        return divided(num%4,romanNumber)\\n    }\\n     if(num>=1){\\n        var romanNumber = \"I\".repeat(num/1);\\n        return divided(num%1,romanNumber)\\n    }\\n    return roman; \\n}\\n\\nvar intToRoman = function(num) {\\n var roman = divided(num,\"\");\\n return roman \\n};\\n// how does it work when i code it on visual studio code but at \"leetcode\" it\\'s wrong. @@\\n"
                    },
                    {
                        "username": "RohitAgarwal08",
                        "content": "Explanation in Hindi\\n\\nhttps://youtu.be/fh5Q-2TvQwo"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1768434,
                "content": [
                    {
                        "username": "haduong825",
                        "content": "Here is my stupid solution \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\n `class Solution {\\n  String intToRoman(int num) {\\n    final oneMap = {1: \"I\", 10: \"X\", 100: \"C\", 1000: \"M\"};\\n    final fiveMap = {5: \"V\", 50: \"L\", 500: \"D\"};\\n    final inputStr =\\n        num.toString().split(\\'\\').reversed.map((e) => int.parse(e)).toList();\\n    var outputArray = List<String>.empty(growable: true);\\n    for (int i = 0; i < inputStr.length; i++) {\\n      if (inputStr[i] * pow(10, i) < (5 * pow(10, i) - pow(10, i))) {\\n        for (int j = 0; j < inputStr[i]; j++) {\\n          outputArray.add(oneMap[pow(10, i)] ?? \"\");\\n        }\\n      } else if (inputStr[i] * pow(10, i) < 9 * pow(10, i) &&\\n          inputStr[i] * pow(10, i) != (4 * pow(10, i))) {\\n        var tmpStr = \"\";\\n        tmpStr += fiveMap[5 * pow(10, i)] ?? \"\";\\n        for (int j = 0; j < inputStr[i] - 5; j++) {\\n          tmpStr += oneMap[pow(10, i)] ?? \"\";\\n        }\\n\\n        outputArray.add(tmpStr);\\n      } else if (inputStr[i] * pow(10, i) == (4 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${fiveMap[5 * pow(10, i)]}\");\\n      } else if (inputStr[i] * pow(10, i) == (9 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${oneMap[pow(10, i + 1)]}\");\\n      } else if (inputStr[i] * pow(10, (i + 1)) == (5 * pow(10, (i + 1)))) {\\n        outputArray.add(fiveMap[5 * pow(10, i)] ?? \"\");\\n      }\\n    }\\n\\n    return outputArray.reversed.reduce((value, element) => value + element);\\n  }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nAnd here are the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "maj-oliveira",
                        "content": "what is the complexity of this code?\\n\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d = {1000:\\'M\\',900:\\'CM\\',500:\\'D\\',400:\\'CD\\',100:\\'C\\',90:\\'XC\\',50:\\'L\\',40:\\'XL\\',10:\\'X\\',9:\\'IX\\',5:\\'V\\',4:\\'IV\\',1:\\'I\\'}\\n        result = \"\"\\n\\n        while num !=0:\\n            for key in d:\\n                if key<=num or key==1:\\n                    div = num // key\\n                    for i in range(div):\\n                        result = result + d[key]\\n                    num = num % key\\n\\n        return result"
                    },
                    {
                        "username": "boy19970722",
                        "content": "can someone exmplain why 200 is LLLL instead of CC where 20 is XX instead of VVVV?"
                    },
                    {
                        "username": "jamesTheCoder",
                        "content": "200 is CC. Largest possible. "
                    },
                    {
                        "username": "adnanitzer",
                        "content": "Here is an easy way in JS, find the first number >= the result, add its symbol and substract it then continue\n `let roman = \"M\".repeat(parseInt(num/1000));\n    num = num%1000;\n    const nums = ['900', '500','400','100', '90','50',  '40',  '10', '9', '5','4', '1']\n    const rom = [\"CM\", 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n    for (let i in nums){\n        while (num>=nums[i]){\n            roman+=rom[i]\n            num-=nums[i]\n        }\n    }\n    return roman;`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "RASWQQW",
                        "content": "Can we this code but its shown as incorrect in testcase\n\n`\n\n\n        _dict = {1000: \"M\", 500: \"D\", 100: \"C\", 50: \"L\", 10: \"X\", 5: \"V\", 1: \"I\"}\n        # print(dict(reversed(list(_dict.items()))))\n\n        _digitLen = len(str(num))\n        num = str(num)[::-1]\n        dar = 1\n        text = ''\n        for elem in str(num):\n            elem = int(elem) * dar\n            for key, value in _dict.items():\n\n                if int(elem) == key:\n                    text+= value; break\n\n                elif int(elem) % key == 0:\n                    for _ in range(int(elem / dar)):\n                        text+=value\n\n                    break\n\n                elif 3 * dar >= int(elem) % key > 0 and int(elem) % key != elem:\n                    for ss in range(int(int(elem) % key / dar)):\n                        text+=_dict[dar]\n                    text += value\n                    break\n\n                elif int(elem) + dar == key:\n                    text+=value+_dict[dar]; \n                    \n                    break\n\n            dar *= 10\n\n        return text[::-1] `\n\n\n\n\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "hsthanh00",
                        "content": "var roman = \"\";\\nfunction divided(num,romanNum){\\n    roman += romanNum ;\\n    if(num <= 0){\\n        return roman;\\n    }\\n    if( num>=1000){\\n        var romanNumber = \"M\".repeat(num/1000);\\n       return divided(num%1000,romanNumber)\\n    }\\n    if(num >= 900){\\n        var romanNumber = \"CM\".repeat(num/900);\\n       return divided(num%900,romanNumber)\\n    }\\n    if(num>=500){\\n        \\n        var romanNumber = \"D\".repeat(num/500);\\n        return divided(num%500,romanNumber)\\n    }\\n    if(num >= 400){\\n         var romanNumber = \"CD\".repeat(num/400);\\n        return divided(num%400,romanNumber)\\n    }\\n    if(num>=100){\\n        var romanNumber = \"C\".repeat(num/100);\\n        return divided(num%100,romanNumber)\\n    }\\n    if(num>=90){\\n         var romanNumber = \"XC\".repeat(num/90);\\n        return divided(num%90,romanNumber)\\n    }\\n    if(num>=50){\\n        var romanNumber = \"L\".repeat(num/50);\\n        return divided(num%50,romanNumber)\\n    }\\n    if(num>=40){\\n         var romanNumber = \"XL\".repeat(num/40);\\n        return divided(num%40,romanNumber)\\n    }\\n    \\n    if(num>=10){\\n        var romanNumber = \"X\".repeat(num/10);\\n        return divided(num%10,romanNumber)\\n    }\\n    if(num>=9){\\n         var romanNumber = \"IX\".repeat(num/9);\\n        return divided(num%9,romanNumber)\\n    }\\n     if(num>=5){\\n        var romanNumber = \"V\".repeat(num/5);\\n        return  divided(num%5,romanNumber)\\n    }\\n    if(num>=4){\\n         var romanNumber = \"IV\".repeat(num/4);\\n        return divided(num%4,romanNumber)\\n    }\\n     if(num>=1){\\n        var romanNumber = \"I\".repeat(num/1);\\n        return divided(num%1,romanNumber)\\n    }\\n    return roman; \\n}\\n\\nvar intToRoman = function(num) {\\n var roman = divided(num,\"\");\\n return roman \\n};\\n// how does it work when i code it on visual studio code but at \"leetcode\" it\\'s wrong. @@\\n"
                    },
                    {
                        "username": "RohitAgarwal08",
                        "content": "Explanation in Hindi\\n\\nhttps://youtu.be/fh5Q-2TvQwo"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1766388,
                "content": [
                    {
                        "username": "haduong825",
                        "content": "Here is my stupid solution \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\n `class Solution {\\n  String intToRoman(int num) {\\n    final oneMap = {1: \"I\", 10: \"X\", 100: \"C\", 1000: \"M\"};\\n    final fiveMap = {5: \"V\", 50: \"L\", 500: \"D\"};\\n    final inputStr =\\n        num.toString().split(\\'\\').reversed.map((e) => int.parse(e)).toList();\\n    var outputArray = List<String>.empty(growable: true);\\n    for (int i = 0; i < inputStr.length; i++) {\\n      if (inputStr[i] * pow(10, i) < (5 * pow(10, i) - pow(10, i))) {\\n        for (int j = 0; j < inputStr[i]; j++) {\\n          outputArray.add(oneMap[pow(10, i)] ?? \"\");\\n        }\\n      } else if (inputStr[i] * pow(10, i) < 9 * pow(10, i) &&\\n          inputStr[i] * pow(10, i) != (4 * pow(10, i))) {\\n        var tmpStr = \"\";\\n        tmpStr += fiveMap[5 * pow(10, i)] ?? \"\";\\n        for (int j = 0; j < inputStr[i] - 5; j++) {\\n          tmpStr += oneMap[pow(10, i)] ?? \"\";\\n        }\\n\\n        outputArray.add(tmpStr);\\n      } else if (inputStr[i] * pow(10, i) == (4 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${fiveMap[5 * pow(10, i)]}\");\\n      } else if (inputStr[i] * pow(10, i) == (9 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${oneMap[pow(10, i + 1)]}\");\\n      } else if (inputStr[i] * pow(10, (i + 1)) == (5 * pow(10, (i + 1)))) {\\n        outputArray.add(fiveMap[5 * pow(10, i)] ?? \"\");\\n      }\\n    }\\n\\n    return outputArray.reversed.reduce((value, element) => value + element);\\n  }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nAnd here are the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "maj-oliveira",
                        "content": "what is the complexity of this code?\\n\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d = {1000:\\'M\\',900:\\'CM\\',500:\\'D\\',400:\\'CD\\',100:\\'C\\',90:\\'XC\\',50:\\'L\\',40:\\'XL\\',10:\\'X\\',9:\\'IX\\',5:\\'V\\',4:\\'IV\\',1:\\'I\\'}\\n        result = \"\"\\n\\n        while num !=0:\\n            for key in d:\\n                if key<=num or key==1:\\n                    div = num // key\\n                    for i in range(div):\\n                        result = result + d[key]\\n                    num = num % key\\n\\n        return result"
                    },
                    {
                        "username": "boy19970722",
                        "content": "can someone exmplain why 200 is LLLL instead of CC where 20 is XX instead of VVVV?"
                    },
                    {
                        "username": "jamesTheCoder",
                        "content": "200 is CC. Largest possible. "
                    },
                    {
                        "username": "adnanitzer",
                        "content": "Here is an easy way in JS, find the first number >= the result, add its symbol and substract it then continue\n `let roman = \"M\".repeat(parseInt(num/1000));\n    num = num%1000;\n    const nums = ['900', '500','400','100', '90','50',  '40',  '10', '9', '5','4', '1']\n    const rom = [\"CM\", 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n    for (let i in nums){\n        while (num>=nums[i]){\n            roman+=rom[i]\n            num-=nums[i]\n        }\n    }\n    return roman;`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "RASWQQW",
                        "content": "Can we this code but its shown as incorrect in testcase\n\n`\n\n\n        _dict = {1000: \"M\", 500: \"D\", 100: \"C\", 50: \"L\", 10: \"X\", 5: \"V\", 1: \"I\"}\n        # print(dict(reversed(list(_dict.items()))))\n\n        _digitLen = len(str(num))\n        num = str(num)[::-1]\n        dar = 1\n        text = ''\n        for elem in str(num):\n            elem = int(elem) * dar\n            for key, value in _dict.items():\n\n                if int(elem) == key:\n                    text+= value; break\n\n                elif int(elem) % key == 0:\n                    for _ in range(int(elem / dar)):\n                        text+=value\n\n                    break\n\n                elif 3 * dar >= int(elem) % key > 0 and int(elem) % key != elem:\n                    for ss in range(int(int(elem) % key / dar)):\n                        text+=_dict[dar]\n                    text += value\n                    break\n\n                elif int(elem) + dar == key:\n                    text+=value+_dict[dar]; \n                    \n                    break\n\n            dar *= 10\n\n        return text[::-1] `\n\n\n\n\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "hsthanh00",
                        "content": "var roman = \"\";\\nfunction divided(num,romanNum){\\n    roman += romanNum ;\\n    if(num <= 0){\\n        return roman;\\n    }\\n    if( num>=1000){\\n        var romanNumber = \"M\".repeat(num/1000);\\n       return divided(num%1000,romanNumber)\\n    }\\n    if(num >= 900){\\n        var romanNumber = \"CM\".repeat(num/900);\\n       return divided(num%900,romanNumber)\\n    }\\n    if(num>=500){\\n        \\n        var romanNumber = \"D\".repeat(num/500);\\n        return divided(num%500,romanNumber)\\n    }\\n    if(num >= 400){\\n         var romanNumber = \"CD\".repeat(num/400);\\n        return divided(num%400,romanNumber)\\n    }\\n    if(num>=100){\\n        var romanNumber = \"C\".repeat(num/100);\\n        return divided(num%100,romanNumber)\\n    }\\n    if(num>=90){\\n         var romanNumber = \"XC\".repeat(num/90);\\n        return divided(num%90,romanNumber)\\n    }\\n    if(num>=50){\\n        var romanNumber = \"L\".repeat(num/50);\\n        return divided(num%50,romanNumber)\\n    }\\n    if(num>=40){\\n         var romanNumber = \"XL\".repeat(num/40);\\n        return divided(num%40,romanNumber)\\n    }\\n    \\n    if(num>=10){\\n        var romanNumber = \"X\".repeat(num/10);\\n        return divided(num%10,romanNumber)\\n    }\\n    if(num>=9){\\n         var romanNumber = \"IX\".repeat(num/9);\\n        return divided(num%9,romanNumber)\\n    }\\n     if(num>=5){\\n        var romanNumber = \"V\".repeat(num/5);\\n        return  divided(num%5,romanNumber)\\n    }\\n    if(num>=4){\\n         var romanNumber = \"IV\".repeat(num/4);\\n        return divided(num%4,romanNumber)\\n    }\\n     if(num>=1){\\n        var romanNumber = \"I\".repeat(num/1);\\n        return divided(num%1,romanNumber)\\n    }\\n    return roman; \\n}\\n\\nvar intToRoman = function(num) {\\n var roman = divided(num,\"\");\\n return roman \\n};\\n// how does it work when i code it on visual studio code but at \"leetcode\" it\\'s wrong. @@\\n"
                    },
                    {
                        "username": "RohitAgarwal08",
                        "content": "Explanation in Hindi\\n\\nhttps://youtu.be/fh5Q-2TvQwo"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1766291,
                "content": [
                    {
                        "username": "haduong825",
                        "content": "Here is my stupid solution \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\n `class Solution {\\n  String intToRoman(int num) {\\n    final oneMap = {1: \"I\", 10: \"X\", 100: \"C\", 1000: \"M\"};\\n    final fiveMap = {5: \"V\", 50: \"L\", 500: \"D\"};\\n    final inputStr =\\n        num.toString().split(\\'\\').reversed.map((e) => int.parse(e)).toList();\\n    var outputArray = List<String>.empty(growable: true);\\n    for (int i = 0; i < inputStr.length; i++) {\\n      if (inputStr[i] * pow(10, i) < (5 * pow(10, i) - pow(10, i))) {\\n        for (int j = 0; j < inputStr[i]; j++) {\\n          outputArray.add(oneMap[pow(10, i)] ?? \"\");\\n        }\\n      } else if (inputStr[i] * pow(10, i) < 9 * pow(10, i) &&\\n          inputStr[i] * pow(10, i) != (4 * pow(10, i))) {\\n        var tmpStr = \"\";\\n        tmpStr += fiveMap[5 * pow(10, i)] ?? \"\";\\n        for (int j = 0; j < inputStr[i] - 5; j++) {\\n          tmpStr += oneMap[pow(10, i)] ?? \"\";\\n        }\\n\\n        outputArray.add(tmpStr);\\n      } else if (inputStr[i] * pow(10, i) == (4 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${fiveMap[5 * pow(10, i)]}\");\\n      } else if (inputStr[i] * pow(10, i) == (9 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${oneMap[pow(10, i + 1)]}\");\\n      } else if (inputStr[i] * pow(10, (i + 1)) == (5 * pow(10, (i + 1)))) {\\n        outputArray.add(fiveMap[5 * pow(10, i)] ?? \"\");\\n      }\\n    }\\n\\n    return outputArray.reversed.reduce((value, element) => value + element);\\n  }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nAnd here are the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "maj-oliveira",
                        "content": "what is the complexity of this code?\\n\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d = {1000:\\'M\\',900:\\'CM\\',500:\\'D\\',400:\\'CD\\',100:\\'C\\',90:\\'XC\\',50:\\'L\\',40:\\'XL\\',10:\\'X\\',9:\\'IX\\',5:\\'V\\',4:\\'IV\\',1:\\'I\\'}\\n        result = \"\"\\n\\n        while num !=0:\\n            for key in d:\\n                if key<=num or key==1:\\n                    div = num // key\\n                    for i in range(div):\\n                        result = result + d[key]\\n                    num = num % key\\n\\n        return result"
                    },
                    {
                        "username": "boy19970722",
                        "content": "can someone exmplain why 200 is LLLL instead of CC where 20 is XX instead of VVVV?"
                    },
                    {
                        "username": "jamesTheCoder",
                        "content": "200 is CC. Largest possible. "
                    },
                    {
                        "username": "adnanitzer",
                        "content": "Here is an easy way in JS, find the first number >= the result, add its symbol and substract it then continue\n `let roman = \"M\".repeat(parseInt(num/1000));\n    num = num%1000;\n    const nums = ['900', '500','400','100', '90','50',  '40',  '10', '9', '5','4', '1']\n    const rom = [\"CM\", 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n    for (let i in nums){\n        while (num>=nums[i]){\n            roman+=rom[i]\n            num-=nums[i]\n        }\n    }\n    return roman;`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "RASWQQW",
                        "content": "Can we this code but its shown as incorrect in testcase\n\n`\n\n\n        _dict = {1000: \"M\", 500: \"D\", 100: \"C\", 50: \"L\", 10: \"X\", 5: \"V\", 1: \"I\"}\n        # print(dict(reversed(list(_dict.items()))))\n\n        _digitLen = len(str(num))\n        num = str(num)[::-1]\n        dar = 1\n        text = ''\n        for elem in str(num):\n            elem = int(elem) * dar\n            for key, value in _dict.items():\n\n                if int(elem) == key:\n                    text+= value; break\n\n                elif int(elem) % key == 0:\n                    for _ in range(int(elem / dar)):\n                        text+=value\n\n                    break\n\n                elif 3 * dar >= int(elem) % key > 0 and int(elem) % key != elem:\n                    for ss in range(int(int(elem) % key / dar)):\n                        text+=_dict[dar]\n                    text += value\n                    break\n\n                elif int(elem) + dar == key:\n                    text+=value+_dict[dar]; \n                    \n                    break\n\n            dar *= 10\n\n        return text[::-1] `\n\n\n\n\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "hsthanh00",
                        "content": "var roman = \"\";\\nfunction divided(num,romanNum){\\n    roman += romanNum ;\\n    if(num <= 0){\\n        return roman;\\n    }\\n    if( num>=1000){\\n        var romanNumber = \"M\".repeat(num/1000);\\n       return divided(num%1000,romanNumber)\\n    }\\n    if(num >= 900){\\n        var romanNumber = \"CM\".repeat(num/900);\\n       return divided(num%900,romanNumber)\\n    }\\n    if(num>=500){\\n        \\n        var romanNumber = \"D\".repeat(num/500);\\n        return divided(num%500,romanNumber)\\n    }\\n    if(num >= 400){\\n         var romanNumber = \"CD\".repeat(num/400);\\n        return divided(num%400,romanNumber)\\n    }\\n    if(num>=100){\\n        var romanNumber = \"C\".repeat(num/100);\\n        return divided(num%100,romanNumber)\\n    }\\n    if(num>=90){\\n         var romanNumber = \"XC\".repeat(num/90);\\n        return divided(num%90,romanNumber)\\n    }\\n    if(num>=50){\\n        var romanNumber = \"L\".repeat(num/50);\\n        return divided(num%50,romanNumber)\\n    }\\n    if(num>=40){\\n         var romanNumber = \"XL\".repeat(num/40);\\n        return divided(num%40,romanNumber)\\n    }\\n    \\n    if(num>=10){\\n        var romanNumber = \"X\".repeat(num/10);\\n        return divided(num%10,romanNumber)\\n    }\\n    if(num>=9){\\n         var romanNumber = \"IX\".repeat(num/9);\\n        return divided(num%9,romanNumber)\\n    }\\n     if(num>=5){\\n        var romanNumber = \"V\".repeat(num/5);\\n        return  divided(num%5,romanNumber)\\n    }\\n    if(num>=4){\\n         var romanNumber = \"IV\".repeat(num/4);\\n        return divided(num%4,romanNumber)\\n    }\\n     if(num>=1){\\n        var romanNumber = \"I\".repeat(num/1);\\n        return divided(num%1,romanNumber)\\n    }\\n    return roman; \\n}\\n\\nvar intToRoman = function(num) {\\n var roman = divided(num,\"\");\\n return roman \\n};\\n// how does it work when i code it on visual studio code but at \"leetcode\" it\\'s wrong. @@\\n"
                    },
                    {
                        "username": "RohitAgarwal08",
                        "content": "Explanation in Hindi\\n\\nhttps://youtu.be/fh5Q-2TvQwo"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1746519,
                "content": [
                    {
                        "username": "haduong825",
                        "content": "Here is my stupid solution \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\n `class Solution {\\n  String intToRoman(int num) {\\n    final oneMap = {1: \"I\", 10: \"X\", 100: \"C\", 1000: \"M\"};\\n    final fiveMap = {5: \"V\", 50: \"L\", 500: \"D\"};\\n    final inputStr =\\n        num.toString().split(\\'\\').reversed.map((e) => int.parse(e)).toList();\\n    var outputArray = List<String>.empty(growable: true);\\n    for (int i = 0; i < inputStr.length; i++) {\\n      if (inputStr[i] * pow(10, i) < (5 * pow(10, i) - pow(10, i))) {\\n        for (int j = 0; j < inputStr[i]; j++) {\\n          outputArray.add(oneMap[pow(10, i)] ?? \"\");\\n        }\\n      } else if (inputStr[i] * pow(10, i) < 9 * pow(10, i) &&\\n          inputStr[i] * pow(10, i) != (4 * pow(10, i))) {\\n        var tmpStr = \"\";\\n        tmpStr += fiveMap[5 * pow(10, i)] ?? \"\";\\n        for (int j = 0; j < inputStr[i] - 5; j++) {\\n          tmpStr += oneMap[pow(10, i)] ?? \"\";\\n        }\\n\\n        outputArray.add(tmpStr);\\n      } else if (inputStr[i] * pow(10, i) == (4 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${fiveMap[5 * pow(10, i)]}\");\\n      } else if (inputStr[i] * pow(10, i) == (9 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${oneMap[pow(10, i + 1)]}\");\\n      } else if (inputStr[i] * pow(10, (i + 1)) == (5 * pow(10, (i + 1)))) {\\n        outputArray.add(fiveMap[5 * pow(10, i)] ?? \"\");\\n      }\\n    }\\n\\n    return outputArray.reversed.reduce((value, element) => value + element);\\n  }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nAnd here are the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "maj-oliveira",
                        "content": "what is the complexity of this code?\\n\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d = {1000:\\'M\\',900:\\'CM\\',500:\\'D\\',400:\\'CD\\',100:\\'C\\',90:\\'XC\\',50:\\'L\\',40:\\'XL\\',10:\\'X\\',9:\\'IX\\',5:\\'V\\',4:\\'IV\\',1:\\'I\\'}\\n        result = \"\"\\n\\n        while num !=0:\\n            for key in d:\\n                if key<=num or key==1:\\n                    div = num // key\\n                    for i in range(div):\\n                        result = result + d[key]\\n                    num = num % key\\n\\n        return result"
                    },
                    {
                        "username": "boy19970722",
                        "content": "can someone exmplain why 200 is LLLL instead of CC where 20 is XX instead of VVVV?"
                    },
                    {
                        "username": "jamesTheCoder",
                        "content": "200 is CC. Largest possible. "
                    },
                    {
                        "username": "adnanitzer",
                        "content": "Here is an easy way in JS, find the first number >= the result, add its symbol and substract it then continue\n `let roman = \"M\".repeat(parseInt(num/1000));\n    num = num%1000;\n    const nums = ['900', '500','400','100', '90','50',  '40',  '10', '9', '5','4', '1']\n    const rom = [\"CM\", 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n    for (let i in nums){\n        while (num>=nums[i]){\n            roman+=rom[i]\n            num-=nums[i]\n        }\n    }\n    return roman;`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "RASWQQW",
                        "content": "Can we this code but its shown as incorrect in testcase\n\n`\n\n\n        _dict = {1000: \"M\", 500: \"D\", 100: \"C\", 50: \"L\", 10: \"X\", 5: \"V\", 1: \"I\"}\n        # print(dict(reversed(list(_dict.items()))))\n\n        _digitLen = len(str(num))\n        num = str(num)[::-1]\n        dar = 1\n        text = ''\n        for elem in str(num):\n            elem = int(elem) * dar\n            for key, value in _dict.items():\n\n                if int(elem) == key:\n                    text+= value; break\n\n                elif int(elem) % key == 0:\n                    for _ in range(int(elem / dar)):\n                        text+=value\n\n                    break\n\n                elif 3 * dar >= int(elem) % key > 0 and int(elem) % key != elem:\n                    for ss in range(int(int(elem) % key / dar)):\n                        text+=_dict[dar]\n                    text += value\n                    break\n\n                elif int(elem) + dar == key:\n                    text+=value+_dict[dar]; \n                    \n                    break\n\n            dar *= 10\n\n        return text[::-1] `\n\n\n\n\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "hsthanh00",
                        "content": "var roman = \"\";\\nfunction divided(num,romanNum){\\n    roman += romanNum ;\\n    if(num <= 0){\\n        return roman;\\n    }\\n    if( num>=1000){\\n        var romanNumber = \"M\".repeat(num/1000);\\n       return divided(num%1000,romanNumber)\\n    }\\n    if(num >= 900){\\n        var romanNumber = \"CM\".repeat(num/900);\\n       return divided(num%900,romanNumber)\\n    }\\n    if(num>=500){\\n        \\n        var romanNumber = \"D\".repeat(num/500);\\n        return divided(num%500,romanNumber)\\n    }\\n    if(num >= 400){\\n         var romanNumber = \"CD\".repeat(num/400);\\n        return divided(num%400,romanNumber)\\n    }\\n    if(num>=100){\\n        var romanNumber = \"C\".repeat(num/100);\\n        return divided(num%100,romanNumber)\\n    }\\n    if(num>=90){\\n         var romanNumber = \"XC\".repeat(num/90);\\n        return divided(num%90,romanNumber)\\n    }\\n    if(num>=50){\\n        var romanNumber = \"L\".repeat(num/50);\\n        return divided(num%50,romanNumber)\\n    }\\n    if(num>=40){\\n         var romanNumber = \"XL\".repeat(num/40);\\n        return divided(num%40,romanNumber)\\n    }\\n    \\n    if(num>=10){\\n        var romanNumber = \"X\".repeat(num/10);\\n        return divided(num%10,romanNumber)\\n    }\\n    if(num>=9){\\n         var romanNumber = \"IX\".repeat(num/9);\\n        return divided(num%9,romanNumber)\\n    }\\n     if(num>=5){\\n        var romanNumber = \"V\".repeat(num/5);\\n        return  divided(num%5,romanNumber)\\n    }\\n    if(num>=4){\\n         var romanNumber = \"IV\".repeat(num/4);\\n        return divided(num%4,romanNumber)\\n    }\\n     if(num>=1){\\n        var romanNumber = \"I\".repeat(num/1);\\n        return divided(num%1,romanNumber)\\n    }\\n    return roman; \\n}\\n\\nvar intToRoman = function(num) {\\n var roman = divided(num,\"\");\\n return roman \\n};\\n// how does it work when i code it on visual studio code but at \"leetcode\" it\\'s wrong. @@\\n"
                    },
                    {
                        "username": "RohitAgarwal08",
                        "content": "Explanation in Hindi\\n\\nhttps://youtu.be/fh5Q-2TvQwo"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1744912,
                "content": [
                    {
                        "username": "haduong825",
                        "content": "Here is my stupid solution \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\n `class Solution {\\n  String intToRoman(int num) {\\n    final oneMap = {1: \"I\", 10: \"X\", 100: \"C\", 1000: \"M\"};\\n    final fiveMap = {5: \"V\", 50: \"L\", 500: \"D\"};\\n    final inputStr =\\n        num.toString().split(\\'\\').reversed.map((e) => int.parse(e)).toList();\\n    var outputArray = List<String>.empty(growable: true);\\n    for (int i = 0; i < inputStr.length; i++) {\\n      if (inputStr[i] * pow(10, i) < (5 * pow(10, i) - pow(10, i))) {\\n        for (int j = 0; j < inputStr[i]; j++) {\\n          outputArray.add(oneMap[pow(10, i)] ?? \"\");\\n        }\\n      } else if (inputStr[i] * pow(10, i) < 9 * pow(10, i) &&\\n          inputStr[i] * pow(10, i) != (4 * pow(10, i))) {\\n        var tmpStr = \"\";\\n        tmpStr += fiveMap[5 * pow(10, i)] ?? \"\";\\n        for (int j = 0; j < inputStr[i] - 5; j++) {\\n          tmpStr += oneMap[pow(10, i)] ?? \"\";\\n        }\\n\\n        outputArray.add(tmpStr);\\n      } else if (inputStr[i] * pow(10, i) == (4 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${fiveMap[5 * pow(10, i)]}\");\\n      } else if (inputStr[i] * pow(10, i) == (9 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${oneMap[pow(10, i + 1)]}\");\\n      } else if (inputStr[i] * pow(10, (i + 1)) == (5 * pow(10, (i + 1)))) {\\n        outputArray.add(fiveMap[5 * pow(10, i)] ?? \"\");\\n      }\\n    }\\n\\n    return outputArray.reversed.reduce((value, element) => value + element);\\n  }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nAnd here are the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "maj-oliveira",
                        "content": "what is the complexity of this code?\\n\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d = {1000:\\'M\\',900:\\'CM\\',500:\\'D\\',400:\\'CD\\',100:\\'C\\',90:\\'XC\\',50:\\'L\\',40:\\'XL\\',10:\\'X\\',9:\\'IX\\',5:\\'V\\',4:\\'IV\\',1:\\'I\\'}\\n        result = \"\"\\n\\n        while num !=0:\\n            for key in d:\\n                if key<=num or key==1:\\n                    div = num // key\\n                    for i in range(div):\\n                        result = result + d[key]\\n                    num = num % key\\n\\n        return result"
                    },
                    {
                        "username": "boy19970722",
                        "content": "can someone exmplain why 200 is LLLL instead of CC where 20 is XX instead of VVVV?"
                    },
                    {
                        "username": "jamesTheCoder",
                        "content": "200 is CC. Largest possible. "
                    },
                    {
                        "username": "adnanitzer",
                        "content": "Here is an easy way in JS, find the first number >= the result, add its symbol and substract it then continue\n `let roman = \"M\".repeat(parseInt(num/1000));\n    num = num%1000;\n    const nums = ['900', '500','400','100', '90','50',  '40',  '10', '9', '5','4', '1']\n    const rom = [\"CM\", 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n    for (let i in nums){\n        while (num>=nums[i]){\n            roman+=rom[i]\n            num-=nums[i]\n        }\n    }\n    return roman;`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "RASWQQW",
                        "content": "Can we this code but its shown as incorrect in testcase\n\n`\n\n\n        _dict = {1000: \"M\", 500: \"D\", 100: \"C\", 50: \"L\", 10: \"X\", 5: \"V\", 1: \"I\"}\n        # print(dict(reversed(list(_dict.items()))))\n\n        _digitLen = len(str(num))\n        num = str(num)[::-1]\n        dar = 1\n        text = ''\n        for elem in str(num):\n            elem = int(elem) * dar\n            for key, value in _dict.items():\n\n                if int(elem) == key:\n                    text+= value; break\n\n                elif int(elem) % key == 0:\n                    for _ in range(int(elem / dar)):\n                        text+=value\n\n                    break\n\n                elif 3 * dar >= int(elem) % key > 0 and int(elem) % key != elem:\n                    for ss in range(int(int(elem) % key / dar)):\n                        text+=_dict[dar]\n                    text += value\n                    break\n\n                elif int(elem) + dar == key:\n                    text+=value+_dict[dar]; \n                    \n                    break\n\n            dar *= 10\n\n        return text[::-1] `\n\n\n\n\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "hsthanh00",
                        "content": "var roman = \"\";\\nfunction divided(num,romanNum){\\n    roman += romanNum ;\\n    if(num <= 0){\\n        return roman;\\n    }\\n    if( num>=1000){\\n        var romanNumber = \"M\".repeat(num/1000);\\n       return divided(num%1000,romanNumber)\\n    }\\n    if(num >= 900){\\n        var romanNumber = \"CM\".repeat(num/900);\\n       return divided(num%900,romanNumber)\\n    }\\n    if(num>=500){\\n        \\n        var romanNumber = \"D\".repeat(num/500);\\n        return divided(num%500,romanNumber)\\n    }\\n    if(num >= 400){\\n         var romanNumber = \"CD\".repeat(num/400);\\n        return divided(num%400,romanNumber)\\n    }\\n    if(num>=100){\\n        var romanNumber = \"C\".repeat(num/100);\\n        return divided(num%100,romanNumber)\\n    }\\n    if(num>=90){\\n         var romanNumber = \"XC\".repeat(num/90);\\n        return divided(num%90,romanNumber)\\n    }\\n    if(num>=50){\\n        var romanNumber = \"L\".repeat(num/50);\\n        return divided(num%50,romanNumber)\\n    }\\n    if(num>=40){\\n         var romanNumber = \"XL\".repeat(num/40);\\n        return divided(num%40,romanNumber)\\n    }\\n    \\n    if(num>=10){\\n        var romanNumber = \"X\".repeat(num/10);\\n        return divided(num%10,romanNumber)\\n    }\\n    if(num>=9){\\n         var romanNumber = \"IX\".repeat(num/9);\\n        return divided(num%9,romanNumber)\\n    }\\n     if(num>=5){\\n        var romanNumber = \"V\".repeat(num/5);\\n        return  divided(num%5,romanNumber)\\n    }\\n    if(num>=4){\\n         var romanNumber = \"IV\".repeat(num/4);\\n        return divided(num%4,romanNumber)\\n    }\\n     if(num>=1){\\n        var romanNumber = \"I\".repeat(num/1);\\n        return divided(num%1,romanNumber)\\n    }\\n    return roman; \\n}\\n\\nvar intToRoman = function(num) {\\n var roman = divided(num,\"\");\\n return roman \\n};\\n// how does it work when i code it on visual studio code but at \"leetcode\" it\\'s wrong. @@\\n"
                    },
                    {
                        "username": "RohitAgarwal08",
                        "content": "Explanation in Hindi\\n\\nhttps://youtu.be/fh5Q-2TvQwo"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1731563,
                "content": [
                    {
                        "username": "haduong825",
                        "content": "Here is my stupid solution \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\n `class Solution {\\n  String intToRoman(int num) {\\n    final oneMap = {1: \"I\", 10: \"X\", 100: \"C\", 1000: \"M\"};\\n    final fiveMap = {5: \"V\", 50: \"L\", 500: \"D\"};\\n    final inputStr =\\n        num.toString().split(\\'\\').reversed.map((e) => int.parse(e)).toList();\\n    var outputArray = List<String>.empty(growable: true);\\n    for (int i = 0; i < inputStr.length; i++) {\\n      if (inputStr[i] * pow(10, i) < (5 * pow(10, i) - pow(10, i))) {\\n        for (int j = 0; j < inputStr[i]; j++) {\\n          outputArray.add(oneMap[pow(10, i)] ?? \"\");\\n        }\\n      } else if (inputStr[i] * pow(10, i) < 9 * pow(10, i) &&\\n          inputStr[i] * pow(10, i) != (4 * pow(10, i))) {\\n        var tmpStr = \"\";\\n        tmpStr += fiveMap[5 * pow(10, i)] ?? \"\";\\n        for (int j = 0; j < inputStr[i] - 5; j++) {\\n          tmpStr += oneMap[pow(10, i)] ?? \"\";\\n        }\\n\\n        outputArray.add(tmpStr);\\n      } else if (inputStr[i] * pow(10, i) == (4 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${fiveMap[5 * pow(10, i)]}\");\\n      } else if (inputStr[i] * pow(10, i) == (9 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${oneMap[pow(10, i + 1)]}\");\\n      } else if (inputStr[i] * pow(10, (i + 1)) == (5 * pow(10, (i + 1)))) {\\n        outputArray.add(fiveMap[5 * pow(10, i)] ?? \"\");\\n      }\\n    }\\n\\n    return outputArray.reversed.reduce((value, element) => value + element);\\n  }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nAnd here are the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "maj-oliveira",
                        "content": "what is the complexity of this code?\\n\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d = {1000:\\'M\\',900:\\'CM\\',500:\\'D\\',400:\\'CD\\',100:\\'C\\',90:\\'XC\\',50:\\'L\\',40:\\'XL\\',10:\\'X\\',9:\\'IX\\',5:\\'V\\',4:\\'IV\\',1:\\'I\\'}\\n        result = \"\"\\n\\n        while num !=0:\\n            for key in d:\\n                if key<=num or key==1:\\n                    div = num // key\\n                    for i in range(div):\\n                        result = result + d[key]\\n                    num = num % key\\n\\n        return result"
                    },
                    {
                        "username": "boy19970722",
                        "content": "can someone exmplain why 200 is LLLL instead of CC where 20 is XX instead of VVVV?"
                    },
                    {
                        "username": "jamesTheCoder",
                        "content": "200 is CC. Largest possible. "
                    },
                    {
                        "username": "adnanitzer",
                        "content": "Here is an easy way in JS, find the first number >= the result, add its symbol and substract it then continue\n `let roman = \"M\".repeat(parseInt(num/1000));\n    num = num%1000;\n    const nums = ['900', '500','400','100', '90','50',  '40',  '10', '9', '5','4', '1']\n    const rom = [\"CM\", 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n    for (let i in nums){\n        while (num>=nums[i]){\n            roman+=rom[i]\n            num-=nums[i]\n        }\n    }\n    return roman;`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "RASWQQW",
                        "content": "Can we this code but its shown as incorrect in testcase\n\n`\n\n\n        _dict = {1000: \"M\", 500: \"D\", 100: \"C\", 50: \"L\", 10: \"X\", 5: \"V\", 1: \"I\"}\n        # print(dict(reversed(list(_dict.items()))))\n\n        _digitLen = len(str(num))\n        num = str(num)[::-1]\n        dar = 1\n        text = ''\n        for elem in str(num):\n            elem = int(elem) * dar\n            for key, value in _dict.items():\n\n                if int(elem) == key:\n                    text+= value; break\n\n                elif int(elem) % key == 0:\n                    for _ in range(int(elem / dar)):\n                        text+=value\n\n                    break\n\n                elif 3 * dar >= int(elem) % key > 0 and int(elem) % key != elem:\n                    for ss in range(int(int(elem) % key / dar)):\n                        text+=_dict[dar]\n                    text += value\n                    break\n\n                elif int(elem) + dar == key:\n                    text+=value+_dict[dar]; \n                    \n                    break\n\n            dar *= 10\n\n        return text[::-1] `\n\n\n\n\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "hsthanh00",
                        "content": "var roman = \"\";\\nfunction divided(num,romanNum){\\n    roman += romanNum ;\\n    if(num <= 0){\\n        return roman;\\n    }\\n    if( num>=1000){\\n        var romanNumber = \"M\".repeat(num/1000);\\n       return divided(num%1000,romanNumber)\\n    }\\n    if(num >= 900){\\n        var romanNumber = \"CM\".repeat(num/900);\\n       return divided(num%900,romanNumber)\\n    }\\n    if(num>=500){\\n        \\n        var romanNumber = \"D\".repeat(num/500);\\n        return divided(num%500,romanNumber)\\n    }\\n    if(num >= 400){\\n         var romanNumber = \"CD\".repeat(num/400);\\n        return divided(num%400,romanNumber)\\n    }\\n    if(num>=100){\\n        var romanNumber = \"C\".repeat(num/100);\\n        return divided(num%100,romanNumber)\\n    }\\n    if(num>=90){\\n         var romanNumber = \"XC\".repeat(num/90);\\n        return divided(num%90,romanNumber)\\n    }\\n    if(num>=50){\\n        var romanNumber = \"L\".repeat(num/50);\\n        return divided(num%50,romanNumber)\\n    }\\n    if(num>=40){\\n         var romanNumber = \"XL\".repeat(num/40);\\n        return divided(num%40,romanNumber)\\n    }\\n    \\n    if(num>=10){\\n        var romanNumber = \"X\".repeat(num/10);\\n        return divided(num%10,romanNumber)\\n    }\\n    if(num>=9){\\n         var romanNumber = \"IX\".repeat(num/9);\\n        return divided(num%9,romanNumber)\\n    }\\n     if(num>=5){\\n        var romanNumber = \"V\".repeat(num/5);\\n        return  divided(num%5,romanNumber)\\n    }\\n    if(num>=4){\\n         var romanNumber = \"IV\".repeat(num/4);\\n        return divided(num%4,romanNumber)\\n    }\\n     if(num>=1){\\n        var romanNumber = \"I\".repeat(num/1);\\n        return divided(num%1,romanNumber)\\n    }\\n    return roman; \\n}\\n\\nvar intToRoman = function(num) {\\n var roman = divided(num,\"\");\\n return roman \\n};\\n// how does it work when i code it on visual studio code but at \"leetcode\" it\\'s wrong. @@\\n"
                    },
                    {
                        "username": "RohitAgarwal08",
                        "content": "Explanation in Hindi\\n\\nhttps://youtu.be/fh5Q-2TvQwo"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            }
        ]
    },
    {
        "title": "Path Sum",
        "question_content": "<p>Given the <code>root</code> of a binary tree and an integer <code>targetSum</code>, return <code>true</code> if the tree has a <strong>root-to-leaf</strong> path such that adding up all the values along the path equals <code>targetSum</code>.</p>\n\n<p>A <strong>leaf</strong> is a node with no children.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg\" style=\"width: 500px; height: 356px;\" />\n<pre>\n<strong>Input:</strong> root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The root-to-leaf path with the target sum is shown.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3], targetSum = 5\n<strong>Output:</strong> false\n<strong>Explanation:</strong> There two root-to-leaf paths in the tree:\n(1 --&gt; 2): The sum is 3.\n(1 --&gt; 3): The sum is 4.\nThere is no root-to-leaf path with sum = 5.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [], targetSum = 0\n<strong>Output:</strong> false\n<strong>Explanation:</strong> Since the tree is empty, there are no root-to-leaf paths.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 5000]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n\t<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 36378,
                "title": "accepted-my-recursive-solution-in-java",
                "content": "The basic idea is to subtract the value of current node from sum until it reaches a leaf node and the subtraction equals 0, then we know that we got a hit. Otherwise the subtraction at the end could not be 0.\\n\\n    public class Solution {\\n        public boolean hasPathSum(TreeNode root, int sum) {\\n            if(root == null) return false;\\n        \\n            if(root.left == null && root.right == null && sum - root.val == 0) return true;\\n        \\n            return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean hasPathSum(TreeNode root, int sum) {\\n            if(root == null) return false;\\n        \\n            if(root.left == null && root.right == null && sum - root.val == 0) return true;\\n        \\n            return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 36360,
                "title": "short-python-recursive-solution-o-n",
                "content": "    # Definition for a  binary tree node\\n    # class TreeNode:\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class Solution:\\n        # @param root, a tree node\\n        # @param sum, an integer\\n        # @return a boolean\\n        # 1:27\\n        def hasPathSum(self, root, sum):\\n            if not root:\\n                return False\\n    \\n            if not root.left and not root.right and root.val == sum:\\n                return True\\n            \\n            sum -= root.val\\n    \\n            return self.hasPathSum(root.left, sum) or self.hasPathSum(root.right, sum)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    # Definition for a  binary tree node\\n    # class TreeNode:\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class Solution:\\n        # @param root, a tree node\\n        # @param sum, an integer\\n        # @return a boolean\\n        # 1:27\\n        def hasPathSum(self, root, sum):\\n            if not root:\\n                return False\\n    \\n            if not root.left and not root.right and root.val == sum:\\n                return True\\n            \\n            sum -= root.val\\n    \\n            return self.hasPathSum(root.left, sum) or self.hasPathSum(root.right, sum)",
                "codeTag": "Java"
            },
            {
                "id": 36367,
                "title": "3-lines-of-c-solution",
                "content": "    bool hasPathSum(TreeNode *root, int sum) {\\n            if (root == NULL) return false;\\n            if (root->val == sum && root->left ==  NULL && root->right == NULL) return true;\\n            return hasPathSum(root->left, sum-root->val) || hasPathSum(root->right, sum-root->val);\\n        }",
                "solutionTags": [],
                "code": "    bool hasPathSum(TreeNode *root, int sum) {\\n            if (root == NULL) return false;\\n            if (root->val == sum && root->left ==  NULL && root->right == NULL) return true;\\n            return hasPathSum(root->left, sum-root->val) || hasPathSum(root->right, sum-root->val);\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 36486,
                "title": "python-solutions-dfs-recursively-dfs-stack-bfs-queue",
                "content": "# DFS Recursively \\n    def hasPathSum1(self, root, sum):\\n        res = []\\n        self.dfs(root, sum, res)\\n        return any(res)\\n        \\n    def dfs(self, root, target, res):\\n        if root:\\n            if not root.left and not root.right and root.val == target:\\n                res.append(True)\\n            if root.left:\\n                self.dfs(root.left, target-root.val, res)\\n            if root.right:\\n                self.dfs(root.right, target-root.val, res)\\n    \\n    # DFS with stack\\n    def hasPathSum2(self, root, sum):\\n        if not root:\\n            return False\\n        stack = [(root, root.val)]\\n        while stack:\\n            curr, val = stack.pop()\\n            if not curr.left and not curr.right and val == sum:\\n                return True\\n            if curr.right:\\n                stack.append((curr.right, val+curr.right.val))\\n            if curr.left:\\n                stack.append((curr.left, val+curr.left.val))\\n        return False\\n        \\n    # BFS with queue\\n    def hasPathSum(self, root, sum):\\n        if not root:\\n            return False\\n        queue = [(root, sum-root.val)]\\n        while queue:\\n            curr, val = queue.pop(0)\\n            if not curr.left and not curr.right and val == 0:\\n                return True\\n            if curr.left:\\n                queue.append((curr.left, val-curr.left.val))\\n            if curr.right:\\n                queue.append((curr.right, val-curr.right.val))\\n        return False\\n\\t\\t\\n\\tdef hasPathSum1(self, root, sum):\\n        if not root:\\n            return False\\n        if not root.left and not root.right and root.val == sum:\\n            return True\\n        return self.hasPathSum(root.left, sum-root.val) or self.hasPathSum(root.right, sum-root.val)",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "# DFS Recursively \\n    def hasPathSum1(self, root, sum):\\n        res = []\\n        self.dfs(root, sum, res)\\n        return any(res)\\n        \\n    def dfs(self, root, target, res):\\n        if root:\\n            if not root.left and not root.right and root.val == target:\\n                res.append(True)\\n            if root.left:\\n                self.dfs(root.left, target-root.val, res)\\n            if root.right:\\n                self.dfs(root.right, target-root.val, res)\\n    \\n    # DFS with stack\\n    def hasPathSum2(self, root, sum):\\n        if not root:\\n            return False\\n        stack = [(root, root.val)]\\n        while stack:\\n            curr, val = stack.pop()\\n            if not curr.left and not curr.right and val == sum:\\n                return True\\n            if curr.right:\\n                stack.append((curr.right, val+curr.right.val))\\n            if curr.left:\\n                stack.append((curr.left, val+curr.left.val))\\n        return False\\n        \\n    # BFS with queue\\n    def hasPathSum(self, root, sum):\\n        if not root:\\n            return False\\n        queue = [(root, sum-root.val)]\\n        while queue:\\n            curr, val = queue.pop(0)\\n            if not curr.left and not curr.right and val == 0:\\n                return True\\n            if curr.left:\\n                queue.append((curr.left, val-curr.left.val))\\n            if curr.right:\\n                queue.append((curr.right, val-curr.right.val))\\n        return False\\n\\t\\t\\n\\tdef hasPathSum1(self, root, sum):\\n        if not root:\\n            return False\\n        if not root.left and not root.right and root.val == sum:\\n            return True\\n        return self.hasPathSum(root.left, sum-root.val) or self.hasPathSum(root.right, sum-root.val)",
                "codeTag": "Python3"
            },
            {
                "id": 670515,
                "title": "c-recursive-solution-4-lines-code",
                "content": "***Pls upvote if you find this helpful  :)***\\n\\nThree things to remember while solving any recursion based questions are:\\n1)Terminating condition/Base Case\\n2)Body (Code to be performed each time)\\n3)Propagation(Calling itself,propagating further)\\n```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int sum) {\\n        if(!root)return false;                                         //Terminating Condition\\n        sum=sum-root->val;                                             //Body\\n        if(sum==0&&!root->left&&!root->right)return true;              //body\\n        return hasPathSum(root->left,sum)||hasPathSum(root->right,sum);//Propagation\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int sum) {\\n        if(!root)return false;                                         //Terminating Condition\\n        sum=sum-root->val;                                             //Body\\n        if(sum==0&&!root->left&&!root->right)return true;              //body\\n        return hasPathSum(root->left,sum)||hasPathSum(root->right,sum);//Propagation\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096296,
                "title": "easiest-beginner-friendly-sol-recursion-o-n-time-and-o-h-space",
                "content": "# Intuition\\n- We are using **top down recursion** approach to solve this problem.\\n- See below solution to understand how we can use top down and bottom up approach in recursion.\\nhttps://leetcode.com/problems/maximum-depth-of-binary-tree/solutions/3093043/easiest-beginner-friendly-solution-dfs-o-n-time-and-o-h-space/?orderBy=hot\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Create a helper function called \"rootToLeafPathSum\" that takes in three parameters: a binary tree node, a target sum, and a current sum.\\n2. Check if the current node is null, and if so, return false.\\n3. Check if the current node is a leaf node (i.e. has no left or right children), and if so, add the value of the node to the current sum.\\n4. If the current sum equals the target sum, return true.\\n5. Recursively call the \"rootToLeafPathSum\" function on the left and right children of the current node, passing in the updated current sum.\\n6. Return the result of the recursive calls.\\n7. In the \"hasPathSum\" function, initialize the current sum to 0 and call the \"rootToLeafPathSum\" function on the root node, passing in the target sum and current sum as parameters.\\n8. Return the result of the \"rootToLeafPathSum\" function call.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool rootToLeafPathSum(TreeNode* root, int targetSum, int sum){\\n        if(root == nullptr)\\n            return false;\\n        if(root -> left == nullptr && root -> right == nullptr){\\n            sum = sum + root -> val;\\n            if(sum == targetSum)\\n                return true;   \\n        }\\n        return rootToLeafPathSum(root -> left, targetSum, sum + root -> val) || rootToLeafPathSum(root -> right, targetSum, sum + root -> val);\\n    }\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        int sum = 0;\\n        return rootToLeafPathSum(root, targetSum, sum);\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean rootToLeafPathSum(TreeNode root, int targetSum, int sum){\\n        if(root == null)\\n            return false;\\n        if(root.left == null && root.right == null){\\n            sum = sum + root.val;\\n            if(sum == targetSum)\\n                return true;   \\n        }\\n        return rootToLeafPathSum(root.left, targetSum, sum + root.val) || rootToLeafPathSum(root.right, targetSum, sum + root.val);\\n    }\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        int sum = 0;\\n        return rootToLeafPathSum(root, targetSum, sum);\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def rootToLeafPathSum(self, root: TreeNode, targetSum: int, sum: int) -> bool:\\n        if root is None:\\n            return False\\n        if root.left is None and root.right is None:\\n            sum += root.val\\n            if sum == targetSum:\\n                return True   \\n        return self.rootToLeafPathSum(root.left, targetSum, sum + root.val) or self.rootToLeafPathSum(root.right, targetSum, sum + root.val)\\n\\n    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:\\n        sum = 0\\n        return self.rootToLeafPathSum(root, targetSum, sum)\\n\\n```\\n- If my solution is helpful to you then please **UPVOTE** my solution, your **UPVOTE** motivates me to post such kind of solution.\\n- Please let me know in comments if there is need to do any improvement in my approach, code....anything.\\n- **Let\\'s connect on** https://www.linkedin.com/in/abhinash-singh-1b851b188\\n![57jfh9.jpg](https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg)\\n\\n# Complexity\\n- Time complexity: **O(n)** // where n is the number of nodes in the tree\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:**O(h)** //where h is the height of the tree\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Binary Tree"
                ],
                "code": "```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool rootToLeafPathSum(TreeNode* root, int targetSum, int sum){\\n        if(root == nullptr)\\n            return false;\\n        if(root -> left == nullptr && root -> right == nullptr){\\n            sum = sum + root -> val;\\n            if(sum == targetSum)\\n                return true;   \\n        }\\n        return rootToLeafPathSum(root -> left, targetSum, sum + root -> val) || rootToLeafPathSum(root -> right, targetSum, sum + root -> val);\\n    }\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        int sum = 0;\\n        return rootToLeafPathSum(root, targetSum, sum);\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean rootToLeafPathSum(TreeNode root, int targetSum, int sum){\\n        if(root == null)\\n            return false;\\n        if(root.left == null && root.right == null){\\n            sum = sum + root.val;\\n            if(sum == targetSum)\\n                return true;   \\n        }\\n        return rootToLeafPathSum(root.left, targetSum, sum + root.val) || rootToLeafPathSum(root.right, targetSum, sum + root.val);\\n    }\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        int sum = 0;\\n        return rootToLeafPathSum(root, targetSum, sum);\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def rootToLeafPathSum(self, root: TreeNode, targetSum: int, sum: int) -> bool:\\n        if root is None:\\n            return False\\n        if root.left is None and root.right is None:\\n            sum += root.val\\n            if sum == targetSum:\\n                return True   \\n        return self.rootToLeafPathSum(root.left, targetSum, sum + root.val) or self.rootToLeafPathSum(root.right, targetSum, sum + root.val)\\n\\n    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:\\n        sum = 0\\n        return self.rootToLeafPathSum(root, targetSum, sum)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 36580,
                "title": "java-solution-both-recursion-and-iteration",
                "content": "  \\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        // iteration method\\n        if (root == null) {return false;}\\n        Stack<TreeNode> path = new Stack<>();\\n        Stack<Integer> sub = new Stack<>();\\n        path.push(root);\\n        sub.push(root.val);\\n        while (!path.isEmpty()) {\\n            TreeNode temp = path.pop();\\n            int tempVal = sub.pop();\\n            if (temp.left == null && temp.right == null) {if (tempVal == sum) return true;}\\n            else {\\n                if (temp.left != null) {\\n                    path.push(temp.left);\\n                    sub.push(temp.left.val + tempVal);\\n                }\\n                if (temp.right != null) {\\n                    path.push(temp.right);\\n                    sub.push(temp.right.val + tempVal);\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n\\n----------\\n\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        // recursion method\\n        if (root == null) return false;\\n        if (root.left == null && root.right == null && root.val == sum) return true;\\n        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "  \\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        // iteration method\\n        if (root == null) {return false;}\\n        Stack<TreeNode> path = new Stack<>();\\n        Stack<Integer> sub = new Stack<>();\\n        path.push(root);\\n        sub.push(root.val);\\n        while (!path.isEmpty()) {\\n            TreeNode temp = path.pop();\\n            int tempVal = sub.pop();\\n            if (temp.left == null && temp.right == null) {if (tempVal == sum) return true;}\\n            else {\\n                if (temp.left != null) {\\n                    path.push(temp.left);\\n                    sub.push(temp.left.val + tempVal);\\n                }\\n                if (temp.right != null) {\\n                    path.push(temp.right);\\n                    sub.push(temp.right.val + tempVal);\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n\\n----------\\n\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        // recursion method\\n        if (root == null) return false;\\n        if (root.left == null && root.right == null && root.val == sum) return true;\\n        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 36382,
                "title": "accepted-by-using-postorder-traversal",
                "content": "In the postorder traversal, the node will be removed from the stack only when the right sub-tree has been visited.so the path will be stored in the stack. we can keep check the SUM, the length from root to leaf node.\\nat leaf node, if SUM == sum, OK, return true. After postorder traversal, return false.\\n\\nI have compared this solution with recursion solutions. In the leetcode OJ, the run time of two solutions is very near.\\n\\nbelow is my iterator code.\\n\\n\\n    class Solution {\\n    public:\\n        bool hasPathSum(TreeNode *root, int sum) {\\n            stack<TreeNode *> s;\\n            TreeNode *pre = NULL, *cur = root;\\n            int SUM = 0;\\n            while (cur || !s.empty()) {\\n                while (cur) {\\n                    s.push(cur);\\n                    SUM += cur->val;\\n                    cur = cur->left;\\n                }\\n                cur = s.top();\\n                if (cur->left == NULL && cur->right == NULL && SUM == sum) {\\n                    return true;\\n                }\\n                if (cur->right && pre != cur->right) {\\n                    cur = cur->right;\\n                } else {\\n                    pre = cur;\\n                    s.pop();\\n                    SUM -= cur->val;\\n                    cur = NULL;\\n                }\\n            }\\n            return false;\\n        }\\n    };",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "class Solution {\\n    public:\\n        bool hasPathSum(TreeNode *root, int sum) {\\n            stack<TreeNode *> s;\\n            TreeNode *pre = NULL, *cur = root;\\n            int SUM = 0;\\n            while (cur || !s.empty()) {\\n                while (cur) {\\n                    s.push(cur);\\n                    SUM += cur->val;\\n                    cur = cur->left;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2658162,
                "title": "c-beats-95-easy-explained-optimized",
                "content": "**PLEASE UPVOTE IF YOU FIND MY APPROACH HELPFUL, MEANS A LOT \\uD83D\\uDE0A**\\n\\n**Ques)** Why we `return left || right` ???\\n**Ans =>** `return left || right` means we are checking either root->left side gives us our targetSum or root->right side gives us our targetSum\\n\\n```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum)\\n    {\\n        if(root == NULL)\\n        {\\n            return false;\\n        }\\n        if(root->left == NULL && root->right == NULL && root->val - targetSum == 0)\\n        {\\n            return true;\\n        }\\n        \\n        bool left = hasPathSum(root->left,targetSum - root->val);\\n        bool right = hasPathSum(root->right,targetSum - root->val);\\n        \\n        return left || right;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/dd5b3b44-6321-44eb-8a47-add0158c3dad_1664857526.350247.png)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum)\\n    {\\n        if(root == NULL)\\n        {\\n            return false;\\n        }\\n        if(root->left == NULL && root->right == NULL && root->val - targetSum == 0)\\n        {\\n            return true;\\n        }\\n        \\n        bool left = hasPathSum(root->left,targetSum - root->val);\\n        bool right = hasPathSum(root->right,targetSum - root->val);\\n        \\n        return left || right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 36534,
                "title": "my-java-no-recursive-method",
                "content": "the idea is preorder traverse , instead of using recursive call, I am using a stack.\\nthe only problem is that I changed TreeNode value\\n\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n    \\t    Stack <TreeNode> stack = new Stack<> ();\\t    \\n    \\t    stack.push(root) ;\\t    \\n    \\t    while (!stack.isEmpty() && root != null){\\n    \\t    \\tTreeNode cur = stack.pop() ;\\t\\n    \\t    \\tif (cur.left == null && cur.right == null){\\t    \\t\\t\\n    \\t    \\t\\tif (cur.val == sum ) return true ;\\n    \\t    \\t}\\n    \\t    \\tif (cur.right != null) {\\n    \\t    \\t\\tcur.right.val = cur.val + cur.right.val ;\\n    \\t    \\t\\tstack.push(cur.right) ;\\n    \\t    \\t}\\n    \\t    \\tif (cur.left != null) {\\n    \\t    \\t\\tcur.left.val = cur.val + cur.left.val;\\n    \\t    \\t\\tstack.push(cur.left);\\n    \\t    \\t}\\n    \\t    }\\t    \\n    \\t    return false ;\\n    \\t }",
                "solutionTags": [],
                "code": "the idea is preorder traverse , instead of using recursive call, I am using a stack.\\nthe only problem is that I changed TreeNode value\\n\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n    \\t    Stack <TreeNode> stack = new Stack<> ();\\t    \\n    \\t    stack.push(root) ;\\t    \\n    \\t    while (!stack.isEmpty() && root != null){\\n    \\t    \\tTreeNode cur = stack.pop() ;\\t\\n    \\t    \\tif (cur.left == null && cur.right == null){\\t    \\t\\t\\n    \\t    \\t\\tif (cur.val == sum ) return true ;\\n    \\t    \\t}\\n    \\t    \\tif (cur.right != null) {\\n    \\t    \\t\\tcur.right.val = cur.val + cur.right.val ;\\n    \\t    \\t\\tstack.push(cur.right) ;\\n    \\t    \\t}\\n    \\t    \\tif (cur.left != null) {\\n    \\t    \\t\\tcur.left.val = cur.val + cur.left.val;\\n    \\t    \\t\\tstack.push(cur.left);\\n    \\t    \\t}\\n    \\t    }\\t    \\n    \\t    return false ;\\n    \\t }",
                "codeTag": "Unknown"
            },
            {
                "id": 1285179,
                "title": "simplest-c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum)\\n    {\\n        if(root == NULL)\\n        {\\n            return false;\\n        }\\n        if(root->left == NULL && root->right == NULL && root->val - targetSum == 0)\\n        {\\n            return true;\\n        }\\n        \\n        bool left = hasPathSum(root->left,targetSum - root->val);\\n        bool right = hasPathSum(root->right,targetSum - root->val);\\n        \\n        return left || right;\\n    }\\n};\\n```\\n**Like the solution?\\nPlease upvote \\u30C4**\\n\\nIf you can\\'t understand any step/point, feel free to comment.\\nHappy to help.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum)\\n    {\\n        if(root == NULL)\\n        {\\n            return false;\\n        }\\n        if(root->left == NULL && root->right == NULL && root->val - targetSum == 0)\\n        {\\n            return true;\\n        }\\n        \\n        bool left = hasPathSum(root->left,targetSum - root->val);\\n        bool right = hasPathSum(root->right,targetSum - root->val);\\n        \\n        return left || right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 36596,
                "title": "one-line-solution-sharing-in-javascript",
                "content": "Since this problem is quite straight forward, so I played around a bit and turned it into the shortest solution as below.\\n\\n    /**\\n     * Memo:\\n     * Complex: O(n)\\n     * Runtime: 164ms\\n     * Tests: 114 test cases passed\\n     * Rank: A\\n     */\\n    var hasPathSum = function(root, sum) { return root ? (!root.left && !root.right) ? sum === root.val : (hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val)) : false; };\\n\\nWhile it is equivalent as the following\\n \\n    var hasPathSum = function(root, sum) {\\n        if (!root) return false;\\n\\n        if (!root.left && !root.right) { // check leaf\\n            return sum === root.val;\\n        } else { // continue DFS\\n            return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n        }\\n    };",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "Since this problem is quite straight forward, so I played around a bit and turned it into the shortest solution as below.\\n\\n    /**\\n     * Memo:\\n     * Complex: O(n)\\n     * Runtime: 164ms\\n     * Tests: 114 test cases passed\\n     * Rank: A\\n     */\\n    var hasPathSum = function(root, sum) { return root ? (!root.left && !root.right) ? sum === root.val : (hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val)) : false; };\\n\\nWhile it is equivalent as the following\\n \\n    var hasPathSum = function(root, sum) {\\n        if (!root) return false;\\n\\n        if (!root.left && !root.right) { // check leaf\\n            return sum === root.val;\\n        } else { // continue DFS\\n            return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n        }\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 36372,
                "title": "easy-5-lines-and-clean-java-solution",
                "content": "   You simply check if current node (starting with root) is a leaf node and sum is equal its value. If not, you just check left or right with the decremented sum. If one of them returns true, it has a path.\\n\\n    public boolean hasPathSum(TreeNode root, int sum) {    \\n      if (root == null)\\n         return false;\\n            \\n      if (root.left == null && root.right == null && root.val == sum) // Leaf check\\n         return true;\\n            \\n      return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "   You simply check if current node (starting with root) is a leaf node and sum is equal its value. If not, you just check left or right with the decremented sum. If one of them returns true, it has a path.\\n\\n    public boolean hasPathSum(TreeNode root, int sum) {    \\n      if (root == null)\\n         return false;\\n            \\n      if (root.left == null && root.right == null && root.val == sum) // Leaf check\\n         return true;\\n            \\n      return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 36370,
                "title": "a-java-concise-solution",
                "content": "    public boolean hasPathSum(TreeNode root, int sum) {\\n       if(root == null){\\n\\t     return false;\\n\\t   }\\n       if(root.left == null && root.right == null){\\n\\t      return (root.val == sum);\\n\\t   }\\n\\t   return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n       \\t   \\n    }",
                "solutionTags": [],
                "code": "    public boolean hasPathSum(TreeNode root, int sum) {\\n       if(root == null){\\n\\t     return false;\\n\\t   }\\n       if(root.left == null && root.right == null){\\n\\t      return (root.val == sum);\\n\\t   }\\n\\t   return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n       \\t   \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1749038,
                "title": "c-efficient-recursive-easy-3-lines-solution-with-comments",
                "content": "#### If you understand the approach please please upvote!!!\\n***Thanks :)***\\n```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return false;\\n        \\n        //we reached here,i.e the root is not NULL, so we took the root value in our sum, and remaining targetSum is targetSum-root value.\\n        targetSum=targetSum-root->val;\\n        \\n        //if the current node is a leaf and its value is equal to the sum, we\\'ve found a path\\n        if(targetSum==0 && root->left==NULL && root->right==NULL) return true;\\n        \\n        // recursively call to traverse the left and right sub-tree\\n        // return true if any of the two recursive call return true\\n        return hasPathSum(root->left,targetSum) || hasPathSum(root->right,targetSum);\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return false;\\n        \\n        //we reached here,i.e the root is not NULL, so we took the root value in our sum, and remaining targetSum is targetSum-root value.\\n        targetSum=targetSum-root->val;\\n        \\n        //if the current node is a leaf and its value is equal to the sum, we\\'ve found a path\\n        if(targetSum==0 && root->left==NULL && root->right==NULL) return true;\\n        \\n        // recursively call to traverse the left and right sub-tree\\n        // return true if any of the two recursive call return true\\n        return hasPathSum(root->left,targetSum) || hasPathSum(root->right,targetSum);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 534122,
                "title": "python-bfs-dfs-recursive-dfs-iterative-solution",
                "content": "#### I. DFS recursive solution\\nAlgorithm:\\n1. Visit a node and check that node is leaf and node.val == sum. If it\\'s true - return True, else continue traverse\\n2. Traverse the left subtree and decrease current sum by value of current node , i.e., call `hasPathSum(node.left, curr_sum - node.val)`\\n3. Traverse the right subtree and decrease current sum by value of current node , i.e., call `hasPathSum(node.right, curr_sum - node.val)`\\n```Python\\ndef hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n\\tif not root:\\n\\t\\treturn False\\n\\tif not root.left and not root.right and root.val == sum:\\n\\t\\treturn True\\n\\treturn self.hasPathSum(root.left, sum - root.val) or self.hasPathSum(root.right, sum - root.val)\\n```\\n\\n#### II. DFS iterative solution\\nAlgorithm:\\n1. Create empty stack and push root node and current sum to stack.\\n2. Do followind steps while stack is not empty:\\n\\t * Pop `(node, curr_sum)` from stack\\n\\t * Cheack that node is leaf and `node.val == sum`. If it\\'s true - return True, else go to the next step\\n\\t * Push left child of popped node and current sum decreased by popped node value `(node.left, curr_sum - node.val)`.\\n\\t * Push right child of popped node and current sum decreased by popped node value `(node.right, curr_sum - node.val)`.\\n3. Return False if sum is not found.\\n```Python\\ndef hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n\\tstack = [(root, sum)]\\n\\twhile stack:\\n\\t\\tnode, curr_sum = stack.pop()\\n\\tif not node:\\n\\t\\tcontinue\\n\\tif not node.left and not node.right and curr_sum == node.val:\\n\\t\\treturn True\\n\\tstack.append((node.left, curr_sum - node.val))\\n\\tstack.append((node.right, curr_sum - node.val))\\n\\treturn False\\n```\\n\\n#### III. BFS Solution\\n\\nAlgorithm:\\n1. Create empty deque (double-ended queue) and push root node and current sum to queue.\\n2. Do followind steps while queue is not empty:\\n\\t * Do popfront/popleft `(node, curr_sum)` from queue\\n\\t * If node is None - continue\\n\\t * Cheack that node is leaf and `node.val == sum`. If it\\'s true - return True, else go to the next step\\n\\t * Push left child of popped node and current sum decreased by popped node value `(node.left, curr_sum - node.val)` to the queue.\\n\\t * Push right child of popped node and current sum decreased by popped node value `(node.right, curr_sum - node.val)` to the queue.\\n3. Return False if sum is not found.\\n\\n```Python\\nfrom collections import deque\\n\\ndef hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n\\tdeq = deque()\\n\\tdeq.append((root, sum))\\n\\t\\twhile deq:\\n\\t\\t\\tnode, curr_sum = deq.popleft()\\n\\t\\t\\tif not node:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tif not node.left and not node.right and curr_sum == node.val:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\tdeq.append((node.left, curr_sum - node.val))\\n\\t\\t\\tdeq.append((node.right, curr_sum - node.val))\\n\\treturn False\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```Python\\ndef hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n\\tif not root:\\n\\t\\treturn False\\n\\tif not root.left and not root.right and root.val == sum:\\n\\t\\treturn True\\n\\treturn self.hasPathSum(root.left, sum - root.val) or self.hasPathSum(root.right, sum - root.val)\\n```\n```Python\\ndef hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n\\tstack = [(root, sum)]\\n\\twhile stack:\\n\\t\\tnode, curr_sum = stack.pop()\\n\\tif not node:\\n\\t\\tcontinue\\n\\tif not node.left and not node.right and curr_sum == node.val:\\n\\t\\treturn True\\n\\tstack.append((node.left, curr_sum - node.val))\\n\\tstack.append((node.right, curr_sum - node.val))\\n\\treturn False\\n```\n```Python\\nfrom collections import deque\\n\\ndef hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n\\tdeq = deque()\\n\\tdeq.append((root, sum))\\n\\t\\twhile deq:\\n\\t\\t\\tnode, curr_sum = deq.popleft()\\n\\t\\t\\tif not node:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tif not node.left and not node.right and curr_sum == node.val:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\tdeq.append((node.left, curr_sum - node.val))\\n\\t\\t\\tdeq.append((node.right, curr_sum - node.val))\\n\\treturn False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1329291,
                "title": "java-three-easy-approach-with-explanation-preorder-postorder-0ms",
                "content": "```\\n1 st Approach \\nclass Solution\\n{\\n    public boolean hasPathSum(TreeNode root, int targetSum)//we always try to approach the zero ----0++++ from any half left or right, like taking limit//if zero found at leaf then true else false\\n    {\\n        if(root == null)\\n            return false;//base case when the selected path is not the desired path //we return false and check in next half of the subtree//base case for terminnation of the recursion \\n        else if(root.left == null && root.right == null && targetSum - root.val == 0)//we have faith in tree that it can find the node if present where the value nutralizes each other at 0\\n            return true;//only the case when we are returning true \\n        else\\n            return hasPathSum(root.left,targetSum - root.val)||hasPathSum(root.right,targetSum - root.val);//if present in left is good otherwiswe we are searching in right subtree recursively //all permutation in ways are done by recursion and not our tension \\n    }\\n}//Please do Upvote, It helps a lot\\n```\\n```\\n2 nd Approach \\n\\nclass Solution \\n{\\n    private boolean flag= false;//we are taking the base case as false, if the sum is not found and if the target sum lies in the path from root to leaf, we make the flag true  \\n    \\n    public boolean hasPathSum(TreeNode root, int targetSum) \\n    {\\n        int sum = 0;//calculate the downward sum \\n        \\n        Helper(root, sum, targetSum);//it helps us calculate  the sum of each node for each path from root to leaf and tells us that our desired sum is present or not, by adding the node at that path \\n        \\n        return flag;//returns true if sum is present else false is returned \\n    }\\n    public TreeNode  Helper(TreeNode root, int sum, int targetSum)\\n    {//postorder traversal + semi preorder traversal(accesing root beforehand once), we want to know about child first and then the parent \\n        if(root == null)//base case when we hit the null node, to tell the parent no node is present we return null \\n            return null;\\n        //ROOT\\n        sum= sum + root.val;//adding the node value to sum at each level//accesing root beforehand once\\n        \\n        TreeNode left= Helper(root.left, sum, targetSum);//recursing down the left subtree and knowing about the left child//storring the reference to detect it is leaf or not, if it is leaf then left == null//LEFT\\n        TreeNode right= Helper(root.right, sum, targetSum);//recursing down the right subtree and knowing about the right child//storring the reference to detect it is leaf or not, if it is leaf then right == null//RIGHT\\n        \\n        //ROOT\\n        if(sum == targetSum && left == null && right == null) //if we reached to our desired sum and the parent node is a leaf node, we got our path finally \\n            flag= true;//we make the flag to true as the desired path from root to leaf is achived \\n        \\n        return root;//returning root, to tell the parent that I am present \\n    }\\n}\\n```\\n```\\n3 rd Approach \\nclass Solution {\\n    //0 -- null node, 1 means node, 2 found path node //metadata about the current status of the node \\n     public int PathSum(TreeNode root, int curr, int targetSum){\\n         if ( root == null){\\n            return 0;//we return 0 to tell that i am leaf \\n        }\\n         curr+= root.val;//preorder sum\\n         \\n         int left= PathSum(root.left, curr, targetSum);\\n         \\n         if ( left == 2 )\\n             return 2;//if left path conatins the desired path to leaf node with target sum, we no need to go to right part reccursively\\n         \\n        int right= PathSum(root.right, curr, targetSum);\\n         \\n        if ( right == 2)\\n             return 2;//if right path conatins the desired path to leaf node with target sum, we no need to check further condition we just return 2 in order to indicate desired path has been found\\n         \\n         //Backtracking postorder traversal \\n         \\n        if ( left == 0 && right == 0 && targetSum == curr){//if we reach to leaf node with desired sum we return 2, inorder to indicate we have found the path \\n             return 2;\\n        }\\n        \\n        return 1;//we return 1, to tell that we have not found the desired path till now  \\n     }\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if ( root == null){\\n            return false;//empty graph, no path tp find we return false \\n        }\\n        \\n        if ( PathSum(root, 0, targetSum) == 2)//found path case \\n            return true;\\n        else\\n            return false;//not path found case \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n1 st Approach \\nclass Solution\\n{\\n    public boolean hasPathSum(TreeNode root, int targetSum)//we always try to approach the zero ----0++++ from any half left or right, like taking limit//if zero found at leaf then true else false\\n    {\\n        if(root == null)\\n            return false;//base case when the selected path is not the desired path //we return false and check in next half of the subtree//base case for terminnation of the recursion \\n        else if(root.left == null && root.right == null && targetSum - root.val == 0)//we have faith in tree that it can find the node if present where the value nutralizes each other at 0\\n            return true;//only the case when we are returning true \\n        else\\n            return hasPathSum(root.left,targetSum - root.val)||hasPathSum(root.right,targetSum - root.val);//if present in left is good otherwiswe we are searching in right subtree recursively //all permutation in ways are done by recursion and not our tension \\n    }\\n}//Please do Upvote, It helps a lot\\n```\n```\\n2 nd Approach \\n\\nclass Solution \\n{\\n    private boolean flag= false;//we are taking the base case as false, if the sum is not found and if the target sum lies in the path from root to leaf, we make the flag true  \\n    \\n    public boolean hasPathSum(TreeNode root, int targetSum) \\n    {\\n        int sum = 0;//calculate the downward sum \\n        \\n        Helper(root, sum, targetSum);//it helps us calculate  the sum of each node for each path from root to leaf and tells us that our desired sum is present or not, by adding the node at that path \\n        \\n        return flag;//returns true if sum is present else false is returned \\n    }\\n    public TreeNode  Helper(TreeNode root, int sum, int targetSum)\\n    {//postorder traversal + semi preorder traversal(accesing root beforehand once), we want to know about child first and then the parent \\n        if(root == null)//base case when we hit the null node, to tell the parent no node is present we return null \\n            return null;\\n        //ROOT\\n        sum= sum + root.val;//adding the node value to sum at each level//accesing root beforehand once\\n        \\n        TreeNode left= Helper(root.left, sum, targetSum);//recursing down the left subtree and knowing about the left child//storring the reference to detect it is leaf or not, if it is leaf then left == null//LEFT\\n        TreeNode right= Helper(root.right, sum, targetSum);//recursing down the right subtree and knowing about the right child//storring the reference to detect it is leaf or not, if it is leaf then right == null//RIGHT\\n        \\n        //ROOT\\n        if(sum == targetSum && left == null && right == null) //if we reached to our desired sum and the parent node is a leaf node, we got our path finally \\n            flag= true;//we make the flag to true as the desired path from root to leaf is achived \\n        \\n        return root;//returning root, to tell the parent that I am present \\n    }\\n}\\n```\n```\\n3 rd Approach \\nclass Solution {\\n    //0 -- null node, 1 means node, 2 found path node //metadata about the current status of the node \\n     public int PathSum(TreeNode root, int curr, int targetSum){\\n         if ( root == null){\\n            return 0;//we return 0 to tell that i am leaf \\n        }\\n         curr+= root.val;//preorder sum\\n         \\n         int left= PathSum(root.left, curr, targetSum);\\n         \\n         if ( left == 2 )\\n             return 2;//if left path conatins the desired path to leaf node with target sum, we no need to go to right part reccursively\\n         \\n        int right= PathSum(root.right, curr, targetSum);\\n         \\n        if ( right == 2)\\n             return 2;//if right path conatins the desired path to leaf node with target sum, we no need to check further condition we just return 2 in order to indicate desired path has been found\\n         \\n         //Backtracking postorder traversal \\n         \\n        if ( left == 0 && right == 0 && targetSum == curr){//if we reach to leaf node with desired sum we return 2, inorder to indicate we have found the path \\n             return 2;\\n        }\\n        \\n        return 1;//we return 1, to tell that we have not found the desired path till now  \\n     }\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if ( root == null){\\n            return false;//empty graph, no path tp find we return false \\n        }\\n        \\n        if ( PathSum(root, 0, targetSum) == 2)//found path case \\n            return true;\\n        else\\n            return false;//not path found case \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054429,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(!root)\\n            return false;\\n        if(!root->left && !root->right && root->val==targetSum)\\n            return true;\\n        else\\n            return hasPathSum(root->left, targetSum-root->val) ||\\n            hasPathSum(root->right, targetSum-root->val);\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(!root)\\n            return false;\\n        if(!root->left && !root->right && root->val==targetSum)\\n            return true;\\n        else\\n            return hasPathSum(root->left, targetSum-root->val) ||\\n            hasPathSum(root->right, targetSum-root->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 36581,
                "title": "my-python-iterative-dfs-solution",
                "content": "    \\n    def hasPathSum(self, root, sum):\\n        if root is None:\\n            return False\\n        stack = [(root, sum)]\\n        while stack:\\n            node, _sum = stack.pop()\\n            if node.left is node.right is None and node.val == _sum:\\n                return True\\n            if node.left:\\n                stack.append((node.left, _sum - node.val))\\n            if node.right:\\n                stack.append((node.right, _sum - node.val))\\n        return False\\n\\n\\nCurrent node and the sum until current node as a tuple is pushed onto the stack to keep track of the sum.",
                "solutionTags": [
                    "Python"
                ],
                "code": "    \\n    def hasPathSum(self, root, sum):\\n        if root is None:\\n            return False\\n        stack = [(root, sum)]\\n        while stack:\\n            node, _sum = stack.pop()\\n            if node.left is node.right is None and node.val == _sum:\\n                return True\\n            if node.left:\\n                stack.append((node.left, _sum - node.val))\\n            if node.right:\\n                stack.append((node.right, _sum - node.val))\\n        return False\\n\\n\\nCurrent node and the sum until current node as a tuple is pushed onto the stack to keep track of the sum.",
                "codeTag": "Python3"
            },
            {
                "id": 518530,
                "title": "c-97-runtime-iterative-and-recursive-solution",
                "content": "Iterative Solution \\n```\\nbool hasPathSum(TreeNode* root, int sum) {\\n        if(root == NULL) return false;\\n        stack<pair<TreeNode*,int>> stack;\\n        stack.push({root, root->val});\\n        while(!stack.empty()) {\\n            TreeNode* current = stack.top().first; \\n            int total_sum = stack.top().second; stack.pop();\\n            if(current->right) stack.push({current->right, total_sum+current->right->val});\\n            if(current->left) stack.push({current->left, total_sum+current->left->val});\\n            if(!current->right && !current->left && total_sum==sum) { //if its a leaf\\n                return true; //and total sum is found\\n            }\\n        }\\n        return false;\\n    }\\n```\\n\\nRecursive Solution\\n```\\nbool hasPathSum(TreeNode* root, int sum) {\\n        if(root == NULL) return false;\\n        int new_sum = sum - root->val;\\n        if(!root->left && !root->right) return new_sum==0;\\n        return hasPathSum(root->left, new_sum) || hasPathSum(root->right, new_sum);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nbool hasPathSum(TreeNode* root, int sum) {\\n        if(root == NULL) return false;\\n        stack<pair<TreeNode*,int>> stack;\\n        stack.push({root, root->val});\\n        while(!stack.empty()) {\\n            TreeNode* current = stack.top().first; \\n            int total_sum = stack.top().second; stack.pop();\\n            if(current->right) stack.push({current->right, total_sum+current->right->val});\\n            if(current->left) stack.push({current->left, total_sum+current->left->val});\\n            if(!current->right && !current->left && total_sum==sum) { //if its a leaf\\n                return true; //and total sum is found\\n            }\\n        }\\n        return false;\\n    }\\n```\n```\\nbool hasPathSum(TreeNode* root, int sum) {\\n        if(root == NULL) return false;\\n        int new_sum = sum - root->val;\\n        if(!root->left && !root->right) return new_sum==0;\\n        return hasPathSum(root->left, new_sum) || hasPathSum(root->right, new_sum);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 170024,
                "title": "python-solution",
                "content": "Recursion:\\n```\\nclass Solution(object):\\n    def hasPathSum(self, root, sum):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type sum: int\\n        :rtype: bool\\n        \"\"\"\\n        if not root:\\n            return False\\n        elif not root.left and not root.right:\\n            if root.val == sum:\\n                return True\\n            else:\\n                return False\\n        return self.hasPathSum(root.left, sum - root.val) or self.hasPathSum(root.right, sum - root.val)\\n```\\nDFS:\\n```\\nclass Solution(object):\\n    def hasPathSum(self, root, sum):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type sum: int\\n        :rtype: bool\\n        \"\"\"\\n        if not root:\\n            return False\\n        stack = [(root,sum - root.val)]\\n        while stack:\\n            u = stack.pop()\\n            if not u[0].left and not u[0].right:\\n                if u[1] == 0:\\n                    return True\\n            if u[0].left:\\n                stack.append((u[0].left, u[1]-u[0].left.val))\\n            if u[0].right:\\n                stack.append((u[0].right, u[1]-u[0].right.val))\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def hasPathSum(self, root, sum):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type sum: int\\n        :rtype: bool\\n        \"\"\"\\n        if not root:\\n            return False\\n        elif not root.left and not root.right:\\n            if root.val == sum:\\n                return True\\n            else:\\n                return False\\n        return self.hasPathSum(root.left, sum - root.val) or self.hasPathSum(root.right, sum - root.val)\\n```\n```\\nclass Solution(object):\\n    def hasPathSum(self, root, sum):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type sum: int\\n        :rtype: bool\\n        \"\"\"\\n        if not root:\\n            return False\\n        stack = [(root,sum - root.val)]\\n        while stack:\\n            u = stack.pop()\\n            if not u[0].left and not u[0].right:\\n                if u[1] == 0:\\n                    return True\\n            if u[0].left:\\n                stack.append((u[0].left, u[1]-u[0].left.val))\\n            if u[0].right:\\n                stack.append((u[0].right, u[1]-u[0].right.val))\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977919,
                "title": "easy-solution-python3-c-c-c-java-explain-line-by-line-with-image",
                "content": "# Problem\\nYou\\'re given a binary tree and an integer targetSum. The task is to determine whether there exists a root-to-leaf path in the tree where the sum of the values of the nodes along the path equals the targetSum.\\n\\nIn other words, you need to check if there\\'s a sequence of nodes starting from the root and following edges to reach a leaf node such that the sum of values along this path is equal to the given targetSum.\\n\\n\\n---\\n# Solution\\nThe provided solution is implemented as a method named hasPathSum within a class named Solution. The method takes two parameters: root, which is the root node of the binary tree, and targetSum, the desired sum.\\n\\n\\n**Here\\'s how the solution works:** \\n\\n1. f root is None (i.e., the tree is empty), there can\\'t be any path with the desired sum. So, the function returns False.\\n2. If root is a leaf node (i.e., it has no left or right children), the function checks whether the value of the leaf node is equal to the remaining targetSum. If they are equal, it returns True, indicating that a valid path with the target sum has been found.\\n3. If the above conditions are not met, the function recursively checks for a valid path with the target sum in both the left and right subtrees. It subtracts the value of the current node from the targetSum before passing it to the recursive calls.\\n4. The result of the recursive calls on the left and right subtrees (left_sum and right_sum) are then combined using the logical OR operation. This is because if either the left subtree or the right subtree has a valid path, it means there\\'s a valid path in the entire tree, so the function should return True.\\n5. If none of the above conditions are met, the function returns False.\\n\\nThe base cases (when the tree is empty or when a leaf node with a matching value is found) guarantee that the recursion will eventually terminate. The recursion explores all possible paths from the root to leaf nodes, checking if any of them sum up to the given targetSum. The logical OR operation on the results of the recursive calls ensures that the function correctly returns True if a valid path is found anywhere in the tree.\\n\\nThis solution has a time complexity of O(N), where N is the number of nodes in the binary tree, as it visits each node once in the worst case.\\n\\n![Screenshot 2023-08-20 065922.png](https://assets.leetcode.com/users/images/5bd15a5a-5ff9-4683-82d9-2c25a18bc26a_1693336283.4753764.png)\\n\\n\\n# Code\\n---\\n\\n```Python3 []\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        \\n        if not root.left and not root.right:\\n            return targetSum == root.val\\n        \\n        left_sum = self.hasPathSum(root.left, targetSum - root.val)\\n        right_sum = self.hasPathSum(root.right, targetSum - root.val)\\n        \\n        return left_sum or right_sum\\n```\\n```python []\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        \\n        if not root.left and not root.right:\\n            return targetSum == root.val\\n        \\n        left_sum = self.hasPathSum(root.left, targetSum - root.val)\\n        right_sum = self.hasPathSum(root.right, targetSum - root.val)\\n        \\n        return left_sum or right_sum\\n```\\n```C# []\\npublic class Solution\\n{\\n    public bool HasPathSum(TreeNode root, int targetSum)\\n    {\\n        if (root == null)\\n        {\\n            return false;\\n        }\\n\\n        if (root.left == null && root.right == null)\\n        {\\n            return targetSum == root.val;\\n        }\\n\\n        bool leftSum = HasPathSum(root.left, targetSum - root.val);\\n        bool rightSum = HasPathSum(root.right, targetSum - root.val);\\n\\n        return leftSum || rightSum;\\n    }\\n}\\n```\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if (!root) {\\n            return false;\\n        }\\n        \\n        if (!root->left && !root->right) {\\n            return targetSum == root->val;\\n        }\\n        \\n        bool left_sum = hasPathSum(root->left, targetSum - root->val);\\n        bool right_sum = hasPathSum(root->right, targetSum - root->val);\\n        \\n        return left_sum || right_sum;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) {\\n            return false;\\n        }\\n        \\n        if (root.left == null && root.right == null) {\\n            return targetSum == root.val;\\n        }\\n        \\n        boolean leftSum = hasPathSum(root.left, targetSum - root.val);\\n        boolean rightSum = hasPathSum(root.right, targetSum - root.val);\\n        \\n        return leftSum || rightSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "C#"
                ],
                "code": "```Python3 []\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        \\n        if not root.left and not root.right:\\n            return targetSum == root.val\\n        \\n        left_sum = self.hasPathSum(root.left, targetSum - root.val)\\n        right_sum = self.hasPathSum(root.right, targetSum - root.val)\\n        \\n        return left_sum or right_sum\\n```\n```python []\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        \\n        if not root.left and not root.right:\\n            return targetSum == root.val\\n        \\n        left_sum = self.hasPathSum(root.left, targetSum - root.val)\\n        right_sum = self.hasPathSum(root.right, targetSum - root.val)\\n        \\n        return left_sum or right_sum\\n```\n```C# []\\npublic class Solution\\n{\\n    public bool HasPathSum(TreeNode root, int targetSum)\\n    {\\n        if (root == null)\\n        {\\n            return false;\\n        }\\n\\n        if (root.left == null && root.right == null)\\n        {\\n            return targetSum == root.val;\\n        }\\n\\n        bool leftSum = HasPathSum(root.left, targetSum - root.val);\\n        bool rightSum = HasPathSum(root.right, targetSum - root.val);\\n\\n        return leftSum || rightSum;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if (!root) {\\n            return false;\\n        }\\n        \\n        if (!root->left && !root->right) {\\n            return targetSum == root->val;\\n        }\\n        \\n        bool left_sum = hasPathSum(root->left, targetSum - root->val);\\n        bool right_sum = hasPathSum(root->right, targetSum - root->val);\\n        \\n        return left_sum || right_sum;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) {\\n            return false;\\n        }\\n        \\n        if (root.left == null && root.right == null) {\\n            return targetSum == root.val;\\n        }\\n        \\n        boolean leftSum = hasPathSum(root.left, targetSum - root.val);\\n        boolean rightSum = hasPathSum(root.right, targetSum - root.val);\\n        \\n        return leftSum || rightSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658019,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\nI\\'ll explain my solution line by line daily and you can find the full list in my [Discord](https://discord.gg/Nqm4jJcyBf).\\nIf you like it, please give a star, watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/PNj2PJfY/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\nI\\'ll explain my solution line by line daily and you can find the full list in my [Discord](https://discord.gg/Nqm4jJcyBf).\\nIf you like it, please give a star, watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/PNj2PJfY/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 36489,
                "title": "3-line-java-solution",
                "content": "\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if (root == null) return false;\\n        if (root.left == null && root.right == null && root.val == sum) return true;\\n        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if (root == null) return false;\\n        if (root.left == null && root.right == null && root.val == sum) return true;\\n        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2658792,
                "title": "python-elegant-short-dfs",
                "content": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n)\\n    Memory: O(n)\\n    \"\"\"\\n\\n    def hasPathSum(self, root: Optional[TreeNode], target: int) -> bool:\\n        if root is None:\\n            return False\\n        if root.left is None and root.right is None:\\n            return target == root.val\\n        return self.hasPathSum( root.left, target - root.val) or \\\\\\n               self.hasPathSum(root.right, target - root.val)\\n```\\n\\nIf you like this solution remember to **upvote it** to let me know.\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n)\\n    Memory: O(n)\\n    \"\"\"\\n\\n    def hasPathSum(self, root: Optional[TreeNode], target: int) -> bool:\\n        if root is None:\\n            return False\\n        if root.left is None and root.right is None:\\n            return target == root.val\\n        return self.hasPathSum( root.left, target - root.val) or \\\\\\n               self.hasPathSum(root.right, target - root.val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1255933,
                "title": "c-dfs-multiple-solutions",
                "content": "```\\nSolution 1: \\nclass Solution {\\npublic:\\n    \\n    int pathSum = 0; \\n    bool pathFound = false;\\n    \\n    bool hasPathSum(TreeNode* root, int targetSum) \\n    {                \\n        if(root != NULL)\\n        {\\n            pathSum += root->val;\\n            \\n            if(root->left == NULL && root->right == NULL)\\n            {\\n                if(pathSum == targetSum)\\n                    pathFound = true;\\n            }\\n            else\\n            {\\n                hasPathSum(root->left, targetSum);\\n                hasPathSum(root->right, targetSum);\\n            }\\n            \\n            pathSum -= root->val;    \\n        }\\n\\n        return (pathFound == true) ? true : false;\\n     }\\n};\\n\\nSolution 2: \\n\\nclass Solution {\\npublic:\\n    \\n   \\n    bool hasPathSum(TreeNode* root, int targetSum) \\n    {        \\n        if (root == nullptr) \\n        {\\n          return false;\\n        }\\n\\n        // if the current node is a leaf and its value is equal to the sum, we\\'ve found a path\\n        if (root->val == targetSum && root->left == nullptr && root->right == nullptr) \\n        {\\n          return true;\\n        }\\n\\t\\t\\n        // recursively call to traverse the left and right sub-tree\\n        // return true if any of the two recursive call return true\\n        return hasPathSum(root->left, targetSum - root->val) || hasPathSum(root->right, targetSum - root->val);\\n     }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nSolution 1: \\nclass Solution {\\npublic:\\n    \\n    int pathSum = 0; \\n    bool pathFound = false;\\n    \\n    bool hasPathSum(TreeNode* root, int targetSum) \\n    {                \\n        if(root != NULL)\\n        {\\n            pathSum += root->val;\\n            \\n            if(root->left == NULL && root->right == NULL)\\n            {\\n                if(pathSum == targetSum)\\n                    pathFound = true;\\n            }\\n            else\\n            {\\n                hasPathSum(root->left, targetSum);\\n                hasPathSum(root->right, targetSum);\\n            }\\n            \\n            pathSum -= root->val;    \\n        }\\n\\n        return (pathFound == true) ? true : false;\\n     }\\n};\\n\\nSolution 2: \\n\\nclass Solution {\\npublic:\\n    \\n   \\n    bool hasPathSum(TreeNode* root, int targetSum) \\n    {        \\n        if (root == nullptr) \\n        {\\n          return false;\\n        }\\n\\n        // if the current node is a leaf and its value is equal to the sum, we\\'ve found a path\\n        if (root->val == targetSum && root->left == nullptr && root->right == nullptr) \\n        {\\n          return true;\\n        }\\n\\t\\t\\n        // recursively call to traverse the left and right sub-tree\\n        // return true if any of the two recursive call return true\\n        return hasPathSum(root->left, targetSum - root->val) || hasPathSum(root->right, targetSum - root->val);\\n     }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 36470,
                "title": "u3010python-u3011recursive-solution-with-explanation-and-thinking-process",
                "content": "## Base case\\n1. This question wants to find a path from node to the **leaf**, so the node who satisfies must be a **leaf** (`not node.left and not nood.right`)\\n2. I want to recursively subtract the `sum` by current node's value, so the leaf node of correct path must have the same value of its assigned `sum`\\n\\n## Recursive step\\n1. We want to traverse all the nodes, so `node.left` and `node.right` must be called parallelly\\n2. One valid path is enough, so we want to use `or` to connect two \"branches\"\\n3. Considering each node as the root of its children, `sum` should be modified from its parent\\n\\n<br>\\n\\n    def hasPathSum(self, root, sum):\\n        if not root:\\n            return False\\n            \\n        if root.val == sum and not root.left and not root.right:\\n            return True\\n            \\n        return self.hasPathSum(root.left, sum - root.val) or \\\\\\n               self.hasPathSum(root.right, sum - root.val)",
                "solutionTags": [
                    "Python"
                ],
                "code": "## Base case\\n1. This question wants to find a path from node to the **leaf**, so the node who satisfies must be a **leaf** (`not node.left and not nood.right`)\\n2. I want to recursively subtract the `sum` by current node's value, so the leaf node of correct path must have the same value of its assigned `sum`\\n\\n## Recursive step\\n1. We want to traverse all the nodes, so `node.left` and `node.right` must be called parallelly\\n2. One valid path is enough, so we want to use `or` to connect two \"branches\"\\n3. Considering each node as the root of its children, `sum` should be modified from its parent\\n\\n<br>\\n\\n    def hasPathSum(self, root, sum):\\n        if not root:\\n            return False\\n            \\n        if root.val == sum and not root.left and not root.right:\\n            return True\\n            \\n        return self.hasPathSum(root.left, sum - root.val) or \\\\\\n               self.hasPathSum(root.right, sum - root.val)",
                "codeTag": "Python3"
            },
            {
                "id": 2432844,
                "title": "very-easy-100-3-line-explained-java-c-python-js-c-python3",
                "content": "# **Java Solution:**\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Path Sum.\\n```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        // If the tree is empty i.e. root is NULL, return false...\\n\\t    if (root == null) return false;\\n        // If there is only a single root node and the value of root node is equal to the targetSum...\\n\\t    if (root.val == targetSum && (root.left == null && root.right == null)) return true;\\n        // Call the same function recursively for left and right subtree...\\n\\t    return hasPathSum(root.left, targetSum - root.val)|| hasPathSum(root.right, targetSum - root.val);\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\nRuntime: 6 ms, faster than 89.18% of C++ online submissions for Path Sum.\\nMemory Usage: 11.2 MB, less than 92.17% of C++ online submissions for Path Sum.\\n```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        // If the tree is empty i.e. root is NULL, return false...\\n\\t    if (root == NULL) return false;\\n        // If there is only a single root node and the value of root node is equal to the targetSum...\\n\\t    if (root->val == targetSum && (root->left == NULL && root->right == NULL)) return true;\\n        // Call the same function recursively for left and right subtree...\\n\\t    return hasPathSum(root->left, targetSum - root->val)|| hasPathSum(root->right, targetSum - root->val);\\n    }\\n};\\n```\\n\\n\\n# **Python Solution:**\\n```\\nclass Solution(object):\\n    def hasPathSum(self, root, targetSum):\\n        # If the tree is empty i.e. root is NULL, return false...\\n\\t    if root is None: return 0\\n        # If there is only a single root node and the value of root node is equal to the targetSum...\\n\\t    if root.val == targetSum and (root.left is None and root.right is None):  return 1\\n        # Call the same function recursively for left and right subtree...\\n\\t    return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\\n```\\n            \\n# **JavaScript Solution:**\\n```\\nvar hasPathSum = function(root, targetSum) {\\n    // If the tree is empty i.e. root is NULL, return false...\\n\\tif (root == null) return false;\\n    // If there is only a single root node and the value of root node is equal to the targetSum...\\n\\tif (root.val == targetSum && (root.left == null && root.right == null)) return true;\\n    // Call the same function recursively for left and right subtree...\\n\\treturn hasPathSum(root.left, targetSum - root.val)|| hasPathSum(root.right, targetSum - root.val);\\n};\\n```\\n\\n# **C Language:**\\n```\\nbool hasPathSum(struct TreeNode* root, int targetSum){\\n    // If the tree is empty i.e. root is NULL, return false...\\n\\tif (root == NULL) return false;\\n    // If there is only a single root node and the value of root node is equal to the targetSum...\\n\\tif (root->val == targetSum && (root->left == NULL && root->right == NULL)) return true;\\n    // Call the same function recursively for left and right subtree...\\n\\treturn hasPathSum(root->left, targetSum - root->val)|| hasPathSum(root->right, targetSum - root->val);\\n}\\n```\\n\\n# **Python3 Solution:**\\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        # If the tree is empty i.e. root is NULL, return false...\\n\\t    if root is None: return 0\\n        # If there is only a single root node and the value of root node is equal to the targetSum...\\n\\t    if root.val == targetSum and (root.left is None and root.right is None):  return 1\\n        # Call the same function recursively for left and right subtree...\\n\\t    return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\\n```\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        // If the tree is empty i.e. root is NULL, return false...\\n\\t    if (root == null) return false;\\n        // If there is only a single root node and the value of root node is equal to the targetSum...\\n\\t    if (root.val == targetSum && (root.left == null && root.right == null)) return true;\\n        // Call the same function recursively for left and right subtree...\\n\\t    return hasPathSum(root.left, targetSum - root.val)|| hasPathSum(root.right, targetSum - root.val);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        // If the tree is empty i.e. root is NULL, return false...\\n\\t    if (root == NULL) return false;\\n        // If there is only a single root node and the value of root node is equal to the targetSum...\\n\\t    if (root->val == targetSum && (root->left == NULL && root->right == NULL)) return true;\\n        // Call the same function recursively for left and right subtree...\\n\\t    return hasPathSum(root->left, targetSum - root->val)|| hasPathSum(root->right, targetSum - root->val);\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def hasPathSum(self, root, targetSum):\\n        # If the tree is empty i.e. root is NULL, return false...\\n\\t    if root is None: return 0\\n        # If there is only a single root node and the value of root node is equal to the targetSum...\\n\\t    if root.val == targetSum and (root.left is None and root.right is None):  return 1\\n        # Call the same function recursively for left and right subtree...\\n\\t    return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\\n```\n```\\nvar hasPathSum = function(root, targetSum) {\\n    // If the tree is empty i.e. root is NULL, return false...\\n\\tif (root == null) return false;\\n    // If there is only a single root node and the value of root node is equal to the targetSum...\\n\\tif (root.val == targetSum && (root.left == null && root.right == null)) return true;\\n    // Call the same function recursively for left and right subtree...\\n\\treturn hasPathSum(root.left, targetSum - root.val)|| hasPathSum(root.right, targetSum - root.val);\\n};\\n```\n```\\nbool hasPathSum(struct TreeNode* root, int targetSum){\\n    // If the tree is empty i.e. root is NULL, return false...\\n\\tif (root == NULL) return false;\\n    // If there is only a single root node and the value of root node is equal to the targetSum...\\n\\tif (root->val == targetSum && (root->left == NULL && root->right == NULL)) return true;\\n    // Call the same function recursively for left and right subtree...\\n\\treturn hasPathSum(root->left, targetSum - root->val)|| hasPathSum(root->right, targetSum - root->val);\\n}\\n```\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        # If the tree is empty i.e. root is NULL, return false...\\n\\t    if root is None: return 0\\n        # If there is only a single root node and the value of root node is equal to the targetSum...\\n\\t    if root.val == targetSum and (root.left is None and root.right is None):  return 1\\n        # Call the same function recursively for left and right subtree...\\n\\t    return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658225,
                "title": "java-easy-solution-2-liner-code-recursive",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\npublic class Solution {\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if(root==null)return false;\\n        sum = sum - root.val;\\n        if(root.left==null && root.right==null){\\n            if(sum == 0)return true;\\n            else return false;\\n        }\\n        return hasPathSum(root.left,sum) || hasPathSum(root.right,sum);\\n        \\n        \\n    }\\n    \\n   \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\npublic class Solution {\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if(root==null)return false;\\n        sum = sum - root.val;\\n        if(root.left==null && root.right==null){\\n            if(sum == 0)return true;\\n            else return false;\\n        }\\n        return hasPathSum(root.left,sum) || hasPathSum(root.right,sum);\\n        \\n        \\n    }\\n    \\n   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1928074,
                "title": "100-fastest-swift-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    func hasPathSum(_ root: TreeNode?, _ targetSum: Int) -> Bool {\\n        guard let root = root else { return false }\\n        \\n        if root.val == targetSum && root.left == nil && root.right == nil { return true }\\n        \\n        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val)\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    func hasPathSum(_ root: TreeNode?, _ targetSum: Int) -> Bool {\\n        guard let root = root else { return false }\\n        \\n        if root.val == targetSum && root.left == nil && root.right == nil { return true }\\n        \\n        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val)\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779613,
                "title": "python-simple-dfs",
                "content": "```\\ndef hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n    if not root: # edge case\\n        return False\\n    if not root.left and not root.right: \\n        return sum == root.val\\n    return self.hasPathSum(root.left, sum - root.val) or self.hasPathSum(root.right, sum - root.val)\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\ndef hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n    if not root: # edge case\\n        return False\\n    if not root.left and not root.right: \\n        return sum == root.val\\n    return self.hasPathSum(root.left, sum - root.val) or self.hasPathSum(root.right, sum - root.val)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3193152,
                "title": "path-sum-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis solution uses an iterative approach with a stack to traverse the binary tree and keep track of the current path value. It checks if the current node is a leaf node and its value matches the target sum. If not, it adds the left and right children to the stack along with their updated path value. It returns False if no such path is found.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        \\n        # Use a list to store the path from root to the current node\\n        stack = [(root, root.val)]\\n        \\n        while stack:\\n            node, val = stack.pop()\\n            \\n            # Check if the current node is a leaf node and its value matches the targetSum\\n            if not node.left and not node.right and val == targetSum:\\n                return True\\n            \\n            # Add the left and right children to the stack along with their updated path value\\n            if node.left:\\n                stack.append((node.left, val + node.left.val))\\n            if node.right:\\n                stack.append((node.right, val + node.right.val))\\n        \\n        return False\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        \\n        # Use a list to store the path from root to the current node\\n        stack = [(root, root.val)]\\n        \\n        while stack:\\n            node, val = stack.pop()\\n            \\n            # Check if the current node is a leaf node and its value matches the targetSum\\n            if not node.left and not node.right and val == targetSum:\\n                return True\\n            \\n            # Add the left and right children to the stack along with their updated path value\\n            if node.left:\\n                stack.append((node.left, val + node.left.val))\\n            if node.right:\\n                stack.append((node.right, val + node.right.val))\\n        \\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207135,
                "title": "easy-js-solution",
                "content": "```\\n/*\\n1. Use DFS to try all possible paths.\\n2. Keep track of the sum of path during traversal. When leaf node is reached, check if\\nthe sum of path equals the target. If so, return true, else continue DFS traversal to\\ntry other paths.\\n*/\\nvar hasPathSum = function(root, targetSum) {\\n    return dfs(root, targetSum);\\n    // T.C: O(N)\\n    // S.C: O(H)\\n};\\n\\nconst dfs = (root, target) => {\\n    if (!root) {\\n        return false;\\n    }\\n    if (!root.left && !root.right) {\\n        return target - root.val === 0;\\n    }\\n    return dfs(root.left, target - root.val) || \\n        dfs(root.right, target - root.val);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/*\\n1. Use DFS to try all possible paths.\\n2. Keep track of the sum of path during traversal. When leaf node is reached, check if\\nthe sum of path equals the target. If so, return true, else continue DFS traversal to\\ntry other paths.\\n*/\\nvar hasPathSum = function(root, targetSum) {\\n    return dfs(root, targetSum);\\n    // T.C: O(N)\\n    // S.C: O(H)\\n};\\n\\nconst dfs = (root, target) => {\\n    if (!root) {\\n        return false;\\n    }\\n    if (!root.left && !root.right) {\\n        return target - root.val === 0;\\n    }\\n    return dfs(root.left, target - root.val) || \\n        dfs(root.right, target - root.val);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1190588,
                "title": "python-recursive-approach-easy-to-solve",
                "content": "Think about one small tree. Let say we have only one node like\\n```\\n\\t\\t\\t\\t\\t    1\\n\\t\\t\\t\\tNone         None\\n```\\nand targetSum is 1, so our condtion will be \\n```\\nif root.left is None and root.right is None and root.val == targetSum:\\n            return True\\n```\\n  \\n                     1\\n\\t\\t\\t\\t2         3\\nand targetSum is 4\\nFor the above example we have the path sum in right hand side, so whenever we are recursively calling on a node we will check both side of the tree.\\n```\\n\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:\\n        \\n        if root is None: return False\\n        \\n        if root.left is None and root.right is None and root.val == targetSum:\\n            return True\\n        \\n        return self.hasPathSum(root.left, targetSum-root.val) or self.hasPathSum(root.right, targetSum-root.val)\\n```\\nPlease Upvote if you get it.\\n\\nPlease check out Path sum II solution. (https://leetcode.com/problems/path-sum-ii/discuss/1192146/Python-or-Recursive-approach-or-97-beats)\\n",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n\\t\\t\\t\\t\\t    1\\n\\t\\t\\t\\tNone         None\\n```\n```\\nif root.left is None and root.right is None and root.val == targetSum:\\n            return True\\n```\n```\\n\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:\\n        \\n        if root is None: return False\\n        \\n        if root.left is None and root.right is None and root.val == targetSum:\\n            return True\\n        \\n        return self.hasPathSum(root.left, targetSum-root.val) or self.hasPathSum(root.right, targetSum-root.val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 744383,
                "title": "c-solution-recursion-iterative-dfs-iterative-bfs",
                "content": "```\\nclass Solution {\\n public:\\n  bool hasPathSum(TreeNode* root, int sum) {\\n    if (not root) return false;\\n    sum -= root->val;\\n    if (not root->left and not root->right) {\\n      return sum == 0;\\n    }\\n    return hasPathSum(root->left, sum) || hasPathSum(root->right, sum);\\n  }\\n};\\n```\\n//DFS\\n```\\nclass Solution {\\n public:\\n  bool hasPathSum(TreeNode* root, int sum) {\\n    if (!root) return false;\\n    stack<pair<TreeNode*, int>> stk;\\n    stk.push({root, sum});\\n    while (!stk.empty()) {\\n      auto [node, curr_sum] = stk.top();\\n      stk.pop();\\n      curr_sum -= node->val;\\n      if (!node->left && !node->right && curr_sum == 0) {\\n        return true;\\n      }\\n      if (node->right) stk.push({node->right, curr_sum});\\n      if (node->left) stk.push({node->left, curr_sum});\\n    }\\n    return false;\\n  }\\n};\\n```\\n// BFS\\n```\\nclass Solution {\\n public:\\n  bool hasPathSum(TreeNode *root, int sum) {\\n    if (!root) return false;\\n    queue<pair<TreeNode *, int>> q;\\n    q.push({root, sum});\\n    while (!q.empty()) {\\n      auto [node, curr_sum] = q.front();\\n      q.pop();\\n      curr_sum -= node->val;\\n      if (!node->left && !node->right && curr_sum == 0) return true;\\n      if (node->left) q.push({node->left, curr_sum});\\n      if (node->right) q.push({node->right, curr_sum});\\n    }\\n    return false;\\n  }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  bool hasPathSum(TreeNode* root, int sum) {\\n    if (not root) return false;\\n    sum -= root->val;\\n    if (not root->left and not root->right) {\\n      return sum == 0;\\n    }\\n    return hasPathSum(root->left, sum) || hasPathSum(root->right, sum);\\n  }\\n};\\n```\n```\\nclass Solution {\\n public:\\n  bool hasPathSum(TreeNode* root, int sum) {\\n    if (!root) return false;\\n    stack<pair<TreeNode*, int>> stk;\\n    stk.push({root, sum});\\n    while (!stk.empty()) {\\n      auto [node, curr_sum] = stk.top();\\n      stk.pop();\\n      curr_sum -= node->val;\\n      if (!node->left && !node->right && curr_sum == 0) {\\n        return true;\\n      }\\n      if (node->right) stk.push({node->right, curr_sum});\\n      if (node->left) stk.push({node->left, curr_sum});\\n    }\\n    return false;\\n  }\\n};\\n```\n```\\nclass Solution {\\n public:\\n  bool hasPathSum(TreeNode *root, int sum) {\\n    if (!root) return false;\\n    queue<pair<TreeNode *, int>> q;\\n    q.push({root, sum});\\n    while (!q.empty()) {\\n      auto [node, curr_sum] = q.front();\\n      q.pop();\\n      curr_sum -= node->val;\\n      if (!node->left && !node->right && curr_sum == 0) return true;\\n      if (node->left) q.push({node->left, curr_sum});\\n      if (node->right) q.push({node->right, curr_sum});\\n    }\\n    return false;\\n  }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768446,
                "title": "java-100-faster-solution-step-by-step-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(H)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/6a3e9288-d254-4302-b55e-0e221543c512_1689421045.2787068.png)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) {\\n            return false;\\n        }\\n        \\n        // Check if the current node is a leaf node and its value matches the targetSum\\n        if (root.left == null && root.right == null && root.val == targetSum) {\\n            return true;\\n        }\\n        \\n        // Recursively check the left and right subtrees with updated targetSum\\n        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) {\\n            return false;\\n        }\\n        \\n        // Check if the current node is a leaf node and its value matches the targetSum\\n        if (root.left == null && root.right == null && root.val == targetSum) {\\n            return true;\\n        }\\n        \\n        // Recursively check the left and right subtrees with updated targetSum\\n        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799035,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int sum) {\\n        if(!root)return false;                                         //Terminating Condition\\n        sum=sum-root->val;                                             //Body\\n        if(sum==0&&!root->left&&!root->right)return true;              //body\\n        return hasPathSum(root->left,sum)||hasPathSum(root->right,sum);//Propagation\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int sum) {\\n        if(!root)return false;                                         //Terminating Condition\\n        sum=sum-root->val;                                             //Body\\n        if(sum==0&&!root->left&&!root->right)return true;              //body\\n        return hasPathSum(root->left,sum)||hasPathSum(root->right,sum);//Propagation\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658451,
                "title": "path-sum-99-22-fastest-execution-c-3-line-easy-solution-simple-and-short",
                "content": "**SHIVAM DAILY LEETCODE SOLUTIONS || CHECK : [https://bit.ly/leetcode-solutions](https://bit.ly/leetcode-solutions)\\nRuntime: 4 ms, faster than 99.22% of C++ online submissions for Path Sum.\\nMemory Usage: 21.4 MB, less than 38.76% of C++ online submissions for Path Sum.** \\n\\n```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int sum)\\n    {\\n        if (!root) return false;\\n        if (!root->left && !root->right) return root->val == sum;\\n        return hasPathSum(root->left, sum - root->val) || hasPathSum(root->right, sum - root->val);\\n    }\\n};\\n\\n```\\n![image](https://assets.leetcode.com/users/images/6523b1bc-71a3-4707-b34e-bcd7a708ca8d_1664862675.8947413.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int sum)\\n    {\\n        if (!root) return false;\\n        if (!root->left && !root->right) return root->val == sum;\\n        return hasPathSum(root->left, sum - root->val) || hasPathSum(root->right, sum - root->val);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 518065,
                "title": "javascript-solution-98-32",
                "content": "```\\nvar hasPathSum = function(root, sum) {\\n    return dfs(root, 0, sum);\\n};\\n\\nvar dfs = function(curr, currentSum, targetSum) {\\n    if (!curr) {\\n        return false;\\n    }\\n\\n    currentSum += curr.val;\\n    \\n    if (curr.left === null && curr.right === null) {\\n        return currentSum === targetSum;\\n    }\\n    \\n    return dfs(curr.left, currentSum, targetSum) || dfs(curr.right, currentSum, targetSum);\\n}\\n```\\n\\nRuntime: 56 ms, faster than 98.32% of JavaScript online submissions for Path Sum.\\nMemory Usage: 37.1 MB, less than 100.00% of JavaScript online submissions for Path Sum.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar hasPathSum = function(root, sum) {\\n    return dfs(root, 0, sum);\\n};\\n\\nvar dfs = function(curr, currentSum, targetSum) {\\n    if (!curr) {\\n        return false;\\n    }\\n\\n    currentSum += curr.val;\\n    \\n    if (curr.left === null && curr.right === null) {\\n        return currentSum === targetSum;\\n    }\\n    \\n    return dfs(curr.left, currentSum, targetSum) || dfs(curr.right, currentSum, targetSum);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 36531,
                "title": "share-my-3-lines-c-solution",
                "content": "    /**\\n     * Definition for a binary tree node.\\n     * struct TreeNode {\\n     *     int val;\\n     *     TreeNode *left;\\n     *     TreeNode *right;\\n     *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n     * };\\n     */\\n    class Solution {\\n    public:\\n        bool hasPathSum(TreeNode* root, int sum) {\\n            if(!root) return false;\\n            if((root -> val == sum) && ((!root -> left) && (!root -> right))) return true;\\n            return hasPathSum(root -> left, sum - root -> val) || hasPathSum(root -> right, sum - root -> val);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool hasPathSum(TreeNode* root, int sum) {\\n            if(!root) return false;\\n            if((root -> val == sum) && ((!root -> left) && (!root -> right))) return true;\\n            return hasPathSum(root -> left, sum - root -> val) || hasPathSum(root -> right, sum - root -> val);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 36600,
                "title": "4-ms-c-solution-recursion",
                "content": "    bool hasPathSum(struct TreeNode* root, int sum) {\\n        if (!root) \\n            return false;\\n        if (!root->right && !root->left) \\n            return sum==root->val;\\n        return hasPathSum(root->left, sum-root->val)||hasPathSum(root->right, sum-root->val);\\n    }",
                "solutionTags": [],
                "code": "    bool hasPathSum(struct TreeNode* root, int sum) {\\n        if (!root) \\n            return false;\\n        if (!root->right && !root->left) \\n            return sum==root->val;\\n        return hasPathSum(root->left, sum-root->val)||hasPathSum(root->right, sum-root->val);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3198445,
                "title": "recursive-depth-first-traversal-with-sum-calculation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to traverse the tree in a depth-first manner, keeping track of the sum of values along the path from the root to the current node. When we reach a leaf node, we check if the sum is equal to the target sum. If yes, we return true, otherwise, we continue traversing the tree.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe define a function `hasPathSum` that takes the root node of the binary tree and the target sum as input, and returns a boolean value indicating whether there exists a root-to-leaf path with the given sum.\\n\\nThe first base case is when the root is None, which means we have reached the end of a branch without finding the target sum. In this case, we return False.\\n\\nThe second base case is when the root is a leaf node, which means we have reached the end of a root-to-leaf path. In this case, we check if the sum of values along the path is equal to the target sum. If yes, we return True, otherwise, we return False.\\n\\nIn the recursive case, we call the `hasPathSum` function on the left and right subtrees, with the target sum reduced by the value of the current node. If either of these recursive calls returns True, we return True, because there exists a root-to-leaf path with the target sum. Otherwise, we continue traversing the tree.\\n# Complexity\\n- Time complexity:$O(n)$, where n is the number of nodes in the binary tree. We need to visit every node once to check if it is a leaf node and calculate the sum along the path.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$ O(h)$, where h is the height of the binary tree. In the worst case, the recursion stack will have h frames, one for each level of the tree.\\n\\n\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        if not root.left and not root.right: # leaf node\\n            return targetSum == root.val\\n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        if not root.left and not root.right: # leaf node\\n            return targetSum == root.val\\n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661481,
                "title": "c-2-different-approach-recursive-iterative",
                "content": "I came up with 2 different approaches for this problem. Please let me know if you have other ideas or if you have suggestions on how to improve one of the solutions. This problem many good solutions have been posted already, nevertheless I just had fun writing up my thoughts. So here we go. :)\\n\\n\\n### Approach 1: recursive\\n\\nWhen we hear \"binary tree\" the first reaction should almost always be \"recursion\", so here we go:\\n\\n```cpp\\n    static bool hasPathSum(const TreeNode* root, int targetSum) {\\n        if (!root) return false;\\n        \\n        if (!root->left && !root->right) return root->val == targetSum;\\n        \\n        return\\n            hasPathSum(root->left, targetSum - root->val) ||\\n            hasPathSum(root->right, targetSum - root->val);\\n    }\\n```\\n\\nPlease note that the code above is better in case there is actually a path, then the following code without \"short circute evaluation\":\\n\\n```cpp\\n        bool left = hasPathSum(root->left, targetSum - root->val);\\n        bool right = hasPathSum(root->right, targetSum - root->val);\\n        return left || right;\\n```\\n\\nThis could be fixed by adding an extra ```if (left) return true;```, but IMO the code above is just the cleanest and shortest solution here.\\n\\n**Complexity Analysis**\\n\\nLet $$n$$ be the number of nodes in the tree, and $$h$$ be the height of the tree, which can range from $$\\\\log n$$ if the tree is perfectly balanced to $$n$$ in the case the tree is basically a linked list.\\n\\n* Time complexity: $$O(n)$$ worst case we need to visit all the nodes.\\n* Space complexity: $$O(h)$$ we need that for the recursion stack.\\n\\n### Approach 2: iterative\\n\\nThe iterative version is straight forward as well if we use a ```stack<pair<TreeNode, int>>```.\\n\\n```cpp\\n    static bool hasPathSum(const TreeNode* root, int targetSum) {\\n        if (!root) return false;\\n\\n        stack<pair<const TreeNode*, int>> st;\\n        st.push({root, targetSum});\\n\\n        while (!empty(st)) {\\n            const auto [node, target] = st.top(); st.pop();\\n            if (!node->left && !node->right && node->val == target) return true;\\n            \\n            if (node->left) st.push({node->left, target - node->val});\\n            if (node->right) st.push({node->right, target - node->val});\\n        }\\n        \\n        return false;\\n    }\\n```\\n\\nWe could use a ```queue``` instead of a ```stack```, but using a BFS like aproach seems a bit pointless to me for this problem. Please let me know if there are good reasons to consider BFS as well.\\n\\nOne aspect I like about an iterative solution is that it seems easier to handle problematic input. Imagine the tree we get is actually not a tree put has a circle. The solutions above would run out of call stack space or allocate more and more memory and eventually run out of memory. For the iterative version we could easly add something like:\\n\\n\\n```cpp\\n   if (size(stack) > 10000) {\\n      LOG_ERROR(\"Tree too larger or input is not a tree.\");\\n      return false;\\n   }\\n```\\n\\nHow to best handle the error would be another questions. Do we want to use exceptions or do we want to use a different API to be able to pass the error to the caller is intersting questions to explore.\\n\\n\\n**Complexity Analysis**\\nThis is basically the same as for approach 1, but we are using an explict stack instead of the implict call stack, but it would grow at the same speed.\\n\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an upvote sparks  joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/Nqm4jJcyBf)!**",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```cpp\\n    static bool hasPathSum(const TreeNode* root, int targetSum) {\\n        if (!root) return false;\\n        \\n        if (!root->left && !root->right) return root->val == targetSum;\\n        \\n        return\\n            hasPathSum(root->left, targetSum - root->val) ||\\n            hasPathSum(root->right, targetSum - root->val);\\n    }\\n```\n```cpp\\n        bool left = hasPathSum(root->left, targetSum - root->val);\\n        bool right = hasPathSum(root->right, targetSum - root->val);\\n        return left || right;\\n```\n```if (left) return true;```\n```stack<pair<TreeNode, int>>```\n```cpp\\n    static bool hasPathSum(const TreeNode* root, int targetSum) {\\n        if (!root) return false;\\n\\n        stack<pair<const TreeNode*, int>> st;\\n        st.push({root, targetSum});\\n\\n        while (!empty(st)) {\\n            const auto [node, target] = st.top(); st.pop();\\n            if (!node->left && !node->right && node->val == target) return true;\\n            \\n            if (node->left) st.push({node->left, target - node->val});\\n            if (node->right) st.push({node->right, target - node->val});\\n        }\\n        \\n        return false;\\n    }\\n```\n```queue```\n```stack```\n```cpp\\n   if (size(stack) > 10000) {\\n      LOG_ERROR(\"Tree too larger or input is not a tree.\");\\n      return false;\\n   }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2658315,
                "title": "java-recursive-solution",
                "content": "```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root==null){\\n            return false;\\n        }\\n        \\n        if(root.left==null && root.right==null && targetSum==root.val){\\n            return true;\\n        }\\n        \\n        return hasPathSum(root.left,targetSum-root.val) || hasPathSum(root.right,targetSum-root.val);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root==null){\\n            return false;\\n        }\\n        \\n        if(root.left==null && root.right==null && targetSum==root.val){\\n            return true;\\n        }\\n        \\n        return hasPathSum(root.left,targetSum-root.val) || hasPathSum(root.right,targetSum-root.val);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1654324,
                "title": "java-100-faster-recursion",
                "content": "## Please upvote if it helps! Thx :D\\n```\\npublic boolean hasPathSum(TreeNode root, int targetSum) {\\n\\tif (root == null) return false;\\n\\tif (root.left == null && root.right==null && root.val == targetSum) return true;\\n\\ttargetSum -= root.val;\\n\\treturn hasPathSum(root.left, targetSum) || hasPathSum(root.right, targetSum);\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\npublic boolean hasPathSum(TreeNode root, int targetSum) {\\n\\tif (root == null) return false;\\n\\tif (root.left == null && root.right==null && root.val == targetSum) return true;\\n\\ttargetSum -= root.val;\\n\\treturn hasPathSum(root.left, targetSum) || hasPathSum(root.right, targetSum);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 350383,
                "title": "python3-recursively-and-iteratively",
                "content": "recursively:\\n```\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n        if not root:\\n            return False\\n        sum -= root.val\\n        if not root.left and not root.right:\\n            return sum == 0\\n        return self.hasPathSum(root.left,sum) or self.hasPathSum(root.right,sum)\\n```\\nIteratively:\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n        if not root:\\n            return False\\n        stack = [[root,sum-root.val]]\\n        while stack:\\n            cur,curr_sum = stack.pop()\\n            if not cur.left and not cur.right and curr_sum == 0:\\n                return True\\n            if cur.right:\\n                stack.append((cur.right,curr_sum-cur.right.val))\\n            if cur.left:\\n                stack.append((cur.left, curr_sum-cur.left.val))\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n        if not root:\\n            return False\\n        sum -= root.val\\n        if not root.left and not root.right:\\n            return sum == 0\\n        return self.hasPathSum(root.left,sum) or self.hasPathSum(root.right,sum)\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n        if not root:\\n            return False\\n        stack = [[root,sum-root.val]]\\n        while stack:\\n            cur,curr_sum = stack.pop()\\n            if not cur.left and not cur.right and curr_sum == 0:\\n                return True\\n            if cur.right:\\n                stack.append((cur.right,curr_sum-cur.right.val))\\n            if cur.left:\\n                stack.append((cur.left, curr_sum-cur.left.val))\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486462,
                "title": "solution",
                "content": "The function hasPathSum checks if there is a path from the root to the leaves in the binary tree defined by the root, whose sum of vertex values is equal to the given number targetSum.\\n\\nThe function first checks if the root is empty. If it is empty, the function returns false, since an empty tree has no path from the root to the leaves.\\n\\nThen it subtracts the value of the root from targetSum. It then checks to see if the current node is a leaf, that is, it has no child nodes. If so, the function returns the result of comparing targetSum to zero. If the sum in the current node goes to the right number and the current node is a leaf, then we have found the path from the root to the leaf with the right sum of values.\\n\\nIf the current node is not a leaf, the function calls itself recursively for the left and right subtree, passing targetSum minus the value of the current node as an argument. The function then returns the result of the logical AND of the recursive calls, since both subtrees must have a path from the root to the leaf with the desired sum in order for the whole tree to have that path.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) {\\n            return false;\\n        }\\n\\n        targetSum -= root.val;\\n\\n        if (root.left == null && root.right == null) {\\n            return targetSum == 0;\\n        }\\n\\n        return hasPathSum(root.left, targetSum) || hasPathSum(root.right, targetSum);        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C#",
                    "Go"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) {\\n            return false;\\n        }\\n\\n        targetSum -= root.val;\\n\\n        if (root.left == null && root.right == null) {\\n            return targetSum == 0;\\n        }\\n\\n        return hasPathSum(root.left, targetSum) || hasPathSum(root.right, targetSum);        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3212802,
                "title": "java-solution-0-ms-beats-100",
                "content": "# Java Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) {\\n            return false;\\n        }\\n        if (root.val == targetSum && root.left == null && root.right == null) {\\n            return true;\\n        }\\n        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) {\\n            return false;\\n        }\\n        if (root.val == targetSum && root.left == null && root.right == null) {\\n            return true;\\n        }\\n        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658457,
                "title": "1-line-python",
                "content": "```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        return (root.val == targetSum) if (root and not root.left and not root.right) else (root and (self.hasPathSum(root.right, targetSum - root.val) or self.hasPathSum(root.left, targetSum - root.val)))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        return (root.val == targetSum) if (root and not root.left and not root.right) else (root and (self.hasPathSum(root.right, targetSum - root.val) or self.hasPathSum(root.left, targetSum - root.val)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856379,
                "title": "simple-js-solution-w-comments",
                "content": "```\\nconst hasPathSum = (root, targetSum) => {\\n\\tif (!root) return false;\\n\\n\\tlet output = false;\\n\\tconst traverse = (root, sum = 0) => {\\n\\t\\t// if targetSum exist at end of path, set output to TRUE\\n\\t\\tif (!root.left && !root.right) {\\n\\t\\t\\tif (targetSum === sum + root.val) output = true;\\n\\t\\t}\\n\\n\\t\\t// traverse left/right and keep adding value of nodes in current path\\n\\t\\tif (root.left) traverse(root.left, sum + root.val);\\n\\t\\tif (root.right) traverse(root.right, sum + root.val);\\n\\t};\\n\\n\\ttraverse(root);\\n\\treturn output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nconst hasPathSum = (root, targetSum) => {\\n\\tif (!root) return false;\\n\\n\\tlet output = false;\\n\\tconst traverse = (root, sum = 0) => {\\n\\t\\t// if targetSum exist at end of path, set output to TRUE\\n\\t\\tif (!root.left && !root.right) {\\n\\t\\t\\tif (targetSum === sum + root.val) output = true;\\n\\t\\t}\\n\\n\\t\\t// traverse left/right and keep adding value of nodes in current path\\n\\t\\tif (root.left) traverse(root.left, sum + root.val);\\n\\t\\tif (root.right) traverse(root.right, sum + root.val);\\n\\t};\\n\\n\\ttraverse(root);\\n\\treturn output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 36391,
                "title": "java-iterative-solution-with-one-stack",
                "content": "```\\npublic boolean hasPathSum(TreeNode root, int sum) {\\n        Stack<TreeNode> visitedNodes = new Stack<>();\\n        TreeNode prev = null;\\n       \\n        while(root!=null || !visitedNodes.isEmpty()){\\n            while(root!=null){\\n                visitedNodes.push(root);\\n                sum -= root.val;\\n                prev = root;\\n                root = root.left;\\n            }\\n            root = visitedNodes.peek();\\n            if(root.left==null && root.right == null && sum==0) return true;\\n            if(root.right != null && root.right != prev){\\n                root = root.right;\\n            }else{\\n                sum += root.val;\\n                prev = visitedNodes.pop();\\n                root = null;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean hasPathSum(TreeNode root, int sum) {\\n        Stack<TreeNode> visitedNodes = new Stack<>();\\n        TreeNode prev = null;\\n       \\n        while(root!=null || !visitedNodes.isEmpty()){\\n            while(root!=null){\\n                visitedNodes.push(root);\\n                sum -= root.val;\\n                prev = root;\\n                root = root.left;\\n            }\\n            root = visitedNodes.peek();\\n            if(root.left==null && root.right == null && sum==0) return true;\\n            if(root.right != null && root.right != prev){\\n                root = root.right;\\n            }else{\\n                sum += root.val;\\n                prev = visitedNodes.pop();\\n                root = null;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 36543,
                "title": "share-my-easy-and-clean-recursion-java-solution-with-explanation",
                "content": "    public class Solution {\\n        public boolean hasPathSum(TreeNode root, int sum) {\\n            \\n            // check if root is null\\n            if(root == null) return false;\\n            \\n            // if the current node is not a leaf node, do recursion.\\n            if(root.left != null || root.right != null) \\n                return hasPathSum(root.left, sum - root.val) || \\n                    hasPathSum(root.right, sum - root.val);\\n            \\n            // now the current node is a leaf node\\n            return sum - root.val == 0;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean hasPathSum(TreeNode root, int sum) {\\n            \\n            // check if root is null\\n            if(root == null) return false;\\n            \\n            // if the current node is not a leaf node, do recursion.\\n            if(root.left != null || root.right != null) \\n                return hasPathSum(root.left, sum - root.val) || \\n                    hasPathSum(root.right, sum - root.val);\\n            \\n            // now the current node is a leaf node\\n            return sum - root.val == 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 36620,
                "title": "java-solution-shortest",
                "content": "    public boolean hasPathSum(TreeNode root, int sum) {\\n        if (root == null) {\\n            return false;\\n        }\\n\\n        if (sum - root.val == 0 && root.left == null && root.right == null) {\\n            return true;\\n        }\\n\\n        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n    }",
                "solutionTags": [],
                "code": "    public boolean hasPathSum(TreeNode root, int sum) {\\n        if (root == null) {\\n            return false;\\n        }\\n\\n        if (sum - root.val == 0 && root.left == null && root.right == null) {\\n            return true;\\n        }\\n\\n        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3336702,
                "title": "python3-deque-beat-98-10-34ms",
                "content": "\\n\\n# Complexity\\n- Time complexity:  O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        queue = collections.deque([(root, root.val)])\\n        while queue:\\n            node, val = queue.popleft()\\n            if not node.left and not node.right:\\n                if val == targetSum: return True\\n                else: continue\\n            if node.left:\\n                queue.append((node.left, val + node.left.val))   \\n            if node.right:\\n                queue.append((node.right, val + node.right.val))   \\n        return False\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        queue = collections.deque([(root, root.val)])\\n        while queue:\\n            node, val = queue.popleft()\\n            if not node.left and not node.right:\\n                if val == targetSum: return True\\n                else: continue\\n            if node.left:\\n                queue.append((node.left, val + node.left.val))   \\n            if node.right:\\n                queue.append((node.right, val + node.right.val))   \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902210,
                "title": "javascript-easy-code-thumbs-up-if-you-like",
                "content": "\\n# Code\\n```\\n\\nvar hasPathSum = function (root, targetSum) {\\n    if (!root)\\n        return false\\n    if (root.val === targetSum && (!root.left && !root.right))\\n        return true\\n\\n    return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val)\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar hasPathSum = function (root, targetSum) {\\n    if (!root)\\n        return false\\n    if (root.val === targetSum && (!root.left && !root.right))\\n        return true\\n\\n    return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val)\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2291836,
                "title": "three-solution-to-come-up-on-iterview-easy-to-understand",
                "content": "Hey there! This problem gives us to practice in use of different binary tree traversals. If you look closer to the idea of the problem you will come up with the following: DFS (**preorder**) with recursion, DFS iterative version and BFS (or level traversal). Go ahead and get to know all of them.\\n\\n___\\n***DFS recursion*** [0ms 44.2MB](https://leetcode.com/submissions/detail/748771650/)\\nThe simplies (it\\'s seems to me) solution based on **preorder** binary tree traversal. Here we will visit all paths to leaf (node with no children) till we find desired path or visit all:\\n\\n```\\npublic boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) return false;\\n        return hasPathSum(root, targetSum, 0);\\n    }\\n    \\n    private boolean hasPathSum(TreeNode root, int targetSum, int currSum) {\\n        if (root == null)\\n            return false;\\n        currSum += root.val;\\n        if (currSum == targetSum && root.left == null && root.right == null)\\n            return true;\\n        if (hasPathSum(root.left, targetSum, currSum) || hasPathSum(root.right, targetSum, currSum))\\n            return true;\\n        return false;\\n    }\\n```\\nTime complexity: O(2^n) - where 2^n is a size of a binary tree\\nSpace complexity: O(n), where n is a depth of this tree\\n\\nSimple, readable and neet. But recursion is sign to find iterative method.\\n___\\n***DFS iterative*** [4ms 44MB](https://leetcode.com/submissions/detail/748798973/)\\nThis is an alternative to the previous method because we want to avoid recursion as much as possible. Here we use the same principles (e.g. Stack) as in dfs traversal of binary tree. Note here we have two stacks - one will indicate root - to - this - node sum. If you know how to make it one stack in Java - please let me know ;]\\n\\n```\\npublic boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) return false;\\n        Stack<TreeNode> stack = new Stack<>();\\n        Stack<Integer> sum = new Stack<>();\\n        stack.push(root);\\n        sum.push(root.val);\\n        while (!stack.isEmpty()) {\\n            TreeNode node = stack.pop();\\n            int currSum = sum.pop();\\n            if (currSum == targetSum && node.left == null && node.right == null)\\n                return true;\\n            \\n            if (node.right != null) {\\n                stack.push(node.right);\\n                sum.push(node.right.val + currSum);\\n            }\\n            if (node.left != null) {\\n                stack.push(node.left);\\n                sum.push(node.left.val + currSum);\\n            }\\n        }\\n        return false;\\n    }\\n```\\nTime and Space complexity are identical to the first approach.- But it\\'s generally better the previous because recursion may cause stackoverflow\\n\\n____\\n***BFS*** [2ms 44.6MB](https://leetcode.com/submissions/detail/748810508/)\\nThe last approach is so called level traversal - that is, we initially visit one level of the tree, then one that below and so on. We use the standart approach for BFS with queue. Note the same issue with the second queue for sum.\\nIt is so much a like previous in implemention, but the data structure dictates an order - stack makes traversal go in depth, when queue makes us check this level first.\\n\\n```\\npublic boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) return false;\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        Queue<Integer> sum = new LinkedList<>();\\n        queue.add(root);\\n        sum.add(root.val);\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                TreeNode node = queue.remove();\\n                int currSum = sum.remove();\\n                if (currSum == targetSum && node.left == null && node.right == null) {\\n                    return true;\\n                }\\n                \\n                \\n               if (node.left != null) {\\n                    queue.add(node.left);\\n                    sum.add(node.left.val + currSum);\\n                }\\n                if (node.right != null) {\\n                    queue.add(node.right);\\n                    sum.add(node.right.val + currSum);\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n```\\nAgain, time and space complexity stay the same.\\n___\\nIn conclusion, benchmarks shows recursive is the best.and BFS is best among iterative version. Still you need to look in the root of the problem and choose the most preferable ( but here I belive it doesn\\'t matter much )\\n",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\npublic boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) return false;\\n        return hasPathSum(root, targetSum, 0);\\n    }\\n    \\n    private boolean hasPathSum(TreeNode root, int targetSum, int currSum) {\\n        if (root == null)\\n            return false;\\n        currSum += root.val;\\n        if (currSum == targetSum && root.left == null && root.right == null)\\n            return true;\\n        if (hasPathSum(root.left, targetSum, currSum) || hasPathSum(root.right, targetSum, currSum))\\n            return true;\\n        return false;\\n    }\\n```\n```\\npublic boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) return false;\\n        Stack<TreeNode> stack = new Stack<>();\\n        Stack<Integer> sum = new Stack<>();\\n        stack.push(root);\\n        sum.push(root.val);\\n        while (!stack.isEmpty()) {\\n            TreeNode node = stack.pop();\\n            int currSum = sum.pop();\\n            if (currSum == targetSum && node.left == null && node.right == null)\\n                return true;\\n            \\n            if (node.right != null) {\\n                stack.push(node.right);\\n                sum.push(node.right.val + currSum);\\n            }\\n            if (node.left != null) {\\n                stack.push(node.left);\\n                sum.push(node.left.val + currSum);\\n            }\\n        }\\n        return false;\\n    }\\n```\n```\\npublic boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) return false;\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        Queue<Integer> sum = new LinkedList<>();\\n        queue.add(root);\\n        sum.add(root.val);\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                TreeNode node = queue.remove();\\n                int currSum = sum.remove();\\n                if (currSum == targetSum && node.left == null && node.right == null) {\\n                    return true;\\n                }\\n                \\n                \\n               if (node.left != null) {\\n                    queue.add(node.left);\\n                    sum.add(node.left.val + currSum);\\n                }\\n                if (node.right != null) {\\n                    queue.add(node.right);\\n                    sum.add(node.right.val + currSum);\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 690667,
                "title": "c-100-time-one-line-recursive-solution",
                "content": "The base case is when the `root->val == sum` and the node is a leaf (ie: both `!root-left` and `!root->right` are true); if not, we keep recursing with decreased values of `sum`:\\n\\nNotice that since the nodes can also have negative values, there is no way to know in advance when you have summed \"too much\" and thus you should stop exploring down.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int sum) {\\n        return root && (!root->left && !root->right && root->val == sum || hasPathSum(root->left, sum - root->val) || hasPathSum(root->right, sum - root->val));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int sum) {\\n        return root && (!root->left && !root->right && root->val == sum || hasPathSum(root->left, sum - root->val) || hasPathSum(root->right, sum - root->val));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 523142,
                "title": "javascript",
                "content": "```\\nvar hasPathSum = function(root, sum) {\\n    if(!root) {\\n        return false;\\n    }\\n    if(!root.left && !root.right) {\\n        return root.val == sum ? true : false;\\n    }\\n    let remain = sum - root.val\\n    return hasPathSum(root.left, remain) || hasPathSum(root.right, remain)\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar hasPathSum = function(root, sum) {\\n    if(!root) {\\n        return false;\\n    }\\n    if(!root.left && !root.right) {\\n        return root.val == sum ? true : false;\\n    }\\n    let remain = sum - root.val\\n    return hasPathSum(root.left, remain) || hasPathSum(root.right, remain)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 519347,
                "title": "go-4ms",
                "content": "```\\nfunc hasPathSum(root *TreeNode, sum int) bool {\\n    if root == nil {\\n        return false\\n    }\\n    if root.Left == nil && root.Right == nil {\\n        return sum == root.Val\\n    }\\n    return hasPathSum(root.Left, sum - root.Val) || hasPathSum(root.Right, sum - root.Val)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc hasPathSum(root *TreeNode, sum int) bool {\\n    if root == nil {\\n        return false\\n    }\\n    if root.Left == nil && root.Right == nil {\\n        return sum == root.Val\\n    }\\n    return hasPathSum(root.Left, sum - root.Val) || hasPathSum(root.Right, sum - root.Val)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 410446,
                "title": "simple-python-solution-recursive-and-iterative-using-dfs",
                "content": "**Recursive**\\n\\n```\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n        if not root:\\n            return False\\n        \\n        sum = sum - root.val\\n        \\n        if not root.left and not root.right: #leaf node\\n            return sum == 0\\n        else:\\n            return self.hasPathSum(root.left, sum) or self.hasPathSum(root.right, sum)\\n```\\n\\t\\t\\t\\n**Iterative**\\n\\n```      \\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n        \\n        if not root:\\n            return False\\n        \\n        stack = []\\n        \\n        stack.append((root, sum - root.val))\\n        \\n        while stack:\\n            node, sum = stack.pop()\\n            if not node.left and not node.right and sum == 0:\\n                return True\\n            if node.left:\\n                stack.append((node.left, sum - node.left.val))\\n            if node.right:\\n                stack.append((node.right, sum - node.right.val))       \\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n        if not root:\\n            return False\\n        \\n        sum = sum - root.val\\n        \\n        if not root.left and not root.right: #leaf node\\n            return sum == 0\\n        else:\\n            return self.hasPathSum(root.left, sum) or self.hasPathSum(root.right, sum)\\n```\n```      \\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n        \\n        if not root:\\n            return False\\n        \\n        stack = []\\n        \\n        stack.append((root, sum - root.val))\\n        \\n        while stack:\\n            node, sum = stack.pop()\\n            if not node.left and not node.right and sum == 0:\\n                return True\\n            if node.left:\\n                stack.append((node.left, sum - node.left.val))\\n            if node.right:\\n                stack.append((node.right, sum - node.right.val))       \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 388724,
                "title": "javascript-easy-top-bottom-approach",
                "content": "```\\nvar hasPathSum = function(root, sum) {\\n    if (!root) return false;\\n    let queue = [root];\\n    while (queue.length > 0) {\\n        let cur = queue.shift();\\n        if (!cur.left && !cur.right && cur.val == sum) {\\n            return true;\\n        }\\n        if (cur.left) {\\n            cur.left.val += cur.val;\\n            queue.push (cur.left);\\n        }\\n        if (cur.right) {\\n            cur.right.val += cur.val;\\n            queue.push (cur.right);\\n        }\\n    }\\n    return false;\\n};\\n\\nfunction TreeNode (val) {\\n    this.val = val;\\n    this.left = this.right = null;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar hasPathSum = function(root, sum) {\\n    if (!root) return false;\\n    let queue = [root];\\n    while (queue.length > 0) {\\n        let cur = queue.shift();\\n        if (!cur.left && !cur.right && cur.val == sum) {\\n            return true;\\n        }\\n        if (cur.left) {\\n            cur.left.val += cur.val;\\n            queue.push (cur.left);\\n        }\\n        if (cur.right) {\\n            cur.right.val += cur.val;\\n            queue.push (cur.right);\\n        }\\n    }\\n    return false;\\n};\\n\\nfunction TreeNode (val) {\\n    this.val = val;\\n    this.left = this.right = null;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 36484,
                "title": "simple-c-solution",
                "content": "    class Solution {\\n    public:\\n        bool hasPathSum(TreeNode* root, int sum) {\\n            if(root == NULL){\\n                return false;\\n            }\\n            int newsum = sum - root->val;\\n            if(root->left == NULL && root->right == NULL){\\n                return newsum == 0;\\n            }\\n            return hasPathSum(root->left, newsum) || hasPathSum(root->right, newsum);\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        bool hasPathSum(TreeNode* root, int sum) {\\n            if(root == NULL){\\n                return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 36536,
                "title": "my-java-solution-using-recursive",
                "content": "    \\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if (root == null) {\\n            return false;\\n        } else {\\n            if (root.left == null && root.right == null) {\\n                return sum == root.val;\\n            } else {\\n                int subSum = sum - root.val;\\n                return hasPathSum(root.left, subSum) || hasPathSum(root.right, subSum);\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "    \\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if (root == null) {\\n            return false;\\n        } else {\\n            if (root.left == null && root.right == null) {\\n                return sum == root.val;\\n            } else {\\n                int subSum = sum - root.val;\\n                return hasPathSum(root.left, subSum) || hasPathSum(root.right, subSum);\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 36567,
                "title": "12ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        bool hasPathSum(TreeNode* root, int sum) {\\n            if(root == NULL) return false;\\n            sum -= root->val;\\n            return sum == 0 && root->left == NULL && root->right == NULL ? true : hasPathSum(root->left, sum) | hasPathSum(root->right, sum);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool hasPathSum(TreeNode* root, int sum) {\\n            if(root == NULL) return false;\\n            sum -= root->val;\\n            return sum == 0 && root->left == NULL && root->right == NULL ? true : hasPathSum(root->left, sum) | hasPathSum(root->right, sum);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 36642,
                "title": "just-another-java-solution-recursive-simple-but-can-be-simpler",
                "content": "    /**\\n     * Definition for binary tree\\n     * public class TreeNode {\\n     *     int val;\\n     *     TreeNode left;\\n     *     TreeNode right;\\n     *     TreeNode(int x) { val = x; }\\n     * }\\n     */\\n    public class Solution {\\n        public boolean hasPathSum(TreeNode root, int sum) {\\n            //start it off with initial sum of 0, pass in root.\\n            return helper(root,0,sum);\\n        }\\n        \\n      public boolean helper(TreeNode node,int currSum,int wanted){\\n          if(node==null)\\n            return false;\\n            \\n          //node is a leaf\\n          if(node.left==null && node.right==null){\\n              if((node.val+currSum) == wanted) //check if it sumeed up.\\n                  return true;\\n              return false;\\n          }\\n          \\n          //not a leaf, so recursively try again but with child nodes, pass in current sum + val of this node.\\n          return (helper(node.left,currSum+node.val,wanted) || helper(node.right,currSum+node.val,wanted));\\n          \\n      }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean hasPathSum(TreeNode root, int sum) {\\n            //start it off with initial sum of 0, pass in root.\\n            return helper(root,0,sum);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2231004,
                "title": "python-dfs-binary-tree-leaves-find-all-paths",
                "content": "It is intuitive to find all the possible paths from roots to leaves and sum them and check with the target sum.\\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        res = []\\n        if not root:\\n            return False\\n        def dfs(r,path):\\n            if not r.left and not r.right:\\n                path+=[r.val]\\n                res.append(path)\\n                return\\n            if r.left:\\n                dfs(r.left,path+[r.val])\\n            if r.right:\\n                dfs(r.right,path+[r.val])\\n            return \\n        dfs(root,[])\\n        # print(res)\\n        for arr in res:\\n            if sum(arr)==targetSum:\\n                return True\\n        return False\\n```\\n```\\nUPVOTE IF YOU LIKED IT :)\\n```\\nDo Let me know how we can optimise this further.\\nOne way i know that instead of keeping path, we can keep the sum itself and then return true if found targetSum.\\nBut for me it does not change time complexity much. \\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        res = []\\n        if not root:\\n            return False\\n        def dfs(r,path):\\n            if not r.left and not r.right:\\n                path+=[r.val]\\n                res.append(path)\\n                return\\n            if r.left:\\n                dfs(r.left,path+[r.val])\\n            if r.right:\\n                dfs(r.right,path+[r.val])\\n            return \\n        dfs(root,[])\\n        # print(res)\\n        for arr in res:\\n            if sum(arr)==targetSum:\\n                return True\\n        return False\\n```\n```\\nUPVOTE IF YOU LIKED IT :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040038,
                "title": "o-n-time-beats-99-97-memory-speed-0ms-may-2022",
                "content": "```\\n```\\n\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* ***Java***\\n```\\npublic boolean hasPathSum(TreeNode root, int sum) {\\n    // iteration method\\n    if (root == null) {return false;}\\n    Stack<TreeNode> path = new Stack<>();\\n    Stack<Integer> sub = new Stack<>();\\n    path.push(root);\\n    sub.push(root.val);\\n    while (!path.isEmpty()) {\\n        TreeNode temp = path.pop();\\n        int tempVal = sub.pop();\\n        if (temp.left == null && temp.right == null) {if (tempVal == sum) return true;}\\n        else {\\n            if (temp.left != null) {\\n                path.push(temp.left);\\n                sub.push(temp.left.val + tempVal);\\n            }\\n            if (temp.right != null) {\\n                path.push(temp.right);\\n                sub.push(temp.right.val + tempVal);\\n            }\\n        }\\n    }\\n    return false;\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 7.0MB*** (beats 100.00% / 100.00%).\\n* ***C++***\\n```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int sum) {\\n        if(!root)return false;                                         //Terminating Condition\\n        sum=sum-root->val;                                             //Body\\n        if(sum==0&&!root->left&&!root->right)return true;              //body\\n        return hasPathSum(root->left,sum)||hasPathSum(root->right,sum);//Propagation\\n    }\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n\\nThe best result for the code below is ***26ms / 12.2MB*** (beats 95.42% / 82.32%).\\n* ***Python***\\n```\\ndef hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n\\n        def inorder(root, path_sum):\\n            if not root:\\n                return False\\n            \\n            path_sum+=root.val\\n            \\n            if not root.left and not root.right:\\n                return path_sum==targetSum\\n                \\n            return inorder(root.left, path_sum) or inorder(root.right, path_sum)\\n             \\n        return inorder(root, 0)\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***51ms / 34.2MB*** (beats 100.00% / 84.12%).\\n* ***JavaScript***\\n```\\nvar hasPathSum = function(root, targetSum) {\\n    return dfs(root, targetSum);\\n    // T.C: O(N)\\n    // S.C: O(H)\\n};\\n\\nconst dfs = (root, target) => {\\n    if (!root) {\\n        return false;\\n    }\\n    if (!root.left && !root.right) {\\n        return target - root.val === 0;\\n    }\\n    return dfs(root.left, target - root.val) || \\n        dfs(root.right, target - root.val);\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***68ms / 44.2MB*** (beats 100.00% / 45.25%).\\n* ***Kotlin***\\n```\\nclass Solution {\\n    fun hasPathSum(root: TreeNode?, sum: Int): Boolean {\\n        if (root==null){\\n            return false\\n        }\\n        else if (root.left==null && root.right==null && root!!.`val`==sum){\\n            return true\\n        }\\n        return hasPathSum(root.left, sum-root!!.`val`) || hasPathSum(root.right, sum-root!!.`val`)\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***12ms / 32.2MB*** (beats 95% / 84%).\\n* ***Swift***\\n```\\nclass Solution {\\n    func hasPathSum(_ root: TreeNode?, _ targetSum: Int) -> Bool {\\n        guard let root = root else {\\n            return false\\n        }\\n        \\n        if root.left == nil && root.right == nil {\\n            return root.val == targetSum\\n        }\\n        \\n        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val)\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin",
                    "PHP",
                    "Recursion"
                ],
                "code": "```\\n```\n```\\n```\n```\\n```\n```\\n```\n```\\npublic boolean hasPathSum(TreeNode root, int sum) {\\n    // iteration method\\n    if (root == null) {return false;}\\n    Stack<TreeNode> path = new Stack<>();\\n    Stack<Integer> sub = new Stack<>();\\n    path.push(root);\\n    sub.push(root.val);\\n    while (!path.isEmpty()) {\\n        TreeNode temp = path.pop();\\n        int tempVal = sub.pop();\\n        if (temp.left == null && temp.right == null) {if (tempVal == sum) return true;}\\n        else {\\n            if (temp.left != null) {\\n                path.push(temp.left);\\n                sub.push(temp.left.val + tempVal);\\n            }\\n            if (temp.right != null) {\\n                path.push(temp.right);\\n                sub.push(temp.right.val + tempVal);\\n            }\\n        }\\n    }\\n    return false;\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int sum) {\\n        if(!root)return false;                                         //Terminating Condition\\n        sum=sum-root->val;                                             //Body\\n        if(sum==0&&!root->left&&!root->right)return true;              //body\\n        return hasPathSum(root->left,sum)||hasPathSum(root->right,sum);//Propagation\\n    }\\n};\\n```\n```\\n```\n```\\n```\n```\\ndef hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n\\n        def inorder(root, path_sum):\\n            if not root:\\n                return False\\n            \\n            path_sum+=root.val\\n            \\n            if not root.left and not root.right:\\n                return path_sum==targetSum\\n                \\n            return inorder(root.left, path_sum) or inorder(root.right, path_sum)\\n             \\n        return inorder(root, 0)\\n```\n```\\n```\n```\\n```\n```\\nvar hasPathSum = function(root, targetSum) {\\n    return dfs(root, targetSum);\\n    // T.C: O(N)\\n    // S.C: O(H)\\n};\\n\\nconst dfs = (root, target) => {\\n    if (!root) {\\n        return false;\\n    }\\n    if (!root.left && !root.right) {\\n        return target - root.val === 0;\\n    }\\n    return dfs(root.left, target - root.val) || \\n        dfs(root.right, target - root.val);\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    fun hasPathSum(root: TreeNode?, sum: Int): Boolean {\\n        if (root==null){\\n            return false\\n        }\\n        else if (root.left==null && root.right==null && root!!.`val`==sum){\\n            return true\\n        }\\n        return hasPathSum(root.left, sum-root!!.`val`) || hasPathSum(root.right, sum-root!!.`val`)\\n    }\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    func hasPathSum(_ root: TreeNode?, _ targetSum: Int) -> Bool {\\n        guard let root = root else {\\n            return false\\n        }\\n        \\n        if root.left == nil && root.right == nil {\\n            return root.val == targetSum\\n        }\\n        \\n        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val)\\n    }\\n}\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1567369,
                "title": "javascript-easy-to-understand-dfs",
                "content": "Since we need to sum the values from root to leaf, it\\'s straightforward to think about DFS. So, the process could be:\\n1. Traverse the tree via DFS\\n2. Check whether current node is leaf\\n\\t- check the target value\\n\\t- continue recursion\\n\\nHere\\'s the code:\\n\\n```js\\nconst hasPathSum = (node, target) => {\\n  if (!node) return false;\\n  if (!node.left && !node.right) return target === node.val;\\n  return (\\n    hasPathSum(node.left, target - node.val) ||\\n    hasPathSum(node.right, target - node.val)\\n  );\\n};\\n```\\n\\nEven, we could make it in 1-line:\\n\\n```js\\nconst hasPathSum = (node, target) => !!node && (!node.left && !node.right ? target === node.val : hasPathSum(node.left, target - node.val) || hasPathSum(node.right, target - node.val));\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst hasPathSum = (node, target) => {\\n  if (!node) return false;\\n  if (!node.left && !node.right) return target === node.val;\\n  return (\\n    hasPathSum(node.left, target - node.val) ||\\n    hasPathSum(node.right, target - node.val)\\n  );\\n};\\n```\n```js\\nconst hasPathSum = (node, target) => !!node && (!node.left && !node.right ? target === node.val : hasPathSum(node.left, target - node.val) || hasPathSum(node.right, target - node.val));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1517970,
                "title": "two-approaches-dfs-very-simple-c",
                "content": "\\nImplementation\\n\\n**1st Approach using helper(findPath) method\\nTime Complexity = O(N), Space Complexity = O(H) where H is the height of the Binary Tree**\\n\\n```\\nclass Solution {\\npublic:\\n    bool findPath(TreeNode* root, int targetSum, int sum){\\n        if(root == NULL) return false;\\n        sum += root->val;\\n        \\n        if(root->left == NULL && root->right == NULL){\\n            return (sum == targetSum) ? true : false;\\n        }\\n        return (findPath(root->left, targetSum, sum) || findPath(root->right, targetSum, sum));        \\n    }\\n    \\n    bool hasPathSum(TreeNode* root, int targetSum) {        \\n        return findPath(root, targetSum, 0);\\n    }\\n};\\n```\\n\\n**2nd Approach without using any helper method\\nTime Complexity = O(N), Space Complexity = O(H) where H is the height of the Binary Tree**\\n\\n```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {        \\n        if(root == NULL) return false;\\n        targetSum -= root->val;\\n        \\n        if(root->left == NULL && root->right == NULL){\\n            return (targetSum == 0) ? true : false;\\n        }\\n        return (hasPathSum(root->left, targetSum) || hasPathSum(root->right, targetSum));        \\n    }\\n};\\n```\\n\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding **:)**",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool findPath(TreeNode* root, int targetSum, int sum){\\n        if(root == NULL) return false;\\n        sum += root->val;\\n        \\n        if(root->left == NULL && root->right == NULL){\\n            return (sum == targetSum) ? true : false;\\n        }\\n        return (findPath(root->left, targetSum, sum) || findPath(root->right, targetSum, sum));        \\n    }\\n    \\n    bool hasPathSum(TreeNode* root, int targetSum) {        \\n        return findPath(root, targetSum, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {        \\n        if(root == NULL) return false;\\n        targetSum -= root->val;\\n        \\n        if(root->left == NULL && root->right == NULL){\\n            return (targetSum == 0) ? true : false;\\n        }\\n        return (hasPathSum(root->left, targetSum) || hasPathSum(root->right, targetSum));        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 746228,
                "title": "java-dfs-runtime-0-ms-faster-than-100-00-memory-usage-39-2-mb-less-than-73-39",
                "content": "```\\n// Runtime: 0 ms, faster than 100.00% of Java online submissions for Path Sum.\\n// Memory Usage: 39.2 MB, less than 73.39% of Java online submissions for Path Sum.\\nclass Solution {\\n    private boolean answer = false;\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if(root==null) return false;\\n        dfs(root,sum,0);\\n        return answer;    \\n    }\\n    \\n    private void dfs(TreeNode node, int sum, int currentSum){\\n        if(answer==true) return;\\n        \\n        if(node.left==null && node.right==null){\\n            currentSum+=node.val;\\n            if(sum==currentSum) answer = true;\\n            return;\\n        }\\n        \\n        currentSum+=node.val;\\n        if(node.left!=null) dfs(node.left, sum, currentSum);\\n        if(node.right!=null) dfs(node.right,sum,currentSum);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n// Runtime: 0 ms, faster than 100.00% of Java online submissions for Path Sum.\\n// Memory Usage: 39.2 MB, less than 73.39% of Java online submissions for Path Sum.\\nclass Solution {\\n    private boolean answer = false;\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if(root==null) return false;\\n        dfs(root,sum,0);\\n        return answer;    \\n    }\\n    \\n    private void dfs(TreeNode node, int sum, int currentSum){\\n        if(answer==true) return;\\n        \\n        if(node.left==null && node.right==null){\\n            currentSum+=node.val;\\n            if(sum==currentSum) answer = true;\\n            return;\\n        }\\n        \\n        currentSum+=node.val;\\n        if(node.left!=null) dfs(node.left, sum, currentSum);\\n        if(node.right!=null) dfs(node.right,sum,currentSum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 517434,
                "title": "java-0ms-recursive",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if(root == null)\\n            return false;\\n        else\\n            return (root.left == null && root.right == null && root.val == sum)\\n            || hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if(root == null)\\n            return false;\\n        else\\n            return (root.left == null && root.right == null && root.val == sum)\\n            || hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 36618,
                "title": "my-java-solution",
                "content": "    public class Solution {\\n        public boolean hasPathSum(TreeNode root, int sum) {\\n            if (root == null)\\n                return false;\\n            if (root.left == null && root.right == null)\\n                return sum == root.val;\\n            return hasPathSum(root.left,sum-root.val) || hasPathSum(root.right,sum-root.val);\\n        }   \\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean hasPathSum(TreeNode root, int sum) {\\n            if (root == null)\\n                return false;\\n            if (root.left == null && root.right == null)\\n                return sum == root.val;\\n            return hasPathSum(root.left,sum-root.val) || hasPathSum(root.right,sum-root.val);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 36640,
                "title": "my-solution-in-c",
                "content": "    /**\\n     * Definition for binary tree\\n     * struct TreeNode {\\n     *     int val;\\n     *     TreeNode *left;\\n     *     TreeNode *right;\\n     *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n     * };\\n     */\\n    class Solution {\\n    public:\\n        bool hasPathSum(TreeNode *root, int sum) {\\n            if(!root) return false;\\n            if(!root->left && !root->right)\\n                return root->val == sum;\\n            return hasPathSum(root->left,sum-root->val) || hasPathSum(root->right,sum-root->val);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool hasPathSum(TreeNode *root, int sum) {\\n            if(!root) return false;\\n            if(!root->left && !root->right)\\n                return root->val == sum;\\n            return hasPathSum(root->left,sum-root->val) || hasPathSum(root->right,sum-root->val);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3526144,
                "title": "c-easy-in-3-lines",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if (!root) return false;\\n        if (root->val == targetSum && !root->left && !root->right) return true;\\n        return hasPathSum(root->right, targetSum - root->val) || hasPathSum(root->left, targetSum - root->val);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if (!root) return false;\\n        if (root->val == targetSum && !root->left && !root->right) return true;\\n        return hasPathSum(root->right, targetSum - root->val) || hasPathSum(root->left, targetSum - root->val);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418430,
                "title": "easiest-java-solution-beats-100-recursive",
                "content": "# Intuition\\nIteration of Tree and summing up the path till leaf.\\nsearcing the leaf node is equal to target or not.\\n\\n# Approach\\njust like node to leaf sum problem , sum up all path till leaf\\nex- \\n```\\ntree = 1            and target is 11\\n      / \\\\\\n    2     3\\n   /     / \\\\\\n  5     4   7\\n```\\n\\nso after path() function tree will be like\\n```\\n       1\\n      / \\\\\\n    3     4\\n   /     / \\\\\\n  8     8   11  \\n\\n```\\n* now search through the leaf to check is there any targetSum present or not if any return true else false  \\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    public boolean hasPathSum(TreeNode root, int targetSum){\\n        path(root);\\n        return has(root,targetSum);\\n    }\\n    public boolean has(TreeNode root, int targetSum) {\\n        if(root==null)\\n        return false;\\n\\n        if(root.left==null && root.right==null){\\n            if(root.val==targetSum)\\n            return true;\\n        }\\n\\n        return has(root.left,targetSum) || has(root.right,targetSum);\\n    }\\n\\n    public static void path(TreeNode root){\\n        if(root==null)\\n        return;\\n        int data = root.val;\\n        if(root.left!=null)\\n        root.left.val += data;\\n\\n        if(root.right!=null)\\n        root.right.val += data;\\n\\n        path(root.left);\\n        path(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\ntree = 1            and target is 11\\n      / \\\\\\n    2     3\\n   /     / \\\\\\n  5     4   7\\n```\n```\\n       1\\n      / \\\\\\n    3     4\\n   /     / \\\\\\n  8     8   11  \\n\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    public boolean hasPathSum(TreeNode root, int targetSum){\\n        path(root);\\n        return has(root,targetSum);\\n    }\\n    public boolean has(TreeNode root, int targetSum) {\\n        if(root==null)\\n        return false;\\n\\n        if(root.left==null && root.right==null){\\n            if(root.val==targetSum)\\n            return true;\\n        }\\n\\n        return has(root.left,targetSum) || has(root.right,targetSum);\\n    }\\n\\n    public static void path(TreeNode root){\\n        if(root==null)\\n        return;\\n        int data = root.val;\\n        if(root.left!=null)\\n        root.left.val += data;\\n\\n        if(root.right!=null)\\n        root.right.val += data;\\n\\n        path(root.left);\\n        path(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294258,
                "title": "my-shortest-c-solution",
                "content": "\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if (!root)\\n            return false;\\n        \\n        if (root->val == targetSum and !root->left and !root->right)\\n            return true;\\n        \\n        return hasPathSum(root->left, targetSum - root->val) or hasPathSum(root->right, targetSum - root->val);\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time Complexity : $$O(n)$$ [worst case : Traverse all `n` nodes]\\n- Space Complexity : $$O(1)$$",
                "solutionTags": [
                    "C++"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if (!root)\\n            return false;\\n        \\n        if (root->val == targetSum and !root->left and !root->right)\\n            return true;\\n        \\n        return hasPathSum(root->left, targetSum - root->val) or hasPathSum(root->right, targetSum - root->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3058005,
                "title": "javascript-simple-up-vote-if-u-like",
                "content": "# Code\\n```\\nvar hasPathSum = function(root, targetSum) {\\n    if (!root) return false // not a leaf\\n    if (!root.left && !root.right) return root.val === targetSum; // leaf\\n\\n    return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar hasPathSum = function(root, targetSum) {\\n    if (!root) return false // not a leaf\\n    if (!root.left && !root.right) return root.val === targetSum; // leaf\\n\\n    return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3039724,
                "title": "0ms-java-solution-another-approach",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int target) \\n    {\\n        if(root==null)\\n            return false;\\n        if(root.left==null && root.right==null)\\n            return (target-root.val)==0;\\n     return hasPathSum(root.left,target-root.val) || hasPathSum(root.right,target-root.val);   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int target) \\n    {\\n        if(root==null)\\n            return false;\\n        if(root.left==null && root.right==null)\\n            return (target-root.val)==0;\\n     return hasPathSum(root.left,target-root.val) || hasPathSum(root.right,target-root.val);   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2813240,
                "title": "python-recursive",
                "content": "```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        def helper(node,tot):\\n            if not node:\\n                return \\n            elif not node.left and not node.right:\\n                if tot+node.val==targetSum:\\n                    return True\\n            else:\\n                return helper(node.left,tot+node.val) or helper(node.right,tot+node.val)\\n        if root:\\n            return helper(root,0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        def helper(node,tot):\\n            if not node:\\n                return \\n            elif not node.left and not node.right:\\n                if tot+node.val==targetSum:\\n                    return True\\n            else:\\n                return helper(node.left,tot+node.val) or helper(node.right,tot+node.val)\\n        if root:\\n            return helper(root,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2660894,
                "title": "c-concise-recursion-clean-inorder-traversal",
                "content": "```\\n  bool inorder(TreeNode* root , int sum , int &targetSum)\\n    {\\n        if(!root) return false;\\n        sum+=root->val;\\n        if(root->left==NULL && root->right==NULL) if(sum==targetSum) return true; \\n        return (inorder(root->left , sum , targetSum) || inorder(root->right , sum , targetSum));\\n    }\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        return inorder(root, 0 , targetSum);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  bool inorder(TreeNode* root , int sum , int &targetSum)\\n    {\\n        if(!root) return false;\\n        sum+=root->val;\\n        if(root->left==NULL && root->right==NULL) if(sum==targetSum) return true; \\n        return (inorder(root->left , sum , targetSum) || inorder(root->right , sum , targetSum));\\n    }\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        return inorder(root, 0 , targetSum);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2231534,
                "title": "java-0ms-simple-explanation-with-tc-sc-easy-to-understand",
                "content": "```\\nclass Solution {\\n    \\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        \\n        //return false when root is null or when we reached leaf node but the sum is not equal to target sum\\n        if(root == null) {\\n            return false;\\n        }\\n        \\n        //if the current node is not null then we subract targetSum by it\\'s value and pass the new targetSum ahead in the function\\n        targetSum = targetSum - root.val;\\n        \\n        //if both sides are null then it means that we have reached leaf node and if at the same time targetSum is also equals to 0 then we can return true because we have found the path\\n        if(root.left == null && root.right == null && 0 == targetSum) {\\n            return true;\\n        }\\n        \\n        //we do a recursive call for both the sides and use \\'or(||)\\' function because even if one side is true then we got the ans(path)\\n        return hasPathSum(root.left,  targetSum) || hasPathSum(root.right, targetSum);\\n    }\\n    \\n}\\n\\n//Time Complexity: O(n) n is the total number of nodes in the binary tree\\n//Space Complexity: O(n) n is the total number of nodes in the binary tree\\n//Please upvote the solution if you like it",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n    \\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        \\n        //return false when root is null or when we reached leaf node but the sum is not equal to target sum\\n        if(root == null) {\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1550790,
                "title": "90-faster-c-solution",
                "content": "```\\n bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(!root){\\n            return false;\\n        }\\n        if(targetSum==root->val && root->left==NULL && root->right==NULL){\\n            return true;\\n        }\\n        return hasPathSum(root->left,targetSum-(root->val)) || hasPathSum(root->right,targetSum-(root->val));\\n    }\\n```\\nFor More LeetCode Problem\\'s Solution(Topic-Wise)Please Check Out;\\nhttps://github.com/Ariyanlaskar/DSA/tree/master/LeetCode",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(!root){\\n            return false;\\n        }\\n        if(targetSum==root->val && root->left==NULL && root->right==NULL){\\n            return true;\\n        }\\n        return hasPathSum(root->left,targetSum-(root->val)) || hasPathSum(root->right,targetSum-(root->val));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1381668,
                "title": "c-dfs-recursive-dfs-iterative-and-bfs",
                "content": "DFS Recursive:\\n\\n```\\npublic bool HasPathSum(TreeNode root, int targetSum)\\n{\\n    if(root == null)\\n        return false;\\n    \\n    if(root.left == null && root.right == null)\\n        return root.val == targetSum;\\n    \\n    return HasPathSum(root.left, targetSum - root.val) || HasPathSum(root.right, targetSum - root.val);\\n}\\n```\\n\\nDFS Iterative:\\n\\n```\\npublic bool HasPathSum(TreeNode root, int targetSum)\\n{\\n    if(root == null)\\n        return false;\\n        \\n    var stack = new Stack<TreeNode>();\\n    var rest = new Stack<int>();\\n    \\n    stack.Push(root);\\n    rest.Push(targetSum);\\n    \\n    while(stack.Count() > 0)\\n    {\\n        root = stack.Pop();\\n        targetSum = rest.Pop();\\n        \\n        if(root.left == null && root.right == null)\\n        {\\n            if(targetSum == root.val)\\n                return true;\\n        }\\n            \\n        if(root.left != null)\\n        {\\n            stack.Push(root.left);\\n            rest.Push(targetSum - root.val);\\n        }\\n            \\n        if(root.right != null)\\n        {\\n            stack.Push(root.right);\\n            rest.Push(targetSum - root.val);\\n        }\\n    }\\n    return false;\\n}\\n```\\n\\nBFS:\\n\\n```\\npublic bool HasPathSum(TreeNode root, int targetSum)\\n{\\n    if (root == null)\\n        return false;\\n        \\n    var queue = new Queue<TreeNode>();\\n    var rest = new Queue<int>();\\n    \\n    queue.Enqueue(root);\\n    rest.Enqueue(targetSum);\\n\\n    while (queue.Count() > 0)\\n    {\\n        root = queue.Dequeue();\\n        targetSum = rest.Dequeue();\\n        \\n        if (root.left == null && root.right == null)\\n        {\\n            if(targetSum == root.val)\\n                return true;\\n        }\\n        \\n        if(root.left != null)\\n        {\\n            queue.Enqueue(root.left);\\n            rest.Enqueue(targetSum - root.val);\\n        }\\n        \\n        if(root.right != null)\\n        {\\n            queue.Enqueue(root.right);\\n            rest.Enqueue(targetSum - root.val);\\n        }\\n    }\\n\\n    return false;\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\npublic bool HasPathSum(TreeNode root, int targetSum)\\n{\\n    if(root == null)\\n        return false;\\n    \\n    if(root.left == null && root.right == null)\\n        return root.val == targetSum;\\n    \\n    return HasPathSum(root.left, targetSum - root.val) || HasPathSum(root.right, targetSum - root.val);\\n}\\n```\n```\\npublic bool HasPathSum(TreeNode root, int targetSum)\\n{\\n    if(root == null)\\n        return false;\\n        \\n    var stack = new Stack<TreeNode>();\\n    var rest = new Stack<int>();\\n    \\n    stack.Push(root);\\n    rest.Push(targetSum);\\n    \\n    while(stack.Count() > 0)\\n    {\\n        root = stack.Pop();\\n        targetSum = rest.Pop();\\n        \\n        if(root.left == null && root.right == null)\\n        {\\n            if(targetSum == root.val)\\n                return true;\\n        }\\n            \\n        if(root.left != null)\\n        {\\n            stack.Push(root.left);\\n            rest.Push(targetSum - root.val);\\n        }\\n            \\n        if(root.right != null)\\n        {\\n            stack.Push(root.right);\\n            rest.Push(targetSum - root.val);\\n        }\\n    }\\n    return false;\\n}\\n```\n```\\npublic bool HasPathSum(TreeNode root, int targetSum)\\n{\\n    if (root == null)\\n        return false;\\n        \\n    var queue = new Queue<TreeNode>();\\n    var rest = new Queue<int>();\\n    \\n    queue.Enqueue(root);\\n    rest.Enqueue(targetSum);\\n\\n    while (queue.Count() > 0)\\n    {\\n        root = queue.Dequeue();\\n        targetSum = rest.Dequeue();\\n        \\n        if (root.left == null && root.right == null)\\n        {\\n            if(targetSum == root.val)\\n                return true;\\n        }\\n        \\n        if(root.left != null)\\n        {\\n            queue.Enqueue(root.left);\\n            rest.Enqueue(targetSum - root.val);\\n        }\\n        \\n        if(root.right != null)\\n        {\\n            queue.Enqueue(root.right);\\n            rest.Enqueue(targetSum - root.val);\\n        }\\n    }\\n\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 525239,
                "title": "python-js-go-c-o-n-dfs-w-hint",
                "content": "Python O(n) sol by DFS\\n\\n---\\n**Hint**:\\n\\nThink of **DFS** algorithm framework\\n\\nOne node is the so-called **leaf node**, if and only if,\\nit is **not an empty node** and it **doesn\\'t have** both *left child* and *right child*.\\n\\nImagine the path sum as a process treasure hunt **from root to leaf** with specified target value\\n\\nUpdate *target value* as *previous target* - *current node value*, then go down to next level in DFS.\\n\\n\\n---\\n**Implementation_#1**:\\nDFS with recursion\\n\\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        \\n        ## Base case\\n        if not root:\\n            return False\\n        \\n        ## Base case\\n        if not root.left and not root.right:\\n            \\n            # we have the path with targetSum\\n            return targetSum == root.val\\n        \\n        ## General case:\\n        return self.hasPathSum(root.left, targetSum - root.val) or \\\\\\n                self.hasPathSum(root.right, targetSum - root.val)\\n```\\n\\n---\\n\\nin **Javascript**:\\n\\n<details>\\n\\t<summary> Expand to see source code </summary>\\n\\n```\\nvar hasPathSum = function(root, targetSum) {\\n    \\n    // Base case\\n    if( null == root ){\\n        return false;\\n    }\\n    \\n    \\n    if( null == root.left && null == root.right ){\\n        // Base case\\n        return root.val == targetSum;\\n    }else{\\n        \\n        // General cases\\n        return hasPathSum( root.left, targetSum-root.val ) || hasPathSum( root.right, targetSum-root.val );\\n    }\\n};\\n```\\n\\n</details>\\n\\n---\\n\\nin **Go**:\\n\\n<details>\\n\\t<summary> Expand to see source code </summary>\\n\\t\\n```\\nfunc hasPathSum(root *TreeNode, targetSum int) bool {\\n    \\n    // Base case\\n    if nil == root{\\n        return false\\n    }\\n    \\n    \\n    if nil == root.Left && nil == root.Right{\\n        // Base case\\n        return root.Val == targetSum\\n        \\n    }else{\\n        // General cases\\n        return hasPathSum(root.Left, targetSum - root.Val) || hasPathSum(root.Right, targetSum - root.Val)\\n    }\\n}\\n```\\n\\n</details>\\n\\n---\\n\\nin **C++**\\n\\n<details>\\n\\t<summary> Expand to see source code </summary>\\n\\t\\n```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        \\n        if ( NULL == root ){\\n            return false;\\n        }\\n        \\n        if ( NULL == root->left && NULL == root->right){\\n            return root->val == targetSum;\\n        }else{\\n            return hasPathSum(root->left, targetSum - root->val) || hasPathSum(root->right, targetSum - root->val);\\n        }\\n    }\\n};\\n```\\n</details>\\n\\n---\\n**Implementation_#2**:\\nDFS with stack\\n\\n```\\nclass Solution:\\n    \\n    def hasPathSum(self, root, sum):\\n        \\n        traversal_stack = [(root, sum)]\\n        \\n        # DFS with stack\\n        while traversal_stack:\\n            \\n            node, value = traversal_stack.pop()\\n            \\n            if node:\\n                if not node.left and not node.right and node.val == value:\\n                    # leaf node\\n                    return True\\n                \\n                else:\\n                    # non-leaf node\\n                    traversal_stack.append((node.right, value-node.val))\\n                    traversal_stack.append((node.left, value-node.val))\\n\\n            else:\\n                # empty node\\n                continue\\n                \\n        return False\\n```\\n\\n---\\n\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[1] [Leetcode #113 Path Sum II](https://leetcode.com/problems/path-sum-ii/)\\n\\n[2] [Leetcode #437 Path Sum III](https://leetcode.com/problems/path-sum-iii/)\\n\\n[3] [Leetcode #129 Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/)",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C",
                    "JavaScript",
                    "Go",
                    "Stack",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        \\n        ## Base case\\n        if not root:\\n            return False\\n        \\n        ## Base case\\n        if not root.left and not root.right:\\n            \\n            # we have the path with targetSum\\n            return targetSum == root.val\\n        \\n        ## General case:\\n        return self.hasPathSum(root.left, targetSum - root.val) or \\\\\\n                self.hasPathSum(root.right, targetSum - root.val)\\n```\n```\\nvar hasPathSum = function(root, targetSum) {\\n    \\n    // Base case\\n    if( null == root ){\\n        return false;\\n    }\\n    \\n    \\n    if( null == root.left && null == root.right ){\\n        // Base case\\n        return root.val == targetSum;\\n    }else{\\n        \\n        // General cases\\n        return hasPathSum( root.left, targetSum-root.val ) || hasPathSum( root.right, targetSum-root.val );\\n    }\\n};\\n```\n```\\nfunc hasPathSum(root *TreeNode, targetSum int) bool {\\n    \\n    // Base case\\n    if nil == root{\\n        return false\\n    }\\n    \\n    \\n    if nil == root.Left && nil == root.Right{\\n        // Base case\\n        return root.Val == targetSum\\n        \\n    }else{\\n        // General cases\\n        return hasPathSum(root.Left, targetSum - root.Val) || hasPathSum(root.Right, targetSum - root.Val)\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        \\n        if ( NULL == root ){\\n            return false;\\n        }\\n        \\n        if ( NULL == root->left && NULL == root->right){\\n            return root->val == targetSum;\\n        }else{\\n            return hasPathSum(root->left, targetSum - root->val) || hasPathSum(root->right, targetSum - root->val);\\n        }\\n    }\\n};\\n```\n```\\nclass Solution:\\n    \\n    def hasPathSum(self, root, sum):\\n        \\n        traversal_stack = [(root, sum)]\\n        \\n        # DFS with stack\\n        while traversal_stack:\\n            \\n            node, value = traversal_stack.pop()\\n            \\n            if node:\\n                if not node.left and not node.right and node.val == value:\\n                    # leaf node\\n                    return True\\n                \\n                else:\\n                    # non-leaf node\\n                    traversal_stack.append((node.right, value-node.val))\\n                    traversal_stack.append((node.left, value-node.val))\\n\\n            else:\\n                # empty node\\n                continue\\n                \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328124,
                "title": "simple-python-solution-top-down-dfs",
                "content": "Please see and vote for my solutions for these similar problems.\\n\\n[257. Binary Tree Paths](https://leetcode.com/problems/binary-tree-paths/discuss/309004/Different-DFS-Python-solutions)\\n```\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        def dfs(node, path, res):\\n            if node.left == None and node.right == None:\\n                res.append(path + str(node.val))\\n            if node.left:\\n                dfs(node.left, path + str(node.val) + \\'->\\', res)\\n            if node.right:\\n                dfs(node.right, path + str(node.val) + \\'->\\', res)\\n        \\n        if not root:\\n            return []\\n        res = []\\n        dfs(root, \"\", res)\\n        return res\\n```\\n\\n[129. Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/discuss/328123/Simple-Python-Solution%3A-top-down-DFS)\\n```\\n    def sumNumbers(self, root: TreeNode) -> int:\\n        def dfs(node, bits, res):\\n            if node.left == None and node.right == None:\\n                res[0] += int(bits + str(node.val), 10)\\n            if node.left:\\n                dfs(node.left, bits + str(node.val), res)\\n            if node.right:\\n                dfs(node.right, bits + str(node.val), res)\\n        \\n        if root == None:\\n            return 0\\n        bits, res = \\'\\', [0]\\n        dfs(root, bits, res)\\n        return res[0]\\n```\\n\\n[1022. Sum of Root To Leaf Binary Numbers](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/discuss/328033/Top-down-Python-DFS-Solution)\\n```\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        def dfs(node, bits, res):\\n            if node.left == None and node.right == None:\\n                res[0] += int(bits + str(node.val), 2)\\n            if node.left:\\n                dfs(node.left, bits + str(node.val), res)\\n            if node.right:\\n                dfs(node.right, bits + str(node.val), res)\\n        \\n        if root == None:\\n            return 0\\n        bits, res = \\'\\', [0]\\n        dfs(root, bits, res)\\n        return res[0]\\n```\\n\\n[988. Smallest String Starting From Leaf](https://leetcode.com/problems/smallest-string-starting-from-leaf/discuss/328119/Simple-Python-Solution%3A-top-down-DFS)\\n```\\n    def smallestFromLeaf(self, root: TreeNode) -> str:\\n        def dfs(root, s):\\n            s = s + chr(ord(\\'a\\') + root.val)\\n            if not root.left and not root.right:\\n                if res[0] == None:\\n                    res[0] = s[::-1]\\n                else:\\n                    res[0] = min(res[0], s[::-1])\\n            if root.left:\\n                dfs(root.left, s)\\n            if root.right:\\n                dfs(root.right, s)\\n        \\n        if not root:\\n            return \\'\\'\\n        res = [None]\\n        dfs(root, \\'\\')\\n        return res[0]\\n```\\n\\n[112. Path Sum](https://leetcode.com/problems/path-sum/discuss/328124/Simple-Python-Solution%3A-top-down-DFS)\\n\\n```\\n    def hasPathSum(self, root: TreeNode, s: int) -> bool:\\n        def dfs(root, curr_s):\\n            curr_s += root.val\\n            if not root.left and not root.right:\\n                if curr_s == s:\\n                    res[0] = True\\n                    return\\n            if not res[0] and root.left:\\n                dfs(root.left, curr_s)\\n            if not res[0] and root.right:\\n                dfs(root.right, curr_s)\\n        \\n        if not root:\\n            return False\\n        res = [False]\\n        dfs(root, 0)\\n        return res[0]\\n```\\n\\n[113. Path Sum II](https://leetcode.com/problems/path-sum-ii/discuss/328125/Simple-Python-Solution%3A-top-down-DFS)\\n```\\n    def pathSum(self, root: TreeNode, s: int) -> List[List[int]]:\\n        def dfs(root, lst, curr_s):\\n            curr_s += root.val\\n            if not root.left and not root.right:\\n                if curr_s == s:\\n                    res.append(lst + [root.val])\\n                    return\\n            if root.left:\\n                dfs(root.left, lst + [root.val], curr_s)\\n            if root.right:\\n                dfs(root.right, lst + [root.val], curr_s)\\n        \\n        if not root:\\n            return []\\n        res = []\\n        dfs(root, [], 0)\\n        return res\\n```\\n\\n[437. Path Sum III](https://leetcode.com/problems/path-sum-iii/discuss/328128/Simple-Python-Solution%3A-top-down-DFS-%2B-DP) (Similar problem: 560. Subarray Sum Equals K)\\n\\n```\\n    def pathSum(self, root, s):\\n        def dfs(root, curr_s):\\n            curr_s += root.val\\n            res[0] += pre_sums.get(curr_s - s, 0)\\n            pre_sums[curr_s] = pre_sums.get(curr_s, 0) + 1\\n            if root.left:\\n                dfs(root.left, curr_s)\\n            if root.right:\\n                dfs(root.right, curr_s)\\n            pre_sums[curr_s] -= 1\\n            if pre_sums[curr_s] == 0:\\n                del pre_sums[curr_s]\\n        \\n        res = [0]\\n        pre_sums = {0: 1}\\n        if not root:\\n            return res[0]\\n        dfs(root, 0)\\n        return res[0]\\n```",
                "solutionTags": [],
                "code": "```\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        def dfs(node, path, res):\\n            if node.left == None and node.right == None:\\n                res.append(path + str(node.val))\\n            if node.left:\\n                dfs(node.left, path + str(node.val) + \\'->\\', res)\\n            if node.right:\\n                dfs(node.right, path + str(node.val) + \\'->\\', res)\\n        \\n        if not root:\\n            return []\\n        res = []\\n        dfs(root, \"\", res)\\n        return res\\n```\n```\\n    def sumNumbers(self, root: TreeNode) -> int:\\n        def dfs(node, bits, res):\\n            if node.left == None and node.right == None:\\n                res[0] += int(bits + str(node.val), 10)\\n            if node.left:\\n                dfs(node.left, bits + str(node.val), res)\\n            if node.right:\\n                dfs(node.right, bits + str(node.val), res)\\n        \\n        if root == None:\\n            return 0\\n        bits, res = \\'\\', [0]\\n        dfs(root, bits, res)\\n        return res[0]\\n```\n```\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        def dfs(node, bits, res):\\n            if node.left == None and node.right == None:\\n                res[0] += int(bits + str(node.val), 2)\\n            if node.left:\\n                dfs(node.left, bits + str(node.val), res)\\n            if node.right:\\n                dfs(node.right, bits + str(node.val), res)\\n        \\n        if root == None:\\n            return 0\\n        bits, res = \\'\\', [0]\\n        dfs(root, bits, res)\\n        return res[0]\\n```\n```\\n    def smallestFromLeaf(self, root: TreeNode) -> str:\\n        def dfs(root, s):\\n            s = s + chr(ord(\\'a\\') + root.val)\\n            if not root.left and not root.right:\\n                if res[0] == None:\\n                    res[0] = s[::-1]\\n                else:\\n                    res[0] = min(res[0], s[::-1])\\n            if root.left:\\n                dfs(root.left, s)\\n            if root.right:\\n                dfs(root.right, s)\\n        \\n        if not root:\\n            return \\'\\'\\n        res = [None]\\n        dfs(root, \\'\\')\\n        return res[0]\\n```\n```\\n    def hasPathSum(self, root: TreeNode, s: int) -> bool:\\n        def dfs(root, curr_s):\\n            curr_s += root.val\\n            if not root.left and not root.right:\\n                if curr_s == s:\\n                    res[0] = True\\n                    return\\n            if not res[0] and root.left:\\n                dfs(root.left, curr_s)\\n            if not res[0] and root.right:\\n                dfs(root.right, curr_s)\\n        \\n        if not root:\\n            return False\\n        res = [False]\\n        dfs(root, 0)\\n        return res[0]\\n```\n```\\n    def pathSum(self, root: TreeNode, s: int) -> List[List[int]]:\\n        def dfs(root, lst, curr_s):\\n            curr_s += root.val\\n            if not root.left and not root.right:\\n                if curr_s == s:\\n                    res.append(lst + [root.val])\\n                    return\\n            if root.left:\\n                dfs(root.left, lst + [root.val], curr_s)\\n            if root.right:\\n                dfs(root.right, lst + [root.val], curr_s)\\n        \\n        if not root:\\n            return []\\n        res = []\\n        dfs(root, [], 0)\\n        return res\\n```\n```\\n    def pathSum(self, root, s):\\n        def dfs(root, curr_s):\\n            curr_s += root.val\\n            res[0] += pre_sums.get(curr_s - s, 0)\\n            pre_sums[curr_s] = pre_sums.get(curr_s, 0) + 1\\n            if root.left:\\n                dfs(root.left, curr_s)\\n            if root.right:\\n                dfs(root.right, curr_s)\\n            pre_sums[curr_s] -= 1\\n            if pre_sums[curr_s] == 0:\\n                del pre_sums[curr_s]\\n        \\n        res = [0]\\n        pre_sums = {0: 1}\\n        if not root:\\n            return res[0]\\n        dfs(root, 0)\\n        return res[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 111106,
                "title": "javascript-clean-solution",
                "content": "```\\nvar hasPathSum = function(root, sum) {\\n    let res = false;\\n    function helper(node, cur){\\n        if(!node) return;\\n        cur += node.val;\\n        if(!node.left && !node.right){\\n            if(cur === sum){\\n                res = true;\\n                return;\\n            }\\n        }\\n        else{\\n            helper(node.left, cur);\\n            helper(node.right, cur);\\n        }\\n    }\\n    helper(root, 0);\\n    return res;\\n};",
                "solutionTags": [],
                "code": "```\\nvar hasPathSum = function(root, sum) {\\n    let res = false;\\n    function helper(node, cur){\\n        if(!node) return;\\n        cur += node.val;\\n        if(!node.left && !node.right){\\n            if(cur === sum){\\n                res = true;\\n                return;\\n            }\\n        }\\n        else{\\n            helper(node.left, cur);\\n            helper(node.right, cur);\\n        }\\n    }\\n    helper(root, 0);\\n    return res;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 36387,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func hasPathSum(_ root: TreeNode?, _ sum: Int) -> Bool {\\n        guard let root = root else {\\n            return false\\n        }\\n        \\n        if root.left == nil && root.right == nil {\\n            return root.val == sum\\n        }\\n        \\n        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func hasPathSum(_ root: TreeNode?, _ sum: Int) -> Bool {\\n        guard let root = root else {\\n            return false\\n        }\\n        \\n        if root.left == nil && root.right == nil {\\n            return root.val == sum\\n        }\\n        \\n        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 36389,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public bool HasPathSum(TreeNode root, int sum) {\\n        if (root == null)\\n            return false;\\n        \\n        if (root.left == null && root.right == null)\\n            return sum == root.val;\\n        \\n        return HasPathSum(root.left, sum - root.val) || HasPathSum(root.right, sum - root.val);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public bool HasPathSum(TreeNode root, int sum) {\\n        if (root == null)\\n            return false;\\n        \\n        if (root.left == null && root.right == null)\\n            return sum == root.val;\\n        \\n        return HasPathSum(root.left, sum - root.val) || HasPathSum(root.right, sum - root.val);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 36513,
                "title": "accepted-java-iteration-solution-with-one-stack-without-change-the-value-of-treenode",
                "content": "Enjoy my first post ^ ^\\n\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n\\t\\tStack<TreeNode> stack = new Stack<>();\\n\\t\\twhile (!stack.isEmpty() || root != null) {\\n\\t\\t\\twhile (root != null) {\\n\\t\\t\\t\\tstack.push(root);\\n\\t\\t\\t\\tsum -= root.val;\\n\\t\\t\\t\\troot = root.left;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif (sum == 0 && stack.peek().right == null && stack.peek().left == null) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t} \\n\\t\\t\\t\\n\\t\\t\\t//root == null\\n\\t\\t\\t//pop all nodes whose children pathes have been both checked.\\n\\t\\t\\twhile (!stack.isEmpty() && stack.peek().right == root) {\\n\\t\\t\\t    root = stack.pop();\\n\\t\\t\\t    sum += root.val;\\n\\t\\t\\t}\\n\\t\\t\\troot = stack.isEmpty() ? null : stack.peek().right;\\n\\t\\t\\t//root is now the first node in in-order which has never been pushed in the stack.\\n\\t\\t}\\n\\t\\treturn false;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Enjoy my first post ^ ^\\n\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n\\t\\tStack<TreeNode> stack = new Stack<>();\\n\\t\\twhile (!stack.isEmpty() || root != null) {\\n\\t\\t\\twhile (root != null) {\\n\\t\\t\\t\\tstack.push(root);\\n\\t\\t\\t\\tsum -= root.val;\\n\\t\\t\\t\\troot = root.left;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif (sum == 0 && stack.peek().right == null && stack.peek().left == null) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t} \\n\\t\\t\\t\\n\\t\\t\\t//root == null\\n\\t\\t\\t//pop all nodes whose children pathes have been both checked.\\n\\t\\t\\twhile (!stack.isEmpty() && stack.peek().right == root) {\\n\\t\\t\\t    root = stack.pop();\\n\\t\\t\\t    sum += root.val;\\n\\t\\t\\t}\\n\\t\\t\\troot = stack.isEmpty() ? null : stack.peek().right;\\n\\t\\t\\t//root is now the first node in in-order which has never been pushed in the stack.\\n\\t\\t}\\n\\t\\treturn false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 36523,
                "title": "clean-1-ms-recursive-java-solution",
                "content": "    public boolean hasPathSum(TreeNode root, int sum) {\\n        \\n        if((root==null))\\n        {\\n            return false;\\n        }\\n        sum=sum-root.val;\\n        if(sum==0)\\n        {\\n            if((root.left==null)&&(root.right==null))\\n            {\\n                return true;\\n            }\\n        }\\n\\n       if(hasPathSum(root.left,sum)||hasPathSum(root.right,sum))\\n       {\\n           return true;\\n       }\\n\\n        \\n        return false;\\n        \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public boolean hasPathSum(TreeNode root, int sum) {\\n        \\n        if((root==null))\\n        {\\n            return false;\\n        }\\n        sum=sum-root.val;\\n        if(sum==0)\\n        {\\n            if((root.left==null)&&(root.right==null))\\n            {\\n                return true;\\n            }\\n        }\\n\\n       if(hasPathSum(root.left,sum)||hasPathSum(root.right,sum))\\n       {\\n           return true;\\n       }\\n\\n        \\n        return false;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 36568,
                "title": "a-c-recursive-version",
                "content": "    public bool HasPathSum(TreeNode root, int sum) {\\n        return root == null ? false :\\n               root.val == sum && root.left == null && root.right == null\\n            || HasPathSum(root.left, sum - root.val)\\n            || HasPathSum(root.right, sum - root.val);\\n    }",
                "solutionTags": [],
                "code": "    public bool HasPathSum(TreeNode root, int sum) {\\n        return root == null ? false :\\n               root.val == sum && root.left == null && root.right == null\\n            || HasPathSum(root.left, sum - root.val)\\n            || HasPathSum(root.right, sum - root.val);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3009126,
                "title": "1ms-java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root==null){\\n            return false;\\n        }\\n        if(root.left==null && root.right==null && root.val==targetSum){\\n            return true;\\n        }\\n        if(hasPathSum(root.left,targetSum-root.val)||hasPathSum(root.right,targetSum-root.val)){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root==null){\\n            return false;\\n        }\\n        if(root.left==null && root.right==null && root.val==targetSum){\\n            return true;\\n        }\\n        if(hasPathSum(root.left,targetSum-root.val)||hasPathSum(root.right,targetSum-root.val)){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2660876,
                "title": "java-dfs-and-bfs",
                "content": "# Intuition\\nTraverse the tree and sum up the values you get along the path to a leaf node.\\nWhenever you arrive at a leaf node, check whether it is equal to the `targetSum`\\n\\n# DFS\\n```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) return false;\\n        return searchPathSum(root, 0, targetSum);\\n    }\\n    \\n    public boolean searchPathSum(TreeNode root, int currentSum, int targetSum) {\\n        if (root == null) {\\n            return false;\\n        }\\n        \\n        currentSum += root.val;\\n        if (root.left == null && root.right == null) {\\n            return currentSum == targetSum;\\n        }\\n        \\n        return searchPathSum(root.left, currentSum, targetSum) || searchPathSum(root.right, currentSum, targetSum);\\n    }\\n}\\n```\\n\\n# BFS\\n```\\nclass TreeElement {\\n    public TreeNode node;\\n    private int sum;\\n    \\n    TreeElement(TreeNode node, int sum) {\\n        this.node = node;\\n        this.sum = sum;\\n    }\\n    \\n    public boolean isLeaf() {\\n        return node != null && node.left == null && node.right == null;\\n    }\\n    \\n    public int getSum() {\\n        return sum;\\n    }\\n}\\n\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) return false;\\n        \\n        Queue<TreeElement> queue = new LinkedList<TreeElement>();\\n        queue.add(new TreeElement(root, 0));\\n        \\n        while(queue.size() != 0) {\\n            TreeElement currentElement = queue.poll();\\n            if(currentElement.node == null) continue;\\n            \\n            int newSum = currentElement.getSum() + currentElement.node.val;\\n            if(currentElement.isLeaf() && newSum == targetSum) {\\n                return true;\\n            }\\n            \\n            if(currentElement.node.right != null) {\\n                queue.add(new TreeElement(currentElement.node.right, newSum));\\n            }\\n            if(currentElement.node.left != null) {\\n                queue.add(new TreeElement(currentElement.node.left, newSum));\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) return false;\\n        return searchPathSum(root, 0, targetSum);\\n    }\\n    \\n    public boolean searchPathSum(TreeNode root, int currentSum, int targetSum) {\\n        if (root == null) {\\n            return false;\\n        }\\n        \\n        currentSum += root.val;\\n        if (root.left == null && root.right == null) {\\n            return currentSum == targetSum;\\n        }\\n        \\n        return searchPathSum(root.left, currentSum, targetSum) || searchPathSum(root.right, currentSum, targetSum);\\n    }\\n}\\n```\n```\\nclass TreeElement {\\n    public TreeNode node;\\n    private int sum;\\n    \\n    TreeElement(TreeNode node, int sum) {\\n        this.node = node;\\n        this.sum = sum;\\n    }\\n    \\n    public boolean isLeaf() {\\n        return node != null && node.left == null && node.right == null;\\n    }\\n    \\n    public int getSum() {\\n        return sum;\\n    }\\n}\\n\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) return false;\\n        \\n        Queue<TreeElement> queue = new LinkedList<TreeElement>();\\n        queue.add(new TreeElement(root, 0));\\n        \\n        while(queue.size() != 0) {\\n            TreeElement currentElement = queue.poll();\\n            if(currentElement.node == null) continue;\\n            \\n            int newSum = currentElement.getSum() + currentElement.node.val;\\n            if(currentElement.isLeaf() && newSum == targetSum) {\\n                return true;\\n            }\\n            \\n            if(currentElement.node.right != null) {\\n                queue.add(new TreeElement(currentElement.node.right, newSum));\\n            }\\n            if(currentElement.node.left != null) {\\n                queue.add(new TreeElement(currentElement.node.left, newSum));\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658790,
                "title": "c-recursion-with-explanation-4-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool root_to_leaf(TreeNode* root, int Sum){\\n        \\n        // root reaches NULL that means we didn\\'t find any path root-to-leaf that add up to sum because if there is any we return from line number \\'24\\'\\n        if(root==NULL)return false;\\n        \\n        // because we reach some root value so remaining target sum is sum-root_value\\n        Sum=Sum-root->val;\\n        \\n        // base case when we reach leaf node && Sum becomes \\'0\\' specify that we find a path THEREFORE return true\\n        if(root->left==NULL and root->right==NULL and Sum==0)return true;\\n        \\n        // recursive call to LEFT subtree of root && RIGHT subtree of root using or because \\n        // if any one of them return true we found a path so return true  && if both of them return false we didn\\'t found any path so return false\\n        // true or true => true || true or false => true || false or true => true || false or false => false \\n        return root_to_leaf(root->left,Sum) or root_to_leaf(root->right,Sum);\\n    }\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        \\n        // EDGE case when tree is empty because there are no root-to-leaf paths THRERFORE return false\\n        if(root==NULL)return false;\\n        \\n        // function call to check if there exist a path root-to-leaf such that adding up values along the path == targetSum\\n        return root_to_leaf(root,targetSum);\\n    }\\n};\\n```\\n\\n```\\nTIME COMPLEXITY \\nO(N) as we have to visit every node until we find a root-to-leaf path of sum = target sum \\n\\nSPACE COMPLEXITY \\nO(LOGN) recursion stack space as we go as depth as height of tree\\n\\nN=Total Number of Nodes in Tree",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool root_to_leaf(TreeNode* root, int Sum){\\n        \\n        // root reaches NULL that means we didn\\'t find any path root-to-leaf that add up to sum because if there is any we return from line number \\'24\\'\\n        if(root==NULL)return false;\\n        \\n        // because we reach some root value so remaining target sum is sum-root_value\\n        Sum=Sum-root->val;\\n        \\n        // base case when we reach leaf node && Sum becomes \\'0\\' specify that we find a path THEREFORE return true\\n        if(root->left==NULL and root->right==NULL and Sum==0)return true;\\n        \\n        // recursive call to LEFT subtree of root && RIGHT subtree of root using or because \\n        // if any one of them return true we found a path so return true  && if both of them return false we didn\\'t found any path so return false\\n        // true or true => true || true or false => true || false or true => true || false or false => false \\n        return root_to_leaf(root->left,Sum) or root_to_leaf(root->right,Sum);\\n    }\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        \\n        // EDGE case when tree is empty because there are no root-to-leaf paths THRERFORE return false\\n        if(root==NULL)return false;\\n        \\n        // function call to check if there exist a path root-to-leaf such that adding up values along the path == targetSum\\n        return root_to_leaf(root,targetSum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2657629,
                "title": "python-3-7-lines-recursion-t-m-94-56",
                "content": "```\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:\\n        \\n        if not root :                                               # if null node\\n            return False                                            # return False\\n    \\n        if (not root.right and not root.left                        # if target hit on leaf, \\n            and root.val == targetSum):                             # return True\\n            return True\\n        \\n        return (self.hasPathSum(root.left ,targetSum-root.val) or   # traverse left  subtree\\n                self.hasPathSum(root.right,targetSum-root.val))     # traverse right subtree  \\n```\\n[https://leetcode.com/submissions/detail/603749417/](http://)",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:\\n        \\n        if not root :                                               # if null node\\n            return False                                            # return False\\n    \\n        if (not root.right and not root.left                        # if target hit on leaf, \\n            and root.val == targetSum):                             # return True\\n            return True\\n        \\n        return (self.hasPathSum(root.left ,targetSum-root.val) or   # traverse left  subtree\\n                self.hasPathSum(root.right,targetSum-root.val))     # traverse right subtree  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2580206,
                "title": "accepted-recursive-solution",
                "content": "```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root == null)\\n            return false;\\n        \\n        if(root.left==null && root.right==null && targetSum -root.val ==0)\\n            return true;\\n        \\n        \\n        return hasPathSum(root.left, targetSum -root.val) || hasPathSum(root.right, targetSum -root.val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root == null)\\n            return false;\\n        \\n        if(root.left==null && root.right==null && targetSum -root.val ==0)\\n            return true;\\n        \\n        \\n        return hasPathSum(root.left, targetSum -root.val) || hasPathSum(root.right, targetSum -root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1688756,
                "title": "recursive-iterative-and-morris-traversal-solutions-in-python",
                "content": "## Approach 1. recursive\\n---\\n##### Time complexity: O(n)\\n##### Space complexity: O(n)\\n```python\\nclass Solution:\\n    def hasPathSum(self, root: Optiona[TreeNode], targetSum: int) -> bool:\\n        if root == None:\\n            return False\\n\\n        if root.left == None and root.right == None:\\n            return targetSum == root.val\\n\\n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\\n```\\n## Approach 2. iterative\\n---\\n##### Time complexity: O(n)\\n##### Space complexity: O(n)\\n```python\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if root == None:\\n            return False\\n\\n        stack = [(root, targetSum - root.val)]\\n\\n        while len(stack) > 0:\\n            node, remainder = stack.pop()\\n\\n            if node.left == None and node.right == None and remainder == 0:\\n                return True\\n\\n            if node.left != None:\\n                stack.append((node.left, remainder - node.left.val))\\n\\n            if node.right != None:\\n                stack.append((node.right, remainder - node.right.val))\\n\\n        return False\\n```\\n## Approach 3. Morris traversal\\n---\\n##### Time complexity: O(n)\\n##### Space complexity: O(1)\\n\\nThis solution is thanks to [ayuanx](https://leetcode.com/problems/path-sum/discuss/36435/C%2B%2B-Non-recursive-O(1)-space-solution-based-on-Morris-Traversal). The intuition behind it is that we keep track of the path sum so far while we traverse down the tree, where `m` is updated when we move the root pointer down the tree, and `n` is updated when we\\'re setting up successor relationships / [threading the tree](https://en.wikipedia.org/wiki/Threaded_binary_tree). When we\\'re about to explore a different path, we subtract the current path\\'s sum `n` from the total path sum `m`.\\n\\n```python\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        m = 0\\n\\n        while root != None:\\n            if root.left == None:\\n                m += root.val\\n                root = root.right\\n\\n                if root == None and m == targetSum:\\n                    return True\\n            else:\\n                prev = root.left\\n                n = prev.val\\n\\n                while prev.right != None and prev.right != root:\\n                    prev = prev.right\\n                    n += prev.val\\n\\n                if prev.right == None:\\n                    m += root.val\\n                    prev.right = root\\n\\n                    if prev.left == None and m + n == targetSum:\\n                        return True\\n\\n                    root = root.left\\n                else:\\n                    prev.right = None\\n                    root = root.right\\n                    m -= n\\n\\n        return False\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```python\\nclass Solution:\\n    def hasPathSum(self, root: Optiona[TreeNode], targetSum: int) -> bool:\\n        if root == None:\\n            return False\\n\\n        if root.left == None and root.right == None:\\n            return targetSum == root.val\\n\\n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\\n```\n```python\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if root == None:\\n            return False\\n\\n        stack = [(root, targetSum - root.val)]\\n\\n        while len(stack) > 0:\\n            node, remainder = stack.pop()\\n\\n            if node.left == None and node.right == None and remainder == 0:\\n                return True\\n\\n            if node.left != None:\\n                stack.append((node.left, remainder - node.left.val))\\n\\n            if node.right != None:\\n                stack.append((node.right, remainder - node.right.val))\\n\\n        return False\\n```\n```python\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        m = 0\\n\\n        while root != None:\\n            if root.left == None:\\n                m += root.val\\n                root = root.right\\n\\n                if root == None and m == targetSum:\\n                    return True\\n            else:\\n                prev = root.left\\n                n = prev.val\\n\\n                while prev.right != None and prev.right != root:\\n                    prev = prev.right\\n                    n += prev.val\\n\\n                if prev.right == None:\\n                    m += root.val\\n                    prev.right = root\\n\\n                    if prev.left == None and m + n == targetSum:\\n                        return True\\n\\n                    root = root.left\\n                else:\\n                    prev.right = None\\n                    root = root.right\\n                    m -= n\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 896271,
                "title": "simple-recursive-python-3",
                "content": "Algorithm:\\n* decrement the sum as you recurse down the binary tree\\n* if you are at a leaf node, check if `sum == 0`\\n\\n```\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n        if not root:\\n            return False\\n\\n        sum -= root.val\\n        \\n        #only check sum if it is a leaf node\\n        if root.left == None and root.right == None:\\n            if sum == 0:\\n                return True\\n            return False\\n\\n        return self.hasPathSum(root.left, sum) or self.hasPathSum(root.right, sum)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n        if not root:\\n            return False\\n\\n        sum -= root.val\\n        \\n        #only check sum if it is a leaf node\\n        if root.left == None and root.right == None:\\n            if sum == 0:\\n                return True\\n            return False\\n\\n        return self.hasPathSum(root.left, sum) or self.hasPathSum(root.right, sum)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 286472,
                "title": "c-dfs",
                "content": "```\\npublic class Solution {\\n    public bool HasPathSum(TreeNode root, int sum) {\\n        if (root == null) return false;\\n        if (root.left == null && root.right == null && sum == root.val) {\\n            return true;\\n        }\\n\\n        return HasPathSum(root.left, sum - root.val) || HasPathSum(root.right, sum - root.val);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool HasPathSum(TreeNode root, int sum) {\\n        if (root == null) return false;\\n        if (root.left == null && root.right == null && sum == root.val) {\\n            return true;\\n        }\\n\\n        return HasPathSum(root.left, sum - root.val) || HasPathSum(root.right, sum - root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 144669,
                "title": "my-swift-solution",
                "content": "\\tfunc hasPathSum(_ root: TreeNode?, _ sum: Int) -> Bool {\\n        guard let root = root else {\\n            return false\\n        }\\n        \\n        if root.left == nil && root.right == nil {\\n            return root.val == sum\\n        }\\n        \\n        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val)\\n    }",
                "solutionTags": [],
                "code": "\\tfunc hasPathSum(_ root: TreeNode?, _ sum: Int) -> Bool {\\n        guard let root = root else {\\n            return false\\n        }\\n        \\n        if root.left == nil && root.right == nil {\\n            return root.val == sum\\n        }\\n        \\n        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val)\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 36438,
                "title": "simple-python-solution-3-lines",
                "content": "```\\ndef hasPathSum(self, root, sum):\\n        if root == None:return False\\n        if root.val - sum == 0 and root.left == None and root.right == None:return True\\n        return self.hasPathSum(root.left, sum-root.val) or self.hasPathSum(root.right, sum-root.val)",
                "solutionTags": [],
                "code": "```\\ndef hasPathSum(self, root, sum):\\n        if root == None:return False\\n        if root.val - sum == 0 and root.left == None and root.right == None:return True\\n        return self.hasPathSum(root.left, sum-root.val) or self.hasPathSum(root.right, sum-root.val)",
                "codeTag": "Python3"
            },
            {
                "id": 36505,
                "title": "java-recursive-solution-with-comments",
                "content": "    public boolean hasPathSum(TreeNode root, int sum) {\\n     \\n     // empty tree\\n     if (root == null)\\n        return false;\\n    \\n     // leaf node, check sum\\n    if (root.left == null && root.right == null) {\\n      if(sum == root.val)\\n        return true;\\n      else \\n        return false;\\n    } \\n    \\n    // at least one sub tree is not null, check if either one has path sum\\n    return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n     \\n        \\n    }",
                "solutionTags": [],
                "code": "    public boolean hasPathSum(TreeNode root, int sum) {\\n     \\n     // empty tree\\n     if (root == null)\\n        return false;\\n    \\n     // leaf node, check sum\\n    if (root.left == null && root.right == null) {\\n      if(sum == root.val)\\n        return true;\\n      else \\n        return false;\\n    } \\n    \\n    // at least one sub tree is not null, check if either one has path sum\\n    return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n     \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 36500,
                "title": "recommend-for-beginners-recursive-non-recursive-c-implementation-with-detailed-explaination",
                "content": "    class Solution {\\n    public:\\n        /*** recursive solution  ***/\\n        bool hasPathSum(TreeNode* root, int sum) {\\n            if(root==NULL)  return false;\\n            if(root->left==NULL && root->right==NULL)   return sum==root->val;\\n            return hasPathSum(root->left, sum-root->val) || hasPathSum(root->right, sum-root->val);\\n        }\\n        \\n        /*** level-bfs-iterative solution  ***/\\n        bool hasPathSum(TreeNode* root, int sum){\\n            if(root==NULL)  return false;\\n            \\n            queue<TreeNode*> q;\\n            q.push(root);\\n            while(q.size()>0){\\n                TreeNode* node=q.front();\\n                q.pop();\\n                if(node->left==NULL && node->right==NULL){\\n                    if(node->val==sum)  return true;\\n                }\\n                if(node->left){\\n                    node->left->val+=node->val;\\n                    q.push(node->left);\\n                }\\n                if(node->right){\\n                    node->right->val+=node->val;\\n                    q.push(node->right);\\n                }\\n            }\\n            return false;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        /*** recursive solution  ***/\\n        bool hasPathSum(TreeNode* root, int sum) {\\n            if(root==NULL)  return false;\\n            if(root->left==NULL && root->right==NULL)   return sum==root->val;\\n            return hasPathSum(root->left, sum-root->val) || hasPathSum(root->right, sum-root->val);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 36510,
                "title": "1ms-3-lines-java-recursion-solution",
                "content": "    public class Solution {\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if(root == null) return false;\\n        if(root.val == sum && root.left == null && root.right == null) return true;\\n        return hasPathSum(root.left, sum-root.val) || hasPathSum(root.right, sum-root.val);\\n    }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if(root == null) return false;\\n        if(root.val == sum && root.left == null && root.right == null) return true;\\n        return hasPathSum(root.left, sum-root.val) || hasPathSum(root.right, sum-root.val);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 36554,
                "title": "3-line-java-recursive-solution",
                "content": "    public boolean hasPathSum(TreeNode root, int sum) {\\n            if(root == null) return false;\\n            if(root.right==null && root.left == null && root.val == sum) return true;\\n            return hasPathSum(root.left,sum-root.val) || hasPathSum(root.right,sum-root.val);\\n    }",
                "solutionTags": [],
                "code": "    public boolean hasPathSum(TreeNode root, int sum) {\\n            if(root == null) return false;\\n            if(root.right==null && root.left == null && root.val == sum) return true;\\n            return hasPathSum(root.left,sum-root.val) || hasPathSum(root.right,sum-root.val);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 36638,
                "title": "super-easy-3-lines-java-solution",
                "content": "I believe this is the easiest approach. Let me know if you can improve it.\\n\\n    public class Solution {\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if(root == null) return false;\\n        \\n        if(root.left == null && root.right == null && sum - root.val == 0 ) return true;\\n        \\n        return hasPathSum(root.left,sum - root.val)||hasPathSum(root.right,sum - root.val);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if(root == null) return false;\\n        \\n        if(root.left == null && root.right == null && sum - root.val == 0 ) return true;\\n        \\n        return hasPathSum(root.left,sum - root.val)||hasPathSum(root.right,sum - root.val);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 4087878,
                "title": "best-o-n-solution",
                "content": "# Approach\\nDFS Traversal\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool traversal(TreeNode* root, int curSum, int targetSum) {\\n        if (!root->left && !root->right) {\\n            if (targetSum == (curSum + root->val))\\n                return true;\\n            return false;    \\n        }\\n        if (root->left) {\\n            if (traversal(root->left, curSum + root->val, targetSum))\\n                return true;\\n        }\\n        if (root->right) {\\n            if (traversal(root->right, curSum + root->val, targetSum))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        int curSum = 0;\\n        if (!root)\\n            return false;\\n        return traversal(root, curSum, targetSum);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool traversal(TreeNode* root, int curSum, int targetSum) {\\n        if (!root->left && !root->right) {\\n            if (targetSum == (curSum + root->val))\\n                return true;\\n            return false;    \\n        }\\n        if (root->left) {\\n            if (traversal(root->left, curSum + root->val, targetSum))\\n                return true;\\n        }\\n        if (root->right) {\\n            if (traversal(root->right, curSum + root->val, targetSum))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        int curSum = 0;\\n        if (!root)\\n            return false;\\n        return traversal(root, curSum, targetSum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609573,
                "title": "path-sum-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code defines a method called hasPathSum that takes two parameters: a root node of a binary tree and a target sum. The method returns true if there is a path from the root to a leaf node that adds up to the target sum, and false otherwise.\\n\\nThe method uses recursion to check every possible path in the tree. It first checks if the root node is null, which means the tree is empty. In that case, it returns false. Then it checks if the root node is a leaf node, which means it has no children. In that case, it subtracts the root node\\u2019s value from the target sum and compares it to zero. If they are equal, it means the path sum equals the target sum, so it returns true. Otherwise, it returns false.\\n\\nIf the root node is not a leaf node, it recursively calls itself on the left and right subtrees of the root node, with the updated target sum (target sum minus root node\\u2019s value). It returns true if either of the recursive calls returns true, or false if both of them return false. This way, it explores all possible paths in the tree and returns true if any of them matches the target sum.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(h)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root == null){\\n            return false;\\n        }\\n        if(root.left == null && root.right == null){\\n            if((targetSum - root.val) == 0){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n        return hasPathSum(root.left,(targetSum - root.val)) || hasPathSum(root.right,(targetSum - root.val));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root == null){\\n            return false;\\n        }\\n        if(root.left == null && root.right == null){\\n            if((targetSum - root.val) == 0){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n        return hasPathSum(root.left,(targetSum - root.val)) || hasPathSum(root.right,(targetSum - root.val));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445571,
                "title": "simple-c-solution",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL){\\n            return false;\\n        }\\n        if(root->left==NULL && root->right==NULL){\\n            return targetSum==root->val;\\n        }\\n        return hasPathSum(root->left,targetSum-root->val) || hasPathSum(root->right,targetSum-root->val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL){\\n            return false;\\n        }\\n        if(root->left==NULL && root->right==NULL){\\n            return targetSum==root->val;\\n        }\\n        return hasPathSum(root->left,targetSum-root->val) || hasPathSum(root->right,targetSum-root->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294299,
                "title": "python3-100-fast-easiest-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Usig DFS**\\n![image.png](https://assets.leetcode.com/users/images/58b332db-48fa-497b-8543-4275b77fc517_1678764586.376835.png)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- use dfs to get till leaf node.\\n- while traversing keep track of current sum.\\n- now when encountered leaf node check current sum and target sum, return true if equal else false.\\n- now we will also keep track of left and right returned values, if we find that from left subtree we\\'re getting answer then we will not traverse right sub-tree.\\n- this will help in redusing time by 50%.\\n- return answer found\\n# Complexity\\n- Time complexity: O(N/2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N/2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        def dfs_sum(curr=None, sumTill=0):\\n            if curr:\\n                sumTill += curr.val\\n                left = dfs_sum(curr.left, sumTill)\\n                right = False\\n                if not left:\\n                    right = dfs_sum(curr.right, sumTill)\\n                \\n                if curr.left == None and curr.right == None:\\n                    return sumTill == targetSum\\n                return left or right\\n            return False\\n        return dfs_sum(root)\\n```\\n # Please like and comment below ( \\u0361\\uD83D\\uDC41\\uFE0F\\u202F\\u035C\\u0296 \\u0361\\uD83D\\uDC41\\uFE0F)\\uD83D\\uDC4C",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        def dfs_sum(curr=None, sumTill=0):\\n            if curr:\\n                sumTill += curr.val\\n                left = dfs_sum(curr.left, sumTill)\\n                right = False\\n                if not left:\\n                    right = dfs_sum(curr.right, sumTill)\\n                \\n                if curr.left == None and curr.right == None:\\n                    return sumTill == targetSum\\n                return left or right\\n            return False\\n        return dfs_sum(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3193893,
                "title": "python-recursive-code-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if root is None:\\n            return False\\n        if root.left is None and root.right is None and targetSum - root.val == 0:\\n            return True\\n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if root is None:\\n            return False\\n        if root.left is None and root.right is None and targetSum - root.val == 0:\\n            return True\\n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996017,
                "title": "1ms-java-recursive-solution-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root==null){\\n            return false;\\n        }\\n        if(root.left==null && root.right==null && targetSum==root.val){\\n            return true;\\n        }\\n\\n        return hasPathSum(root.left,targetSum-root.val) || hasPathSum(root.right,targetSum-root.val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root==null){\\n            return false;\\n        }\\n        if(root.left==null && root.right==null && targetSum==root.val){\\n            return true;\\n        }\\n\\n        return hasPathSum(root.left,targetSum-root.val) || hasPathSum(root.right,targetSum-root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830351,
                "title": "java-dfs",
                "content": "If you like it pls upvote\\n```\\n\\n\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root==null)  return false;\\n\\n        Deque<TreeNode> stack = new ArrayDeque<>();\\n        stack.push(root);\\n\\n        while(!stack.isEmpty()) {\\n            TreeNode curr = stack.pop();\\n\\n            if(curr.val == targetSum && curr.left==null && curr.right==null) {\\n                return true;\\n            }\\n\\n            if(curr.left!=null) {\\n                curr.left.val += curr.val;\\n                stack.push(curr.left);\\n            }\\n\\n            if(curr.right!=null) {\\n                curr.right.val += curr.val;\\n                stack.push(curr.right);\\n            }\\n        }\\n        return false;\\n    }\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n\\n\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root==null)  return false;\\n\\n        Deque<TreeNode> stack = new ArrayDeque<>();\\n        stack.push(root);\\n\\n        while(!stack.isEmpty()) {\\n            TreeNode curr = stack.pop();\\n\\n            if(curr.val == targetSum && curr.left==null && curr.right==null) {\\n                return true;\\n            }\\n\\n            if(curr.left!=null) {\\n                curr.left.val += curr.val;\\n                stack.push(curr.left);\\n            }\\n\\n            if(curr.right!=null) {\\n                curr.right.val += curr.val;\\n                stack.push(curr.right);\\n            }\\n        }\\n        return false;\\n    }\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2765268,
                "title": "tree-traversal",
                "content": "```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        \\n        ans = [False]\\n        \\n        def tree_traversal(root, curr_sum, ans):\\n            curr_sum += root.val\\n    \\n            if root.left is None and root.right is None:\\n                if curr_sum == targetSum:\\n                    ans[0] = True\\n\\n            \\n            if root.left:\\n                tree_traversal(root.left, curr_sum, ans)\\n            \\n            if root.right:\\n                tree_traversal(root.right, curr_sum, ans)\\n        \\n        if root:\\n            tree_traversal(root, 0, ans)\\n        return ans[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        \\n        ans = [False]\\n        \\n        def tree_traversal(root, curr_sum, ans):\\n            curr_sum += root.val\\n    \\n            if root.left is None and root.right is None:\\n                if curr_sum == targetSum:\\n                    ans[0] = True\\n\\n            \\n            if root.left:\\n                tree_traversal(root.left, curr_sum, ans)\\n            \\n            if root.right:\\n                tree_traversal(root.right, curr_sum, ans)\\n        \\n        if root:\\n            tree_traversal(root, 0, ans)\\n        return ans[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765163,
                "title": "one-lineeer",
                "content": "```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        return (root.val == targetSum) if (root and not root.left and not root.right) else (root and (self.hasPathSum(root.right, targetSum - root.val) or self.hasPathSum(root.left, targetSum - root.val)))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        return (root.val == targetSum) if (root and not root.left and not root.right) else (root and (self.hasPathSum(root.right, targetSum - root.val) or self.hasPathSum(root.left, targetSum - root.val)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687829,
                "title": "java-recursive-easy-to-understand-100-faster",
                "content": "```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        traversal(root,targetSum);\\n        return res;\\n    }\\n    boolean res = false;\\n    public void traversal(TreeNode root, int targetSum) {\\n        if(root != null) {\\n            root.val = targetSum-root.val;\\n            if(root.left == null && root.right == null && root.val == 0) {\\n                res = true;\\n                return;\\n            }\\n            traversal(root.left, root.val);\\n            traversal(root.right, root.val);\\n        }\\n    }\\n}\\n```\\n\\nIf you like the solution please do upvote, Thanks in advance.",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        traversal(root,targetSum);\\n        return res;\\n    }\\n    boolean res = false;\\n    public void traversal(TreeNode root, int targetSum) {\\n        if(root != null) {\\n            root.val = targetSum-root.val;\\n            if(root.left == null && root.right == null && root.val == 0) {\\n                res = true;\\n                return;\\n            }\\n            traversal(root.left, root.val);\\n            traversal(root.right, root.val);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658684,
                "title": "root-path-sum",
                "content": "bool hasPathSum(TreeNode* root, int sum) {\\n      if(root == nullptr) return false;\\nif(root->val == sum && root->right == nullptr && root->left == nullptr) return true;\\nif(root->left != nullptr) root->left->val += root->val;\\nif(root->right != nullptr) root->right->val += root->val;\\nreturn hasPathSum(root->left,sum) || hasPathSum(root->right,sum);\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "bool hasPathSum(TreeNode* root, int sum) {\\n      if(root == nullptr) return false;\\nif(root->val == sum && root->right == nullptr && root->left == nullptr) return true;\\nif(root->left != nullptr) root->left->val += root->val;\\nif(root->right != nullptr) root->right->val += root->val;\\nreturn hasPathSum(root->left,sum) || hasPathSum(root->right,sum);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2658505,
                "title": "112-path-sum-python",
                "content": "Python:\\n```\\n    def hasPathSum(self, root, sum):\\n        if not root:\\n            return False\\n        if not root.left and not root.right and root.val == sum:\\n            return True\\n        sum -= root.val\\n        return self.hasPathSum(root.left, sum) or self.hasPathSum(root.right, sum)\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n    def hasPathSum(self, root, sum):\\n        if not root:\\n            return False\\n        if not root.left and not root.right and root.val == sum:\\n            return True\\n        sum -= root.val\\n        return self.hasPathSum(root.left, sum) or self.hasPathSum(root.right, sum)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2657607,
                "title": "daily-leetcode-solution-easy-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool preOrderTraversal(TreeNode* root,int targetSum)\\n    {\\n        if(root==NULL) return false;\\n        if(root->right==NULL&&root->left==NULL)\\n        {\\n            if(root->val==targetSum) return true;\\n        }\\n        bool left=preOrderTraversal(root->left,targetSum-(root->val));\\n        bool right=preOrderTraversal(root->right,targetSum-(root->val));\\n        return left|right;\\n    }\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        return preOrderTraversal(root,targetSum);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool preOrderTraversal(TreeNode* root,int targetSum)\\n    {\\n        if(root==NULL) return false;\\n        if(root->right==NULL&&root->left==NULL)\\n        {\\n            if(root->val==targetSum) return true;\\n        }\\n        bool left=preOrderTraversal(root->left,targetSum-(root->val));\\n        bool right=preOrderTraversal(root->right,targetSum-(root->val));\\n        return left|right;\\n    }\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        return preOrderTraversal(root,targetSum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2657586,
                "title": "daily-leetcoding-challenge-october-day-4",
                "content": "This problem is the Daily LeetCoding Challenge for October, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/path-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iterations\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/path-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2537117,
                "title": "javascript-dfs-with-comments",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number} targetSum\\n * @return {boolean}\\n */\\nconst hasPathSum = (root, targetSum) => {\\n    // DFS\\n    // Relatively easy to understand\\n    if(!root) return false; // Base case if we DFS all the way to the end, but dont find an answer\\n    \\n    // Condition if true\\n    // Since we substract the node value from the targetSum as we DFS\\n    // If we get to a node with no left or right AND the node.val === targetSum, we found an answer\\n\\t// Because if node.val === targetSum, that means if we subtract the two, it is 0\\n    if(!root.left && !root.right && targetSum === root.val) return true;\\n    \\n    // We just need to find 1, so if either side returns true, it is true\\n    return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number} targetSum\\n * @return {boolean}\\n */\\nconst hasPathSum = (root, targetSum) => {\\n    // DFS\\n    // Relatively easy to understand\\n    if(!root) return false; // Base case if we DFS all the way to the end, but dont find an answer\\n    \\n    // Condition if true\\n    // Since we substract the node value from the targetSum as we DFS\\n    // If we get to a node with no left or right AND the node.val === targetSum, we found an answer\\n\\t// Because if node.val === targetSum, that means if we subtract the two, it is 0\\n    if(!root.left && !root.right && targetSum === root.val) return true;\\n    \\n    // We just need to find 1, so if either side returns true, it is true\\n    return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2379258,
                "title": "accepted-dfs-iterative-java",
                "content": "```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root==null)  return false;\\n        \\n        Deque<TreeNode> stack = new ArrayDeque<TreeNode>();\\n        stack.push(root);\\n        \\n        while(!stack.isEmpty()) {\\n            TreeNode curr = stack.pop();\\n            \\n            if(curr.val == targetSum && curr.left==null && curr.right==null)    return true;\\n            \\n            if(curr.left!=null) {\\n                curr.left.val += curr.val;\\n                stack.push(curr.left);\\n            }\\n            \\n            if(curr.right!=null) {\\n                curr.right.val += curr.val;\\n                stack.push(curr.right);\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root==null)  return false;\\n        \\n        Deque<TreeNode> stack = new ArrayDeque<TreeNode>();\\n        stack.push(root);\\n        \\n        while(!stack.isEmpty()) {\\n            TreeNode curr = stack.pop();\\n            \\n            if(curr.val == targetSum && curr.left==null && curr.right==null)    return true;\\n            \\n            if(curr.left!=null) {\\n                curr.left.val += curr.val;\\n                stack.push(curr.left);\\n            }\\n            \\n            if(curr.right!=null) {\\n                curr.right.val += curr.val;\\n                stack.push(curr.right);\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2176648,
                "title": "python3-short-4lines-dfs",
                "content": "```\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n        if not root:\\n            return False\\n        if root.val == sum and not  root.left and not root.right:\\n            return True\\n        return self.hasPathSum(root.left, sum-root.val) or self.hasPathSum(root.right, sum-root.val)\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n        if not root:\\n            return False\\n        if root.val == sum and not  root.left and not root.right:\\n            return True\\n        return self.hasPathSum(root.left, sum-root.val) or self.hasPathSum(root.right, sum-root.val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2013138,
                "title": "c-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root == NULL)\\n            return false;\\n        if(root->left == NULL && root->right == NULL && targetSum  - root->val == 0)\\n            return true;\\n        else\\n            return hasPathSum(root->left, targetSum - root->val) || hasPathSum(root->right, targetSum - root->val) ;\\n       }\\n\\t};\\n\\t\\n\\nTime complexity  --> O(n) \\nspace complexity --> O(log n)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root == NULL)\\n            return false;\\n        if(root->left == NULL && root->right == NULL && targetSum  - root->val == 0)\\n            return true;\\n        else\\n            return hasPathSum(root->left, targetSum - root->val) || hasPathSum(root->right, targetSum - root->val) ;\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 1746355,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root==null)return false;\\n        if(root.left==null &&root.right==null){\\n           return root.val==targetSum;\\n        }\\n        return hasPathSum(root.left,targetSum-root.val)||hasPathSum(root.right,targetSum-root.val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root==null)return false;\\n        if(root.left==null &&root.right==null){\\n           return root.val==targetSum;\\n        }\\n        return hasPathSum(root.left,targetSum-root.val)||hasPathSum(root.right,targetSum-root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1741659,
                "title": "c-fast-solution-dfs-recursive-approach-easy-to-understand",
                "content": "class Solution {\\npublic:\\n\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL)\\n            return false;\\n        else  \\n        if(root->left==NULL && root->right==NULL) {\\n             if(targetSum-root->val==0)\\n                return true;\\n            return false;\\n        }\\n            bool l=hasPathSum(root->left,targetSum-root->val);\\n            bool r=hasPathSum(root->right,targetSum-root->val);\\n     return l || r;\\n    }\\n};",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL)\\n            return false;\\n        else  \\n        if(root->left==NULL && root->right==NULL) {\\n             if(targetSum-root->val==0)\\n                return true;\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1583269,
                "title": "python3-easy-fast-recursive-solution",
                "content": "```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root: return False\\n        if root and not root.left and not root.right: return root.val == targetSum\\n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root: return False\\n        if root and not root.left and not root.right: return root.val == targetSum\\n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1560896,
                "title": "python3-simple-solution-with-explanation",
                "content": "**Idea:**\\nFor every node we visit we add its value to the path_sum, and:\\nIf its a leaf, we check if its `path_sum` is equal to the `targetSum`,\\notherwise, we continue checking with its left and right nodes.\\n\\n**Time complexity:** O(n) where n is the number of nodes in the tree.\\n**Space complexity:** O(h) where h is the height of the tree (in worst case h=n).\\n\\n```\\ndef hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n\\n        def inorder(root, path_sum):\\n            if not root:\\n                return False\\n            \\n            path_sum+=root.val\\n            \\n            if not root.left and not root.right:\\n                return path_sum==targetSum\\n                \\n            return inorder(root.left, path_sum) or inorder(root.right, path_sum)\\n             \\n        return inorder(root, 0)\\n```\\n\\n*Thanx for reading, please **upvote** if it helped you :)*",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n\\n        def inorder(root, path_sum):\\n            if not root:\\n                return False\\n            \\n            path_sum+=root.val\\n            \\n            if not root.left and not root.right:\\n                return path_sum==targetSum\\n                \\n            return inorder(root.left, path_sum) or inorder(root.right, path_sum)\\n             \\n        return inorder(root, 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1522254,
                "title": "simple-to-understand-using-recursion-with-comments",
                "content": "**Thumbs up if you find this helpful** \\uD83D\\uDC4D\\n\\n```\\npublic class Solution {\\n    public bool HasPathSum(TreeNode root, int targetSum) {\\n        return Search(root, targetSum);\\n    }\\n    \\n    public bool Search(TreeNode node, int targetSum) {\\n        if (node == null) {\\n            return false;\\n        }\\n        \\n        // Determine the current sum\\n        targetSum = targetSum - node.val;\\n        \\n        // Since this is a root-to-leaf check, evaluate for the \\n        // success condition when both left and right nodes are null        \\n        if (node.left == null && node.right == null) {\\n            return targetSum == 0;\\n        }\\n        \\n        // Keep exploring along branches finding the target sum\\n        return Search(node.left, targetSum)\\n            || Search(node.right, targetSum);      \\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool HasPathSum(TreeNode root, int targetSum) {\\n        return Search(root, targetSum);\\n    }\\n    \\n    public bool Search(TreeNode node, int targetSum) {\\n        if (node == null) {\\n            return false;\\n        }\\n        \\n        // Determine the current sum\\n        targetSum = targetSum - node.val;\\n        \\n        // Since this is a root-to-leaf check, evaluate for the \\n        // success condition when both left and right nodes are null        \\n        if (node.left == null && node.right == null) {\\n            return targetSum == 0;\\n        }\\n        \\n        // Keep exploring along branches finding the target sum\\n        return Search(node.left, targetSum)\\n            || Search(node.right, targetSum);      \\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1467761,
                "title": "javascript-solution-with-stack",
                "content": "Solving this question with recursion is too simple. Why not implement a stack instead???\\n\\nStrategy: Add node and current total of the path we are traversing into the stack. \\n\\t\\t\\t\\tKeep track of where we are in the tree using a variable called curr\\n\\t\\t\\t\\tWhen we have no left or right children, we check to see if value in the path is equal to target value.\\n```\\nvar hasPathSum = function(root, targetSum) {\\n//check to see if we are given an empty tree\\n    if (!root)return false\\n    const stack =[]\\n\\t\\n\\t//in our current variable, we will keep track of the tree in 0th index, and keep current sum of path at 1st index\\n     let curr=[root,0]\\n\\t \\n\\t /* our stop conditions for while loop are:\\n\\t 1.) when we have no elements in the stack\\n\\t 2.) since our stack is initially empty, we will add in when curr is null as a stop condition */\\n\\n    while (curr || stack.length){\\n\\t/* we want to keep adding to our stack while traversing left. We will stop when we add a null child to our\\n\\tstack, since that means we are at the leftmost child of current subtree*/\\n       while (curr && curr[0]){\\n           let [node,val]=curr\\n           stack.push([node,val+node.val])\\n           curr=[node.left,val+node.val]\\n       }\\n\\t   /*because curr has an empty child, that means we have went 1 level too far in the tree, in order\\n\\t   to get our last node that had a value in the tree, we just pop off the last item in the stack*/\\n          curr=stack.pop()\\n\\n   /* we need to figure out if the node we are currently at-which we know has no left children, is a leaf,\\n   meaning it has no right children as well. So we set a variable rightNode as either the right node, or null */\\n        let rightNode= curr[0]? curr[0].right :null\\n        if (rightNode === null){\\n\\t\\t/*we need to ensure we are at a leaf, and if we are, we will see if current path sum is equal to target */\\n            if(curr[0].left===null && curr[1]===targetSum){\\n                return true\\n            }\\n\\t\\t\\t/*since we are at a leaf node, we cannot traverse any further, we will instead set curr to null so that\\n\\t\\t\\twe bypass the inner while loop and pop off the stack to previous node */\\n\\t\\t\\tcurr=null\\n        } else {\\n\\t\\t//since we do have a right node, we want to traverse down to the bottom of the graph before checking sum\\n            curr=[rightNode, curr[1]]        \\n        }   \\n\\t\\t\\n    } return false \\n}",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "Solving this question with recursion is too simple. Why not implement a stack instead???\\n\\nStrategy: Add node and current total of the path we are traversing into the stack. \\n\\t\\t\\t\\tKeep track of where we are in the tree using a variable called curr\\n\\t\\t\\t\\tWhen we have no left or right children, we check to see if value in the path is equal to target value.\\n```\\nvar hasPathSum = function(root, targetSum) {\\n//check to see if we are given an empty tree\\n    if (!root)return false\\n    const stack =[]\\n\\t\\n\\t//in our current variable, we will keep track of the tree in 0th index, and keep current sum of path at 1st index\\n     let curr=[root,0]\\n\\t \\n\\t /* our stop conditions for while loop are:\\n\\t 1.) when we have no elements in the stack\\n\\t 2.) since our stack is initially empty, we will add in when curr is null as a stop condition */\\n\\n    while (curr || stack.length){\\n\\t/* we want to keep adding to our stack while traversing left. We will stop when we add a null child to our\\n\\tstack, since that means we are at the leftmost child of current subtree*/\\n       while (curr && curr[0]){\\n           let [node,val]=curr\\n           stack.push([node,val+node.val])\\n           curr=[node.left,val+node.val]\\n       }\\n\\t   /*because curr has an empty child, that means we have went 1 level too far in the tree, in order\\n\\t   to get our last node that had a value in the tree, we just pop off the last item in the stack*/\\n          curr=stack.pop()\\n\\n   /* we need to figure out if the node we are currently at-which we know has no left children, is a leaf,\\n   meaning it has no right children as well. So we set a variable rightNode as either the right node, or null */\\n        let rightNode= curr[0]? curr[0].right :null\\n        if (rightNode === null){\\n\\t\\t/*we need to ensure we are at a leaf, and if we are, we will see if current path sum is equal to target */\\n            if(curr[0].left===null && curr[1]===targetSum){\\n                return true\\n            }\\n\\t\\t\\t/*since we are at a leaf node, we cannot traverse any further, we will instead set curr to null so that\\n\\t\\t\\twe bypass the inner while loop and pop off the stack to previous node */\\n\\t\\t\\tcurr=null\\n        } else {\\n\\t\\t//since we do have a right node, we want to traverse down to the bottom of the graph before checking sum\\n            curr=[rightNode, curr[1]]        \\n        }   \\n\\t\\t\\n    } return false \\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1377783,
                "title": "c-short-and-easy-recursion",
                "content": "**If you liked this solution, Please Upvote. Thanks**\\n\\n```\\n\\tbool hasPathSum(TreeNode* root, int sum) {\\n        if(root==nullptr) return false;\\n        if(root->left==nullptr and root->right==nullptr)\\n            if(sum==root->val) return true;\\n        return hasPathSum(root->left,sum-(root->val)) or hasPathSum(root->right,sum-(root->val));\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tbool hasPathSum(TreeNode* root, int sum) {\\n        if(root==nullptr) return false;\\n        if(root->left==nullptr and root->right==nullptr)\\n            if(sum==root->val) return true;\\n        return hasPathSum(root->left,sum-(root->val)) or hasPathSum(root->right,sum-(root->val));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1313180,
                "title": "easy-python-solution-98-77",
                "content": "Runtime: 32 ms, faster than 98.77% of Python3 online submissions for Path Sum.\\nMemory Usage: 15.7 MB, less than 92.65% of Python3 online submissions for Path Sum.\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:\\n        def h(node,ans):\\n            if(node):\\n                ans-=node.val\\n            else:\\n                return None\\n            if(ans==0 and (node.left==node.right==None)):\\n                return True\\n            else:\\n                return h(node.left,ans) or h(node.right,ans)\\n        return h(root,targetSum)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Runtime: 32 ms, faster than 98.77% of Python3 online submissions for Path Sum.\\nMemory Usage: 15.7 MB, less than 92.65% of Python3 online submissions for Path Sum.\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:\\n        def h(node,ans):\\n            if(node):\\n                ans-=node.val\\n            else:\\n                return None\\n            if(ans==0 and (node.left==node.right==None)):\\n                return True\\n            else:\\n                return h(node.left,ans) or h(node.right,ans)\\n        return h(root,targetSum)",
                "codeTag": "Java"
            },
            {
                "id": 1062745,
                "title": "c-simple-recursive-solution-faster-then-95",
                "content": "```\\nbool hasPathSum(struct TreeNode* root, int targetSum){\\n    if (root == NULL) return false;\\n    \\n    // root node is a leaf\\n    if(root->left == NULL && root->right== NULL){\\n        if(root->val == targetSum){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n    return ((hasPathSum(root->left,targetSum - root->val))||\\n            (hasPathSum(root->right,targetSum - root->val)));\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nbool hasPathSum(struct TreeNode* root, int targetSum){\\n    if (root == NULL) return false;\\n    \\n    // root node is a leaf\\n    if(root->left == NULL && root->right== NULL){\\n        if(root->val == targetSum){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n    return ((hasPathSum(root->left,targetSum - root->val))||\\n            (hasPathSum(root->right,targetSum - root->val)));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1039799,
                "title": "elegant-recursive-java-solution",
                "content": "\\n```\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) return false;\\n        if (root.val == targetSum && root.left == null && root.right == null) return true;\\n        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) return false;\\n        if (root.val == targetSum && root.left == null && root.right == null) return true;\\n        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 779553,
                "title": "c-recursion-fast-then-94-of-solution-easy-to-understand",
                "content": "**Please UP Vote this solution if you like**\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n\\n    bool dfs(TreeNode *root,int sum)\\n    {\\n        if(!root)\\n            return 0;\\n        \\n        if(root->left==NULL && root->right==NULL && sum-root->val==0)// If this is a leaf node and sum-leafNodeValue==0 return True;\\n            return 1;\\n        \\n        return dfs(root->left,sum-root->val) || dfs(root->right,sum-root->val);//If left or right sub tree satisfy the condition the return true\\n    }\\n    \\n    bool hasPathSum(TreeNode* root, int sum) {\\n        return dfs(root,sum);\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool dfs(TreeNode *root,int sum)\\n    {\\n        if(!root)\\n            return 0;\\n        \\n        if(root->left==NULL && root->right==NULL && sum-root->val==0)// If this is a leaf node and sum-leafNodeValue==0 return True;\\n            return 1;\\n        \\n        return dfs(root->left,sum-root->val) || dfs(root->right,sum-root->val);//If left or right sub tree satisfy the condition the return true\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 689922,
                "title": "simple-iterative-solution-c",
                "content": "Iterative Solution\\n```\\n    bool hasPathSum(TreeNode* root, int sum) {\\n        vector<TreeNode*> my_stack;\\n        my_stack.emplace_back(root);\\n        while(!my_stack.empty()){\\n            root = my_stack.back();\\n            my_stack.pop_back();\\n            if(root){\\n                if(!root->left&&!root->right&&root->val==sum) return true; //check terminating condition only at leaf node \\n                if(root->right){\\n                    root->right->val += root->val;\\n                    my_stack.emplace_back(root->right);\\n                }  \\n                if(root->left){\\n                    root->left->val += root->val;\\n                    my_stack.emplace_back(root->left);\\n                }  \\n            }\\n            \\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```\\n    bool hasPathSum(TreeNode* root, int sum) {\\n        vector<TreeNode*> my_stack;\\n        my_stack.emplace_back(root);\\n        while(!my_stack.empty()){\\n            root = my_stack.back();\\n            my_stack.pop_back();\\n            if(root){\\n                if(!root->left&&!root->right&&root->val==sum) return true; //check terminating condition only at leaf node \\n                if(root->right){\\n                    root->right->val += root->val;\\n                    my_stack.emplace_back(root->right);\\n                }  \\n                if(root->left){\\n                    root->left->val += root->val;\\n                    my_stack.emplace_back(root->left);\\n                }  \\n            }\\n            \\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 683862,
                "title": "in-rust",
                "content": "```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn has_path_sum(root: Option<Rc<RefCell<TreeNode>>>, sum: i32) -> bool {\\n        if let Some(n) = root {\\n            let node = n.borrow();\\n            if node.left.is_none() && node.right.is_none() && node.val == sum {\\n                return true\\n            }\\n            return Solution::has_path_sum(node.left.clone(), sum - node.val) ||\\n                    Solution::has_path_sum(node.right.clone(), sum - node.val)\\n        }\\n        return false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn has_path_sum(root: Option<Rc<RefCell<TreeNode>>>, sum: i32) -> bool {\\n        if let Some(n) = root {\\n            let node = n.borrow();\\n            if node.left.is_none() && node.right.is_none() && node.val == sum {\\n                return true\\n            }\\n            return Solution::has_path_sum(node.left.clone(), sum - node.val) ||\\n                    Solution::has_path_sum(node.right.clone(), sum - node.val)\\n        }\\n        return false\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 673154,
                "title": "java-dfs-runtime-faster-100",
                "content": "```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if (root == null) {\\n            return false;\\n        }\\n        \\n        sum -= root.val;\\n        if (sum == 0 && root.left == null && root.right == null) {\\n            return true;\\n        }\\n        \\n        return hasPathSum(root.left, sum) || hasPathSum(root.right, sum);\\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if (root == null) {\\n            return false;\\n        }\\n        \\n        sum -= root.val;\\n        if (sum == 0 && root.left == null && root.right == null) {\\n            return true;\\n        }\\n        \\n        return hasPathSum(root.left, sum) || hasPathSum(root.right, sum);\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 519579,
                "title": "c-iterative-solution",
                "content": "```\\npublic class Solution {\\n    public bool HasPathSum(TreeNode root, int sum) {\\n        if (root == null)\\n\\t\\t\\treturn false;\\n\\n\\t    var stack = new Stack<(TreeNode Node, int Sum)>();\\n\\t    stack.Push((root, root.val));\\n\\t    while (stack.Count != 0) {\\n\\t\\t    var p = stack.Pop();\\n            TreeNode node = p.Node;\\n            int psum = p.Sum;\\n            \\n\\t\\t\\tif (node.right != null)\\n\\t\\t        stack.Push((node.right, node.right.val+psum));\\t\\t\\t\\n\\t\\t\\tif (node.left != null)\\n\\t\\t\\t\\tstack.Push((node.left, node.left.val+psum));\\n            \\n\\t\\t\\tif (node.left == null && node.right == null && psum == sum)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\npublic class Solution {\\n    public bool HasPathSum(TreeNode root, int sum) {\\n        if (root == null)\\n\\t\\t\\treturn false;\\n\\n\\t    var stack = new Stack<(TreeNode Node, int Sum)>();\\n\\t    stack.Push((root, root.val));\\n\\t    while (stack.Count != 0) {\\n\\t\\t    var p = stack.Pop();\\n            TreeNode node = p.Node;\\n            int psum = p.Sum;\\n            \\n\\t\\t\\tif (node.right != null)\\n\\t\\t        stack.Push((node.right, node.right.val+psum));\\t\\t\\t\\n\\t\\t\\tif (node.left != null)\\n\\t\\t\\t\\tstack.Push((node.left, node.left.val+psum));\\n            \\n\\t\\t\\tif (node.left == null && node.right == null && psum == sum)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 466765,
                "title": "simple-recursion",
                "content": "```\\npublic boolean hasPathSum(TreeNode root, int sum) {\\n        if(root==null){\\n            return false;\\n        }else if(root.left==null && root.right==null && root.val == sum){\\n            return true;\\n        }\\n        return hasPathSum(root.left, sum-(root.val)) || hasPathSum(root.right, sum-(root.val));\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\npublic boolean hasPathSum(TreeNode root, int sum) {\\n        if(root==null){\\n            return false;\\n        }else if(root.left==null && root.right==null && root.val == sum){\\n            return true;\\n        }\\n        return hasPathSum(root.left, sum-(root.val)) || hasPathSum(root.right, sum-(root.val));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 320633,
                "title": "c-88-beat-easy-win-o-n-recursive-solution-logic",
                "content": "```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int sum) {        \\n        if (root == NULL) { return false; }\\n        sum -= root->val;\\n        if (root->left == NULL && root->right == NULL && sum == 0) { return true; }\\n        if (root->left  != NULL) { if (hasPathSum(root->left,  sum)) { return true; } }\\n        if (root->right != NULL) { if (hasPathSum(root->right, sum)) { return true; } }\\n        return false;\\n    }\\n};\\n```\\n\\nThe logic checks out.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int sum) {        \\n        if (root == NULL) { return false; }\\n        sum -= root->val;\\n        if (root->left == NULL && root->right == NULL && sum == 0) { return true; }\\n        if (root->left  != NULL) { if (hasPathSum(root->left,  sum)) { return true; } }\\n        if (root->right != NULL) { if (hasPathSum(root->right, sum)) { return true; } }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 315089,
                "title": "simple-rust-recursive-solution-faster-than-100-00-of-rust-online-submissions",
                "content": "```\\nimpl Solution {\\n    pub fn has_path_sum(root: Option<Rc<RefCell<TreeNode>>>, sum: i32) -> bool {\\n        Solution::helper(&root, sum)\\n    }\\n\\n    fn helper(root: &Option<Rc<RefCell<TreeNode>>>, sum: i32) -> bool {\\n        if let Some(data) = root {\\n            let node = data.borrow_mut();\\n            if node.left.is_none() && node.right.is_none() { // is leaf\\n                return sum == node.val;\\n            }\\n            return Solution::helper(&node.left, sum - node.val)\\n                || Solution::helper(&node.right, sum - node.val);\\n        }\\n        false\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn has_path_sum(root: Option<Rc<RefCell<TreeNode>>>, sum: i32) -> bool {\\n        Solution::helper(&root, sum)\\n    }\\n\\n    fn helper(root: &Option<Rc<RefCell<TreeNode>>>, sum: i32) -> bool {\\n        if let Some(data) = root {\\n            let node = data.borrow_mut();\\n            if node.left.is_none() && node.right.is_none() { // is leaf\\n                return sum == node.val;\\n            }\\n            return Solution::helper(&node.left, sum - node.val)\\n                || Solution::helper(&node.right, sum - node.val);\\n        }\\n        false\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 157106,
                "title": "easy-4-lines-scala",
                "content": "```\\n  def hasPathSum(root: TreeNode, sum: Int): Boolean = (root, sum) match {\\n    case (null, _) => false\\n    case (r, s) if r.left == null && r.right == null => r.value == sum\\n    case (r, s) =>\\n      hasPathSum(r.left, sum - r.value) || hasPathSum(r.right, sum - r.value)\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n  def hasPathSum(root: TreeNode, sum: Int): Boolean = (root, sum) match {\\n    case (null, _) => false\\n    case (r, s) if r.left == null && r.right == null => r.value == sum\\n    case (r, s) =>\\n      hasPathSum(r.left, sum - r.value) || hasPathSum(r.right, sum - r.value)\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 36361,
                "title": "3-lines-accepted-java-solution",
                "content": "```\\nclass Solution \\n{\\n    public boolean hasPathSum(TreeNode root, int sum) \\n    {  \\n        if (root == null) return false;\\n        if (root.val == sum && root.left == null && root.right == null) return true;\\n        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public boolean hasPathSum(TreeNode root, int sum) \\n    {  \\n        if (root == null) return false;\\n        if (root.val == sum && root.left == null && root.right == null) return true;\\n        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 36428,
                "title": "java-3-line-easy-to-understand-1-ms",
                "content": "```\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if(root==null)return false;\\n        if(sum-root.val==0 && root.left==null && root.right==null)return true;\\n        return hasPathSum(root.left,sum-root.val) || hasPathSum(root.right,sum-root.val);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if(root==null)return false;\\n        if(sum-root.val==0 && root.left==null && root.right==null)return true;\\n        return hasPathSum(root.left,sum-root.val) || hasPathSum(root.right,sum-root.val);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 36499,
                "title": "one-line-c-solution",
                "content": "class Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int sum) {\\n        return root && ((!root->left && !root->right && root->val == sum) || hasPathSum(root->left, sum - root->val) || hasPathSum(root->right, sum - root->val));\\n    }\\n};",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int sum) {\\n        return root && ((!root->left && !root->right && root->val == sum) || hasPathSum(root->left, sum - root->val) || hasPathSum(root->right, sum - root->val));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 36537,
                "title": "c-bfs-solution",
                "content": "    class Solution {\\n    public:\\n        bool hasPathSum(TreeNode* root, int sum) {\\n            if(root == NULL) return false;\\n            queue<TreeNode*> myqueue;\\n            myqueue.push(root);\\n            while(!myqueue.empty()){\\n                TreeNode* cur = myqueue.front();\\n                myqueue.pop();\\n                if(cur->left != NULL){\\n                    cur->left->val+=cur->val;\\n                    myqueue.push(cur->left);\\n                }\\n                if(cur->right != NULL){\\n                    cur->right->val+=cur->val;\\n                    myqueue.push(cur->right);\\n                }\\n                if(cur->left == NULL && cur->right ==NULL && cur->val == sum) return true;\\n            }\\n            return false;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool hasPathSum(TreeNode* root, int sum) {\\n            if(root == NULL) return false;\\n            queue<TreeNode*> myqueue;\\n            myqueue.push(root);\\n            while(!myqueue.empty()){\\n                TreeNode* cur = myqueue.front();\\n                myqueue.pop();\\n                if(cur->left != NULL){\\n                    cur->left->val+=cur->val;\\n                    myqueue.push(cur->left);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 36546,
                "title": "c-12ms-recursive-iterative-solutions",
                "content": "    class Solution {\\n    public:\\n    bool hasPathSum(TreeNode* root, int sum) {\\n        //return solution1(root, sum);        //recursive\\n        return solution2(root, sum);        //iterative\\n    }\\n    private:\\n    bool solution1(TreeNode *n, int sum){\\n        if(!n) return false;\\n        if(!n->left && !n->right) return sum - n->val == 0;\\n        return solution1(n->left, sum - n->val) || solution1(n->right, sum - n->val);\\n    }\\n    bool solution2(TreeNode *n, int sum){\\n        if(!n) return false;\\n        stack<TreeNode *> st;\\n        TreeNode *cur = n, *pre;\\n        while(cur || !st.empty()){\\n            while(cur){\\n                st.push(cur);\\n                sum -= cur->val;\\n                cur = cur->left;\\n            }\\n            cur = st.top();\\n            if(!cur->left && !cur->right && !sum) return true;\\n            if(cur->right && pre != cur->right) cur = cur->right;\\n            else{\\n                st.pop();\\n                sum += cur->val;\\n                pre = cur;\\n                cur = NULL;\\n            }\\n        }\\n        return false;\\n    }\\n    };",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public:\\n    bool hasPathSum(TreeNode* root, int sum) {\\n        //return solution1(root, sum);        //recursive\\n        return solution2(root, sum);        //iterative\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 36590,
                "title": "simple-recursive-solution-in-ruby",
                "content": "    def has_path_sum(root, sum)\\n      return false if root.nil?\\n    \\n      if root.val == sum && root.left.nil? && root.right.nil?\\n        return true\\n      end\\n      \\n      has_path_sum(root.left, sum - root.val) || has_path_sum(root.right, sum - root.val)\\n    end",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "    def has_path_sum(root, sum)\\n      return false if root.nil?\\n    \\n      if root.val == sum && root.left.nil? && root.right.nil?\\n        return true\\n      end\\n      \\n      has_path_sum(root.left, sum - root.val) || has_path_sum(root.right, sum - root.val)\\n    end",
                "codeTag": "Python3"
            },
            {
                "id": 36599,
                "title": "8-ms-c-solution-one-line-of-code",
                "content": "    bool hasPathSum(struct TreeNode* root, int sum) {\\n        return !root? false: (root->right || root->left)? hasPathSum(root->left, sum-root->val)||hasPathSum(root->right, sum-root->val):sum==root->val ;\\n    }",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "    bool hasPathSum(struct TreeNode* root, int sum) {\\n        return !root? false: (root->right || root->left)? hasPathSum(root->left, sum-root->val)||hasPathSum(root->right, sum-root->val):sum==root->val ;\\n    }",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1565659,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1564962,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1566325,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1566073,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1568025,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1572485,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1566969,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1570035,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1815767,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1574172,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1565659,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1564962,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1566325,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1566073,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1568025,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1572485,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1566969,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1570035,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1815767,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1574172,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1566745,
                "content": [
                    {
                        "username": "amiyadiwan",
                        "content": "If only strictly positive numbers are allowed as values, then additional pruning of branches can be applied"
                    },
                    {
                        "username": "RandomDev123",
                        "content": "If the tree is empty and the supplied int value is 0, the \"expected\" response is false, but this isn\\'t specified in the question\\'s description. There\\'s a case to be made that the code should return TRUE in that case, as there does exist a path that adds to 0."
                    },
                    {
                        "username": "pavlic148",
                        "content": "In that case there\\'s no such path that adds to 0 since there are no paths at all."
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "Anyone else having issues with this test case \\nroot = [1,2,null,3,null,4,null,5], targetSum = 6, expected false????\\nAm I missing something here?\\n \\nTarget: 6, path: 1->2->3. \\n\\n[Submission](https://leetcode.com/problems/path-sum/submissions/1023144591/)\\n"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) Ahh got it. Yeah, I should have read the problem more carefully. Thanks"
                    },
                    {
                        "username": "sjames8888",
                        "content": "has a root-to-leaf path in question where implication is you must go all way down the side of tree root to leaf where both left right are null as end point \\n```java\\n // a leaf\\n        if (v == target && root.left == null && root.right == null) {\\n            return target;\\n        }\\n```"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) I\\'m not sure what you mean? The TreeNode is just on the left side(like a linked list) and the sum 1+2+3 should give a target of 6. Or you meant something else?!"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Task :compileTestJava\n> Task :processTestResources NO-SOURCE\n> Task :testClasses\n> Task :test\n\n```txt\n                                    1\n                        /\n                       2\n                   /\n                  3\n                /\n               4\n              /\n             5\n```\n\ngraph is as above \n\n @Test\n    void case5() {\n        final var root = TreeNode.from(new Integer[] {1,2,null,3,null,4,null,5});\n        Assertions.assertNotNull(root);\n        System.out.println(root.prettyPrint());\n        final var res = new PathSum().hasPathSum(root, 6);\n        Assertions.assertFalse(res);\n    }\n\ns\n"
                    },
                    {
                        "username": "wjeevika",
                        "content": "Idk why but I like this question. It\\'s so cute. "
                    },
                    {
                        "username": "akashgkrishnan",
                        "content": "I had run the same code multiple times and found that the same code runs faster then 90 percent of submissions and also slower than 90 percent submissions. is there any particular reason why"
                    },
                    {
                        "username": "max_223",
                        "content": "Below are two related problems and solution in C++/Java/Python if anybody is interested:\\n\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/\">Find maximum sum root-to-leaf path in a binary tree</a>\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-path-between-two-leaves-in-a-binary-tree/\">Find maximum sum path between two leaves in a binary tree</a>"
                    },
                    {
                        "username": "sugikushal",
                        "content": "public boolean hasPathSum(TreeNode root, int sum) {\\n\\tif(root == null) return false;\\n\\tif(root.val == sum && root.right == null && root.left == null) return true;\\n\\tif(root.left != null) root.left.val += root.val;\\n\\tif(root.right != null) root.right.val += root.val;\\n\\treturn hasPathSum(root.left,sum) || hasPathSum(root.right,sum);\\n}"
                    },
                    {
                        "username": "wuhan9087",
                        "content": "What is root node,and its leftchild, rightchild?"
                    },
                    {
                        "username": "heena",
                        "content": "If the tree is empty but the sum is also zero then the function hasPathSum should return true .\\nBut the code is accepted on\\n `if(root==NULL) {\\nreturn false; }`   .I have this doubt that shouldn't this be `if(tree==NULL) return (sum==0);` \\n\\nNote: the code doesnt get accepted with return sum==0 but with return false."
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Python || Easy and Clean Code\\n\\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if root==None:\\n            return False\\n        \\n        targetSum=targetSum-root.val\\n        \\n        if root.left==None and root.right==None:\\n            return targetSum==0\\n        \\n        return self.hasPathSum(root.left,targetSum) or self.hasPathSum(root.right,targetSum)\\n        \\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy and Clean Rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "noita_verse",
                        "content": "FYI there\\'s a new solutions tab to post your solutions"
                    }
                ]
            },
            {
                "id": 1569579,
                "content": [
                    {
                        "username": "amiyadiwan",
                        "content": "If only strictly positive numbers are allowed as values, then additional pruning of branches can be applied"
                    },
                    {
                        "username": "RandomDev123",
                        "content": "If the tree is empty and the supplied int value is 0, the \"expected\" response is false, but this isn\\'t specified in the question\\'s description. There\\'s a case to be made that the code should return TRUE in that case, as there does exist a path that adds to 0."
                    },
                    {
                        "username": "pavlic148",
                        "content": "In that case there\\'s no such path that adds to 0 since there are no paths at all."
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "Anyone else having issues with this test case \\nroot = [1,2,null,3,null,4,null,5], targetSum = 6, expected false????\\nAm I missing something here?\\n \\nTarget: 6, path: 1->2->3. \\n\\n[Submission](https://leetcode.com/problems/path-sum/submissions/1023144591/)\\n"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) Ahh got it. Yeah, I should have read the problem more carefully. Thanks"
                    },
                    {
                        "username": "sjames8888",
                        "content": "has a root-to-leaf path in question where implication is you must go all way down the side of tree root to leaf where both left right are null as end point \\n```java\\n // a leaf\\n        if (v == target && root.left == null && root.right == null) {\\n            return target;\\n        }\\n```"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) I\\'m not sure what you mean? The TreeNode is just on the left side(like a linked list) and the sum 1+2+3 should give a target of 6. Or you meant something else?!"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Task :compileTestJava\n> Task :processTestResources NO-SOURCE\n> Task :testClasses\n> Task :test\n\n```txt\n                                    1\n                        /\n                       2\n                   /\n                  3\n                /\n               4\n              /\n             5\n```\n\ngraph is as above \n\n @Test\n    void case5() {\n        final var root = TreeNode.from(new Integer[] {1,2,null,3,null,4,null,5});\n        Assertions.assertNotNull(root);\n        System.out.println(root.prettyPrint());\n        final var res = new PathSum().hasPathSum(root, 6);\n        Assertions.assertFalse(res);\n    }\n\ns\n"
                    },
                    {
                        "username": "wjeevika",
                        "content": "Idk why but I like this question. It\\'s so cute. "
                    },
                    {
                        "username": "akashgkrishnan",
                        "content": "I had run the same code multiple times and found that the same code runs faster then 90 percent of submissions and also slower than 90 percent submissions. is there any particular reason why"
                    },
                    {
                        "username": "max_223",
                        "content": "Below are two related problems and solution in C++/Java/Python if anybody is interested:\\n\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/\">Find maximum sum root-to-leaf path in a binary tree</a>\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-path-between-two-leaves-in-a-binary-tree/\">Find maximum sum path between two leaves in a binary tree</a>"
                    },
                    {
                        "username": "sugikushal",
                        "content": "public boolean hasPathSum(TreeNode root, int sum) {\\n\\tif(root == null) return false;\\n\\tif(root.val == sum && root.right == null && root.left == null) return true;\\n\\tif(root.left != null) root.left.val += root.val;\\n\\tif(root.right != null) root.right.val += root.val;\\n\\treturn hasPathSum(root.left,sum) || hasPathSum(root.right,sum);\\n}"
                    },
                    {
                        "username": "wuhan9087",
                        "content": "What is root node,and its leftchild, rightchild?"
                    },
                    {
                        "username": "heena",
                        "content": "If the tree is empty but the sum is also zero then the function hasPathSum should return true .\\nBut the code is accepted on\\n `if(root==NULL) {\\nreturn false; }`   .I have this doubt that shouldn't this be `if(tree==NULL) return (sum==0);` \\n\\nNote: the code doesnt get accepted with return sum==0 but with return false."
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Python || Easy and Clean Code\\n\\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if root==None:\\n            return False\\n        \\n        targetSum=targetSum-root.val\\n        \\n        if root.left==None and root.right==None:\\n            return targetSum==0\\n        \\n        return self.hasPathSum(root.left,targetSum) or self.hasPathSum(root.right,targetSum)\\n        \\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy and Clean Rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "noita_verse",
                        "content": "FYI there\\'s a new solutions tab to post your solutions"
                    }
                ]
            },
            {
                "id": 2016906,
                "content": [
                    {
                        "username": "amiyadiwan",
                        "content": "If only strictly positive numbers are allowed as values, then additional pruning of branches can be applied"
                    },
                    {
                        "username": "RandomDev123",
                        "content": "If the tree is empty and the supplied int value is 0, the \"expected\" response is false, but this isn\\'t specified in the question\\'s description. There\\'s a case to be made that the code should return TRUE in that case, as there does exist a path that adds to 0."
                    },
                    {
                        "username": "pavlic148",
                        "content": "In that case there\\'s no such path that adds to 0 since there are no paths at all."
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "Anyone else having issues with this test case \\nroot = [1,2,null,3,null,4,null,5], targetSum = 6, expected false????\\nAm I missing something here?\\n \\nTarget: 6, path: 1->2->3. \\n\\n[Submission](https://leetcode.com/problems/path-sum/submissions/1023144591/)\\n"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) Ahh got it. Yeah, I should have read the problem more carefully. Thanks"
                    },
                    {
                        "username": "sjames8888",
                        "content": "has a root-to-leaf path in question where implication is you must go all way down the side of tree root to leaf where both left right are null as end point \\n```java\\n // a leaf\\n        if (v == target && root.left == null && root.right == null) {\\n            return target;\\n        }\\n```"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) I\\'m not sure what you mean? The TreeNode is just on the left side(like a linked list) and the sum 1+2+3 should give a target of 6. Or you meant something else?!"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Task :compileTestJava\n> Task :processTestResources NO-SOURCE\n> Task :testClasses\n> Task :test\n\n```txt\n                                    1\n                        /\n                       2\n                   /\n                  3\n                /\n               4\n              /\n             5\n```\n\ngraph is as above \n\n @Test\n    void case5() {\n        final var root = TreeNode.from(new Integer[] {1,2,null,3,null,4,null,5});\n        Assertions.assertNotNull(root);\n        System.out.println(root.prettyPrint());\n        final var res = new PathSum().hasPathSum(root, 6);\n        Assertions.assertFalse(res);\n    }\n\ns\n"
                    },
                    {
                        "username": "wjeevika",
                        "content": "Idk why but I like this question. It\\'s so cute. "
                    },
                    {
                        "username": "akashgkrishnan",
                        "content": "I had run the same code multiple times and found that the same code runs faster then 90 percent of submissions and also slower than 90 percent submissions. is there any particular reason why"
                    },
                    {
                        "username": "max_223",
                        "content": "Below are two related problems and solution in C++/Java/Python if anybody is interested:\\n\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/\">Find maximum sum root-to-leaf path in a binary tree</a>\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-path-between-two-leaves-in-a-binary-tree/\">Find maximum sum path between two leaves in a binary tree</a>"
                    },
                    {
                        "username": "sugikushal",
                        "content": "public boolean hasPathSum(TreeNode root, int sum) {\\n\\tif(root == null) return false;\\n\\tif(root.val == sum && root.right == null && root.left == null) return true;\\n\\tif(root.left != null) root.left.val += root.val;\\n\\tif(root.right != null) root.right.val += root.val;\\n\\treturn hasPathSum(root.left,sum) || hasPathSum(root.right,sum);\\n}"
                    },
                    {
                        "username": "wuhan9087",
                        "content": "What is root node,and its leftchild, rightchild?"
                    },
                    {
                        "username": "heena",
                        "content": "If the tree is empty but the sum is also zero then the function hasPathSum should return true .\\nBut the code is accepted on\\n `if(root==NULL) {\\nreturn false; }`   .I have this doubt that shouldn't this be `if(tree==NULL) return (sum==0);` \\n\\nNote: the code doesnt get accepted with return sum==0 but with return false."
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Python || Easy and Clean Code\\n\\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if root==None:\\n            return False\\n        \\n        targetSum=targetSum-root.val\\n        \\n        if root.left==None and root.right==None:\\n            return targetSum==0\\n        \\n        return self.hasPathSum(root.left,targetSum) or self.hasPathSum(root.right,targetSum)\\n        \\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy and Clean Rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "noita_verse",
                        "content": "FYI there\\'s a new solutions tab to post your solutions"
                    }
                ]
            },
            {
                "id": 1674698,
                "content": [
                    {
                        "username": "amiyadiwan",
                        "content": "If only strictly positive numbers are allowed as values, then additional pruning of branches can be applied"
                    },
                    {
                        "username": "RandomDev123",
                        "content": "If the tree is empty and the supplied int value is 0, the \"expected\" response is false, but this isn\\'t specified in the question\\'s description. There\\'s a case to be made that the code should return TRUE in that case, as there does exist a path that adds to 0."
                    },
                    {
                        "username": "pavlic148",
                        "content": "In that case there\\'s no such path that adds to 0 since there are no paths at all."
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "Anyone else having issues with this test case \\nroot = [1,2,null,3,null,4,null,5], targetSum = 6, expected false????\\nAm I missing something here?\\n \\nTarget: 6, path: 1->2->3. \\n\\n[Submission](https://leetcode.com/problems/path-sum/submissions/1023144591/)\\n"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) Ahh got it. Yeah, I should have read the problem more carefully. Thanks"
                    },
                    {
                        "username": "sjames8888",
                        "content": "has a root-to-leaf path in question where implication is you must go all way down the side of tree root to leaf where both left right are null as end point \\n```java\\n // a leaf\\n        if (v == target && root.left == null && root.right == null) {\\n            return target;\\n        }\\n```"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) I\\'m not sure what you mean? The TreeNode is just on the left side(like a linked list) and the sum 1+2+3 should give a target of 6. Or you meant something else?!"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Task :compileTestJava\n> Task :processTestResources NO-SOURCE\n> Task :testClasses\n> Task :test\n\n```txt\n                                    1\n                        /\n                       2\n                   /\n                  3\n                /\n               4\n              /\n             5\n```\n\ngraph is as above \n\n @Test\n    void case5() {\n        final var root = TreeNode.from(new Integer[] {1,2,null,3,null,4,null,5});\n        Assertions.assertNotNull(root);\n        System.out.println(root.prettyPrint());\n        final var res = new PathSum().hasPathSum(root, 6);\n        Assertions.assertFalse(res);\n    }\n\ns\n"
                    },
                    {
                        "username": "wjeevika",
                        "content": "Idk why but I like this question. It\\'s so cute. "
                    },
                    {
                        "username": "akashgkrishnan",
                        "content": "I had run the same code multiple times and found that the same code runs faster then 90 percent of submissions and also slower than 90 percent submissions. is there any particular reason why"
                    },
                    {
                        "username": "max_223",
                        "content": "Below are two related problems and solution in C++/Java/Python if anybody is interested:\\n\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/\">Find maximum sum root-to-leaf path in a binary tree</a>\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-path-between-two-leaves-in-a-binary-tree/\">Find maximum sum path between two leaves in a binary tree</a>"
                    },
                    {
                        "username": "sugikushal",
                        "content": "public boolean hasPathSum(TreeNode root, int sum) {\\n\\tif(root == null) return false;\\n\\tif(root.val == sum && root.right == null && root.left == null) return true;\\n\\tif(root.left != null) root.left.val += root.val;\\n\\tif(root.right != null) root.right.val += root.val;\\n\\treturn hasPathSum(root.left,sum) || hasPathSum(root.right,sum);\\n}"
                    },
                    {
                        "username": "wuhan9087",
                        "content": "What is root node,and its leftchild, rightchild?"
                    },
                    {
                        "username": "heena",
                        "content": "If the tree is empty but the sum is also zero then the function hasPathSum should return true .\\nBut the code is accepted on\\n `if(root==NULL) {\\nreturn false; }`   .I have this doubt that shouldn't this be `if(tree==NULL) return (sum==0);` \\n\\nNote: the code doesnt get accepted with return sum==0 but with return false."
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Python || Easy and Clean Code\\n\\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if root==None:\\n            return False\\n        \\n        targetSum=targetSum-root.val\\n        \\n        if root.left==None and root.right==None:\\n            return targetSum==0\\n        \\n        return self.hasPathSum(root.left,targetSum) or self.hasPathSum(root.right,targetSum)\\n        \\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy and Clean Rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "noita_verse",
                        "content": "FYI there\\'s a new solutions tab to post your solutions"
                    }
                ]
            },
            {
                "id": 1574055,
                "content": [
                    {
                        "username": "amiyadiwan",
                        "content": "If only strictly positive numbers are allowed as values, then additional pruning of branches can be applied"
                    },
                    {
                        "username": "RandomDev123",
                        "content": "If the tree is empty and the supplied int value is 0, the \"expected\" response is false, but this isn\\'t specified in the question\\'s description. There\\'s a case to be made that the code should return TRUE in that case, as there does exist a path that adds to 0."
                    },
                    {
                        "username": "pavlic148",
                        "content": "In that case there\\'s no such path that adds to 0 since there are no paths at all."
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "Anyone else having issues with this test case \\nroot = [1,2,null,3,null,4,null,5], targetSum = 6, expected false????\\nAm I missing something here?\\n \\nTarget: 6, path: 1->2->3. \\n\\n[Submission](https://leetcode.com/problems/path-sum/submissions/1023144591/)\\n"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) Ahh got it. Yeah, I should have read the problem more carefully. Thanks"
                    },
                    {
                        "username": "sjames8888",
                        "content": "has a root-to-leaf path in question where implication is you must go all way down the side of tree root to leaf where both left right are null as end point \\n```java\\n // a leaf\\n        if (v == target && root.left == null && root.right == null) {\\n            return target;\\n        }\\n```"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) I\\'m not sure what you mean? The TreeNode is just on the left side(like a linked list) and the sum 1+2+3 should give a target of 6. Or you meant something else?!"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Task :compileTestJava\n> Task :processTestResources NO-SOURCE\n> Task :testClasses\n> Task :test\n\n```txt\n                                    1\n                        /\n                       2\n                   /\n                  3\n                /\n               4\n              /\n             5\n```\n\ngraph is as above \n\n @Test\n    void case5() {\n        final var root = TreeNode.from(new Integer[] {1,2,null,3,null,4,null,5});\n        Assertions.assertNotNull(root);\n        System.out.println(root.prettyPrint());\n        final var res = new PathSum().hasPathSum(root, 6);\n        Assertions.assertFalse(res);\n    }\n\ns\n"
                    },
                    {
                        "username": "wjeevika",
                        "content": "Idk why but I like this question. It\\'s so cute. "
                    },
                    {
                        "username": "akashgkrishnan",
                        "content": "I had run the same code multiple times and found that the same code runs faster then 90 percent of submissions and also slower than 90 percent submissions. is there any particular reason why"
                    },
                    {
                        "username": "max_223",
                        "content": "Below are two related problems and solution in C++/Java/Python if anybody is interested:\\n\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/\">Find maximum sum root-to-leaf path in a binary tree</a>\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-path-between-two-leaves-in-a-binary-tree/\">Find maximum sum path between two leaves in a binary tree</a>"
                    },
                    {
                        "username": "sugikushal",
                        "content": "public boolean hasPathSum(TreeNode root, int sum) {\\n\\tif(root == null) return false;\\n\\tif(root.val == sum && root.right == null && root.left == null) return true;\\n\\tif(root.left != null) root.left.val += root.val;\\n\\tif(root.right != null) root.right.val += root.val;\\n\\treturn hasPathSum(root.left,sum) || hasPathSum(root.right,sum);\\n}"
                    },
                    {
                        "username": "wuhan9087",
                        "content": "What is root node,and its leftchild, rightchild?"
                    },
                    {
                        "username": "heena",
                        "content": "If the tree is empty but the sum is also zero then the function hasPathSum should return true .\\nBut the code is accepted on\\n `if(root==NULL) {\\nreturn false; }`   .I have this doubt that shouldn't this be `if(tree==NULL) return (sum==0);` \\n\\nNote: the code doesnt get accepted with return sum==0 but with return false."
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Python || Easy and Clean Code\\n\\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if root==None:\\n            return False\\n        \\n        targetSum=targetSum-root.val\\n        \\n        if root.left==None and root.right==None:\\n            return targetSum==0\\n        \\n        return self.hasPathSum(root.left,targetSum) or self.hasPathSum(root.right,targetSum)\\n        \\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy and Clean Rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "noita_verse",
                        "content": "FYI there\\'s a new solutions tab to post your solutions"
                    }
                ]
            },
            {
                "id": 1573928,
                "content": [
                    {
                        "username": "amiyadiwan",
                        "content": "If only strictly positive numbers are allowed as values, then additional pruning of branches can be applied"
                    },
                    {
                        "username": "RandomDev123",
                        "content": "If the tree is empty and the supplied int value is 0, the \"expected\" response is false, but this isn\\'t specified in the question\\'s description. There\\'s a case to be made that the code should return TRUE in that case, as there does exist a path that adds to 0."
                    },
                    {
                        "username": "pavlic148",
                        "content": "In that case there\\'s no such path that adds to 0 since there are no paths at all."
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "Anyone else having issues with this test case \\nroot = [1,2,null,3,null,4,null,5], targetSum = 6, expected false????\\nAm I missing something here?\\n \\nTarget: 6, path: 1->2->3. \\n\\n[Submission](https://leetcode.com/problems/path-sum/submissions/1023144591/)\\n"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) Ahh got it. Yeah, I should have read the problem more carefully. Thanks"
                    },
                    {
                        "username": "sjames8888",
                        "content": "has a root-to-leaf path in question where implication is you must go all way down the side of tree root to leaf where both left right are null as end point \\n```java\\n // a leaf\\n        if (v == target && root.left == null && root.right == null) {\\n            return target;\\n        }\\n```"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) I\\'m not sure what you mean? The TreeNode is just on the left side(like a linked list) and the sum 1+2+3 should give a target of 6. Or you meant something else?!"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Task :compileTestJava\n> Task :processTestResources NO-SOURCE\n> Task :testClasses\n> Task :test\n\n```txt\n                                    1\n                        /\n                       2\n                   /\n                  3\n                /\n               4\n              /\n             5\n```\n\ngraph is as above \n\n @Test\n    void case5() {\n        final var root = TreeNode.from(new Integer[] {1,2,null,3,null,4,null,5});\n        Assertions.assertNotNull(root);\n        System.out.println(root.prettyPrint());\n        final var res = new PathSum().hasPathSum(root, 6);\n        Assertions.assertFalse(res);\n    }\n\ns\n"
                    },
                    {
                        "username": "wjeevika",
                        "content": "Idk why but I like this question. It\\'s so cute. "
                    },
                    {
                        "username": "akashgkrishnan",
                        "content": "I had run the same code multiple times and found that the same code runs faster then 90 percent of submissions and also slower than 90 percent submissions. is there any particular reason why"
                    },
                    {
                        "username": "max_223",
                        "content": "Below are two related problems and solution in C++/Java/Python if anybody is interested:\\n\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/\">Find maximum sum root-to-leaf path in a binary tree</a>\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-path-between-two-leaves-in-a-binary-tree/\">Find maximum sum path between two leaves in a binary tree</a>"
                    },
                    {
                        "username": "sugikushal",
                        "content": "public boolean hasPathSum(TreeNode root, int sum) {\\n\\tif(root == null) return false;\\n\\tif(root.val == sum && root.right == null && root.left == null) return true;\\n\\tif(root.left != null) root.left.val += root.val;\\n\\tif(root.right != null) root.right.val += root.val;\\n\\treturn hasPathSum(root.left,sum) || hasPathSum(root.right,sum);\\n}"
                    },
                    {
                        "username": "wuhan9087",
                        "content": "What is root node,and its leftchild, rightchild?"
                    },
                    {
                        "username": "heena",
                        "content": "If the tree is empty but the sum is also zero then the function hasPathSum should return true .\\nBut the code is accepted on\\n `if(root==NULL) {\\nreturn false; }`   .I have this doubt that shouldn't this be `if(tree==NULL) return (sum==0);` \\n\\nNote: the code doesnt get accepted with return sum==0 but with return false."
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Python || Easy and Clean Code\\n\\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if root==None:\\n            return False\\n        \\n        targetSum=targetSum-root.val\\n        \\n        if root.left==None and root.right==None:\\n            return targetSum==0\\n        \\n        return self.hasPathSum(root.left,targetSum) or self.hasPathSum(root.right,targetSum)\\n        \\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy and Clean Rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "noita_verse",
                        "content": "FYI there\\'s a new solutions tab to post your solutions"
                    }
                ]
            },
            {
                "id": 1573249,
                "content": [
                    {
                        "username": "amiyadiwan",
                        "content": "If only strictly positive numbers are allowed as values, then additional pruning of branches can be applied"
                    },
                    {
                        "username": "RandomDev123",
                        "content": "If the tree is empty and the supplied int value is 0, the \"expected\" response is false, but this isn\\'t specified in the question\\'s description. There\\'s a case to be made that the code should return TRUE in that case, as there does exist a path that adds to 0."
                    },
                    {
                        "username": "pavlic148",
                        "content": "In that case there\\'s no such path that adds to 0 since there are no paths at all."
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "Anyone else having issues with this test case \\nroot = [1,2,null,3,null,4,null,5], targetSum = 6, expected false????\\nAm I missing something here?\\n \\nTarget: 6, path: 1->2->3. \\n\\n[Submission](https://leetcode.com/problems/path-sum/submissions/1023144591/)\\n"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) Ahh got it. Yeah, I should have read the problem more carefully. Thanks"
                    },
                    {
                        "username": "sjames8888",
                        "content": "has a root-to-leaf path in question where implication is you must go all way down the side of tree root to leaf where both left right are null as end point \\n```java\\n // a leaf\\n        if (v == target && root.left == null && root.right == null) {\\n            return target;\\n        }\\n```"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) I\\'m not sure what you mean? The TreeNode is just on the left side(like a linked list) and the sum 1+2+3 should give a target of 6. Or you meant something else?!"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Task :compileTestJava\n> Task :processTestResources NO-SOURCE\n> Task :testClasses\n> Task :test\n\n```txt\n                                    1\n                        /\n                       2\n                   /\n                  3\n                /\n               4\n              /\n             5\n```\n\ngraph is as above \n\n @Test\n    void case5() {\n        final var root = TreeNode.from(new Integer[] {1,2,null,3,null,4,null,5});\n        Assertions.assertNotNull(root);\n        System.out.println(root.prettyPrint());\n        final var res = new PathSum().hasPathSum(root, 6);\n        Assertions.assertFalse(res);\n    }\n\ns\n"
                    },
                    {
                        "username": "wjeevika",
                        "content": "Idk why but I like this question. It\\'s so cute. "
                    },
                    {
                        "username": "akashgkrishnan",
                        "content": "I had run the same code multiple times and found that the same code runs faster then 90 percent of submissions and also slower than 90 percent submissions. is there any particular reason why"
                    },
                    {
                        "username": "max_223",
                        "content": "Below are two related problems and solution in C++/Java/Python if anybody is interested:\\n\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/\">Find maximum sum root-to-leaf path in a binary tree</a>\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-path-between-two-leaves-in-a-binary-tree/\">Find maximum sum path between two leaves in a binary tree</a>"
                    },
                    {
                        "username": "sugikushal",
                        "content": "public boolean hasPathSum(TreeNode root, int sum) {\\n\\tif(root == null) return false;\\n\\tif(root.val == sum && root.right == null && root.left == null) return true;\\n\\tif(root.left != null) root.left.val += root.val;\\n\\tif(root.right != null) root.right.val += root.val;\\n\\treturn hasPathSum(root.left,sum) || hasPathSum(root.right,sum);\\n}"
                    },
                    {
                        "username": "wuhan9087",
                        "content": "What is root node,and its leftchild, rightchild?"
                    },
                    {
                        "username": "heena",
                        "content": "If the tree is empty but the sum is also zero then the function hasPathSum should return true .\\nBut the code is accepted on\\n `if(root==NULL) {\\nreturn false; }`   .I have this doubt that shouldn't this be `if(tree==NULL) return (sum==0);` \\n\\nNote: the code doesnt get accepted with return sum==0 but with return false."
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Python || Easy and Clean Code\\n\\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if root==None:\\n            return False\\n        \\n        targetSum=targetSum-root.val\\n        \\n        if root.left==None and root.right==None:\\n            return targetSum==0\\n        \\n        return self.hasPathSum(root.left,targetSum) or self.hasPathSum(root.right,targetSum)\\n        \\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy and Clean Rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "noita_verse",
                        "content": "FYI there\\'s a new solutions tab to post your solutions"
                    }
                ]
            },
            {
                "id": 1571233,
                "content": [
                    {
                        "username": "amiyadiwan",
                        "content": "If only strictly positive numbers are allowed as values, then additional pruning of branches can be applied"
                    },
                    {
                        "username": "RandomDev123",
                        "content": "If the tree is empty and the supplied int value is 0, the \"expected\" response is false, but this isn\\'t specified in the question\\'s description. There\\'s a case to be made that the code should return TRUE in that case, as there does exist a path that adds to 0."
                    },
                    {
                        "username": "pavlic148",
                        "content": "In that case there\\'s no such path that adds to 0 since there are no paths at all."
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "Anyone else having issues with this test case \\nroot = [1,2,null,3,null,4,null,5], targetSum = 6, expected false????\\nAm I missing something here?\\n \\nTarget: 6, path: 1->2->3. \\n\\n[Submission](https://leetcode.com/problems/path-sum/submissions/1023144591/)\\n"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) Ahh got it. Yeah, I should have read the problem more carefully. Thanks"
                    },
                    {
                        "username": "sjames8888",
                        "content": "has a root-to-leaf path in question where implication is you must go all way down the side of tree root to leaf where both left right are null as end point \\n```java\\n // a leaf\\n        if (v == target && root.left == null && root.right == null) {\\n            return target;\\n        }\\n```"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) I\\'m not sure what you mean? The TreeNode is just on the left side(like a linked list) and the sum 1+2+3 should give a target of 6. Or you meant something else?!"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Task :compileTestJava\n> Task :processTestResources NO-SOURCE\n> Task :testClasses\n> Task :test\n\n```txt\n                                    1\n                        /\n                       2\n                   /\n                  3\n                /\n               4\n              /\n             5\n```\n\ngraph is as above \n\n @Test\n    void case5() {\n        final var root = TreeNode.from(new Integer[] {1,2,null,3,null,4,null,5});\n        Assertions.assertNotNull(root);\n        System.out.println(root.prettyPrint());\n        final var res = new PathSum().hasPathSum(root, 6);\n        Assertions.assertFalse(res);\n    }\n\ns\n"
                    },
                    {
                        "username": "wjeevika",
                        "content": "Idk why but I like this question. It\\'s so cute. "
                    },
                    {
                        "username": "akashgkrishnan",
                        "content": "I had run the same code multiple times and found that the same code runs faster then 90 percent of submissions and also slower than 90 percent submissions. is there any particular reason why"
                    },
                    {
                        "username": "max_223",
                        "content": "Below are two related problems and solution in C++/Java/Python if anybody is interested:\\n\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/\">Find maximum sum root-to-leaf path in a binary tree</a>\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-path-between-two-leaves-in-a-binary-tree/\">Find maximum sum path between two leaves in a binary tree</a>"
                    },
                    {
                        "username": "sugikushal",
                        "content": "public boolean hasPathSum(TreeNode root, int sum) {\\n\\tif(root == null) return false;\\n\\tif(root.val == sum && root.right == null && root.left == null) return true;\\n\\tif(root.left != null) root.left.val += root.val;\\n\\tif(root.right != null) root.right.val += root.val;\\n\\treturn hasPathSum(root.left,sum) || hasPathSum(root.right,sum);\\n}"
                    },
                    {
                        "username": "wuhan9087",
                        "content": "What is root node,and its leftchild, rightchild?"
                    },
                    {
                        "username": "heena",
                        "content": "If the tree is empty but the sum is also zero then the function hasPathSum should return true .\\nBut the code is accepted on\\n `if(root==NULL) {\\nreturn false; }`   .I have this doubt that shouldn't this be `if(tree==NULL) return (sum==0);` \\n\\nNote: the code doesnt get accepted with return sum==0 but with return false."
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Python || Easy and Clean Code\\n\\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if root==None:\\n            return False\\n        \\n        targetSum=targetSum-root.val\\n        \\n        if root.left==None and root.right==None:\\n            return targetSum==0\\n        \\n        return self.hasPathSum(root.left,targetSum) or self.hasPathSum(root.right,targetSum)\\n        \\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy and Clean Rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "noita_verse",
                        "content": "FYI there\\'s a new solutions tab to post your solutions"
                    }
                ]
            },
            {
                "id": 1571234,
                "content": [
                    {
                        "username": "amiyadiwan",
                        "content": "If only strictly positive numbers are allowed as values, then additional pruning of branches can be applied"
                    },
                    {
                        "username": "RandomDev123",
                        "content": "If the tree is empty and the supplied int value is 0, the \"expected\" response is false, but this isn\\'t specified in the question\\'s description. There\\'s a case to be made that the code should return TRUE in that case, as there does exist a path that adds to 0."
                    },
                    {
                        "username": "pavlic148",
                        "content": "In that case there\\'s no such path that adds to 0 since there are no paths at all."
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "Anyone else having issues with this test case \\nroot = [1,2,null,3,null,4,null,5], targetSum = 6, expected false????\\nAm I missing something here?\\n \\nTarget: 6, path: 1->2->3. \\n\\n[Submission](https://leetcode.com/problems/path-sum/submissions/1023144591/)\\n"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) Ahh got it. Yeah, I should have read the problem more carefully. Thanks"
                    },
                    {
                        "username": "sjames8888",
                        "content": "has a root-to-leaf path in question where implication is you must go all way down the side of tree root to leaf where both left right are null as end point \\n```java\\n // a leaf\\n        if (v == target && root.left == null && root.right == null) {\\n            return target;\\n        }\\n```"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) I\\'m not sure what you mean? The TreeNode is just on the left side(like a linked list) and the sum 1+2+3 should give a target of 6. Or you meant something else?!"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Task :compileTestJava\n> Task :processTestResources NO-SOURCE\n> Task :testClasses\n> Task :test\n\n```txt\n                                    1\n                        /\n                       2\n                   /\n                  3\n                /\n               4\n              /\n             5\n```\n\ngraph is as above \n\n @Test\n    void case5() {\n        final var root = TreeNode.from(new Integer[] {1,2,null,3,null,4,null,5});\n        Assertions.assertNotNull(root);\n        System.out.println(root.prettyPrint());\n        final var res = new PathSum().hasPathSum(root, 6);\n        Assertions.assertFalse(res);\n    }\n\ns\n"
                    },
                    {
                        "username": "wjeevika",
                        "content": "Idk why but I like this question. It\\'s so cute. "
                    },
                    {
                        "username": "akashgkrishnan",
                        "content": "I had run the same code multiple times and found that the same code runs faster then 90 percent of submissions and also slower than 90 percent submissions. is there any particular reason why"
                    },
                    {
                        "username": "max_223",
                        "content": "Below are two related problems and solution in C++/Java/Python if anybody is interested:\\n\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/\">Find maximum sum root-to-leaf path in a binary tree</a>\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-path-between-two-leaves-in-a-binary-tree/\">Find maximum sum path between two leaves in a binary tree</a>"
                    },
                    {
                        "username": "sugikushal",
                        "content": "public boolean hasPathSum(TreeNode root, int sum) {\\n\\tif(root == null) return false;\\n\\tif(root.val == sum && root.right == null && root.left == null) return true;\\n\\tif(root.left != null) root.left.val += root.val;\\n\\tif(root.right != null) root.right.val += root.val;\\n\\treturn hasPathSum(root.left,sum) || hasPathSum(root.right,sum);\\n}"
                    },
                    {
                        "username": "wuhan9087",
                        "content": "What is root node,and its leftchild, rightchild?"
                    },
                    {
                        "username": "heena",
                        "content": "If the tree is empty but the sum is also zero then the function hasPathSum should return true .\\nBut the code is accepted on\\n `if(root==NULL) {\\nreturn false; }`   .I have this doubt that shouldn't this be `if(tree==NULL) return (sum==0);` \\n\\nNote: the code doesnt get accepted with return sum==0 but with return false."
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Python || Easy and Clean Code\\n\\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if root==None:\\n            return False\\n        \\n        targetSum=targetSum-root.val\\n        \\n        if root.left==None and root.right==None:\\n            return targetSum==0\\n        \\n        return self.hasPathSum(root.left,targetSum) or self.hasPathSum(root.right,targetSum)\\n        \\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy and Clean Rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "noita_verse",
                        "content": "FYI there\\'s a new solutions tab to post your solutions"
                    }
                ]
            },
            {
                "id": 1630176,
                "content": [
                    {
                        "username": "amiyadiwan",
                        "content": "If only strictly positive numbers are allowed as values, then additional pruning of branches can be applied"
                    },
                    {
                        "username": "RandomDev123",
                        "content": "If the tree is empty and the supplied int value is 0, the \"expected\" response is false, but this isn\\'t specified in the question\\'s description. There\\'s a case to be made that the code should return TRUE in that case, as there does exist a path that adds to 0."
                    },
                    {
                        "username": "pavlic148",
                        "content": "In that case there\\'s no such path that adds to 0 since there are no paths at all."
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "Anyone else having issues with this test case \\nroot = [1,2,null,3,null,4,null,5], targetSum = 6, expected false????\\nAm I missing something here?\\n \\nTarget: 6, path: 1->2->3. \\n\\n[Submission](https://leetcode.com/problems/path-sum/submissions/1023144591/)\\n"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) Ahh got it. Yeah, I should have read the problem more carefully. Thanks"
                    },
                    {
                        "username": "sjames8888",
                        "content": "has a root-to-leaf path in question where implication is you must go all way down the side of tree root to leaf where both left right are null as end point \\n```java\\n // a leaf\\n        if (v == target && root.left == null && root.right == null) {\\n            return target;\\n        }\\n```"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) I\\'m not sure what you mean? The TreeNode is just on the left side(like a linked list) and the sum 1+2+3 should give a target of 6. Or you meant something else?!"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Task :compileTestJava\n> Task :processTestResources NO-SOURCE\n> Task :testClasses\n> Task :test\n\n```txt\n                                    1\n                        /\n                       2\n                   /\n                  3\n                /\n               4\n              /\n             5\n```\n\ngraph is as above \n\n @Test\n    void case5() {\n        final var root = TreeNode.from(new Integer[] {1,2,null,3,null,4,null,5});\n        Assertions.assertNotNull(root);\n        System.out.println(root.prettyPrint());\n        final var res = new PathSum().hasPathSum(root, 6);\n        Assertions.assertFalse(res);\n    }\n\ns\n"
                    },
                    {
                        "username": "wjeevika",
                        "content": "Idk why but I like this question. It\\'s so cute. "
                    },
                    {
                        "username": "akashgkrishnan",
                        "content": "I had run the same code multiple times and found that the same code runs faster then 90 percent of submissions and also slower than 90 percent submissions. is there any particular reason why"
                    },
                    {
                        "username": "max_223",
                        "content": "Below are two related problems and solution in C++/Java/Python if anybody is interested:\\n\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/\">Find maximum sum root-to-leaf path in a binary tree</a>\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-path-between-two-leaves-in-a-binary-tree/\">Find maximum sum path between two leaves in a binary tree</a>"
                    },
                    {
                        "username": "sugikushal",
                        "content": "public boolean hasPathSum(TreeNode root, int sum) {\\n\\tif(root == null) return false;\\n\\tif(root.val == sum && root.right == null && root.left == null) return true;\\n\\tif(root.left != null) root.left.val += root.val;\\n\\tif(root.right != null) root.right.val += root.val;\\n\\treturn hasPathSum(root.left,sum) || hasPathSum(root.right,sum);\\n}"
                    },
                    {
                        "username": "wuhan9087",
                        "content": "What is root node,and its leftchild, rightchild?"
                    },
                    {
                        "username": "heena",
                        "content": "If the tree is empty but the sum is also zero then the function hasPathSum should return true .\\nBut the code is accepted on\\n `if(root==NULL) {\\nreturn false; }`   .I have this doubt that shouldn't this be `if(tree==NULL) return (sum==0);` \\n\\nNote: the code doesnt get accepted with return sum==0 but with return false."
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Python || Easy and Clean Code\\n\\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if root==None:\\n            return False\\n        \\n        targetSum=targetSum-root.val\\n        \\n        if root.left==None and root.right==None:\\n            return targetSum==0\\n        \\n        return self.hasPathSum(root.left,targetSum) or self.hasPathSum(root.right,targetSum)\\n        \\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy and Clean Rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "noita_verse",
                        "content": "FYI there\\'s a new solutions tab to post your solutions"
                    }
                ]
            },
            {
                "id": 2039961,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Pretty proud in March April.. I started learn for the first time traversals in trees and now I can approach these types of problems with a good thought what I should do, sometimes I take a peek if isn\\'t working, but wish I was again in my student years to grind this shit non-stop. "
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[1,1,1,1] and target sum 2 is a good test case."
                    },
                    {
                        "username": "TernyavskyIlya",
                        "content": "Where my fail?\\n `def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        def wrap(root, total):\\n            if not root.left and not root.right:\\n                print(total)\\n                if total == targetSum:\\n                    return False\\n            if root.left:\\n                wrap(root.left, total+root.left.val)\\n            if root.right:\\n                wrap(root.right, total+root.right.val)\\n            return True\\n        wrap(root, root.val)\\n`"
                    },
                    {
                        "username": "chahatgupta1060",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "the question has 117 testcases i have passed 99 testcase but my code is break while passing 100 number test case. the question asked you want to check that the binery tree path sum is equal of target sum. \"you should think about decrease the targetsum either think about increment "
                    },
                    {
                        "username": "kush512",
                        "content": "class Solution {\\npublic:\\n\\n    bool solve(TreeNode* root, int targetSum) {\\n        if(root==NULL && targetSum==0) return true;\\n        if(root==NULL) return false;\\n        bool l=hasPathSum(root->left, targetSum-root->val);\\n        bool r=hasPathSum(root->right, targetSum-root->val);\\n        return l || r;\\n    }\\n\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return false; \\n        else return solve(root,targetSum);\\n    }\\n};\\n\\nwhy is it not giving correct answer?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "There is a test case where root=[1,2], and target sum = 1, so it should return true but it expects false, which I can\\'t understand why. This is a weird test case."
                    },
                    {
                        "username": "sjames8888",
                        "content": "That\\u2019s a one sided tree where root 1 has one child 2 and leaf defined as no children nodes so path sum in this case is sum of 2 nodes. You have to include sum of 2 as this has no nodes so sum is 3 in this case "
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "testcase 70 has something issue there is expected output is true but while debug my code in visual studio then received correct output but leetcode has something issue"
                    },
                    {
                        "username": "batuczarny",
                        "content": "Why does this code not work? \\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n\\n        def check(root, curSum):\\n            if not root:\\n                return False\\n        \\n            if root.left is None and root.right is None and curSum==targetSum:\\n                return True\\n            \\n            left = check(root.left, curSum + root.val)\\n            right = check(root.right, curSum + root.val)\\n            \\n            return left or right\\n\\n        return check(root, 0) \\n\\n        "
                    },
                    {
                        "username": "1valeryvb",
                        "content": "curSum - root.val"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Parsing given array into tree - suggested Java\n\nthe following Java seems to parse correctly.  Probably not best but incase it is useful to somone\n\n```java\nfinal var root = TreeNode.from2(new Integer[]{5,4,8,11,null,13,4,7,2,null,null,null,1});\n```\n\n\n                    5\n                /       \\\n               4         8\n             /         /   \\\n           11        13     4\n           / \\               \\\n          7   2               1\n\n```java\n  public static TreeNode from2(Integer[] arr) {\n        if (arr.length == 0) {\n            return null;\n        }\n        var ptr = 0;\n        final var root = new TreeNode(arr[ptr++]);\n        final Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n\n        while (ptr < arr.length && !q.isEmpty()) {\n            final var size = q.size();\n            for (var i = 0; i < size; ++i) {\n                final var node = q.remove();\n                ptr = fromConsume(node, ptr, arr, q);\n            }\n        }\n\n        return root;\n    }\n\n    enum Position {\n        Left,\n        Right\n    }\n\n    public static int fromConsume(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q) {\n        if (ptr >= arr.length) return ptr;\n        if (focus == null) return ptr;\n\n        ptr  = fromConsumeOne(focus, ptr, arr,q, Position.Left);\n        if (ptr < arr.length) {\n            ptr  = fromConsumeOne(focus, ptr, arr,q,Position.Right);\n        }\n\n        return ptr;\n    }\n\n    public static TreeNode from(Integer[] arr) {\n        return from2(arr);\n\n    }\n\n    static int fromConsumeOne(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q, Position position) {\n        if (arr[ptr] == null) {\n            ptr++;\n        } else {\n            final var node = new TreeNode(arr[ptr++]);\n            q.add(node);\n            if (position == Position.Left) {\n                focus.left = node;\n            } else {\n                focus.right = node;\n            }\n        }\n        return ptr;\n    } \n```\n"
                    }
                ]
            },
            {
                "id": 2032318,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Pretty proud in March April.. I started learn for the first time traversals in trees and now I can approach these types of problems with a good thought what I should do, sometimes I take a peek if isn\\'t working, but wish I was again in my student years to grind this shit non-stop. "
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[1,1,1,1] and target sum 2 is a good test case."
                    },
                    {
                        "username": "TernyavskyIlya",
                        "content": "Where my fail?\\n `def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        def wrap(root, total):\\n            if not root.left and not root.right:\\n                print(total)\\n                if total == targetSum:\\n                    return False\\n            if root.left:\\n                wrap(root.left, total+root.left.val)\\n            if root.right:\\n                wrap(root.right, total+root.right.val)\\n            return True\\n        wrap(root, root.val)\\n`"
                    },
                    {
                        "username": "chahatgupta1060",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "the question has 117 testcases i have passed 99 testcase but my code is break while passing 100 number test case. the question asked you want to check that the binery tree path sum is equal of target sum. \"you should think about decrease the targetsum either think about increment "
                    },
                    {
                        "username": "kush512",
                        "content": "class Solution {\\npublic:\\n\\n    bool solve(TreeNode* root, int targetSum) {\\n        if(root==NULL && targetSum==0) return true;\\n        if(root==NULL) return false;\\n        bool l=hasPathSum(root->left, targetSum-root->val);\\n        bool r=hasPathSum(root->right, targetSum-root->val);\\n        return l || r;\\n    }\\n\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return false; \\n        else return solve(root,targetSum);\\n    }\\n};\\n\\nwhy is it not giving correct answer?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "There is a test case where root=[1,2], and target sum = 1, so it should return true but it expects false, which I can\\'t understand why. This is a weird test case."
                    },
                    {
                        "username": "sjames8888",
                        "content": "That\\u2019s a one sided tree where root 1 has one child 2 and leaf defined as no children nodes so path sum in this case is sum of 2 nodes. You have to include sum of 2 as this has no nodes so sum is 3 in this case "
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "testcase 70 has something issue there is expected output is true but while debug my code in visual studio then received correct output but leetcode has something issue"
                    },
                    {
                        "username": "batuczarny",
                        "content": "Why does this code not work? \\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n\\n        def check(root, curSum):\\n            if not root:\\n                return False\\n        \\n            if root.left is None and root.right is None and curSum==targetSum:\\n                return True\\n            \\n            left = check(root.left, curSum + root.val)\\n            right = check(root.right, curSum + root.val)\\n            \\n            return left or right\\n\\n        return check(root, 0) \\n\\n        "
                    },
                    {
                        "username": "1valeryvb",
                        "content": "curSum - root.val"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Parsing given array into tree - suggested Java\n\nthe following Java seems to parse correctly.  Probably not best but incase it is useful to somone\n\n```java\nfinal var root = TreeNode.from2(new Integer[]{5,4,8,11,null,13,4,7,2,null,null,null,1});\n```\n\n\n                    5\n                /       \\\n               4         8\n             /         /   \\\n           11        13     4\n           / \\               \\\n          7   2               1\n\n```java\n  public static TreeNode from2(Integer[] arr) {\n        if (arr.length == 0) {\n            return null;\n        }\n        var ptr = 0;\n        final var root = new TreeNode(arr[ptr++]);\n        final Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n\n        while (ptr < arr.length && !q.isEmpty()) {\n            final var size = q.size();\n            for (var i = 0; i < size; ++i) {\n                final var node = q.remove();\n                ptr = fromConsume(node, ptr, arr, q);\n            }\n        }\n\n        return root;\n    }\n\n    enum Position {\n        Left,\n        Right\n    }\n\n    public static int fromConsume(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q) {\n        if (ptr >= arr.length) return ptr;\n        if (focus == null) return ptr;\n\n        ptr  = fromConsumeOne(focus, ptr, arr,q, Position.Left);\n        if (ptr < arr.length) {\n            ptr  = fromConsumeOne(focus, ptr, arr,q,Position.Right);\n        }\n\n        return ptr;\n    }\n\n    public static TreeNode from(Integer[] arr) {\n        return from2(arr);\n\n    }\n\n    static int fromConsumeOne(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q, Position position) {\n        if (arr[ptr] == null) {\n            ptr++;\n        } else {\n            final var node = new TreeNode(arr[ptr++]);\n            q.add(node);\n            if (position == Position.Left) {\n                focus.left = node;\n            } else {\n                focus.right = node;\n            }\n        }\n        return ptr;\n    } \n```\n"
                    }
                ]
            },
            {
                "id": 2020632,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Pretty proud in March April.. I started learn for the first time traversals in trees and now I can approach these types of problems with a good thought what I should do, sometimes I take a peek if isn\\'t working, but wish I was again in my student years to grind this shit non-stop. "
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[1,1,1,1] and target sum 2 is a good test case."
                    },
                    {
                        "username": "TernyavskyIlya",
                        "content": "Where my fail?\\n `def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        def wrap(root, total):\\n            if not root.left and not root.right:\\n                print(total)\\n                if total == targetSum:\\n                    return False\\n            if root.left:\\n                wrap(root.left, total+root.left.val)\\n            if root.right:\\n                wrap(root.right, total+root.right.val)\\n            return True\\n        wrap(root, root.val)\\n`"
                    },
                    {
                        "username": "chahatgupta1060",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "the question has 117 testcases i have passed 99 testcase but my code is break while passing 100 number test case. the question asked you want to check that the binery tree path sum is equal of target sum. \"you should think about decrease the targetsum either think about increment "
                    },
                    {
                        "username": "kush512",
                        "content": "class Solution {\\npublic:\\n\\n    bool solve(TreeNode* root, int targetSum) {\\n        if(root==NULL && targetSum==0) return true;\\n        if(root==NULL) return false;\\n        bool l=hasPathSum(root->left, targetSum-root->val);\\n        bool r=hasPathSum(root->right, targetSum-root->val);\\n        return l || r;\\n    }\\n\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return false; \\n        else return solve(root,targetSum);\\n    }\\n};\\n\\nwhy is it not giving correct answer?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "There is a test case where root=[1,2], and target sum = 1, so it should return true but it expects false, which I can\\'t understand why. This is a weird test case."
                    },
                    {
                        "username": "sjames8888",
                        "content": "That\\u2019s a one sided tree where root 1 has one child 2 and leaf defined as no children nodes so path sum in this case is sum of 2 nodes. You have to include sum of 2 as this has no nodes so sum is 3 in this case "
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "testcase 70 has something issue there is expected output is true but while debug my code in visual studio then received correct output but leetcode has something issue"
                    },
                    {
                        "username": "batuczarny",
                        "content": "Why does this code not work? \\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n\\n        def check(root, curSum):\\n            if not root:\\n                return False\\n        \\n            if root.left is None and root.right is None and curSum==targetSum:\\n                return True\\n            \\n            left = check(root.left, curSum + root.val)\\n            right = check(root.right, curSum + root.val)\\n            \\n            return left or right\\n\\n        return check(root, 0) \\n\\n        "
                    },
                    {
                        "username": "1valeryvb",
                        "content": "curSum - root.val"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Parsing given array into tree - suggested Java\n\nthe following Java seems to parse correctly.  Probably not best but incase it is useful to somone\n\n```java\nfinal var root = TreeNode.from2(new Integer[]{5,4,8,11,null,13,4,7,2,null,null,null,1});\n```\n\n\n                    5\n                /       \\\n               4         8\n             /         /   \\\n           11        13     4\n           / \\               \\\n          7   2               1\n\n```java\n  public static TreeNode from2(Integer[] arr) {\n        if (arr.length == 0) {\n            return null;\n        }\n        var ptr = 0;\n        final var root = new TreeNode(arr[ptr++]);\n        final Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n\n        while (ptr < arr.length && !q.isEmpty()) {\n            final var size = q.size();\n            for (var i = 0; i < size; ++i) {\n                final var node = q.remove();\n                ptr = fromConsume(node, ptr, arr, q);\n            }\n        }\n\n        return root;\n    }\n\n    enum Position {\n        Left,\n        Right\n    }\n\n    public static int fromConsume(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q) {\n        if (ptr >= arr.length) return ptr;\n        if (focus == null) return ptr;\n\n        ptr  = fromConsumeOne(focus, ptr, arr,q, Position.Left);\n        if (ptr < arr.length) {\n            ptr  = fromConsumeOne(focus, ptr, arr,q,Position.Right);\n        }\n\n        return ptr;\n    }\n\n    public static TreeNode from(Integer[] arr) {\n        return from2(arr);\n\n    }\n\n    static int fromConsumeOne(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q, Position position) {\n        if (arr[ptr] == null) {\n            ptr++;\n        } else {\n            final var node = new TreeNode(arr[ptr++]);\n            q.add(node);\n            if (position == Position.Left) {\n                focus.left = node;\n            } else {\n                focus.right = node;\n            }\n        }\n        return ptr;\n    } \n```\n"
                    }
                ]
            },
            {
                "id": 2016841,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Pretty proud in March April.. I started learn for the first time traversals in trees and now I can approach these types of problems with a good thought what I should do, sometimes I take a peek if isn\\'t working, but wish I was again in my student years to grind this shit non-stop. "
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[1,1,1,1] and target sum 2 is a good test case."
                    },
                    {
                        "username": "TernyavskyIlya",
                        "content": "Where my fail?\\n `def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        def wrap(root, total):\\n            if not root.left and not root.right:\\n                print(total)\\n                if total == targetSum:\\n                    return False\\n            if root.left:\\n                wrap(root.left, total+root.left.val)\\n            if root.right:\\n                wrap(root.right, total+root.right.val)\\n            return True\\n        wrap(root, root.val)\\n`"
                    },
                    {
                        "username": "chahatgupta1060",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "the question has 117 testcases i have passed 99 testcase but my code is break while passing 100 number test case. the question asked you want to check that the binery tree path sum is equal of target sum. \"you should think about decrease the targetsum either think about increment "
                    },
                    {
                        "username": "kush512",
                        "content": "class Solution {\\npublic:\\n\\n    bool solve(TreeNode* root, int targetSum) {\\n        if(root==NULL && targetSum==0) return true;\\n        if(root==NULL) return false;\\n        bool l=hasPathSum(root->left, targetSum-root->val);\\n        bool r=hasPathSum(root->right, targetSum-root->val);\\n        return l || r;\\n    }\\n\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return false; \\n        else return solve(root,targetSum);\\n    }\\n};\\n\\nwhy is it not giving correct answer?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "There is a test case where root=[1,2], and target sum = 1, so it should return true but it expects false, which I can\\'t understand why. This is a weird test case."
                    },
                    {
                        "username": "sjames8888",
                        "content": "That\\u2019s a one sided tree where root 1 has one child 2 and leaf defined as no children nodes so path sum in this case is sum of 2 nodes. You have to include sum of 2 as this has no nodes so sum is 3 in this case "
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "testcase 70 has something issue there is expected output is true but while debug my code in visual studio then received correct output but leetcode has something issue"
                    },
                    {
                        "username": "batuczarny",
                        "content": "Why does this code not work? \\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n\\n        def check(root, curSum):\\n            if not root:\\n                return False\\n        \\n            if root.left is None and root.right is None and curSum==targetSum:\\n                return True\\n            \\n            left = check(root.left, curSum + root.val)\\n            right = check(root.right, curSum + root.val)\\n            \\n            return left or right\\n\\n        return check(root, 0) \\n\\n        "
                    },
                    {
                        "username": "1valeryvb",
                        "content": "curSum - root.val"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Parsing given array into tree - suggested Java\n\nthe following Java seems to parse correctly.  Probably not best but incase it is useful to somone\n\n```java\nfinal var root = TreeNode.from2(new Integer[]{5,4,8,11,null,13,4,7,2,null,null,null,1});\n```\n\n\n                    5\n                /       \\\n               4         8\n             /         /   \\\n           11        13     4\n           / \\               \\\n          7   2               1\n\n```java\n  public static TreeNode from2(Integer[] arr) {\n        if (arr.length == 0) {\n            return null;\n        }\n        var ptr = 0;\n        final var root = new TreeNode(arr[ptr++]);\n        final Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n\n        while (ptr < arr.length && !q.isEmpty()) {\n            final var size = q.size();\n            for (var i = 0; i < size; ++i) {\n                final var node = q.remove();\n                ptr = fromConsume(node, ptr, arr, q);\n            }\n        }\n\n        return root;\n    }\n\n    enum Position {\n        Left,\n        Right\n    }\n\n    public static int fromConsume(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q) {\n        if (ptr >= arr.length) return ptr;\n        if (focus == null) return ptr;\n\n        ptr  = fromConsumeOne(focus, ptr, arr,q, Position.Left);\n        if (ptr < arr.length) {\n            ptr  = fromConsumeOne(focus, ptr, arr,q,Position.Right);\n        }\n\n        return ptr;\n    }\n\n    public static TreeNode from(Integer[] arr) {\n        return from2(arr);\n\n    }\n\n    static int fromConsumeOne(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q, Position position) {\n        if (arr[ptr] == null) {\n            ptr++;\n        } else {\n            final var node = new TreeNode(arr[ptr++]);\n            q.add(node);\n            if (position == Position.Left) {\n                focus.left = node;\n            } else {\n                focus.right = node;\n            }\n        }\n        return ptr;\n    } \n```\n"
                    }
                ]
            },
            {
                "id": 2013717,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Pretty proud in March April.. I started learn for the first time traversals in trees and now I can approach these types of problems with a good thought what I should do, sometimes I take a peek if isn\\'t working, but wish I was again in my student years to grind this shit non-stop. "
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[1,1,1,1] and target sum 2 is a good test case."
                    },
                    {
                        "username": "TernyavskyIlya",
                        "content": "Where my fail?\\n `def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        def wrap(root, total):\\n            if not root.left and not root.right:\\n                print(total)\\n                if total == targetSum:\\n                    return False\\n            if root.left:\\n                wrap(root.left, total+root.left.val)\\n            if root.right:\\n                wrap(root.right, total+root.right.val)\\n            return True\\n        wrap(root, root.val)\\n`"
                    },
                    {
                        "username": "chahatgupta1060",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "the question has 117 testcases i have passed 99 testcase but my code is break while passing 100 number test case. the question asked you want to check that the binery tree path sum is equal of target sum. \"you should think about decrease the targetsum either think about increment "
                    },
                    {
                        "username": "kush512",
                        "content": "class Solution {\\npublic:\\n\\n    bool solve(TreeNode* root, int targetSum) {\\n        if(root==NULL && targetSum==0) return true;\\n        if(root==NULL) return false;\\n        bool l=hasPathSum(root->left, targetSum-root->val);\\n        bool r=hasPathSum(root->right, targetSum-root->val);\\n        return l || r;\\n    }\\n\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return false; \\n        else return solve(root,targetSum);\\n    }\\n};\\n\\nwhy is it not giving correct answer?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "There is a test case where root=[1,2], and target sum = 1, so it should return true but it expects false, which I can\\'t understand why. This is a weird test case."
                    },
                    {
                        "username": "sjames8888",
                        "content": "That\\u2019s a one sided tree where root 1 has one child 2 and leaf defined as no children nodes so path sum in this case is sum of 2 nodes. You have to include sum of 2 as this has no nodes so sum is 3 in this case "
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "testcase 70 has something issue there is expected output is true but while debug my code in visual studio then received correct output but leetcode has something issue"
                    },
                    {
                        "username": "batuczarny",
                        "content": "Why does this code not work? \\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n\\n        def check(root, curSum):\\n            if not root:\\n                return False\\n        \\n            if root.left is None and root.right is None and curSum==targetSum:\\n                return True\\n            \\n            left = check(root.left, curSum + root.val)\\n            right = check(root.right, curSum + root.val)\\n            \\n            return left or right\\n\\n        return check(root, 0) \\n\\n        "
                    },
                    {
                        "username": "1valeryvb",
                        "content": "curSum - root.val"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Parsing given array into tree - suggested Java\n\nthe following Java seems to parse correctly.  Probably not best but incase it is useful to somone\n\n```java\nfinal var root = TreeNode.from2(new Integer[]{5,4,8,11,null,13,4,7,2,null,null,null,1});\n```\n\n\n                    5\n                /       \\\n               4         8\n             /         /   \\\n           11        13     4\n           / \\               \\\n          7   2               1\n\n```java\n  public static TreeNode from2(Integer[] arr) {\n        if (arr.length == 0) {\n            return null;\n        }\n        var ptr = 0;\n        final var root = new TreeNode(arr[ptr++]);\n        final Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n\n        while (ptr < arr.length && !q.isEmpty()) {\n            final var size = q.size();\n            for (var i = 0; i < size; ++i) {\n                final var node = q.remove();\n                ptr = fromConsume(node, ptr, arr, q);\n            }\n        }\n\n        return root;\n    }\n\n    enum Position {\n        Left,\n        Right\n    }\n\n    public static int fromConsume(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q) {\n        if (ptr >= arr.length) return ptr;\n        if (focus == null) return ptr;\n\n        ptr  = fromConsumeOne(focus, ptr, arr,q, Position.Left);\n        if (ptr < arr.length) {\n            ptr  = fromConsumeOne(focus, ptr, arr,q,Position.Right);\n        }\n\n        return ptr;\n    }\n\n    public static TreeNode from(Integer[] arr) {\n        return from2(arr);\n\n    }\n\n    static int fromConsumeOne(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q, Position position) {\n        if (arr[ptr] == null) {\n            ptr++;\n        } else {\n            final var node = new TreeNode(arr[ptr++]);\n            q.add(node);\n            if (position == Position.Left) {\n                focus.left = node;\n            } else {\n                focus.right = node;\n            }\n        }\n        return ptr;\n    } \n```\n"
                    }
                ]
            },
            {
                "id": 2008249,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Pretty proud in March April.. I started learn for the first time traversals in trees and now I can approach these types of problems with a good thought what I should do, sometimes I take a peek if isn\\'t working, but wish I was again in my student years to grind this shit non-stop. "
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[1,1,1,1] and target sum 2 is a good test case."
                    },
                    {
                        "username": "TernyavskyIlya",
                        "content": "Where my fail?\\n `def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        def wrap(root, total):\\n            if not root.left and not root.right:\\n                print(total)\\n                if total == targetSum:\\n                    return False\\n            if root.left:\\n                wrap(root.left, total+root.left.val)\\n            if root.right:\\n                wrap(root.right, total+root.right.val)\\n            return True\\n        wrap(root, root.val)\\n`"
                    },
                    {
                        "username": "chahatgupta1060",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "the question has 117 testcases i have passed 99 testcase but my code is break while passing 100 number test case. the question asked you want to check that the binery tree path sum is equal of target sum. \"you should think about decrease the targetsum either think about increment "
                    },
                    {
                        "username": "kush512",
                        "content": "class Solution {\\npublic:\\n\\n    bool solve(TreeNode* root, int targetSum) {\\n        if(root==NULL && targetSum==0) return true;\\n        if(root==NULL) return false;\\n        bool l=hasPathSum(root->left, targetSum-root->val);\\n        bool r=hasPathSum(root->right, targetSum-root->val);\\n        return l || r;\\n    }\\n\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return false; \\n        else return solve(root,targetSum);\\n    }\\n};\\n\\nwhy is it not giving correct answer?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "There is a test case where root=[1,2], and target sum = 1, so it should return true but it expects false, which I can\\'t understand why. This is a weird test case."
                    },
                    {
                        "username": "sjames8888",
                        "content": "That\\u2019s a one sided tree where root 1 has one child 2 and leaf defined as no children nodes so path sum in this case is sum of 2 nodes. You have to include sum of 2 as this has no nodes so sum is 3 in this case "
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "testcase 70 has something issue there is expected output is true but while debug my code in visual studio then received correct output but leetcode has something issue"
                    },
                    {
                        "username": "batuczarny",
                        "content": "Why does this code not work? \\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n\\n        def check(root, curSum):\\n            if not root:\\n                return False\\n        \\n            if root.left is None and root.right is None and curSum==targetSum:\\n                return True\\n            \\n            left = check(root.left, curSum + root.val)\\n            right = check(root.right, curSum + root.val)\\n            \\n            return left or right\\n\\n        return check(root, 0) \\n\\n        "
                    },
                    {
                        "username": "1valeryvb",
                        "content": "curSum - root.val"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Parsing given array into tree - suggested Java\n\nthe following Java seems to parse correctly.  Probably not best but incase it is useful to somone\n\n```java\nfinal var root = TreeNode.from2(new Integer[]{5,4,8,11,null,13,4,7,2,null,null,null,1});\n```\n\n\n                    5\n                /       \\\n               4         8\n             /         /   \\\n           11        13     4\n           / \\               \\\n          7   2               1\n\n```java\n  public static TreeNode from2(Integer[] arr) {\n        if (arr.length == 0) {\n            return null;\n        }\n        var ptr = 0;\n        final var root = new TreeNode(arr[ptr++]);\n        final Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n\n        while (ptr < arr.length && !q.isEmpty()) {\n            final var size = q.size();\n            for (var i = 0; i < size; ++i) {\n                final var node = q.remove();\n                ptr = fromConsume(node, ptr, arr, q);\n            }\n        }\n\n        return root;\n    }\n\n    enum Position {\n        Left,\n        Right\n    }\n\n    public static int fromConsume(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q) {\n        if (ptr >= arr.length) return ptr;\n        if (focus == null) return ptr;\n\n        ptr  = fromConsumeOne(focus, ptr, arr,q, Position.Left);\n        if (ptr < arr.length) {\n            ptr  = fromConsumeOne(focus, ptr, arr,q,Position.Right);\n        }\n\n        return ptr;\n    }\n\n    public static TreeNode from(Integer[] arr) {\n        return from2(arr);\n\n    }\n\n    static int fromConsumeOne(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q, Position position) {\n        if (arr[ptr] == null) {\n            ptr++;\n        } else {\n            final var node = new TreeNode(arr[ptr++]);\n            q.add(node);\n            if (position == Position.Left) {\n                focus.left = node;\n            } else {\n                focus.right = node;\n            }\n        }\n        return ptr;\n    } \n```\n"
                    }
                ]
            },
            {
                "id": 2003829,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Pretty proud in March April.. I started learn for the first time traversals in trees and now I can approach these types of problems with a good thought what I should do, sometimes I take a peek if isn\\'t working, but wish I was again in my student years to grind this shit non-stop. "
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[1,1,1,1] and target sum 2 is a good test case."
                    },
                    {
                        "username": "TernyavskyIlya",
                        "content": "Where my fail?\\n `def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        def wrap(root, total):\\n            if not root.left and not root.right:\\n                print(total)\\n                if total == targetSum:\\n                    return False\\n            if root.left:\\n                wrap(root.left, total+root.left.val)\\n            if root.right:\\n                wrap(root.right, total+root.right.val)\\n            return True\\n        wrap(root, root.val)\\n`"
                    },
                    {
                        "username": "chahatgupta1060",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "the question has 117 testcases i have passed 99 testcase but my code is break while passing 100 number test case. the question asked you want to check that the binery tree path sum is equal of target sum. \"you should think about decrease the targetsum either think about increment "
                    },
                    {
                        "username": "kush512",
                        "content": "class Solution {\\npublic:\\n\\n    bool solve(TreeNode* root, int targetSum) {\\n        if(root==NULL && targetSum==0) return true;\\n        if(root==NULL) return false;\\n        bool l=hasPathSum(root->left, targetSum-root->val);\\n        bool r=hasPathSum(root->right, targetSum-root->val);\\n        return l || r;\\n    }\\n\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return false; \\n        else return solve(root,targetSum);\\n    }\\n};\\n\\nwhy is it not giving correct answer?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "There is a test case where root=[1,2], and target sum = 1, so it should return true but it expects false, which I can\\'t understand why. This is a weird test case."
                    },
                    {
                        "username": "sjames8888",
                        "content": "That\\u2019s a one sided tree where root 1 has one child 2 and leaf defined as no children nodes so path sum in this case is sum of 2 nodes. You have to include sum of 2 as this has no nodes so sum is 3 in this case "
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "testcase 70 has something issue there is expected output is true but while debug my code in visual studio then received correct output but leetcode has something issue"
                    },
                    {
                        "username": "batuczarny",
                        "content": "Why does this code not work? \\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n\\n        def check(root, curSum):\\n            if not root:\\n                return False\\n        \\n            if root.left is None and root.right is None and curSum==targetSum:\\n                return True\\n            \\n            left = check(root.left, curSum + root.val)\\n            right = check(root.right, curSum + root.val)\\n            \\n            return left or right\\n\\n        return check(root, 0) \\n\\n        "
                    },
                    {
                        "username": "1valeryvb",
                        "content": "curSum - root.val"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Parsing given array into tree - suggested Java\n\nthe following Java seems to parse correctly.  Probably not best but incase it is useful to somone\n\n```java\nfinal var root = TreeNode.from2(new Integer[]{5,4,8,11,null,13,4,7,2,null,null,null,1});\n```\n\n\n                    5\n                /       \\\n               4         8\n             /         /   \\\n           11        13     4\n           / \\               \\\n          7   2               1\n\n```java\n  public static TreeNode from2(Integer[] arr) {\n        if (arr.length == 0) {\n            return null;\n        }\n        var ptr = 0;\n        final var root = new TreeNode(arr[ptr++]);\n        final Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n\n        while (ptr < arr.length && !q.isEmpty()) {\n            final var size = q.size();\n            for (var i = 0; i < size; ++i) {\n                final var node = q.remove();\n                ptr = fromConsume(node, ptr, arr, q);\n            }\n        }\n\n        return root;\n    }\n\n    enum Position {\n        Left,\n        Right\n    }\n\n    public static int fromConsume(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q) {\n        if (ptr >= arr.length) return ptr;\n        if (focus == null) return ptr;\n\n        ptr  = fromConsumeOne(focus, ptr, arr,q, Position.Left);\n        if (ptr < arr.length) {\n            ptr  = fromConsumeOne(focus, ptr, arr,q,Position.Right);\n        }\n\n        return ptr;\n    }\n\n    public static TreeNode from(Integer[] arr) {\n        return from2(arr);\n\n    }\n\n    static int fromConsumeOne(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q, Position position) {\n        if (arr[ptr] == null) {\n            ptr++;\n        } else {\n            final var node = new TreeNode(arr[ptr++]);\n            q.add(node);\n            if (position == Position.Left) {\n                focus.left = node;\n            } else {\n                focus.right = node;\n            }\n        }\n        return ptr;\n    } \n```\n"
                    }
                ]
            },
            {
                "id": 1994356,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Pretty proud in March April.. I started learn for the first time traversals in trees and now I can approach these types of problems with a good thought what I should do, sometimes I take a peek if isn\\'t working, but wish I was again in my student years to grind this shit non-stop. "
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[1,1,1,1] and target sum 2 is a good test case."
                    },
                    {
                        "username": "TernyavskyIlya",
                        "content": "Where my fail?\\n `def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        def wrap(root, total):\\n            if not root.left and not root.right:\\n                print(total)\\n                if total == targetSum:\\n                    return False\\n            if root.left:\\n                wrap(root.left, total+root.left.val)\\n            if root.right:\\n                wrap(root.right, total+root.right.val)\\n            return True\\n        wrap(root, root.val)\\n`"
                    },
                    {
                        "username": "chahatgupta1060",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "the question has 117 testcases i have passed 99 testcase but my code is break while passing 100 number test case. the question asked you want to check that the binery tree path sum is equal of target sum. \"you should think about decrease the targetsum either think about increment "
                    },
                    {
                        "username": "kush512",
                        "content": "class Solution {\\npublic:\\n\\n    bool solve(TreeNode* root, int targetSum) {\\n        if(root==NULL && targetSum==0) return true;\\n        if(root==NULL) return false;\\n        bool l=hasPathSum(root->left, targetSum-root->val);\\n        bool r=hasPathSum(root->right, targetSum-root->val);\\n        return l || r;\\n    }\\n\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return false; \\n        else return solve(root,targetSum);\\n    }\\n};\\n\\nwhy is it not giving correct answer?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "There is a test case where root=[1,2], and target sum = 1, so it should return true but it expects false, which I can\\'t understand why. This is a weird test case."
                    },
                    {
                        "username": "sjames8888",
                        "content": "That\\u2019s a one sided tree where root 1 has one child 2 and leaf defined as no children nodes so path sum in this case is sum of 2 nodes. You have to include sum of 2 as this has no nodes so sum is 3 in this case "
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "testcase 70 has something issue there is expected output is true but while debug my code in visual studio then received correct output but leetcode has something issue"
                    },
                    {
                        "username": "batuczarny",
                        "content": "Why does this code not work? \\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n\\n        def check(root, curSum):\\n            if not root:\\n                return False\\n        \\n            if root.left is None and root.right is None and curSum==targetSum:\\n                return True\\n            \\n            left = check(root.left, curSum + root.val)\\n            right = check(root.right, curSum + root.val)\\n            \\n            return left or right\\n\\n        return check(root, 0) \\n\\n        "
                    },
                    {
                        "username": "1valeryvb",
                        "content": "curSum - root.val"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Parsing given array into tree - suggested Java\n\nthe following Java seems to parse correctly.  Probably not best but incase it is useful to somone\n\n```java\nfinal var root = TreeNode.from2(new Integer[]{5,4,8,11,null,13,4,7,2,null,null,null,1});\n```\n\n\n                    5\n                /       \\\n               4         8\n             /         /   \\\n           11        13     4\n           / \\               \\\n          7   2               1\n\n```java\n  public static TreeNode from2(Integer[] arr) {\n        if (arr.length == 0) {\n            return null;\n        }\n        var ptr = 0;\n        final var root = new TreeNode(arr[ptr++]);\n        final Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n\n        while (ptr < arr.length && !q.isEmpty()) {\n            final var size = q.size();\n            for (var i = 0; i < size; ++i) {\n                final var node = q.remove();\n                ptr = fromConsume(node, ptr, arr, q);\n            }\n        }\n\n        return root;\n    }\n\n    enum Position {\n        Left,\n        Right\n    }\n\n    public static int fromConsume(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q) {\n        if (ptr >= arr.length) return ptr;\n        if (focus == null) return ptr;\n\n        ptr  = fromConsumeOne(focus, ptr, arr,q, Position.Left);\n        if (ptr < arr.length) {\n            ptr  = fromConsumeOne(focus, ptr, arr,q,Position.Right);\n        }\n\n        return ptr;\n    }\n\n    public static TreeNode from(Integer[] arr) {\n        return from2(arr);\n\n    }\n\n    static int fromConsumeOne(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q, Position position) {\n        if (arr[ptr] == null) {\n            ptr++;\n        } else {\n            final var node = new TreeNode(arr[ptr++]);\n            q.add(node);\n            if (position == Position.Left) {\n                focus.left = node;\n            } else {\n                focus.right = node;\n            }\n        }\n        return ptr;\n    } \n```\n"
                    }
                ]
            },
            {
                "id": 1990034,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Pretty proud in March April.. I started learn for the first time traversals in trees and now I can approach these types of problems with a good thought what I should do, sometimes I take a peek if isn\\'t working, but wish I was again in my student years to grind this shit non-stop. "
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[1,1,1,1] and target sum 2 is a good test case."
                    },
                    {
                        "username": "TernyavskyIlya",
                        "content": "Where my fail?\\n `def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        def wrap(root, total):\\n            if not root.left and not root.right:\\n                print(total)\\n                if total == targetSum:\\n                    return False\\n            if root.left:\\n                wrap(root.left, total+root.left.val)\\n            if root.right:\\n                wrap(root.right, total+root.right.val)\\n            return True\\n        wrap(root, root.val)\\n`"
                    },
                    {
                        "username": "chahatgupta1060",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "the question has 117 testcases i have passed 99 testcase but my code is break while passing 100 number test case. the question asked you want to check that the binery tree path sum is equal of target sum. \"you should think about decrease the targetsum either think about increment "
                    },
                    {
                        "username": "kush512",
                        "content": "class Solution {\\npublic:\\n\\n    bool solve(TreeNode* root, int targetSum) {\\n        if(root==NULL && targetSum==0) return true;\\n        if(root==NULL) return false;\\n        bool l=hasPathSum(root->left, targetSum-root->val);\\n        bool r=hasPathSum(root->right, targetSum-root->val);\\n        return l || r;\\n    }\\n\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return false; \\n        else return solve(root,targetSum);\\n    }\\n};\\n\\nwhy is it not giving correct answer?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "There is a test case where root=[1,2], and target sum = 1, so it should return true but it expects false, which I can\\'t understand why. This is a weird test case."
                    },
                    {
                        "username": "sjames8888",
                        "content": "That\\u2019s a one sided tree where root 1 has one child 2 and leaf defined as no children nodes so path sum in this case is sum of 2 nodes. You have to include sum of 2 as this has no nodes so sum is 3 in this case "
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "testcase 70 has something issue there is expected output is true but while debug my code in visual studio then received correct output but leetcode has something issue"
                    },
                    {
                        "username": "batuczarny",
                        "content": "Why does this code not work? \\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n\\n        def check(root, curSum):\\n            if not root:\\n                return False\\n        \\n            if root.left is None and root.right is None and curSum==targetSum:\\n                return True\\n            \\n            left = check(root.left, curSum + root.val)\\n            right = check(root.right, curSum + root.val)\\n            \\n            return left or right\\n\\n        return check(root, 0) \\n\\n        "
                    },
                    {
                        "username": "1valeryvb",
                        "content": "curSum - root.val"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Parsing given array into tree - suggested Java\n\nthe following Java seems to parse correctly.  Probably not best but incase it is useful to somone\n\n```java\nfinal var root = TreeNode.from2(new Integer[]{5,4,8,11,null,13,4,7,2,null,null,null,1});\n```\n\n\n                    5\n                /       \\\n               4         8\n             /         /   \\\n           11        13     4\n           / \\               \\\n          7   2               1\n\n```java\n  public static TreeNode from2(Integer[] arr) {\n        if (arr.length == 0) {\n            return null;\n        }\n        var ptr = 0;\n        final var root = new TreeNode(arr[ptr++]);\n        final Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n\n        while (ptr < arr.length && !q.isEmpty()) {\n            final var size = q.size();\n            for (var i = 0; i < size; ++i) {\n                final var node = q.remove();\n                ptr = fromConsume(node, ptr, arr, q);\n            }\n        }\n\n        return root;\n    }\n\n    enum Position {\n        Left,\n        Right\n    }\n\n    public static int fromConsume(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q) {\n        if (ptr >= arr.length) return ptr;\n        if (focus == null) return ptr;\n\n        ptr  = fromConsumeOne(focus, ptr, arr,q, Position.Left);\n        if (ptr < arr.length) {\n            ptr  = fromConsumeOne(focus, ptr, arr,q,Position.Right);\n        }\n\n        return ptr;\n    }\n\n    public static TreeNode from(Integer[] arr) {\n        return from2(arr);\n\n    }\n\n    static int fromConsumeOne(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q, Position position) {\n        if (arr[ptr] == null) {\n            ptr++;\n        } else {\n            final var node = new TreeNode(arr[ptr++]);\n            q.add(node);\n            if (position == Position.Left) {\n                focus.left = node;\n            } else {\n                focus.right = node;\n            }\n        }\n        return ptr;\n    } \n```\n"
                    }
                ]
            },
            {
                "id": 1972828,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Pretty proud in March April.. I started learn for the first time traversals in trees and now I can approach these types of problems with a good thought what I should do, sometimes I take a peek if isn\\'t working, but wish I was again in my student years to grind this shit non-stop. "
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[1,1,1,1] and target sum 2 is a good test case."
                    },
                    {
                        "username": "TernyavskyIlya",
                        "content": "Where my fail?\\n `def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        def wrap(root, total):\\n            if not root.left and not root.right:\\n                print(total)\\n                if total == targetSum:\\n                    return False\\n            if root.left:\\n                wrap(root.left, total+root.left.val)\\n            if root.right:\\n                wrap(root.right, total+root.right.val)\\n            return True\\n        wrap(root, root.val)\\n`"
                    },
                    {
                        "username": "chahatgupta1060",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "the question has 117 testcases i have passed 99 testcase but my code is break while passing 100 number test case. the question asked you want to check that the binery tree path sum is equal of target sum. \"you should think about decrease the targetsum either think about increment "
                    },
                    {
                        "username": "kush512",
                        "content": "class Solution {\\npublic:\\n\\n    bool solve(TreeNode* root, int targetSum) {\\n        if(root==NULL && targetSum==0) return true;\\n        if(root==NULL) return false;\\n        bool l=hasPathSum(root->left, targetSum-root->val);\\n        bool r=hasPathSum(root->right, targetSum-root->val);\\n        return l || r;\\n    }\\n\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return false; \\n        else return solve(root,targetSum);\\n    }\\n};\\n\\nwhy is it not giving correct answer?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "There is a test case where root=[1,2], and target sum = 1, so it should return true but it expects false, which I can\\'t understand why. This is a weird test case."
                    },
                    {
                        "username": "sjames8888",
                        "content": "That\\u2019s a one sided tree where root 1 has one child 2 and leaf defined as no children nodes so path sum in this case is sum of 2 nodes. You have to include sum of 2 as this has no nodes so sum is 3 in this case "
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "testcase 70 has something issue there is expected output is true but while debug my code in visual studio then received correct output but leetcode has something issue"
                    },
                    {
                        "username": "batuczarny",
                        "content": "Why does this code not work? \\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n\\n        def check(root, curSum):\\n            if not root:\\n                return False\\n        \\n            if root.left is None and root.right is None and curSum==targetSum:\\n                return True\\n            \\n            left = check(root.left, curSum + root.val)\\n            right = check(root.right, curSum + root.val)\\n            \\n            return left or right\\n\\n        return check(root, 0) \\n\\n        "
                    },
                    {
                        "username": "1valeryvb",
                        "content": "curSum - root.val"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Parsing given array into tree - suggested Java\n\nthe following Java seems to parse correctly.  Probably not best but incase it is useful to somone\n\n```java\nfinal var root = TreeNode.from2(new Integer[]{5,4,8,11,null,13,4,7,2,null,null,null,1});\n```\n\n\n                    5\n                /       \\\n               4         8\n             /         /   \\\n           11        13     4\n           / \\               \\\n          7   2               1\n\n```java\n  public static TreeNode from2(Integer[] arr) {\n        if (arr.length == 0) {\n            return null;\n        }\n        var ptr = 0;\n        final var root = new TreeNode(arr[ptr++]);\n        final Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n\n        while (ptr < arr.length && !q.isEmpty()) {\n            final var size = q.size();\n            for (var i = 0; i < size; ++i) {\n                final var node = q.remove();\n                ptr = fromConsume(node, ptr, arr, q);\n            }\n        }\n\n        return root;\n    }\n\n    enum Position {\n        Left,\n        Right\n    }\n\n    public static int fromConsume(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q) {\n        if (ptr >= arr.length) return ptr;\n        if (focus == null) return ptr;\n\n        ptr  = fromConsumeOne(focus, ptr, arr,q, Position.Left);\n        if (ptr < arr.length) {\n            ptr  = fromConsumeOne(focus, ptr, arr,q,Position.Right);\n        }\n\n        return ptr;\n    }\n\n    public static TreeNode from(Integer[] arr) {\n        return from2(arr);\n\n    }\n\n    static int fromConsumeOne(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q, Position position) {\n        if (arr[ptr] == null) {\n            ptr++;\n        } else {\n            final var node = new TreeNode(arr[ptr++]);\n            q.add(node);\n            if (position == Position.Left) {\n                focus.left = node;\n            } else {\n                focus.right = node;\n            }\n        }\n        return ptr;\n    } \n```\n"
                    }
                ]
            },
            {
                "id": 1891414,
                "content": [
                    {
                        "username": "divyapbagul",
                        "content": "var hasPathSum = function(root, targetSum) {\\n  root = [1,2,3];\\n  targetSum = 5;\\n    var arr =[];\\n      for(var i = 0;i < root.length;i++){\\n          arr[i] = root[i];\\n        //   console.log(arr);\\n          if(arr.length > 1){\\n              var result = arr[0] + arr[1] ;\\n              var result2 = arr[0] + arr[2] ;\\n                if(result == targetSum){\\n                    console.log(result);\\n                    return true;\\n                    \\n                }else if(result2 == targetSum){\\n                    console.log(result2);\\n                    return true;\\n                }else{\\n                    return false;\\n                }\\n             \\n          }\\n      }\\n             \\n          \\n      \\n\\n};\\nhasPathSum([1,2,3],5);"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "thatCoderGirl",
                        "content": "I think there are few incorrect test cases in this question. \\n\\nCase 1: root =[1] , targetSum = 1, expects answer to be true.\\nCase 2: root =[1, 2] , targetSum = 1, expects answer to be false.\\n\\nAre we considering a solution only if it has a root-to-leaf path , or just root as the path also works ? If we are allowing just root also as the answer, then why in case 2, just root is not an answer ?\\n"
                    },
                    {
                        "username": "sujan_mandal",
                        "content": "root = [1,-2,-3,1,3,-2,null,-1]\\ntarget sum = -1\\nhow can this be true?"
                    },
                    {
                        "username": "Ijkeller",
                        "content": "Do we need to construct the tree within the function?  Also, is the input actually an array or is it the root node in a binary tree?"
                    },
                    {
                        "username": "AyushGupta2114",
                        "content": "can somebody tell what is the error in this \\n\\n\\n `\\'class Solution {\\npublic:\\n    long ans=0;\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL)\\n            return false;\\n        return preorder(root,targetSum,ans);\\n    }\\n    bool preorder(TreeNode *root, long targetSum,long ans)\\n    {\\n\\n        if(root!=NULL)\\n        {\\n         ans+=root->val;\\n         cout<<ans<<endl;\\n         if(ans==targetSum)\\n                return true;\\n        preorder(root->left,targetSum,ans);\\n        preorder(root->right,targetSum,ans);\\n        }\\n        return false;\\n    }\\n};.``\\n\\nfor test case 1 getting false\\nbut by cout getting this \\n5\\n9\\n20\\n27\\n22\\n13\\n26\\n17\\n18"
                    },
                    {
                        "username": "ScientificX",
                        "content": "Please why doesnt this code pass all test cases \n\n `your inline code...your inline code...`\n\n `..class Solution:\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\n        if not root: return 0\n        ans = False\n        def solve(node, path):\n            nonlocal ans\n            if not node:\n                ans = ans or (sum(path) == targetSum)\n                return\n\n            solve(node.right, path + [node.val])\n            solve(node.left, path + [node.val])\n\n        solve(root, [])\n        return ans.`"
                    },
                    {
                        "username": "sachin2000",
                        "content": "In my first attempt , i cleared 100 test cases but then it got wrong answer in below test case :\n[1,2] \noutput = true;\nexpected output false;\n\nThen I read the question again and found that the sum must be root to leaf not in between .\n\nfor more details find below: \nhttps://leetcode.com/problems/path-sum/submissions/890816375/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/path-sum/solutions/3049936/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "rahulseith",
                        "content": "why A. [1,2] target = 1 : expected is false B.  [1] : target as 1  has expected ans as true.\\nthese two are contradictory"
                    },
                    {
                        "username": "shin_98",
                        "content": "Those are two different situations. As statet in description *A leaf is a node with no children*.\n`[1,2]` - in this situation root with value \"1\" is not a *leaf* because it has left child with value 2. So only path from root to leaf is from 1 to 2. Thus there is only one path with sum 3 = 1 + 2\n3 != 1 (target) so it is expected to be False.\n`[1]` - in this situation root is also a leaf because it has no children. So path from root to leaf has only one step with sum 1\n1 == 1 (target) so it is expected to be True."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            },
            {
                "id": 1875137,
                "content": [
                    {
                        "username": "divyapbagul",
                        "content": "var hasPathSum = function(root, targetSum) {\\n  root = [1,2,3];\\n  targetSum = 5;\\n    var arr =[];\\n      for(var i = 0;i < root.length;i++){\\n          arr[i] = root[i];\\n        //   console.log(arr);\\n          if(arr.length > 1){\\n              var result = arr[0] + arr[1] ;\\n              var result2 = arr[0] + arr[2] ;\\n                if(result == targetSum){\\n                    console.log(result);\\n                    return true;\\n                    \\n                }else if(result2 == targetSum){\\n                    console.log(result2);\\n                    return true;\\n                }else{\\n                    return false;\\n                }\\n             \\n          }\\n      }\\n             \\n          \\n      \\n\\n};\\nhasPathSum([1,2,3],5);"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "thatCoderGirl",
                        "content": "I think there are few incorrect test cases in this question. \\n\\nCase 1: root =[1] , targetSum = 1, expects answer to be true.\\nCase 2: root =[1, 2] , targetSum = 1, expects answer to be false.\\n\\nAre we considering a solution only if it has a root-to-leaf path , or just root as the path also works ? If we are allowing just root also as the answer, then why in case 2, just root is not an answer ?\\n"
                    },
                    {
                        "username": "sujan_mandal",
                        "content": "root = [1,-2,-3,1,3,-2,null,-1]\\ntarget sum = -1\\nhow can this be true?"
                    },
                    {
                        "username": "Ijkeller",
                        "content": "Do we need to construct the tree within the function?  Also, is the input actually an array or is it the root node in a binary tree?"
                    },
                    {
                        "username": "AyushGupta2114",
                        "content": "can somebody tell what is the error in this \\n\\n\\n `\\'class Solution {\\npublic:\\n    long ans=0;\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL)\\n            return false;\\n        return preorder(root,targetSum,ans);\\n    }\\n    bool preorder(TreeNode *root, long targetSum,long ans)\\n    {\\n\\n        if(root!=NULL)\\n        {\\n         ans+=root->val;\\n         cout<<ans<<endl;\\n         if(ans==targetSum)\\n                return true;\\n        preorder(root->left,targetSum,ans);\\n        preorder(root->right,targetSum,ans);\\n        }\\n        return false;\\n    }\\n};.``\\n\\nfor test case 1 getting false\\nbut by cout getting this \\n5\\n9\\n20\\n27\\n22\\n13\\n26\\n17\\n18"
                    },
                    {
                        "username": "ScientificX",
                        "content": "Please why doesnt this code pass all test cases \n\n `your inline code...your inline code...`\n\n `..class Solution:\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\n        if not root: return 0\n        ans = False\n        def solve(node, path):\n            nonlocal ans\n            if not node:\n                ans = ans or (sum(path) == targetSum)\n                return\n\n            solve(node.right, path + [node.val])\n            solve(node.left, path + [node.val])\n\n        solve(root, [])\n        return ans.`"
                    },
                    {
                        "username": "sachin2000",
                        "content": "In my first attempt , i cleared 100 test cases but then it got wrong answer in below test case :\n[1,2] \noutput = true;\nexpected output false;\n\nThen I read the question again and found that the sum must be root to leaf not in between .\n\nfor more details find below: \nhttps://leetcode.com/problems/path-sum/submissions/890816375/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/path-sum/solutions/3049936/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "rahulseith",
                        "content": "why A. [1,2] target = 1 : expected is false B.  [1] : target as 1  has expected ans as true.\\nthese two are contradictory"
                    },
                    {
                        "username": "shin_98",
                        "content": "Those are two different situations. As statet in description *A leaf is a node with no children*.\n`[1,2]` - in this situation root with value \"1\" is not a *leaf* because it has left child with value 2. So only path from root to leaf is from 1 to 2. Thus there is only one path with sum 3 = 1 + 2\n3 != 1 (target) so it is expected to be False.\n`[1]` - in this situation root is also a leaf because it has no children. So path from root to leaf has only one step with sum 1\n1 == 1 (target) so it is expected to be True."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            },
            {
                "id": 1847826,
                "content": [
                    {
                        "username": "divyapbagul",
                        "content": "var hasPathSum = function(root, targetSum) {\\n  root = [1,2,3];\\n  targetSum = 5;\\n    var arr =[];\\n      for(var i = 0;i < root.length;i++){\\n          arr[i] = root[i];\\n        //   console.log(arr);\\n          if(arr.length > 1){\\n              var result = arr[0] + arr[1] ;\\n              var result2 = arr[0] + arr[2] ;\\n                if(result == targetSum){\\n                    console.log(result);\\n                    return true;\\n                    \\n                }else if(result2 == targetSum){\\n                    console.log(result2);\\n                    return true;\\n                }else{\\n                    return false;\\n                }\\n             \\n          }\\n      }\\n             \\n          \\n      \\n\\n};\\nhasPathSum([1,2,3],5);"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "thatCoderGirl",
                        "content": "I think there are few incorrect test cases in this question. \\n\\nCase 1: root =[1] , targetSum = 1, expects answer to be true.\\nCase 2: root =[1, 2] , targetSum = 1, expects answer to be false.\\n\\nAre we considering a solution only if it has a root-to-leaf path , or just root as the path also works ? If we are allowing just root also as the answer, then why in case 2, just root is not an answer ?\\n"
                    },
                    {
                        "username": "sujan_mandal",
                        "content": "root = [1,-2,-3,1,3,-2,null,-1]\\ntarget sum = -1\\nhow can this be true?"
                    },
                    {
                        "username": "Ijkeller",
                        "content": "Do we need to construct the tree within the function?  Also, is the input actually an array or is it the root node in a binary tree?"
                    },
                    {
                        "username": "AyushGupta2114",
                        "content": "can somebody tell what is the error in this \\n\\n\\n `\\'class Solution {\\npublic:\\n    long ans=0;\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL)\\n            return false;\\n        return preorder(root,targetSum,ans);\\n    }\\n    bool preorder(TreeNode *root, long targetSum,long ans)\\n    {\\n\\n        if(root!=NULL)\\n        {\\n         ans+=root->val;\\n         cout<<ans<<endl;\\n         if(ans==targetSum)\\n                return true;\\n        preorder(root->left,targetSum,ans);\\n        preorder(root->right,targetSum,ans);\\n        }\\n        return false;\\n    }\\n};.``\\n\\nfor test case 1 getting false\\nbut by cout getting this \\n5\\n9\\n20\\n27\\n22\\n13\\n26\\n17\\n18"
                    },
                    {
                        "username": "ScientificX",
                        "content": "Please why doesnt this code pass all test cases \n\n `your inline code...your inline code...`\n\n `..class Solution:\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\n        if not root: return 0\n        ans = False\n        def solve(node, path):\n            nonlocal ans\n            if not node:\n                ans = ans or (sum(path) == targetSum)\n                return\n\n            solve(node.right, path + [node.val])\n            solve(node.left, path + [node.val])\n\n        solve(root, [])\n        return ans.`"
                    },
                    {
                        "username": "sachin2000",
                        "content": "In my first attempt , i cleared 100 test cases but then it got wrong answer in below test case :\n[1,2] \noutput = true;\nexpected output false;\n\nThen I read the question again and found that the sum must be root to leaf not in between .\n\nfor more details find below: \nhttps://leetcode.com/problems/path-sum/submissions/890816375/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/path-sum/solutions/3049936/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "rahulseith",
                        "content": "why A. [1,2] target = 1 : expected is false B.  [1] : target as 1  has expected ans as true.\\nthese two are contradictory"
                    },
                    {
                        "username": "shin_98",
                        "content": "Those are two different situations. As statet in description *A leaf is a node with no children*.\n`[1,2]` - in this situation root with value \"1\" is not a *leaf* because it has left child with value 2. So only path from root to leaf is from 1 to 2. Thus there is only one path with sum 3 = 1 + 2\n3 != 1 (target) so it is expected to be False.\n`[1]` - in this situation root is also a leaf because it has no children. So path from root to leaf has only one step with sum 1\n1 == 1 (target) so it is expected to be True."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            },
            {
                "id": 1839802,
                "content": [
                    {
                        "username": "divyapbagul",
                        "content": "var hasPathSum = function(root, targetSum) {\\n  root = [1,2,3];\\n  targetSum = 5;\\n    var arr =[];\\n      for(var i = 0;i < root.length;i++){\\n          arr[i] = root[i];\\n        //   console.log(arr);\\n          if(arr.length > 1){\\n              var result = arr[0] + arr[1] ;\\n              var result2 = arr[0] + arr[2] ;\\n                if(result == targetSum){\\n                    console.log(result);\\n                    return true;\\n                    \\n                }else if(result2 == targetSum){\\n                    console.log(result2);\\n                    return true;\\n                }else{\\n                    return false;\\n                }\\n             \\n          }\\n      }\\n             \\n          \\n      \\n\\n};\\nhasPathSum([1,2,3],5);"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "thatCoderGirl",
                        "content": "I think there are few incorrect test cases in this question. \\n\\nCase 1: root =[1] , targetSum = 1, expects answer to be true.\\nCase 2: root =[1, 2] , targetSum = 1, expects answer to be false.\\n\\nAre we considering a solution only if it has a root-to-leaf path , or just root as the path also works ? If we are allowing just root also as the answer, then why in case 2, just root is not an answer ?\\n"
                    },
                    {
                        "username": "sujan_mandal",
                        "content": "root = [1,-2,-3,1,3,-2,null,-1]\\ntarget sum = -1\\nhow can this be true?"
                    },
                    {
                        "username": "Ijkeller",
                        "content": "Do we need to construct the tree within the function?  Also, is the input actually an array or is it the root node in a binary tree?"
                    },
                    {
                        "username": "AyushGupta2114",
                        "content": "can somebody tell what is the error in this \\n\\n\\n `\\'class Solution {\\npublic:\\n    long ans=0;\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL)\\n            return false;\\n        return preorder(root,targetSum,ans);\\n    }\\n    bool preorder(TreeNode *root, long targetSum,long ans)\\n    {\\n\\n        if(root!=NULL)\\n        {\\n         ans+=root->val;\\n         cout<<ans<<endl;\\n         if(ans==targetSum)\\n                return true;\\n        preorder(root->left,targetSum,ans);\\n        preorder(root->right,targetSum,ans);\\n        }\\n        return false;\\n    }\\n};.``\\n\\nfor test case 1 getting false\\nbut by cout getting this \\n5\\n9\\n20\\n27\\n22\\n13\\n26\\n17\\n18"
                    },
                    {
                        "username": "ScientificX",
                        "content": "Please why doesnt this code pass all test cases \n\n `your inline code...your inline code...`\n\n `..class Solution:\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\n        if not root: return 0\n        ans = False\n        def solve(node, path):\n            nonlocal ans\n            if not node:\n                ans = ans or (sum(path) == targetSum)\n                return\n\n            solve(node.right, path + [node.val])\n            solve(node.left, path + [node.val])\n\n        solve(root, [])\n        return ans.`"
                    },
                    {
                        "username": "sachin2000",
                        "content": "In my first attempt , i cleared 100 test cases but then it got wrong answer in below test case :\n[1,2] \noutput = true;\nexpected output false;\n\nThen I read the question again and found that the sum must be root to leaf not in between .\n\nfor more details find below: \nhttps://leetcode.com/problems/path-sum/submissions/890816375/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/path-sum/solutions/3049936/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "rahulseith",
                        "content": "why A. [1,2] target = 1 : expected is false B.  [1] : target as 1  has expected ans as true.\\nthese two are contradictory"
                    },
                    {
                        "username": "shin_98",
                        "content": "Those are two different situations. As statet in description *A leaf is a node with no children*.\n`[1,2]` - in this situation root with value \"1\" is not a *leaf* because it has left child with value 2. So only path from root to leaf is from 1 to 2. Thus there is only one path with sum 3 = 1 + 2\n3 != 1 (target) so it is expected to be False.\n`[1]` - in this situation root is also a leaf because it has no children. So path from root to leaf has only one step with sum 1\n1 == 1 (target) so it is expected to be True."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            },
            {
                "id": 1833547,
                "content": [
                    {
                        "username": "divyapbagul",
                        "content": "var hasPathSum = function(root, targetSum) {\\n  root = [1,2,3];\\n  targetSum = 5;\\n    var arr =[];\\n      for(var i = 0;i < root.length;i++){\\n          arr[i] = root[i];\\n        //   console.log(arr);\\n          if(arr.length > 1){\\n              var result = arr[0] + arr[1] ;\\n              var result2 = arr[0] + arr[2] ;\\n                if(result == targetSum){\\n                    console.log(result);\\n                    return true;\\n                    \\n                }else if(result2 == targetSum){\\n                    console.log(result2);\\n                    return true;\\n                }else{\\n                    return false;\\n                }\\n             \\n          }\\n      }\\n             \\n          \\n      \\n\\n};\\nhasPathSum([1,2,3],5);"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "thatCoderGirl",
                        "content": "I think there are few incorrect test cases in this question. \\n\\nCase 1: root =[1] , targetSum = 1, expects answer to be true.\\nCase 2: root =[1, 2] , targetSum = 1, expects answer to be false.\\n\\nAre we considering a solution only if it has a root-to-leaf path , or just root as the path also works ? If we are allowing just root also as the answer, then why in case 2, just root is not an answer ?\\n"
                    },
                    {
                        "username": "sujan_mandal",
                        "content": "root = [1,-2,-3,1,3,-2,null,-1]\\ntarget sum = -1\\nhow can this be true?"
                    },
                    {
                        "username": "Ijkeller",
                        "content": "Do we need to construct the tree within the function?  Also, is the input actually an array or is it the root node in a binary tree?"
                    },
                    {
                        "username": "AyushGupta2114",
                        "content": "can somebody tell what is the error in this \\n\\n\\n `\\'class Solution {\\npublic:\\n    long ans=0;\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL)\\n            return false;\\n        return preorder(root,targetSum,ans);\\n    }\\n    bool preorder(TreeNode *root, long targetSum,long ans)\\n    {\\n\\n        if(root!=NULL)\\n        {\\n         ans+=root->val;\\n         cout<<ans<<endl;\\n         if(ans==targetSum)\\n                return true;\\n        preorder(root->left,targetSum,ans);\\n        preorder(root->right,targetSum,ans);\\n        }\\n        return false;\\n    }\\n};.``\\n\\nfor test case 1 getting false\\nbut by cout getting this \\n5\\n9\\n20\\n27\\n22\\n13\\n26\\n17\\n18"
                    },
                    {
                        "username": "ScientificX",
                        "content": "Please why doesnt this code pass all test cases \n\n `your inline code...your inline code...`\n\n `..class Solution:\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\n        if not root: return 0\n        ans = False\n        def solve(node, path):\n            nonlocal ans\n            if not node:\n                ans = ans or (sum(path) == targetSum)\n                return\n\n            solve(node.right, path + [node.val])\n            solve(node.left, path + [node.val])\n\n        solve(root, [])\n        return ans.`"
                    },
                    {
                        "username": "sachin2000",
                        "content": "In my first attempt , i cleared 100 test cases but then it got wrong answer in below test case :\n[1,2] \noutput = true;\nexpected output false;\n\nThen I read the question again and found that the sum must be root to leaf not in between .\n\nfor more details find below: \nhttps://leetcode.com/problems/path-sum/submissions/890816375/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/path-sum/solutions/3049936/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "rahulseith",
                        "content": "why A. [1,2] target = 1 : expected is false B.  [1] : target as 1  has expected ans as true.\\nthese two are contradictory"
                    },
                    {
                        "username": "shin_98",
                        "content": "Those are two different situations. As statet in description *A leaf is a node with no children*.\n`[1,2]` - in this situation root with value \"1\" is not a *leaf* because it has left child with value 2. So only path from root to leaf is from 1 to 2. Thus there is only one path with sum 3 = 1 + 2\n3 != 1 (target) so it is expected to be False.\n`[1]` - in this situation root is also a leaf because it has no children. So path from root to leaf has only one step with sum 1\n1 == 1 (target) so it is expected to be True."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            },
            {
                "id": 1830752,
                "content": [
                    {
                        "username": "divyapbagul",
                        "content": "var hasPathSum = function(root, targetSum) {\\n  root = [1,2,3];\\n  targetSum = 5;\\n    var arr =[];\\n      for(var i = 0;i < root.length;i++){\\n          arr[i] = root[i];\\n        //   console.log(arr);\\n          if(arr.length > 1){\\n              var result = arr[0] + arr[1] ;\\n              var result2 = arr[0] + arr[2] ;\\n                if(result == targetSum){\\n                    console.log(result);\\n                    return true;\\n                    \\n                }else if(result2 == targetSum){\\n                    console.log(result2);\\n                    return true;\\n                }else{\\n                    return false;\\n                }\\n             \\n          }\\n      }\\n             \\n          \\n      \\n\\n};\\nhasPathSum([1,2,3],5);"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "thatCoderGirl",
                        "content": "I think there are few incorrect test cases in this question. \\n\\nCase 1: root =[1] , targetSum = 1, expects answer to be true.\\nCase 2: root =[1, 2] , targetSum = 1, expects answer to be false.\\n\\nAre we considering a solution only if it has a root-to-leaf path , or just root as the path also works ? If we are allowing just root also as the answer, then why in case 2, just root is not an answer ?\\n"
                    },
                    {
                        "username": "sujan_mandal",
                        "content": "root = [1,-2,-3,1,3,-2,null,-1]\\ntarget sum = -1\\nhow can this be true?"
                    },
                    {
                        "username": "Ijkeller",
                        "content": "Do we need to construct the tree within the function?  Also, is the input actually an array or is it the root node in a binary tree?"
                    },
                    {
                        "username": "AyushGupta2114",
                        "content": "can somebody tell what is the error in this \\n\\n\\n `\\'class Solution {\\npublic:\\n    long ans=0;\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL)\\n            return false;\\n        return preorder(root,targetSum,ans);\\n    }\\n    bool preorder(TreeNode *root, long targetSum,long ans)\\n    {\\n\\n        if(root!=NULL)\\n        {\\n         ans+=root->val;\\n         cout<<ans<<endl;\\n         if(ans==targetSum)\\n                return true;\\n        preorder(root->left,targetSum,ans);\\n        preorder(root->right,targetSum,ans);\\n        }\\n        return false;\\n    }\\n};.``\\n\\nfor test case 1 getting false\\nbut by cout getting this \\n5\\n9\\n20\\n27\\n22\\n13\\n26\\n17\\n18"
                    },
                    {
                        "username": "ScientificX",
                        "content": "Please why doesnt this code pass all test cases \n\n `your inline code...your inline code...`\n\n `..class Solution:\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\n        if not root: return 0\n        ans = False\n        def solve(node, path):\n            nonlocal ans\n            if not node:\n                ans = ans or (sum(path) == targetSum)\n                return\n\n            solve(node.right, path + [node.val])\n            solve(node.left, path + [node.val])\n\n        solve(root, [])\n        return ans.`"
                    },
                    {
                        "username": "sachin2000",
                        "content": "In my first attempt , i cleared 100 test cases but then it got wrong answer in below test case :\n[1,2] \noutput = true;\nexpected output false;\n\nThen I read the question again and found that the sum must be root to leaf not in between .\n\nfor more details find below: \nhttps://leetcode.com/problems/path-sum/submissions/890816375/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/path-sum/solutions/3049936/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "rahulseith",
                        "content": "why A. [1,2] target = 1 : expected is false B.  [1] : target as 1  has expected ans as true.\\nthese two are contradictory"
                    },
                    {
                        "username": "shin_98",
                        "content": "Those are two different situations. As statet in description *A leaf is a node with no children*.\n`[1,2]` - in this situation root with value \"1\" is not a *leaf* because it has left child with value 2. So only path from root to leaf is from 1 to 2. Thus there is only one path with sum 3 = 1 + 2\n3 != 1 (target) so it is expected to be False.\n`[1]` - in this situation root is also a leaf because it has no children. So path from root to leaf has only one step with sum 1\n1 == 1 (target) so it is expected to be True."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            },
            {
                "id": 1786313,
                "content": [
                    {
                        "username": "divyapbagul",
                        "content": "var hasPathSum = function(root, targetSum) {\\n  root = [1,2,3];\\n  targetSum = 5;\\n    var arr =[];\\n      for(var i = 0;i < root.length;i++){\\n          arr[i] = root[i];\\n        //   console.log(arr);\\n          if(arr.length > 1){\\n              var result = arr[0] + arr[1] ;\\n              var result2 = arr[0] + arr[2] ;\\n                if(result == targetSum){\\n                    console.log(result);\\n                    return true;\\n                    \\n                }else if(result2 == targetSum){\\n                    console.log(result2);\\n                    return true;\\n                }else{\\n                    return false;\\n                }\\n             \\n          }\\n      }\\n             \\n          \\n      \\n\\n};\\nhasPathSum([1,2,3],5);"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "thatCoderGirl",
                        "content": "I think there are few incorrect test cases in this question. \\n\\nCase 1: root =[1] , targetSum = 1, expects answer to be true.\\nCase 2: root =[1, 2] , targetSum = 1, expects answer to be false.\\n\\nAre we considering a solution only if it has a root-to-leaf path , or just root as the path also works ? If we are allowing just root also as the answer, then why in case 2, just root is not an answer ?\\n"
                    },
                    {
                        "username": "sujan_mandal",
                        "content": "root = [1,-2,-3,1,3,-2,null,-1]\\ntarget sum = -1\\nhow can this be true?"
                    },
                    {
                        "username": "Ijkeller",
                        "content": "Do we need to construct the tree within the function?  Also, is the input actually an array or is it the root node in a binary tree?"
                    },
                    {
                        "username": "AyushGupta2114",
                        "content": "can somebody tell what is the error in this \\n\\n\\n `\\'class Solution {\\npublic:\\n    long ans=0;\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL)\\n            return false;\\n        return preorder(root,targetSum,ans);\\n    }\\n    bool preorder(TreeNode *root, long targetSum,long ans)\\n    {\\n\\n        if(root!=NULL)\\n        {\\n         ans+=root->val;\\n         cout<<ans<<endl;\\n         if(ans==targetSum)\\n                return true;\\n        preorder(root->left,targetSum,ans);\\n        preorder(root->right,targetSum,ans);\\n        }\\n        return false;\\n    }\\n};.``\\n\\nfor test case 1 getting false\\nbut by cout getting this \\n5\\n9\\n20\\n27\\n22\\n13\\n26\\n17\\n18"
                    },
                    {
                        "username": "ScientificX",
                        "content": "Please why doesnt this code pass all test cases \n\n `your inline code...your inline code...`\n\n `..class Solution:\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\n        if not root: return 0\n        ans = False\n        def solve(node, path):\n            nonlocal ans\n            if not node:\n                ans = ans or (sum(path) == targetSum)\n                return\n\n            solve(node.right, path + [node.val])\n            solve(node.left, path + [node.val])\n\n        solve(root, [])\n        return ans.`"
                    },
                    {
                        "username": "sachin2000",
                        "content": "In my first attempt , i cleared 100 test cases but then it got wrong answer in below test case :\n[1,2] \noutput = true;\nexpected output false;\n\nThen I read the question again and found that the sum must be root to leaf not in between .\n\nfor more details find below: \nhttps://leetcode.com/problems/path-sum/submissions/890816375/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/path-sum/solutions/3049936/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "rahulseith",
                        "content": "why A. [1,2] target = 1 : expected is false B.  [1] : target as 1  has expected ans as true.\\nthese two are contradictory"
                    },
                    {
                        "username": "shin_98",
                        "content": "Those are two different situations. As statet in description *A leaf is a node with no children*.\n`[1,2]` - in this situation root with value \"1\" is not a *leaf* because it has left child with value 2. So only path from root to leaf is from 1 to 2. Thus there is only one path with sum 3 = 1 + 2\n3 != 1 (target) so it is expected to be False.\n`[1]` - in this situation root is also a leaf because it has no children. So path from root to leaf has only one step with sum 1\n1 == 1 (target) so it is expected to be True."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            },
            {
                "id": 1757501,
                "content": [
                    {
                        "username": "divyapbagul",
                        "content": "var hasPathSum = function(root, targetSum) {\\n  root = [1,2,3];\\n  targetSum = 5;\\n    var arr =[];\\n      for(var i = 0;i < root.length;i++){\\n          arr[i] = root[i];\\n        //   console.log(arr);\\n          if(arr.length > 1){\\n              var result = arr[0] + arr[1] ;\\n              var result2 = arr[0] + arr[2] ;\\n                if(result == targetSum){\\n                    console.log(result);\\n                    return true;\\n                    \\n                }else if(result2 == targetSum){\\n                    console.log(result2);\\n                    return true;\\n                }else{\\n                    return false;\\n                }\\n             \\n          }\\n      }\\n             \\n          \\n      \\n\\n};\\nhasPathSum([1,2,3],5);"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "thatCoderGirl",
                        "content": "I think there are few incorrect test cases in this question. \\n\\nCase 1: root =[1] , targetSum = 1, expects answer to be true.\\nCase 2: root =[1, 2] , targetSum = 1, expects answer to be false.\\n\\nAre we considering a solution only if it has a root-to-leaf path , or just root as the path also works ? If we are allowing just root also as the answer, then why in case 2, just root is not an answer ?\\n"
                    },
                    {
                        "username": "sujan_mandal",
                        "content": "root = [1,-2,-3,1,3,-2,null,-1]\\ntarget sum = -1\\nhow can this be true?"
                    },
                    {
                        "username": "Ijkeller",
                        "content": "Do we need to construct the tree within the function?  Also, is the input actually an array or is it the root node in a binary tree?"
                    },
                    {
                        "username": "AyushGupta2114",
                        "content": "can somebody tell what is the error in this \\n\\n\\n `\\'class Solution {\\npublic:\\n    long ans=0;\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL)\\n            return false;\\n        return preorder(root,targetSum,ans);\\n    }\\n    bool preorder(TreeNode *root, long targetSum,long ans)\\n    {\\n\\n        if(root!=NULL)\\n        {\\n         ans+=root->val;\\n         cout<<ans<<endl;\\n         if(ans==targetSum)\\n                return true;\\n        preorder(root->left,targetSum,ans);\\n        preorder(root->right,targetSum,ans);\\n        }\\n        return false;\\n    }\\n};.``\\n\\nfor test case 1 getting false\\nbut by cout getting this \\n5\\n9\\n20\\n27\\n22\\n13\\n26\\n17\\n18"
                    },
                    {
                        "username": "ScientificX",
                        "content": "Please why doesnt this code pass all test cases \n\n `your inline code...your inline code...`\n\n `..class Solution:\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\n        if not root: return 0\n        ans = False\n        def solve(node, path):\n            nonlocal ans\n            if not node:\n                ans = ans or (sum(path) == targetSum)\n                return\n\n            solve(node.right, path + [node.val])\n            solve(node.left, path + [node.val])\n\n        solve(root, [])\n        return ans.`"
                    },
                    {
                        "username": "sachin2000",
                        "content": "In my first attempt , i cleared 100 test cases but then it got wrong answer in below test case :\n[1,2] \noutput = true;\nexpected output false;\n\nThen I read the question again and found that the sum must be root to leaf not in between .\n\nfor more details find below: \nhttps://leetcode.com/problems/path-sum/submissions/890816375/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/path-sum/solutions/3049936/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "rahulseith",
                        "content": "why A. [1,2] target = 1 : expected is false B.  [1] : target as 1  has expected ans as true.\\nthese two are contradictory"
                    },
                    {
                        "username": "shin_98",
                        "content": "Those are two different situations. As statet in description *A leaf is a node with no children*.\n`[1,2]` - in this situation root with value \"1\" is not a *leaf* because it has left child with value 2. So only path from root to leaf is from 1 to 2. Thus there is only one path with sum 3 = 1 + 2\n3 != 1 (target) so it is expected to be False.\n`[1]` - in this situation root is also a leaf because it has no children. So path from root to leaf has only one step with sum 1\n1 == 1 (target) so it is expected to be True."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            },
            {
                "id": 1738580,
                "content": [
                    {
                        "username": "divyapbagul",
                        "content": "var hasPathSum = function(root, targetSum) {\\n  root = [1,2,3];\\n  targetSum = 5;\\n    var arr =[];\\n      for(var i = 0;i < root.length;i++){\\n          arr[i] = root[i];\\n        //   console.log(arr);\\n          if(arr.length > 1){\\n              var result = arr[0] + arr[1] ;\\n              var result2 = arr[0] + arr[2] ;\\n                if(result == targetSum){\\n                    console.log(result);\\n                    return true;\\n                    \\n                }else if(result2 == targetSum){\\n                    console.log(result2);\\n                    return true;\\n                }else{\\n                    return false;\\n                }\\n             \\n          }\\n      }\\n             \\n          \\n      \\n\\n};\\nhasPathSum([1,2,3],5);"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "thatCoderGirl",
                        "content": "I think there are few incorrect test cases in this question. \\n\\nCase 1: root =[1] , targetSum = 1, expects answer to be true.\\nCase 2: root =[1, 2] , targetSum = 1, expects answer to be false.\\n\\nAre we considering a solution only if it has a root-to-leaf path , or just root as the path also works ? If we are allowing just root also as the answer, then why in case 2, just root is not an answer ?\\n"
                    },
                    {
                        "username": "sujan_mandal",
                        "content": "root = [1,-2,-3,1,3,-2,null,-1]\\ntarget sum = -1\\nhow can this be true?"
                    },
                    {
                        "username": "Ijkeller",
                        "content": "Do we need to construct the tree within the function?  Also, is the input actually an array or is it the root node in a binary tree?"
                    },
                    {
                        "username": "AyushGupta2114",
                        "content": "can somebody tell what is the error in this \\n\\n\\n `\\'class Solution {\\npublic:\\n    long ans=0;\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL)\\n            return false;\\n        return preorder(root,targetSum,ans);\\n    }\\n    bool preorder(TreeNode *root, long targetSum,long ans)\\n    {\\n\\n        if(root!=NULL)\\n        {\\n         ans+=root->val;\\n         cout<<ans<<endl;\\n         if(ans==targetSum)\\n                return true;\\n        preorder(root->left,targetSum,ans);\\n        preorder(root->right,targetSum,ans);\\n        }\\n        return false;\\n    }\\n};.``\\n\\nfor test case 1 getting false\\nbut by cout getting this \\n5\\n9\\n20\\n27\\n22\\n13\\n26\\n17\\n18"
                    },
                    {
                        "username": "ScientificX",
                        "content": "Please why doesnt this code pass all test cases \n\n `your inline code...your inline code...`\n\n `..class Solution:\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\n        if not root: return 0\n        ans = False\n        def solve(node, path):\n            nonlocal ans\n            if not node:\n                ans = ans or (sum(path) == targetSum)\n                return\n\n            solve(node.right, path + [node.val])\n            solve(node.left, path + [node.val])\n\n        solve(root, [])\n        return ans.`"
                    },
                    {
                        "username": "sachin2000",
                        "content": "In my first attempt , i cleared 100 test cases but then it got wrong answer in below test case :\n[1,2] \noutput = true;\nexpected output false;\n\nThen I read the question again and found that the sum must be root to leaf not in between .\n\nfor more details find below: \nhttps://leetcode.com/problems/path-sum/submissions/890816375/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/path-sum/solutions/3049936/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "rahulseith",
                        "content": "why A. [1,2] target = 1 : expected is false B.  [1] : target as 1  has expected ans as true.\\nthese two are contradictory"
                    },
                    {
                        "username": "shin_98",
                        "content": "Those are two different situations. As statet in description *A leaf is a node with no children*.\n`[1,2]` - in this situation root with value \"1\" is not a *leaf* because it has left child with value 2. So only path from root to leaf is from 1 to 2. Thus there is only one path with sum 3 = 1 + 2\n3 != 1 (target) so it is expected to be False.\n`[1]` - in this situation root is also a leaf because it has no children. So path from root to leaf has only one step with sum 1\n1 == 1 (target) so it is expected to be True."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            },
            {
                "id": 1728211,
                "content": [
                    {
                        "username": "divyapbagul",
                        "content": "var hasPathSum = function(root, targetSum) {\\n  root = [1,2,3];\\n  targetSum = 5;\\n    var arr =[];\\n      for(var i = 0;i < root.length;i++){\\n          arr[i] = root[i];\\n        //   console.log(arr);\\n          if(arr.length > 1){\\n              var result = arr[0] + arr[1] ;\\n              var result2 = arr[0] + arr[2] ;\\n                if(result == targetSum){\\n                    console.log(result);\\n                    return true;\\n                    \\n                }else if(result2 == targetSum){\\n                    console.log(result2);\\n                    return true;\\n                }else{\\n                    return false;\\n                }\\n             \\n          }\\n      }\\n             \\n          \\n      \\n\\n};\\nhasPathSum([1,2,3],5);"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "thatCoderGirl",
                        "content": "I think there are few incorrect test cases in this question. \\n\\nCase 1: root =[1] , targetSum = 1, expects answer to be true.\\nCase 2: root =[1, 2] , targetSum = 1, expects answer to be false.\\n\\nAre we considering a solution only if it has a root-to-leaf path , or just root as the path also works ? If we are allowing just root also as the answer, then why in case 2, just root is not an answer ?\\n"
                    },
                    {
                        "username": "sujan_mandal",
                        "content": "root = [1,-2,-3,1,3,-2,null,-1]\\ntarget sum = -1\\nhow can this be true?"
                    },
                    {
                        "username": "Ijkeller",
                        "content": "Do we need to construct the tree within the function?  Also, is the input actually an array or is it the root node in a binary tree?"
                    },
                    {
                        "username": "AyushGupta2114",
                        "content": "can somebody tell what is the error in this \\n\\n\\n `\\'class Solution {\\npublic:\\n    long ans=0;\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL)\\n            return false;\\n        return preorder(root,targetSum,ans);\\n    }\\n    bool preorder(TreeNode *root, long targetSum,long ans)\\n    {\\n\\n        if(root!=NULL)\\n        {\\n         ans+=root->val;\\n         cout<<ans<<endl;\\n         if(ans==targetSum)\\n                return true;\\n        preorder(root->left,targetSum,ans);\\n        preorder(root->right,targetSum,ans);\\n        }\\n        return false;\\n    }\\n};.``\\n\\nfor test case 1 getting false\\nbut by cout getting this \\n5\\n9\\n20\\n27\\n22\\n13\\n26\\n17\\n18"
                    },
                    {
                        "username": "ScientificX",
                        "content": "Please why doesnt this code pass all test cases \n\n `your inline code...your inline code...`\n\n `..class Solution:\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\n        if not root: return 0\n        ans = False\n        def solve(node, path):\n            nonlocal ans\n            if not node:\n                ans = ans or (sum(path) == targetSum)\n                return\n\n            solve(node.right, path + [node.val])\n            solve(node.left, path + [node.val])\n\n        solve(root, [])\n        return ans.`"
                    },
                    {
                        "username": "sachin2000",
                        "content": "In my first attempt , i cleared 100 test cases but then it got wrong answer in below test case :\n[1,2] \noutput = true;\nexpected output false;\n\nThen I read the question again and found that the sum must be root to leaf not in between .\n\nfor more details find below: \nhttps://leetcode.com/problems/path-sum/submissions/890816375/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/path-sum/solutions/3049936/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "rahulseith",
                        "content": "why A. [1,2] target = 1 : expected is false B.  [1] : target as 1  has expected ans as true.\\nthese two are contradictory"
                    },
                    {
                        "username": "shin_98",
                        "content": "Those are two different situations. As statet in description *A leaf is a node with no children*.\n`[1,2]` - in this situation root with value \"1\" is not a *leaf* because it has left child with value 2. So only path from root to leaf is from 1 to 2. Thus there is only one path with sum 3 = 1 + 2\n3 != 1 (target) so it is expected to be False.\n`[1]` - in this situation root is also a leaf because it has no children. So path from root to leaf has only one step with sum 1\n1 == 1 (target) so it is expected to be True."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            }
        ]
    },
    {
        "title": "Word Search II",
        "question_content": "<p>Given an <code>m x n</code> <code>board</code>&nbsp;of characters and a list of strings <code>words</code>, return <em>all words on the board</em>.</p>\n\n<p>Each word must be constructed from letters of sequentially adjacent cells, where <strong>adjacent cells</strong> are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/07/search1.jpg\" style=\"width: 322px; height: 322px;\" />\n<pre>\n<strong>Input:</strong> board = [[&quot;o&quot;,&quot;a&quot;,&quot;a&quot;,&quot;n&quot;],[&quot;e&quot;,&quot;t&quot;,&quot;a&quot;,&quot;e&quot;],[&quot;i&quot;,&quot;h&quot;,&quot;k&quot;,&quot;r&quot;],[&quot;i&quot;,&quot;f&quot;,&quot;l&quot;,&quot;v&quot;]], words = [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]\n<strong>Output:</strong> [&quot;eat&quot;,&quot;oath&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/07/search2.jpg\" style=\"width: 162px; height: 162px;\" />\n<pre>\n<strong>Input:</strong> board = [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], words = [&quot;abcb&quot;]\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == board.length</code></li>\n\t<li><code>n == board[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 12</code></li>\n\t<li><code>board[i][j]</code> is a lowercase English letter.</li>\n\t<li><code>1 &lt;= words.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 10</code></li>\n\t<li><code>words[i]</code> consists of lowercase English letters.</li>\n\t<li>All the strings of <code>words</code> are unique.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 59780,
                "title": "java-15ms-easiest-solution-100-00",
                "content": "<h2>Backtracking + Trie</h2>\\n<hr>\\n\\nIntuitively, start from every cell and try to build a word in the dictionary. `Backtracking (dfs)` is the powerful way to exhaust every possible ways. Apparently, we need to do `pruning` when current character is not in any word. \\n\\n1. How do we instantly know the current character is invalid? `HashMap`? \\n2. How do we instantly know what's the next valid character? `LinkedList`?\\n3. But the next character can be chosen from a list of characters. `\"Mutil-LinkedList\"`?\\n\\nCombing them, `Trie` is the natural choice. Notice that:\\n\\n1. `TrieNode` is all we need. `search` and `startsWith` are useless.\\n2. No need to store character at TrieNode. `c.next[i] != null` is enough.\\n3. Never use `c1 + c2 + c3`. Use `StringBuilder`.\\n4. No need to use `O(n^2)` extra space `visited[m][n].` \\n5. No need to use `StringBuilder`. Storing `word` itself at leaf node is enough.\\n6. No need to use `HashSet` to de-duplicate. Use \"one time search\" trie.\\n\\nFor more explanations, check out [dietpepsi's blog][1].\\n\\n<hr>\\n<h2>Code Optimization</h2>\\n<hr>\\n\\nUPDATE: Thanks to @dietpepsi we further improved from `17ms` to `15ms`.\\n\\n1. `59ms`: Use `search` and `startsWith` in Trie class like [this popular solution.][2]\\n2. `33ms`: Remove Trie class which unnecessarily starts from `root` in every `dfs` call. \\n3. `30ms`: Use `w.toCharArray()` instead of `w.charAt(i)`.\\n4. `22ms`: Use `StringBuilder` instead of `c1 + c2 + c3`.\\n5. `20ms`: Remove `StringBuilder` completely by storing `word` instead of `boolean` in TrieNode.\\n6. `20ms`: Remove `visited[m][n]` completely by modifying `board[i][j] = '#'` directly.\\n7. `18ms`: check validity, e.g., `if(i > 0) dfs(...)`, before going to the next `dfs`.\\n8. `17ms`: De-duplicate `c - a` with one variable `i`.\\n9. `15ms`: Remove `HashSet` completely. dietpepsi's idea is awesome. \\n\\nThe final run time is `15ms`. Hope it helps!\\n\\n<hr>\\n\\n    public List<String> findWords(char[][] board, String[] words) {\\n        List<String> res = new ArrayList<>();\\n        TrieNode root = buildTrie(words);\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[0].length; j++) {\\n                dfs (board, i, j, root, res);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public void dfs(char[][] board, int i, int j, TrieNode p, List<String> res) {\\n        char c = board[i][j];\\n        if (c == '#' || p.next[c - 'a'] == null) return;\\n        p = p.next[c - 'a'];\\n        if (p.word != null) {   // found one\\n            res.add(p.word);\\n            p.word = null;     // de-duplicate\\n        }\\n\\n        board[i][j] = '#';\\n        if (i > 0) dfs(board, i - 1, j ,p, res); \\n        if (j > 0) dfs(board, i, j - 1, p, res);\\n        if (i < board.length - 1) dfs(board, i + 1, j, p, res); \\n        if (j < board[0].length - 1) dfs(board, i, j + 1, p, res); \\n        board[i][j] = c;\\n    }\\n    \\n    public TrieNode buildTrie(String[] words) {\\n        TrieNode root = new TrieNode();\\n        for (String w : words) {\\n            TrieNode p = root;\\n            for (char c : w.toCharArray()) {\\n                int i = c - 'a';\\n                if (p.next[i] == null) p.next[i] = new TrieNode();\\n                p = p.next[i];\\n           }\\n           p.word = w;\\n        }\\n        return root;\\n    }\\n    \\n    class TrieNode {\\n        TrieNode[] next = new TrieNode[26];\\n        String word;\\n    }\\n\\n\\n  [1]: http://algobox.org/word-search-ii/\\n  [2]: https://leetcode.com/discuss/36337/my-simple-and-clean-java-code-using-dfs-and-trie",
                "solutionTags": [
                    "Java"
                ],
                "code": "<h2>Backtracking + Trie</h2>\\n<hr>\\n\\nIntuitively, start from every cell and try to build a word in the dictionary. `Backtracking (dfs)` is the powerful way to exhaust every possible ways. Apparently, we need to do `pruning` when current character is not in any word. \\n\\n1. How do we instantly know the current character is invalid? `HashMap`? \\n2. How do we instantly know what's the next valid character? `LinkedList`?\\n3. But the next character can be chosen from a list of characters. `\"Mutil-LinkedList\"`?\\n\\nCombing them, `Trie` is the natural choice. Notice that:\\n\\n1. `TrieNode` is all we need. `search` and `startsWith` are useless.\\n2. No need to store character at TrieNode. `c.next[i] != null` is enough.\\n3. Never use `c1 + c2 + c3`. Use `StringBuilder`.\\n4. No need to use `O(n^2)` extra space `visited[m][n].` \\n5. No need to use `StringBuilder`. Storing `word` itself at leaf node is enough.\\n6. No need to use `HashSet` to de-duplicate. Use \"one time search\" trie.\\n\\nFor more explanations, check out [dietpepsi's blog][1].\\n\\n<hr>\\n<h2>Code Optimization</h2>\\n<hr>\\n\\nUPDATE: Thanks to @dietpepsi we further improved from `17ms` to `15ms`.\\n\\n1. `59ms`: Use `search` and `startsWith` in Trie class like [this popular solution.][2]\\n2. `33ms`: Remove Trie class which unnecessarily starts from `root` in every `dfs` call. \\n3. `30ms`: Use `w.toCharArray()` instead of `w.charAt(i)`.\\n4. `22ms`: Use `StringBuilder` instead of `c1 + c2 + c3`.\\n5. `20ms`: Remove `StringBuilder` completely by storing `word` instead of `boolean` in TrieNode.\\n6. `20ms`: Remove `visited[m][n]` completely by modifying `board[i][j] = '#'` directly.\\n7. `18ms`: check validity, e.g., `if(i > 0) dfs(...)`, before going to the next `dfs`.\\n8. `17ms`: De-duplicate `c - a` with one variable `i`.\\n9. `15ms`: Remove `HashSet` completely. dietpepsi's idea is awesome. \\n\\nThe final run time is `15ms`. Hope it helps!\\n\\n<hr>\\n\\n    public List<String> findWords(char[][] board, String[] words) {\\n        List<String> res = new ArrayList<>();\\n        TrieNode root = buildTrie(words);\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[0].length; j++) {\\n                dfs (board, i, j, root, res);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public void dfs(char[][] board, int i, int j, TrieNode p, List<String> res) {\\n        char c = board[i][j];\\n        if (c == '#' || p.next[c - 'a'] == null) return;\\n        p = p.next[c - 'a'];\\n        if (p.word != null) {   // found one\\n            res.add(p.word);\\n            p.word = null;     // de-duplicate\\n        }\\n\\n        board[i][j] = '#';\\n        if (i > 0) dfs(board, i - 1, j ,p, res); \\n        if (j > 0) dfs(board, i, j - 1, p, res);\\n        if (i < board.length - 1) dfs(board, i + 1, j, p, res); \\n        if (j < board[0].length - 1) dfs(board, i, j + 1, p, res); \\n        board[i][j] = c;\\n    }\\n    \\n    public TrieNode buildTrie(String[] words) {\\n        TrieNode root = new TrieNode();\\n        for (String w : words) {\\n            TrieNode p = root;\\n            for (char c : w.toCharArray()) {\\n                int i = c - 'a';\\n                if (p.next[i] == null) p.next[i] = new TrieNode();\\n                p = p.next[i];\\n           }\\n           p.word = w;\\n        }\\n        return root;\\n    }\\n    \\n    class TrieNode {\\n        TrieNode[] next = new TrieNode[26];\\n        String word;\\n    }\\n\\n\\n  [1]: http://algobox.org/word-search-ii/\\n  [2]: https://leetcode.com/discuss/36337/my-simple-and-clean-java-code-using-dfs-and-trie",
                "codeTag": "Java"
            },
            {
                "id": 59790,
                "title": "python-dfs-solution-directly-use-trie-implemented",
                "content": "Here is an implementation based on  [Implement Trie][1] in LeetCode. TrieNode, Trie, Solution are treated as seperated classes. \\n\\n    class TrieNode():\\n        def __init__(self):\\n            self.children = collections.defaultdict(TrieNode)\\n            self.isWord = False\\n        \\n    class Trie():\\n        def __init__(self):\\n            self.root = TrieNode()\\n        \\n        def insert(self, word):\\n            node = self.root\\n            for w in word:\\n                node = node.children[w]\\n            node.isWord = True\\n        \\n        def search(self, word):\\n            node = self.root\\n            for w in word:\\n                node = node.children.get(w)\\n                if not node:\\n                    return False\\n            return node.isWord\\n        \\n    class Solution(object):\\n        def findWords(self, board, words):\\n            res = []\\n            trie = Trie()\\n            node = trie.root\\n            for w in words:\\n                trie.insert(w)\\n            for i in xrange(len(board)):\\n                for j in xrange(len(board[0])):\\n                    self.dfs(board, node, i, j, \"\", res)\\n            return res\\n        \\n        def dfs(self, board, node, i, j, path, res):\\n            if node.isWord:\\n                res.append(path)\\n                node.isWord = False\\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]):\\n                return \\n            tmp = board[i][j]\\n            node = node.children.get(tmp)\\n            if not node:\\n                return \\n            board[i][j] = \"#\"\\n            self.dfs(board, node, i+1, j, path+tmp, res)\\n            self.dfs(board, node, i-1, j, path+tmp, res)\\n            self.dfs(board, node, i, j-1, path+tmp, res)\\n            self.dfs(board, node, i, j+1, path+tmp, res)\\n            board[i][j] = tmp\\n\\n\\n  [1]: https://leetcode.com/problems/implement-trie-prefix-tree/",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "Here is an implementation based on  [Implement Trie][1] in LeetCode. TrieNode, Trie, Solution are treated as seperated classes. \\n\\n    class TrieNode():\\n        def __init__(self):\\n            self.children = collections.defaultdict(TrieNode)\\n            self.isWord = False\\n        \\n    class Trie():\\n        def __init__(self):\\n            self.root = TrieNode()\\n        \\n        def insert(self, word):\\n            node = self.root\\n            for w in word:\\n                node = node.children[w]\\n            node.isWord = True\\n        \\n        def search(self, word):\\n            node = self.root\\n            for w in word:\\n                node = node.children.get(w)\\n                if not node:\\n                    return False\\n            return node.isWord\\n        \\n    class Solution(object):\\n        def findWords(self, board, words):\\n            res = []\\n            trie = Trie()\\n            node = trie.root\\n            for w in words:\\n                trie.insert(w)\\n            for i in xrange(len(board)):\\n                for j in xrange(len(board[0])):\\n                    self.dfs(board, node, i, j, \"\", res)\\n            return res\\n        \\n        def dfs(self, board, node, i, j, path, res):\\n            if node.isWord:\\n                res.append(path)\\n                node.isWord = False\\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]):\\n                return \\n            tmp = board[i][j]\\n            node = node.children.get(tmp)\\n            if not node:\\n                return \\n            board[i][j] = \"#\"\\n            self.dfs(board, node, i+1, j, path+tmp, res)\\n            self.dfs(board, node, i-1, j, path+tmp, res)\\n            self.dfs(board, node, i, j-1, path+tmp, res)\\n            self.dfs(board, node, i, j+1, path+tmp, res)\\n            board[i][j] = tmp\\n\\n\\n  [1]: https://leetcode.com/problems/implement-trie-prefix-tree/",
                "codeTag": "Java"
            },
            {
                "id": 59841,
                "title": "my-ac-very-clean-c-code",
                "content": "The idea is start from every position of the board, and then see if we can find a word starting from this position with checking if is_end is true in TrieNode structure\\n\\n    class TrieNode{\\n    public:\\n        bool is_end;\\n        vector<TrieNode*> children;\\n        TrieNode(){\\n            is_end=false;\\n            children=vector<TrieNode*>(26, NULL);\\n        }   \\n    };\\n    \\n    class Trie{\\n    public:\\n        TrieNode* getRoot(){return root;}\\n        Trie(vector<string>& words){\\n            root=new TrieNode();\\n            for(int i=0; i<words.size(); ++i)\\n                addWord(words[i]);\\n        }\\n        void addWord(const string& word){\\n            TrieNode* cur=root;\\n            for(int i=0; i<word.size(); ++i){\\n                int index=word[i]-'a';\\n                if(cur->children[index]==NULL)   \\n                   cur->children[index]=new TrieNode();\\n                cur=cur->children[index];    \\n            }\\n            cur->is_end=true;\\n        }\\n    private:\\n        TrieNode* root;\\n    };\\n    \\n    class Solution {\\n    public:\\n        vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n            Trie* trie = new Trie(words);\\n            TrieNode* root=trie->getRoot();\\n            set<string> result_set;\\n            for(int x=0; x<board.size(); ++x)\\n                for(int y=0; y<board[0].size(); ++y)\\n                    findWords(board, x, y, root, \"\", result_set);\\n            \\n            vector<string> result;\\n            for(auto it:result_set)    result.push_back(it);\\n            return result;        \\n        }\\n    private:\\n        void findWords(vector<vector<char>>& board, int x, int y, TrieNode* root, string word, set<string>& result){\\n            if(x<0||x>=board.size()||y<0||y>=board[0].size() || board[x][y]==' ') return;\\n            \\n            if(root->children[board[x][y]-'a'] != NULL){\\n                word=word+board[x][y];\\n                root=root->children[board[x][y]-'a']; \\n                if(root->is_end) result.insert(word);\\n                char c=board[x][y];\\n                board[x][y]=' ';\\n                findWords(board, x+1, y, root, word, result);\\n                findWords(board, x-1, y, root, word, result);\\n                findWords(board, x, y+1, root, word, result);\\n                findWords(board, x, y-1, root, word, result);\\n                board[x][y]=c;        \\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n            Trie* trie = new Trie(words);\\n            TrieNode* root=trie->getRoot();\\n            set<string> result_set;\\n            for(int x=0; x<board.size(); ++x)\\n                for(int y=0; y<board[0].size(); ++y)\\n                    findWords(board, x, y, root, \"\", result_set);\\n            \\n            vector<string> result;\\n            for(auto it:result_set)    result.push_back(it);\\n            return result;        \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 59784,
                "title": "my-simple-and-clean-java-code-using-dfs-and-trie",
                "content": "Compared with [Word Search][1], I make my DFS with a tire but a word. The Trie is formed by all the words in given *words*. Then during the DFS, for each current formed word, I check if it is in the Trie.\\n\\n    public class Solution {\\n        Set<String> res = new HashSet<String>();\\n        \\n        public List<String> findWords(char[][] board, String[] words) {\\n            Trie trie = new Trie();\\n            for (String word : words) {\\n                trie.insert(word);\\n            }\\n            \\n            int m = board.length;\\n            int n = board[0].length;\\n            boolean[][] visited = new boolean[m][n];\\n            for (int i = 0; i < m; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    dfs(board, visited, \"\", i, j, trie);\\n                }\\n            }\\n            \\n            return new ArrayList<String>(res);\\n        }\\n        \\n        public void dfs(char[][] board, boolean[][] visited, String str, int x, int y, Trie trie) {\\n            if (x < 0 || x >= board.length || y < 0 || y >= board[0].length) return;\\n            if (visited[x][y]) return;\\n            \\n            str += board[x][y];\\n            if (!trie.startsWith(str)) return;\\n            \\n            if (trie.search(str)) {\\n                res.add(str);\\n            }\\n            \\n            visited[x][y] = true;\\n            dfs(board, visited, str, x - 1, y, trie);\\n            dfs(board, visited, str, x + 1, y, trie);\\n            dfs(board, visited, str, x, y - 1, trie);\\n            dfs(board, visited, str, x, y + 1, trie);\\n            visited[x][y] = false;\\n        }\\n    }\\n \\n\\n  [1]: https://leetcode.com/problems/word-search/",
                "solutionTags": [
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "class Solution {\\n        Set<String> res = new HashSet<String>();\\n        \\n        public List<String> findWords(char[][] board, String[] words) {\\n            Trie trie = new Trie();\\n            for (String word : words) {\\n                trie.insert(word);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 712733,
                "title": "python-trie-solution-with-dfs-explained",
                "content": "One of the efficient ways to solve this problem is to use **Trie**. For more details please look https://en.wikipedia.org/wiki/Trie. In two words, it is a special data structure, similar to trees, but which has letters inside and used to quick search of patterns in strings. For implementation of Trie, please visit problem **208. Implement Trie** (however I put my code here as well)\\n\\nOutline of algorithm:\\n1. For each `word` in our `words` insert it in our Trie.\\n2. Starting with each symbol in our board, start `dfs` (backtracking) which are looking for words in our Trie.\\n\\n**Variables**: \\n`self.num_words` is total number of words we still need to find, in the beginning it is equal to total number of words. \\n`res` is our result, where we keep found words. \\n`trie` is our trie.\\n\\nNow, how our `dfs(self, board, node, i, j, path, res)` works?\\n\\n0. `board` is our original board, `node` is current node of `trie`, `i` and `j` are current coordinates we are it, `path` is word build so far and `res` is global variable for found words.\\n1. First, we check if we still need to look for words, if not, return\\n2. Check if the node we are in currently is **end_node**: it means, that some word was found! We add it to our `res`, mark `node.end_node` as False (we do not want to search it once again) and decrease number of words we still need to find by `1`.\\n3. If we out of border or we inside border, but we can not traverse our `trie` we again do nothing.\\n4. Now, we mark `(i,j)` position in our board as visited: `#`, call our dfs for all neibours, and then restore value ofr `(i,j)` position. (the reason is in pyton if we give list as parameter of recursive method, it will deal as global variable, so we need to fix it when we returned from our recursion).\\n\\n**Complexity**. This is difficult question, space complexity is needed to keep our `trie`, which is `O(k)`, where `k` is sum of length of all words. Time complexity is `O(mn*3^T)`, where `m` and `n` are sizes of our board and `T` is the length of the longest word in `words`. Why? Because we start our `dfs` from all points of our board and do not stop until we make sure that the longest word is checked: if we are not lucky and this word can not be found on board we need to check potentialy to the length `T`. Why `3^T`? Because each time we can choose one of three directions, except the one we came from.\\n\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.end_node = 0\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n\\n    def insert(self, word):\\n        root = self.root\\n        for symbol in word:\\n            root = root.children.setdefault(symbol, TrieNode())\\n        root.end_node = 1\\n\\nclass Solution:\\n    def findWords(self, board, words):\\n        self.num_words = len(words)\\n        res, trie = [], Trie()\\n        for word in words: trie.insert(word) \\n\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                self.dfs(board, trie.root, i, j, \"\", res)\\n        return res\\n\\n    def dfs(self, board, node, i, j, path, res):\\n        if self.num_words == 0: return\\n\\n        if node.end_node:\\n            res.append(path)\\n            node.end_node = False\\n            self.num_words -= 1\\n\\n        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]): return \\n        tmp = board[i][j]\\n        if tmp not in node.children: return\\n\\n        board[i][j] = \"#\"\\n        for x,y in [[0,-1], [0,1], [1,0], [-1,0]]:\\n            self.dfs(board, node.children[tmp], i+x, j+y, path+tmp, res)\\n        board[i][j] = tmp\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.end_node = 0\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n\\n    def insert(self, word):\\n        root = self.root\\n        for symbol in word:\\n            root = root.children.setdefault(symbol, TrieNode())\\n        root.end_node = 1\\n\\nclass Solution:\\n    def findWords(self, board, words):\\n        self.num_words = len(words)\\n        res, trie = [], Trie()\\n        for word in words: trie.insert(word) \\n\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                self.dfs(board, trie.root, i, j, \"\", res)\\n        return res\\n\\n    def dfs(self, board, node, i, j, path, res):\\n        if self.num_words == 0: return\\n\\n        if node.end_node:\\n            res.append(path)\\n            node.end_node = False\\n            self.num_words -= 1\\n\\n        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]): return \\n        tmp = board[i][j]\\n        if tmp not in node.children: return\\n\\n        board[i][j] = \"#\"\\n        for x,y in [[0,-1], [0,1], [1,0], [-1,0]]:\\n            self.dfs(board, node.children[tmp], i+x, j+y, path+tmp, res)\\n        board[i][j] = tmp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878708,
                "title": "c-python-backtracking-with-trie-clean-concise",
                "content": "**Idea**\\n- Just backtracking to try all possible paths in the board.\\n- To check if the current path exists any word, we can build Trie structure, which can prune early when the current path is not a prefix of any words in our Trie.\\n- Check basic implemetation of Trie Structure under **[208. Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/discuss/1509720)**\\n\\n<iframe src=\"https://leetcode.com/playground/UviFN7ns/shared\" frameBorder=\"0\" width=\"100%\" height=\"810\"></iframe>\\n\\n**Complexity**\\n- Time: `O(M * N * 4 * 3^(L-2) + S)`, where `M*N <= 12*12` is total number of cells in the board, `L <= 10` is the maximum length of words, `S <= 3 * 10^5` is sum length of all words.\\n   Explain: Firstly, we can choose `M*N` cells of the board as starting position, we have `4` choices to go neighbors of the first cell, each of neighbors have total `3` choices to go to their neighbors (exclude their previous neighbor) and so on.\\n![image](https://assets.leetcode.com/users/images/25730536-a35a-469b-94a3-77e24f8e5de6_1601824879.6308603.png)\\n\\n- Space: `O(S)`\\n  Explain: The main space consumed by the algorithm is the Trie data structure we build. In the worst case where there is no overlapping of prefixes among the words, the Trie would have as many nodes as the letters of all words.",
                "solutionTags": [],
                "code": "**Idea**\\n- Just backtracking to try all possible paths in the board.\\n- To check if the current path exists any word, we can build Trie structure, which can prune early when the current path is not a prefix of any words in our Trie.\\n- Check basic implemetation of Trie Structure under **[208. Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/discuss/1509720)**\\n\\n<iframe src=\"https://leetcode.com/playground/UviFN7ns/shared\" frameBorder=\"0\" width=\"100%\" height=\"810\"></iframe>\\n\\n**Complexity**\\n- Time: `O(M * N * 4 * 3^(L-2) + S)`, where `M*N <= 12*12` is total number of cells in the board, `L <= 10` is the maximum length of words, `S <= 3 * 10^5` is sum length of all words.\\n   Explain: Firstly, we can choose `M*N` cells of the board as starting position, we have `4` choices to go neighbors of the first cell, each of neighbors have total `3` choices to go to their neighbors (exclude their previous neighbor) and so on.\\n![image](https://assets.leetcode.com/users/images/25730536-a35a-469b-94a3-77e24f8e5de6_1601824879.6308603.png)\\n\\n- Space: `O(S)`\\n  Explain: The main space consumed by the algorithm is the Trie data structure we build. In the worst case where there is no overlapping of prefixes among the words, the Trie would have as many nodes as the letters of all words.",
                "codeTag": "Unknown"
            },
            {
                "id": 59804,
                "title": "27-lines-uses-complex-numbers",
                "content": "I first build the tree of words with root `root` and also represent the board a different way, namely as one-dimensional dictionary where the keys are complex numbers representing the row/column indexes. That makes further work with it easier. Looping over all board positions is just `for z in board`, the four neighbors of a board position z are just `z + 1j**k` (for k in 0 to 3), and I don't need to check borders because `board.get` just returns \"None\" if I request an invalid position.\\n\\nAfter this preparation, I just take the tree and recursively dive with it into each board position. Similar to how you'd search a single word, but with the tree instead.\\n\\n    class Solution:\\n        def findWords(self, board, words):\\n    \\n            root = {}\\n            for word in words:\\n                node = root\\n                for c in word:\\n                    node = node.setdefault(c, {})\\n                node[None] = True\\n            board = {i + 1j*j: c\\n                     for i, row in enumerate(board)\\n                     for j, c in enumerate(row)}\\n    \\n            found = []\\n            def search(node, z, word):\\n                if node.pop(None, None):\\n                    found.append(word)\\n                c = board.get(z)\\n                if c in node:\\n                    board[z] = None\\n                    for k in range(4):\\n                        search(node[c], z + 1j**k, word + c)\\n                    board[z] = c\\n            for z in board:\\n                search(root, z, '')\\n    \\n            return found",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        def findWords(self, board, words):\\n    \\n            root = {}",
                "codeTag": "Java"
            },
            {
                "id": 59864,
                "title": "python-code-use-trie-and-dfs",
                "content": "```python\\nclass Solution:\\n    # @param {character[][]} board\\n    # @param {string[]} words\\n    # @return {string[]}\\n    def findWords(self, board, words):\\n        #make trie\\n        count = Counter()\\n        for l in board:\\n            count += Counter(l)\\n        trie={}\\n        for w in words:\\n            wc = Counter(w)\\n            for c in wc:\\n\\t\\t\\t\\t# optimization, ignore word if there isn\\'t enough c in board\\n                if wc[c] > count[c]:\\n                    continue\\n            t=trie\\n            for c in w:\\n                if c not in t:\\n                    t[c]={}\\n                t=t[c]\\n            t[\\'#\\']=\\'#\\'\\n        self.res=[]\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                self.find(board,i,j,trie,[])\\n        return self.res\\n    \\n    def find(self,board,i,j,trie,pre):\\n        if \\'#\\' in trie:\\n\\t\\t\\t# optimization, delete for avoiding duplicated matches\\n            del trie[\"#\"]\\n            self.res.append(\\'\\'.join(pre))\\n        if i<0 or i>=len(board) or j<0 or j>=len(board[0]):\\n            return\\n        if board[i][j] in trie:\\n            tmp = board[i][j]\\n            board[i][j] = \\'$\\'\\n            pre.append(tmp)\\n            self.find(board,i+1,j,trie[tmp],pre)\\n            self.find(board,i,j+1,trie[tmp],pre)\\n            self.find(board,i-1,j,trie[tmp],pre)\\n            self.find(board,i,j-1,trie[tmp],pre)\\n            board[i][j] = tmp\\n            pre.pop()\\n            if not trie[board[i][j]]:\\n\\t\\t\\t\\t# nothing in trie[board[i][j]] because of matched before, delete node for optimization\\n                del trie[board[i][j]]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    # @param {character[][]} board\\n    # @param {string[]} words\\n    # @return {string[]}\\n    def findWords(self, board, words):\\n        #make trie\\n        count = Counter()\\n        for l in board:\\n            count += Counter(l)\\n        trie={}\\n        for w in words:\\n            wc = Counter(w)\\n            for c in wc:\\n\\t\\t\\t\\t# optimization, ignore word if there isn\\'t enough c in board\\n                if wc[c] > count[c]:\\n                    continue\\n            t=trie\\n            for c in w:\\n                if c not in t:\\n                    t[c]={}\\n                t=t[c]\\n            t[\\'#\\']=\\'#\\'\\n        self.res=[]\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                self.find(board,i,j,trie,[])\\n        return self.res\\n    \\n    def find(self,board,i,j,trie,pre):\\n        if \\'#\\' in trie:\\n\\t\\t\\t# optimization, delete for avoiding duplicated matches\\n            del trie[\"#\"]\\n            self.res.append(\\'\\'.join(pre))\\n        if i<0 or i>=len(board) or j<0 or j>=len(board[0]):\\n            return\\n        if board[i][j] in trie:\\n            tmp = board[i][j]\\n            board[i][j] = \\'$\\'\\n            pre.append(tmp)\\n            self.find(board,i+1,j,trie[tmp],pre)\\n            self.find(board,i,j+1,trie[tmp],pre)\\n            self.find(board,i-1,j,trie[tmp],pre)\\n            self.find(board,i,j-1,trie[tmp],pre)\\n            board[i][j] = tmp\\n            pre.pop()\\n            if not trie[board[i][j]]:\\n\\t\\t\\t\\t# nothing in trie[board[i][j]] because of matched before, delete node for optimization\\n                del trie[board[i][j]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 262396,
                "title": "c-trie-solution-99-62-faster",
                "content": "C++ implementation in this [post](https://leetcode.com/problems/word-search-ii/discuss/59780/Java-15ms-Easiest-Solution-(100.00))\\n```\\nclass Solution {\\n    struct TrieNode {\\n        TrieNode *children[26];\\n        string word;\\n\\n        TrieNode() : word(\"\") {\\n            for (int i = 0; i < 26; i++) {\\n                children[i] = nullptr;\\n            }\\n        }\\n    };\\n\\npublic:\\n    vector<string> findWords(vector<vector<char>> &board, vector<string> &words) {\\n        TrieNode *root = buildTrie(words);\\n        vector<string> result;\\n        for (int i = 0; i < board.size(); i++) {\\n            for (int j = 0; j < board[0].size(); j++) {\\n                dfs(board, i, j, root, result);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /** Inserts a word into the trie. */\\n    TrieNode *buildTrie(vector<string> &words) {\\n        TrieNode *root = new TrieNode();\\n        for (int j = 0; j < words.size(); j++) {\\n            string word = words[j];\\n            TrieNode *curr = root;\\n            for (int i = 0; i < word.length(); i++) {\\n                char c = word[i] - \\'a\\';\\n                if (curr->children[c] == nullptr) {\\n                    curr->children[c] = new TrieNode();\\n                }\\n                curr = curr->children[c];\\n            }\\n            curr->word = word;\\n        }\\n        return root;\\n    }\\n\\n    void dfs(vector<vector<char>> &board, int i, int j, TrieNode *p, vector<string> &result) {\\n        char c = board[i][j];\\n        if (c == \\'#\\' || !p->children[c - \\'a\\']) return;\\n        p = p->children[c - \\'a\\'];\\n        if (p->word.size() > 0) {\\n            result.push_back(p->word);\\n            p->word = \"\";\\n        }\\n\\n        board[i][j] = \\'#\\';\\n        if (i > 0) dfs(board, i - 1, j, p, result);\\n        if (j > 0) dfs(board, i, j - 1, p, result);\\n        if (i < board.size() - 1) dfs(board, i + 1, j, p, result);\\n        if (j < board[0].size() - 1) dfs(board, i, j + 1, p, result);\\n        board[i][j] = c;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    struct TrieNode {\\n        TrieNode *children[26];\\n        string word;\\n\\n        TrieNode() : word(\"\") {\\n            for (int i = 0; i < 26; i++) {\\n                children[i] = nullptr;\\n            }\\n        }\\n    };\\n\\npublic:\\n    vector<string> findWords(vector<vector<char>> &board, vector<string> &words) {\\n        TrieNode *root = buildTrie(words);\\n        vector<string> result;\\n        for (int i = 0; i < board.size(); i++) {\\n            for (int j = 0; j < board[0].size(); j++) {\\n                dfs(board, i, j, root, result);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /** Inserts a word into the trie. */\\n    TrieNode *buildTrie(vector<string> &words) {\\n        TrieNode *root = new TrieNode();\\n        for (int j = 0; j < words.size(); j++) {\\n            string word = words[j];\\n            TrieNode *curr = root;\\n            for (int i = 0; i < word.length(); i++) {\\n                char c = word[i] - \\'a\\';\\n                if (curr->children[c] == nullptr) {\\n                    curr->children[c] = new TrieNode();\\n                }\\n                curr = curr->children[c];\\n            }\\n            curr->word = word;\\n        }\\n        return root;\\n    }\\n\\n    void dfs(vector<vector<char>> &board, int i, int j, TrieNode *p, vector<string> &result) {\\n        char c = board[i][j];\\n        if (c == \\'#\\' || !p->children[c - \\'a\\']) return;\\n        p = p->children[c - \\'a\\'];\\n        if (p->word.size() > 0) {\\n            result.push_back(p->word);\\n            p->word = \"\";\\n        }\\n\\n        board[i][j] = \\'#\\';\\n        if (i > 0) dfs(board, i - 1, j, p, result);\\n        if (j > 0) dfs(board, i, j - 1, p, result);\\n        if (i < board.size() - 1) dfs(board, i + 1, j, p, result);\\n        if (j < board[0].size() - 1) dfs(board, i, j + 1, p, result);\\n        board[i][j] = c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 138279,
                "title": "clean-javascript-solution",
                "content": "```js\\nconst findWords = (board, words) => {\\n  const dirs = [[-1, 0], [0, 1], [1, 0], [0, -1]];\\n  let res = [];\\n\\n  const buildTrie = () => {\\n    const root = {};\\n    for (const w of words) {\\n      let node = root;\\n      for (const c of w) {\\n        if (node[c] == null) node[c] = {};\\n        node = node[c];\\n      }\\n      node.word = w;\\n    }\\n    return root;\\n  };\\n\\n  const search = (node, x, y) => {\\n    if (node.word != null) {\\n      res.push(node.word);\\n      node.word = null; // make sure only print one time for each word\\n    }\\n\\n    if (x < 0 || x >= board.length || y < 0 || y >= board[0].length) return;\\n    if (node[board[x][y]] == null) return;\\n\\n    const c = board[x][y];\\n    board[x][y] = \\'#\\'; // Mark visited\\n    for (const [dx, dy] of dirs) {\\n      const i = x + dx;\\n      const j = y + dy;\\n      search(node[c], i, j);\\n    }\\n    board[x][y] = c; // Reset\\n  };\\n\\n  const root = buildTrie();\\n  for (let i = 0; i < board.length; i++) {\\n    for (let j = 0; j < board[0].length; j++) {\\n      search(root, i, j);\\n    }\\n  }\\n  return res;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Trie"
                ],
                "code": "```js\\nconst findWords = (board, words) => {\\n  const dirs = [[-1, 0], [0, 1], [1, 0], [0, -1]];\\n  let res = [];\\n\\n  const buildTrie = () => {\\n    const root = {};\\n    for (const w of words) {\\n      let node = root;\\n      for (const c of w) {\\n        if (node[c] == null) node[c] = {};\\n        node = node[c];\\n      }\\n      node.word = w;\\n    }\\n    return root;\\n  };\\n\\n  const search = (node, x, y) => {\\n    if (node.word != null) {\\n      res.push(node.word);\\n      node.word = null; // make sure only print one time for each word\\n    }\\n\\n    if (x < 0 || x >= board.length || y < 0 || y >= board[0].length) return;\\n    if (node[board[x][y]] == null) return;\\n\\n    const c = board[x][y];\\n    board[x][y] = \\'#\\'; // Mark visited\\n    for (const [dx, dy] of dirs) {\\n      const i = x + dx;\\n      const j = y + dy;\\n      search(node[c], i, j);\\n    }\\n    board[x][y] = c; // Reset\\n  };\\n\\n  const root = buildTrie();\\n  for (let i = 0; i < board.length; i++) {\\n    for (let j = 0; j < board[0].length; j++) {\\n      search(root, i, j);\\n    }\\n  }\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1512202,
                "title": "c-trie-dfs-o-m-n-4-length-of-largest-word-time-complexity",
                "content": "**TIME COMPLEXITY EXPLANATION**\\nFor single word search in a 2d matrix in [WORD SEARCH 1](https://leetcode.com/problems/word-search/discuss/1512539/c-dfs-backtracking-nm4size_of_word-time) problem we apply dfs at every point of matrix for that we run 2 for loops and their time complexity is m\\xD7n and in each dfs we visit 4^(sizeofword) because we are applying dfs calls to 4 directions for each character of the given word , so the time complexity for that will be m\\xD7n\\xD74^(sizeofword).Now coming to this problem, if we dont use Trie we will use the code of word search 1 problem but we will run 1 more for loop for each word in words array , so the time complexity of that would be no_of_word\\xD7(m\\xD7n\\xD74^(sum_of_lengths_of_all_words)) .Here, we are using trie because of that we dont need to run the extra for loop for each word due to which time complexity drops to m\\xD7n\\xD74^(length_of_largest_word) where length_of_largest_word is the height of the trie.\\nlink to [WORD SEARCH 1 PROBLEM SOLUTION](https://leetcode.com/problems/word-search/discuss/1512539/c-dfs-backtracking-nm4size_of_word-time) \\n\\n**CODE-**\\n```\\nclass Trie{\\npublic:\\n    string word;\\n    bool is_word=false;\\n    Trie* children[26]={NULL};\\n};\\n\\nclass Solution {\\nprivate:   \\n    Trie* root=NULL;\\n    \\n    void insert(string &s){\\n        Trie* temp=root;\\n        for(auto &i:s){\\n            int k=i-\\'a\\';\\n            if(temp->children[k]==NULL){\\n                temp->children[k]=new Trie;\\n            }\\n            temp=temp->children[k];\\n        }\\n        temp->word=s;\\n        temp->is_word=true;\\n    }\\n    \\n    void dfs(vector<vector<char>>&board, vector<string>&res, Trie* temp, int i, int j){\\n\\n        if(i<0 || i>=board.size() || j<0 || j>=board[0].size() || board[i][j]==\\'*\\' || !(temp->children[board[i][j]-\\'a\\']))\\n            return;\\n        \\n        temp=temp->children[board[i][j]-\\'a\\'];\\n        \\n        if(temp->is_word){\\n            res.push_back(temp->word);\\n            temp->is_word=false;\\n        }\\n        \\n        char temp_char = board[i][j];\\n        board[i][j]=\\'*\\';\\n        \\n        dfs(board, res, temp, i+1, j);\\n        dfs(board, res, temp, i, j+1);\\n        dfs(board, res, temp, i-1, j);\\n        dfs(board, res, temp, i, j-1);\\n        \\n        board[i][j]=temp_char;\\n        \\n        return;\\n    }\\n    \\npublic:\\n    Solution(){\\n        root=new Trie;\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        for(auto &s:words)\\n            insert(s);\\n        vector<string>res;\\n        Trie* temp=root;\\n        \\n        for(int i=0;i<board.size();i++)\\n            for(int j=0;j<board[0].size();j++)\\n                dfs(board, res, temp, i, j);\\n        \\n        return res;\\n    }\\n    \\n/*--------destructor not neccesary-----------\\n    ~Solution(){                      \\n        clear_nodes(root);\\n    }\\n    \\n    void clear_nodes(Trie* root) //\\n    {\\n        for(int i = 0; i<26; i++)\\n            if(root->children[i] != NULL)\\n                clear_nodes(root->children[i]);\\n        delete root;\\n    }\\n-------------------------------------------*/\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Trie",
                    "Recursion"
                ],
                "code": "```\\nclass Trie{\\npublic:\\n    string word;\\n    bool is_word=false;\\n    Trie* children[26]={NULL};\\n};\\n\\nclass Solution {\\nprivate:   \\n    Trie* root=NULL;\\n    \\n    void insert(string &s){\\n        Trie* temp=root;\\n        for(auto &i:s){\\n            int k=i-\\'a\\';\\n            if(temp->children[k]==NULL){\\n                temp->children[k]=new Trie;\\n            }\\n            temp=temp->children[k];\\n        }\\n        temp->word=s;\\n        temp->is_word=true;\\n    }\\n    \\n    void dfs(vector<vector<char>>&board, vector<string>&res, Trie* temp, int i, int j){\\n\\n        if(i<0 || i>=board.size() || j<0 || j>=board[0].size() || board[i][j]==\\'*\\' || !(temp->children[board[i][j]-\\'a\\']))\\n            return;\\n        \\n        temp=temp->children[board[i][j]-\\'a\\'];\\n        \\n        if(temp->is_word){\\n            res.push_back(temp->word);\\n            temp->is_word=false;\\n        }\\n        \\n        char temp_char = board[i][j];\\n        board[i][j]=\\'*\\';\\n        \\n        dfs(board, res, temp, i+1, j);\\n        dfs(board, res, temp, i, j+1);\\n        dfs(board, res, temp, i-1, j);\\n        dfs(board, res, temp, i, j-1);\\n        \\n        board[i][j]=temp_char;\\n        \\n        return;\\n    }\\n    \\npublic:\\n    Solution(){\\n        root=new Trie;\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        for(auto &s:words)\\n            insert(s);\\n        vector<string>res;\\n        Trie* temp=root;\\n        \\n        for(int i=0;i<board.size();i++)\\n            for(int j=0;j<board[0].size();j++)\\n                dfs(board, res, temp, i, j);\\n        \\n        return res;\\n    }\\n    \\n/*--------destructor not neccesary-----------\\n    ~Solution(){                      \\n        clear_nodes(root);\\n    }\\n    \\n    void clear_nodes(Trie* root) //\\n    {\\n        for(int i = 0; i<26; i++)\\n            if(root->children[i] != NULL)\\n                clear_nodes(root->children[i]);\\n        delete root;\\n    }\\n-------------------------------------------*/\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59881,
                "title": "my-java-solution-using-trie",
                "content": "    public class Solution {\\n        public class TrieNode{\\n            public boolean isWord = false;\\n            public TrieNode[] child = new TrieNode[26];\\n            public TrieNode(){\\n                \\n            }\\n        }\\n        \\n        TrieNode root = new TrieNode();\\n        boolean[][] flag;\\n        public List<String> findWords(char[][] board, String[] words) {\\n            Set<String> result = new HashSet<>();\\n            flag = new boolean[board.length][board[0].length];\\n            \\n            addToTrie(words);\\n            \\n            for(int i = 0; i < board.length; i++){\\n                for(int j = 0; j < board[0].length; j++){\\n                    if(root.child[board[i][j] - 'a'] != null){\\n                        search(board, i, j, root, \"\", result);\\n                    }\\n                }\\n            }\\n            \\n            return new LinkedList<>(result);\\n        }\\n        \\n        private void addToTrie(String[] words){\\n            for(String word: words){\\n                TrieNode node = root;\\n                for(int i = 0; i < word.length(); i++){\\n                    char ch = word.charAt(i);\\n                    if(node.child[ch - 'a'] == null){\\n                        node.child[ch - 'a'] = new TrieNode();\\n                    }\\n                    node = node.child[ch - 'a'];\\n                }\\n                node.isWord = true;\\n            }\\n        }\\n        \\n        private void search(char[][] board, int i, int j, TrieNode node, String word, Set<String> result){\\n            if(i >= board.length || i < 0 || j >= board[i].length || j < 0 || flag[i][j]){\\n                return;\\n            }\\n            \\n            if(node.child[board[i][j] - 'a'] == null){\\n                return;\\n            }\\n            \\n            flag[i][j] = true;\\n            node = node.child[board[i][j] - 'a'];\\n            if(node.isWord){\\n                result.add(word + board[i][j]);\\n            }\\n            \\n            search(board, i-1, j, node, word + board[i][j], result);\\n            search(board, i+1, j, node, word + board[i][j], result);\\n            search(board, i, j-1, node, word + board[i][j], result);\\n            search(board, i, j+1, node, word + board[i][j], result);\\n            \\n            flag[i][j] = false;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public class TrieNode{\\n            public boolean isWord = false;\\n            public TrieNode[] child = new TrieNode[26];\\n            public TrieNode(){\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2779789,
                "title": "python-c-dfs-using-trie-with-removal-with-detailed-comments",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs a Depth First Search approach using trie (with removal of words) for fast querying of prefixes that allows pruning of invalid paths. \\n\\n**Python.**\\n```\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        \\n        m, n = len(board), len(board[0])\\n        trie = Trie(words)                   # trie is initialized with a list of words\\n        seen = set()                         # found words are being collected into a set\\n                \\n        # generator that yields (!) adjacent cells\\n        def adj(x, y):\\n            for i,j in [(0,-1),(0,1),(-1,0),(1,0)]:\\n                if 0 <= x+i < m and 0 <= y+j < n:\\n                    yield (x+i,y+j)\\n        \\n        # DFS search with prefix \\'p\\', last cell (x,y) on board \\'b\\'\\n        def dfs(p, b, x, y):          \\n            \\n            ch, b[x][y] = b[x][y], \"#\"        # [1] mark used cell and save board state\\n            \\n            if trie.search(p):               \\n                seen.add(p)                   # [2] mark word as found and\\n                trie.remove(p)                #     no longer search for it\\n\\n            for i,j in adj(x, y):             # [3] iterate over adjacent cells\\n                if b[i][j] != \"#\":            #     which are still unused\\n                    pp = p + b[i][j]          #     and extend the word\\n                    if trie.starts(pp):       # [4] if the prefix exists in the trie,\\n                        dfs(pp, b, i, j)      #     we should check this branch\\n            \\n            b[x][y] = ch                      # [5] restore board state\\n        \\n        for i in range(m):                    # DFS procedure is initialized starting\\n            for j in range(n):                # from all possible cells (i,j)\\n                dfs(board[i][j], board, i, j)\\n        \\n        return seen\\n```\\nThe trie data structure is implemented using set/dict. It allows to search/remove words and to query prefixes.\\n```\\nclass Trie:\\n    def __init__(self, words=[]):\\n        self.trie = {}\\n        for w in words: self.insert(w)\\n\\n    def insert(self, word):\\n        t = self.trie\\n        for w in word:\\n            if w not in t:\\n                t[w] = {}\\n            t = t[w]\\n        t[\\'#\\'] = \\'#\\'\\n\\n    def search(self, word):\\n        t = self.trie\\n        for w in word:\\n            if w not in t:\\n                return False\\n            t = t[w]\\n        if \\'#\\' in t:\\n            return True\\n        return False\\n\\n    def starts(self, prefix):\\n        t = self.trie\\n        for w in prefix:\\n            if w not in t:\\n                return False\\n            t = t[w]\\n        return True\\n    \\n    def remove(self, word):\\n        t = self.trie\\n        nodes = []\\n        for w in word:\\n            if w not in t: return\\n            t = t[w]\\n            nodes.append((t,w))\\n\\n        if \\'#\\' in t:\\n            p = \\'#\\'\\n            for n,w in nodes[::-1]:\\n                if len(n[p]) == 0 or p == \\'#\\' : del n[p]\\n                p = w                \\n```\\n\\nHere is the same algorithm in other languages (C++ for now).\\n<iframe src=\"https://leetcode.com/playground/XfPDMsKZ/shared\" frameBorder=\"0\" width=\"800\" height=\"500\"></iframe>",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        \\n        m, n = len(board), len(board[0])\\n        trie = Trie(words)                   # trie is initialized with a list of words\\n        seen = set()                         # found words are being collected into a set\\n                \\n        # generator that yields (!) adjacent cells\\n        def adj(x, y):\\n            for i,j in [(0,-1),(0,1),(-1,0),(1,0)]:\\n                if 0 <= x+i < m and 0 <= y+j < n:\\n                    yield (x+i,y+j)\\n        \\n        # DFS search with prefix \\'p\\', last cell (x,y) on board \\'b\\'\\n        def dfs(p, b, x, y):          \\n            \\n            ch, b[x][y] = b[x][y], \"#\"        # [1] mark used cell and save board state\\n            \\n            if trie.search(p):               \\n                seen.add(p)                   # [2] mark word as found and\\n                trie.remove(p)                #     no longer search for it\\n\\n            for i,j in adj(x, y):             # [3] iterate over adjacent cells\\n                if b[i][j] != \"#\":            #     which are still unused\\n                    pp = p + b[i][j]          #     and extend the word\\n                    if trie.starts(pp):       # [4] if the prefix exists in the trie,\\n                        dfs(pp, b, i, j)      #     we should check this branch\\n            \\n            b[x][y] = ch                      # [5] restore board state\\n        \\n        for i in range(m):                    # DFS procedure is initialized starting\\n            for j in range(n):                # from all possible cells (i,j)\\n                dfs(board[i][j], board, i, j)\\n        \\n        return seen\\n```\n```\\nclass Trie:\\n    def __init__(self, words=[]):\\n        self.trie = {}\\n        for w in words: self.insert(w)\\n\\n    def insert(self, word):\\n        t = self.trie\\n        for w in word:\\n            if w not in t:\\n                t[w] = {}\\n            t = t[w]\\n        t[\\'#\\'] = \\'#\\'\\n\\n    def search(self, word):\\n        t = self.trie\\n        for w in word:\\n            if w not in t:\\n                return False\\n            t = t[w]\\n        if \\'#\\' in t:\\n            return True\\n        return False\\n\\n    def starts(self, prefix):\\n        t = self.trie\\n        for w in prefix:\\n            if w not in t:\\n                return False\\n            t = t[w]\\n        return True\\n    \\n    def remove(self, word):\\n        t = self.trie\\n        nodes = []\\n        for w in word:\\n            if w not in t: return\\n            t = t[w]\\n            nodes.append((t,w))\\n\\n        if \\'#\\' in t:\\n            p = \\'#\\'\\n            for n,w in nodes[::-1]:\\n                if len(n[p]) == 0 or p == \\'#\\' : del n[p]\\n                p = w                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 59836,
                "title": "my-c-trie-backtrace-based-solution-48-ms",
                "content": "The idea is to use a Trie to build a prefix tree for words to simplify the search and do DFS to search all the possible strings. \\nFor Trie, 26 pointers to point the sub-strings and a bool leaf to indicate whether the current node is a leaf (i.e. a string in words) and also idx is used to save the index of words for the current node.\\nFor DFS, just check if the current position is visited before (board[i][j]=='X'), if so, return, check if there is a string with such prefix (nullptr == root->children[words[idx][pos]-'a']), if not, return; otherwise, check if the current searched string is a leaf of the trie (a string in words), if so, save it to res and set leaf of the trie node to false to indicate such string is already found. At last, move to its neighbors to continue the search. Remember to recover the char [i][j] at the end.    \\n\\n        class Solution {\\n            class Trie{\\n            public:\\n                Trie *children[26]; // pointers to its substrings starting with 'a' to 'z'\\n                bool leaf; // if the node is a leaf, or if there is a word stopping at here\\n                int idx; // if it is a leaf, the string index of the array words\\n                Trie()\\n                {\\n                    this->leaf = false;\\n                    this->idx = 0;\\n                    fill_n(this->children, 26, nullptr);            \\n                }\\n            };\\n            \\n        public:\\n            void insertWords(Trie *root, vector<string>& words, int idx)\\n            {\\n                int pos = 0, len = words[idx].size();\\n                while(pos<len)\\n                {\\n                    if(nullptr == root->children[words[idx][pos]-'a']) root->children[words[idx][pos]-'a'] = new Trie();\\n                    root = root->children[words[idx][pos++]-'a'];\\n                }\\n                root->leaf = true;\\n                root->idx = idx;\\n            }\\n            \\n            Trie *buildTrie(vector<string>& words)\\n            {\\n                Trie *root = new Trie(); \\n                int i;\\n                for(i=0; i<words.size();i++) insertWords(root, words, i);\\n                return root;\\n            }\\n            \\n            void checkWords(vector<vector<char>>& board, int i, int j, int row, int col, Trie *root, vector<string> &res, vector<string>& words)\\n            {\\n                char temp;\\n                if(board[i][j]=='X') return; // visited before;\\n                if(nullptr == root->children[board[i][j]-'a']) return ; // no string with such prefix\\n                else\\n                {\\n                    temp = board[i][j];\\n                    if(root->children[temp-'a']->leaf)  // if it is a leaf\\n                    {\\n                        res.push_back(words[root->children[temp-'a']->idx]);\\n                        root->children[temp-'a']->leaf = false; // set to false to indicate that we found it already\\n                    }\\n                    board[i][j]='X'; //mark the current position as visited\\n    // check all the possible neighbors\\n                    if(i>0) checkWords(board, i-1, j, row, col, root->children[temp-'a'], res, words);\\n                    if((i+1)<row) checkWords(board, i+1, j, row, col,  root->children[temp-'a'], res, words);\\n                    if(j>0) checkWords(board, i, j-1,  row, col, root->children[temp-'a'], res, words);\\n                    if((j+1)<col)  checkWords(board, i, j+1,  row, col, root->children[temp-'a'], res, words);\\n                    board[i][j] = temp; // recover the current position\\n                }\\n            }\\n        \\n            vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n               vector<string> res;\\n               int row = board.size();\\n               if(0==row) return res;\\n               int col = board[0].size();\\n               if(0==col) return res;\\n               int wordCount = words.size();\\n               if(0==wordCount) return res;\\n               \\n               Trie *root = buildTrie(words);\\n               \\n               int i,j;\\n               for(i =0 ; i<row; i++)\\n               {\\n                   for(j=0; j<col && wordCount > res.size(); j++)\\n                   {\\n                       checkWords(board, i, j, row, col, root, res, words);\\n                   }\\n               }\\n               return res;\\n            }\\n     };\\n\\nBased on the comments received. I created another version with Trie node counter (thanks,   zhiqing_xiao and gxyeecspku). However, for the current test set, it doesn't help too much. Anyway, my version with Trie node counter.\\n\\n    class Solution {\\n    private:\\n    class Trie\\n    {\\n    public:    \\n        Trie * children[26];\\n        bool isLeaf;\\n        int  wordIdx;\\n        int prefixCount;\\n        \\n        Trie()\\n        {\\n            isLeaf = false;\\n            wordIdx = 0;\\n            prefixCount = 0;\\n            fill_n(children, 26, nullptr);\\n        }\\n        \\n        ~Trie()\\n        {\\n            for(auto i=0; i<26; ++i) delete children[i];\\n        }\\n    };\\n        void insertWord(Trie *root,  const vector<string>& words, int idx)\\n        {\\n            int i, childID, len = words[idx].size();\\n            for(i=0, root->prefixCount++ ; i<len; ++i)\\n            {\\n                childID = words[idx][i]-'a';\\n                if(!root->children[childID]) root->children[childID] = new Trie();\\n                root = root->children[childID];\\n                ++root->prefixCount;\\n            }\\n            root->isLeaf = true; \\n            root->wordIdx = idx;\\n        }\\n        \\n        Trie *buildTrie(const vector<string> &words)\\n        {\\n            Trie *root = new Trie();\\n            for(int i=0; i < words.size(); ++i) insertWord(root, words, i);\\n            return root;\\n        }\\n        \\n        int dfs_Trie(vector<string> &res, Trie *root, vector<vector<char>>& board, vector<string>& words, int row, int col)\\n        {\\n            int detected = 0;\\n    \\n            if(root->isLeaf)\\n            {\\n                ++detected;\\n                root->isLeaf = false;\\n                res.push_back(words[root->wordIdx]);\\n            }\\n            \\n            if( row<0 || row>=board.size() || col<0 || col>=board[0].size() || board[row][col]=='*' || !root->children[ board[row][col]-'a'] || root->children[ board[row][col]-'a']->prefixCount <= 0 ) return detected;\\n            int curC = board[row][col] - 'a';\\n            board[row][col] = '*';\\n            detected += dfs_Trie(res, root->children[curC], board, words, row-1, col) + \\n                   dfs_Trie(res, root->children[curC], board, words, row+1, col) +    \\n                   dfs_Trie(res, root->children[curC], board, words, row, col - 1) +    \\n                   dfs_Trie(res, root->children[curC], board, words, row, col + 1) ;\\n            root->prefixCount -=detected;\\n            board[row][col] = curC+'a';\\n            return detected;\\n        }\\n        \\n    public:\\n        vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n            int M, N, wordNum = words.size();\\n            vector<string> res;\\n            if( !(M = board.size()) || !(N = board[0].size()) || !wordNum) return res;\\n            Trie *root = buildTrie(words);\\n            for(auto i=0; i<M && root->prefixCount; ++i)\\n                for(auto j=0; j<N; ++j)\\n                    dfs_Trie(res, root, board, words, i, j);\\n            delete root;\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n            class Trie{\\n            public:\\n                Trie *children[26]; // pointers to its substrings starting with 'a' to 'z'\\n                bool leaf; // if the node is a leaf, or if there is a word stopping at here\\n                int idx; // if it is a leaf, the string index of the array words\\n                Trie()\\n                {\\n                    this->leaf = false;\\n                    this->idx = 0;\\n                    fill_n(this->children, 26, nullptr);            \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2779665,
                "title": "python-using-tries",
                "content": "If you like, please up vote\\n\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.isWord = False\\n        self.refs = 0\\n\\n    def addWord(self, word):\\n        cur = self\\n        cur.refs += 1\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        cur.isWord = True\\n\\n    def removeWord(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        root = TrieNode()\\n        for w in words:\\n            root.addWord(w)\\n\\n        ROWS, COLS = len(board), len(board[0])\\n        res, visit = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r == ROWS\\n                or c == COLS\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in visit\\n            ):\\n                return\\n\\n            visit.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.isWord:\\n                node.isWord = False\\n                res.add(word)\\n                root.removeWord(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            visit.remove((r, c))\\n\\n        for r in range(ROWS):\\n            for c in range(COLS):\\n                dfs(r, c, root, \"\")\\n\\n        return list(res)\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.isWord = False\\n        self.refs = 0\\n\\n    def addWord(self, word):\\n        cur = self\\n        cur.refs += 1\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        cur.isWord = True\\n\\n    def removeWord(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        root = TrieNode()\\n        for w in words:\\n            root.addWord(w)\\n\\n        ROWS, COLS = len(board), len(board[0])\\n        res, visit = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r == ROWS\\n                or c == COLS\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in visit\\n            ):\\n                return\\n\\n            visit.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.isWord:\\n                node.isWord = False\\n                res.add(word)\\n                root.removeWord(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            visit.remove((r, c))\\n\\n        for r in range(ROWS):\\n            for c in range(COLS):\\n                dfs(r, c, root, \"\")\\n\\n        return list(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1870133,
                "title": "c-explanation-with-pictures-trie-backtracking",
                "content": "Prerequisite : https://leetcode.com/problems/implement-trie-prefix-tree/\\nThis will help in trie implementation part. A must do inshort.\\n\\nStructure of Trie Node : \\n```\\nclass trie {\\n    public:\\n    trie *arr[26];\\n    bool end = false; // if a word ends here or not since there can be prefixes as well\\n    string s = \"\"; // to keep track of how far down we have traversed\\n    trie() {\\n        memset(arr, 0, sizeof(arr));\\n    }\\n};\\n```\\n\\nDefinition of trie : \\n```\\nclass Trie {\\n    public:\\n    trie *root;\\n    Trie() {\\n        root = new trie();\\n    }\\n    void insert(string &word)\\n    {\\n        int n = word.size();\\n        trie *temp = root;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(temp->arr[word[i]-\\'a\\'] == NULL)\\n            {\\n                temp->arr[word[i]-\\'a\\'] = new trie();\\n            }\\n            temp = temp->arr[word[i]-\\'a\\'];\\n        }\\n        temp->end = true;\\n\\t\\t// making use of string only here since we don\\'t need it otherwise\\n        temp->s = word;\\n    }\\n};\\n```\\n***Explanation:***\\n![image](https://assets.leetcode.com/users/images/f30984f0-0251-453d-af6f-e41ced1770e4_1647864493.0455797.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/305a5242-c583-4eb0-bbd7-baf4f31770c2_1647864500.991744.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n\\t// we can move in all 4 directions in very less line(s) of code using this\\n    vector<vector<int>> moves{{0,0,-1,1}, {1,-1,0,0}};\\n\\t\\n\\t//our final ans\\n    vector<string> ans;\\n\\t\\n\\t//main function\\n    void dfs(vector<vector<char>>& board, vector<string>& s, trie* ptr, int i, int j)\\n    {\\n        if(i==-1 || i==board.size() || j==-1 || j==board[0].size() || board[i][j]==\\'#\\') return;\\n        \\n\\t\\t//traversing towards the character board[i][j] of the string (if present)\\n\\t\\t//this will be the first character of string when executed the first time (from the main original function)\\n        ptr = ptr->arr[board[i][j]-\\'a\\'];\\n        \\n\\t\\t//if no such word exist then we simply return\\n        if(!ptr) return;\\n\\t\\t\\n\\t\\t//if this is a end that means a word exists so we append it to our ans\\n        if(ptr->end) \\n        {\\n            ptr->end = false;\\n            ans.push_back(ptr->s);\\n        }\\n\\t\\t\\n\\t\\t//since we can\\'t come to a cell once traversed \\n        char el = board[i][j];\\n\\t\\t// we make it unusable for mean time\\n        board[i][j] = \\'#\\';\\n\\t\\t\\n\\t\\t//traversing in all 4 directions with a single line of code !!\\n        for(int x=0; x<4; x++) dfs(board, s, ptr, i+moves[0][x], j+moves[1][x]);\\n\\t\\t\\n\\t\\t//backtracking\\n        board[i][j] = el;\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& s) {\\n        int n = board.size(), m = board[0].size(), ss = s.size();\\n        Trie obj\\n\\t\\t//building the trie\\n        for(int k=0; k<ss; k++)\\n        {\\n            obj.insert(s[k]);\\n        }\\n\\t\\t//instead of traversing for all words we just traverse one time across the whole board\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                dfs(board, s, obj.root, i, j);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nA more cleaner approach:\\n```\\nclass Trie {\\n    public:\\n        unordered_map<char, Trie*> child;\\n        bool isEnd = false;\\n        string word;\\n};\\nclass Solution {\\npublic:\\n    Trie* root = new Trie();\\n\\n    void insertWord(string &s)\\n    {\\n        Trie* temp = root;\\n        for(char c : s)\\n        {\\n            if(temp->child.find(c) == temp->child.end())\\n                temp->child[c] = new Trie();\\n            temp = temp->child[c];\\n        }\\n        temp->isEnd = true;\\n        temp->word = s;\\n    }\\n    vector<string> ans;\\n    bool isValid(int i, int j, int n, int m)\\n    {\\n        return (i >= 0 and j >= 0 and i < n and j < m);\\n    }\\n    void rec(int i, int j, int n, int m, vector<vector<char>> &board, vector<vector<bool>> &vis, Trie* temp)\\n    {\\n        if(temp->isEnd)\\n        {\\n            temp->isEnd = false;\\n            ans.push_back(temp->word);\\n        }\\n        int dir[5] = {-1, 0, 1, 0, -1};\\n\\n        for(int k=0; k<4; ++k)\\n        {\\n            int new_i = i + dir[k];\\n            int new_j = j + dir[k+1];\\n\\n            if(isValid(new_i, new_j, n, m) && temp->child.find(board[new_i][new_j]) != temp->child.end() && !vis[new_i][new_j])\\n            {\\n                vis[new_i][new_j] = true;\\n\\n                rec(new_i, new_j, n, m, board, vis, temp->child[board[new_i][new_j]]);\\n\\n                vis[new_i][new_j] = false;\\n            }\\n        }\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        for(auto s : words)\\n            insertWord(s);\\n\\n        int n = board.size(), m = board[0].size();\\n        vector<vector<bool>> vis(n, vector<bool>(m));\\n\\n        for(int i=0; i<n; ++i)\\n        {\\n            for(int j=0; j<m; ++j)\\n            {\\n                if(root->child.find(board[i][j]) != root->child.end())\\n                {\\n                    Trie* temp = root;\\n                    vis[i][j] = true;\\n                    rec(i, j, n, m, board, vis, temp->child[board[i][j]]);\\n                    vis[i][j] = false;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nNow the last important thing left to cover is **UPVOTE**. Make sure you do it, if this answer helpful.\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Trie"
                ],
                "code": "```\\nclass trie {\\n    public:\\n    trie *arr[26];\\n    bool end = false; // if a word ends here or not since there can be prefixes as well\\n    string s = \"\"; // to keep track of how far down we have traversed\\n    trie() {\\n        memset(arr, 0, sizeof(arr));\\n    }\\n};\\n```\n```\\nclass Trie {\\n    public:\\n    trie *root;\\n    Trie() {\\n        root = new trie();\\n    }\\n    void insert(string &word)\\n    {\\n        int n = word.size();\\n        trie *temp = root;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(temp->arr[word[i]-\\'a\\'] == NULL)\\n            {\\n                temp->arr[word[i]-\\'a\\'] = new trie();\\n            }\\n            temp = temp->arr[word[i]-\\'a\\'];\\n        }\\n        temp->end = true;\\n\\t\\t// making use of string only here since we don\\'t need it otherwise\\n        temp->s = word;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\t// we can move in all 4 directions in very less line(s) of code using this\\n    vector<vector<int>> moves{{0,0,-1,1}, {1,-1,0,0}};\\n\\t\\n\\t//our final ans\\n    vector<string> ans;\\n\\t\\n\\t//main function\\n    void dfs(vector<vector<char>>& board, vector<string>& s, trie* ptr, int i, int j)\\n    {\\n        if(i==-1 || i==board.size() || j==-1 || j==board[0].size() || board[i][j]==\\'#\\') return;\\n        \\n\\t\\t//traversing towards the character board[i][j] of the string (if present)\\n\\t\\t//this will be the first character of string when executed the first time (from the main original function)\\n        ptr = ptr->arr[board[i][j]-\\'a\\'];\\n        \\n\\t\\t//if no such word exist then we simply return\\n        if(!ptr) return;\\n\\t\\t\\n\\t\\t//if this is a end that means a word exists so we append it to our ans\\n        if(ptr->end) \\n        {\\n            ptr->end = false;\\n            ans.push_back(ptr->s);\\n        }\\n\\t\\t\\n\\t\\t//since we can\\'t come to a cell once traversed \\n        char el = board[i][j];\\n\\t\\t// we make it unusable for mean time\\n        board[i][j] = \\'#\\';\\n\\t\\t\\n\\t\\t//traversing in all 4 directions with a single line of code !!\\n        for(int x=0; x<4; x++) dfs(board, s, ptr, i+moves[0][x], j+moves[1][x]);\\n\\t\\t\\n\\t\\t//backtracking\\n        board[i][j] = el;\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& s) {\\n        int n = board.size(), m = board[0].size(), ss = s.size();\\n        Trie obj\\n\\t\\t//building the trie\\n        for(int k=0; k<ss; k++)\\n        {\\n            obj.insert(s[k]);\\n        }\\n\\t\\t//instead of traversing for all words we just traverse one time across the whole board\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                dfs(board, s, obj.root, i, j);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Trie {\\n    public:\\n        unordered_map<char, Trie*> child;\\n        bool isEnd = false;\\n        string word;\\n};\\nclass Solution {\\npublic:\\n    Trie* root = new Trie();\\n\\n    void insertWord(string &s)\\n    {\\n        Trie* temp = root;\\n        for(char c : s)\\n        {\\n            if(temp->child.find(c) == temp->child.end())\\n                temp->child[c] = new Trie();\\n            temp = temp->child[c];\\n        }\\n        temp->isEnd = true;\\n        temp->word = s;\\n    }\\n    vector<string> ans;\\n    bool isValid(int i, int j, int n, int m)\\n    {\\n        return (i >= 0 and j >= 0 and i < n and j < m);\\n    }\\n    void rec(int i, int j, int n, int m, vector<vector<char>> &board, vector<vector<bool>> &vis, Trie* temp)\\n    {\\n        if(temp->isEnd)\\n        {\\n            temp->isEnd = false;\\n            ans.push_back(temp->word);\\n        }\\n        int dir[5] = {-1, 0, 1, 0, -1};\\n\\n        for(int k=0; k<4; ++k)\\n        {\\n            int new_i = i + dir[k];\\n            int new_j = j + dir[k+1];\\n\\n            if(isValid(new_i, new_j, n, m) && temp->child.find(board[new_i][new_j]) != temp->child.end() && !vis[new_i][new_j])\\n            {\\n                vis[new_i][new_j] = true;\\n\\n                rec(new_i, new_j, n, m, board, vis, temp->child[board[new_i][new_j]]);\\n\\n                vis[new_i][new_j] = false;\\n            }\\n        }\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        for(auto s : words)\\n            insertWord(s);\\n\\n        int n = board.size(), m = board[0].size();\\n        vector<vector<bool>> vis(n, vector<bool>(m));\\n\\n        for(int i=0; i<n; ++i)\\n        {\\n            for(int j=0; j<m; ++j)\\n            {\\n                if(root->child.find(board[i][j]) != root->child.end())\\n                {\\n                    Trie* temp = root;\\n                    vis[i][j] = true;\\n                    rec(i, j, n, m, board, vis, temp->child[board[i][j]]);\\n                    vis[i][j] = false;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 156559,
                "title": "java-26ms-solution-with-complexity-analysis",
                "content": "```\\n/*\\nIdea: The brute-force solution is to DFS all cells for every word in the dictionary. The time complexity will be O(m * n * wl * l) where \\nm is board.length, n is board[0].length, l is words.length and wl is the average of length of words in \\'words\\'.\\n\\nInstead, we use a Trie to check multiple words at the same time when DFS from a certain cell.\\n\\nComplexity - \\nTime: O(m * n * wl * l) = max(O(wl * l), O(m * n * l * wl)) where\\nO(wl * l) - Build the trie\\nO(m * n * wl * l) - In the worst case where all words start with different chracters, and there is a word starting with a character\\nin the cell board[m - 1][n - 1], we have O(m * n * wl * l). However, if there are words starting with same characters and paths sharing\\ncells, Trie can check multiple words when DFS from a certain cell, rather than check ONLY ONE word when DFS from a certain cell like the \\nbrute-force solution.\\n\\nSpace: O(wl * l) = max(O(wl), O(wl * l)) where\\nO(wl) - The recursive stack can grow at most to wl layers. \\nO(wl * l) - In the worst case when all words start with different characters, the trie has wl * l nodes. Also, since each word\\nis stored in a leaf node, all the leaf nodes require wl * l memory.\\n*/\\npublic class Solution {\\n    private List<String> result = new ArrayList<>();\\n\\t\\n    public List<String> findWords(char[][] board, String[] words) {\\n        List<String> result = new ArrayList<>();\\n        if (board == null || words == null || words.length == 0) {\\n            return result;\\n        }\\n        \\n        TrieNode root = buildTrie(words);\\n        \\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[0].length; j++) {\\n                recursiveFindWords(result, board, root, i, j);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private void recursiveFindWords(char[][] board, TrieNode parent, int x, int y) {   \\n        if (outOfBounds(board, x, y) || board[x][y] == \\'#\\' || parent.children.get(board[x][y]) == null) {\\n            return; // return if out of bounds, if visited and if current cell is not a character in the trie\\n        }\\n        \\n        char xy = board[x][y];\\n        TrieNode child = parent.children.get(xy);\\n        if (child.isEndOfWord) { // Found a word\\n            result.add(child.word);\\n            child.isEndOfWord = false; // Set to false to avoid adding word to result multiple times\\n            // Don\\'t RETURN since child.word can be a prefix of other words, e.g., \\'ane\\' and \\'aneis\\'\\n        }\\n        \\n        board[x][y] = \\'#\\'; // \\'#\\' marks a cell as visited\\n        \\n        recursiveFindWords(board, child, x, y - 1); // left\\n        recursiveFindWords(board, child, x - 1, y); // up\\n        recursiveFindWords(board, child, x, y + 1); // right\\n        recursiveFindWords(board, child, x + 1, y); // down\\n        \\n        board[x][y] = xy; // Set as unvisited since we are about to backtracking\\n    }\\n    \\n    private boolean outOfBounds(char[][] board, int x, int y) {\\n        return x < 0 || x >= board.length || y < 0 || y >= board[0].length;\\n    }\\n    \\n    // The trie is represented by a root node, not a Trie object\\n    private TrieNode buildTrie(String[] words) {\\n        TrieNode root = new TrieNode();\\n        for (String word : words) {\\n            if (word == null || word.isEmpty()) {\\n                continue;\\n            }\\n            \\n            TrieNode parent = root;\\n            for (int i = 0; i < word.length(); i++) {\\n                char cur = word.charAt(i);\\n                \\n                TrieNode child = parent.children.get(cur);\\n                if (child == null) {\\n                    child = new TrieNode();\\n                    parent.children.put(cur, child);\\n                }\\n                \\n                parent = child;\\n            }\\n            \\n            parent.isEndOfWord = true;\\n            parent.word = word; // Store a word at the leaf node\\n        }\\n        \\n        return root;\\n    }\\n    \\n    private class TrieNode {\\n        boolean isEndOfWord; // this.word is null if isEndOfWord is false\\n        String word; // Store the word so that no StringBuilder is needed to build the word char by char\\n        Map<Character, TrieNode> children;\\n        \\n        TrieNode() {\\n            this.children = new HashMap<>();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nIdea: The brute-force solution is to DFS all cells for every word in the dictionary. The time complexity will be O(m * n * wl * l) where \\nm is board.length, n is board[0].length, l is words.length and wl is the average of length of words in \\'words\\'.\\n\\nInstead, we use a Trie to check multiple words at the same time when DFS from a certain cell.\\n\\nComplexity - \\nTime: O(m * n * wl * l) = max(O(wl * l), O(m * n * l * wl)) where\\nO(wl * l) - Build the trie\\nO(m * n * wl * l) - In the worst case where all words start with different chracters, and there is a word starting with a character\\nin the cell board[m - 1][n - 1], we have O(m * n * wl * l). However, if there are words starting with same characters and paths sharing\\ncells, Trie can check multiple words when DFS from a certain cell, rather than check ONLY ONE word when DFS from a certain cell like the \\nbrute-force solution.\\n\\nSpace: O(wl * l) = max(O(wl), O(wl * l)) where\\nO(wl) - The recursive stack can grow at most to wl layers. \\nO(wl * l) - In the worst case when all words start with different characters, the trie has wl * l nodes. Also, since each word\\nis stored in a leaf node, all the leaf nodes require wl * l memory.\\n*/\\npublic class Solution {\\n    private List<String> result = new ArrayList<>();\\n\\t\\n    public List<String> findWords(char[][] board, String[] words) {\\n        List<String> result = new ArrayList<>();\\n        if (board == null || words == null || words.length == 0) {\\n            return result;\\n        }\\n        \\n        TrieNode root = buildTrie(words);\\n        \\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[0].length; j++) {\\n                recursiveFindWords(result, board, root, i, j);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private void recursiveFindWords(char[][] board, TrieNode parent, int x, int y) {   \\n        if (outOfBounds(board, x, y) || board[x][y] == \\'#\\' || parent.children.get(board[x][y]) == null) {\\n            return; // return if out of bounds, if visited and if current cell is not a character in the trie\\n        }\\n        \\n        char xy = board[x][y];\\n        TrieNode child = parent.children.get(xy);\\n        if (child.isEndOfWord) { // Found a word\\n            result.add(child.word);\\n            child.isEndOfWord = false; // Set to false to avoid adding word to result multiple times\\n            // Don\\'t RETURN since child.word can be a prefix of other words, e.g., \\'ane\\' and \\'aneis\\'\\n        }\\n        \\n        board[x][y] = \\'#\\'; // \\'#\\' marks a cell as visited\\n        \\n        recursiveFindWords(board, child, x, y - 1); // left\\n        recursiveFindWords(board, child, x - 1, y); // up\\n        recursiveFindWords(board, child, x, y + 1); // right\\n        recursiveFindWords(board, child, x + 1, y); // down\\n        \\n        board[x][y] = xy; // Set as unvisited since we are about to backtracking\\n    }\\n    \\n    private boolean outOfBounds(char[][] board, int x, int y) {\\n        return x < 0 || x >= board.length || y < 0 || y >= board[0].length;\\n    }\\n    \\n    // The trie is represented by a root node, not a Trie object\\n    private TrieNode buildTrie(String[] words) {\\n        TrieNode root = new TrieNode();\\n        for (String word : words) {\\n            if (word == null || word.isEmpty()) {\\n                continue;\\n            }\\n            \\n            TrieNode parent = root;\\n            for (int i = 0; i < word.length(); i++) {\\n                char cur = word.charAt(i);\\n                \\n                TrieNode child = parent.children.get(cur);\\n                if (child == null) {\\n                    child = new TrieNode();\\n                    parent.children.put(cur, child);\\n                }\\n                \\n                parent = child;\\n            }\\n            \\n            parent.isEndOfWord = true;\\n            parent.word = word; // Store a word at the leaf node\\n        }\\n        \\n        return root;\\n    }\\n    \\n    private class TrieNode {\\n        boolean isEndOfWord; // this.word is null if isEndOfWord is false\\n        String word; // Store the word so that no StringBuilder is needed to build the word char by char\\n        Map<Character, TrieNode> children;\\n        \\n        TrieNode() {\\n            this.children = new HashMap<>();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2545262,
                "title": "python-100-00-faster-runtime-33-ms-memory-usage-13-7-mb-less-than-98-35",
                "content": "# Please upvote if you find it useful.\\n\\n\\'\\'\\'\\n\\n    def findWords(self, board, words):\\n\\n       m, n = len(board), len(board[0])\\n        dic = defaultdict(set)\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                dic[board[i][j]].add((i, j))\\n        \\n        results = deque()\\n        \\n        word, lngth, word_isReversed = \\'\\', 0, False\\n        def dfs(cord, indx):\\n            if indx == lngth: \\n                if word_isReversed:\\n                    results.append(word[::-1])\\n                else:\\n                    results.append(word)\\n                return True\\n            \\n            ch = word[indx]\\n            i, j = cord\\n            for cand in [(i - 1, j), (i, j - 1), (i, j + 1), (i + 1, j)]:\\n                if cand in dic[ch]:\\n                    dic[ch].remove(cand)\\n                    flag = dfs(cand, indx + 1)\\n                    dic[ch].add(cand)\\n                    if flag: return True\\n\\n            return False\\n            \\n        \\n        ref = set()\\n        for i in range(m):\\n            for j in range(n - 1):\\n                ref.add(board[i][j] + board[i][j + 1])\\n        for j in range(n):\\n            for i in range(m - 1):\\n                ref.add(board[i][j] + board[i + 1][j])\\n                    \\n        #len_dic = len(dic)\\n        def check(word):\\n            for i in range(len(word) - 1):\\n                if word[i] + word[i + 1] not in ref:\\n                    if word[i + 1] + word[i] not in ref:\\n                        return False\\n            # wordCount = Counter(word)\\n            # if len(wordCount) > len_dic:\\n            #     return False\\n            # for ch, count in wordCount.items():\\n            #     if len(dic[ch]) < count:\\n            #         return False\\n            return True\\n        \\n        \\n        for w in words:\\n            if check(w):\\n                if w[:4] == w[0]*4 or len(dic[w[-1]]) < len(dic[w[0]]):\\n                    word = w[::-1]\\n                    word_isReversed = True\\n                else:\\n                    word = w\\n                    if word_isReversed: word_isReversed = False\\n        \\n                lngth = len(word)\\n                for cord in list(dic[word[0]]):\\n                    dic[word[0]].remove(cord)\\n                    flag = dfs(cord, 1)\\n                    dic[word[0]].add(cord)\\n                    if flag: break\\n            \\n        return results\\n\\t\\'\\'\\'",
                "solutionTags": [
                    "Python"
                ],
                "code": "# Please upvote if you find it useful.\\n\\n\\'\\'\\'\\n\\n    def findWords(self, board, words):\\n\\n       m, n = len(board), len(board[0])\\n        dic = defaultdict(set)\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                dic[board[i][j]].add((i, j))\\n        \\n        results = deque()\\n        \\n        word, lngth, word_isReversed = \\'\\', 0, False\\n        def dfs(cord, indx):\\n            if indx == lngth: \\n                if word_isReversed:\\n                    results.append(word[::-1])\\n                else:\\n                    results.append(word)\\n                return True\\n            \\n            ch = word[indx]\\n            i, j = cord\\n            for cand in [(i - 1, j), (i, j - 1), (i, j + 1), (i + 1, j)]:\\n                if cand in dic[ch]:\\n                    dic[ch].remove(cand)\\n                    flag = dfs(cand, indx + 1)\\n                    dic[ch].add(cand)\\n                    if flag: return True\\n\\n            return False\\n            \\n        \\n        ref = set()\\n        for i in range(m):\\n            for j in range(n - 1):\\n                ref.add(board[i][j] + board[i][j + 1])\\n        for j in range(n):\\n            for i in range(m - 1):\\n                ref.add(board[i][j] + board[i + 1][j])\\n                    \\n        #len_dic = len(dic)\\n        def check(word):\\n            for i in range(len(word) - 1):\\n                if word[i] + word[i + 1] not in ref:\\n                    if word[i + 1] + word[i] not in ref:\\n                        return False\\n            # wordCount = Counter(word)\\n            # if len(wordCount) > len_dic:\\n            #     return False\\n            # for ch, count in wordCount.items():\\n            #     if len(dic[ch]) < count:\\n            #         return False\\n            return True\\n        \\n        \\n        for w in words:\\n            if check(w):\\n                if w[:4] == w[0]*4 or len(dic[w[-1]]) < len(dic[w[0]]):\\n                    word = w[::-1]\\n                    word_isReversed = True\\n                else:\\n                    word = w\\n                    if word_isReversed: word_isReversed = False\\n        \\n                lngth = len(word)\\n                for cord in list(dic[word[0]]):\\n                    dic[word[0]].remove(cord)\\n                    flag = dfs(cord, 1)\\n                    dic[word[0]].add(cord)\\n                    if flag: break\\n            \\n        return results\\n\\t\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 564747,
                "title": "python-3-beats-99-02-trie-and-dfs",
                "content": "```\\nfrom functools import reduce\\nfrom collections import defaultdict\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        \\n        # create trie\\n        Trie = lambda: defaultdict(Trie)\\n        trie = Trie()\\n        END = True\\n        \\n        for word in words:\\n            reduce(dict.__getitem__,word,trie)[END] = word\\n        \\n        res = set()\\n        def findstr(i,j,t):\\n            if END in t:\\n                res.add(t[END])\\n                # return\\n            letter = board[i][j]\\n            board[i][j] = \"\"\\n            if i > 0 and board[i-1][j] in t:\\n                findstr(i-1,j,t[board[i-1][j]])\\n            if j>0 and board[i][j-1] in t:\\n                findstr(i,j-1,t[board[i][j-1]])\\n            if i < len(board)-1 and board[i+1][j] in t:\\n                findstr(i+1,j,t[board[i+1][j]])\\n            if j < len(board[0])-1 and board[i][j+1] in t:\\n                findstr(i,j+1,t[board[i][j+1]])\\n            board[i][j] = letter\\n            \\n            return \\n        \\n        for i, row in enumerate(board):\\n            for j, char in enumerate(row):\\n                if board[i][j] in trie:\\n                    findstr(i,j,trie[board[i][j]])\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Trie"
                ],
                "code": "```\\nfrom functools import reduce\\nfrom collections import defaultdict\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        \\n        # create trie\\n        Trie = lambda: defaultdict(Trie)\\n        trie = Trie()\\n        END = True\\n        \\n        for word in words:\\n            reduce(dict.__getitem__,word,trie)[END] = word\\n        \\n        res = set()\\n        def findstr(i,j,t):\\n            if END in t:\\n                res.add(t[END])\\n                # return\\n            letter = board[i][j]\\n            board[i][j] = \"\"\\n            if i > 0 and board[i-1][j] in t:\\n                findstr(i-1,j,t[board[i-1][j]])\\n            if j>0 and board[i][j-1] in t:\\n                findstr(i,j-1,t[board[i][j-1]])\\n            if i < len(board)-1 and board[i+1][j] in t:\\n                findstr(i+1,j,t[board[i+1][j]])\\n            if j < len(board[0])-1 and board[i][j+1] in t:\\n                findstr(i,j+1,t[board[i][j+1]])\\n            board[i][j] = letter\\n            \\n            return \\n        \\n        for i, row in enumerate(board):\\n            for j, char in enumerate(row):\\n                if board[i][j] in trie:\\n                    findstr(i,j,trie[board[i][j]])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780127,
                "title": "c-trie-dfs-backtracking-faster-easy-to-understand",
                "content": "* ***Using Trie + DFS + Backtracking***\\n\\n```\\nclass Solution {\\npublic:\\n\\n    // declare a structure for TrieNode\\n\\n    struct TrieNode\\n    {\\n        bool is_end;\\n\\n        string word;\\n\\n        TrieNode* child[26];\\n\\n        TrieNode()\\n        {\\n            is_end = false;\\n\\n            word = \"\";\\n\\n            for(int i = 0; i < 26; i++)\\n            {\\n                child[i] = NULL;\\n            }\\n        }\\n    };\\n\\n    // declare root of the Trie\\n\\n    TrieNode* root = new TrieNode();\\n\\n    // function for inserting word into Trie\\n\\n    void insert(string& str)\\n    {\\n        int n = str.size();\\n\\n        TrieNode* curr = root;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            int idx = str[i] - \\'a\\';\\n\\n            // if no subtree is present then insert the new node\\n\\n            if(curr -> child[idx] == NULL)\\n            {\\n                curr -> child[idx] = new TrieNode();\\n            }\\n\\n            curr = curr -> child[idx];\\n        }\\n\\n        // update is_end and word\\n\\n        curr -> is_end = true;\\n\\n        curr -> word = str;\\n    }\\n\\n    // dfs function\\n\\n    vector<string> res;\\n\\n    // direction co-ordinates of all four directions\\n\\n    vector<int> dx = {-1, 0, 1, 0};\\n\\n    vector<int> dy = {0, 1, 0, -1};\\n\\n    void dfs(vector<vector<char>>& grid, int i, int j, int n, int m, TrieNode* curr)\\n    {\\n        // base case\\n         \\n        if(i < 0 || i >= n || j < 0 || j >= m || grid[i][j] == \\'#\\')\\n        {\\n            return;\\n        }\\n\\n        int idx = grid[i][j] - \\'a\\';\\n\\n        // if there is no word starting with curr character then return\\n\\n        if(curr -> child[idx] == NULL)\\n        {\\n            return;\\n        }\\n\\n        // move curr\\n\\n        curr = curr -> child[idx];\\n\\n        // if we found a word\\n\\n        if(curr -> is_end)\\n        {\\n            res.push_back(curr -> word);\\n\\n            // mark is_end with false to avoid duplicate result\\n\\n            curr -> is_end = false;\\n        }\\n\\n        // store the val of curr cell\\n\\n        char val = grid[i][j];\\n\\n        // mark the curr cell visited\\n\\n        grid[i][j] = \\'#\\';\\n\\n        // explore all the four directions\\n\\n        for(int k = 0; k < 4; k++)\\n        {\\n            int new_i = i + dx[k];\\n\\n            int new_j = j + dy[k];\\n\\n            // call dfs\\n\\n            dfs(grid, new_i, new_j, n, m, curr);\\n        }\\n\\n        // backtrack\\n\\n        grid[i][j] = val;\\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& grid, vector<string>& words) {\\n        \\n        int n = grid.size();\\n        \\n        int m = grid[0].size();\\n\\n        // insert all the words into trie\\n\\n        for(auto word : words)\\n        {\\n            insert(word);\\n        }\\n\\n        // start dfs from all the cell and find possible result\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                dfs(grid, i, j, n, m, root);\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // declare a structure for TrieNode\\n\\n    struct TrieNode\\n    {\\n        bool is_end;\\n\\n        string word;\\n\\n        TrieNode* child[26];\\n\\n        TrieNode()\\n        {\\n            is_end = false;\\n\\n            word = \"\";\\n\\n            for(int i = 0; i < 26; i++)\\n            {\\n                child[i] = NULL;\\n            }\\n        }\\n    };\\n\\n    // declare root of the Trie\\n\\n    TrieNode* root = new TrieNode();\\n\\n    // function for inserting word into Trie\\n\\n    void insert(string& str)\\n    {\\n        int n = str.size();\\n\\n        TrieNode* curr = root;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            int idx = str[i] - \\'a\\';\\n\\n            // if no subtree is present then insert the new node\\n\\n            if(curr -> child[idx] == NULL)\\n            {\\n                curr -> child[idx] = new TrieNode();\\n            }\\n\\n            curr = curr -> child[idx];\\n        }\\n\\n        // update is_end and word\\n\\n        curr -> is_end = true;\\n\\n        curr -> word = str;\\n    }\\n\\n    // dfs function\\n\\n    vector<string> res;\\n\\n    // direction co-ordinates of all four directions\\n\\n    vector<int> dx = {-1, 0, 1, 0};\\n\\n    vector<int> dy = {0, 1, 0, -1};\\n\\n    void dfs(vector<vector<char>>& grid, int i, int j, int n, int m, TrieNode* curr)\\n    {\\n        // base case\\n         \\n        if(i < 0 || i >= n || j < 0 || j >= m || grid[i][j] == \\'#\\')\\n        {\\n            return;\\n        }\\n\\n        int idx = grid[i][j] - \\'a\\';\\n\\n        // if there is no word starting with curr character then return\\n\\n        if(curr -> child[idx] == NULL)\\n        {\\n            return;\\n        }\\n\\n        // move curr\\n\\n        curr = curr -> child[idx];\\n\\n        // if we found a word\\n\\n        if(curr -> is_end)\\n        {\\n            res.push_back(curr -> word);\\n\\n            // mark is_end with false to avoid duplicate result\\n\\n            curr -> is_end = false;\\n        }\\n\\n        // store the val of curr cell\\n\\n        char val = grid[i][j];\\n\\n        // mark the curr cell visited\\n\\n        grid[i][j] = \\'#\\';\\n\\n        // explore all the four directions\\n\\n        for(int k = 0; k < 4; k++)\\n        {\\n            int new_i = i + dx[k];\\n\\n            int new_j = j + dy[k];\\n\\n            // call dfs\\n\\n            dfs(grid, new_i, new_j, n, m, curr);\\n        }\\n\\n        // backtrack\\n\\n        grid[i][j] = val;\\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& grid, vector<string>& words) {\\n        \\n        int n = grid.size();\\n        \\n        int m = grid[0].size();\\n\\n        // insert all the words into trie\\n\\n        for(auto word : words)\\n        {\\n            insert(word);\\n        }\\n\\n        // start dfs from all the cell and find possible result\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                dfs(grid, i, j, n, m, root);\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520723,
                "title": "java-tc-o-rc-3-l-sc-o-n-l-optimal-trie-dfs-solution",
                "content": "```java\\n/**\\n * Create Trie of all words. And then search in Trie.\\n *\\n * Time Complexity: O(R*C * 4*(3^(L-1))) + O(N)\\n *      O(4*(3^(L-1))) ==> For the dfsHelper function, first time we have at most 4 directions\\n *                         to explore, but the choices are reduced to 3 (since no need to go back to the\\n *                         cell from where we came). Therefore, in the worst case, the total number of\\n *                         calls to dfsHelper will be 3^L\\n *      O(N) ==> For building trie\\n *\\n * Space Complexity: O(N + L)\\n *      O(N) ==> For Trie. We are storing reference of word. So no space used by word.\\n *      O(L) ==> For Recursion Depth.\\n *\\n * R = Number of rows. C = Number of columns. N = Total number of chars in words\\n * array. L = Maximum length of a word in the words array.\\n */\\nclass Solution {\\n    private static final int[][] DIRS = new int[][] { { 0, 1 }, { 1, 0 }, { -1, 0 }, { 0, -1 } };\\n\\n    class TrieNode {\\n        HashMap<Character, TrieNode> map;\\n        String word;\\n\\t\\t\\n        public TrieNode() {\\n            map = new HashMap<>();\\n        }\\n    }\\n\\n    public List<String> findWords(char[][] board, String[] words) {\\n        List<String> result = new ArrayList<>();\\n        if (board == null || board.length == 0 || board[0].length == 0 || words == null || words.length == 0) {\\n            return result;\\n        }\\n\\n        int rows = board.length;\\n        int cols = board[0].length;\\n\\n        TrieNode root = buildTrie(words, rows * cols);\\n        root.word.hashCode();\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (root.map.containsKey(board[i][j])) {\\n                    dfsHelper(board, root, i, j, result);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    private TrieNode buildTrie(String[] words, int maxLen) {\\n        TrieNode root = new TrieNode();\\n        for (String w : words) {\\n            if (w == null || w.length() == 0 || w.length() > maxLen) {\\n                continue;\\n            }\\n            TrieNode cur = root;\\n            for (int i = 0; i < w.length(); i++) {\\n                char c = w.charAt(i);\\n                if (!cur.map.containsKey(c)) {\\n                    cur.map.put(c, new TrieNode());\\n                }\\n                cur = cur.map.get(c);\\n            }\\n            cur.word = w;\\n        }\\n        return root;\\n    }\\n\\n    private void dfsHelper(char[][] board, TrieNode cur, int x, int y, List<String> result) {\\n        if (cur == null) {\\n            return;\\n        }\\n\\n        if (cur.word != null) {\\n            // A Valid word found. Add to the result.\\n            result.add(cur.word);\\n            // Set this word to null, so that its not added again.\\n            cur.word = null;\\n        }\\n\\n        if (x < 0 || x >= board.length || y < 0 || y >= board[0].length || !cur.map.containsKey(board[x][y])) {\\n            return;\\n        }\\n\\n        char curChar = board[x][y];\\n        board[x][y] = \\'#\\';\\n        for (int[] d : DIRS) {\\n            dfsHelper(board, cur.map.get(curChar), x + d[0], y + d[1], result);\\n        }\\n        board[x][y] = curChar;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other parts of Word Search question on LeetCode:\\n- [79. Word Search](https://leetcode.com/problems/word-search/discuss/1520705/Java-or-TC%3A-O(RC*(3L))-or-SC%3A-O(L)-or-Optimal-DFS-solution-without-visited-matrix)",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Backtracking",
                    "Depth-First Search",
                    "Trie",
                    "Recursion",
                    "Matrix"
                ],
                "code": "```java\\n/**\\n * Create Trie of all words. And then search in Trie.\\n *\\n * Time Complexity: O(R*C * 4*(3^(L-1))) + O(N)\\n *      O(4*(3^(L-1))) ==> For the dfsHelper function, first time we have at most 4 directions\\n *                         to explore, but the choices are reduced to 3 (since no need to go back to the\\n *                         cell from where we came). Therefore, in the worst case, the total number of\\n *                         calls to dfsHelper will be 3^L\\n *      O(N) ==> For building trie\\n *\\n * Space Complexity: O(N + L)\\n *      O(N) ==> For Trie. We are storing reference of word. So no space used by word.\\n *      O(L) ==> For Recursion Depth.\\n *\\n * R = Number of rows. C = Number of columns. N = Total number of chars in words\\n * array. L = Maximum length of a word in the words array.\\n */\\nclass Solution {\\n    private static final int[][] DIRS = new int[][] { { 0, 1 }, { 1, 0 }, { -1, 0 }, { 0, -1 } };\\n\\n    class TrieNode {\\n        HashMap<Character, TrieNode> map;\\n        String word;\\n\\t\\t\\n        public TrieNode() {\\n            map = new HashMap<>();\\n        }\\n    }\\n\\n    public List<String> findWords(char[][] board, String[] words) {\\n        List<String> result = new ArrayList<>();\\n        if (board == null || board.length == 0 || board[0].length == 0 || words == null || words.length == 0) {\\n            return result;\\n        }\\n\\n        int rows = board.length;\\n        int cols = board[0].length;\\n\\n        TrieNode root = buildTrie(words, rows * cols);\\n        root.word.hashCode();\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (root.map.containsKey(board[i][j])) {\\n                    dfsHelper(board, root, i, j, result);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    private TrieNode buildTrie(String[] words, int maxLen) {\\n        TrieNode root = new TrieNode();\\n        for (String w : words) {\\n            if (w == null || w.length() == 0 || w.length() > maxLen) {\\n                continue;\\n            }\\n            TrieNode cur = root;\\n            for (int i = 0; i < w.length(); i++) {\\n                char c = w.charAt(i);\\n                if (!cur.map.containsKey(c)) {\\n                    cur.map.put(c, new TrieNode());\\n                }\\n                cur = cur.map.get(c);\\n            }\\n            cur.word = w;\\n        }\\n        return root;\\n    }\\n\\n    private void dfsHelper(char[][] board, TrieNode cur, int x, int y, List<String> result) {\\n        if (cur == null) {\\n            return;\\n        }\\n\\n        if (cur.word != null) {\\n            // A Valid word found. Add to the result.\\n            result.add(cur.word);\\n            // Set this word to null, so that its not added again.\\n            cur.word = null;\\n        }\\n\\n        if (x < 0 || x >= board.length || y < 0 || y >= board[0].length || !cur.map.containsKey(board[x][y])) {\\n            return;\\n        }\\n\\n        char curChar = board[x][y];\\n        board[x][y] = \\'#\\';\\n        for (int[] d : DIRS) {\\n            dfsHelper(board, cur.map.get(curChar), x + d[0], y + d[1], result);\\n        }\\n        board[x][y] = curChar;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 637238,
                "title": "c-no-trie-two-different-solutions",
                "content": "## Solution 1\\n**I passed the current word searched by *value* into DFS function, Got 420 ms, 55.4 MB**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        unordered_map<char, unordered_set<string>> wordMap; // {last letter, set of whole words}\\n        unordered_set<string> found; // words already found\\n        // Inserts each word into map with last letter\\n        for (string word : words) {\\n            if (wordMap.count(word.back())) {\\n                wordMap[word.back()].insert(word);\\n            } \\n            else {\\n                wordMap.insert({ word.back(), {word} });\\n            }\\n        }\\n        vector<string> result;\\n        int M = board.size(); // Rows\\n        int N = board[0].size(); // Columns\\n        for (int i = 0; i < M; i++) {\\n            for (int j = 0; j < N; j++) {\\n                char currentLetter = board[i][j];\\n                if (wordMap.count(currentLetter) == 1) {\\n                    for (string currentPossibleWord : wordMap[currentLetter]) {\\n                        if (!found.count(currentPossibleWord) && dfs(board, currentPossibleWord, i, j) && currentPossibleWord != \"\") {\\n                            result.push_back(currentPossibleWord);\\n                            found.insert(currentPossibleWord);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    bool dfs(vector<vector<char>> &board, string word, int i, int j) {\\n        // If we\\'ve found the whole word in the board\\n        if (word == \"\") {\\n            return true;\\n        }\\n        if (!inside(board, word, i, j)) {\\n            return false;    \\n        }\\n        // Save original letter for next searches\\n        char previousLetter = board[i][j];\\n        // Mark letter as visited on board\\n        board[i][j] = \\'*\\';\\n        // Remove the last letter since we already counted it\\n        word.pop_back();\\n        // Keep searching\\n        // Backtracking (Revert back previous letter)\\n        bool result = dfs(board, word, i + 1, j)\\n        || dfs(board, word, i - 1, j) \\n        || dfs(board, word, i, j + 1) \\n        || dfs(board, word, i, j - 1);\\n        board[i][j] = previousLetter;\\n        return result;\\n    }\\n    \\n    // Checks borders if we are inside of the grid and check letter if valid\\n    bool inside(vector<vector<char>> &board, string &word, int &i, int &j) {\\n        if (i < 0 || i >= board.size() || j < 0 || j >= board[i].size() || word.back() != board[i][j]) {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n## Solution 2 (Optimzed Both Time & Space)\\n**Here, word is passed by *reference* into DFS function, then Got 152 ms, 17 MB**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        unordered_map<char, unordered_set<string>> wordMap; // {first letter, whole word}\\n        unordered_set<string> found;\\n        // Inserts each word into map with last letter\\n        for (string word : words) {\\n            if (wordMap.count(word.back())) {\\n                wordMap[word.back()].insert(word);\\n            } \\n            else {\\n                wordMap.insert({ word.back(), {word} });\\n            }\\n        }\\n        vector<string> result;\\n        int M = board.size(); // Rows\\n        int N = board[0].size(); // Columns\\n        for (int i = 0; i < M; i++) {\\n            for (int j = 0; j < N; j++) {\\n                char currentLetter = board[i][j];\\n                if (wordMap.count(currentLetter) == 1) {\\n                    for (string currentPossibleWord : wordMap[currentLetter]) {\\n                        int letterIndex = currentPossibleWord.size() - 1;\\n                        if (!found.count(currentPossibleWord) && dfs(board, currentPossibleWord, letterIndex,i, j) && currentPossibleWord != \"\") {\\n                            result.push_back(currentPossibleWord);\\n                            found.insert(currentPossibleWord);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    bool dfs(vector<vector<char>> &board, string &word, int letterIndex, int i, int j) {\\n        // If we\\'ve found the whole word in the board\\n        if (letterIndex == -1) {\\n            return true;\\n        }\\n        if (!inside(board, word, letterIndex, i, j)) {\\n            return false;    \\n        }\\n        // Save original letter for next searches\\n        char previousLetter = board[i][j];\\n        // Mark letter as visited on board\\n        board[i][j] = \\'*\\';\\n        // Decrease the last letter index\\n        letterIndex--;\\n        // Keep searching\\n        // Backtracking (Revert back previous letter)\\n        bool result = dfs(board, word, letterIndex, i + 1, j)\\n        || dfs(board, word, letterIndex, i - 1, j) \\n        || dfs(board, word, letterIndex, i, j + 1) \\n        || dfs(board, word, letterIndex, i, j - 1);\\n        board[i][j] = previousLetter;\\n        return result;\\n    }\\n    \\n    // Checks borders if we are inside of the grid and check letter if valid\\n    bool inside(vector<vector<char>> &board, string &word, int letterIndex, int &i, int &j) {\\n        if (i < 0 || i >= board.size() || j < 0 || j >= board[i].size() || word[letterIndex] != board[i][j]) {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        unordered_map<char, unordered_set<string>> wordMap; // {last letter, set of whole words}\\n        unordered_set<string> found; // words already found\\n        // Inserts each word into map with last letter\\n        for (string word : words) {\\n            if (wordMap.count(word.back())) {\\n                wordMap[word.back()].insert(word);\\n            } \\n            else {\\n                wordMap.insert({ word.back(), {word} });\\n            }\\n        }\\n        vector<string> result;\\n        int M = board.size(); // Rows\\n        int N = board[0].size(); // Columns\\n        for (int i = 0; i < M; i++) {\\n            for (int j = 0; j < N; j++) {\\n                char currentLetter = board[i][j];\\n                if (wordMap.count(currentLetter) == 1) {\\n                    for (string currentPossibleWord : wordMap[currentLetter]) {\\n                        if (!found.count(currentPossibleWord) && dfs(board, currentPossibleWord, i, j) && currentPossibleWord != \"\") {\\n                            result.push_back(currentPossibleWord);\\n                            found.insert(currentPossibleWord);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    bool dfs(vector<vector<char>> &board, string word, int i, int j) {\\n        // If we\\'ve found the whole word in the board\\n        if (word == \"\") {\\n            return true;\\n        }\\n        if (!inside(board, word, i, j)) {\\n            return false;    \\n        }\\n        // Save original letter for next searches\\n        char previousLetter = board[i][j];\\n        // Mark letter as visited on board\\n        board[i][j] = \\'*\\';\\n        // Remove the last letter since we already counted it\\n        word.pop_back();\\n        // Keep searching\\n        // Backtracking (Revert back previous letter)\\n        bool result = dfs(board, word, i + 1, j)\\n        || dfs(board, word, i - 1, j) \\n        || dfs(board, word, i, j + 1) \\n        || dfs(board, word, i, j - 1);\\n        board[i][j] = previousLetter;\\n        return result;\\n    }\\n    \\n    // Checks borders if we are inside of the grid and check letter if valid\\n    bool inside(vector<vector<char>> &board, string &word, int &i, int &j) {\\n        if (i < 0 || i >= board.size() || j < 0 || j >= board[i].size() || word.back() != board[i][j]) {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        unordered_map<char, unordered_set<string>> wordMap; // {first letter, whole word}\\n        unordered_set<string> found;\\n        // Inserts each word into map with last letter\\n        for (string word : words) {\\n            if (wordMap.count(word.back())) {\\n                wordMap[word.back()].insert(word);\\n            } \\n            else {\\n                wordMap.insert({ word.back(), {word} });\\n            }\\n        }\\n        vector<string> result;\\n        int M = board.size(); // Rows\\n        int N = board[0].size(); // Columns\\n        for (int i = 0; i < M; i++) {\\n            for (int j = 0; j < N; j++) {\\n                char currentLetter = board[i][j];\\n                if (wordMap.count(currentLetter) == 1) {\\n                    for (string currentPossibleWord : wordMap[currentLetter]) {\\n                        int letterIndex = currentPossibleWord.size() - 1;\\n                        if (!found.count(currentPossibleWord) && dfs(board, currentPossibleWord, letterIndex,i, j) && currentPossibleWord != \"\") {\\n                            result.push_back(currentPossibleWord);\\n                            found.insert(currentPossibleWord);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    bool dfs(vector<vector<char>> &board, string &word, int letterIndex, int i, int j) {\\n        // If we\\'ve found the whole word in the board\\n        if (letterIndex == -1) {\\n            return true;\\n        }\\n        if (!inside(board, word, letterIndex, i, j)) {\\n            return false;    \\n        }\\n        // Save original letter for next searches\\n        char previousLetter = board[i][j];\\n        // Mark letter as visited on board\\n        board[i][j] = \\'*\\';\\n        // Decrease the last letter index\\n        letterIndex--;\\n        // Keep searching\\n        // Backtracking (Revert back previous letter)\\n        bool result = dfs(board, word, letterIndex, i + 1, j)\\n        || dfs(board, word, letterIndex, i - 1, j) \\n        || dfs(board, word, letterIndex, i, j + 1) \\n        || dfs(board, word, letterIndex, i, j - 1);\\n        board[i][j] = previousLetter;\\n        return result;\\n    }\\n    \\n    // Checks borders if we are inside of the grid and check letter if valid\\n    bool inside(vector<vector<char>> &board, string &word, int letterIndex, int &i, int &j) {\\n        if (i < 0 || i >= board.size() || j < 0 || j >= board[i].size() || word[letterIndex] != board[i][j]) {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59852,
                "title": "clean-python-code-with-trie",
                "content": "    class TrieNode(object):\\n        def __init__(self):\\n            self.word = None\\n            self.children = {}\\n    \\n    \\n    class Trie(object):\\n        def __init__(self):\\n            self.root = TrieNode()\\n    \\n        def insert(self, word):\\n            root = self.root\\n            for char in word:\\n                root = root.children.setdefault(char, TrieNode())\\n            root.word = word\\n    \\n    \\n    class Solution(object):\\n        def search(self, i, j, root, board, m, n, r):\\n            char = board[i][j]\\n            if not (char and char in root.children):\\n                return\\n    \\n            board[i][j], root = None, root.children[char]\\n    \\n            if root.word:\\n                r.append(root.word)\\n                root.word = None\\n    \\n            for x, y in ((0, -1), (-1, 0), (0, 1), (1, 0)):\\n                ii, jj = i + x, j + y\\n                if 0 <= ii < m and 0 <= jj < n:\\n                    self.search(ii, jj, root, board, m, n, r)\\n    \\n            board[i][j] = char\\n    \\n        def findWords(self, board, words):\\n            if not board:\\n                return []\\n    \\n            tree = Trie()\\n            [tree.insert(word) for word in words]\\n    \\n            m, n, r = len(board), len(board[0]), []\\n    \\n            for i, row in enumerate(board):\\n                for j, char in enumerate(row):\\n                    self.search(i, j, tree.root, board, m, n, r)\\n            return r\\n\\nThanks @julien6 for pointing out a corner-case error.",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class TrieNode(object):\\n        def __init__(self):\\n            self.word = None\\n            self.children = {}\\n    \\n    \\n    class Trie(object):\\n        def __init__(self):\\n            self.root = TrieNode()\\n    \\n        def insert(self, word):\\n            root = self.root\\n            for char in word:\\n                root = root.children.setdefault(char, TrieNode())\\n            root.word = word\\n    \\n    \\n    class Solution(object):\\n        def search(self, i, j, root, board, m, n, r):\\n            char = board[i][j]\\n            if not (char and char in root.children):\\n                return\\n    \\n            board[i][j], root = None, root.children[char]\\n    \\n            if root.word:\\n                r.append(root.word)\\n                root.word = None\\n    \\n            for x, y in ((0, -1), (-1, 0), (0, 1), (1, 0)):\\n                ii, jj = i + x, j + y\\n                if 0 <= ii < m and 0 <= jj < n:\\n                    self.search(ii, jj, root, board, m, n, r)\\n    \\n            board[i][j] = char\\n    \\n        def findWords(self, board, words):\\n            if not board:\\n                return []\\n    \\n            tree = Trie()\\n            [tree.insert(word) for word in words]\\n    \\n            m, n, r = len(board), len(board[0]), []\\n    \\n            for i, row in enumerate(board):\\n                for j, char in enumerate(row):\\n                    self.search(i, j, tree.root, board, m, n, r)\\n            return r\\n\\nThanks @julien6 for pointing out a corner-case error.",
                "codeTag": "Java"
            },
            {
                "id": 2779874,
                "title": "without-trie-all-test-pass-easy-solution",
                "content": "This Solution is very helpful for peoples who don\\'t know TRIE. \\n\\n\\n\\n```\\nclass Solution {\\n    \\n     HashMap<String,Integer> map=new HashMap<>();\\n     Set<String> ans=new HashSet<>();\\n    int max=-1;\\n    \\n    public List<String> findWords(char[][] board, String[] words) {\\n       \\n        for(int i=0;i<words.length;i++){\\n            map.put(words[i],1);\\n            max=Math.max(max,words[i].length());\\n        }\\n        \\n        \\n        for(int i=0;i<board.length;i++){\\n            for(int j=0;j<board[i].length;j++){\\n                boolean[][] visited=new boolean[board.length][board[i].length];\\n                check(i,j,\"\",board,visited);\\n            }\\n        }\\n        return new ArrayList<>(ans);\\n    }\\n        \\n        \\n        \\n        public void check(int i,int j,String str,char[][] board,boolean[][] visited){\\n            if(i<0 || j<0 || i>=board.length || j>=board[i].length || visited[i][j]==true || str.length()>=max) return;\\n             \\n            visited[i][j]=true;   \\n            str+=board[i][j];\\n            //System.out.println(str);\\n            \\n            if(map.containsKey(str)){\\n                ans.add(str);\\n                // System.out.println(str);\\n                \\n            }\\n            \\n            check(i-1,j,str,board,visited);\\n            check(i+1,j,str,board,visited);\\n            check(i,j-1,str,board,visited);\\n            check(i,j+1,str,board,visited);\\n            \\n            str=str.substring(0, str.length() - 1);\\n            \\n            visited[i][j]=false;\\n        }\\n    }\\n```\\n\\nPlease upvote , If you liked it .",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n     HashMap<String,Integer> map=new HashMap<>();\\n     Set<String> ans=new HashSet<>();\\n    int max=-1;\\n    \\n    public List<String> findWords(char[][] board, String[] words) {\\n       \\n        for(int i=0;i<words.length;i++){\\n            map.put(words[i],1);\\n            max=Math.max(max,words[i].length());\\n        }\\n        \\n        \\n        for(int i=0;i<board.length;i++){\\n            for(int j=0;j<board[i].length;j++){\\n                boolean[][] visited=new boolean[board.length][board[i].length];\\n                check(i,j,\"\",board,visited);\\n            }\\n        }\\n        return new ArrayList<>(ans);\\n    }\\n        \\n        \\n        \\n        public void check(int i,int j,String str,char[][] board,boolean[][] visited){\\n            if(i<0 || j<0 || i>=board.length || j>=board[i].length || visited[i][j]==true || str.length()>=max) return;\\n             \\n            visited[i][j]=true;   \\n            str+=board[i][j];\\n            //System.out.println(str);\\n            \\n            if(map.containsKey(str)){\\n                ans.add(str);\\n                // System.out.println(str);\\n                \\n            }\\n            \\n            check(i-1,j,str,board,visited);\\n            check(i+1,j,str,board,visited);\\n            check(i,j-1,str,board,visited);\\n            check(i,j+1,str,board,visited);\\n            \\n            str=str.substring(0, str.length() - 1);\\n            \\n            visited[i][j]=false;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 264038,
                "title": "why-trie-brute-force-trie",
                "content": "Hi, \\nI was also thinking about it. Then, I tried to run it with simple optimized Dfs.\\n\\nLook at the code which caused TLE.  You can see that if we did not find the word, we continue our search hoping that next word may match!\\nWhat if there is a way to tell you that stop it here, you do not have to go next! \\nThat\\'s, where Trie is coming to rescue. If this current prefix not in trie, we are sure that there is no possibility of exploration.\\n\\nI hope this will help!\\n\\n    class Solution(object):\\n        def __init__(self):\\n            self.set = None\\n            self.ans = set()   #set to remove duplicates\\n            self.visited = None\\n    \\n        def dfs(self, i, j, string, m , n, board):\\n            #boundary conditions\\n            if i < 0 or j < 0 or i >= m or j >= n or self.visited[i][j] == 1:\\n                return \\n        \\n            #marking visited to remove cycle\\n            self.visited[i][j] = 1\\n        \\n            #checks if the words in set/list, then puts it But we continue exploring. Trie reduces this exploration\\n            if string + board[i][j] in self.set:\\n                self.ans.add(string+board[i][j])\\n        \\n        \\n            #do for dfs\\n            self.dfs(i-1, j, string+board[i][j], m , n, board)\\n            self.dfs(i+1, j, string+board[i][j], m , n, board)\\n            self.dfs(i, j+1, string+board[i][j], m , n, board)\\n            self.dfs(i, j-1, string+board[i][j], m , n, board)\\n        \\n            #unmarking visited\\n            self.visited[i][j] = 0\\n        \\n        \\n        def findWords(self, board, words):\\n            #created set for fast lookup\\n        \\n            self.set = set(words)\\n            m = len(board); n = len(board[0])\\n            self.visited = [[0]*n for i in range(m)]\\n        \\n        \\n            #doing normal dfs\\n            for i in range(m):\\n                for j in range(n):\\n                    self.dfs(i, j, \"\", m, n, board)\\n        \\n    \\n            #returning set as a list\\n            return list(self.ans)",
                "solutionTags": [],
                "code": "Hi, \\nI was also thinking about it. Then, I tried to run it with simple optimized Dfs.\\n\\nLook at the code which caused TLE.  You can see that if we did not find the word, we continue our search hoping that next word may match!\\nWhat if there is a way to tell you that stop it here, you do not have to go next! \\nThat\\'s, where Trie is coming to rescue. If this current prefix not in trie, we are sure that there is no possibility of exploration.\\n\\nI hope this will help!\\n\\n    class Solution(object):\\n        def __init__(self):\\n            self.set = None\\n            self.ans = set()   #set to remove duplicates\\n            self.visited = None\\n    \\n        def dfs(self, i, j, string, m , n, board):\\n            #boundary conditions\\n            if i < 0 or j < 0 or i >= m or j >= n or self.visited[i][j] == 1:\\n                return \\n        \\n            #marking visited to remove cycle\\n            self.visited[i][j] = 1\\n        \\n            #checks if the words in set/list, then puts it But we continue exploring. Trie reduces this exploration\\n            if string + board[i][j] in self.set:\\n                self.ans.add(string+board[i][j])\\n        \\n        \\n            #do for dfs\\n            self.dfs(i-1, j, string+board[i][j], m , n, board)\\n            self.dfs(i+1, j, string+board[i][j], m , n, board)\\n            self.dfs(i, j+1, string+board[i][j], m , n, board)\\n            self.dfs(i, j-1, string+board[i][j], m , n, board)\\n        \\n            #unmarking visited\\n            self.visited[i][j] = 0\\n        \\n        \\n        def findWords(self, board, words):\\n            #created set for fast lookup\\n        \\n            self.set = set(words)\\n            m = len(board); n = len(board[0])\\n            self.visited = [[0]*n for i in range(m)]\\n        \\n        \\n            #doing normal dfs\\n            for i in range(m):\\n                for j in range(n):\\n                    self.dfs(i, j, \"\", m, n, board)\\n        \\n    \\n            #returning set as a list\\n            return list(self.ans)",
                "codeTag": "Java"
            },
            {
                "id": 2780237,
                "title": "dfs-trie-c-soln",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nConstruct a trie to determine if we are going on the right path to find a valid word.\\nApply dfs on every cell and traverse the trie node corresponding to it concurrently. For every dfs call , if we are at a particular cell after traversing some characters, then our trie node should also be at the same character. If the node is terminal , we add the word to our list. If such a node does not exist or is NULL then we are on a wrong path and we need to backtrack. Also make a visit array so that we do not go on the same cell again in same path.\\n<!--\\n# Complexity\\n- Time complexity:\\n Add your time complexity here, e.g. $$O(n)$$ \\n\\n- Space complexity:\\n Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Node{  //*** trie Node\\n    public:\\n        string word;\\n        bool isTerminal;  \\n        vector<Node*> next;\\n        Node():next(26,NULL){\\n            isTerminal = false; \\n            \\n        }\\n};\\n\\nclass Solution {\\n    \\n    void put(string &s,int si, Node* cur){ //** adds a word to the trie \\n            int a = s[si]-\\'a\\';    //*********** also stores the word at the terminal node\\n            if(!cur->next[a]){\\n            Node* newnode = new Node();\\n            cur->next[a] = newnode;\\n            }\\n\\n            if(si != s.size()-1){\\n            put(s,si+1,cur->next[a]); }\\n            else\\n             { cur->next[a]->isTerminal = true;\\n               cur->next[a]->word = s;\\n              }\\n      }\\n\\nvoid dfs(vector<vector<char>>& board,int i,int j,Node* t,set<string>& res,vector<vector<bool>>& visit){ \\n    if(i<0 || j<0 || i>=board.size() || j>= board[0].size())return; //** dfs call to search for word\\n    char x = board[i][j]-\\'a\\';\\n    t = t->next[x];\\n    if(visit[i][j] || !t)return ;\\n   \\n    if(t->isTerminal)res.insert((t->word));\\n    visit[i][j] = true;\\n    dfs(board,i+1,j,t,res,visit);\\n    dfs(board,i-1,j,t,res,visit);\\n    dfs(board,i,j+1,t,res,visit);\\n    dfs(board,i,j-1,t,res,visit);\\n    visit[i][j]= false;\\n}\\n\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        set<string> res;\\n        Node* t = new Node();\\n        for(string &s:words){\\n            put(s,0,t);\\n        }\\n       vector<vector<bool>> visit(board.size(),vector<bool>(board[0].size(),false));\\n        for(int i = 0 ;i<board.size();i++){\\n            for(int j=0;j<board[0].size();j++){\\n               dfs(board,i,j,t,res,visit);\\n            }\\n        }\\n        vector<string> ans(res.begin(),res.end());\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Node{  //*** trie Node\\n    public:\\n        string word;\\n        bool isTerminal;  \\n        vector<Node*> next;\\n        Node():next(26,NULL){\\n            isTerminal = false; \\n            \\n        }\\n};\\n\\nclass Solution {\\n    \\n    void put(string &s,int si, Node* cur){ //** adds a word to the trie \\n            int a = s[si]-\\'a\\';    //*********** also stores the word at the terminal node\\n            if(!cur->next[a]){\\n            Node* newnode = new Node();\\n            cur->next[a] = newnode;\\n            }\\n\\n            if(si != s.size()-1){\\n            put(s,si+1,cur->next[a]); }\\n            else\\n             { cur->next[a]->isTerminal = true;\\n               cur->next[a]->word = s;\\n              }\\n      }\\n\\nvoid dfs(vector<vector<char>>& board,int i,int j,Node* t,set<string>& res,vector<vector<bool>>& visit){ \\n    if(i<0 || j<0 || i>=board.size() || j>= board[0].size())return; //** dfs call to search for word\\n    char x = board[i][j]-\\'a\\';\\n    t = t->next[x];\\n    if(visit[i][j] || !t)return ;\\n   \\n    if(t->isTerminal)res.insert((t->word));\\n    visit[i][j] = true;\\n    dfs(board,i+1,j,t,res,visit);\\n    dfs(board,i-1,j,t,res,visit);\\n    dfs(board,i,j+1,t,res,visit);\\n    dfs(board,i,j-1,t,res,visit);\\n    visit[i][j]= false;\\n}\\n\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        set<string> res;\\n        Node* t = new Node();\\n        for(string &s:words){\\n            put(s,0,t);\\n        }\\n       vector<vector<bool>> visit(board.size(),vector<bool>(board[0].size(),false));\\n        for(int i = 0 ;i<board.size();i++){\\n            for(int j=0;j<board[0].size();j++){\\n               dfs(board,i,j,t,res,visit);\\n            }\\n        }\\n        vector<string> ans(res.begin(),res.end());\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2413504,
                "title": "python-trie-dfs-backtracking-with-pruning-commented-and-explained",
                "content": "**tl;dr**\\n\\n- Create a trie where each node has a pointer to its parent node\\n- Perform DFS traversal on the board with backtracking\\n- When a word is found, attempt to prune trie branches\\n\\n**Solution**\\n```\\nclass TrieNode:\\n    \\n    def __init__(self, val: str = None, parent: Optional[\\'TrieNode\\'] = None):\\n        self.children = {}\\n        self.val = val\\n        self.parent = parent\\n        self.word = None\\n        \\n\\nclass Trie:\\n    \\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    \\n    def addWord(self, word: str) -> None:\\n        node = self.root\\n        for c in word:\\n            if c not in node.children:\\n                node.children[c] = TrieNode(val=c, parent=node)\\n            node = node.children[c]\\n        node.word = word\\n        \\n    \\n    def prune(self, node: TrieNode) -> None:\\n        \"\"\"\\n        When a word is found, we will perform the following actions:\\n        \\n        - Set the word node\\'s \"word\" to None\\n        - If the current word node\\'s child count is 0, we will\\n          traverse up node\\'s parent and \"evict\" the child. We will\\n          perform this check up to trie until we reach a node who\\'s child\\n          count is not zero OR we are at the root\\n          \\n        The reason why we do this is because we only need to match\\n        a word once. So we will improve subsequent word searches by\\n        pruning branches to words we\\'ve already found. We always check if\\n        a node\\'s child count is 0 because we don\\'t want to prune\\n        a branch if there are still words further down.\\n        \\n        For example:\\n            \\n            \"bat\", \"batter\", \"battery\"\\n        \\n        If we found \"bat\", then \"bat\" is no longer an eligible word.\\n        However, \"batter\" and \"battery\" are both further down the\\n        trie, so we don\\'t prune this branch yet.\\n        \\n        If we found \"battery\" next, then this branch would be pruned\\n        to \"bat\", \"batter\".\\n        \\n        Finally, after finding \"batter\", we will prune the entire\\n        \"bat...\" branch.\\n        \"\"\"\\n        # remove current word from possible match later\\n        node.word = None\\n\\n        # prune trie until we reach a node with remaining children\\n        # or the root\\n        child = node\\n        parent = child.parent\\n        while parent and len(child.children) == 0:\\n            del parent.children[child.val]\\n            child = parent\\n            parent = parent.parent\\n        \\n        \\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        trie = Trie()\\n        for word in words:\\n            trie.addWord(word)\\n        \\n        res = []\\n        m, n = len(board), len(board[0])\\n        seen = set()\\n        \\n        def dfs(i, j, node) -> None:\\n            if (i < 0 or i == m or j < 0 or j == n or\\n                (i, j) in seen or board[i][j] not in node.children):\\n                return\\n            \\n            # we can use current board position to (maybe) build a word\\n            seen.add((i, j))\\n            node = node.children[board[i][j]]\\n            \\n            if node.word:\\n                res.append(node.word)\\n                trie.prune(node)\\n\\n            if len(node.children) == 0:\\n                # no more words can be built from here\\n                # no need to dfs further, so we backtrack\\n                seen.remove((i, j))\\n                return\\n\\n            dfs(i + 1, j, node)\\n            dfs(i - 1, j, node)\\n            dfs(i, j + 1, node)\\n            dfs(i, j - 1, node)\\n            \\n            # back track\\n            seen.remove((i, j))\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                dfs(i, j, trie.root)\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode:\\n    \\n    def __init__(self, val: str = None, parent: Optional[\\'TrieNode\\'] = None):\\n        self.children = {}\\n        self.val = val\\n        self.parent = parent\\n        self.word = None\\n        \\n\\nclass Trie:\\n    \\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    \\n    def addWord(self, word: str) -> None:\\n        node = self.root\\n        for c in word:\\n            if c not in node.children:\\n                node.children[c] = TrieNode(val=c, parent=node)\\n            node = node.children[c]\\n        node.word = word\\n        \\n    \\n    def prune(self, node: TrieNode) -> None:\\n        \"\"\"\\n        When a word is found, we will perform the following actions:\\n        \\n        - Set the word node\\'s \"word\" to None\\n        - If the current word node\\'s child count is 0, we will\\n          traverse up node\\'s parent and \"evict\" the child. We will\\n          perform this check up to trie until we reach a node who\\'s child\\n          count is not zero OR we are at the root\\n          \\n        The reason why we do this is because we only need to match\\n        a word once. So we will improve subsequent word searches by\\n        pruning branches to words we\\'ve already found. We always check if\\n        a node\\'s child count is 0 because we don\\'t want to prune\\n        a branch if there are still words further down.\\n        \\n        For example:\\n            \\n            \"bat\", \"batter\", \"battery\"\\n        \\n        If we found \"bat\", then \"bat\" is no longer an eligible word.\\n        However, \"batter\" and \"battery\" are both further down the\\n        trie, so we don\\'t prune this branch yet.\\n        \\n        If we found \"battery\" next, then this branch would be pruned\\n        to \"bat\", \"batter\".\\n        \\n        Finally, after finding \"batter\", we will prune the entire\\n        \"bat...\" branch.\\n        \"\"\"\\n        # remove current word from possible match later\\n        node.word = None\\n\\n        # prune trie until we reach a node with remaining children\\n        # or the root\\n        child = node\\n        parent = child.parent\\n        while parent and len(child.children) == 0:\\n            del parent.children[child.val]\\n            child = parent\\n            parent = parent.parent\\n        \\n        \\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        trie = Trie()\\n        for word in words:\\n            trie.addWord(word)\\n        \\n        res = []\\n        m, n = len(board), len(board[0])\\n        seen = set()\\n        \\n        def dfs(i, j, node) -> None:\\n            if (i < 0 or i == m or j < 0 or j == n or\\n                (i, j) in seen or board[i][j] not in node.children):\\n                return\\n            \\n            # we can use current board position to (maybe) build a word\\n            seen.add((i, j))\\n            node = node.children[board[i][j]]\\n            \\n            if node.word:\\n                res.append(node.word)\\n                trie.prune(node)\\n\\n            if len(node.children) == 0:\\n                # no more words can be built from here\\n                # no need to dfs further, so we backtrack\\n                seen.remove((i, j))\\n                return\\n\\n            dfs(i + 1, j, node)\\n            dfs(i - 1, j, node)\\n            dfs(i, j + 1, node)\\n            dfs(i, j - 1, node)\\n            \\n            # back track\\n            seen.remove((i, j))\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                dfs(i, j, trie.root)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 875771,
                "title": "java-slow-solution-it-ain-t-much-but-its-honest-work",
                "content": "```\\nclass Solution {\\n    boolean[][] v;\\n    int n,m;\\n    public List<String> findWords(char[][] board, String[] words) {\\n        n = board.length;\\n        m = board[0].length;\\n        Set<String> set = new HashSet<>();\\n        List<String> ans = new ArrayList<>();\\n        for(String word:words){\\n            v = new boolean[n][m];\\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<m;j++){\\n                    if(word.charAt(0)==board[i][j] && dfs(i,j,board,0,word) &&                                      !set.contains(word)){\\n                        ans.add(word);\\n                        set.add(word);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    public boolean dfs(int i,int j,char[][] board,int at,String word){\\n        if(at==word.length()) return true;\\n        if(i>=n || i<0 || j>=m || j<0 || \\n           v[i][j] || board[i][j]!=word.charAt(at)) return false;\\n        \\n        v[i][j] = true;\\n        \\n        if(dfs(i+1,j,board,at+1,word) || dfs(i-1,j,board,at+1,word) ||\\n            dfs(i,j+1,board,at+1,word) || dfs(i,j-1,board,at+1,word)) return true;\\n        \\n        v[i][j] = false;\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    boolean[][] v;\\n    int n,m;\\n    public List<String> findWords(char[][] board, String[] words) {\\n        n = board.length;\\n        m = board[0].length;\\n        Set<String> set = new HashSet<>();\\n        List<String> ans = new ArrayList<>();\\n        for(String word:words){\\n            v = new boolean[n][m];\\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<m;j++){\\n                    if(word.charAt(0)==board[i][j] && dfs(i,j,board,0,word) &&                                      !set.contains(word)){\\n                        ans.add(word);\\n                        set.add(word);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    public boolean dfs(int i,int j,char[][] board,int at,String word){\\n        if(at==word.length()) return true;\\n        if(i>=n || i<0 || j>=m || j<0 || \\n           v[i][j] || board[i][j]!=word.charAt(at)) return false;\\n        \\n        v[i][j] = true;\\n        \\n        if(dfs(i+1,j,board,at+1,word) || dfs(i-1,j,board,at+1,word) ||\\n            dfs(i,j+1,board,at+1,word) || dfs(i,j-1,board,at+1,word)) return true;\\n        \\n        v[i][j] = false;\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 230245,
                "title": "java-concise-code-very-easy-to-understand",
                "content": "This Question is Actually very similar with 79(Word search)\\nIn backtracing step, seperate the dfs logic and judgment logic will make the code very concise\\n```\\npublic List<String> findWords(char[][] board, String[] words) {\\n\\tList<String> res = new ArrayList<>();\\n\\n\\tfor (String word : words) {\\n\\t\\tboolean[][] visited = new boolean[board.length][board[0].length];\\n\\t\\tfor (int i = 0; i < board.length; i++) {\\n\\t\\t\\tfor (int j = 0; j < board[0].length; j++) {\\n\\t\\t\\t\\tif (board[i][j] == word.charAt(0) && exist(board, visited, i, j, word, 0)) {\\n\\t\\t\\t\\t\\tif (!res.contains(word))\\n\\t\\t\\t\\t\\t\\tres.add(word);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n\\nprivate boolean exist(char[][] board, boolean[][] visited, int i, int j, String s, int index) {\\n\\tif (index == s.length())\\n\\t\\treturn true;\\n\\t//false case\\n\\tif (i < 0 || i >= board.length || j < 0 || \\n\\t\\tj >= board[0].length || visited[i][j] || board[i][j] != s.charAt(index)) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\tvisited[i][j] = true;\\n\\tif (exist(board, visited, i + 1, j, s, index + 1) ||\\n\\t\\texist(board, visited, i - 1, j, s, index + 1) ||\\n\\t\\texist(board, visited, i, j + 1, s, index + 1) ||\\n\\t\\texist(board, visited, i, j - 1, s, index + 1)) {\\n\\t\\treturn true;\\n\\t}\\n\\tvisited[i][j] = false;\\n\\n\\treturn false;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<String> findWords(char[][] board, String[] words) {\\n\\tList<String> res = new ArrayList<>();\\n\\n\\tfor (String word : words) {\\n\\t\\tboolean[][] visited = new boolean[board.length][board[0].length];\\n\\t\\tfor (int i = 0; i < board.length; i++) {\\n\\t\\t\\tfor (int j = 0; j < board[0].length; j++) {\\n\\t\\t\\t\\tif (board[i][j] == word.charAt(0) && exist(board, visited, i, j, word, 0)) {\\n\\t\\t\\t\\t\\tif (!res.contains(word))\\n\\t\\t\\t\\t\\t\\tres.add(word);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n\\nprivate boolean exist(char[][] board, boolean[][] visited, int i, int j, String s, int index) {\\n\\tif (index == s.length())\\n\\t\\treturn true;\\n\\t//false case\\n\\tif (i < 0 || i >= board.length || j < 0 || \\n\\t\\tj >= board[0].length || visited[i][j] || board[i][j] != s.charAt(index)) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\tvisited[i][j] = true;\\n\\tif (exist(board, visited, i + 1, j, s, index + 1) ||\\n\\t\\texist(board, visited, i - 1, j, s, index + 1) ||\\n\\t\\texist(board, visited, i, j + 1, s, index + 1) ||\\n\\t\\texist(board, visited, i, j - 1, s, index + 1)) {\\n\\t\\treturn true;\\n\\t}\\n\\tvisited[i][j] = false;\\n\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 59868,
                "title": "c-48ms-56ms-simple-trie-structure-68lines",
                "content": "    class Trie {\\n        public:\\n        Trie *next[26];\\n        bool exist;\\n        \\n        Trie() {\\n            fill_n(next, 26, nullptr);\\n            exist = false;\\n        }\\n        \\n        ~Trie() {\\n            for (int i = 0; i < 26; ++i)\\n                delete next[i];\\n        }\\n        \\n        void insert(const string &t) {\\n            Trie *iter = this;\\n            for (int i = 0; i < t.size(); ++i) {\\n                if (iter->next[t[i] - 'a'] == nullptr)\\n                    iter->next[t[i] - 'a'] = new Trie();\\n                iter = iter->next[t[i] - 'a'];\\n            }\\n            iter->exist = true;\\n        }\\n    };\\n\\n    class Solution {\\n        public:\\n        int m, n;\\n        \\n        vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n            Trie *trie = new Trie();\\n            for (auto &s : words)\\n                trie->insert(s);\\n            m = board.size();\\n            n = board[0].size();\\n            \\n            vector<string> ret;\\n            string sofar;\\n            for (int i = 0; i < m; ++i) {\\n                for (int j = 0; j < n; ++j) {\\n                    bc(board, ret, sofar, trie, i, j);\\n                }\\n            }\\n            return ret;\\n        }\\n        \\n        void bc(vector<vector<char>> &board, vector<string> &ret, string &sofar, Trie *root, int x, int y) {\\n            if (x < 0 || y < 0 || x >= m || y >= n || board[x][y] == '\\\\0' || root == nullptr)\\n                return ;\\n            if (root->next[board[x][y] - 'a'] == nullptr)\\n                return ;\\n            root = root->next[board[x][y] - 'a'];\\n            char t = '\\\\0';\\n            swap(t, board[x][y]);\\n            sofar.push_back(t);\\n            if (root->exist) {\\n                root->exist = false;\\n                ret.push_back(sofar);\\n            }\\n            bc(board, ret, sofar, root, x, y + 1);\\n            bc(board, ret, sofar, root, x + 1, y);\\n            bc(board, ret, sofar, root, x - 1, y);\\n            bc(board, ret, sofar, root, x, y - 1);\\n            swap(t, board[x][y]);\\n            sofar.pop_back();\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n        int m, n;\\n        \\n        vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n            Trie *trie = new Trie();\\n            for (auto &s : words)\\n                trie->insert(s);\\n            m = board.size();\\n            n = board[0].size();\\n            \\n            vector<string> ret;\\n            string sofar;\\n            for (int i = 0; i < m; ++i) {\\n                for (int j = 0; j < n; ++j) {\\n                    bc(board, ret, sofar, trie, i, j);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3224569,
                "title": "212-beats-94-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nBeats\\n94%\\n\\n- Space complexity:\\nBeats\\n81.69%\\n\\n# Code\\n```\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        \\n        # Define a DFS function to traverse the board and search for words\\n        def dfs(x, y, root):\\n            # Get the letter at the current position on the board\\n            letter = board[x][y]\\n            # Traverse the trie to the next node\\n            cur = root[letter]\\n            # Check if the node has a word in it\\n            word = cur.pop(\\'#\\', False)\\n            if word:\\n                # If a word is found, add it to the results list\\n                res.append(word)\\n            # Mark the current position on the board as visited\\n            board[x][y] = \\'*\\'\\n            # Recursively search in all four directions\\n            for dirx, diry in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                curx, cury = x + dirx, y + diry\\n                # Check if the next position is within the board and the next letter is in the trie\\n                if 0 <= curx < m and 0 <= cury < n and board[curx][cury] in cur:\\n                    dfs(curx, cury, cur)\\n            # Restore the original value of the current position on the board\\n            board[x][y] = letter\\n            # If the current node has no children, remove it from the trie\\n            if not cur:\\n                root.pop(letter)\\n                \\n        # Build a trie data structure from the list of words\\n        trie = {}\\n        for word in words:\\n            cur = trie\\n            for letter in word:\\n                cur = cur.setdefault(letter, {})\\n            cur[\\'#\\'] = word\\n            \\n        # Get the dimensions of the board\\n        m, n = len(board), len(board[0])\\n        # Initialize a list to store the results\\n        res = []\\n        \\n        # Traverse the board and search for words\\n        for i in range(m):\\n            for j in range(n):\\n                # Check if the current letter is in the trie\\n                if board[i][j] in trie:\\n                    dfs(i, j, trie)\\n        \\n        # Return the list of results\\n        return res\\n\\n```\\nThe basic idea of the solution is to use a trie data structure to efficiently search for words on the board. We first build the trie from the list of words, where each node in the trie represents a letter in a word and the \\'#\\' symbol indicates the end of a word. Then, we traverse the board and use a depth-first search (DFS) algorithm to search for words starting from each position on the board. We use the trie to efficiently traverse the board and check if each sequence of letters corresponds to a valid word in the trie. When a valid word is found, we add it to the results list. Finally, we return the list of results.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        \\n        # Define a DFS function to traverse the board and search for words\\n        def dfs(x, y, root):\\n            # Get the letter at the current position on the board\\n            letter = board[x][y]\\n            # Traverse the trie to the next node\\n            cur = root[letter]\\n            # Check if the node has a word in it\\n            word = cur.pop(\\'#\\', False)\\n            if word:\\n                # If a word is found, add it to the results list\\n                res.append(word)\\n            # Mark the current position on the board as visited\\n            board[x][y] = \\'*\\'\\n            # Recursively search in all four directions\\n            for dirx, diry in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                curx, cury = x + dirx, y + diry\\n                # Check if the next position is within the board and the next letter is in the trie\\n                if 0 <= curx < m and 0 <= cury < n and board[curx][cury] in cur:\\n                    dfs(curx, cury, cur)\\n            # Restore the original value of the current position on the board\\n            board[x][y] = letter\\n            # If the current node has no children, remove it from the trie\\n            if not cur:\\n                root.pop(letter)\\n                \\n        # Build a trie data structure from the list of words\\n        trie = {}\\n        for word in words:\\n            cur = trie\\n            for letter in word:\\n                cur = cur.setdefault(letter, {})\\n            cur[\\'#\\'] = word\\n            \\n        # Get the dimensions of the board\\n        m, n = len(board), len(board[0])\\n        # Initialize a list to store the results\\n        res = []\\n        \\n        # Traverse the board and search for words\\n        for i in range(m):\\n            for j in range(n):\\n                # Check if the current letter is in the trie\\n                if board[i][j] in trie:\\n                    dfs(i, j, trie)\\n        \\n        # Return the list of results\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779776,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    struct TrieNode {\\n        vector<TrieNode*> child;\\n        string word;\\n        TrieNode() : word(\"\"), child(vector<TrieNode*>(26, nullptr)) {}\\n    };\\n    \\n    TrieNode* buildTrie(vector<string>& words) {\\n        TrieNode* root = new TrieNode();\\n        for (string w : words) {\\n            TrieNode* curr = root;\\n            for (char c : w) {\\n                int i = c - \\'a\\';\\n                if (curr->child[i] == NULL) curr->child[i] = new TrieNode();\\n                curr = curr->child[i];\\n            }\\n            curr->word = w;\\n        }\\n        return root;\\n    }\\n\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        vector<string> out;\\n        TrieNode* root = buildTrie(words);\\n        for(int i = 0; i < board.size(); ++i) \\n            for(int j = 0; j < board[0].size(); ++j) \\n                dfs(board, i, j, root, out);\\n        return out;\\n    }\\n    \\n    void dfs(vector<vector<char>>& board, int i, int j, TrieNode* curr, vector<string>& out) {\\n        char c = board[i][j];\\n        if(c == \\'#\\' || curr->child[c - \\'a\\'] == NULL) return;\\n        curr = curr->child[c - \\'a\\'];\\n        if (curr->word != \"\") {\\n            out.push_back(curr->word);\\n            curr->word = \"\";\\n        }\\n        board[i][j] = \\'#\\';\\n        if(i > 0) dfs(board, i - 1, j , curr, out); \\n        if(j > 0) dfs(board, i, j - 1, curr, out);\\n        if(i < board.size() - 1) dfs(board, i + 1, j, curr, out); \\n        if(j < board[0].size() - 1) dfs(board, i, j + 1, curr, out); \\n        board[i][j] = c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct TrieNode {\\n        vector<TrieNode*> child;\\n        string word;\\n        TrieNode() : word(\"\"), child(vector<TrieNode*>(26, nullptr)) {}\\n    };\\n    \\n    TrieNode* buildTrie(vector<string>& words) {\\n        TrieNode* root = new TrieNode();\\n        for (string w : words) {\\n            TrieNode* curr = root;\\n            for (char c : w) {\\n                int i = c - \\'a\\';\\n                if (curr->child[i] == NULL) curr->child[i] = new TrieNode();\\n                curr = curr->child[i];\\n            }\\n            curr->word = w;\\n        }\\n        return root;\\n    }\\n\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        vector<string> out;\\n        TrieNode* root = buildTrie(words);\\n        for(int i = 0; i < board.size(); ++i) \\n            for(int j = 0; j < board[0].size(); ++j) \\n                dfs(board, i, j, root, out);\\n        return out;\\n    }\\n    \\n    void dfs(vector<vector<char>>& board, int i, int j, TrieNode* curr, vector<string>& out) {\\n        char c = board[i][j];\\n        if(c == \\'#\\' || curr->child[c - \\'a\\'] == NULL) return;\\n        curr = curr->child[c - \\'a\\'];\\n        if (curr->word != \"\") {\\n            out.push_back(curr->word);\\n            curr->word = \"\";\\n        }\\n        board[i][j] = \\'#\\';\\n        if(i > 0) dfs(board, i - 1, j , curr, out); \\n        if(j > 0) dfs(board, i, j - 1, curr, out);\\n        if(i < board.size() - 1) dfs(board, i + 1, j, curr, out); \\n        if(j < board[0].size() - 1) dfs(board, i, j + 1, curr, out); \\n        board[i][j] = c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779595,
                "title": "java-easy-solution-100-faster",
                "content": "# Upvote if you like the solution\\n# Code\\n```\\nclass Solution {\\n    private static final char HASH_TAG = \\'#\\';\\n    private Tree root = new Tree();\\n    \\n    public List<String> findWords(char[][] board, String[] words) {\\n        for (String word : words) {\\n            Tree temp = root;\\n            // Test case 60/63 \\n            for (int i = word.length() - 1; i >= 0; i--) {\\n                int idx = word.charAt(i) - \\'a\\';\\n                if (temp.val[idx] == null) {\\n                    temp.val[idx] = new Tree();\\n                    temp.val[idx].parent = temp;\\n                    temp.val[idx].idx = idx;\\n                }\\n                temp = temp.val[idx];\\n            }\\n            temp.word = word;\\n        }    \\n        return searchWord(board);\\n    }\\n    \\n    private List<String> searchWord(char[][] board) {\\n        List<String> res = new ArrayList<>();\\n        \\n        for (int i = 0; i < board.length; i++)\\n            for (int j = 0; j < board[0].length; j++) {\\n                Tree temp = root;\\n                checkWord(res, i, j, board, temp);\\n            }\\n        \\n        return res;\\n    }\\n    \\n    private void checkWord(List<String> res, int y, int x, char[][] board, Tree temp) {\\n        \\n        if (x >= board[0].length || x < 0\\n            || y >= board.length || y < 0)\\n            return;\\n        \\n        char ch = board[y][x];\\n        if (ch== HASH_TAG || temp.val[ch - \\'a\\'] == null)\\n            return;\\n        \\n        temp = temp.val[ch - \\'a\\'];\\n        \\n        if (temp.word != null) {\\n            res.add(temp.word);\\n            temp.word = null; // Test case 17/63: When there is more than one answer\\n            Tree ptr = temp;\\n            while (ptr.parent != null \\n                    && ptr.isEmpty()) {\\n                int idx = ptr.idx;\\n                ptr = ptr.parent;\\n                ptr.val[idx] = null;\\n            }\\n        }\\n        \\n        board[y][x] = HASH_TAG;\\n\\n        checkWord(res, y, x + 1, board, temp);\\n        checkWord(res, y, x - 1, board, temp);\\n        checkWord(res, y + 1, x, board, temp);\\n        checkWord(res, y - 1, x, board, temp);\\n        \\n        board[y][x] = ch;\\n    }\\n    \\n    class Tree {\\n        Tree parent;\\n        Tree[] val = new Tree[26];\\n        String word;\\n        int idx;\\n\\n        public boolean isEmpty() {\\n            for (int i = 0; i < 26; i++) \\n                if (val[i] != null)\\n                    return false;\\n\\n            return true;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private static final char HASH_TAG = \\'#\\';\\n    private Tree root = new Tree();\\n    \\n    public List<String> findWords(char[][] board, String[] words) {\\n        for (String word : words) {\\n            Tree temp = root;\\n            // Test case 60/63 \\n            for (int i = word.length() - 1; i >= 0; i--) {\\n                int idx = word.charAt(i) - \\'a\\';\\n                if (temp.val[idx] == null) {\\n                    temp.val[idx] = new Tree();\\n                    temp.val[idx].parent = temp;\\n                    temp.val[idx].idx = idx;\\n                }\\n                temp = temp.val[idx];\\n            }\\n            temp.word = word;\\n        }    \\n        return searchWord(board);\\n    }\\n    \\n    private List<String> searchWord(char[][] board) {\\n        List<String> res = new ArrayList<>();\\n        \\n        for (int i = 0; i < board.length; i++)\\n            for (int j = 0; j < board[0].length; j++) {\\n                Tree temp = root;\\n                checkWord(res, i, j, board, temp);\\n            }\\n        \\n        return res;\\n    }\\n    \\n    private void checkWord(List<String> res, int y, int x, char[][] board, Tree temp) {\\n        \\n        if (x >= board[0].length || x < 0\\n            || y >= board.length || y < 0)\\n            return;\\n        \\n        char ch = board[y][x];\\n        if (ch== HASH_TAG || temp.val[ch - \\'a\\'] == null)\\n            return;\\n        \\n        temp = temp.val[ch - \\'a\\'];\\n        \\n        if (temp.word != null) {\\n            res.add(temp.word);\\n            temp.word = null; // Test case 17/63: When there is more than one answer\\n            Tree ptr = temp;\\n            while (ptr.parent != null \\n                    && ptr.isEmpty()) {\\n                int idx = ptr.idx;\\n                ptr = ptr.parent;\\n                ptr.val[idx] = null;\\n            }\\n        }\\n        \\n        board[y][x] = HASH_TAG;\\n\\n        checkWord(res, y, x + 1, board, temp);\\n        checkWord(res, y, x - 1, board, temp);\\n        checkWord(res, y + 1, x, board, temp);\\n        checkWord(res, y - 1, x, board, temp);\\n        \\n        board[y][x] = ch;\\n    }\\n    \\n    class Tree {\\n        Tree parent;\\n        Tree[] val = new Tree[26];\\n        String word;\\n        int idx;\\n\\n        public boolean isEmpty() {\\n            for (int i = 0; i < 26; i++) \\n                if (val[i] != null)\\n                    return false;\\n\\n            return true;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1242807,
                "title": "c-easy-trie-solution-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    //we use a trie for storing the words\\n    struct TrieNode{\\n        int endsHere;\\n        TrieNode* child[26];\\n    };\\n     \\n    //create a trieNode and returns it\\n    TrieNode* getNode()\\n    {\\n        TrieNode* newNode=new TrieNode;\\n        newNode->endsHere=0;\\n        for(int i=0;i<26;++i)\\n        {\\n            newNode->child[i]=NULL;\\n        }\\n        return newNode;\\n    }\\n    \\n    TrieNode* root=getNode();\\n    \\n    vector<vector<int>> offset={{0,1},{1,0},{-1,0},{0,-1}}; //useful to move in 4 directions\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        \\n        //insert all the words into the trie\\n        for(auto word:words)\\n        {\\n            addWord(word);\\n        }\\n        \\n        \\n        vector<string> res;\\n        //now search the words in the grid\\n        int rows=board.size();\\n        int cols=board[0].size();\\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if(root->child[board[i][j]-\\'a\\']!=NULL){ //if a starting letter of a wod exists in the words dict\\n                    checkWord(root->child[board[i][j]-\\'a\\'],board,i,j,res,\"\");\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    \\n    //inserts words into the trie\\n    void addWord(string word)\\n    {\\n        TrieNode* curr=root;\\n        for(int i=0;i<word.length();++i)\\n        {\\n            int ind=word[i]-\\'a\\';\\n            if(curr->child[ind]==NULL) //create if doesnot exists\\n                curr->child[ind]=getNode();\\n            curr=curr->child[ind];\\n        }\\n        curr->endsHere=1; //the word ends here\\n    }\\n    \\n    //check if the char exists in the board\\n    void checkWord(TrieNode* curr,vector<vector<char>>& board,int i,int j,vector<string>& res,string s)\\n    {\\n        \\n        s.push_back(board[i][j]);\\n        if(curr->endsHere>0)\\n        {\\n            //we have got a word\\n            res.push_back(s);\\n            curr->endsHere-=1; //since  not to push again the same word from other possibility\\n        }\\n        char orig=board[i][j];\\n        board[i][j]=\\'#\\';\\n        for(int k=0;k<4;k++)\\n        {\\n            int x=offset[k][0]+i;\\n            int y=offset[k][1]+j;\\n            \\n            //dont move in these directions\\n            if(x<0 || y<0 || x>=board.size() || y>=board[0].size() || board[x][y]==\\'#\\' || curr->child[board[x][y]-\\'a\\']==NULL)\\n                continue;\\n            checkWord(curr->child[board[x][y]-\\'a\\'],board,x,y,res,s);\\n        }\\n        board[i][j]=orig;\\n        \\n        \\n    }\\n};\\n```\\n**Please upvote if this helps :)**",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //we use a trie for storing the words\\n    struct TrieNode{\\n        int endsHere;\\n        TrieNode* child[26];\\n    };\\n     \\n    //create a trieNode and returns it\\n    TrieNode* getNode()\\n    {\\n        TrieNode* newNode=new TrieNode;\\n        newNode->endsHere=0;\\n        for(int i=0;i<26;++i)\\n        {\\n            newNode->child[i]=NULL;\\n        }\\n        return newNode;\\n    }\\n    \\n    TrieNode* root=getNode();\\n    \\n    vector<vector<int>> offset={{0,1},{1,0},{-1,0},{0,-1}}; //useful to move in 4 directions\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        \\n        //insert all the words into the trie\\n        for(auto word:words)\\n        {\\n            addWord(word);\\n        }\\n        \\n        \\n        vector<string> res;\\n        //now search the words in the grid\\n        int rows=board.size();\\n        int cols=board[0].size();\\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if(root->child[board[i][j]-\\'a\\']!=NULL){ //if a starting letter of a wod exists in the words dict\\n                    checkWord(root->child[board[i][j]-\\'a\\'],board,i,j,res,\"\");\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    \\n    //inserts words into the trie\\n    void addWord(string word)\\n    {\\n        TrieNode* curr=root;\\n        for(int i=0;i<word.length();++i)\\n        {\\n            int ind=word[i]-\\'a\\';\\n            if(curr->child[ind]==NULL) //create if doesnot exists\\n                curr->child[ind]=getNode();\\n            curr=curr->child[ind];\\n        }\\n        curr->endsHere=1; //the word ends here\\n    }\\n    \\n    //check if the char exists in the board\\n    void checkWord(TrieNode* curr,vector<vector<char>>& board,int i,int j,vector<string>& res,string s)\\n    {\\n        \\n        s.push_back(board[i][j]);\\n        if(curr->endsHere>0)\\n        {\\n            //we have got a word\\n            res.push_back(s);\\n            curr->endsHere-=1; //since  not to push again the same word from other possibility\\n        }\\n        char orig=board[i][j];\\n        board[i][j]=\\'#\\';\\n        for(int k=0;k<4;k++)\\n        {\\n            int x=offset[k][0]+i;\\n            int y=offset[k][1]+j;\\n            \\n            //dont move in these directions\\n            if(x<0 || y<0 || x>=board.size() || y>=board[0].size() || board[x][y]==\\'#\\' || curr->child[board[x][y]-\\'a\\']==NULL)\\n                continue;\\n            checkWord(curr->child[board[x][y]-\\'a\\'],board,x,y,res,s);\\n        }\\n        board[i][j]=orig;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1511657,
                "title": "python-clean-with-trie-pruning-optimization-and-code-comments",
                "content": "The idea is to build a Trie for words, then run dfs at each board location to match the words stored in trie. The time limit is tight, so to avoid TLE, prune the trie once a match is found at the leaf node. \\n\\nIf you are interested, below are some options I tried that lead to TLE:\\n\\n1. Insead build Trie for words, build a Trie for each board location, then match words to all these Tries; this lead to TLE since needs to build many tries, and there are too many paths to store during dfs (at each position has 3 directions to go and explode)\\n\\n2. Use python defaultdict for trie and no pruning (if you use the python native dict() for trie, it can pass even without pruning).\\n\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = collections.defaultdict(TrieNode)\\n        self.is_word = False\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def insert(self, word):\\n        node = self.root\\n        for c in word:\\n            node = node.children[c]\\n        node.is_word = True\\n\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        trie = Trie()\\n        for w in words:\\n            trie.insert(w)\\n            \\n        m, n = len(board), len(board[0])\\n        res = []\\n        for i in range(m):\\n            for j in range(n):\\n                paths = []\\n                path = \"\"\\n                self.dfs(board, i, j, trie.root, path, paths)\\n                res += paths\\n        return res\\n    \\n    def dfs(self, board, row, col, node, path, paths):\\n        # match words starting from node of the trie, board starting from (row, col)\\n        if node.is_word:\\n            paths.append(path)\\n\\t\\t\\t# set to False so not to repeat the same word\\n            node.is_word = False\\n        \\n        m, n = len(board), len(board[0])\\n\\t\\t# similar to two pointers: here is to check if pointer for board reaches its end, or not a match\\n        if row < 0 or row >=m or col < 0 or col >= n or board[row][col] not in node.children:\\n            return \\n        \\n\\t\\t# This is similar to 2 pointers: now a match is found, move the pointer for trie and pointer for board\\n        tmp = board[row][col]\\n        board[row][col] = \\'#\\'\\n        dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        for d in dirs:\\n            r, c = row + d[0], col + d[1]\\n            self.dfs(board, r, c, node.children[tmp], path + tmp, paths)\\n        board[row][col] = tmp\\n        \\n        # pruning: if it is a leaf and a matched word is found for it already, pop it to decrease trie size\\n        if len(node.children[tmp].children) == 0:\\n            del node.children[tmp]\\n",
                "solutionTags": [
                    "Python3",
                    "Trie"
                ],
                "code": "The idea is to build a Trie for words, then run dfs at each board location to match the words stored in trie. The time limit is tight, so to avoid TLE, prune the trie once a match is found at the leaf node. \\n\\nIf you are interested, below are some options I tried that lead to TLE:\\n\\n1. Insead build Trie for words, build a Trie for each board location, then match words to all these Tries; this lead to TLE since needs to build many tries, and there are too many paths to store during dfs (at each position has 3 directions to go and explode)\\n\\n2. Use python defaultdict for trie and no pruning (if you use the python native dict() for trie, it can pass even without pruning).\\n\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = collections.defaultdict(TrieNode)\\n        self.is_word = False\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def insert(self, word):\\n        node = self.root\\n        for c in word:\\n            node = node.children[c]\\n        node.is_word = True\\n\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        trie = Trie()\\n        for w in words:\\n            trie.insert(w)\\n            \\n        m, n = len(board), len(board[0])\\n        res = []\\n        for i in range(m):\\n            for j in range(n):\\n                paths = []\\n                path = \"\"\\n                self.dfs(board, i, j, trie.root, path, paths)\\n                res += paths\\n        return res\\n    \\n    def dfs(self, board, row, col, node, path, paths):\\n        # match words starting from node of the trie, board starting from (row, col)\\n        if node.is_word:\\n            paths.append(path)\\n\\t\\t\\t# set to False so not to repeat the same word\\n            node.is_word = False\\n        \\n        m, n = len(board), len(board[0])\\n\\t\\t# similar to two pointers: here is to check if pointer for board reaches its end, or not a match\\n        if row < 0 or row >=m or col < 0 or col >= n or board[row][col] not in node.children:\\n            return \\n        \\n\\t\\t# This is similar to 2 pointers: now a match is found, move the pointer for trie and pointer for board\\n        tmp = board[row][col]\\n        board[row][col] = \\'#\\'\\n        dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        for d in dirs:\\n            r, c = row + d[0], col + d[1]\\n            self.dfs(board, r, c, node.children[tmp], path + tmp, paths)\\n        board[row][col] = tmp\\n        \\n        # pruning: if it is a leaf and a matched word is found for it already, pop it to decrease trie size\\n        if len(node.children[tmp].children) == 0:\\n            del node.children[tmp]\\n",
                "codeTag": "Java"
            },
            {
                "id": 591116,
                "title": "javascript-backtracking-with-trie-comments-video",
                "content": "https://www.youtube.com/watch?v=7XmS8McW_1U\\nsee detailed explanation about trie here\\n```\\n/**\\n * @param {character[][]} board\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar findWords = function(board, words) {\\n  let res = [];\\n\\n  const root = buildTrie(words);\\n  for (let row = 0; row < board.length; row++) {\\n    for (let col = 0; col < board[0].length; col++) {\\n      dfs(root, row, col, board, res);\\n    }\\n  }\\n  return res;\\n\\n};\\n\\n  function dfs(node, row, col, board, res) {\\n    if (node.end) {\\n      res.push(node.end);\\n      node.end = null;   // make sure only print one time for each word\\n    }\\n\\n    if (row < 0 || row >= board.length || col < 0 || col >= board[0].length) return;\\n    if (!node[board[row][col]]) return;\\n\\n    const c = board[row][col];\\n    board[row][col] = \\'#\\';  // mark visited\\n    dfs(node[c], row + 1, col, board, res); // up\\n    dfs(node[c], row - 1, col, board, res); // down\\n    dfs(node[c], row, col + 1, board, res); // right\\n    dfs(node[c], row, col - 1, board, res); // left\\n    board[row][col] = c;  // reset - back track\\n  }\\n\\nfunction buildTrie(words) {\\n    const root = {};\\n    for (let w of words) {\\n      let pointer = root; // here \\'pointer\\' just a reference, that we use to go down from root till last child node\\n                          // and when we rich last child node - this is the end of the world\\n                          // and instead of setting \"node.end = true\", we set \"node.end = word\"\\n      for (let c of w) {\\n        if (!pointer[c]) pointer[c] = {}; // if we already have such node, lets ignore it creating and just move the pointer\\n        pointer = pointer[c];\\n      }\\n      pointer.end = w; \\n    }\\n    return root;\\n  }\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\n/**\\n * @param {character[][]} board\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar findWords = function(board, words) {\\n  let res = [];\\n\\n  const root = buildTrie(words);\\n  for (let row = 0; row < board.length; row++) {\\n    for (let col = 0; col < board[0].length; col++) {\\n      dfs(root, row, col, board, res);\\n    }\\n  }\\n  return res;\\n\\n};\\n\\n  function dfs(node, row, col, board, res) {\\n    if (node.end) {\\n      res.push(node.end);\\n      node.end = null;   // make sure only print one time for each word\\n    }\\n\\n    if (row < 0 || row >= board.length || col < 0 || col >= board[0].length) return;\\n    if (!node[board[row][col]]) return;\\n\\n    const c = board[row][col];\\n    board[row][col] = \\'#\\';  // mark visited\\n    dfs(node[c], row + 1, col, board, res); // up\\n    dfs(node[c], row - 1, col, board, res); // down\\n    dfs(node[c], row, col + 1, board, res); // right\\n    dfs(node[c], row, col - 1, board, res); // left\\n    board[row][col] = c;  // reset - back track\\n  }\\n\\nfunction buildTrie(words) {\\n    const root = {};\\n    for (let w of words) {\\n      let pointer = root; // here \\'pointer\\' just a reference, that we use to go down from root till last child node\\n                          // and when we rich last child node - this is the end of the world\\n                          // and instead of setting \"node.end = true\", we set \"node.end = word\"\\n      for (let c of w) {\\n        if (!pointer[c]) pointer[c] = {}; // if we already have such node, lets ignore it creating and just move the pointer\\n        pointer = pointer[c];\\n      }\\n      pointer.end = w; \\n    }\\n    return root;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1510396,
                "title": "python-going-from-7586-ms-to-300-ms",
                "content": "The idea is the same as mentioned by others, i.e. construct a trie of the given words and then do a DFS + Backtrack from each cell, moving ahead only if the character is in the trie. To maintain a unique set of words, add the discovered words into a set. \\n\\nThe above solution works fine, but gives a runtime of 7586ms in Python. How to improve?\\n\\nNote that only unique words are required, so one **big** optimization would be to delete the words from the trie which are already found. This simple optimization brings down the runtime from 7586ms to 300ms!!\\n\\nDamn, that ended soon. (That\\'s what she said!)\\n\\n```\\nclass TrieNode(object):\\n        def __init__(self, char):\\n            self.char = char\\n            self.isWord = False\\n            self.children = {}\\n\\n        def addNode(self, char, node):\\n            self.children[char] = node\\n\\nclass Trie:\\n\\n    def __init__(self):\\n        self.root = TrieNode(\\'0\\')\\n\\n    def insert(self, word: str) -> None:\\n        cur = self.root\\n        for c in word:\\n            if c not in cur.children:\\n                child = TrieNode(c)\\n                cur.addNode(c, child)\\n            cur = cur.children[c]\\n        cur.isWord = True\\n\\n    def search(self, word: str) -> bool:\\n        cur = self.root\\n        for c in word:\\n            if c not in cur.children:\\n                return False\\n            cur = cur.children[c]\\n        return cur.isWord\\n\\n    def startsWith(self, prefix: str) -> bool:\\n        cur = self.root\\n        for c in prefix:\\n            if c not in cur.children:\\n                return False\\n            cur = cur.children[c]\\n        return True\\n    \\n    def eraseWord(self, ind, word, cur):\\n        if ind == len(word):\\n            cur.isWord = False\\n            if len(cur.children) == 0:\\n                return True\\n            return False\\n        \\n        canErase = self.eraseWord(ind+1, word, cur.children[word[ind]])\\n        if canErase:\\n            cur.children.pop(word[ind])\\n        \\n        return len(cur.children) == 0\\n            \\n        \\n    \\nclass Solution:\\n    \\n    def getWords(self, x, y, cur, board, vis, word):\\n        \\n        if cur.isWord:\\n            w = \"\".join(word)\\n            self.wordsPresent.append(w)\\n            self.trieOb.eraseWord(0, word, self.trieOb.root)\\n            \\n        vis[x][y] = 1\\n        for nx, ny in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:\\n            if nx >= 0 and nx < self.m and ny >= 0 and ny < self.n and vis[nx][ny] == 0:\\n                nxc = board[nx][ny]\\n                if nxc in cur.children:\\n                    word.append(nxc)\\n                    self.getWords(nx, ny, cur.children[nxc], board, vis, word)\\n                    word.pop()\\n        vis[x][y] = 0\\n        \\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        self.m, self.n = len(board), len(board[0])\\n        self.trieOb = Trie()\\n        for w in words:\\n            self.trieOb.insert(w)\\n        \\n        self.wordsPresent = []\\n        vis = [[0 for _ in range(self.n)] for _ in range(self.m)]\\n        for x in range(self.m):\\n            for y in range(self.n):\\n                c = board[x][y]\\n                if c in self.trieOb.root.children:\\n                    self.getWords(x, y, self.trieOb.root.children[c], board, vis, [c])\\n        return self.wordsPresent\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode(object):\\n        def __init__(self, char):\\n            self.char = char\\n            self.isWord = False\\n            self.children = {}\\n\\n        def addNode(self, char, node):\\n            self.children[char] = node\\n\\nclass Trie:\\n\\n    def __init__(self):\\n        self.root = TrieNode(\\'0\\')\\n\\n    def insert(self, word: str) -> None:\\n        cur = self.root\\n        for c in word:\\n            if c not in cur.children:\\n                child = TrieNode(c)\\n                cur.addNode(c, child)\\n            cur = cur.children[c]\\n        cur.isWord = True\\n\\n    def search(self, word: str) -> bool:\\n        cur = self.root\\n        for c in word:\\n            if c not in cur.children:\\n                return False\\n            cur = cur.children[c]\\n        return cur.isWord\\n\\n    def startsWith(self, prefix: str) -> bool:\\n        cur = self.root\\n        for c in prefix:\\n            if c not in cur.children:\\n                return False\\n            cur = cur.children[c]\\n        return True\\n    \\n    def eraseWord(self, ind, word, cur):\\n        if ind == len(word):\\n            cur.isWord = False\\n            if len(cur.children) == 0:\\n                return True\\n            return False\\n        \\n        canErase = self.eraseWord(ind+1, word, cur.children[word[ind]])\\n        if canErase:\\n            cur.children.pop(word[ind])\\n        \\n        return len(cur.children) == 0\\n            \\n        \\n    \\nclass Solution:\\n    \\n    def getWords(self, x, y, cur, board, vis, word):\\n        \\n        if cur.isWord:\\n            w = \"\".join(word)\\n            self.wordsPresent.append(w)\\n            self.trieOb.eraseWord(0, word, self.trieOb.root)\\n            \\n        vis[x][y] = 1\\n        for nx, ny in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:\\n            if nx >= 0 and nx < self.m and ny >= 0 and ny < self.n and vis[nx][ny] == 0:\\n                nxc = board[nx][ny]\\n                if nxc in cur.children:\\n                    word.append(nxc)\\n                    self.getWords(nx, ny, cur.children[nxc], board, vis, word)\\n                    word.pop()\\n        vis[x][y] = 0\\n        \\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        self.m, self.n = len(board), len(board[0])\\n        self.trieOb = Trie()\\n        for w in words:\\n            self.trieOb.insert(w)\\n        \\n        self.wordsPresent = []\\n        vis = [[0 for _ in range(self.n)] for _ in range(self.m)]\\n        for x in range(self.m):\\n            for y in range(self.n):\\n                c = board[x][y]\\n                if c in self.trieOb.root.children:\\n                    self.getWords(x, y, self.trieOb.root.children[c], board, vis, [c])\\n        return self.wordsPresent\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1482662,
                "title": "javascript-100-clean-code-w-explanation-trie-pruning",
                "content": "![image](https://assets.leetcode.com/users/images/794345da-3575-4594-8ce2-ee19daff7735_1632497992.4097955.png)\\n\\nDoing the Blind 75 List and posting all solutions.\\n\\nHere\\'s the pruning version w/o comments:  (See below for explanation.)\\n```\\nvar findWords = function(board, words) {\\n  const res = [], trie = {};\\n  \\n  for (let word of words) {\\n    let curNode = trie;\\n    for (let char of word) {\\n      curNode[char] = curNode[char] || {};\\n      curNode[char].count = curNode[char].count + 1 || 1;\\n      curNode = curNode[char];\\n    };\\n    curNode.end = word;\\n  }\\n  \\n  for (let row = 0; row < board.length; row++) {\\n    for (let col = 0; col < board[row].length; col++) {\\n      if (trie[board[row][col]]) traverse(row, col);\\n    }\\n  }\\n  \\n  return res;\\n  \\n  function traverse(row, col, node = trie) {\\n    if (!board[row][col]) return;\\n    \\n    const char = board[row][col], curNode = node[char];\\n    if (!curNode) return;\\n    \\n    if (curNode.end) {\\n      res.push(curNode.end);\\n      let toDelete = trie;\\n      for (let char of curNode.end) {\\n        toDelete[char].count--;\\n        if (!toDelete[char].count) {\\n          delete(toDelete[char]);\\n          break;\\n        }\\n        toDelete = toDelete[char];\\n      }\\n      curNode.end = null;\\n    }\\n    \\n    board[row][col] = 0;\\n    (col - 1 >= 0) && traverse(row, col - 1, curNode);\\n    (col + 1 < board[row].length) && traverse(row, col + 1, curNode);\\n    (row - 1 >= 0) && traverse(row - 1, col, curNode);\\n    (row + 1 < board.length) && traverse(row + 1, col, curNode);\\n    board[row][col] = char;\\n  }\\n};\\n```\\n\\nHere is - mostly - the same code as above w/ explanation: (Minus pruning.  Sorry, I already had this explanation written up before I implemented it.  That said, to implement pruning, we just added a counter to each trie node that increments so we can tell how many words share the node.  Then, below when we find results, we decrement the count as we push to results.  If count === 0 after, we prune it from the trie so that we don\\'t go down that track again.  And that\\'s it... All we need to take an 85% 440ms solution to a 99% 96ms one.)\\n![image](https://assets.leetcode.com/users/images/09e67c6e-948d-4d30-9d9e-c0d2ff9488f1_1632521543.0135832.png)\\n\\n```\\nvar findWords = function(board, words) {\\n  const trie = {}, res = [];\\n  \\n  //Lines below just populate our trie.  See LC 208. & 211. for a better understanding on tries.\\n  for (let word of words) {\\n    let curNode = trie;\\n    for (let char of word) (curNode = curNode[char] = curNode[char] || {});\\n    curNode.end = word;\\n  }\\n  \\n  //Here we loop through entire board, if char at those coords is in \\n  //our trie on the root level, we call our traverse function.\\n  for (let row = 0; row < board.length; row++) {\\n    for (let col = 0; col < board[row].length; col++) {\\n      if (trie[board[row][col]]) traverse(row, col);\\n    }\\n  }\\n  \\n  return res;\\n  \\n  //Function takes row, col and node.  First time called, node is root\\n  //level of our trie, as the function runs node stays in sync with where\\n  //our recursive calls are at.\\n  function traverse(row, col, node = trie) {\\n    \\n    //Further down in this function we set board[row][col] to 0 before trying\\n    //neighboring coordinates.  The line below keeps us from visiting the same\\n    //cell more than once.\\n    if (!board[row][col]) return;\\n    \\n    //Here we capture the char on the board at coords, and we also move down\\n    //within the trie to the level that matches that char.\\n    const char = board[row][col], curNode = node[char];\\n    \\n    //If there is no curNode (I.e.- Current letter not within our trie node), \\n    //we return, because our sequence of correct letters has been broken.\\n    if (!curNode) return;\\n    \\n    //If current node has the end property, we push the word that\\'s the value\\n    //for curNode.end (We set this above in the trie).  We then set end to \\n\\t//null to keep from pushing the same word more than once.\\n    if (curNode.end) {\\n      res.push(curNode.end);\\n      curNode.end = null;\\n    }\\n    \\n    //Here we set board[row][col] to 0 in order to keep track of where we \\n    //have already visited.  Then we try all options and set it back afterward.\\n    board[row][col] = 0;\\n    (col - 1 >= 0) && traverse(row, col - 1, curNode);\\n    (col + 1 < board[row].length) && traverse(row, col + 1, curNode);\\n    (row - 1 >= 0) && traverse(row - 1, col, curNode);\\n    (row + 1 < board.length) && traverse(row + 1, col, curNode);\\n    board[row][col] = char;\\n  }\\n};\\n```\\n\\nEdit:\\nSlightly modified version of this code performs Phenomenal for actual wordsearches (Added directions and diagonals so it only searches in straight lines radiating out from found char).  I might make this a RN project with ML Kit to scan in searches and solve on the fly.  Trying to decide if it\\'s a project worth working on or not. lol\\n![image](https://assets.leetcode.com/users/images/e72df208-a87c-49ab-952e-7d45d130159b_1633803539.6985726.png)\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Trie"
                ],
                "code": "```\\nvar findWords = function(board, words) {\\n  const res = [], trie = {};\\n  \\n  for (let word of words) {\\n    let curNode = trie;\\n    for (let char of word) {\\n      curNode[char] = curNode[char] || {};\\n      curNode[char].count = curNode[char].count + 1 || 1;\\n      curNode = curNode[char];\\n    };\\n    curNode.end = word;\\n  }\\n  \\n  for (let row = 0; row < board.length; row++) {\\n    for (let col = 0; col < board[row].length; col++) {\\n      if (trie[board[row][col]]) traverse(row, col);\\n    }\\n  }\\n  \\n  return res;\\n  \\n  function traverse(row, col, node = trie) {\\n    if (!board[row][col]) return;\\n    \\n    const char = board[row][col], curNode = node[char];\\n    if (!curNode) return;\\n    \\n    if (curNode.end) {\\n      res.push(curNode.end);\\n      let toDelete = trie;\\n      for (let char of curNode.end) {\\n        toDelete[char].count--;\\n        if (!toDelete[char].count) {\\n          delete(toDelete[char]);\\n          break;\\n        }\\n        toDelete = toDelete[char];\\n      }\\n      curNode.end = null;\\n    }\\n    \\n    board[row][col] = 0;\\n    (col - 1 >= 0) && traverse(row, col - 1, curNode);\\n    (col + 1 < board[row].length) && traverse(row, col + 1, curNode);\\n    (row - 1 >= 0) && traverse(row - 1, col, curNode);\\n    (row + 1 < board.length) && traverse(row + 1, col, curNode);\\n    board[row][col] = char;\\n  }\\n};\\n```\n```\\nvar findWords = function(board, words) {\\n  const trie = {}, res = [];\\n  \\n  //Lines below just populate our trie.  See LC 208. & 211. for a better understanding on tries.\\n  for (let word of words) {\\n    let curNode = trie;\\n    for (let char of word) (curNode = curNode[char] = curNode[char] || {});\\n    curNode.end = word;\\n  }\\n  \\n  //Here we loop through entire board, if char at those coords is in \\n  //our trie on the root level, we call our traverse function.\\n  for (let row = 0; row < board.length; row++) {\\n    for (let col = 0; col < board[row].length; col++) {\\n      if (trie[board[row][col]]) traverse(row, col);\\n    }\\n  }\\n  \\n  return res;\\n  \\n  //Function takes row, col and node.  First time called, node is root\\n  //level of our trie, as the function runs node stays in sync with where\\n  //our recursive calls are at.\\n  function traverse(row, col, node = trie) {\\n    \\n    //Further down in this function we set board[row][col] to 0 before trying\\n    //neighboring coordinates.  The line below keeps us from visiting the same\\n    //cell more than once.\\n    if (!board[row][col]) return;\\n    \\n    //Here we capture the char on the board at coords, and we also move down\\n    //within the trie to the level that matches that char.\\n    const char = board[row][col], curNode = node[char];\\n    \\n    //If there is no curNode (I.e.- Current letter not within our trie node), \\n    //we return, because our sequence of correct letters has been broken.\\n    if (!curNode) return;\\n    \\n    //If current node has the end property, we push the word that\\'s the value\\n    //for curNode.end (We set this above in the trie).  We then set end to \\n\\t//null to keep from pushing the same word more than once.\\n    if (curNode.end) {\\n      res.push(curNode.end);\\n      curNode.end = null;\\n    }\\n    \\n    //Here we set board[row][col] to 0 in order to keep track of where we \\n    //have already visited.  Then we try all options and set it back afterward.\\n    board[row][col] = 0;\\n    (col - 1 >= 0) && traverse(row, col - 1, curNode);\\n    (col + 1 < board[row].length) && traverse(row, col + 1, curNode);\\n    (row - 1 >= 0) && traverse(row - 1, col, curNode);\\n    (row + 1 < board.length) && traverse(row + 1, col, curNode);\\n    board[row][col] = char;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 59877,
                "title": "java-simple-solution-trie-dfs",
                "content": "The Algorithm works as follow:\\n\\n - In the first step we build  a [Trie][1] with the words received as\\n   parameter.\\n - Then for each square in the board, we perform the deep first search only if the next char in the board belongs to a valid branch in the Trie;\\n - At every step in the dfs, we add the current char to the string currentWord, and if the current node in the Trie is a valid word, we add this word to the final list of words.\\n\\nThe class **Move** keeps the coordinates of the next step in the board\\n\\nThe class **TrieSW** implements theTrie\\n\\nThe method **search** performs the DFS\\n\\nThe method **possMoves** retrieves the list of the possible moves from the current square\\n\\nThe method **isInBound** check if the coordinates are in the board\\n\\n    class Move {\\n    \\tint x;\\n    \\tint y;\\n    \\tpublic Move(int x,int y) {\\n    \\t\\tthis.x = x;\\n    \\t\\tthis.y = y;\\n    \\t}\\n    }\\n    \\n    class TrieSW {\\n    \\tMap<Character,TrieSW> children;\\n    \\tboolean isWord;\\n    \\t\\n    \\tpublic TrieSW() {\\n    \\t\\tthis.children = new HashMap<Character, TrieSW>();\\n    \\t\\tthis.isWord = false;\\n    \\t}\\n    \\t\\n    \\tpublic void addWord(String word) {\\n    \\t\\tchar[] chars = word.toCharArray();\\n    \\t\\tTrieSW current = this;\\n    \\t\\tfor(char c:chars) {\\n    \\t\\t\\tif(!current.children.containsKey(c)) current.children.put(c, new TrieSW());\\n    \\t\\t\\tcurrent = current.children.get(c);\\n    \\t\\t}\\n    \\t\\tcurrent.isWord = true;\\n    \\t}\\n    \\t\\n    \\tpublic void addWords(String[] words) {\\n    \\t\\tfor(String w:words) this.addWord(w);\\n    \\t}\\n    }\\n    \\n    public class Solution {\\n    \\t\\n    \\tint[] dx = {0,1,0,-1};\\n    \\tint[] dy = {1,0,-1,0};\\n    \\t\\n    \\tpublic List<String> findWords(char[][] board, String[] words) {\\n            Set<String> foundWords = new HashSet<String>();\\n            if(board==null || words==null || board.length==0 || words.length==0) return new ArrayList<String>(foundWords);\\n            TrieSW trie = new TrieSW();\\n            trie.addWords(words);\\n            StringBuilder currentWord = new StringBuilder();\\n            boolean[][] visited = new boolean[board.length][board[0].length];\\n            for(int i=0;i<board.length;i++) {\\n            \\tfor(int j=0;j<board[i].length;j++) {\\n            \\t\\tif(trie.children.containsKey(board[i][j]))\\n            \\t\\t\\tsearch(board,i,j,visited,trie,currentWord,foundWords);\\n            \\t}\\n            }\\n            return new ArrayList<String>(foundWords);\\n        }\\n    \\t\\n    \\tpublic void search(char[][] board, int y, int x, boolean[][] visited, TrieSW trie, StringBuilder currentWord, Set<String> foundWords) {\\n    \\t\\tchar c = board[y][x];\\n    \\t\\tcurrentWord.append(c);\\n    \\t\\tTrieSW current = trie.children.get(c);\\n    \\t\\tif(current.isWord) foundWords.add(currentWord.toString());\\n    \\t\\tvisited[y][x] = true;\\n    \\t\\tfor(Move m: possMoves(board,y,x,visited,current)) {\\n    \\t\\t\\tsearch(board,m.y,m.x,visited,current,currentWord,foundWords);\\n    \\t\\t}\\n    \\t\\tvisited[y][x] = false;\\n    \\t\\tcurrentWord.deleteCharAt(currentWord.length()-1);\\n    \\t}\\n    \\t\\n    \\tpublic List<Move> possMoves(char[][] board, int y, int x, boolean[][] visited, TrieSW trie) {\\n    \\t\\tList<Move> moves = new ArrayList<Move>();\\n    \\t\\tfor(int d=0; d<dx.length; d++) {\\n    \\t\\t\\tint newX = x+dx[d];\\n    \\t\\t\\tint newY = y+dy[d];\\n    \\t\\t\\tif(isInBound(newY,newX,board) && trie.children.containsKey(board[newY][newX]) && !visited[newY][newX])\\n    \\t\\t\\t\\tmoves.add(new Move(newX,newY));\\n    \\t\\t}\\n    \\t\\treturn moves;\\n    \\t}\\n    \\n    \\tprivate boolean isInBound(int y, int x, char[][] board) {\\n    \\t\\treturn x>=0 && y>=0 && y<board.length && x<board[y].length;\\n    \\t}\\n    \\t\\n    }",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "class Solution {\\n    \\t\\n    \\tint[] dx = {0,1,0,-1}",
                "codeTag": "Java"
            },
            {
                "id": 2780552,
                "title": "python-trie-dfs-53-ms-beats-99-89-optimized-for-leetcode-tests-and-well-commented",
                "content": "### Solution using Trie + DFS + optimizations directed at the LeetCode tests.\\n\\n- Use a trie to do quick lookups of the words, since the words are max 10 characters long, looking up a word in the trie can be done in O(1). \\n- Iterate over all the positions in the matrix doing DFS starting at that position and moving to its neighbors while the words that we are constructing are prefixes found in the trie. \\n- When we find a word, add it to the result set. \\n\\n### If you like this solution, don\\'t forget to \\uD83D\\uDC4D\\uD83D\\uDC4D\\uD83D\\uDC4DUPVOTE! \\uD83D\\uDC4D\\uD83D\\uDC4D\\uD83D\\uDC4D\\n\\n**NOTE:** Using the trie to do prefix and word lookups is probably all that is expected in an interview, but adding the word removal is an optimization that could be discussed.\\n\\n#### The Trie class\\n\\nThis solution uses a Trie class instead of a TrieNode. This leads to having to check the entire path in the trie at each interation of the DFS, while using a TrieNode allows us to pass the current TrieNode in the recursive call and would seem more optimal. \\n\\nI tested and I was getting worst performance using TrieNode and passing it as a parameter of the `dfs()` call vs using the Trie class and having to check the entire path, of max length 10, on each call, so I went on ahead with using the Trie class.\\n\\nOn an interview I would favor using TrieNodes because they would be more readable and easier to maintain.\\n\\n```\\n# A fast trie implementation, not as readable as using TrieNodes but\\n# more performant.\\n#\\n# https://github.com/raul-sauco/coding-challenges/blob/main/leetcode/implement-trie-prefix-tree.py\\n#\\nclass Trie:\\n    def __init__(self, words: List[str] = None):\\n\\t\\t# The variable length stores the total number of children of this node.\\n        self.root = {\"length\": 0}\\n        for word in words:\\n            self.insert(word)\\n\\t\\t\\t\\n\\t# Having a len method helps debug.\\n    def __len__(self) -> int:\\n        return self.root[\"length\"]\\n\\n    # Insert a word into this trie object. O(1) because max word length is 10 chars.\\n    def insert(self, word: str) -> None:\\n        current = self.root\\n        for c in word:\\n            if c not in current:\\n                current[c] = {\"length\": 0}\\n            # There is more complete word under this node.\\n            current[\"length\"] += 1\\n            current = current[c]\\n        current[\"length\"] += 1\\n        current[\"?\"] = True\\n\\n    # Remove a word from this trie object. O(1) because max word length is 10.\\n    def remove(self, word: str) -> None:\\n        current = self.root\\n        current[\"length\"] -= 1\\n        for i, c in enumerate(word):\\n            if c in current:\\n                current[c][\"length\"] -= 1\\n                if current[c][\"length\"] < 1:\\n                    current.pop(c)\\n                    break\\n                else:\\n                    current = current[c]\\n        # If we get to the word leaf but the trie node has children.\\n        if i == len(word) - 1 and \"?\" in current:\\n            current.pop(\"?\")\\n\\n    # Check if a given list of chars is in the trie, it returns 0 if\\n    # not found, 1 if found but not a full word and 2 if a full word.\\n\\t# O(1) because max word length is 10.\\n    def contains(self, word: List[str]) -> int:\\n        current = self.root\\n        for c in word:\\n            if c not in current:\\n                return 0\\n            current = current[c]\\n        return 2 if \"?\" in current else 1\\n```\\n\\n### The Solution class\\n\\nThis is very similar to other solutions here, use the Trie for lookups and do DFS from each cell in the board, the solution was running in 5/6 seconds in average, which placed it in the bottom 70%, until I looked at the tests and saw that a lot of the time was being wasted checking long paths that could not lead to a word.\\n\\n##### Adding two small optimizations led to the running time decreasing from 5/6 seconds to 53ms.\\n\\n**First optimization:** Create a dictionary of all the two letter combinations found in the board, only do this for combinations going right and down. The iterate over all the input words checking if all the sequences of two characters in the word can be found in the lookup dictionary, either in regular or reverse form. We create a list of _candidates_ that are words that could be found in the board, and use this on to fill the trie, instead of all the words in the input.\\n\\n**Second optimization:** Create a lookup of reversed words, when we are adding words to the trie, check if the first character repeats itself at the beginning of the word, I choose 4 times as the limit. If the first 4 characters are the same, then reverse the word, add it to the trie, reversed, and to the reversed words lookup.\\n\\n**NOTE:** Reversing the characters would still work, even if we had a word and its anadrome in the input, because we are removing the reversed words from the lookup once we find one instance of them. By the time we find the anadrome, it would be interpreted as a non-reversed word.\\n\\n**NOTE:** This optimizations, specially the second one, are directed to the LeetCode tests in particular, with other input data, for example dictionary words, I believe that they wouldn\\'t lead to any significant performance improvement.\\n\\n\\n```\\n# https://github.com/raul-sauco/coding-challenges/blob/main/leetcode/word-search-ii.py\\n\\n# Time complexity: O(m*n*(4*3^10)) - We iterate over all the positions\\n# on the board, for each, we start a search for any words that can be\\n# constructed from this position, the search will initially move to the\\n# four neighbors, then from there, as long as the characters added are\\n# found in the trie, the search will expand to the three neighbors of\\n# the new cell, since the cell we just came from cannot be visited again.\\n# So, from each position in the matrix, we will potentially do 4*3^10\\n# calls to DFS, since the max depth is equal to the length of the\\n# longest word in the trie and that is a max of 10. In theory that is\\n# still O(1) but it seems significant enough that is worth mentioning it\\n# on the time complexity.\\n#\\n# Space complexity: O(w*c) - The number of characters in all the words\\n# in the input, we store them all in the trie, and potentially also in\\n# the result set even though we would not consider that because it is\\n# used as the output. The call stack will have a max height of 10.\\n#\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        NUM_ROWS, NUM_COLS = len(board), len(board[0])\\n        # Remove words for which one of their two letter combinations\\n        # cannot be found in the board.\\n        seq_two = set()\\n        candidates = []\\n        reversed_words = set()\\n        # Find all sequences of two characters in the board. Only right\\n        # and down.\\n        for i in range(NUM_ROWS):\\n            for j in range(NUM_COLS - 1):\\n                seq_two.add(board[i][j] + board[i][j + 1])\\n        for j in range(NUM_COLS):\\n            for i in range(NUM_ROWS - 1):\\n                seq_two.add(board[i][j] + board[i + 1][j])\\n        # Iterate over the words checking if they could be in the board.\\n        for word in words:\\n            in_board = True\\n            for i in range(len(word) - 1):\\n                # For each sequence of two characters in the word, check\\n                # if that sequence or its inverse are in the board.\\n                if (\\n                    word[i : i + 2] not in seq_two\\n                    and word[i + 1] + word[i] not in seq_two\\n                ):\\n                    in_board = False\\n                    break\\n            if not in_board:\\n                continue\\n            # Reverse words with the same character in the first\\n            # four positions.\\n            if word[:4] == word[0] * 4:\\n                word = word[::-1]\\n                reversed_words.add(word)\\n            candidates.append(word)\\n\\n        NUM_ROWS, NUM_COLS = len(board), len(board[0])\\n        # Store the words found.\\n        res = set()\\n        # Initialize a Trie with the words in the input that could be in\\n        # the board potentially, the candidates, some of them may have\\n        # been reversed to make finding them more efficient.\\n        trie = Trie(candidates)\\n        # Define a function that explores the board from a given start\\n        # position.\\n        def dfs(row: int, col: int, current: List[str]) -> None:\\n            current.append(board[row][col])\\n            board[row][col] = \".\"\\n            found = trie.contains(current)\\n            # If the current branch is not in the trie, not point on\\n            # exploring any further.\\n            if not found:\\n                board[row][col] = current.pop()\\n                return\\n            # If this is an exact match, add it to the result set.\\n            if found == 2:\\n                w = \"\".join(current)\\n                if w in reversed_words:\\n                    res.add(w[::-1])\\n                    reversed_words.remove(w)\\n                else:\\n                    res.add(w)\\n                trie.remove(w)\\n            # The four directions where neighbors are found.\\n            dirs = ((0, 1), (0, -1), (1, 0), (-1, 0))\\n            for di, dj in dirs:\\n                i, j = row + di, col + dj\\n                if (\\n                    0 <= i < NUM_ROWS\\n                    and 0 <= j < NUM_COLS\\n                    and board[i][j] != \".\"\\n                ):\\n                    dfs(i, j, current)\\n            # Backtrack.\\n            board[row][col] = current.pop()\\n\\n        for i in range(NUM_ROWS):\\n            for j in range(NUM_COLS):\\n                dfs(i, j, [])\\n        return res\\n```\\n\\n#### Runtime: \\n\\nhttps://leetcode.com/problems/word-search-ii/submissions/836918548/\\n\\n![image](https://assets.leetcode.com/users/images/695b2933-f69d-4884-a4b5-322b66aaf94c_1667636295.0872102.png)\\n\\n\\n### If you liked this solution, don\\'t forget to \\uD83D\\uDC4D\\uD83D\\uDC4D\\uD83D\\uDC4DUPVOTE! \\uD83D\\uDC4D\\uD83D\\uDC4D\\uD83D\\uDC4D\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\n# A fast trie implementation, not as readable as using TrieNodes but\\n# more performant.\\n#\\n# https://github.com/raul-sauco/coding-challenges/blob/main/leetcode/implement-trie-prefix-tree.py\\n#\\nclass Trie:\\n    def __init__(self, words: List[str] = None):\\n\\t\\t# The variable length stores the total number of children of this node.\\n        self.root = {\"length\": 0}\\n        for word in words:\\n            self.insert(word)\\n\\t\\t\\t\\n\\t# Having a len method helps debug.\\n    def __len__(self) -> int:\\n        return self.root[\"length\"]\\n\\n    # Insert a word into this trie object. O(1) because max word length is 10 chars.\\n    def insert(self, word: str) -> None:\\n        current = self.root\\n        for c in word:\\n            if c not in current:\\n                current[c] = {\"length\": 0}\\n            # There is more complete word under this node.\\n            current[\"length\"] += 1\\n            current = current[c]\\n        current[\"length\"] += 1\\n        current[\"?\"] = True\\n\\n    # Remove a word from this trie object. O(1) because max word length is 10.\\n    def remove(self, word: str) -> None:\\n        current = self.root\\n        current[\"length\"] -= 1\\n        for i, c in enumerate(word):\\n            if c in current:\\n                current[c][\"length\"] -= 1\\n                if current[c][\"length\"] < 1:\\n                    current.pop(c)\\n                    break\\n                else:\\n                    current = current[c]\\n        # If we get to the word leaf but the trie node has children.\\n        if i == len(word) - 1 and \"?\" in current:\\n            current.pop(\"?\")\\n\\n    # Check if a given list of chars is in the trie, it returns 0 if\\n    # not found, 1 if found but not a full word and 2 if a full word.\\n\\t# O(1) because max word length is 10.\\n    def contains(self, word: List[str]) -> int:\\n        current = self.root\\n        for c in word:\\n            if c not in current:\\n                return 0\\n            current = current[c]\\n        return 2 if \"?\" in current else 1\\n```\n```\\n# https://github.com/raul-sauco/coding-challenges/blob/main/leetcode/word-search-ii.py\\n\\n# Time complexity: O(m*n*(4*3^10)) - We iterate over all the positions\\n# on the board, for each, we start a search for any words that can be\\n# constructed from this position, the search will initially move to the\\n# four neighbors, then from there, as long as the characters added are\\n# found in the trie, the search will expand to the three neighbors of\\n# the new cell, since the cell we just came from cannot be visited again.\\n# So, from each position in the matrix, we will potentially do 4*3^10\\n# calls to DFS, since the max depth is equal to the length of the\\n# longest word in the trie and that is a max of 10. In theory that is\\n# still O(1) but it seems significant enough that is worth mentioning it\\n# on the time complexity.\\n#\\n# Space complexity: O(w*c) - The number of characters in all the words\\n# in the input, we store them all in the trie, and potentially also in\\n# the result set even though we would not consider that because it is\\n# used as the output. The call stack will have a max height of 10.\\n#\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        NUM_ROWS, NUM_COLS = len(board), len(board[0])\\n        # Remove words for which one of their two letter combinations\\n        # cannot be found in the board.\\n        seq_two = set()\\n        candidates = []\\n        reversed_words = set()\\n        # Find all sequences of two characters in the board. Only right\\n        # and down.\\n        for i in range(NUM_ROWS):\\n            for j in range(NUM_COLS - 1):\\n                seq_two.add(board[i][j] + board[i][j + 1])\\n        for j in range(NUM_COLS):\\n            for i in range(NUM_ROWS - 1):\\n                seq_two.add(board[i][j] + board[i + 1][j])\\n        # Iterate over the words checking if they could be in the board.\\n        for word in words:\\n            in_board = True\\n            for i in range(len(word) - 1):\\n                # For each sequence of two characters in the word, check\\n                # if that sequence or its inverse are in the board.\\n                if (\\n                    word[i : i + 2] not in seq_two\\n                    and word[i + 1] + word[i] not in seq_two\\n                ):\\n                    in_board = False\\n                    break\\n            if not in_board:\\n                continue\\n            # Reverse words with the same character in the first\\n            # four positions.\\n            if word[:4] == word[0] * 4:\\n                word = word[::-1]\\n                reversed_words.add(word)\\n            candidates.append(word)\\n\\n        NUM_ROWS, NUM_COLS = len(board), len(board[0])\\n        # Store the words found.\\n        res = set()\\n        # Initialize a Trie with the words in the input that could be in\\n        # the board potentially, the candidates, some of them may have\\n        # been reversed to make finding them more efficient.\\n        trie = Trie(candidates)\\n        # Define a function that explores the board from a given start\\n        # position.\\n        def dfs(row: int, col: int, current: List[str]) -> None:\\n            current.append(board[row][col])\\n            board[row][col] = \".\"\\n            found = trie.contains(current)\\n            # If the current branch is not in the trie, not point on\\n            # exploring any further.\\n            if not found:\\n                board[row][col] = current.pop()\\n                return\\n            # If this is an exact match, add it to the result set.\\n            if found == 2:\\n                w = \"\".join(current)\\n                if w in reversed_words:\\n                    res.add(w[::-1])\\n                    reversed_words.remove(w)\\n                else:\\n                    res.add(w)\\n                trie.remove(w)\\n            # The four directions where neighbors are found.\\n            dirs = ((0, 1), (0, -1), (1, 0), (-1, 0))\\n            for di, dj in dirs:\\n                i, j = row + di, col + dj\\n                if (\\n                    0 <= i < NUM_ROWS\\n                    and 0 <= j < NUM_COLS\\n                    and board[i][j] != \".\"\\n                ):\\n                    dfs(i, j, current)\\n            # Backtrack.\\n            board[row][col] = current.pop()\\n\\n        for i in range(NUM_ROWS):\\n            for j in range(NUM_COLS):\\n                dfs(i, j, [])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1516101,
                "title": "c-simple-backtracking-dfs-trie-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    class Node{\\n        public:\\n        Node* links[26]={NULL};\\n        string flag;\\n        void put(char ch,Node* node){\\n            links[ch-\\'a\\']=node;\\n        }\\n        Node* next(char ch){\\n            return links[ch-\\'a\\'];\\n        }\\n        void set(string w){\\n            flag=w;\\n        }\\n        int isEnd(){\\n            return flag.length();\\n        }\\n    };\\n    int dr[4] = {1, -1, 0, 0}; \\n    int dc[4] = {0, 0, -1, 1}; \\n    int n,m;\\n    void dfs(int r, int c, vector<vector<char>>& grid, Node *trie, vector<string>&ans) {\\n        if (r < 0 || r >= n || c < 0 || c >= m || grid[r][c]==\\'0\\' || trie->next(grid[r][c])==nullptr) return;\\n        char ch=grid[r][c];\\n        trie=trie->next(ch);\\n        if(trie->isEnd()){\\n            ans.push_back(trie->flag);\\n            trie->flag=\"\";\\n        }\\n        grid[r][c] = \\'0\\';\\n        for (int i = 0; i < 4; i++) { \\n            dfs(r + dr[i], c + dc[i],grid,trie,ans);\\n        }\\n        grid[r][c]=ch;\\n    }\\n    \\n    void insert(string s,Node *root){\\n        Node *node=root;\\n        for(int i=0;i<s.length();i++){\\n            if(node->links[s[i]-\\'a\\']==nullptr){\\n                node->put(s[i],new Node);\\n            }\\n            node=node->next(s[i]);\\n        }\\n        node->set(s);\\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        n=board.size();\\n        m=board[0].size();\\n        Node *trie=new Node();\\n        for(auto w:words){\\n            insert(w,trie);\\n        }\\n        vector<string>ans;\\n        for(int j=0;j<n;j++){\\n            for(int k=0;k<m;k++){\\n                    dfs(j,k,board,trie,ans);\\n                }\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    class Node{\\n        public:\\n        Node* links[26]={NULL};\\n        string flag;\\n        void put(char ch,Node* node){\\n            links[ch-\\'a\\']=node;\\n        }\\n        Node* next(char ch){\\n            return links[ch-\\'a\\'];\\n        }\\n        void set(string w){\\n            flag=w;\\n        }\\n        int isEnd(){\\n            return flag.length();\\n        }\\n    };\\n    int dr[4] = {1, -1, 0, 0}; \\n    int dc[4] = {0, 0, -1, 1}; \\n    int n,m;\\n    void dfs(int r, int c, vector<vector<char>>& grid, Node *trie, vector<string>&ans) {\\n        if (r < 0 || r >= n || c < 0 || c >= m || grid[r][c]==\\'0\\' || trie->next(grid[r][c])==nullptr) return;\\n        char ch=grid[r][c];\\n        trie=trie->next(ch);\\n        if(trie->isEnd()){\\n            ans.push_back(trie->flag);\\n            trie->flag=\"\";\\n        }\\n        grid[r][c] = \\'0\\';\\n        for (int i = 0; i < 4; i++) { \\n            dfs(r + dr[i], c + dc[i],grid,trie,ans);\\n        }\\n        grid[r][c]=ch;\\n    }\\n    \\n    void insert(string s,Node *root){\\n        Node *node=root;\\n        for(int i=0;i<s.length();i++){\\n            if(node->links[s[i]-\\'a\\']==nullptr){\\n                node->put(s[i],new Node);\\n            }\\n            node=node->next(s[i]);\\n        }\\n        node->set(s);\\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        n=board.size();\\n        m=board[0].size();\\n        Node *trie=new Node();\\n        for(auto w:words){\\n            insert(w,trie);\\n        }\\n        vector<string>ans;\\n        for(int j=0;j<n;j++){\\n            for(int k=0;k<m;k++){\\n                    dfs(j,k,board,trie,ans);\\n                }\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354804,
                "title": "c-trie-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<string> ans;\\n    int dx[4]={0,0,1,-1};\\n    int dy[4]={1,-1,0,0};\\n    \\n    class Trie {\\n        public:\\n            Trie *arr[26];\\n            bool isEnd = false;\\n    };\\n    \\n    void insert(string &word, Trie* root){\\n        Trie *cur = root;\\n        for(int i=0; i<word.size(); ++i){\\n            int idx = word[i]-\\'a\\';\\n            if(!cur->arr[idx]){\\n                cur->arr[idx] = new Trie();\\n            }\\n            cur=cur->arr[idx];\\n        }\\n        cur->isEnd = true;\\n        return;\\n    }\\n    \\n    bool isValid(vector<vector<char>>& board, int x, int y){\\n        int row = board.size(), col = board[0].size();\\n        if(x<0 || x>=row || y<0 || y>=col || board[x][y]==\\'*\\') return false;\\n        return true;\\n    }\\n    \\n    void search(vector<vector<char>>& board, int x, int y, Trie* root, string& str){\\n        if(board[x][y]==\\'*\\') return;\\n        \\n        int idx = board[x][y]-\\'a\\';\\n        if(!root->arr[idx]) return;\\n        \\n        str.push_back(board[x][y]);\\n        \\n        char ch = board[x][y];\\n        board[x][y]=\\'*\\';\\n        \\n        if(root->arr[idx]->isEnd){\\n            ans.push_back(str);\\n            root->arr[idx]->isEnd = false;\\n        }\\n        \\n        for(int i=0;i<4;++i){\\n            int x1 = x+dx[i], y1 = y+dy[i];\\n            if(isValid(board,x1,y1)) search(board,x1,y1,root->arr[idx],str);\\n        }\\n        \\n        board[x][y]=ch;\\n        str.pop_back();\\n        return;\\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        Trie *root = new Trie();\\n        for(auto &word : words) insert(word,root);\\n        \\n        int row = board.size(), col = board[0].size();\\n        string str=\"\";\\n        for(int i=0;i<row;++i){\\n            for(int j=0;j<col;++j){\\n                search(board,i,j,root,str);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<string> ans;\\n    int dx[4]={0,0,1,-1};\\n    int dy[4]={1,-1,0,0};\\n    \\n    class Trie {\\n        public:\\n            Trie *arr[26];\\n            bool isEnd = false;\\n    };\\n    \\n    void insert(string &word, Trie* root){\\n        Trie *cur = root;\\n        for(int i=0; i<word.size(); ++i){\\n            int idx = word[i]-\\'a\\';\\n            if(!cur->arr[idx]){\\n                cur->arr[idx] = new Trie();\\n            }\\n            cur=cur->arr[idx];\\n        }\\n        cur->isEnd = true;\\n        return;\\n    }\\n    \\n    bool isValid(vector<vector<char>>& board, int x, int y){\\n        int row = board.size(), col = board[0].size();\\n        if(x<0 || x>=row || y<0 || y>=col || board[x][y]==\\'*\\') return false;\\n        return true;\\n    }\\n    \\n    void search(vector<vector<char>>& board, int x, int y, Trie* root, string& str){\\n        if(board[x][y]==\\'*\\') return;\\n        \\n        int idx = board[x][y]-\\'a\\';\\n        if(!root->arr[idx]) return;\\n        \\n        str.push_back(board[x][y]);\\n        \\n        char ch = board[x][y];\\n        board[x][y]=\\'*\\';\\n        \\n        if(root->arr[idx]->isEnd){\\n            ans.push_back(str);\\n            root->arr[idx]->isEnd = false;\\n        }\\n        \\n        for(int i=0;i<4;++i){\\n            int x1 = x+dx[i], y1 = y+dy[i];\\n            if(isValid(board,x1,y1)) search(board,x1,y1,root->arr[idx],str);\\n        }\\n        \\n        board[x][y]=ch;\\n        str.pop_back();\\n        return;\\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        Trie *root = new Trie();\\n        for(auto &word : words) insert(word,root);\\n        \\n        int row = board.size(), col = board[0].size();\\n        string str=\"\";\\n        for(int i=0;i<row;++i){\\n            for(int j=0;j<col;++j){\\n                search(board,i,j,root,str);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 308130,
                "title": "python-trie-and-ordereddict-less-memory-and-not-modifying-the-original-board",
                "content": "In order to avoid reusing the same letters more than once, some solutions temporary modify the array: https://leetcode.com/problems/word-search-ii/discuss/59790/Python-dfs-solution-(directly-use-Trie-implemented).\\n\\nOther solutions keep track of the visited letters in a matrix.\\nhttps://leetcode.com/problems/word-search-ii/discuss/59864/Python-code-use-trie-and-dfs-380ms\\n\\nI simply used an OrderedDict to keep track of the visited letters (and to create the final path for the word):\\n```\\nfrom collections import OrderedDict, defaultdict\\n\\nclass TrieNode:\\n    \\n    def __init__(self):\\n        self.children = defaultdict(TrieNode)\\n        self.isEnd = False\\n\\n    def addWord(self, word):\\n        if not word:\\n            self.isEnd = True\\n            return\\n        self.children[word[0]].addWord(word[1:])\\n\\nclass Solution:\\n\\n    def findWords(self, board, words):\\n        self.root = TrieNode(); self.found = set(); self.R = len(board); self.C = len(board[0])\\n        \\n        for word in words:\\n            self.root.addWord(word)\\n\\n        for r in range(self.R):\\n            for c in range(self.C):\\n                self.traverse(board, r, c, self.root, OrderedDict())\\n        return list(self.found)\\n\\n    def traverse(self, board, r, c, trieNode, visited):\\n        \\n        if trieNode.isEnd:\\n            self.found.add(\\'\\'.join(visited.values()))\\n\\n        if r < 0 or c < 0 or r >= self.R or c >= self.C or board[r][c] not in trieNode.children or (r,c) in visited:\\n            return\\n        \\n        visited[(r,c)] = board[r][c]\\n        self.traverse(board, r + 1, c, trieNode.children[board[r][c]], visited)\\n        self.traverse(board, r - 1, c, trieNode.children[board[r][c]], visited)\\n        self.traverse(board, r, c - 1, trieNode.children[board[r][c]], visited)\\n        self.traverse(board, r, c + 1, trieNode.children[board[r][c]], visited)\\n        del visited[(r,c)]\\n```",
                "solutionTags": [
                    "Python",
                    "Trie"
                ],
                "code": "```\\nfrom collections import OrderedDict, defaultdict\\n\\nclass TrieNode:\\n    \\n    def __init__(self):\\n        self.children = defaultdict(TrieNode)\\n        self.isEnd = False\\n\\n    def addWord(self, word):\\n        if not word:\\n            self.isEnd = True\\n            return\\n        self.children[word[0]].addWord(word[1:])\\n\\nclass Solution:\\n\\n    def findWords(self, board, words):\\n        self.root = TrieNode(); self.found = set(); self.R = len(board); self.C = len(board[0])\\n        \\n        for word in words:\\n            self.root.addWord(word)\\n\\n        for r in range(self.R):\\n            for c in range(self.C):\\n                self.traverse(board, r, c, self.root, OrderedDict())\\n        return list(self.found)\\n\\n    def traverse(self, board, r, c, trieNode, visited):\\n        \\n        if trieNode.isEnd:\\n            self.found.add(\\'\\'.join(visited.values()))\\n\\n        if r < 0 or c < 0 or r >= self.R or c >= self.C or board[r][c] not in trieNode.children or (r,c) in visited:\\n            return\\n        \\n        visited[(r,c)] = board[r][c]\\n        self.traverse(board, r + 1, c, trieNode.children[board[r][c]], visited)\\n        self.traverse(board, r - 1, c, trieNode.children[board[r][c]], visited)\\n        self.traverse(board, r, c - 1, trieNode.children[board[r][c]], visited)\\n        self.traverse(board, r, c + 1, trieNode.children[board[r][c]], visited)\\n        del visited[(r,c)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 265145,
                "title": "swift-solution-with-dfs-trie",
                "content": "> 37 / 37 test cases passed.\\n> **Status**: Accepted\\n> **Runtime**: 404 ms\\n> **Memory Usage**: 25.5 MB\\n\\n```swift\\nclass Solution {\\n    class TrieNode {\\n        var word: String?\\n        var children = [Character: TrieNode]()\\n    }\\n\\n    func findWords(_ board: [[Character]], _ words: [String]) -> [String] {\\n        let trieRoot = buildTrie(words)\\n\\n        var board = board\\n        var result = Set<String>()\\n        for i in 0..<board.count {\\n            for j in 0..<board[i].count {\\n                dfs(&board, i, j, trieRoot, &result)\\n            }\\n        }\\n        \\n        return Array(result)\\n    }\\n    \\n    func dfs(_ board: inout [[Character]], _ i: Int, _ j: Int, _ trieNode: TrieNode, _ result: inout Set<String>) {\\n        if let word = trieNode.word {\\n            result.insert(word)\\n        }\\n        \\n        guard i >= 0 && j >= 0 && i < board.count && j < board[i].count else { return }\\n        guard board[i][j] != \"#\" else { return }\\n        \\n        let char = board[i][j]\\n        guard let nextTrieNode = trieNode.children[char] else { return }\\n        \\n        var board = board\\n        board[i][j] = \"#\"\\n        for (nexti, nextj) in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)] {\\n            dfs(&board, nexti, nextj, nextTrieNode, &result)\\n        }\\n        board[i][j] = char\\n    }\\n    \\n    func buildTrie(_ words: [String]) -> TrieNode {\\n        let root = TrieNode()\\n        for word in words {\\n            var node = root\\n            for char in word {\\n                if node.children[char] == nil {\\n                    node.children[char] = TrieNode()\\n                }\\n                node = node.children[char]!\\n            }\\n            node.word = word\\n        }\\n        return root\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nclass Solution {\\n    class TrieNode {\\n        var word: String?\\n        var children = [Character: TrieNode]()\\n    }\\n\\n    func findWords(_ board: [[Character]], _ words: [String]) -> [String] {\\n        let trieRoot = buildTrie(words)\\n\\n        var board = board\\n        var result = Set<String>()\\n        for i in 0..<board.count {\\n            for j in 0..<board[i].count {\\n                dfs(&board, i, j, trieRoot, &result)\\n            }\\n        }\\n        \\n        return Array(result)\\n    }\\n    \\n    func dfs(_ board: inout [[Character]], _ i: Int, _ j: Int, _ trieNode: TrieNode, _ result: inout Set<String>) {\\n        if let word = trieNode.word {\\n            result.insert(word)\\n        }\\n        \\n        guard i >= 0 && j >= 0 && i < board.count && j < board[i].count else { return }\\n        guard board[i][j] != \"#\" else { return }\\n        \\n        let char = board[i][j]\\n        guard let nextTrieNode = trieNode.children[char] else { return }\\n        \\n        var board = board\\n        board[i][j] = \"#\"\\n        for (nexti, nextj) in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)] {\\n            dfs(&board, nexti, nextj, nextTrieNode, &result)\\n        }\\n        board[i][j] = char\\n    }\\n    \\n    func buildTrie(_ words: [String]) -> TrieNode {\\n        let root = TrieNode()\\n        for word in words {\\n            var node = root\\n            for char in word {\\n                if node.children[char] == nil {\\n                    node.children[char] = TrieNode()\\n                }\\n                node = node.children[char]!\\n            }\\n            node.word = word\\n        }\\n        return root\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 227044,
                "title": "c-trie",
                "content": "This is a combination of [Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/) and [Word Search](https://leetcode.com/problems/word-search/). To remove duplicates in the result, a word is marked as a non-word after it has been added to the result. Also once the size of the result is not smaller than that of the dictionary, we return early.\\n\\n```cpp\\nclass TrieNode {\\npublic:\\n    bool word;\\n    TrieNode* children[26];\\n    TrieNode() : word(false) {\\n        memset(children, 0, sizeof(children));\\n    }\\n};\\n\\nclass Trie {\\npublic:\\n    Trie() {}\\n    \\n    void add(string word) {\\n        TrieNode* node = root;\\n        for (char c : word) {\\n            if (!node -> children[c - \\'a\\']) {\\n                node -> children[c - \\'a\\'] = new TrieNode();\\n            }\\n            node = node -> children[c - \\'a\\'];\\n        }\\n        node -> word = true;\\n    }\\n    \\n    bool search(string word) {\\n        TrieNode* node = leaf(word);\\n        if (node && node -> word) {\\n            node -> word = false;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool startsWith(string word) {\\n        return leaf(word);\\n    }\\nprivate:\\n    TrieNode* root = new TrieNode();\\n    \\n    TrieNode* leaf(string word) {\\n        TrieNode* node = root;\\n        for (int i = 0; i < word.size() && node; i++) {\\n            node = node -> children[word[i] - \\'a\\'];\\n        }\\n        return node;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        Trie trie = Trie();\\n        for (string word : words) {\\n            trie.add(word);\\n        }\\n        int m = board.size(), n = m ? board[0].size() : 0;\\n        vector<string> ans;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                find(trie, board, ans, \"\", i, j);\\n                if (ans.size() >= words.size()) {\\n                    return ans;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\nprivate:\\n    void find(Trie& trie, vector<vector<char>>& board, vector<string>& ans, string word, int i, int j) {\\n        int m = board.size(), n = board[0].size();\\n        if (i >= 0 && i < m && j >= 0 && j < n && board[i][j]) {\\n            word += board[i][j];\\n            if (!trie.startsWith(word)) {\\n                return;\\n            }\\n            if (trie.search(word)) {\\n                ans.push_back(word);\\n            }\\n            board[i][j] = 0;\\n            find(trie, board, ans, word, i - 1, j);\\n            find(trie, board, ans, word, i + 1, j);\\n            find(trie, board, ans, word, i, j - 1);\\n            find(trie, board, ans, word, i, j + 1);\\n            board[i][j] = word.back();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```cpp\\nclass TrieNode {\\npublic:\\n    bool word;\\n    TrieNode* children[26];\\n    TrieNode() : word(false) {\\n        memset(children, 0, sizeof(children));\\n    }\\n};\\n\\nclass Trie {\\npublic:\\n    Trie() {}\\n    \\n    void add(string word) {\\n        TrieNode* node = root;\\n        for (char c : word) {\\n            if (!node -> children[c - \\'a\\']) {\\n                node -> children[c - \\'a\\'] = new TrieNode();\\n            }\\n            node = node -> children[c - \\'a\\'];\\n        }\\n        node -> word = true;\\n    }\\n    \\n    bool search(string word) {\\n        TrieNode* node = leaf(word);\\n        if (node && node -> word) {\\n            node -> word = false;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool startsWith(string word) {\\n        return leaf(word);\\n    }\\nprivate:\\n    TrieNode* root = new TrieNode();\\n    \\n    TrieNode* leaf(string word) {\\n        TrieNode* node = root;\\n        for (int i = 0; i < word.size() && node; i++) {\\n            node = node -> children[word[i] - \\'a\\'];\\n        }\\n        return node;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        Trie trie = Trie();\\n        for (string word : words) {\\n            trie.add(word);\\n        }\\n        int m = board.size(), n = m ? board[0].size() : 0;\\n        vector<string> ans;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                find(trie, board, ans, \"\", i, j);\\n                if (ans.size() >= words.size()) {\\n                    return ans;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\nprivate:\\n    void find(Trie& trie, vector<vector<char>>& board, vector<string>& ans, string word, int i, int j) {\\n        int m = board.size(), n = board[0].size();\\n        if (i >= 0 && i < m && j >= 0 && j < n && board[i][j]) {\\n            word += board[i][j];\\n            if (!trie.startsWith(word)) {\\n                return;\\n            }\\n            if (trie.search(word)) {\\n                ans.push_back(word);\\n            }\\n            board[i][j] = 0;\\n            find(trie, board, ans, word, i - 1, j);\\n            find(trie, board, ans, word, i + 1, j);\\n            find(trie, board, ans, word, i, j - 1);\\n            find(trie, board, ans, word, i, j + 1);\\n            board[i][j] = word.back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59905,
                "title": "python-ac-solution",
                "content": "    class TrieNode:\\n    def __init__(self):\\n        self.children = collections.defaultdict(TrieNode)\\n        self.flag = False\\n\\n    class Solution:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        self.result = []\\n\\n    def insert(self, word):\\n        node = self.root\\n        for letter in word:\\n            node = node.children[letter]\\n        node.flag = True\\n\\n    def findWords(self, board, words):\\n        for w in words:\\n            self.insert(w)\\n        for j in range(len(board)):\\n            for i in range(len(board[0])):\\n                self.dfs(self.root, board, j, i)\\n        return self.result\\n\\n    def dfs(self, node, board, j, i, word=''):\\n        if node.flag:\\n            self.result.append(word)\\n            node.flag = False\\n        if 0 <= j < len(board) and 0 <= i < len(board[0]):\\n            char = board[j][i]\\n            child = node.children.get(char)\\n            if child is not None:\\n                word += char\\n                board[j][i] = None\\n                self.dfs(child, board, j + 1, i, word)\\n                self.dfs(child, board, j - 1, i, word)\\n                self.dfs(child, board, j, i + 1, word)\\n                self.dfs(child, board, j, i - 1, word)\\n                board[j][i] = char",
                "solutionTags": [],
                "code": "    class TrieNode:\\n    def __init__(self):\\n        self.children = collections.defaultdict(TrieNode)\\n        self.flag = False\\n\\n    class Solution:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        self.result = []\\n\\n    def insert(self, word):\\n        node = self.root\\n        for letter in word:\\n            node = node.children[letter]\\n        node.flag = True\\n\\n    def findWords(self, board, words):\\n        for w in words:\\n            self.insert(w)\\n        for j in range(len(board)):\\n            for i in range(len(board[0])):\\n                self.dfs(self.root, board, j, i)\\n        return self.result\\n\\n    def dfs(self, node, board, j, i, word=''):\\n        if node.flag:\\n            self.result.append(word)\\n            node.flag = False\\n        if 0 <= j < len(board) and 0 <= i < len(board[0]):\\n            char = board[j][i]\\n            child = node.children.get(char)\\n            if child is not None:\\n                word += char\\n                board[j][i] = None\\n                self.dfs(child, board, j + 1, i, word)\\n                self.dfs(child, board, j - 1, i, word)\\n                self.dfs(child, board, j, i + 1, word)\\n                self.dfs(child, board, j, i - 1, word)\\n                board[j][i] = char",
                "codeTag": "Java"
            },
            {
                "id": 2781724,
                "title": "c-clean-code-dfs-trie",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApply dfs from every cell to find a path that correspond to a string and use trie to check if it is a required string.\\n\\n# Code\\n```\\nclass Solution {\\n    struct trie {\\n        trie *child[26];\\n        bool isEnd;\\n        trie() {\\n            for(int i = 0; i < 26; i++) child[i] = NULL;\\n            isEnd = false;\\n        }\\n    };\\n    trie *root = new trie();\\n    void insert(string s) {\\n        trie *curr = root;\\n        for(int i = 0; i < s.size(); i++) {\\n            int id = s[i] - \\'a\\';\\n            if(curr->child[id] == NULL) curr->child[id] = new trie();\\n            curr = curr->child[id];\\n        }\\n        curr->isEnd = true;\\n    }\\n    vector<vector<char>> board; int n, m; vector<vector<bool>> vis; vector<string> ans;\\n    string str;\\n    void dfs(trie *curr, int y, int x) {\\n        if(curr->isEnd) {\\n            ans.push_back(str);\\n            curr->isEnd = false;\\n        }\\n        if(y < 0 || y >= n || x < 0 || x >= m || vis[y][x]) return;\\n        int id = board[y][x] - \\'a\\';\\n        if(curr->child[id] == NULL) return;\\n        vis[y][x] = true;\\n        str.push_back(board[y][x]);\\n        dfs(curr->child[id], y + 1, x);\\n        dfs(curr->child[id], y - 1, x);\\n        dfs(curr->child[id], y, x + 1);\\n        dfs(curr->child[id], y, x - 1);\\n        str.pop_back();\\n        vis[y][x] = false;\\n    }\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        for (auto &word: words) insert(word);\\n        this->board = board; n = board.size(); m = board[0].size();\\n        vis.resize(n, vector<bool>(m, false));\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                dfs(root, i, j);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    struct trie {\\n        trie *child[26];\\n        bool isEnd;\\n        trie() {\\n            for(int i = 0; i < 26; i++) child[i] = NULL;\\n            isEnd = false;\\n        }\\n    };\\n    trie *root = new trie();\\n    void insert(string s) {\\n        trie *curr = root;\\n        for(int i = 0; i < s.size(); i++) {\\n            int id = s[i] - \\'a\\';\\n            if(curr->child[id] == NULL) curr->child[id] = new trie();\\n            curr = curr->child[id];\\n        }\\n        curr->isEnd = true;\\n    }\\n    vector<vector<char>> board; int n, m; vector<vector<bool>> vis; vector<string> ans;\\n    string str;\\n    void dfs(trie *curr, int y, int x) {\\n        if(curr->isEnd) {\\n            ans.push_back(str);\\n            curr->isEnd = false;\\n        }\\n        if(y < 0 || y >= n || x < 0 || x >= m || vis[y][x]) return;\\n        int id = board[y][x] - \\'a\\';\\n        if(curr->child[id] == NULL) return;\\n        vis[y][x] = true;\\n        str.push_back(board[y][x]);\\n        dfs(curr->child[id], y + 1, x);\\n        dfs(curr->child[id], y - 1, x);\\n        dfs(curr->child[id], y, x + 1);\\n        dfs(curr->child[id], y, x - 1);\\n        str.pop_back();\\n        vis[y][x] = false;\\n    }\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        for (auto &word: words) insert(word);\\n        this->board = board; n = board.size(); m = board[0].size();\\n        vis.resize(n, vector<bool>(m, false));\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                dfs(root, i, j);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2781438,
                "title": "don-t-know-trie-c-dfs-hashmap",
                "content": "<b>Main Idea:</b>\\nAt first store all the prefixes of  all the words in a hashmap. Now run a dfs from each cell and try to construct string that can be found in the hashmap.\\nAfter running dfs from all cells check if the given words was construced during dfs.\\n<b>Sample Code:</b>\\n```\\nclass Solution {\\nprivate:\\n    vector<vector<int>>vis;//mark the cell during dfs\\n    unordered_map<string,bool>found;//strings found during dfs\\n    unordered_map<string,bool>can;// prefixes of all the words\\n    int n,m;\\n\\tconst int fx[4]={0,0,1,-1};\\n    const int fy[4]={1,-1,0,0};\\npublic:\\n    void dfs(int x,int y,vector<vector<char>>& board,string &s){\\n        if(can.find(s)==can.end())return;// return if the string is invalid\\n        if(s.size()==10)return; // words length won\\'t be greater than 10. so we can just return.\\n        s+=board[x][y];\\n        found[s] = 1;\\n        vis[x][y] = 1;\\n        for(int i=0;i<4;i++){\\n            int dx = x+fx[i];\\n            int dy = y+fy[i];\\n            if(dx>=0 && dx<n && dy>=0 && dy<m){\\n                if(!vis[dx][dy]){\\n                    dfs(dx,dy,board,s);\\n                }\\n            }\\n        }\\n        s.pop_back();\\n        vis[x][y] = 0;\\n        return ;\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        n = board.size();\\n        m = board[0].size();\\n        vector<pair<int,int>>pos[26];\\n        can[\"\"]=true;\\n        for(auto&s:words){\\n            string ts;\\n            for(auto&c:s){\\n                ts+=c;\\n                can[ts] = 1;\\n            }\\n        }\\n        vis.resize(n,vector<int>(m));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                string s;\\n                dfs(i,j,board,s);\\n            }\\n        }\\n        vector<string>ans;\\n        for(auto&s:words){\\n          if(found[s])ans.push_back(s);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<vector<int>>vis;//mark the cell during dfs\\n    unordered_map<string,bool>found;//strings found during dfs\\n    unordered_map<string,bool>can;// prefixes of all the words\\n    int n,m;\\n\\tconst int fx[4]={0,0,1,-1};\\n    const int fy[4]={1,-1,0,0};\\npublic:\\n    void dfs(int x,int y,vector<vector<char>>& board,string &s){\\n        if(can.find(s)==can.end())return;// return if the string is invalid\\n        if(s.size()==10)return; // words length won\\'t be greater than 10. so we can just return.\\n        s+=board[x][y];\\n        found[s] = 1;\\n        vis[x][y] = 1;\\n        for(int i=0;i<4;i++){\\n            int dx = x+fx[i];\\n            int dy = y+fy[i];\\n            if(dx>=0 && dx<n && dy>=0 && dy<m){\\n                if(!vis[dx][dy]){\\n                    dfs(dx,dy,board,s);\\n                }\\n            }\\n        }\\n        s.pop_back();\\n        vis[x][y] = 0;\\n        return ;\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        n = board.size();\\n        m = board[0].size();\\n        vector<pair<int,int>>pos[26];\\n        can[\"\"]=true;\\n        for(auto&s:words){\\n            string ts;\\n            for(auto&c:s){\\n                ts+=c;\\n                can[ts] = 1;\\n            }\\n        }\\n        vis.resize(n,vector<int>(m));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                string s;\\n                dfs(i,j,board,s);\\n            }\\n        }\\n        vector<string>ans;\\n        for(auto&s:words){\\n          if(found[s])ans.push_back(s);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780879,
                "title": "my-solution-thought-process-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst idea, is simply looping over every word and use the solution found for [Word Search I](https://leetcode.com/problems/word-search/description/).\\nAs expected, TLE...\\n\\nUsing trie is helpful. Because let\\'s say we have a word AAAA and a second word AAAAB, by doing two separate DFS, we have to go over the same prefix \\'AAAA\\' twice. When it gets longer, we waste a lot of time. The trie structure solve this problem, AAAAB is basically AAAA + B in here, and we can do a single branching till the very end and not stopping at the last A. (although marking it as the end of a word)\\n\\nNow that we have constructed the trie, we can build our branching algo that goes throw the trie. DFS for example.\\nHowever doing it naively still gives TLE. (63/64 :d)\\nSay given a trie node \\'a\\', it has the following child nodes: [\\'b\\', \\'c\\']. But we already found the word \\'ab\\' to be valid. If we keep \\'b\\' in the list, everytime we see a \\'b\\', we will explore it again. Basically we are searching on all the child nodes, including the ones that we\\'ve already found a solution, which is again a waste.\\nThe trick is to remove those nodes from the child list if they are finished (namely we already found a solution for it.) We can do that because we know the words are unique. For that, we can use the return value, which is bottom-up.\\n\\nSo below is the final solution:\\n\\n# Code\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.childs = {}\\n        self.end = False\\n\\n\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        m, n = len(board), len(board[0])\\n\\n        ### construct trie\\n        self.trie_root = TrieNode()\\n        for word in words:\\n            cur = self.trie_root\\n            for char in word:\\n                if char not in cur.childs:\\n                    cur.childs[char] = TrieNode()\\n                cur = cur.childs[char]\\n            cur.end = True\\n\\n\\n        ### dfs branching algo\\n        def dfs(r, c, node, path):\\n            nonlocal m, n, out\\n            if node.end:\\n                out.add(path)\\n                if len(node.childs) == 0:\\n                    return True  # i.e. we have completed the whole branch (word end at leaf)\\n            \\n            if len(node.childs) > 0:\\n                for rr, cc in [(r-1, c), (r+1, c), (r, c+1), (r, c-1)]:\\n                    if rr >= 0 and rr < m and cc >= 0 and cc < n:\\n                        letter = board[rr][cc]\\n                        if (rr, cc) not in seen and letter in node.childs:\\n                            seen.add((rr, cc))\\n                            done = dfs(rr, cc, node.childs[letter], path+letter)\\n                            if done:  # if the branch is completed, throw it away !\\n                                node.childs.pop(letter)\\n                            seen.remove((rr, cc))  # backtrack\\n            \\n            return len(node.childs)==0  # keep the branch only if not empty (this will backprop to top nodes)\\n            # by structure, a leaf node can only be either a word end, or a branch we started popping already.\\n\\n\\n        ### main\\n        out = set()  # use set to avoid duplicates\\n        for r in range(m):\\n            for c in range(n):\\n                letter = board[r][c]\\n                if letter in self.trie_root.childs:\\n                    seen = set([(r, c)])\\n                    dfs(r, c, self.trie_root.childs[letter], letter)\\n\\n        return list(out)\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.childs = {}\\n        self.end = False\\n\\n\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        m, n = len(board), len(board[0])\\n\\n        ### construct trie\\n        self.trie_root = TrieNode()\\n        for word in words:\\n            cur = self.trie_root\\n            for char in word:\\n                if char not in cur.childs:\\n                    cur.childs[char] = TrieNode()\\n                cur = cur.childs[char]\\n            cur.end = True\\n\\n\\n        ### dfs branching algo\\n        def dfs(r, c, node, path):\\n            nonlocal m, n, out\\n            if node.end:\\n                out.add(path)\\n                if len(node.childs) == 0:\\n                    return True  # i.e. we have completed the whole branch (word end at leaf)\\n            \\n            if len(node.childs) > 0:\\n                for rr, cc in [(r-1, c), (r+1, c), (r, c+1), (r, c-1)]:\\n                    if rr >= 0 and rr < m and cc >= 0 and cc < n:\\n                        letter = board[rr][cc]\\n                        if (rr, cc) not in seen and letter in node.childs:\\n                            seen.add((rr, cc))\\n                            done = dfs(rr, cc, node.childs[letter], path+letter)\\n                            if done:  # if the branch is completed, throw it away !\\n                                node.childs.pop(letter)\\n                            seen.remove((rr, cc))  # backtrack\\n            \\n            return len(node.childs)==0  # keep the branch only if not empty (this will backprop to top nodes)\\n            # by structure, a leaf node can only be either a word end, or a branch we started popping already.\\n\\n\\n        ### main\\n        out = set()  # use set to avoid duplicates\\n        for r in range(m):\\n            for c in range(n):\\n                letter = board[r][c]\\n                if letter in self.trie_root.childs:\\n                    seen = set([(r, c)])\\n                    dfs(r, c, self.trie_root.childs[letter], letter)\\n\\n        return list(out)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779728,
                "title": "java-kotlin-clear-trie-back-tracking-solution",
                "content": "Java\\n```\\nclass Solution {\\n    private TrieNode root = new TrieNode();\\n    private int m = 0;\\n    private int n = 0;\\n    private Set<String> set = new HashSet<>();\\n    private int[] dir = new int[] {1, 0, -1, 0, 1};\\n    \\n    public List<String> findWords(char[][] board, String[] words) {\\n        for (String w : words) {\\n            insert(w);\\n        }\\n        m = board.length;\\n        n = board[0].length;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                bt(i, j, board, new boolean[m][n], root);\\n            }\\n        }\\n        \\n        return new ArrayList<String>(set);\\n    }\\n    \\n    private void bt(int x, int y, char[][] board, boolean[][] visited, TrieNode node) {\\n        if (x < 0 || x >= m || y < 0 || y >= n || visited[x][y]) {\\n            return;\\n        }\\n        \\n        int idx = board[x][y] - \\'a\\';\\n        if (node.children[idx] == null) {\\n            return;\\n        }\\n        \\n        if (node.children[idx].w != null) {\\n            set.add(node.children[idx].w); // Notice: do not return. cause there may have a longer word!\\n        }\\n        \\n        visited[x][y] = true;\\n        \\n        for (int i = 0; i < dir.length-1; i++) {\\n            bt(x+dir[i], y + dir[i+1], board, visited, node.children[idx]);\\n        }\\n        \\n        visited[x][y] = false;\\n    }\\n    \\n    private void insert(String w) {\\n        TrieNode node = root;\\n        for (char ch : w.toCharArray()) {\\n            int idx = ch - \\'a\\';\\n            if (node.children[idx] == null) {\\n                node.children[idx] = new TrieNode();\\n            }\\n            node = node.children[idx];\\n        }\\n        \\n        node.w = w;\\n    }\\n}\\n\\nclass TrieNode {\\n    TrieNode[] children = new TrieNode[26];\\n    String w;\\n}\\n```\\nKotlin\\n```\\nclass Solution {\\n    fun findWords(board: Array<CharArray>, words: Array<String>): List<String> {\\n        val m = board.size\\n        val n = board[0].size\\n        \\n        val dir = intArrayOf(1, 0, -1, 0, 1)\\n        \\n        val root = TrieNode()\\n        val res = mutableListOf<String>()\\n        \\n        fun insert(w: String) {\\n            var node = root\\n            for (ch in w.toCharArray()) {\\n                node = node.children.getOrPut(ch) { TrieNode() }\\n            }\\n            node.w = w\\n        }\\n        \\n        for (w in words) {\\n            insert(w)\\n        }\\n        \\n        fun bt(x: Int, y: Int, board: Array<CharArray>, visited: Array<BooleanArray>, node: TrieNode) {\\n            if (x < 0 || x >= m || y < 0 || y >= n || visited[x][y]) return\\n            \\n            val next = node.children.get(board[x][y])\\n            \\n            next ?: return\\n            \\n            next.w?.let {\\n                res.add(it)\\n                next.w = null\\n            }\\n            \\n            visited[x][y] = true\\n            for (i in 0 until dir.size-1) {\\n                bt(x + dir[i], y + dir[i+1], board, visited, next)\\n            }\\n            visited[x][y] = false\\n        }\\n        \\n        for (i in 0 until m) {\\n            for (j in 0 until n) {\\n                bt(i, j, board, Array(m) { BooleanArray(n) }, root)\\n            }\\n        }\\n        \\n        return res\\n    }\\n}\\n\\nclass TrieNode {\\n    val children = mutableMapOf<Char, TrieNode>()\\n    var w: String? = null\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Kotlin",
                    "Backtracking",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    private TrieNode root = new TrieNode();\\n    private int m = 0;\\n    private int n = 0;\\n    private Set<String> set = new HashSet<>();\\n    private int[] dir = new int[] {1, 0, -1, 0, 1};\\n    \\n    public List<String> findWords(char[][] board, String[] words) {\\n        for (String w : words) {\\n            insert(w);\\n        }\\n        m = board.length;\\n        n = board[0].length;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                bt(i, j, board, new boolean[m][n], root);\\n            }\\n        }\\n        \\n        return new ArrayList<String>(set);\\n    }\\n    \\n    private void bt(int x, int y, char[][] board, boolean[][] visited, TrieNode node) {\\n        if (x < 0 || x >= m || y < 0 || y >= n || visited[x][y]) {\\n            return;\\n        }\\n        \\n        int idx = board[x][y] - \\'a\\';\\n        if (node.children[idx] == null) {\\n            return;\\n        }\\n        \\n        if (node.children[idx].w != null) {\\n            set.add(node.children[idx].w); // Notice: do not return. cause there may have a longer word!\\n        }\\n        \\n        visited[x][y] = true;\\n        \\n        for (int i = 0; i < dir.length-1; i++) {\\n            bt(x+dir[i], y + dir[i+1], board, visited, node.children[idx]);\\n        }\\n        \\n        visited[x][y] = false;\\n    }\\n    \\n    private void insert(String w) {\\n        TrieNode node = root;\\n        for (char ch : w.toCharArray()) {\\n            int idx = ch - \\'a\\';\\n            if (node.children[idx] == null) {\\n                node.children[idx] = new TrieNode();\\n            }\\n            node = node.children[idx];\\n        }\\n        \\n        node.w = w;\\n    }\\n}\\n\\nclass TrieNode {\\n    TrieNode[] children = new TrieNode[26];\\n    String w;\\n}\\n```\n```\\nclass Solution {\\n    fun findWords(board: Array<CharArray>, words: Array<String>): List<String> {\\n        val m = board.size\\n        val n = board[0].size\\n        \\n        val dir = intArrayOf(1, 0, -1, 0, 1)\\n        \\n        val root = TrieNode()\\n        val res = mutableListOf<String>()\\n        \\n        fun insert(w: String) {\\n            var node = root\\n            for (ch in w.toCharArray()) {\\n                node = node.children.getOrPut(ch) { TrieNode() }\\n            }\\n            node.w = w\\n        }\\n        \\n        for (w in words) {\\n            insert(w)\\n        }\\n        \\n        fun bt(x: Int, y: Int, board: Array<CharArray>, visited: Array<BooleanArray>, node: TrieNode) {\\n            if (x < 0 || x >= m || y < 0 || y >= n || visited[x][y]) return\\n            \\n            val next = node.children.get(board[x][y])\\n            \\n            next ?: return\\n            \\n            next.w?.let {\\n                res.add(it)\\n                next.w = null\\n            }\\n            \\n            visited[x][y] = true\\n            for (i in 0 until dir.size-1) {\\n                bt(x + dir[i], y + dir[i+1], board, visited, next)\\n            }\\n            visited[x][y] = false\\n        }\\n        \\n        for (i in 0 until m) {\\n            for (j in 0 until n) {\\n                bt(i, j, board, Array(m) { BooleanArray(n) }, root)\\n            }\\n        }\\n        \\n        return res\\n    }\\n}\\n\\nclass TrieNode {\\n    val children = mutableMapOf<Char, TrieNode>()\\n    var w: String? = null\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2072973,
                "title": "trie-in-simple-words",
                "content": "**hello guys,**\\nthis is very simple explanation about **trie**\\n\\nstart explaining from basic : \\n**Question link** : https://leetcode.com/problems/implement-trie-prefix-tree/\\n\\n**declare trie like this :**\\n```\\nclass Trie {\\n    public :\\n    bool end=false;\\n    Trie* children[27]={};\\n};\\n```\\n\\nimport trie to main class :\\n`Trie* node = new Trie();`\\n\\nuse this to declare as local trie node : \\n`Trie* cr=node;`\\n\\n**if you are already have Trie class then declare trie as :**\\n```\\nbool end=false;\\nTrie* children[27]={};\\n```\\n\\nand use as local node like this : \\n`Trie* node=this;`\\n\\n**insert a string to trie :**\\n```\\nfor(int i=0;i<s.size();++i)\\n{\\n    if(!node->children[s[i]-\\'a\\']) node->children[s[i]-\\'a\\']=new Trie();\\n    node=node->children[s[i]-\\'a\\'];\\n}\\nnode->end=true;\\n```\\n\\n**search string in trie :**\\n\\n        Trie* node=this;\\n        \\n        for(int i=0;i<s.size();++i)\\n        {\\n            if(!node->children[s[i]-\\'a\\']) return false;\\n            node=node->children[s[i]-\\'a\\'];\\n        }\\n        \\n        return node->end;\\n\\n\\n*this is enough for trie.\\nwe can do every question on trie by using just insertion and search part.\\nthere are some variations in different differetn questions.\\nso we can modify as required, but nothing will be new in modifiocation*.\\n\\n\\n**Solution for \"Word search ii\"**\\n**question link** : [https://leetcode.com/problems/word-search-ii/] \\n\\n1. insert all string to trie\\n2. start bfs from every cell of the matrix that if a[i][j] is availabe in trie or not, if a[i][j] is in trie then go for next unvisited cells, when cr->end==true in trie, it means we are at end position of string, that\\'s how we find a string in matrix.\\n\\n\\n**Code :**\\n\\n```\\n#define pb push_back\\nconst int N=14;\\n\\nclass Trie {\\n    public :\\n    bool end=false;\\n    Trie* children[27]={};\\n};\\n\\n\\nclass Solution {\\npublic:\\n    Trie* node = new Trie();\\n    \\n    vector<string>ans;\\n    set<string>st;\\n    int vis[N][N];\\n    void fun(Trie* cr, int i, int j, vector<vector<char>>&v, string s)\\n    {\\n        if(i<0 && j<0 && i>=v.size() || j>=v[0].size() || vis[i][j] || !cr->children[v[i][j]-\\'a\\']) return ;\\n        \\n        vis[i][j]=1;\\n        if(cr->children[v[i][j]-\\'a\\']) cr=cr->children[v[i][j]-\\'a\\'], s+=v[i][j];\\n        else return ;\\n        if(cr->end) st.insert(s);\\n        \\n        \\n        if(i+1<v.size() && cr->children[v[i+1][j]-\\'a\\']) fun(cr, i+1, j, v, s);\\n        if(j+1<v[0].size() && cr->children[v[i][j+1]-\\'a\\']) fun(cr, i, j+1, v, s);\\n        if(i-1>=0 && cr->children[v[i-1][j]-\\'a\\']) fun(cr, i-1, j, v, s);\\n        if(j-1>=0 && cr->children[v[i][j-1]-\\'a\\']) fun(cr, i, j-1, v, s);\\n        \\n        vis[i][j]=0;\\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& v, vector<string>& w) {\\n        \\n\\t\\t// make trie for all strings \\n        for(int i=0;i<w.size();++i)\\n        {\\n            string s=w[i];\\n            Trie* cr=node;\\n            for(auto c : s)\\n            {\\n                if(!cr->children[c-\\'a\\']) cr->children[c-\\'a\\']=new Trie();\\n                cr=cr->children[c-\\'a\\'];\\n            }\\n            cr->end=true;\\n        }\\n        \\n        memset(vis,0,sizeof(vis));\\n        for(int i=0;i<v.size();++i)\\n        {\\n            for(int j=0;j<v[0].size();++j)\\n            {\\n                Trie* cr=node;\\n                string s=\"\";\\n                fun(cr, i, j, v, s);\\n                \\n                if(st.size()==w.size()) break;\\n            }\\n        }\\n        \\n        for(auto it : st) ans.pb(it);\\n        return ans;\\n    }\\n};\\n```\\n\\n**Thanks...**\\n",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "```\\nclass Trie {\\n    public :\\n    bool end=false;\\n    Trie* children[27]={};\\n};\\n```\n```\\nbool end=false;\\nTrie* children[27]={};\\n```\n```\\nfor(int i=0;i<s.size();++i)\\n{\\n    if(!node->children[s[i]-\\'a\\']) node->children[s[i]-\\'a\\']=new Trie();\\n    node=node->children[s[i]-\\'a\\'];\\n}\\nnode->end=true;\\n```\n```\\n#define pb push_back\\nconst int N=14;\\n\\nclass Trie {\\n    public :\\n    bool end=false;\\n    Trie* children[27]={};\\n};\\n\\n\\nclass Solution {\\npublic:\\n    Trie* node = new Trie();\\n    \\n    vector<string>ans;\\n    set<string>st;\\n    int vis[N][N];\\n    void fun(Trie* cr, int i, int j, vector<vector<char>>&v, string s)\\n    {\\n        if(i<0 && j<0 && i>=v.size() || j>=v[0].size() || vis[i][j] || !cr->children[v[i][j]-\\'a\\']) return ;\\n        \\n        vis[i][j]=1;\\n        if(cr->children[v[i][j]-\\'a\\']) cr=cr->children[v[i][j]-\\'a\\'], s+=v[i][j];\\n        else return ;\\n        if(cr->end) st.insert(s);\\n        \\n        \\n        if(i+1<v.size() && cr->children[v[i+1][j]-\\'a\\']) fun(cr, i+1, j, v, s);\\n        if(j+1<v[0].size() && cr->children[v[i][j+1]-\\'a\\']) fun(cr, i, j+1, v, s);\\n        if(i-1>=0 && cr->children[v[i-1][j]-\\'a\\']) fun(cr, i-1, j, v, s);\\n        if(j-1>=0 && cr->children[v[i][j-1]-\\'a\\']) fun(cr, i, j-1, v, s);\\n        \\n        vis[i][j]=0;\\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& v, vector<string>& w) {\\n        \\n\\t\\t// make trie for all strings \\n        for(int i=0;i<w.size();++i)\\n        {\\n            string s=w[i];\\n            Trie* cr=node;\\n            for(auto c : s)\\n            {\\n                if(!cr->children[c-\\'a\\']) cr->children[c-\\'a\\']=new Trie();\\n                cr=cr->children[c-\\'a\\'];\\n            }\\n            cr->end=true;\\n        }\\n        \\n        memset(vis,0,sizeof(vis));\\n        for(int i=0;i<v.size();++i)\\n        {\\n            for(int j=0;j<v[0].size();++j)\\n            {\\n                Trie* cr=node;\\n                string s=\"\";\\n                fun(cr, i, j, v, s);\\n                \\n                if(st.size()==w.size()) break;\\n            }\\n        }\\n        \\n        for(auto it : st) ans.pb(it);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1511581,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<vector<char>> &board, string &word, int i, int j, int k, vector<vector<bool>> &visited) {\\n        if(k == word.length())\\n            return true;\\n        \\n        if(i<0 || i==board.size() || j<0 || j==board[0].size() || board[i][j] != word[k] || visited[i][j])\\n            return false;\\n        \\n        visited[i][j] = true;\\n        bool l = solve(board, word, i, j-1, k+1, visited);\\n        bool r = solve(board, word, i, j+1, k+1, visited);\\n        bool t = solve(board, word, i-1, j, k+1, visited);\\n        bool b = solve(board, word, i+1, j, k+1, visited);\\n        visited[i][j] = false;\\n        return l || r || t || b;\\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n                \\n        vector<vector<bool>>visited(board.size(), vector<bool>(board[0].size(), false));\\n        vector<string> res;\\n        \\n        for(auto &word : words) {\\n            int flag = 0;\\n            reverse(word.begin(), word.end());\\n            for (int i=0; i<board.size(); i++) {\\n                for (int j=0; j<board[0].size(); j++) { \\n                    if(solve(board, word, i, j, 0, visited)) {\\n                        flag=1; break;\\n                    }\\n                }\\n                if(flag) break;\\n            }\\n            if(flag) {\\n                reverse(word.begin(), word.end());\\n                res.push_back(word);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<vector<char>> &board, string &word, int i, int j, int k, vector<vector<bool>> &visited) {\\n        if(k == word.length())\\n            return true;\\n        \\n        if(i<0 || i==board.size() || j<0 || j==board[0].size() || board[i][j] != word[k] || visited[i][j])\\n            return false;\\n        \\n        visited[i][j] = true;\\n        bool l = solve(board, word, i, j-1, k+1, visited);\\n        bool r = solve(board, word, i, j+1, k+1, visited);\\n        bool t = solve(board, word, i-1, j, k+1, visited);\\n        bool b = solve(board, word, i+1, j, k+1, visited);\\n        visited[i][j] = false;\\n        return l || r || t || b;\\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n                \\n        vector<vector<bool>>visited(board.size(), vector<bool>(board[0].size(), false));\\n        vector<string> res;\\n        \\n        for(auto &word : words) {\\n            int flag = 0;\\n            reverse(word.begin(), word.end());\\n            for (int i=0; i<board.size(); i++) {\\n                for (int j=0; j<board[0].size(); j++) { \\n                    if(solve(board, word, i, j, 0, visited)) {\\n                        flag=1; break;\\n                    }\\n                }\\n                if(flag) break;\\n            }\\n            if(flag) {\\n                reverse(word.begin(), word.end());\\n                res.push_back(word);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1134922,
                "title": "python-trie-98-99-explanation-comments",
                "content": "Approach: DFS + Trie ~ O(MN \\\\* numPaths \\\\* 3^(longestWordLength)) runtime, O(numWords\\\\*longestWord) space - - 24ms(98.99%), 14.6MB (7.90%)\\nHere the worst case runtime is the same (assuming similar words like \"aaaaab\" \"aaaaac\", etc.)\\nBut disregarding the extreme case, it is on average a lot faster due to pruning (i.e. instead of *numWords, it\\'s *numPaths in Trie)\\n\\nInstead of looping through entire board for each word, at every character we check if it matches the first letter of any of the words\\nand the letters that don\\'t match are pruned. \\nEx: let\\'s say we check board[0][0], and found 20/100 words that match on the first letter. That means 80/100 of the words are pruned right away \\n(we didn\\'t even look at the other 80 words due to properties of hashmap).\\n\\nWhat is a Trie?\\nDiagram: https://drive.google.com/file/d/1McwXQIHmsk4sDwoYVNk0MhZFTMaDvnbg/view?usp=sharing\\nIt is a tree where each node stores a dictionary of next possible letters of a word sequence.\\nThis makes it so we can quickly prune and ignore the letters that don\\'t match.\\n\\n```\\nclass TrieNode:\\n    def __init__(self, char=None, letterToChild=None, word=None, prev=None):\\n        self.char = char # this node\\'s current character\\n        self.letterToChild = letterToChild # dictionary that maps child\\'s letter to child\\'s node\\n        self.word = word #  when a word is complete from start to this node, we set what the word is from start to here (note that there can stll be more words down this path)\\n        self.prev = prev # to backtrack and remove words that are already searched\\n\\nclass Solution:\\n    #24ms (faster than 98.86% Python 3) ~ O(MN * numPaths * 3^(longestWordLength)) runtime, O(totalWordLength * numWords) worst case memory\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        if not board or len(board[0]) == 0 or not words:\\n            return []\\n\\n        def buildTrie(words: List[str]):\\n            #print(\"using words: {}\".format(words))\\n            # root node is character \"/\"\\n            root = TrieNode(char=\"/\")\\n            for word in words:\\n                # given a word, construct path of the word in Trie\\n                index = 0\\n                curNode = root\\n                while index < len(word):\\n                    #print(\"word[index]: {}\".format(word[index]))\\n                    # prepare childNode\\n                    char = word[index]\\n                    if not curNode.letterToChild:\\n                        curNode.letterToChild = {}\\n                    if char not in curNode.letterToChild:\\n                        # if childNode doesn\\'t exist, create it\\n                        childNode = TrieNode(char=char,letterToChild={},prev=curNode) #for some reason I need the {} otherwise it\\'s stealing from previous node\\n                        curNode.letterToChild[char] = childNode\\n                        #print(\"curNode\\'s child: {}\".format(curNode.letterToChild))\\n                    else:\\n                        childNode = curNode.letterToChild[char]\\n                    \\n                    # if at end of word, update the child node\\n                    if index == len(word) - 1:\\n                        childNode.word = word\\n                        break\\n\\n                    index += 1\\n                    curNode = childNode\\n            return root\\n        #build the Trie\\n        root = buildTrie(words)\\n\\n        #iterate through the board\\n        rows = len(board)\\n        cols = len(board[0])\\n        \\n        resultList = []\\n        def dfs(x,y,curNode:TrieNode):\\n            #print(\"(x,y)=({},{})\".format(x,y))\\n            boardLetter = board[x][y]\\n            if boardLetter in curNode.letterToChild:\\n                board[x][y] = \"*\" #modify the board letter so we don\\'t reuse during dfs search\\n                # letter matches, get the childNode\\n                nextNode = curNode.letterToChild[boardLetter]\\n                # check if nextNode is at the end of a word; if so, add that to our resultList. Note that there may be more words further along this path.\\n                if nextNode.word:\\n                    resultList.append(nextNode.word)\\n                    nextNode.word = None\\n                    # delete the branch that is no longer needed (to avoid creating the same word again on next board iteration)\\n                    if len(nextNode.letterToChild) == 0:\\n                        #no more children below so need to backtrack and delete\\n                        #backtrack stops if there are 2+ paths down, or if we\\'re at the root node\\n                        parentNode = curNode\\n                        usedChar = nextNode.char\\n                        while len(parentNode.letterToChild) == 1:\\n                            #cut mapping of parentNode to used-childNode\\n                            del parentNode.letterToChild[usedChar]\\n                            usedChar = parentNode.char\\n                            if usedChar == \"/\":\\n                                #reached the top so no need to backtrack anymore\\n                                break\\n                            parentNode = parentNode.prev                            \\n\\n                # keep dfs traversing until end of word(s) in this Trie path\\n                for dx,dy in [(-1,0),(1,0),(0,-1),(0,1)]:\\n                    adjX, adjY = x+dx, y+dy \\n                    # check if adjacent position is in board\\n                    if 0 <= adjX < rows and 0 <= adjY < cols:\\n                        dfs(adjX,adjY,nextNode)\\n            # no match with board or no more letters along this path\\n            # revert back the letter modified by dfs (backtrack)\\n            board[x][y] = boardLetter\\n            return\\n\\n        for x in range(rows):\\n            for y in range(cols):\\n                #check if word match; if so, traverse dfs\\n                curNode = root \\n                dfs(x,y,curNode)\\n        return resultList\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self, char=None, letterToChild=None, word=None, prev=None):\\n        self.char = char # this node\\'s current character\\n        self.letterToChild = letterToChild # dictionary that maps child\\'s letter to child\\'s node\\n        self.word = word #  when a word is complete from start to this node, we set what the word is from start to here (note that there can stll be more words down this path)\\n        self.prev = prev # to backtrack and remove words that are already searched\\n\\nclass Solution:\\n    #24ms (faster than 98.86% Python 3) ~ O(MN * numPaths * 3^(longestWordLength)) runtime, O(totalWordLength * numWords) worst case memory\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        if not board or len(board[0]) == 0 or not words:\\n            return []\\n\\n        def buildTrie(words: List[str]):\\n            #print(\"using words: {}\".format(words))\\n            # root node is character \"/\"\\n            root = TrieNode(char=\"/\")\\n            for word in words:\\n                # given a word, construct path of the word in Trie\\n                index = 0\\n                curNode = root\\n                while index < len(word):\\n                    #print(\"word[index]: {}\".format(word[index]))\\n                    # prepare childNode\\n                    char = word[index]\\n                    if not curNode.letterToChild:\\n                        curNode.letterToChild = {}\\n                    if char not in curNode.letterToChild:\\n                        # if childNode doesn\\'t exist, create it\\n                        childNode = TrieNode(char=char,letterToChild={},prev=curNode) #for some reason I need the {} otherwise it\\'s stealing from previous node\\n                        curNode.letterToChild[char] = childNode\\n                        #print(\"curNode\\'s child: {}\".format(curNode.letterToChild))\\n                    else:\\n                        childNode = curNode.letterToChild[char]\\n                    \\n                    # if at end of word, update the child node\\n                    if index == len(word) - 1:\\n                        childNode.word = word\\n                        break\\n\\n                    index += 1\\n                    curNode = childNode\\n            return root\\n        #build the Trie\\n        root = buildTrie(words)\\n\\n        #iterate through the board\\n        rows = len(board)\\n        cols = len(board[0])\\n        \\n        resultList = []\\n        def dfs(x,y,curNode:TrieNode):\\n            #print(\"(x,y)=({},{})\".format(x,y))\\n            boardLetter = board[x][y]\\n            if boardLetter in curNode.letterToChild:\\n                board[x][y] = \"*\" #modify the board letter so we don\\'t reuse during dfs search\\n                # letter matches, get the childNode\\n                nextNode = curNode.letterToChild[boardLetter]\\n                # check if nextNode is at the end of a word; if so, add that to our resultList. Note that there may be more words further along this path.\\n                if nextNode.word:\\n                    resultList.append(nextNode.word)\\n                    nextNode.word = None\\n                    # delete the branch that is no longer needed (to avoid creating the same word again on next board iteration)\\n                    if len(nextNode.letterToChild) == 0:\\n                        #no more children below so need to backtrack and delete\\n                        #backtrack stops if there are 2+ paths down, or if we\\'re at the root node\\n                        parentNode = curNode\\n                        usedChar = nextNode.char\\n                        while len(parentNode.letterToChild) == 1:\\n                            #cut mapping of parentNode to used-childNode\\n                            del parentNode.letterToChild[usedChar]\\n                            usedChar = parentNode.char\\n                            if usedChar == \"/\":\\n                                #reached the top so no need to backtrack anymore\\n                                break\\n                            parentNode = parentNode.prev                            \\n\\n                # keep dfs traversing until end of word(s) in this Trie path\\n                for dx,dy in [(-1,0),(1,0),(0,-1),(0,1)]:\\n                    adjX, adjY = x+dx, y+dy \\n                    # check if adjacent position is in board\\n                    if 0 <= adjX < rows and 0 <= adjY < cols:\\n                        dfs(adjX,adjY,nextNode)\\n            # no match with board or no more letters along this path\\n            # revert back the letter modified by dfs (backtrack)\\n            board[x][y] = boardLetter\\n            return\\n\\n        for x in range(rows):\\n            for y in range(cols):\\n                #check if word match; if so, traverse dfs\\n                curNode = root \\n                dfs(x,y,curNode)\\n        return resultList\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1004060,
                "title": "simple-java-implementation-using-backtracking-extending-word-search-solution",
                "content": "I used the same concept which I used to solve Word Search problem. Hope it would help.\\n```\\nclass Solution {\\n    public List<String> findWords(char[][] board, String[] words) {\\n        int r = board.length;\\n        int c = board[0].length;\\n        Set<String> result = new HashSet<>();\\n        \\n        for(int i=0;i<r;i++) {\\n            for(int j=0;j<c;j++) {\\n                for(String word : words) {\\n                    if(board[i][j] == word.charAt(0) && dfs(board, word, new boolean[r][c], i, j, 0)) {\\n                        result.add(word);\\n                    }\\n                }\\n            }\\n        }\\n        return new ArrayList<>(result);\\n    }\\n    \\n    private boolean dfs(char[][] board, String word, boolean[][] visited, int i, int j, int index) {\\n        if(word.length() == index)\\n            return true;\\n        \\n        if(i<0 || j<0 || i>=board.length || j>=board[i].length || visited[i][j] || board[i][j] != word.charAt(index))\\n            return false;\\n        \\n        visited[i][j] = true;\\n        \\n        if( dfs(board, word, visited, i+1, j, index+1) ||\\n            dfs(board, word, visited, i-1, j, index+1) ||\\n            dfs(board, word, visited, i, j+1, index+1) ||\\n            dfs(board, word, visited, i, j-1, index+1)\\n          )\\n            return true;\\n        \\n        visited[i][j] = false;\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> findWords(char[][] board, String[] words) {\\n        int r = board.length;\\n        int c = board[0].length;\\n        Set<String> result = new HashSet<>();\\n        \\n        for(int i=0;i<r;i++) {\\n            for(int j=0;j<c;j++) {\\n                for(String word : words) {\\n                    if(board[i][j] == word.charAt(0) && dfs(board, word, new boolean[r][c], i, j, 0)) {\\n                        result.add(word);\\n                    }\\n                }\\n            }\\n        }\\n        return new ArrayList<>(result);\\n    }\\n    \\n    private boolean dfs(char[][] board, String word, boolean[][] visited, int i, int j, int index) {\\n        if(word.length() == index)\\n            return true;\\n        \\n        if(i<0 || j<0 || i>=board.length || j>=board[i].length || visited[i][j] || board[i][j] != word.charAt(index))\\n            return false;\\n        \\n        visited[i][j] = true;\\n        \\n        if( dfs(board, word, visited, i+1, j, index+1) ||\\n            dfs(board, word, visited, i-1, j, index+1) ||\\n            dfs(board, word, visited, i, j+1, index+1) ||\\n            dfs(board, word, visited, i, j-1, index+1)\\n          )\\n            return true;\\n        \\n        visited[i][j] = false;\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59805,
                "title": "c-462-ms-brute-force-and-35-ms-trie-solution",
                "content": "**Solution 1**\\n\\nBrute force. Using [solution](https://discuss.leetcode.com/topic/82756/two-9-ms-c-backtrack-solutions)  of [Word Search](https://leetcode.com/problems/word-search/description/).\\nRunime: 462 ms\\n```\\nclass Solution {\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        vector<string>res;\\n        unordered_map<char, vector<string>>m;\\n        for(auto x: words) m[x[0]].push_back(x);\\n        for(int i = 0; i < board.size(); i++)\\n            for(int j = 0; j < board[0].size(); j++)\\n                if(m[board[i][j]].size() > 0)\\n                    for(auto x: m[board[i][j]]){\\n                        bool found = false;\\n                        backtrack(board, 1, i, j, board.size(), board[0].size(), x, found);\\n                        if(found && find(res.begin(), res.end(), x) == res.end()) res.push_back(x);\\n                    } \\n        return res;\\n    }\\n    \\n    void backtrack(vector<vector<char>>& board, int pos, int r, int c, int m, int n, string& word, bool& found){\\n        if(board[r][c] == '0' || found) return;\\n        if(pos == word.size()){\\n            found = true;\\n            return;\\n        }\\n        char tmp = board[r][c];\\n        board[r][c] = '0';\\n        if(r - 1 >= 0 && board[r - 1][c] == word[pos]) backtrack(board, pos + 1, r - 1, c, m, n, word, found);\\n        if(r + 1 < m  && board[r + 1][c] == word[pos]) backtrack(board, pos + 1, r + 1, c, m, n, word, found);\\n        if(c + 1 < n  && board[r][c + 1] == word[pos]) backtrack(board, pos + 1, r, c + 1, m, n, word, found);\\n        if(c - 1 >= 0 && board[r][c - 1] == word[pos]) backtrack(board, pos + 1, r, c - 1, m, n, word, found);\\n        board[r][c] = tmp;\\n    }\\n};\\n```\\n***\\n**Solution 2**\\n\\nAdd Trie, inspired by Trie implementation in this [thread](https://discuss.leetcode.com/topic/13463/maybe-the-code-is-not-too-much-by-using-next-26-c).\\nRuntime: 35 ms. (Beats 95.58% of C++ solutions.)\\n```\\nstruct TrieNode{\\n    string word;\\n    TrieNode* next[26];\\n};\\n\\nclass Solution {\\nprivate:\\n    TrieNode* root;\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        vector<string>res;\\n        buildTrie(words);\\n        for(int i = 0; i < board.size(); i++)\\n            for(int j = 0; j < board[0].size(); j++)\\n                backtrack(board, res, i, j, board.size() - 1, board[0].size() - 1, root);\\n        return res;\\n    }\\n    \\n    void backtrack(vector<vector<char>>& board, vector<string>& res, int r, int c, int m, int n, TrieNode* p){\\n        if(r < 0 || c < 0 || r > m || c > n || board[r][c] == '0'|| !p->next[board[r][c] - 'a']) return;\\n        p = p->next[board[r][c] - 'a'];\\n        if(p->word.size() > 0){\\n            res.push_back(p->word);\\n            p->word = \"\";\\n        }\\n        char tmp = board[r][c];\\n        board[r][c] = '0';\\n        backtrack(board, res, r - 1, c, m, n, p);\\n        backtrack(board, res, r + 1, c, m, n, p);\\n        backtrack(board, res, r, c + 1, m, n, p);\\n        backtrack(board, res, r, c - 1, m, n, p);\\n        board[r][c] = tmp;\\n    }\\n    \\n    void buildTrie(vector<string>& words){\\n        root = new TrieNode();\\n        for(auto x: words){\\n            TrieNode* p = root;\\n            for(auto c: x){\\n                if(!p->next[c - 'a']) p->next[c - 'a'] = new TrieNode();\\n                p = p->next[c - 'a'];\\n            }\\n            p->word = x;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        vector<string>res;\\n        unordered_map<char, vector<string>>m;\\n        for(auto x: words) m[x[0]].push_back(x);\\n        for(int i = 0; i < board.size(); i++)\\n            for(int j = 0; j < board[0].size(); j++)\\n                if(m[board[i][j]].size() > 0)\\n                    for(auto x: m[board[i][j]]){\\n                        bool found = false;\\n                        backtrack(board, 1, i, j, board.size(), board[0].size(), x, found);\\n                        if(found && find(res.begin(), res.end(), x) == res.end()) res.push_back(x);\\n                    } \\n        return res;\\n    }\\n    \\n    void backtrack(vector<vector<char>>& board, int pos, int r, int c, int m, int n, string& word, bool& found){\\n        if(board[r][c] == '0' || found) return;\\n        if(pos == word.size()){\\n            found = true;\\n            return;\\n        }\\n        char tmp = board[r][c];\\n        board[r][c] = '0';\\n        if(r - 1 >= 0 && board[r - 1][c] == word[pos]) backtrack(board, pos + 1, r - 1, c, m, n, word, found);\\n        if(r + 1 < m  && board[r + 1][c] == word[pos]) backtrack(board, pos + 1, r + 1, c, m, n, word, found);\\n        if(c + 1 < n  && board[r][c + 1] == word[pos]) backtrack(board, pos + 1, r, c + 1, m, n, word, found);\\n        if(c - 1 >= 0 && board[r][c - 1] == word[pos]) backtrack(board, pos + 1, r, c - 1, m, n, word, found);\\n        board[r][c] = tmp;\\n    }\\n};\\n```\n```\\nstruct TrieNode{\\n    string word;\\n    TrieNode* next[26];\\n};\\n\\nclass Solution {\\nprivate:\\n    TrieNode* root;\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        vector<string>res;\\n        buildTrie(words);\\n        for(int i = 0; i < board.size(); i++)\\n            for(int j = 0; j < board[0].size(); j++)\\n                backtrack(board, res, i, j, board.size() - 1, board[0].size() - 1, root);\\n        return res;\\n    }\\n    \\n    void backtrack(vector<vector<char>>& board, vector<string>& res, int r, int c, int m, int n, TrieNode* p){\\n        if(r < 0 || c < 0 || r > m || c > n || board[r][c] == '0'|| !p->next[board[r][c] - 'a']) return;\\n        p = p->next[board[r][c] - 'a'];\\n        if(p->word.size() > 0){\\n            res.push_back(p->word);\\n            p->word = \"\";\\n        }\\n        char tmp = board[r][c];\\n        board[r][c] = '0';\\n        backtrack(board, res, r - 1, c, m, n, p);\\n        backtrack(board, res, r + 1, c, m, n, p);\\n        backtrack(board, res, r, c + 1, m, n, p);\\n        backtrack(board, res, r, c - 1, m, n, p);\\n        board[r][c] = tmp;\\n    }\\n    \\n    void buildTrie(vector<string>& words){\\n        root = new TrieNode();\\n        for(auto x: words){\\n            TrieNode* p = root;\\n            for(auto c: x){\\n                if(!p->next[c - 'a']) p->next[c - 'a'] = new TrieNode();\\n                p = p->next[c - 'a'];\\n            }\\n            p->word = x;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2781431,
                "title": "kind-of-clumsy-trie-solution-but-it-works",
                "content": "```csharp\\npublic class Solution\\n{\\n    public IList<string> FindWords(char[][] board, string[] words)\\n    {\\n        int m = board.Length;\\n        int n = board[0].Length;\\n        List<string> res = new();\\n\\n        //build trie\\n        Node root = new();\\n        foreach (string word in words)\\n        {\\n            Node node = root;\\n            foreach (char c in word)\\n            {\\n                if (node.Next[c] is null) node.Next[c] = new Node();\\n                node = node.Next[c];\\n            }\\n            node.Word = word;\\n        }\\n\\n        //do dfs\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                Dfs(i, j, root);\\n            }\\n        }\\n\\n        return res;\\n\\n        void Dfs(int i, int j, Node node)\\n        {\\n            if (i < 0 || j < 0 || i == m || j == n) return;\\n            char c = board[i][j];\\n            if (c == \\'/\\' || node.Next[c] is null) return;\\n            node = node.Next[c];\\n\\n            if (node.Word is not null)\\n            {\\n                res.Add(node.Word);\\n                node.Word = null;\\n            }\\n\\n            board[i][j] = \\'/\\';\\n            Dfs(i - 1, j, node);\\n            Dfs(i, j - 1, node);\\n            Dfs(i + 1, j, node);\\n            Dfs(i, j + 1, node);\\n            board[i][j] = c;\\n        }\\n    }\\n}\\n\\npublic class Node\\n{\\n    public Node[] Next { get; } = new Node[\\'z\\' + 1];\\n    public string Word { get; set; }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic class Solution\\n{\\n    public IList<string> FindWords(char[][] board, string[] words)\\n    {\\n        int m = board.Length;\\n        int n = board[0].Length;\\n        List<string> res = new();\\n\\n        //build trie\\n        Node root = new();\\n        foreach (string word in words)\\n        {\\n            Node node = root;\\n            foreach (char c in word)\\n            {\\n                if (node.Next[c] is null) node.Next[c] = new Node();\\n                node = node.Next[c];\\n            }\\n            node.Word = word;\\n        }\\n\\n        //do dfs\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                Dfs(i, j, root);\\n            }\\n        }\\n\\n        return res;\\n\\n        void Dfs(int i, int j, Node node)\\n        {\\n            if (i < 0 || j < 0 || i == m || j == n) return;\\n            char c = board[i][j];\\n            if (c == \\'/\\' || node.Next[c] is null) return;\\n            node = node.Next[c];\\n\\n            if (node.Word is not null)\\n            {\\n                res.Add(node.Word);\\n                node.Word = null;\\n            }\\n\\n            board[i][j] = \\'/\\';\\n            Dfs(i - 1, j, node);\\n            Dfs(i, j - 1, node);\\n            Dfs(i + 1, j, node);\\n            Dfs(i, j + 1, node);\\n            board[i][j] = c;\\n        }\\n    }\\n}\\n\\npublic class Node\\n{\\n    public Node[] Next { get; } = new Node[\\'z\\' + 1];\\n    public string Word { get; set; }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779871,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public List<String> findWords(char[][] board, String[] words) {\\n        List<String> res = new ArrayList<>();\\n        TrieNode root = buildTrie(words);\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[0].length; j++) {\\n                dfs(board, i, j, root, res);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public void dfs(char[][] board, int i, int j, TrieNode p, List<String> res) {\\n        char c = board[i][j];\\n        if (c == \\'#\\' || p.next[c - \\'a\\'] == null) {\\n            return;\\n        }\\n        p = p.next[c - \\'a\\'];\\n        if (p.word != null) {   \\n            res.add(p.word);\\n            p.word = null;     \\n        }\\n        board[i][j] = \\'#\\';\\n        if (i > 0) dfs(board, i - 1, j, p, res);\\n        if (j > 0) dfs(board, i, j - 1, p, res);\\n        if (i < board.length - 1) dfs(board, i + 1, j, p, res);\\n        if (j < board[0].length - 1) dfs(board, i, j + 1, p, res);\\n        board[i][j] = c;\\n    }\\n\\n    public TrieNode buildTrie(String[] words) {\\n        TrieNode root = new TrieNode();\\n        for (int i=0; i< words.length; i++) {\\n            TrieNode p = root;\\n            for (int j=0; j<words[i].toCharArray().length; j++) {\\n                int k = words[i].toCharArray()[j]- \\'a\\';\\n                if (p.next[k] == null) {\\n                    p.next[k] = new TrieNode();\\n                }\\n                p = p.next[k];\\n            }\\n            p.word = words[i];\\n        }\\n        return root;\\n    }\\n\\n    class TrieNode {\\n        TrieNode[] next = new TrieNode[26];\\n        String word;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<String> findWords(char[][] board, String[] words) {\\n        List<String> res = new ArrayList<>();\\n        TrieNode root = buildTrie(words);\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[0].length; j++) {\\n                dfs(board, i, j, root, res);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2779536,
                "title": "daily-leetcoding-challenge-november-day-5",
                "content": "This problem is the Daily LeetCoding Challenge for November, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/word-search-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/word-search-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2252022,
                "title": "accepted-java-solution-without-using-trie",
                "content": "Regular backtracking with length pruning\\n```\\nclass Solution {\\n    public List<String> findWords(char[][] board, String[] words) {\\n        int row = board.length;\\n        int col = board[0].length;\\n        \\n        boolean[][] visited = new boolean[row][col];\\n        Set<String> words_set = new HashSet<>();\\n        \\n        int max_len = 0;\\n        for(String w: words) {\\n            words_set.add(w);\\n            max_len = Math.max(max_len, w.length());\\n        }\\n        \\n        Set<String> ans = new HashSet<>(); //de-dup\\n        \\n        for(int i = 0; i < row; i++) \\n            for(int j = 0; j < col; j++)\\n                helper(board, words_set, i, j, visited, new StringBuilder(), ans, 0, max_len);\\n        \\n        List<String> list = new ArrayList<String>();\\n        list.addAll(ans);\\n        return list;\\n    }\\n    \\n    private void helper(\\n        char[][] board, Set<String> words_set, int r, int c, boolean[][] visited, StringBuilder sb, Set<String> ans, int length, int max_len) {\\n        \\n        int row = board.length;\\n        int col = board[0].length;\\n        \\n        if (r < 0 || c < 0 || r == row || c == col) return;\\n        if (length >= max_len) return;\\n        if (visited[r][c]) return;\\n        \\n        visited[r][c] = true;\\n        sb.append(board[r][c]);\\n        \\n        if (words_set.contains(sb.toString()))\\n            ans.add(sb.toString());\\n        \\n        helper(board, words_set, r + 1, c, visited, sb, ans, length + 1, max_len);\\n        helper(board, words_set, r - 1, c, visited, sb, ans, length + 1, max_len);\\n        helper(board, words_set, r, c + 1, visited, sb, ans, length + 1, max_len);\\n        helper(board, words_set, r, c - 1, visited, sb, ans, length + 1, max_len);  \\n        \\n        visited[r][c] = false;\\n        sb.setLength(sb.length() - 1);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> findWords(char[][] board, String[] words) {\\n        int row = board.length;\\n        int col = board[0].length;\\n        \\n        boolean[][] visited = new boolean[row][col];\\n        Set<String> words_set = new HashSet<>();\\n        \\n        int max_len = 0;\\n        for(String w: words) {\\n            words_set.add(w);\\n            max_len = Math.max(max_len, w.length());\\n        }\\n        \\n        Set<String> ans = new HashSet<>(); //de-dup\\n        \\n        for(int i = 0; i < row; i++) \\n            for(int j = 0; j < col; j++)\\n                helper(board, words_set, i, j, visited, new StringBuilder(), ans, 0, max_len);\\n        \\n        List<String> list = new ArrayList<String>();\\n        list.addAll(ans);\\n        return list;\\n    }\\n    \\n    private void helper(\\n        char[][] board, Set<String> words_set, int r, int c, boolean[][] visited, StringBuilder sb, Set<String> ans, int length, int max_len) {\\n        \\n        int row = board.length;\\n        int col = board[0].length;\\n        \\n        if (r < 0 || c < 0 || r == row || c == col) return;\\n        if (length >= max_len) return;\\n        if (visited[r][c]) return;\\n        \\n        visited[r][c] = true;\\n        sb.append(board[r][c]);\\n        \\n        if (words_set.contains(sb.toString()))\\n            ans.add(sb.toString());\\n        \\n        helper(board, words_set, r + 1, c, visited, sb, ans, length + 1, max_len);\\n        helper(board, words_set, r - 1, c, visited, sb, ans, length + 1, max_len);\\n        helper(board, words_set, r, c + 1, visited, sb, ans, length + 1, max_len);\\n        helper(board, words_set, r, c - 1, visited, sb, ans, length + 1, max_len);  \\n        \\n        visited[r][c] = false;\\n        sb.setLength(sb.length() - 1);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2048961,
                "title": "python-trie-dfs-neetcode-optimized-code-no-tle",
                "content": "Optimized the code by Neetcode.io so that it does not get TLE when submitted:\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.end = False\\n    \\n    def add_word(self, word):\\n        node = self\\n        for c in word:\\n            if c not in node.children:\\n                node.children[c] = TrieNode()\\n            node = node.children[c]\\n        node.end = True\\n\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        root = TrieNode()\\n        for w in words:\\n            root.add_word(w)\\n        \\n        rows, cols = len(board), len(board[0])\\n        ans = []\\n        word = []\\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\\n        \\n        def dfs(x, y, node):\\n            if not (0 <= x < rows) or not (0 <= y < cols) or board[x][y] == \"#\":\\n                return\\n            \\n            char = board[x][y]\\n            if char not in node.children:\\n                return\\n\\n            board[x][y] = \"#\"\\n            \\n            node = node.children[char]\\n            word.append(char)\\n            if node.end:\\n                ans.append(\"\".join(word))\\n                node.end = False\\n            \\n            for dx, dy in directions:\\n                dfs(x + dx, y + dy, node)\\n            \\n            word.pop()\\n            board[x][y] = char\\n        \\n        for i in range(rows):\\n            for j in range(cols):\\n                dfs(i, j, root)\\n        \\n        return ans\\n```\\nMain changes:\\n1. Removed **visited set** and instead used a \"visited char\" (\"#\") in the board, which will tell us if we already visited that position. After we finish the recursion we reset the \"#\" to its original value.\\n2. Changed the **ans set to a list** (we avoid checking duplicates). The way we would manage this is by changing the \"end/end of word\" attribute to False when we add a word, so we verify we don\\'t add it again.\\n3. Converted the \"word\" parameter (string) into a global array/list. **Without this change it will still give TLE.**\\n4. The last change does not affect the overall complexity but makes the code more scalable, which is the directions array/list. This may help in the case the **follow-up** is to verify also the **diagonals** (we can easily add 4 more coordinates to the array).",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.end = False\\n    \\n    def add_word(self, word):\\n        node = self\\n        for c in word:\\n            if c not in node.children:\\n                node.children[c] = TrieNode()\\n            node = node.children[c]\\n        node.end = True\\n\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        root = TrieNode()\\n        for w in words:\\n            root.add_word(w)\\n        \\n        rows, cols = len(board), len(board[0])\\n        ans = []\\n        word = []\\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\\n        \\n        def dfs(x, y, node):\\n            if not (0 <= x < rows) or not (0 <= y < cols) or board[x][y] == \"#\":\\n                return\\n            \\n            char = board[x][y]\\n            if char not in node.children:\\n                return\\n\\n            board[x][y] = \"#\"\\n            \\n            node = node.children[char]\\n            word.append(char)\\n            if node.end:\\n                ans.append(\"\".join(word))\\n                node.end = False\\n            \\n            for dx, dy in directions:\\n                dfs(x + dx, y + dy, node)\\n            \\n            word.pop()\\n            board[x][y] = char\\n        \\n        for i in range(rows):\\n            for j in range(cols):\\n                dfs(i, j, root)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1860991,
                "title": "python3-trie-dfs-pruning",
                "content": "class Node:\\n\\n    def __init__(self):\\n        self.children = {}\\n        self.endOfWord = False\\n    def insert(self,word):\\n        root = self\\n        for w in word:\\n            if w not in root.children:\\n                root.children[w] = Node()\\n            root = root.children[w]\\n        root.endOfWord = True     \\n        \\nclass Solution:\\n\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        root = Node()\\n        for word in words:\\n            root.insert(word)\\n        result,visited=set(),set()\\n        ROWS,COLS=len(board),len(board[0])\\n        def dfs(r,c,node,currWord):\\n            if r in [-1,ROWS] or c in [-1,COLS] or (r,c) in visited or board[r][c] not in node.children:\\n                return False\\n            ele = board[r][c]\\n            currWord+=ele\\n            node = node.children[ele]\\n            flag = True\\n            if node.endOfWord:\\n                result.add(currWord)\\n                if len(node.children)==0:\\n                    flag = False\\n                    del node\\n            if flag:\\n                visited.add((r,c))\\n                dfs(r-1,c,node,currWord)\\n                dfs(r+1,c,node,currWord)\\n                dfs(r,c-1,node,currWord)\\n                dfs(r,c+1,node,currWord)\\n                visited.remove((r,c))\\n                \\n        for r in range(ROWS):\\n            for c in range(COLS):\\n                dfs(r,c,root,\"\")\\n        \\n        return list(result)",
                "solutionTags": [],
                "code": "class Node:\\n\\n    def __init__(self):\\n        self.children = {}\\n        self.endOfWord = False\\n    def insert(self,word):\\n        root = self\\n        for w in word:\\n            if w not in root.children:\\n                root.children[w] = Node()\\n            root = root.children[w]\\n        root.endOfWord = True     \\n        \\nclass Solution:\\n\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        root = Node()\\n        for word in words:\\n            root.insert(word)\\n        result,visited=set(),set()\\n        ROWS,COLS=len(board),len(board[0])\\n        def dfs(r,c,node,currWord):\\n            if r in [-1,ROWS] or c in [-1,COLS] or (r,c) in visited or board[r][c] not in node.children:\\n                return False\\n            ele = board[r][c]\\n            currWord+=ele\\n            node = node.children[ele]\\n            flag = True\\n            if node.endOfWord:\\n                result.add(currWord)\\n                if len(node.children)==0:\\n                    flag = False\\n                    del node\\n            if flag:\\n                visited.add((r,c))\\n                dfs(r-1,c,node,currWord)\\n                dfs(r+1,c,node,currWord)\\n                dfs(r,c-1,node,currWord)\\n                dfs(r,c+1,node,currWord)\\n                visited.remove((r,c))\\n                \\n        for r in range(ROWS):\\n            for c in range(COLS):\\n                dfs(r,c,root,\"\")\\n        \\n        return list(result)",
                "codeTag": "Java"
            },
            {
                "id": 1849610,
                "title": "python-trie-solution-with-dfs-backtracking-no-tle",
                "content": "Similar to other solutions. I used seperate TrieNode and Trie classes for clarity. \\n\\nNOTE: I originally got TLE until I added logic to remove nodes from the tree if they do not have children.\\n\\n```\\n\\'\\'\\'\\nInsert all words into Trie. Then DFS. At each cell, we will check to see if its in children of trie node. So, at each cell, we are checking the existance of all words simultaneously. Once we hit a prefix that does not exist in our trie, we backtrack and move to the next cell.\\n\\'\\'\\'\\nfrom collections import defaultdict\\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = defaultdict(TrieNode)\\n        self.word = None\\n        \\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        \\n    def insert(self, word):\\n        current = self.root\\n        \\n        for letter in word:\\n            current = current.children[letter]\\n        \\n        current.word = word\\n            \\n\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        \\n        m = len(board)\\n        n = len(board[0])\\n        \\n        trie = Trie()\\n        \\n        for word in words:\\n            trie.insert(word)\\n            \\n        ans = []\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                self.dfs(board, i, j, trie.root, ans)\\n        \\n        return ans\\n        \\n        \\n            \\n    def dfs(self, board, i, j, trie_node, ans):\\n        \\n        if i < 0 or j < 0 or i >= len(board) or j >= len(board[0]) or board[i][j] not in trie_node.children:\\n            return\\n        \\n        cell_orig = board[i][j]\\n        next_node = trie_node.children[cell_orig]\\n        \\n        if next_node.word != None:\\n            ans.append(next_node.word)\\n            next_node.word = None\\n            \\n            # If this letter has no children, then remove from trie\\n            if not next_node.children.keys():\\n                del trie_node.children[cell_orig]\\n                return\\n                \\n        board[i][j] = \\'#\\'   \\n            \\n        for x, y in ((-1, 0), (1, 0), (0, -1), (0, 1)):\\n            self.dfs(board, i + x, j + y, next_node, ans)\\n            \\n        # Backtrack\\n        board[i][j] = cell_orig\\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Trie"
                ],
                "code": "```\\n\\'\\'\\'\\nInsert all words into Trie. Then DFS. At each cell, we will check to see if its in children of trie node. So, at each cell, we are checking the existance of all words simultaneously. Once we hit a prefix that does not exist in our trie, we backtrack and move to the next cell.\\n\\'\\'\\'\\nfrom collections import defaultdict\\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = defaultdict(TrieNode)\\n        self.word = None\\n        \\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        \\n    def insert(self, word):\\n        current = self.root\\n        \\n        for letter in word:\\n            current = current.children[letter]\\n        \\n        current.word = word\\n            \\n\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        \\n        m = len(board)\\n        n = len(board[0])\\n        \\n        trie = Trie()\\n        \\n        for word in words:\\n            trie.insert(word)\\n            \\n        ans = []\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                self.dfs(board, i, j, trie.root, ans)\\n        \\n        return ans\\n        \\n        \\n            \\n    def dfs(self, board, i, j, trie_node, ans):\\n        \\n        if i < 0 or j < 0 or i >= len(board) or j >= len(board[0]) or board[i][j] not in trie_node.children:\\n            return\\n        \\n        cell_orig = board[i][j]\\n        next_node = trie_node.children[cell_orig]\\n        \\n        if next_node.word != None:\\n            ans.append(next_node.word)\\n            next_node.word = None\\n            \\n            # If this letter has no children, then remove from trie\\n            if not next_node.children.keys():\\n                del trie_node.children[cell_orig]\\n                return\\n                \\n        board[i][j] = \\'#\\'   \\n            \\n        for x, y in ((-1, 0), (1, 0), (0, -1), (0, 1)):\\n            self.dfs(board, i + x, j + y, next_node, ans)\\n            \\n        # Backtrack\\n        board[i][j] = cell_orig\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1750819,
                "title": "c-trie-backtracking-without-set",
                "content": "OPTIMIZATIONS:-\\n1. there can be multiple occurences of any word in the matrix. usual solutions handles this by adding the word(if found) to the set to avoid duplicates. the way i do it is set isWord TrieNode flag to false once a word has been found and add directly to the ans vector instead of a set\\n\\n2. instead of keeping a hashset/visited matrix, before applying dfs store the cur char in a temp char and set it to any char that is out of range from the input values. eg \\'@\\'. it acts as a flag whether this cell has been visited in the current dfs iteration. once the dfs call has been completed. restore the value from temp char.\\n\\n3. instead of passing a new current word(pass by value) maintain a global current string or pass by reference and just pop_back the char once its dfs call ends.\\n```\\nclass TrieNode{\\npublic:\\n    vector<TrieNode*> links;\\n    bool isWord;\\n    TrieNode(){\\n        links.resize(26);\\n        isWord=false;\\n    }\\n};\\n\\nclass Trie{\\npublic:\\n    TrieNode* root;\\n    Trie(){\\n        root = new TrieNode();\\n    }\\n    \\n    void addword(string& word){\\n        TrieNode* node = root;\\n        for(int i=0;i<word.length();i++){\\n            if(!node->links[word[i]-\\'a\\']) node->links[word[i]-\\'a\\'] = new TrieNode();\\n            node=node->links[word[i]-\\'a\\'];\\n        }\\n        node->isWord=true;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> x={-1,1,0,0};\\n    vector<int> y={0,0,-1,1};\\n    vector<string> ans;\\n    string cur;\\n    void dfs(vector<vector<char>>& board,TrieNode* node,int i,int j){\\n        if(i<0 || i==board.size() || j<0 || j==board[i].size() || board[i][j]==\\'@\\' || !node->links[board[i][j]-\\'a\\']) return;\\n        node=node->links[board[i][j]-\\'a\\'];\\n        cur.push_back(board[i][j]);\\n        if(node->isWord){\\n            ans.push_back(cur);\\n            node->isWord=false;\\n        }\\n        board[i][j]=\\'@\\';\\n        for(int z=0;z<4;z++) dfs(board,node,i+x[z],j+y[z]);\\n        board[i][j]=cur.back();\\n        cur.pop_back();\\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words){\\n        Trie trie;\\n        cur=\"\";\\n        for(int i=0;i<words.size();i++) trie.addword(words[i]);\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[i].size();j++){\\n                dfs(board,trie.root,i,j);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode{\\npublic:\\n    vector<TrieNode*> links;\\n    bool isWord;\\n    TrieNode(){\\n        links.resize(26);\\n        isWord=false;\\n    }\\n};\\n\\nclass Trie{\\npublic:\\n    TrieNode* root;\\n    Trie(){\\n        root = new TrieNode();\\n    }\\n    \\n    void addword(string& word){\\n        TrieNode* node = root;\\n        for(int i=0;i<word.length();i++){\\n            if(!node->links[word[i]-\\'a\\']) node->links[word[i]-\\'a\\'] = new TrieNode();\\n            node=node->links[word[i]-\\'a\\'];\\n        }\\n        node->isWord=true;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> x={-1,1,0,0};\\n    vector<int> y={0,0,-1,1};\\n    vector<string> ans;\\n    string cur;\\n    void dfs(vector<vector<char>>& board,TrieNode* node,int i,int j){\\n        if(i<0 || i==board.size() || j<0 || j==board[i].size() || board[i][j]==\\'@\\' || !node->links[board[i][j]-\\'a\\']) return;\\n        node=node->links[board[i][j]-\\'a\\'];\\n        cur.push_back(board[i][j]);\\n        if(node->isWord){\\n            ans.push_back(cur);\\n            node->isWord=false;\\n        }\\n        board[i][j]=\\'@\\';\\n        for(int z=0;z<4;z++) dfs(board,node,i+x[z],j+y[z]);\\n        board[i][j]=cur.back();\\n        cur.pop_back();\\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words){\\n        Trie trie;\\n        cur=\"\";\\n        for(int i=0;i<words.size();i++) trie.addword(words[i]);\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[i].size();j++){\\n                dfs(board,trie.root,i,j);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1688044,
                "title": "c-dfs-memoization-98-runtime-99-memory",
                "content": "```\\nclass Solution {\\n    \\n    bool dfs(vector<vector<char>>& board, const string& s,\\n             unsigned int idx, int i, int j) {\\n        if(idx == s.length()) {\\n            return true;\\n        }\\n        \\n        //Check if we are in bounds.\\n        if(i<0 or j<0) return false;\\n        if(i>=(int)board.size() or j>=(int)board[0].size()) return false;\\n        \\n        //Check if we found the right character/\\n        if(board[i][j] != s[idx]) {\\n            return false;\\n        }\\n        \\n        //Remember which character was at this location,\\n        //then assign a dummy character, to prevent using\\n        //the same character twice.\\n        char c = board[i][j];\\n        board[i][j] = \\'*\\';\\n        \\n        //Search for the next character at the adjacent indexes.\\n        bool good = dfs(board, s, idx+1, i+1, j) or\\n                     dfs(board, s, idx+1, i-1, j) or\\n                     dfs(board, s, idx+1, i, j+1) or\\n                     dfs(board, s, idx+1, i, j-1);\\n        \\n        //Change the character back and return the result.\\n        board[i][j] = c;\\n        return good;\\n    }\\npublic:\\n    typedef pair<int,int> Pair;\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        unordered_map<char,vector<Pair>> letters;\\n        vector<string> found;\\n        \\n        //Record the indexes of each char.\\n        for(int i = 0; i < (int)board.size(); ++i) {\\n            for(int j = 0; j < (int)board[0].size(); ++j) {\\n                letters[board[i][j]].push_back(Pair(i,j));\\n            }\\n        }\\n        \\n        for(string s: words) {\\n            bool cont = false;\\n            \\n            //If we didn\\'t already find every character in s,\\n            //we can\\'t possibly find the word, so we move on.\\n            for(auto i = 0u; i < s.length(); ++i) {\\n                if(letters.find(s[i]) == letters.end()) {\\n                    cont = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(cont)\\n                continue;\\n            \\n            //We skip to the indexes of the chars that are\\n            //equal to the first character in s.\\n            for(Pair p: letters[s[0]]) {\\n                if(dfs(board, s, 0u, p.first, p.second)) {\\n                    found.push_back(s);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return found;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    \\n    bool dfs(vector<vector<char>>& board, const string& s,\\n             unsigned int idx, int i, int j) {\\n        if(idx == s.length()) {\\n            return true;\\n        }\\n        \\n        //Check if we are in bounds.\\n        if(i<0 or j<0) return false;\\n        if(i>=(int)board.size() or j>=(int)board[0].size()) return false;\\n        \\n        //Check if we found the right character/\\n        if(board[i][j] != s[idx]) {\\n            return false;\\n        }\\n        \\n        //Remember which character was at this location,\\n        //then assign a dummy character, to prevent using\\n        //the same character twice.\\n        char c = board[i][j];\\n        board[i][j] = \\'*\\';\\n        \\n        //Search for the next character at the adjacent indexes.\\n        bool good = dfs(board, s, idx+1, i+1, j) or\\n                     dfs(board, s, idx+1, i-1, j) or\\n                     dfs(board, s, idx+1, i, j+1) or\\n                     dfs(board, s, idx+1, i, j-1);\\n        \\n        //Change the character back and return the result.\\n        board[i][j] = c;\\n        return good;\\n    }\\npublic:\\n    typedef pair<int,int> Pair;\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        unordered_map<char,vector<Pair>> letters;\\n        vector<string> found;\\n        \\n        //Record the indexes of each char.\\n        for(int i = 0; i < (int)board.size(); ++i) {\\n            for(int j = 0; j < (int)board[0].size(); ++j) {\\n                letters[board[i][j]].push_back(Pair(i,j));\\n            }\\n        }\\n        \\n        for(string s: words) {\\n            bool cont = false;\\n            \\n            //If we didn\\'t already find every character in s,\\n            //we can\\'t possibly find the word, so we move on.\\n            for(auto i = 0u; i < s.length(); ++i) {\\n                if(letters.find(s[i]) == letters.end()) {\\n                    cont = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(cont)\\n                continue;\\n            \\n            //We skip to the indexes of the chars that are\\n            //equal to the first character in s.\\n            for(Pair p: letters[s[0]]) {\\n                if(dfs(board, s, 0u, p.first, p.second)) {\\n                    found.push_back(s);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return found;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 664021,
                "title": "java-trie-dfs-clear-code",
                "content": "```\\nclass Solution {\\n    \\n    List<String> res;\\n    char[][] board;\\n    \\n    \\n    public List<String> findWords(char[][] _board, String[] words) {\\n        res = new ArrayList<String>();\\n        this.board = _board;\\n        TrieNode trie = new TrieNode();\\n        trie.constructTrie(words);\\n        for(int r = 0; r<board.length; r++){\\n            for(int c = 0; c<board[r].length; c++){\\n                helper(r,c,trie);\\n            }\\n        }\\n        Collections.sort(res);\\n        return res;\\n    }\\n    \\n    private void helper(int r, int c,TrieNode trie){\\n        if(r<0 || c<0 || r==board.length || c==board[r].length || board[r][c]==\\'#\\')return;\\n        char currentChar = board[r][c];\\n        TrieNode next = trie.children[currentChar -\\'a\\'];\\n        if(next==null)return;\\n        if(!next.word.equals(\"\")){\\n            res.add(next.word);\\n            next.word = \"\";\\n        }\\n        board[r][c]=\\'#\\';\\n        helper(r+1,c,next);\\n        helper(r-1,c,next);\\n        helper(r,c+1,next);\\n        helper(r,c-1,next);\\n        board[r][c]=currentChar;\\n    }\\n    \\n    class TrieNode{\\n        \\n        TrieNode[] children = new TrieNode[\\'z\\'-\\'a\\'+1];\\n        String word = \"\";\\n        \\n        public void constructTrie(String[] words){\\n            TrieNode current = this;\\n            for(String word : words){\\n                for(char c : word.toCharArray()){\\n                    if(current.children[c - \\'a\\']==null){\\n                       current.children[c - \\'a\\'] = new TrieNode(); \\n                    }\\n                    current = current.children[c - \\'a\\'];\\n                }\\n                current.word = word;\\n                current = this;\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    \\n    List<String> res;\\n    char[][] board;\\n    \\n    \\n    public List<String> findWords(char[][] _board, String[] words) {\\n        res = new ArrayList<String>();\\n        this.board = _board;\\n        TrieNode trie = new TrieNode();\\n        trie.constructTrie(words);\\n        for(int r = 0; r<board.length; r++){\\n            for(int c = 0; c<board[r].length; c++){\\n                helper(r,c,trie);\\n            }\\n        }\\n        Collections.sort(res);\\n        return res;\\n    }\\n    \\n    private void helper(int r, int c,TrieNode trie){\\n        if(r<0 || c<0 || r==board.length || c==board[r].length || board[r][c]==\\'#\\')return;\\n        char currentChar = board[r][c];\\n        TrieNode next = trie.children[currentChar -\\'a\\'];\\n        if(next==null)return;\\n        if(!next.word.equals(\"\")){\\n            res.add(next.word);\\n            next.word = \"\";\\n        }\\n        board[r][c]=\\'#\\';\\n        helper(r+1,c,next);\\n        helper(r-1,c,next);\\n        helper(r,c+1,next);\\n        helper(r,c-1,next);\\n        board[r][c]=currentChar;\\n    }\\n    \\n    class TrieNode{\\n        \\n        TrieNode[] children = new TrieNode[\\'z\\'-\\'a\\'+1];\\n        String word = \"\";\\n        \\n        public void constructTrie(String[] words){\\n            TrieNode current = this;\\n            for(String word : words){\\n                for(char c : word.toCharArray()){\\n                    if(current.children[c - \\'a\\']==null){\\n                       current.children[c - \\'a\\'] = new TrieNode(); \\n                    }\\n                    current = current.children[c - \\'a\\'];\\n                }\\n                current.word = word;\\n                current = this;\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 632923,
                "title": "one-of-best-use-cases-for-trie-java-beats-99-9",
                "content": "```\\nclass Solution {\\n    public List<String> findWords(char[][] board, String[] words) {\\n        Trie trie = new Trie();\\n        for(String word:words){\\n            trie.insert(word);\\n        }\\n        List<String> result = new ArrayList<String>();\\n        for(int i=0;i<board.length;i++){\\n            for(int j=0;j<board[0].length;j++){\\n                if(trie.root.childrens[board[i][j] - \\'a\\'] != null){\\n                    trie.search(result,i,j,trie.root,board);\\n                }\\n            }\\n        }\\n        return result;\\n    }   \\n}\\n\\nclass TrieNode {\\n        TrieNode[] childrens;\\n        String word;\\n        TrieNode(){\\n            childrens = new TrieNode[26];\\n        }\\n    }\\nclass Trie {\\n    \\n    TrieNode root;\\n    public Trie() {\\n        root = new TrieNode();\\n    }\\n   \\n    public void insert(String word) {\\n        \\n        TrieNode ptr = root;\\n        for(int i=0;i<word.length();i++){\\n            int index = word.charAt(i) - \\'a\\';\\n            if(ptr.childrens[index] == null){\\n                ptr.childrens[index] = new TrieNode();\\n            }\\n            ptr = ptr.childrens[index];\\n        }\\n        ptr.word = word;\\n    }\\n    \\n    public void search(List<String> result,int i,int j,TrieNode node,char[][] board) {\\n      \\n      if(i<0 || i>= board.length || j < 0 || j >= board[0].length || board[i][j] == \\'.\\')\\n            return;\\n       \\n        int index = board[i][j] - \\'a\\';\\n        if(node.childrens[index] == null)\\n            return;\\n\\n        if(node.childrens[index].word != null)\\n        {\\n            result.add(node.childrens[index].word);\\n            node.childrens[index].word = null;\\n        }\\n        char current = board[i][j];\\n        board[i][j] = \\'.\\';\\n        \\n        search(result,i+1,j,node.childrens[index],board);\\n        search(result,i,j+1,node.childrens[index],board);\\n        search(result,i-1,j,node.childrens[index],board);\\n        search(result,i,j-1,node.childrens[index],board);\\n        board[i][j] = current;\\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> findWords(char[][] board, String[] words) {\\n        Trie trie = new Trie();\\n        for(String word:words){\\n            trie.insert(word);\\n        }\\n        List<String> result = new ArrayList<String>();\\n        for(int i=0;i<board.length;i++){\\n            for(int j=0;j<board[0].length;j++){\\n                if(trie.root.childrens[board[i][j] - \\'a\\'] != null){\\n                    trie.search(result,i,j,trie.root,board);\\n                }\\n            }\\n        }\\n        return result;\\n    }   \\n}\\n\\nclass TrieNode {\\n        TrieNode[] childrens;\\n        String word;\\n        TrieNode(){\\n            childrens = new TrieNode[26];\\n        }\\n    }\\nclass Trie {\\n    \\n    TrieNode root;\\n    public Trie() {\\n        root = new TrieNode();\\n    }\\n   \\n    public void insert(String word) {\\n        \\n        TrieNode ptr = root;\\n        for(int i=0;i<word.length();i++){\\n            int index = word.charAt(i) - \\'a\\';\\n            if(ptr.childrens[index] == null){\\n                ptr.childrens[index] = new TrieNode();\\n            }\\n            ptr = ptr.childrens[index];\\n        }\\n        ptr.word = word;\\n    }\\n    \\n    public void search(List<String> result,int i,int j,TrieNode node,char[][] board) {\\n      \\n      if(i<0 || i>= board.length || j < 0 || j >= board[0].length || board[i][j] == \\'.\\')\\n            return;\\n       \\n        int index = board[i][j] - \\'a\\';\\n        if(node.childrens[index] == null)\\n            return;\\n\\n        if(node.childrens[index].word != null)\\n        {\\n            result.add(node.childrens[index].word);\\n            node.childrens[index].word = null;\\n        }\\n        char current = board[i][j];\\n        board[i][j] = \\'.\\';\\n        \\n        search(result,i+1,j,node.childrens[index],board);\\n        search(result,i,j+1,node.childrens[index],board);\\n        search(result,i-1,j,node.childrens[index],board);\\n        search(result,i,j-1,node.childrens[index],board);\\n        board[i][j] = current;\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 542405,
                "title": "go-dfs-trie-solution",
                "content": "```\\ntype TrieNode struct {\\n\\tword     string\\n\\tchildren [26]*TrieNode\\n}\\n\\nfunc findWords(board [][]byte, words []string) []string {\\n\\troot := &TrieNode{}\\n\\tfor _, w := range words {\\n\\t\\tnode := root\\n\\t\\tfor _, c := range w {\\n\\t\\t\\tif node.children[c-\\'a\\'] == nil {\\n\\t\\t\\t\\tnode.children[c-\\'a\\'] = &TrieNode{}\\n\\t\\t\\t}\\n\\t\\t\\tnode = node.children[c-\\'a\\']\\n\\t\\t}\\n\\t\\tnode.word = w\\n\\t}\\n\\n\\tresult := make([]string, 0)\\n\\tfor i := 0; i < len(board); i++ {\\n\\t\\tfor j := 0; j < len(board[0]); j++ {\\n\\t\\t\\tdfs(i, j, board, root, &result)\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n\\nfunc dfs(i, j int, board [][]byte, node *TrieNode, result *[]string) {\\n\\tif i < 0 || j < 0 || i == len(board) || j == len(board[0]) {\\n\\t\\treturn\\n\\t}\\n\\tc := board[i][j]\\n\\tif c == \\'#\\' || node.children[c-\\'a\\'] == nil {\\n\\t\\treturn\\n\\t}\\n\\tnode = node.children[c-\\'a\\']\\n\\tif node.word != \"\" {\\n\\t\\t*result = append(*result, node.word)\\n\\t\\tnode.word = \"\"\\n\\t}\\n\\n\\tboard[i][j] = \\'#\\'\\n\\tdfs(i+1, j, board, node, result)\\n\\tdfs(i-1, j, board, node, result)\\n\\tdfs(i, j+1, board, node, result)\\n\\tdfs(i, j-1, board, node, result)\\n\\tboard[i][j] = c\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntype TrieNode struct {\\n\\tword     string\\n\\tchildren [26]*TrieNode\\n}\\n\\nfunc findWords(board [][]byte, words []string) []string {\\n\\troot := &TrieNode{}\\n\\tfor _, w := range words {\\n\\t\\tnode := root\\n\\t\\tfor _, c := range w {\\n\\t\\t\\tif node.children[c-\\'a\\'] == nil {\\n\\t\\t\\t\\tnode.children[c-\\'a\\'] = &TrieNode{}\\n\\t\\t\\t}\\n\\t\\t\\tnode = node.children[c-\\'a\\']\\n\\t\\t}\\n\\t\\tnode.word = w\\n\\t}\\n\\n\\tresult := make([]string, 0)\\n\\tfor i := 0; i < len(board); i++ {\\n\\t\\tfor j := 0; j < len(board[0]); j++ {\\n\\t\\t\\tdfs(i, j, board, root, &result)\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n\\nfunc dfs(i, j int, board [][]byte, node *TrieNode, result *[]string) {\\n\\tif i < 0 || j < 0 || i == len(board) || j == len(board[0]) {\\n\\t\\treturn\\n\\t}\\n\\tc := board[i][j]\\n\\tif c == \\'#\\' || node.children[c-\\'a\\'] == nil {\\n\\t\\treturn\\n\\t}\\n\\tnode = node.children[c-\\'a\\']\\n\\tif node.word != \"\" {\\n\\t\\t*result = append(*result, node.word)\\n\\t\\tnode.word = \"\"\\n\\t}\\n\\n\\tboard[i][j] = \\'#\\'\\n\\tdfs(i+1, j, board, node, result)\\n\\tdfs(i-1, j, board, node, result)\\n\\tdfs(i, j+1, board, node, result)\\n\\tdfs(i, j-1, board, node, result)\\n\\tboard[i][j] = c\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 269110,
                "title": "python-clean-trie-dfs",
                "content": "As each cell value is a character, we can leverage trie to store those target words. And later when we DFS those \"character paths\" in the board, we can check all identical prefixes in the same DFS.\\nE.g. We have target words {\"air\", \"aisle\"}. Without a trie, when we meet an \"a\" in board, we have to perform two seperate DFS for \"air\" and \"aisle\". With a trie, two words share a same prefix of \"a\" and \"i\" so DFS seperates until the 3rd character. This greatly reduces search branch.\\n\\nSo first we store our target words in a trie. I used a \"$\" to mark the end of a word. Later in DFS, when we meet a \"$\" in trie node, we know we have found a word and add it to answer array.\\nThen we run DFS from each cell in the board. In each iteration, we need to temporarily remove the character in the current cell since each character can only be used once. If current cell\\'s character appears in current trie, we go for that subtrie rooted at that node.\\n```\\ndef findWords(board, words):\\n\\ttrie, ans, m, n = {}, set(), len(board), len(board) and len(board[0])\\n\\tfor word in words:\\n\\t\\tnode = trie\\n\\t\\tfor c in word: node = node.setdefault(c, {})\\n\\t\\tnode[\\'$\\'] = None\\n\\tdef dfs(i, j, node, word):\\n\\t\\tif board[i][j] in node:\\n\\t\\t\\tboard[i][j], c = \\'\\', board[i][j]\\n\\t\\t\\tnode, word = node[c], word + c\\n\\t\\t\\tif \\'$\\' in node: ans.add(word)\\n\\t\\t\\tfor x, y in ((i-1,j),(i+1,j),(i,j-1),(i,j+1)):\\n\\t\\t\\t\\tif 0 <= x < m and 0 <= y < n: \\n\\t\\t\\t\\t\\tdfs(x, y, node, word)\\n\\t\\t\\tboard[i][j] = c\\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\tdfs(i, j, trie, \\'\\')\\n\\treturn list(ans)\\n```",
                "solutionTags": [],
                "code": "```\\ndef findWords(board, words):\\n\\ttrie, ans, m, n = {}, set(), len(board), len(board) and len(board[0])\\n\\tfor word in words:\\n\\t\\tnode = trie\\n\\t\\tfor c in word: node = node.setdefault(c, {})\\n\\t\\tnode[\\'$\\'] = None\\n\\tdef dfs(i, j, node, word):\\n\\t\\tif board[i][j] in node:\\n\\t\\t\\tboard[i][j], c = \\'\\', board[i][j]\\n\\t\\t\\tnode, word = node[c], word + c\\n\\t\\t\\tif \\'$\\' in node: ans.add(word)\\n\\t\\t\\tfor x, y in ((i-1,j),(i+1,j),(i,j-1),(i,j+1)):\\n\\t\\t\\t\\tif 0 <= x < m and 0 <= y < n: \\n\\t\\t\\t\\t\\tdfs(x, y, node, word)\\n\\t\\t\\tboard[i][j] = c\\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\tdfs(i, j, trie, \\'\\')\\n\\treturn list(ans)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3207483,
                "title": "c-dfs-solution-without-using-trie",
                "content": "# Intuition\\nThough the problem requires the knowledge of Trie, it can be done without actually using the Trie as well, but proper optimisations in backtracking is required to pass all cases. \\n\\n# Approach\\nOptimisations done to improve the time.\\n- Used unordered_map instead of map\\n- Used prefix hashmap of all words and retured back as soon as prefix isn\\'t present in the hashmap\\n- Precalculated the max length among all words[i] and returned when the recursive call exceeds the max length.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void help(vector<vector<char>>&board,unordered_map<string,int>&mp,string &t,int i,int j,unordered_map<string,int>&store,int len){\\n        if(i>=board.size() || j>=board[0].size() || i<0 || j<0 || board[i][j]==\\'0\\'){return;}\\n        if(store[t]==0){return;}\\n        if(t.size()>=len){return;}\\n        char temp1=board[i][j];\\n        t.push_back(board[i][j]);\\n        board[i][j]=\\'0\\';\\n        mp[t]=1;\\n        help(board,mp,t,i+1,j,store,len);\\n        help(board,mp,t,i,j+1,store,len);\\n        help(board,mp,t,i-1,j,store,len);\\n        help(board,mp,t,i,j-1,store,len);\\n        board[i][j]=temp1;\\n        t.pop_back();\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        unordered_map<string,int>mp;\\n        unordered_map<string,int>store;\\n        int len=0;\\n        string g;\\n        for(int i=0;i<words.size();i++){\\n            g=\"\";\\n            for(int j=0;j<words[i].size();j++){\\n                 g+=words[i][j];\\n                 store[g]=1;\\n            }\\n            len=max(len,(int)words[i].size());\\n        }\\n        string t=\"\";\\n        store[t]=1;\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[0].size();j++){\\n                help(board,mp,t,i,j,store,len);\\n            }\\n        }\\n        vector<string>ans;\\n        for(auto x:words){\\n            if(mp[x]){\\n                ans.push_back(x);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void help(vector<vector<char>>&board,unordered_map<string,int>&mp,string &t,int i,int j,unordered_map<string,int>&store,int len){\\n        if(i>=board.size() || j>=board[0].size() || i<0 || j<0 || board[i][j]==\\'0\\'){return;}\\n        if(store[t]==0){return;}\\n        if(t.size()>=len){return;}\\n        char temp1=board[i][j];\\n        t.push_back(board[i][j]);\\n        board[i][j]=\\'0\\';\\n        mp[t]=1;\\n        help(board,mp,t,i+1,j,store,len);\\n        help(board,mp,t,i,j+1,store,len);\\n        help(board,mp,t,i-1,j,store,len);\\n        help(board,mp,t,i,j-1,store,len);\\n        board[i][j]=temp1;\\n        t.pop_back();\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        unordered_map<string,int>mp;\\n        unordered_map<string,int>store;\\n        int len=0;\\n        string g;\\n        for(int i=0;i<words.size();i++){\\n            g=\"\";\\n            for(int j=0;j<words[i].size();j++){\\n                 g+=words[i][j];\\n                 store[g]=1;\\n            }\\n            len=max(len,(int)words[i].size());\\n        }\\n        string t=\"\";\\n        store[t]=1;\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[0].size();j++){\\n                help(board,mp,t,i,j,store,len);\\n            }\\n        }\\n        vector<string>ans;\\n        for(auto x:words){\\n            if(mp[x]){\\n                ans.push_back(x);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2954040,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass TrieNode{\\npublic:\\n    bool is_end;\\n    vector<TrieNode*> children;\\n    TrieNode(){\\n        is_end=false;\\n        children=vector<TrieNode*>(26, NULL);\\n    }   \\n};\\nclass Solution {\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        root=new TrieNode();\\n        for(int i=0;i<words.size();i++)\\n        {\\n            TrieNode* cur=root;\\n            for(int j=0;j<words[i].size();j++)\\n            {\\n                int k=words[i][j]-\\'a\\';\\n                if(cur->children[k]==NULL)\\n                    cur->children[k]=new TrieNode();\\n                cur=cur->children[k];\\n            }\\n            cur->is_end=true;\\n        }\\n        vector<string> ans;\\n        for(int i=0;i<board.size();i++)\\n        {\\n            for(int j=0;j<board[0].size();j++)\\n            {\\n                search(board, root, \"\", ans, i, j);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    void search(vector<vector<char>>& board, TrieNode* root, string word, vector<string>& s, int x, int y)\\n    {\\n        if(root->is_end)\\n        {\\n            s.push_back(word);\\n            root->is_end = false;\\n        }\\n        if(x<0 || y<0 || x>=board.size() || y>=board[0].size() || board[x][y]==\\'.\\')\\n            return;\\n        char c=board[x][y];\\n        int k=c-\\'a\\';\\n        if(root->children[k]==NULL)\\n            return;\\n        root=root->children[k];\\n        board[x][y]=\\'.\\';\\n        word+=c;\\n        search(board, root, word, s, x+1, y);\\n        search(board, root, word, s, x-1, y);\\n        search(board, root, word, s, x, y+1);\\n        search(board, root, word, s, x, y-1);\\n        board[x][y]=c;\\n    }\\n    TrieNode* root;\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass TrieNode{\\npublic:\\n    bool is_end;\\n    vector<TrieNode*> children;\\n    TrieNode(){\\n        is_end=false;\\n        children=vector<TrieNode*>(26, NULL);\\n    }   \\n};\\nclass Solution {\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        root=new TrieNode();\\n        for(int i=0;i<words.size();i++)\\n        {\\n            TrieNode* cur=root;\\n            for(int j=0;j<words[i].size();j++)\\n            {\\n                int k=words[i][j]-\\'a\\';\\n                if(cur->children[k]==NULL)\\n                    cur->children[k]=new TrieNode();\\n                cur=cur->children[k];\\n            }\\n            cur->is_end=true;\\n        }\\n        vector<string> ans;\\n        for(int i=0;i<board.size();i++)\\n        {\\n            for(int j=0;j<board[0].size();j++)\\n            {\\n                search(board, root, \"\", ans, i, j);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    void search(vector<vector<char>>& board, TrieNode* root, string word, vector<string>& s, int x, int y)\\n    {\\n        if(root->is_end)\\n        {\\n            s.push_back(word);\\n            root->is_end = false;\\n        }\\n        if(x<0 || y<0 || x>=board.size() || y>=board[0].size() || board[x][y]==\\'.\\')\\n            return;\\n        char c=board[x][y];\\n        int k=c-\\'a\\';\\n        if(root->children[k]==NULL)\\n            return;\\n        root=root->children[k];\\n        board[x][y]=\\'.\\';\\n        word+=c;\\n        search(board, root, word, s, x+1, y);\\n        search(board, root, word, s, x-1, y);\\n        search(board, root, word, s, x, y+1);\\n        search(board, root, word, s, x, y-1);\\n        board[x][y]=c;\\n    }\\n    TrieNode* root;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782247,
                "title": "python-and-golang-4ms-100",
                "content": "<img src=\"https://assets.leetcode.com/users/images/592567a9-4b22-46f1-a1ed-75b7499fbc41_1667673644.841407.png\" width=\"500\"/>\\n\\n```python\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        \\n        m, n = len(board), len(board[0])\\n        res, trie, has = list(), dict(), set()\\n        \\n        for r in range(m):\\n            for c in range(n - 1):\\n                has.add(board[r][c] + board[r][c + 1])\\n        for r in range(m - 1):\\n            for c in range(n):\\n                has.add(board[r][c] + board[r + 1][c])\\n        \\n        for word in words:\\n            for i in range(len(word) - 1):\\n                a, b = word[i], word[i + 1]\\n                if a + b not in has and b + a not in has:\\n                    break\\n            else:\\n                cur = trie\\n                for c in word:\\n                    if c not in cur: cur[c] = {}\\n                    cur = cur[c]\\n                cur[\\'*\\'] = word\\n        \\n        def dfs(r, c, node):\\n            node = node[board[r][c]]\\n            if \\'*\\' in node:\\n                res.append(node[\\'*\\'])\\n                del node[\\'*\\']\\n            rc = board[r][c]\\n            board[r][c] = \\'*\\'\\n            for i, j in (0, 1), (1, 0), (0, -1), (-1, 0):\\n                dr, dc = r + i, c + j\\n                if dr < 0 or dr >= m or dc < 0 or dc >= n \\\\\\n                or board[dr][dc] not in node:\\n                    continue\\n                dfs(dr, dc, node)\\n                if len(node[board[dr][dc]]) == 0:\\n                    del node[board[dr][dc]]\\n            board[r][c] = rc\\n        \\n        for r in range(m):\\n            for c in range(n):\\n                if board[r][c] in trie:\\n                    dfs(r, c, trie)\\n        \\n        return res\\n```\\n```go\\ntype Node struct {\\n\\tchildren [26]*Node\\n\\tword     string\\n}\\n\\nfunc (n *Node) Insert(word string) {\\n\\tcur := n\\n\\tfor _, c := range word {\\n\\t\\tidx := c - \\'a\\'\\n\\t\\tif cur.children[idx] == nil {\\n\\t\\t\\tcur.children[idx] = &Node{}\\n\\t\\t}\\n\\t\\tcur = cur.children[idx]\\n\\t}\\n\\tcur.word = word\\n}\\n\\nfunc (n *Node) IsEmpty() bool {\\n\\tfor _, child := range n.children {\\n\\t\\tif child != nil {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n\\nfunc (n *Node) Remove(word string) bool {\\n\\tif len(word) == 0 {\\n\\t\\tn.word = \"\"\\n\\t\\treturn n.IsEmpty()\\n\\t}\\n\\tchild := n.children[word[0]-\\'a\\']\\n\\tif child.Remove(word[1:]) {\\n\\t\\tn.children[word[0]-\\'a\\'] = nil\\n\\t\\treturn n.IsEmpty()\\n\\t}\\n\\treturn false\\n}\\n\\nfunc dfs(board [][]byte, r, c int, root, cur *Node, res *[]string) {\\n\\trc := board[r][c]\\n\\tboard[r][c] = 0\\n    \\n\\tif cur.word != \"\" {\\n\\t\\t*res = append(*res, cur.word)\\n\\t\\troot.Remove(cur.word)\\n\\t}\\n\\tds := [5]int{0, 1, 0, -1, 0}\\n\\tfor i := 0; i < len(ds)-1; i++ {\\n\\t\\tdr, dc := r+ds[i], c+ds[i+1]\\n\\t\\tif dr < 0 || dr >= len(board) || dc < 0 || dc >= len(board[0]) {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tb := board[dr][dc]\\n\\t\\tif b == 0 || cur.children[b-\\'a\\'] == nil {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tdfs(board, dr, dc, root, cur.children[b-\\'a\\'], res)\\n\\t}\\n\\tboard[r][c] = rc\\n}\\n\\nfunc findWords(board [][]byte, words []string) []string {\\n\\tm, n := len(board), len(board[0])\\n\\tres, trie, has := []string{}, &Node{}, map[string]bool{}\\n\\n\\tfor r := 0; r < m; r++ {\\n\\t\\tfor c := 0; c < n-1; c++ {\\n\\t\\t\\tp := string(board[r][c]) + string(board[r][c+1])\\n\\t\\t\\thas[p] = true\\n\\t\\t}\\n\\t}\\n\\tfor r := 0; r < m-1; r++ {\\n\\t\\tfor c := 0; c < n; c++ {\\n\\t\\t\\tp := string(board[r][c]) + string(board[r+1][c])\\n\\t\\t\\thas[p] = true\\n\\t\\t}\\n\\t}\\n\\tfor _, word := range words {\\n\\t\\tvalid := true\\n\\t\\tfor i := 0; i < len(word)-1; i++ {\\n\\t\\t\\ta, b := string(word[i]), string(word[i+1])\\n\\t\\t\\tif !has[a+b] && !has[b+a] {\\n\\t\\t\\t\\tvalid = false\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif valid {\\n\\t\\t\\ttrie.Insert(word)\\n\\t\\t}\\n\\t}\\n\\tfor r := 0; r < m; r++ {\\n\\t\\tfor c := 0; c < n; c++ {\\n\\t\\t\\tb := board[r][c]\\n\\t\\t\\tif trie.children[b-\\'a\\'] != nil {\\n\\t\\t\\t\\tdfs(board, r, c, trie, trie.children[b-\\'a\\'], &res)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "Go"
                ],
                "code": "```python\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        \\n        m, n = len(board), len(board[0])\\n        res, trie, has = list(), dict(), set()\\n        \\n        for r in range(m):\\n            for c in range(n - 1):\\n                has.add(board[r][c] + board[r][c + 1])\\n        for r in range(m - 1):\\n            for c in range(n):\\n                has.add(board[r][c] + board[r + 1][c])\\n        \\n        for word in words:\\n            for i in range(len(word) - 1):\\n                a, b = word[i], word[i + 1]\\n                if a + b not in has and b + a not in has:\\n                    break\\n            else:\\n                cur = trie\\n                for c in word:\\n                    if c not in cur: cur[c] = {}\\n                    cur = cur[c]\\n                cur[\\'*\\'] = word\\n        \\n        def dfs(r, c, node):\\n            node = node[board[r][c]]\\n            if \\'*\\' in node:\\n                res.append(node[\\'*\\'])\\n                del node[\\'*\\']\\n            rc = board[r][c]\\n            board[r][c] = \\'*\\'\\n            for i, j in (0, 1), (1, 0), (0, -1), (-1, 0):\\n                dr, dc = r + i, c + j\\n                if dr < 0 or dr >= m or dc < 0 or dc >= n \\\\\\n                or board[dr][dc] not in node:\\n                    continue\\n                dfs(dr, dc, node)\\n                if len(node[board[dr][dc]]) == 0:\\n                    del node[board[dr][dc]]\\n            board[r][c] = rc\\n        \\n        for r in range(m):\\n            for c in range(n):\\n                if board[r][c] in trie:\\n                    dfs(r, c, trie)\\n        \\n        return res\\n```\n```go\\ntype Node struct {\\n\\tchildren [26]*Node\\n\\tword     string\\n}\\n\\nfunc (n *Node) Insert(word string) {\\n\\tcur := n\\n\\tfor _, c := range word {\\n\\t\\tidx := c - \\'a\\'\\n\\t\\tif cur.children[idx] == nil {\\n\\t\\t\\tcur.children[idx] = &Node{}\\n\\t\\t}\\n\\t\\tcur = cur.children[idx]\\n\\t}\\n\\tcur.word = word\\n}\\n\\nfunc (n *Node) IsEmpty() bool {\\n\\tfor _, child := range n.children {\\n\\t\\tif child != nil {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n\\nfunc (n *Node) Remove(word string) bool {\\n\\tif len(word) == 0 {\\n\\t\\tn.word = \"\"\\n\\t\\treturn n.IsEmpty()\\n\\t}\\n\\tchild := n.children[word[0]-\\'a\\']\\n\\tif child.Remove(word[1:]) {\\n\\t\\tn.children[word[0]-\\'a\\'] = nil\\n\\t\\treturn n.IsEmpty()\\n\\t}\\n\\treturn false\\n}\\n\\nfunc dfs(board [][]byte, r, c int, root, cur *Node, res *[]string) {\\n\\trc := board[r][c]\\n\\tboard[r][c] = 0\\n    \\n\\tif cur.word != \"\" {\\n\\t\\t*res = append(*res, cur.word)\\n\\t\\troot.Remove(cur.word)\\n\\t}\\n\\tds := [5]int{0, 1, 0, -1, 0}\\n\\tfor i := 0; i < len(ds)-1; i++ {\\n\\t\\tdr, dc := r+ds[i], c+ds[i+1]\\n\\t\\tif dr < 0 || dr >= len(board) || dc < 0 || dc >= len(board[0]) {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tb := board[dr][dc]\\n\\t\\tif b == 0 || cur.children[b-\\'a\\'] == nil {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tdfs(board, dr, dc, root, cur.children[b-\\'a\\'], res)\\n\\t}\\n\\tboard[r][c] = rc\\n}\\n\\nfunc findWords(board [][]byte, words []string) []string {\\n\\tm, n := len(board), len(board[0])\\n\\tres, trie, has := []string{}, &Node{}, map[string]bool{}\\n\\n\\tfor r := 0; r < m; r++ {\\n\\t\\tfor c := 0; c < n-1; c++ {\\n\\t\\t\\tp := string(board[r][c]) + string(board[r][c+1])\\n\\t\\t\\thas[p] = true\\n\\t\\t}\\n\\t}\\n\\tfor r := 0; r < m-1; r++ {\\n\\t\\tfor c := 0; c < n; c++ {\\n\\t\\t\\tp := string(board[r][c]) + string(board[r+1][c])\\n\\t\\t\\thas[p] = true\\n\\t\\t}\\n\\t}\\n\\tfor _, word := range words {\\n\\t\\tvalid := true\\n\\t\\tfor i := 0; i < len(word)-1; i++ {\\n\\t\\t\\ta, b := string(word[i]), string(word[i+1])\\n\\t\\t\\tif !has[a+b] && !has[b+a] {\\n\\t\\t\\t\\tvalid = false\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif valid {\\n\\t\\t\\ttrie.Insert(word)\\n\\t\\t}\\n\\t}\\n\\tfor r := 0; r < m; r++ {\\n\\t\\tfor c := 0; c < n; c++ {\\n\\t\\t\\tb := board[r][c]\\n\\t\\t\\tif trie.children[b-\\'a\\'] != nil {\\n\\t\\t\\t\\tdfs(board, r, c, trie, trie.children[b-\\'a\\'], &res)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780094,
                "title": "c-solution",
                "content": "``` C++ []\\nclass Solution {\\n    struct TreeNode {\\n        TreeNode *children[26];\\n        string word;\\n\\n        TreeNode() : word(\"\") {\\n            for (int i = 0; i < 26; i++) {\\n                children[i] = nullptr;\\n            }\\n        }\\n    };\\n\\npublic:\\n    vector<string> findWords(vector<vector<char>> &board, vector<string> &words) {\\n        TreeNode *root = BuildTree(words);\\n        vector<string> result;\\n        for (int i = 0; i < board.size(); i++) {\\n            for (int j = 0; j < board[0].size(); j++) {\\n                dfs(board, i, j, root, result);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    TreeNode *BuildTree(vector<string> &words) {\\n        TreeNode *root = new TreeNode();\\n        for (int j = 0; j < words.size(); j++) {\\n            string word = words[j];\\n            TreeNode *curr = root;\\n            for (int i = 0; i < word.length(); i++) {\\n                char c = word[i] - \\'a\\';\\n                if (curr->children[c] == nullptr) {\\n                    curr->children[c] = new TreeNode();\\n                }\\n                curr = curr->children[c];\\n            }\\n            curr->word = word;\\n        }\\n        return root;\\n    }\\n\\n    void dfs(vector<vector<char>> &board, int i, int j, TreeNode *p, vector<string> &result) {\\n        char c = board[i][j];\\n        if (c == \\'#\\' || !p->children[c - \\'a\\']) return;\\n        p = p->children[c - \\'a\\'];\\n        if (p->word.size() > 0) {\\n            result.push_back(p->word);\\n            p->word = \"\";\\n        }\\n\\n        board[i][j] = \\'#\\';\\n        if (i > 0) dfs(board, i - 1, j, p, result);\\n        if (j > 0) dfs(board, i, j - 1, p, result);\\n        if (i < board.size() - 1) dfs(board, i + 1, j, p, result);\\n        if (j < board[0].size() - 1) dfs(board, i, j + 1, p, result);\\n        board[i][j] = c;\\n    }\\n};\\n```\\n\\n*Upvote if it helped you!*",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "``` C++ []\\nclass Solution {\\n    struct TreeNode {\\n        TreeNode *children[26];\\n        string word;\\n\\n        TreeNode() : word(\"\") {\\n            for (int i = 0; i < 26; i++) {\\n                children[i] = nullptr;\\n            }\\n        }\\n    };\\n\\npublic:\\n    vector<string> findWords(vector<vector<char>> &board, vector<string> &words) {\\n        TreeNode *root = BuildTree(words);\\n        vector<string> result;\\n        for (int i = 0; i < board.size(); i++) {\\n            for (int j = 0; j < board[0].size(); j++) {\\n                dfs(board, i, j, root, result);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    TreeNode *BuildTree(vector<string> &words) {\\n        TreeNode *root = new TreeNode();\\n        for (int j = 0; j < words.size(); j++) {\\n            string word = words[j];\\n            TreeNode *curr = root;\\n            for (int i = 0; i < word.length(); i++) {\\n                char c = word[i] - \\'a\\';\\n                if (curr->children[c] == nullptr) {\\n                    curr->children[c] = new TreeNode();\\n                }\\n                curr = curr->children[c];\\n            }\\n            curr->word = word;\\n        }\\n        return root;\\n    }\\n\\n    void dfs(vector<vector<char>> &board, int i, int j, TreeNode *p, vector<string> &result) {\\n        char c = board[i][j];\\n        if (c == \\'#\\' || !p->children[c - \\'a\\']) return;\\n        p = p->children[c - \\'a\\'];\\n        if (p->word.size() > 0) {\\n            result.push_back(p->word);\\n            p->word = \"\";\\n        }\\n\\n        board[i][j] = \\'#\\';\\n        if (i > 0) dfs(board, i - 1, j, p, result);\\n        if (j > 0) dfs(board, i, j - 1, p, result);\\n        if (i < board.size() - 1) dfs(board, i + 1, j, p, result);\\n        if (j < board[0].size() - 1) dfs(board, i, j + 1, p, result);\\n        board[i][j] = c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779796,
                "title": "optimised-with-trie",
                "content": "## Approach 1 : Brute Force\\n\\nfor every position in the board, dfs with it as the starting point and check if a word from the dictionary can be formed\\n```\\nclass Solution {\\n    void dfs(char board[][], boolean visited[][], int x, int y, String pick, HashSet<String> dictionary, List<String> res)\\n    {\\n        if(dictionary.contains(pick)) {\\n            res.add(pick);\\n        }\\n        int dx[]={0, 0, 1, -1}, dy[]={-1, 1, 0, 0};\\n        visited[x][y]=true;\\n        for(int i=0; i<4; i++)\\n        {\\n            int m = x + dx[i], n = y + dy[i];\\n            boolean inBounds = -1<m && m<board.length && -1<n && n<board[m].length;\\n            if(inBounds && !visited[m][n])\\n                dfs(board, visited, m, n, pick+board[m][n], dictionary, res);\\n        }\\n        visited[x][y] = false;\\n    }\\n    \\n    public List<String> findWords(char[][] board, String[] words) {\\n        HashSet<String> dictionary=new HashSet<>();\\n        for(String word : words) dictionary.add(word);\\n        List<String> res=new ArrayList<>();\\n        boolean visited[][]=new boolean[board.length][board[0].length];\\n        \\n        //1. dfs and match\\n        for(int i=0; i<board.length; i++)\\n        {\\n            for(int j=0; j<board[i].length; j++)\\n                dfs(board, visited, i, j, Character.toString(board[i][j]), dictionary, res);\\n        }        \\n        \\n        return res;\\n    }\\n}\\n```\\n\\n## Approach 2 : Trie + DP\\nstore the dictionary as a trie instead of a set, and at every state of the search, only go for neighbours that shall end up in forming a word (using trie).\\n```\\nclass Node {\\n    char c;\\n    Node children[];\\n    boolean end;\\n    Node(char c)\\n    {\\n        this.c = c;\\n        children = new Node[26];\\n        end = false;\\n    }\\n}\\n\\nclass Solution {\\n    \\n    void dfs(char board[][], boolean[][] visited, int x, int y, Node node, HashSet<Node> res)\\n    {\\n        if(node.end) res.add(node);\\n        int dx[]={0, 0, 1, -1}, dy[]={-1, 1, 0, 0};\\n        visited[x][y]=true;\\n        for(int i=0; i<4; i++)\\n        {\\n            int m = x + dx[i], n = y + dy[i];\\n            boolean inBounds = -1<m && m<board.length && -1<n && n<board[m].length;\\n            if(inBounds && !visited[m][n] && node.children[board[m][n] - \\'a\\'] != null)\\n            {\\n                dfs(board, visited, m, n, node.children[board[m][n] - \\'a\\'], res);\\n            }\\n        }\\n        visited[x][y] = false;\\n    }\\n    \\n    public List<String> findWords(char[][] board, String[] words) {\\n        //1. make trie, map end nodes with Strings\\n        HashMap<Node, String> nodeString = new HashMap<>();\\n        Node root = new Node(\\'\\\\0\\');\\n        for(String word : words)\\n        {\\n            Node node=root;\\n            for(int i=0; i<word.length(); i++)\\n            {\\n                char c = word.charAt(i);\\n                if(node.children[c - \\'a\\'] == null) node.children[c - \\'a\\'] = new Node (c);\\n                node = node.children[c - \\'a\\'];\\n            }\\n            node.end = true;\\n            nodeString.put(node, word);\\n        }\\n        \\n        //2. make visited board\\n        boolean visited[][] = new boolean[board.length][board[0].length];\\n        \\n        HashSet<Node> res = new HashSet<>();\\n        //3. greedy dfs board\\n        \\n        for(int i=0; i<board.length; i++)\\n        {\\n            for(int j=0; j<board[i].length; j++)\\n            {\\n                Node node = root;\\n                if(node.children[board[i][j] - \\'a\\'] != null)\\n                    dfs(board, visited, i, j, node.children[board[i][j] - \\'a\\'], res);\\n            }\\n        }\\n        \\n        //4. result\\n        List<String> ans = new ArrayList<>();\\n        for(Node node : res) ans.add(nodeString.get(node));\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search",
                    "Trie",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(char board[][], boolean visited[][], int x, int y, String pick, HashSet<String> dictionary, List<String> res)\\n    {\\n        if(dictionary.contains(pick)) {\\n            res.add(pick);\\n        }\\n        int dx[]={0, 0, 1, -1}, dy[]={-1, 1, 0, 0};\\n        visited[x][y]=true;\\n        for(int i=0; i<4; i++)\\n        {\\n            int m = x + dx[i], n = y + dy[i];\\n            boolean inBounds = -1<m && m<board.length && -1<n && n<board[m].length;\\n            if(inBounds && !visited[m][n])\\n                dfs(board, visited, m, n, pick+board[m][n], dictionary, res);\\n        }\\n        visited[x][y] = false;\\n    }\\n    \\n    public List<String> findWords(char[][] board, String[] words) {\\n        HashSet<String> dictionary=new HashSet<>();\\n        for(String word : words) dictionary.add(word);\\n        List<String> res=new ArrayList<>();\\n        boolean visited[][]=new boolean[board.length][board[0].length];\\n        \\n        //1. dfs and match\\n        for(int i=0; i<board.length; i++)\\n        {\\n            for(int j=0; j<board[i].length; j++)\\n                dfs(board, visited, i, j, Character.toString(board[i][j]), dictionary, res);\\n        }        \\n        \\n        return res;\\n    }\\n}\\n```\n```\\nclass Node {\\n    char c;\\n    Node children[];\\n    boolean end;\\n    Node(char c)\\n    {\\n        this.c = c;\\n        children = new Node[26];\\n        end = false;\\n    }\\n}\\n\\nclass Solution {\\n    \\n    void dfs(char board[][], boolean[][] visited, int x, int y, Node node, HashSet<Node> res)\\n    {\\n        if(node.end) res.add(node);\\n        int dx[]={0, 0, 1, -1}, dy[]={-1, 1, 0, 0};\\n        visited[x][y]=true;\\n        for(int i=0; i<4; i++)\\n        {\\n            int m = x + dx[i], n = y + dy[i];\\n            boolean inBounds = -1<m && m<board.length && -1<n && n<board[m].length;\\n            if(inBounds && !visited[m][n] && node.children[board[m][n] - \\'a\\'] != null)\\n            {\\n                dfs(board, visited, m, n, node.children[board[m][n] - \\'a\\'], res);\\n            }\\n        }\\n        visited[x][y] = false;\\n    }\\n    \\n    public List<String> findWords(char[][] board, String[] words) {\\n        //1. make trie, map end nodes with Strings\\n        HashMap<Node, String> nodeString = new HashMap<>();\\n        Node root = new Node(\\'\\\\0\\');\\n        for(String word : words)\\n        {\\n            Node node=root;\\n            for(int i=0; i<word.length(); i++)\\n            {\\n                char c = word.charAt(i);\\n                if(node.children[c - \\'a\\'] == null) node.children[c - \\'a\\'] = new Node (c);\\n                node = node.children[c - \\'a\\'];\\n            }\\n            node.end = true;\\n            nodeString.put(node, word);\\n        }\\n        \\n        //2. make visited board\\n        boolean visited[][] = new boolean[board.length][board[0].length];\\n        \\n        HashSet<Node> res = new HashSet<>();\\n        //3. greedy dfs board\\n        \\n        for(int i=0; i<board.length; i++)\\n        {\\n            for(int j=0; j<board[i].length; j++)\\n            {\\n                Node node = root;\\n                if(node.children[board[i][j] - \\'a\\'] != null)\\n                    dfs(board, visited, i, j, node.children[board[i][j] - \\'a\\'], res);\\n            }\\n        }\\n        \\n        //4. result\\n        List<String> ans = new ArrayList<>();\\n        for(Node node : res) ans.add(nodeString.get(node));\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779714,
                "title": "js-multiple-approaches-easy-to-understand",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com/2022/11/word-search-ii.html\\nIt has solutions to almost every problem on Leetcode, and I recommend checking it out.\\nNote: You can bookmark it as a resource, and approach. Other approaches are in above blog\\n<br>\\n\\n```\\n/**\\n * @param {character[][]} board\\n * @param {string[]} words\\n * @return {string[]}\\n */\\n\\nconst endWord = \\'*\\'\\n\\nclass Trie{\\n    constructor(words){\\n        this.root = {}\\n        this.isWord = false\\n        words.forEach(word => this.addWord(word))\\n    }\\n    \\n    addWord(word){\\n        let current = this.root\\n        \\n        for(const letter of word){\\n            if(!current[letter]){\\n                current[letter] = {}\\n            }\\n            current = current[letter]   \\n        }\\n        current.isWord = true\\n    }\\n    \\n}\\n\\n\\nvar findWords = function(board, words) {\\n    const trie = new Trie(words)\\n    const result = new Set()\\n    \\n    const visited = new Set()\\n    \\n    const dfs = (i, j, node, subResult) => {\\n        //base cases: out of bounds, letter does not exist in next prefix\\n        if(i < 0 || i >= board.length || j < 0 || j >= board[0].length || !node[board[i][j]] || visited.has(`${i} ${j}`)){\\n            return\\n        }\\n        \\n        visited.add(`${i} ${j}`)\\n        subResult += board[i][j]\\n        \\n        node = node[board[i][j]]\\n        \\n        if(node.isWord){\\n            result.add(subResult)    \\n        }\\n        \\n        dfs(i, j+1, node, subResult)\\n        dfs(i, j-1, node, subResult)\\n        dfs(i-1, j, node, subResult)\\n        dfs(i+1, j, node, subResult)\\n        \\n        \\n        visited.delete(`${i} ${j}`)\\n        \\n    }\\n    \\n    for(let i = 0; i < board.length; i++){\\n        for(let j = 0; j < board[0].length; j++){\\n            if(trie.root[board[i][j]]){\\n                dfs(i, j, trie.root, \"\")\\n            }\\n        }\\n    }\\n    \\n    \\n    return [...result]\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {character[][]} board\\n * @param {string[]} words\\n * @return {string[]}\\n */\\n\\nconst endWord = \\'*\\'\\n\\nclass Trie{\\n    constructor(words){\\n        this.root = {}\\n        this.isWord = false\\n        words.forEach(word => this.addWord(word))\\n    }\\n    \\n    addWord(word){\\n        let current = this.root\\n        \\n        for(const letter of word){\\n            if(!current[letter]){\\n                current[letter] = {}\\n            }\\n            current = current[letter]   \\n        }\\n        current.isWord = true\\n    }\\n    \\n}\\n\\n\\nvar findWords = function(board, words) {\\n    const trie = new Trie(words)\\n    const result = new Set()\\n    \\n    const visited = new Set()\\n    \\n    const dfs = (i, j, node, subResult) => {\\n        //base cases: out of bounds, letter does not exist in next prefix\\n        if(i < 0 || i >= board.length || j < 0 || j >= board[0].length || !node[board[i][j]] || visited.has(`${i} ${j}`)){\\n            return\\n        }\\n        \\n        visited.add(`${i} ${j}`)\\n        subResult += board[i][j]\\n        \\n        node = node[board[i][j]]\\n        \\n        if(node.isWord){\\n            result.add(subResult)    \\n        }\\n        \\n        dfs(i, j+1, node, subResult)\\n        dfs(i, j-1, node, subResult)\\n        dfs(i-1, j, node, subResult)\\n        dfs(i+1, j, node, subResult)\\n        \\n        \\n        visited.delete(`${i} ${j}`)\\n        \\n    }\\n    \\n    for(let i = 0; i < board.length; i++){\\n        for(let j = 0; j < board[0].length; j++){\\n            if(trie.root[board[i][j]]){\\n                dfs(i, j, trie.root, \"\")\\n            }\\n        }\\n    }\\n    \\n    \\n    return [...result]\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2104770,
                "title": "get-to-99-with-one-hack",
                "content": "Just filter out words that are not possible on board and due to the way test cases are structured, just construct trie with words reversed. Just remove reversed keyword to have your old solution xD\\n```\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :type words: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        if not board or not words: return []\\n        boardc = collections.Counter(sum(board,[]))\\n        words = [word for word in words if collections.Counter(word) <= boardc]\\n        trie = {}\\n        for word in words:\\n            node = trie\\n            for c in reversed(word):\\n                node = node.setdefault(c, {})\\n            node[\\'$\\'] = word\\n            \\n        def find(i,j,node):\\n            if \\'$\\' in node: out.append(node.pop(\\'$\\'))\\n            if not node: return\\n            tmp, board[i][j] = board[i][j], \\'#\\'\\n            \\n            for dx,dy in [(i+1, j),(i-1,j), (i,j+1), (i,j-1)]:\\n                if 0<=dx<m and 0<=dy<n and board[dx][dy] in node:\\n                    find(dx,dy,node[board[dx][dy]])\\n                    if not node[board[dx][dy]]: node.pop(board[dx][dy])\\n            board[i][j] = tmp\\n            \\n            return 0\\n                    \\n        m, n = len(board), len(board[0])\\n        out = []\\n        for i in range(m):\\n            for j in range(n):\\n                if board[i][j] in trie:\\n                    find(i,j,trie[board[i][j]])\\n                    if not trie[board[i][j]]: trie.pop(board[i][j])\\n                if len(words) == len(out): return out\\n        return out\\n```",
                "solutionTags": [
                    "Python",
                    "Trie"
                ],
                "code": "```\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :type words: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        if not board or not words: return []\\n        boardc = collections.Counter(sum(board,[]))\\n        words = [word for word in words if collections.Counter(word) <= boardc]\\n        trie = {}\\n        for word in words:\\n            node = trie\\n            for c in reversed(word):\\n                node = node.setdefault(c, {})\\n            node[\\'$\\'] = word\\n            \\n        def find(i,j,node):\\n            if \\'$\\' in node: out.append(node.pop(\\'$\\'))\\n            if not node: return\\n            tmp, board[i][j] = board[i][j], \\'#\\'\\n            \\n            for dx,dy in [(i+1, j),(i-1,j), (i,j+1), (i,j-1)]:\\n                if 0<=dx<m and 0<=dy<n and board[dx][dy] in node:\\n                    find(dx,dy,node[board[dx][dy]])\\n                    if not node[board[dx][dy]]: node.pop(board[dx][dy])\\n            board[i][j] = tmp\\n            \\n            return 0\\n                    \\n        m, n = len(board), len(board[0])\\n        out = []\\n        for i in range(m):\\n            for j in range(n):\\n                if board[i][j] in trie:\\n                    find(i,j,trie[board[i][j]])\\n                    if not trie[board[i][j]]: trie.pop(board[i][j])\\n                if len(words) == len(out): return out\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1512832,
                "title": "clean-go-solution-using-trie-and-dfs",
                "content": "```\\nvar directions = [][2]int{{1, 0}, {-1, 0}, {0, 1}, {0, -1}}\\n\\nfunc findWords(board [][]byte, words []string) []string {\\n\\ttrie := new(TrieNode)\\n\\tfor _, word := range words {\\n\\t\\ttrie.insert(word)\\n\\t}\\n\\n\\tresult := make([]string, 0, len(words))\\n\\tfor i, row := range board {\\n\\t\\tfor j, ch := range row {\\n\\t\\t\\tidx := ch - \\'a\\'\\n\\t\\t\\tif tn := trie.Children[idx]; tn != nil {\\n\\t\\t\\t\\tdfs(board, i, j, trie, &result)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n\\nfunc dfs(board [][]byte, i, j int, node *TrieNode, result *[]string) {\\n\\tletter := board[i][j]\\n\\tnode = node.Children[letter-\\'a\\']\\n\\tif node == nil {\\n\\t\\treturn\\n\\t} else if node.Word != \"\" {\\n\\t\\t*result = append(*result, node.Word)\\n\\t\\tnode.Word = \"\"\\n\\t}\\n\\n\\tboard[i][j] = \\'.\\'\\n\\tfor _, dir := range directions {\\n\\t\\tx, y := i+dir[0], j+dir[1]\\n\\t\\tif x >= 0 && x < len(board) && y >= 0 && y < len(board[0]) && board[x][y] != \\'.\\' {\\n\\t\\t\\tdfs(board, x, y, node, result)\\n\\t\\t}\\n\\t}\\n\\tboard[i][j] = letter\\n}\\n\\ntype TrieNode struct {\\n\\tChildren [26]*TrieNode\\n\\tWord     string\\n}\\n\\nfunc (tn *TrieNode) insert(word string) {\\n\\tfor _, ch := range word {\\n\\t\\tidx := ch - \\'a\\'\\n\\t\\tif tn.Children[idx] == nil {\\n\\t\\t\\ttn.Children[idx] = new(TrieNode)\\n\\t\\t}\\n\\t\\ttn = tn.Children[idx]\\n\\t}\\n\\ttn.Word = word\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nvar directions = [][2]int{{1, 0}, {-1, 0}, {0, 1}, {0, -1}}\\n\\nfunc findWords(board [][]byte, words []string) []string {\\n\\ttrie := new(TrieNode)\\n\\tfor _, word := range words {\\n\\t\\ttrie.insert(word)\\n\\t}\\n\\n\\tresult := make([]string, 0, len(words))\\n\\tfor i, row := range board {\\n\\t\\tfor j, ch := range row {\\n\\t\\t\\tidx := ch - \\'a\\'\\n\\t\\t\\tif tn := trie.Children[idx]; tn != nil {\\n\\t\\t\\t\\tdfs(board, i, j, trie, &result)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n\\nfunc dfs(board [][]byte, i, j int, node *TrieNode, result *[]string) {\\n\\tletter := board[i][j]\\n\\tnode = node.Children[letter-\\'a\\']\\n\\tif node == nil {\\n\\t\\treturn\\n\\t} else if node.Word != \"\" {\\n\\t\\t*result = append(*result, node.Word)\\n\\t\\tnode.Word = \"\"\\n\\t}\\n\\n\\tboard[i][j] = \\'.\\'\\n\\tfor _, dir := range directions {\\n\\t\\tx, y := i+dir[0], j+dir[1]\\n\\t\\tif x >= 0 && x < len(board) && y >= 0 && y < len(board[0]) && board[x][y] != \\'.\\' {\\n\\t\\t\\tdfs(board, x, y, node, result)\\n\\t\\t}\\n\\t}\\n\\tboard[i][j] = letter\\n}\\n\\ntype TrieNode struct {\\n\\tChildren [26]*TrieNode\\n\\tWord     string\\n}\\n\\nfunc (tn *TrieNode) insert(word string) {\\n\\tfor _, ch := range word {\\n\\t\\tidx := ch - \\'a\\'\\n\\t\\tif tn.Children[idx] == nil {\\n\\t\\t\\ttn.Children[idx] = new(TrieNode)\\n\\t\\t}\\n\\t\\ttn = tn.Children[idx]\\n\\t}\\n\\ttn.Word = word\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1511595,
                "title": "simple-to-understand-using-dfs-word-search-i-with-modifications",
                "content": "**Thumbs up if you find this helpful** \\uD83D\\uDC4D\\n\\n***Updated solution using Trie***\\n\\n```\\npublic class Solution {\\n    public IList<string> FindWords(char[][] board, string[] words) {\\n        var result = new List<string>();\\n        \\n        // Add words to the trie\\n        var trie = new Trie();\\n        foreach (var word in words) {\\n            trie.Insert(word);\\n        }\\n        \\n        // Start at the root node and explore as far as possible along each branch\\n        var root = trie.GetRoot();\\n        for (int rowIndex = 0; rowIndex < board.Length; ++rowIndex) {\\n            for (int colIndex = 0; colIndex < board[rowIndex].Length; ++colIndex) {\\n                DFS(board, rowIndex, colIndex, root, result);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    void DFS(char[][] board, int row, int col, TrieNode node, List<string> result) {\\n        // Make sure the search paramaters are in bounds\\n        if (row < 0 || row >= board.Length || col < 0 || col >= board[row].Length) {\\n            return;            \\n        }\\n        // Check to see if this row has been visited\\n        var rowVisitedMarker = \\'@\\';\\n        if (board[row][col] == rowVisitedMarker) {\\n            return;            \\n        } \\n        // Check to see if this character exists in the trie\\n        if (!node.ContainsKey(board[row][col])) {\\n            return;            \\n        }    \\n        \\n        // Get the trie node for this char\\n        node = node.Get(board[row][col]);\\n        \\n        if (!node.visited && !string.IsNullOrEmpty(node.word)) {\\n            result.Add(node.word);\\n            node.visited = true;      \\n        }\\n        \\n        // Mark that this row has been visited\\n        var oldValue = board[row][col];        \\n        board[row][col] = rowVisitedMarker;\\n        \\n        // Search left\\n        DFS(board, row, col - 1, node, result);\\n\\n        // Search right\\n        DFS(board, row, col + 1, node, result);\\n\\n        // Search top\\n        DFS(board, row - 1, col, node, result);\\n\\n        // Search bottom\\n        DFS(board, row + 1, col, node, result);\\n        \\n        // Unmark that this row has been visited\\n        board[row][col] = oldValue;\\n    }   \\n    \\n    \\n    // Trie\\n    public class Trie {\\n        private TrieNode root;\\n\\n        public Trie() {\\n            root = new TrieNode();\\n        }\\n        public TrieNode GetRoot() {\\n            return root;\\n        }\\n        public void Insert(string word) {\\n            var node = root;\\n            foreach (var ch in word) {\\n                if (!node.ContainsKey(ch)) {\\n                    node.Add(ch, new TrieNode());\\n                }\\n                node = node.Get(ch);\\n            }\\n            node.word = word;\\n        }\\n    }\\n\\n    // TrieNode\\n    public class TrieNode {\\n        private Dictionary<char, TrieNode> children;\\n        public string word = string.Empty;\\n        public bool visited = false;\\n\\n        public TrieNode() {\\n            children = new Dictionary<char, TrieNode>();\\n        }\\n        public bool ContainsKey(char ch) {\\n            return children.ContainsKey(ch);\\n        }\\n        public TrieNode Get(char ch) {\\n            return children[ch];\\n        }\\n        public void Add(char ch, TrieNode node) {\\n            children[ch] = node;\\n        }\\n    }\\n}\\n```\\n\\n\\n=================================\\n\\n***Original Solution***\\n\\nThis solution uses DFS & Word Search I.\\n\\nThe main change here is that we remove any words that have characters that dont appear on the board.\\n\\nThis speeds things up because it makes it so we only use DFS for the words where all their characters appear on the board\\n\\n```\\npublic class Solution {\\n    public IList<string> FindWords(char[][] board, string[] words) {\\n        var result = new List<string>();\\n        \\n        // Remove any words that have characters that dont appear on the board\\n        var validWords = GetValidWords(board, words);\\n        \\n        // Create a \\'visitied\\' node matrix to keep track of the\\n        // items we\\'ve already seen\\n        var rowsVisited = new bool[board.Length][];\\n        for (int rowIndex = 0; rowIndex < board.Length; ++rowIndex) {\\n            rowsVisited[rowIndex] = new bool[board[rowIndex].Length];\\n        }\\n        \\n        // Find the words that can be constructed\\n        foreach (var word in validWords) {\\n            if (Exist(board, word, rowsVisited)) {\\n                result.Add(word);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private List<string> GetValidWords(char[][] board, string[] words) {\\n        // Get all the characters on the board\\n        var boardCharacters = new HashSet<char>();\\n        foreach (var row in board) {\\n            foreach (var ch in row) {\\n                boardCharacters.Add(ch);\\n            }\\n        }\\n        \\n        // Only return the words where all characters appear on the board\\n        var validWords = new List<string>();\\n        foreach (var word in words) {\\n            var valid = true;\\n            foreach (var ch in word) {\\n                if (!boardCharacters.Contains(ch)) {\\n                    valid = false;\\n                    break;\\n                }\\n            }\\n            if (valid) {\\n               validWords.Add(word); \\n            }\\n        } \\n        return validWords;\\n    }\\n    \\n    private bool Exist(char[][] board, string word, bool[][] rowsVisited) {        \\n        // Start at the root node and explore as far as possible along each branch\\n        for (int rowIndex = 0; rowIndex < board.Length; ++rowIndex) {\\n            for (int colIndex = 0; colIndex < board[rowIndex].Length; ++colIndex) {\\n                if (DFS(board, rowIndex, colIndex, 0, word, rowsVisited)) {\\n                    return true;                    \\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    bool DFS(char[][] board, int row, int col, int searchIndex, string word, bool[][] rowsVisited) {\\n        // Make sure the search paramaters are in bounds\\n        if (searchIndex >= word.Length) {\\n            return true;            \\n        }\\n        if (row < 0 || row >= board.Length || col < 0 || col >= board[row].Length) {\\n            return false;            \\n        }       \\n        if (rowsVisited[row][col]) {\\n            return false;            \\n        } \\n        if (board[row][col] != word[searchIndex]) {\\n            return false;            \\n        }        \\n        \\n        // Mark that this row has been visited\\n        rowsVisited[row][col] = true;\\n        \\n        var searchResult = \\n            // Search left\\n            DFS(board, row, col - 1, searchIndex + 1, word, rowsVisited) ||\\n            \\n            // Search right\\n            DFS(board, row, col + 1, searchIndex + 1, word, rowsVisited) ||\\n            \\n            // Search top\\n            DFS(board, row - 1, col, searchIndex + 1, word, rowsVisited) ||\\n            \\n            // Search bottom\\n            DFS(board, row + 1, col, searchIndex + 1, word, rowsVisited);\\n        \\n        // Unmark that this row has been visited\\n        rowsVisited[row][col] = false;\\n        \\n        return searchResult;\\n    }    \\n}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<string> FindWords(char[][] board, string[] words) {\\n        var result = new List<string>();\\n        \\n        // Add words to the trie\\n        var trie = new Trie();\\n        foreach (var word in words) {\\n            trie.Insert(word);\\n        }\\n        \\n        // Start at the root node and explore as far as possible along each branch\\n        var root = trie.GetRoot();\\n        for (int rowIndex = 0; rowIndex < board.Length; ++rowIndex) {\\n            for (int colIndex = 0; colIndex < board[rowIndex].Length; ++colIndex) {\\n                DFS(board, rowIndex, colIndex, root, result);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    void DFS(char[][] board, int row, int col, TrieNode node, List<string> result) {\\n        // Make sure the search paramaters are in bounds\\n        if (row < 0 || row >= board.Length || col < 0 || col >= board[row].Length) {\\n            return;            \\n        }\\n        // Check to see if this row has been visited\\n        var rowVisitedMarker = \\'@\\';\\n        if (board[row][col] == rowVisitedMarker) {\\n            return;            \\n        } \\n        // Check to see if this character exists in the trie\\n        if (!node.ContainsKey(board[row][col])) {\\n            return;            \\n        }    \\n        \\n        // Get the trie node for this char\\n        node = node.Get(board[row][col]);\\n        \\n        if (!node.visited && !string.IsNullOrEmpty(node.word)) {\\n            result.Add(node.word);\\n            node.visited = true;      \\n        }\\n        \\n        // Mark that this row has been visited\\n        var oldValue = board[row][col];        \\n        board[row][col] = rowVisitedMarker;\\n        \\n        // Search left\\n        DFS(board, row, col - 1, node, result);\\n\\n        // Search right\\n        DFS(board, row, col + 1, node, result);\\n\\n        // Search top\\n        DFS(board, row - 1, col, node, result);\\n\\n        // Search bottom\\n        DFS(board, row + 1, col, node, result);\\n        \\n        // Unmark that this row has been visited\\n        board[row][col] = oldValue;\\n    }   \\n    \\n    \\n    // Trie\\n    public class Trie {\\n        private TrieNode root;\\n\\n        public Trie() {\\n            root = new TrieNode();\\n        }\\n        public TrieNode GetRoot() {\\n            return root;\\n        }\\n        public void Insert(string word) {\\n            var node = root;\\n            foreach (var ch in word) {\\n                if (!node.ContainsKey(ch)) {\\n                    node.Add(ch, new TrieNode());\\n                }\\n                node = node.Get(ch);\\n            }\\n            node.word = word;\\n        }\\n    }\\n\\n    // TrieNode\\n    public class TrieNode {\\n        private Dictionary<char, TrieNode> children;\\n        public string word = string.Empty;\\n        public bool visited = false;\\n\\n        public TrieNode() {\\n            children = new Dictionary<char, TrieNode>();\\n        }\\n        public bool ContainsKey(char ch) {\\n            return children.ContainsKey(ch);\\n        }\\n        public TrieNode Get(char ch) {\\n            return children[ch];\\n        }\\n        public void Add(char ch, TrieNode node) {\\n            children[ch] = node;\\n        }\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public IList<string> FindWords(char[][] board, string[] words) {\\n        var result = new List<string>();\\n        \\n        // Remove any words that have characters that dont appear on the board\\n        var validWords = GetValidWords(board, words);\\n        \\n        // Create a \\'visitied\\' node matrix to keep track of the\\n        // items we\\'ve already seen\\n        var rowsVisited = new bool[board.Length][];\\n        for (int rowIndex = 0; rowIndex < board.Length; ++rowIndex) {\\n            rowsVisited[rowIndex] = new bool[board[rowIndex].Length];\\n        }\\n        \\n        // Find the words that can be constructed\\n        foreach (var word in validWords) {\\n            if (Exist(board, word, rowsVisited)) {\\n                result.Add(word);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private List<string> GetValidWords(char[][] board, string[] words) {\\n        // Get all the characters on the board\\n        var boardCharacters = new HashSet<char>();\\n        foreach (var row in board) {\\n            foreach (var ch in row) {\\n                boardCharacters.Add(ch);\\n            }\\n        }\\n        \\n        // Only return the words where all characters appear on the board\\n        var validWords = new List<string>();\\n        foreach (var word in words) {\\n            var valid = true;\\n            foreach (var ch in word) {\\n                if (!boardCharacters.Contains(ch)) {\\n                    valid = false;\\n                    break;\\n                }\\n            }\\n            if (valid) {\\n               validWords.Add(word); \\n            }\\n        } \\n        return validWords;\\n    }\\n    \\n    private bool Exist(char[][] board, string word, bool[][] rowsVisited) {        \\n        // Start at the root node and explore as far as possible along each branch\\n        for (int rowIndex = 0; rowIndex < board.Length; ++rowIndex) {\\n            for (int colIndex = 0; colIndex < board[rowIndex].Length; ++colIndex) {\\n                if (DFS(board, rowIndex, colIndex, 0, word, rowsVisited)) {\\n                    return true;                    \\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    bool DFS(char[][] board, int row, int col, int searchIndex, string word, bool[][] rowsVisited) {\\n        // Make sure the search paramaters are in bounds\\n        if (searchIndex >= word.Length) {\\n            return true;            \\n        }\\n        if (row < 0 || row >= board.Length || col < 0 || col >= board[row].Length) {\\n            return false;            \\n        }       \\n        if (rowsVisited[row][col]) {\\n            return false;            \\n        } \\n        if (board[row][col] != word[searchIndex]) {\\n            return false;            \\n        }        \\n        \\n        // Mark that this row has been visited\\n        rowsVisited[row][col] = true;\\n        \\n        var searchResult = \\n            // Search left\\n            DFS(board, row, col - 1, searchIndex + 1, word, rowsVisited) ||\\n            \\n            // Search right\\n            DFS(board, row, col + 1, searchIndex + 1, word, rowsVisited) ||\\n            \\n            // Search top\\n            DFS(board, row - 1, col, searchIndex + 1, word, rowsVisited) ||\\n            \\n            // Search bottom\\n            DFS(board, row + 1, col, searchIndex + 1, word, rowsVisited);\\n        \\n        // Unmark that this row has been visited\\n        rowsVisited[row][col] = false;\\n        \\n        return searchResult;\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1509296,
                "title": "java-dfs-explains-common-approach-for-such-problems-to-do-using-trie",
                "content": "`````\\n/**\\n * 212. Word Search II\\n *\\n * Similar problems: solved in same way\\n * 79. Word Search\\n * Link: https://leetcode.com/problems/word-search/discuss/1508413/java-easy-dfs-backtracking-with-explanation\\n *\\n * 219. Path with Maximum Gold\\n * Link: https://leetcode.com/problems/path-with-maximum-gold/discuss/1508629/easy-dfs-well-explained-with-similar-pattern-problems-java-solution\\n *\\n * 733. Flood Fill\\n * https://leetcode.com/problems/flood-fill/discuss/1511986/Efficient-easy-well-explained-with-common-pattern-or-Java\\n *\\n  **** Note ***: This is not the most efficient solution.The efficient solution would be to use a Trie.\\n  * This is to show a common pattern with previous question.\\n  * WIll post the trie solution soon.\\n \\n */\\nclass Solution {\\n    private  boolean[][] visited;\\n    int nRow, nCol;\\n    Set<String> result;\\n    int[] xs = {0, -1, 0, 1};\\n    int[] ys = {-1, 0, 1, 0};\\n\\n\\n\\n    /**\\n     * Check for each cell if the char matches then do a dfs if not back track search for other directions\\n     * if none of matches then return and try for another cell from the start.\\n     * @param board\\n     * @param words\\n     * @return\\n     */\\n    public List<String> findWords(char[][] board, String[] words) {\\n        nRow=board.length;\\n        nCol=board[0].length;\\n        visited=new boolean[nRow][nCol];\\n        result=new HashSet<>();\\n        //running for each cell\\n        for(String word: words) {//for each word\\n            for (int i = 0; i < nRow; i++) {\\n                for (int j = 0; j < nCol; j++) {\\n                    dfs(board, word, i, j, 0);\\n                }\\n            }\\n        }\\n        return new ArrayList<>(result);\\n    }\\n    \\n     /**\\n     * DFS for an array\\n     * @param board\\n     * @param word\\n     * @param x\\n     * @param y\\n     * @param indexWord\\n     */\\n     private void dfs(char[][] board,String word,int x,int y,int indexWord){\\n        if(indexWord>=word.length())\\n            return;\\n        //to check if word is found or not\\n        if(indexWord==word.length()-1 && word.charAt(indexWord)==board[x][y]) {\\n            result.add(word);\\n            return ;\\n        }\\n    \\n        \\n        //boundary condition so that dfs doesnt go out of the grid\\n       // else if(x> nRow-1 || y> nCol-1 || x<0 || y<0 || word.charAt(indexWord)!=board[x][y])\\n        else if(word.charAt(indexWord)!=board[x][y])\\n            return ;\\n      //mark as visited\\n        visited[x][y]=true;\\n        //for all 4 directions call dfs\\n        for(int i=0;i<4;i++){\\n            int row=x+xs[i];\\n            int col=y+ys[i];\\n            //check to see if DFS can be called or not\\n            if(row<= nRow-1 && col<= nCol-1 && row>=0 && col>=0 && !visited[row][col])\\n                dfs(board,word,row,col,indexWord+1);\\n        }\\n        //reset for back track\\n        visited[x][y]=false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    private  boolean[][] visited;\\n    int nRow, nCol;\\n    Set<String> result;\\n    int[] xs = {0, -1, 0, 1}",
                "codeTag": "Java"
            },
            {
                "id": 1473016,
                "title": "c-trie-dfs-easy-to-understand-290ms",
                "content": "\\nclass Solution {    \\n    struct node{    //TrieNode\\n        char c;\\n        int end;\\n        string word;\\n        node *child[26];\\n    };\\n    struct node *getNode(char c)    //get newnode\\n    {\\n        node *newnode = new node;\\n        newnode->c = c;\\n        newnode->end = 0;\\n        newnode->word = \"\";\\n        for(int i=0;i<26;++i)\\n            newnode->child[i] = NULL;\\n        return newnode;\\n    }\\n    node *root = getNode(\\'/\\');  //root\\n    \\n    //Trie INSERT\\n    void insert(string s)\\n    {\\n        node *cur = root;\\n        int index,i=0;\\n        while(s[i])\\n        {\\n            index = s[i]-\\'a\\';\\n            if(cur->child[index]==NULL){\\n                cur->child[index] = getNode(s[i]);\\n            } \\n            cur=cur->child[index];\\n            i++;\\n        }\\n        cur->end += 1;\\n        cur->word = s;\\n    }\\n    \\n    void solve(vector<vector<char>>& board,int i,int j,vector<string>& ans,node *cur) {\\n        int r = board.size();\\n        int c = board[0].size();\\n        //Base case\\n        //If the trie doesn\\'t have the current char OR cell is Visited\\n        int index = board[i][j]-\\'a\\';\\n        if(board[i][j]==\\'#\\' || cur->child[index]==NULL)  \\n            return;\\n        \\n        cur = cur->child[index];\\n        if(cur->end > 0)\\n        {\\n            ans.push_back(cur->word);\\n            cur->end -=1;\\n        }\\n        \\n        //Body\\n        char ch = board[i][j];   //Store current char\\n        board[i][j] = \\'#\\';  //Mark current node visited\\n        \\n        if(i>0)     //TOP\\n            solve(board,i-1,j,ans,cur);\\n        if(i<r-1)   //DOWN\\n            solve(board,i+1,j,ans,cur);\\n        if(j>0)     //LEFT\\n            solve(board,i,j-1,ans,cur);\\n        if(j<c-1)   //RIGHT\\n            solve(board,i,j+1,ans,cur);\\n        \\n        board[i][j] = ch;    //Mark current node as Unvisited by restoring the value\\n    }\\n    \\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {        \\n        int r=board.size();\\n        int c=board[0].size();\\n        \\n        //Insert all words in TRIE\\n        for(int i=0;i<words.size();++i){\\n            insert(words[i]);\\n        }\\n            \\n        \\n        //Now search words\\n        vector<string> ans;\\n        for(int i=0;i<r;++i) {\\n            for(int j=0;j<c;++j) {\\n                solve(board,i,j,ans,root);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nstatic int fastio = []() {\\n    #define endl \\'\\\\n\\'\\n    std::ios::sync_with_stdio(false);\\n    std::cin.tie(NULL);\\n    std::cout.tie(0);\\n    return 0;\\n}();",
                "solutionTags": [],
                "code": "class Solution {    \\n    struct node{    //TrieNode\\n        char c;\\n        int end;\\n        string word;\\n        node *child[26];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 871865,
                "title": "python-3-simple-trie-solution-beats-90-easy-to-understand",
                "content": "```\\nclass trie:\\n    def __init__(self):\\n        self.children=[None]*26\\n        self.isend=False\\n    def insert(self,word):\\n        for i in word:\\n            if self.children[ord(i)-ord(\\'a\\')]==None:\\n                self.children[ord(i)-ord(\\'a\\')]=trie()\\n            self=self.children[ord(i)-ord(\\'a\\')]\\n        self.isend=True\\n\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        def search(x,y,tre,s):\\n            if board[x][y]==\\'#\\':\\n                return \\n            c=board[x][y]\\n            board[x][y]=\\'#\\'\\n            t=tre.children[ord(c)-ord(\\'a\\')]\\n            if t!=None:\\n                ss=s+c\\n                if t.isend:result.add(ss)\\n                if x>0:search(x-1,y,t,ss)\\n                if y>0:search(x,y-1,t,ss)\\n                if x<len(board)-1:search(x+1,y,t,ss)\\n                if y<len(board[0])-1:search(x,y+1,t,ss)\\n            board[x][y]=c\\n        \\n        m,n=len(board),len(board[0])\\n        if len(words)==0:\\n            return []\\n        t=trie()\\n        for w in words:\\n            t.insert(w)\\n        result=set()\\n        for i in range(m):\\n            for j in range(n):\\n                k=board[i][j]\\n                if t.children[ord(k)-ord(\\'a\\')]!=None:\\n                    search(i,j,t,\"\")\\n        \\n        return list(result)\\n                        \\n```\\nplease upvote if u like..!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Trie"
                ],
                "code": "```\\nclass trie:\\n    def __init__(self):\\n        self.children=[None]*26\\n        self.isend=False\\n    def insert(self,word):\\n        for i in word:\\n            if self.children[ord(i)-ord(\\'a\\')]==None:\\n                self.children[ord(i)-ord(\\'a\\')]=trie()\\n            self=self.children[ord(i)-ord(\\'a\\')]\\n        self.isend=True\\n\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        def search(x,y,tre,s):\\n            if board[x][y]==\\'#\\':\\n                return \\n            c=board[x][y]\\n            board[x][y]=\\'#\\'\\n            t=tre.children[ord(c)-ord(\\'a\\')]\\n            if t!=None:\\n                ss=s+c\\n                if t.isend:result.add(ss)\\n                if x>0:search(x-1,y,t,ss)\\n                if y>0:search(x,y-1,t,ss)\\n                if x<len(board)-1:search(x+1,y,t,ss)\\n                if y<len(board[0])-1:search(x,y+1,t,ss)\\n            board[x][y]=c\\n        \\n        m,n=len(board),len(board[0])\\n        if len(words)==0:\\n            return []\\n        t=trie()\\n        for w in words:\\n            t.insert(w)\\n        result=set()\\n        for i in range(m):\\n            for j in range(n):\\n                k=board[i][j]\\n                if t.children[ord(k)-ord(\\'a\\')]!=None:\\n                    search(i,j,t,\"\")\\n        \\n        return list(result)\\n                        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 830313,
                "title": "two-steps-java-solution-explained-with-comments-line-by-line",
                "content": "There are only 2 steps in this solution\\n1. Form the Trie (If you do not know what trie is and how it works please go and check that)\\n2. DFS (Again if you don\\'t know about recursion,backtracking and dfs please go check otherwise you won\\'t understand this or any solution for this problem)\\nHere first we\\'ve formed a trie and searched words from matrix (board) while traversing the trie in all the directions of matrix i.e. normal dfs.\\n```\\nclass Trie{\\n    Trie[] children = new Trie[26];\\n    String wrd; //instead of boolean isEnd as we need to return list<String> it should be a word\\n}\\nclass Solution {\\n    public List<String> findWords(char[][] board, String[] words) {\\n        List<String> res = new ArrayList();\\n        Trie root = buildTrie(words); //build trie of words and search in matrix\\n        for(int i = 0;i<board.length;i++){\\n            for(int j = 0;j<board[0].length;j++){\\n                dfs(board,i,j,root,res);\\n            }\\n        }\\n        return res;\\n    }\\n    public void dfs(char[][] board, int i, int j, Trie p, List<String> res) {\\n        if(i<0 || i>=board.length || j<0 || j>=board[0].length || board[i][j] == \\'#\\' || p.children[board[i][j] - \\'a\\'] == null)\\n            return; //if i or j is out of bound or if char(board[i][j]) is already visited(\\'#\\') or its child is null rerturn\\n        char c = board[i][j]; //storing char of board[i][j] to c to restore after backtracking\\n        p = p.children[c - \\'a\\'];//if the char is present in child i.e. not null then move root to char\\n        if (p.wrd != null) {   // check if word is found i.e. reached at end of the word \\n            res.add(p.wrd); //add it to list\\n            p.wrd = null;     // setting word as null to avoid reuse of word and to avoid adding again to list\\n        }\\n        board[i][j] = \\'#\\'; //change char to # to avoid revisiting\\n        dfs(board, i - 1, j ,p, res); //check in all directions\\n        dfs(board, i + 1, j, p, res);\\n        dfs(board, i, j - 1, p, res);\\n        dfs(board, i, j + 1, p, res); \\n        board[i][j] = c; //restoring char after backtracking from # to char\\n}\\n    private Trie buildTrie(String[] words){\\n        Trie root = new Trie();\\n        for(String word : words){\\n            Trie temp = root;\\n            for(char c : word.toCharArray()){\\n                if(temp.children[c-\\'a\\'] == null){//if char is not in the trie\\n                    temp.children[c-\\'a\\'] = new Trie();//create new node for that char\\n                }\\n                temp = temp.children[c-\\'a\\'];//move node to next char\\n            }\\n            temp.wrd = word;//update temp.wrd to current word that can be used later\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Trie{\\n    Trie[] children = new Trie[26];\\n    String wrd; //instead of boolean isEnd as we need to return list<String> it should be a word\\n}\\nclass Solution {\\n    public List<String> findWords(char[][] board, String[] words) {\\n        List<String> res = new ArrayList();\\n        Trie root = buildTrie(words); //build trie of words and search in matrix\\n        for(int i = 0;i<board.length;i++){\\n            for(int j = 0;j<board[0].length;j++){\\n                dfs(board,i,j,root,res);\\n            }\\n        }\\n        return res;\\n    }\\n    public void dfs(char[][] board, int i, int j, Trie p, List<String> res) {\\n        if(i<0 || i>=board.length || j<0 || j>=board[0].length || board[i][j] == \\'#\\' || p.children[board[i][j] - \\'a\\'] == null)\\n            return; //if i or j is out of bound or if char(board[i][j]) is already visited(\\'#\\') or its child is null rerturn\\n        char c = board[i][j]; //storing char of board[i][j] to c to restore after backtracking\\n        p = p.children[c - \\'a\\'];//if the char is present in child i.e. not null then move root to char\\n        if (p.wrd != null) {   // check if word is found i.e. reached at end of the word \\n            res.add(p.wrd); //add it to list\\n            p.wrd = null;     // setting word as null to avoid reuse of word and to avoid adding again to list\\n        }\\n        board[i][j] = \\'#\\'; //change char to # to avoid revisiting\\n        dfs(board, i - 1, j ,p, res); //check in all directions\\n        dfs(board, i + 1, j, p, res);\\n        dfs(board, i, j - 1, p, res);\\n        dfs(board, i, j + 1, p, res); \\n        board[i][j] = c; //restoring char after backtracking from # to char\\n}\\n    private Trie buildTrie(String[] words){\\n        Trie root = new Trie();\\n        for(String word : words){\\n            Trie temp = root;\\n            for(char c : word.toCharArray()){\\n                if(temp.children[c-\\'a\\'] == null){//if char is not in the trie\\n                    temp.children[c-\\'a\\'] = new Trie();//create new node for that char\\n                }\\n                temp = temp.children[c-\\'a\\'];//move node to next char\\n            }\\n            temp.wrd = word;//update temp.wrd to current word that can be used later\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 712977,
                "title": "rust-trie-dfs-solution",
                "content": "```rust\\nuse std::collections::HashSet;\\n\\n#[derive(Default)]\\nstruct Trie {\\n    children: [Option<Box<Trie>>; 26],\\n    word: Option<String>,\\n}\\n\\nimpl Solution {\\n    pub fn find_words(board: Vec<Vec<char>>, words: Vec<String>) -> Vec<String> {\\n        let mut trie: Trie = Default::default();\\n        for word in words.iter() {\\n            let mut node = &mut trie;\\n            for c in word.as_bytes() {\\n                node =\\n                    node.children[(c - b\\'a\\') as usize].get_or_insert(Box::new(Default::default()));\\n            }\\n            node.word = Some(word.clone());\\n        }\\n        let mut answer: HashSet<String> = HashSet::new();\\n        for i in 0..board.len() {\\n            for j in 0..board[0].len() {\\n                let mut visited: Vec<Vec<bool>> = vec![vec![false; board[0].len()]; board.len()];\\n                Solution::dfs(&board, (i, j), &trie, &mut visited, &mut answer);\\n            }\\n        }\\n        answer.into_iter().collect()\\n    }\\n    fn dfs(\\n        board: &[Vec<char>],\\n        pos: (usize, usize),\\n        trie: &Trie,\\n        visited: &mut Vec<Vec<bool>>,\\n        answer: &mut HashSet<String>,\\n    ) {\\n        if visited[pos.0][pos.1] {\\n            return;\\n        }\\n        visited[pos.0][pos.1] = true;\\n        let c = board[pos.0][pos.1];\\n        if let Some(node) = &trie.children[(c as u8 - b\\'a\\') as usize] {\\n            if let Some(word) = &node.word {\\n                answer.insert(word.clone());\\n            }\\n            if pos.0 > 0 {\\n                Solution::dfs(board, (pos.0 - 1, pos.1), node.as_ref(), visited, answer);\\n            }\\n            if pos.1 > 0 {\\n                Solution::dfs(board, (pos.0, pos.1 - 1), node.as_ref(), visited, answer);\\n            }\\n            if pos.0 < board.len() - 1 {\\n                Solution::dfs(board, (pos.0 + 1, pos.1), node.as_ref(), visited, answer);\\n            }\\n            if pos.1 < board[0].len() - 1 {\\n                Solution::dfs(board, (pos.0, pos.1 + 1), node.as_ref(), visited, answer);\\n            }\\n        }\\n        visited[pos.0][pos.1] = false;\\n    }\\n}\\n```\\n\\nUpdated:\\n\\n```rust\\n#[derive(Default)]\\nstruct Trie {\\n    children: [Option<Box<Trie>>; 26],\\n    is_end: bool,\\n}\\n\\nimpl Solution {\\n    pub fn find_words(board: Vec<Vec<char>>, words: Vec<String>) -> Vec<String> {\\n        let mut trie = Trie::default();\\n        for word in &words {\\n            let mut node = &mut trie;\\n            for u in word.bytes() {\\n                node = node.children[(u - b\\'a\\') as usize].get_or_insert(Default::default());\\n            }\\n            node.is_end = true;\\n        }\\n        let mut board = board;\\n        let mut answer = Vec::new();\\n        for i in 0..board.len() {\\n            for j in 0..board[0].len() {\\n                Self::backtrack(\\n                    &mut board,\\n                    &mut trie,\\n                    (i, j),\\n                    &mut String::new(),\\n                    &mut answer,\\n                );\\n            }\\n        }\\n        answer\\n    }\\n    fn backtrack(\\n        board: &mut Vec<Vec<char>>,\\n        trie: &mut Trie,\\n        pos: (usize, usize),\\n        s: &mut String,\\n        answer: &mut Vec<String>,\\n    ) {\\n        let c = board[pos.0][pos.1];\\n        if let Some(node) = &mut trie.children[(c as u8 - b\\'a\\') as usize] {\\n            s.push(c);\\n            if node.is_end {\\n                answer.push(s.clone());\\n                node.is_end = false;\\n            }\\n            board[pos.0][pos.1] = \\'*\\';\\n            for d in [0, 1, 0, !0, 0].windows(2) {\\n                let i = pos.0.wrapping_add(d[0]);\\n                let j = pos.1.wrapping_add(d[1]);\\n                if (0..board.len()).contains(&i)\\n                    && (0..board[0].len()).contains(&j)\\n                    && board[i][j] != \\'*\\'\\n                {\\n                    Self::backtrack(board, node, (i, j), s, answer);\\n                }\\n            }\\n            board[pos.0][pos.1] = c;\\n            s.pop();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```rust\\nuse std::collections::HashSet;\\n\\n#[derive(Default)]\\nstruct Trie {\\n    children: [Option<Box<Trie>>; 26],\\n    word: Option<String>,\\n}\\n\\nimpl Solution {\\n    pub fn find_words(board: Vec<Vec<char>>, words: Vec<String>) -> Vec<String> {\\n        let mut trie: Trie = Default::default();\\n        for word in words.iter() {\\n            let mut node = &mut trie;\\n            for c in word.as_bytes() {\\n                node =\\n                    node.children[(c - b\\'a\\') as usize].get_or_insert(Box::new(Default::default()));\\n            }\\n            node.word = Some(word.clone());\\n        }\\n        let mut answer: HashSet<String> = HashSet::new();\\n        for i in 0..board.len() {\\n            for j in 0..board[0].len() {\\n                let mut visited: Vec<Vec<bool>> = vec![vec![false; board[0].len()]; board.len()];\\n                Solution::dfs(&board, (i, j), &trie, &mut visited, &mut answer);\\n            }\\n        }\\n        answer.into_iter().collect()\\n    }\\n    fn dfs(\\n        board: &[Vec<char>],\\n        pos: (usize, usize),\\n        trie: &Trie,\\n        visited: &mut Vec<Vec<bool>>,\\n        answer: &mut HashSet<String>,\\n    ) {\\n        if visited[pos.0][pos.1] {\\n            return;\\n        }\\n        visited[pos.0][pos.1] = true;\\n        let c = board[pos.0][pos.1];\\n        if let Some(node) = &trie.children[(c as u8 - b\\'a\\') as usize] {\\n            if let Some(word) = &node.word {\\n                answer.insert(word.clone());\\n            }\\n            if pos.0 > 0 {\\n                Solution::dfs(board, (pos.0 - 1, pos.1), node.as_ref(), visited, answer);\\n            }\\n            if pos.1 > 0 {\\n                Solution::dfs(board, (pos.0, pos.1 - 1), node.as_ref(), visited, answer);\\n            }\\n            if pos.0 < board.len() - 1 {\\n                Solution::dfs(board, (pos.0 + 1, pos.1), node.as_ref(), visited, answer);\\n            }\\n            if pos.1 < board[0].len() - 1 {\\n                Solution::dfs(board, (pos.0, pos.1 + 1), node.as_ref(), visited, answer);\\n            }\\n        }\\n        visited[pos.0][pos.1] = false;\\n    }\\n}\\n```\n```rust\\n#[derive(Default)]\\nstruct Trie {\\n    children: [Option<Box<Trie>>; 26],\\n    is_end: bool,\\n}\\n\\nimpl Solution {\\n    pub fn find_words(board: Vec<Vec<char>>, words: Vec<String>) -> Vec<String> {\\n        let mut trie = Trie::default();\\n        for word in &words {\\n            let mut node = &mut trie;\\n            for u in word.bytes() {\\n                node = node.children[(u - b\\'a\\') as usize].get_or_insert(Default::default());\\n            }\\n            node.is_end = true;\\n        }\\n        let mut board = board;\\n        let mut answer = Vec::new();\\n        for i in 0..board.len() {\\n            for j in 0..board[0].len() {\\n                Self::backtrack(\\n                    &mut board,\\n                    &mut trie,\\n                    (i, j),\\n                    &mut String::new(),\\n                    &mut answer,\\n                );\\n            }\\n        }\\n        answer\\n    }\\n    fn backtrack(\\n        board: &mut Vec<Vec<char>>,\\n        trie: &mut Trie,\\n        pos: (usize, usize),\\n        s: &mut String,\\n        answer: &mut Vec<String>,\\n    ) {\\n        let c = board[pos.0][pos.1];\\n        if let Some(node) = &mut trie.children[(c as u8 - b\\'a\\') as usize] {\\n            s.push(c);\\n            if node.is_end {\\n                answer.push(s.clone());\\n                node.is_end = false;\\n            }\\n            board[pos.0][pos.1] = \\'*\\';\\n            for d in [0, 1, 0, !0, 0].windows(2) {\\n                let i = pos.0.wrapping_add(d[0]);\\n                let j = pos.1.wrapping_add(d[1]);\\n                if (0..board.len()).contains(&i)\\n                    && (0..board[0].len()).contains(&j)\\n                    && board[i][j] != \\'*\\'\\n                {\\n                    Self::backtrack(board, node, (i, j), s, answer);\\n                }\\n            }\\n            board[pos.0][pos.1] = c;\\n            s.pop();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 712826,
                "title": "my-accepted-java-solution-using-simple-recursion-no-trie-and-hashmap-required",
                "content": "```\\n public List<String> findWords(char[][] board, String[] words) {\\n        List<String> res = new ArrayList();\\n        for(String word : words)\\n            if(exist(board,word))\\n                res.add(word);\\n        return res;\\n    }\\n    \\n    public boolean exist(char[][] board, String word) {\\n        \\n        for(int i =0;i<board.length;i++)\\n            for(int j=0;j<board[0].length;j++){\\n                if(board[i][j] == word.charAt(0) && existWord(board,word,i,j,1))\\n                    return true;\\n            }\\n        return false;\\n    }\\n    \\n    private boolean existWord(char[][] board, String word, int row, int col, int index){\\n        if(index == word.length())\\n            return true;\\n        board[row][col] = \\'.\\';\\n        if(row > 0 && board[row-1][col] == word.charAt(index) && existWord(board,word,row-1,col,index+1)){\\n            board[row][col] = word.charAt(index-1);\\n            return true;\\n        }\\n         if(row<board.length-1 && board[row+1][col] == word.charAt(index) && existWord(board,word,row+1,col,index+1)){\\n             board[row][col] = word.charAt(index-1);\\n            return true;\\n         }\\n         if(col>0 && board[row][col-1] == word.charAt(index) && existWord(board,word,row,col-1,index+1)){\\n             board[row][col] = word.charAt(index-1);\\n            return true;\\n         }\\n        if(col<board[0].length-1 && board[row][col+1] == word.charAt(index) && existWord(board,word,row,col+1,index+1)){\\n             board[row][col] = word.charAt(index-1);\\n            return true;\\n         }\\n        board[row][col] = word.charAt(index-1);\\n        return false;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public List<String> findWords(char[][] board, String[] words) {\\n        List<String> res = new ArrayList();\\n        for(String word : words)\\n            if(exist(board,word))\\n                res.add(word);\\n        return res;\\n    }\\n    \\n    public boolean exist(char[][] board, String word) {\\n        \\n        for(int i =0;i<board.length;i++)\\n            for(int j=0;j<board[0].length;j++){\\n                if(board[i][j] == word.charAt(0) && existWord(board,word,i,j,1))\\n                    return true;\\n            }\\n        return false;\\n    }\\n    \\n    private boolean existWord(char[][] board, String word, int row, int col, int index){\\n        if(index == word.length())\\n            return true;\\n        board[row][col] = \\'.\\';\\n        if(row > 0 && board[row-1][col] == word.charAt(index) && existWord(board,word,row-1,col,index+1)){\\n            board[row][col] = word.charAt(index-1);\\n            return true;\\n        }\\n         if(row<board.length-1 && board[row+1][col] == word.charAt(index) && existWord(board,word,row+1,col,index+1)){\\n             board[row][col] = word.charAt(index-1);\\n            return true;\\n         }\\n         if(col>0 && board[row][col-1] == word.charAt(index) && existWord(board,word,row,col-1,index+1)){\\n             board[row][col] = word.charAt(index-1);\\n            return true;\\n         }\\n        if(col<board[0].length-1 && board[row][col+1] == word.charAt(index) && existWord(board,word,row,col+1,index+1)){\\n             board[row][col] = word.charAt(index-1);\\n            return true;\\n         }\\n        board[row][col] = word.charAt(index-1);\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 693756,
                "title": "python-clean-trie-solution-with-dfs",
                "content": "```\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        ## RC ##\\n\\t\\t## APPROACH : TRIE + DFS ##\\n\\t\\t## LOGIC ##\\n\\t\\t#\\t1. build trie with all words list\\n\\t\\t#\\t2. start scanning matrix, move in all four directions and check if such combination exists in the trie\\n\\t\\t#\\t3. make sure you donot return when result is found ( case: words = [cat, cattle ] )\\n\\t\\t\\n        ## TIME COMPLEXICITY : O(M(4x3^(L-1))) ## (M is the number of cells in the board and L is the maximum length of words.)\\n\\t\\t## SPACE COMPLEXICITY : O(N) ##\\n\\t    \\n        def dfs(i, j, curr, currNode):\\n            ch = board[i][j]\\n            if( ch not in currNode.children or (i, j) in visited ):\\n                return\\n            if currNode.children[ch].endOfWord:\\n                res.add(curr)\\n                # return                            # edge case\\n            visited.add((i,j))\\n            for x,y in directions:\\n                if 0 <= i + x < m and 0 <= j + y < n:\\n                    dfs( i + x, j + y, curr + board[i + x][j + y], currNode.children[ch])\\n            visited.remove((i,j))   # edge case\\n        \\n        # buid trie data structure\\n        my_trie = Trie()\\n        [ my_trie.insert(word) for word in words ]\\n        rootNode = my_trie.get_rootNode()\\n        \\n        m, n = len(board), len(board[0])\\n        directions = [(0,1), (1,0), (0,-1), (-1,0)]\\n        res = set()                     \\n        for i in range(len(board)):\\n            for j in range(len(board[i])):\\n                visited = set()\\n                dfs(i, j, board[i][j], rootNode)\\n        return res\\n    \\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.endOfWord = False\\n\\nclass Trie:\\n    def __init__(self):\\n        self.rootNode = TrieNode()\\n    \\n    def get_rootNode(self):\\n        return self.rootNode\\n    \\n    # Inserts a word into the trie.\\n    def insert(self, word: str) -> None:\\n        currNode = self.rootNode\\n        for idx, ch in enumerate(word):\\n            if( ch not in currNode.children ):\\n                currNode.children[ch] = TrieNode()\\n            currNode = currNode.children[ch]        \\n        currNode.endOfWord = True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        ## RC ##\\n\\t\\t## APPROACH : TRIE + DFS ##\\n\\t\\t## LOGIC ##\\n\\t\\t#\\t1. build trie with all words list\\n\\t\\t#\\t2. start scanning matrix, move in all four directions and check if such combination exists in the trie\\n\\t\\t#\\t3. make sure you donot return when result is found ( case: words = [cat, cattle ] )\\n\\t\\t\\n        ## TIME COMPLEXICITY : O(M(4x3^(L-1))) ## (M is the number of cells in the board and L is the maximum length of words.)\\n\\t\\t## SPACE COMPLEXICITY : O(N) ##\\n\\t    \\n        def dfs(i, j, curr, currNode):\\n            ch = board[i][j]\\n            if( ch not in currNode.children or (i, j) in visited ):\\n                return\\n            if currNode.children[ch].endOfWord:\\n                res.add(curr)\\n                # return                            # edge case\\n            visited.add((i,j))\\n            for x,y in directions:\\n                if 0 <= i + x < m and 0 <= j + y < n:\\n                    dfs( i + x, j + y, curr + board[i + x][j + y], currNode.children[ch])\\n            visited.remove((i,j))   # edge case\\n        \\n        # buid trie data structure\\n        my_trie = Trie()\\n        [ my_trie.insert(word) for word in words ]\\n        rootNode = my_trie.get_rootNode()\\n        \\n        m, n = len(board), len(board[0])\\n        directions = [(0,1), (1,0), (0,-1), (-1,0)]\\n        res = set()                     \\n        for i in range(len(board)):\\n            for j in range(len(board[i])):\\n                visited = set()\\n                dfs(i, j, board[i][j], rootNode)\\n        return res\\n    \\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.endOfWord = False\\n\\nclass Trie:\\n    def __init__(self):\\n        self.rootNode = TrieNode()\\n    \\n    def get_rootNode(self):\\n        return self.rootNode\\n    \\n    # Inserts a word into the trie.\\n    def insert(self, word: str) -> None:\\n        currNode = self.rootNode\\n        for idx, ch in enumerate(word):\\n            if( ch not in currNode.children ):\\n                currNode.children[ch] = TrieNode()\\n            currNode = currNode.children[ch]        \\n        currNode.endOfWord = True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 382930,
                "title": "easy-peasy-python-dfs-trie-solution-with-trie-implementation",
                "content": "\\tclass TrieNode:\\n\\t\\tdef __init__(self):\\n\\t\\t\\tself.children = [None]*26\\n\\t\\t\\tself.end = False\\n\\n\\tclass Trie:\\n\\t\\tdef __init__(self):\\n\\t\\t\\tself.root = TrieNode()\\n\\n\\t\\tdef addWord(self, word):\\n\\t\\t\\troot = self.root\\n\\t\\t\\tfor ch in word:\\n\\t\\t\\t\\tidx = ord(ch) - 97\\n\\t\\t\\t\\tif root.children[idx] is None:\\n\\t\\t\\t\\t\\troot.children[idx] = TrieNode()\\n\\t\\t\\t\\troot = root.children[idx]\\n\\n\\t\\t\\troot.end = True\\n    \\n\\t\\tdef getRoot(self):\\n\\t\\t\\treturn self.root\\n\\n\\tclass Solution:\\n\\t\\tdef findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n\\t\\t\\tself.rows = len(board)\\n\\t\\t\\tif self.rows == 0:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tself.cols = len(board[0])\\n\\t\\t\\tself.board = board\\n\\n\\t\\t\\tself.res = set()\\n\\t\\t\\tself.resLen = len(words)\\n\\n\\t\\t\\tself.visited = [[False]*self.cols for _ in range(self.rows)]\\n\\n\\t\\t\\tobj = Trie()\\n\\t\\t\\tfor word in words:\\n\\t\\t\\t\\tobj.addWord(word)\\n\\n\\t\\t\\troot = obj.getRoot()\\n\\n\\t\\t\\tfor i in range(self.rows):\\n\\t\\t\\t\\tfor j in range(self.cols):\\n\\t\\t\\t\\t\\tidx = ord(self.board[i][j]) - 97\\n\\t\\t\\t\\t\\tif root.children[idx]:\\n\\t\\t\\t\\t\\t\\tself.visited[i][j] = True\\n\\t\\t\\t\\t\\t\\tself.dfs(i, j, board[i][j], root.children[idx])\\n\\t\\t\\t\\t\\t\\tself.visited[i][j] = False\\n\\n\\t\\t\\treturn list(self.res)\\n\\n\\n\\t\\tdef dfs(self, i, j, ls, root):\\n\\t\\t\\tif len(self.res) == self.resLen:\\n\\t\\t\\t\\treturn\\n\\n\\t\\t\\tif root.end:\\n\\t\\t\\t\\tself.res.add(ls)\\n\\n\\t\\t\\tfor (a, b) in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)):\\n\\t\\t\\t\\tif self.isValid(a, b):\\n\\t\\t\\t\\t\\tidx = ord(self.board[a][b]) - 97\\n\\t\\t\\t\\t\\tif root.children[idx]:\\n\\t\\t\\t\\t\\t\\tself.visited[a][b] = True\\n\\t\\t\\t\\t\\t\\tself.dfs(a, b, ls + self.board[a][b], root.children[idx])\\n\\t\\t\\t\\t\\t\\tself.visited[a][b] = False\\n\\n\\t\\tdef isValid(self, a, b):\\n\\t\\t\\treturn 0 <= a < self.rows and 0 <= b < self.cols and not self.visited[a][b]",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "\\tclass TrieNode:\\n\\t\\tdef __init__(self):\\n\\t\\t\\tself.children = [None]*26\\n\\t\\t\\tself.end = False\\n\\n\\tclass Trie:\\n\\t\\tdef __init__(self):\\n\\t\\t\\tself.root = TrieNode()\\n\\n\\t\\tdef addWord(self, word):\\n\\t\\t\\troot = self.root\\n\\t\\t\\tfor ch in word:\\n\\t\\t\\t\\tidx = ord(ch) - 97\\n\\t\\t\\t\\tif root.children[idx] is None:\\n\\t\\t\\t\\t\\troot.children[idx] = TrieNode()\\n\\t\\t\\t\\troot = root.children[idx]\\n\\n\\t\\t\\troot.end = True\\n    \\n\\t\\tdef getRoot(self):\\n\\t\\t\\treturn self.root\\n\\n\\tclass Solution:\\n\\t\\tdef findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n\\t\\t\\tself.rows = len(board)\\n\\t\\t\\tif self.rows == 0:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tself.cols = len(board[0])\\n\\t\\t\\tself.board = board\\n\\n\\t\\t\\tself.res = set()\\n\\t\\t\\tself.resLen = len(words)\\n\\n\\t\\t\\tself.visited = [[False]*self.cols for _ in range(self.rows)]\\n\\n\\t\\t\\tobj = Trie()\\n\\t\\t\\tfor word in words:\\n\\t\\t\\t\\tobj.addWord(word)\\n\\n\\t\\t\\troot = obj.getRoot()\\n\\n\\t\\t\\tfor i in range(self.rows):\\n\\t\\t\\t\\tfor j in range(self.cols):\\n\\t\\t\\t\\t\\tidx = ord(self.board[i][j]) - 97\\n\\t\\t\\t\\t\\tif root.children[idx]:\\n\\t\\t\\t\\t\\t\\tself.visited[i][j] = True\\n\\t\\t\\t\\t\\t\\tself.dfs(i, j, board[i][j], root.children[idx])\\n\\t\\t\\t\\t\\t\\tself.visited[i][j] = False\\n\\n\\t\\t\\treturn list(self.res)\\n\\n\\n\\t\\tdef dfs(self, i, j, ls, root):\\n\\t\\t\\tif len(self.res) == self.resLen:\\n\\t\\t\\t\\treturn\\n\\n\\t\\t\\tif root.end:\\n\\t\\t\\t\\tself.res.add(ls)\\n\\n\\t\\t\\tfor (a, b) in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)):\\n\\t\\t\\t\\tif self.isValid(a, b):\\n\\t\\t\\t\\t\\tidx = ord(self.board[a][b]) - 97\\n\\t\\t\\t\\t\\tif root.children[idx]:\\n\\t\\t\\t\\t\\t\\tself.visited[a][b] = True\\n\\t\\t\\t\\t\\t\\tself.dfs(a, b, ls + self.board[a][b], root.children[idx])\\n\\t\\t\\t\\t\\t\\tself.visited[a][b] = False\\n\\n\\t\\tdef isValid(self, a, b):\\n\\t\\t\\treturn 0 <= a < self.rows and 0 <= b < self.cols and not self.visited[a][b]",
                "codeTag": "Java"
            },
            {
                "id": 319071,
                "title": "standard-python-solution-with-trie-backtrack-340ms-beat-70-2",
                "content": "Please see and vote for my solutions\\n[79. Word Search](https://leetcode.com/problems/word-search/discuss/318208/Python-DFS-%2B-Backtrack-solution)\\n[212. Word Search II](https://leetcode.com/problems/word-search-ii/discuss/319071/Standard-Python-solution-with-Trie-%2B-Backtrack)\\n\\n\\nPlease see and vote for my solutions for\\n[208. Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/discuss/320224/Simple-Python-solution)\\n[1233. Remove Sub-Folders from the Filesystem](https://leetcode.com/problems/remove-sub-folders-from-the-filesystem/discuss/409075/standard-python-prefix-tree-solution)\\n[1032. Stream of Characters](https://leetcode.com/problems/stream-of-characters/discuss/320837/Standard-Python-Trie-Solution)\\n[211. Add and Search Word - Data structure design](https://leetcode.com/problems/add-and-search-word-data-structure-design/discuss/319361/Simple-Python-solution)\\n[676. Implement Magic Dictionary](https://leetcode.com/problems/implement-magic-dictionary/discuss/320197/Simple-Python-solution)\\n[677. Map Sum Pairs](https://leetcode.com/problems/map-sum-pairs/discuss/320237/Simple-Python-solution)\\n[745. Prefix and Suffix Search](https://leetcode.com/problems/prefix-and-suffix-search/discuss/320712/Different-Python-solutions-with-thinking-process)\\n[425. Word Squares](https://leetcode.com/problems/word-squares/discuss/320916/Easily-implemented-Python-solution%3A-Backtrack-%2B-Trie)\\n[472. Concatenated Words](https://leetcode.com/problems/concatenated-words/discuss/322444/Python-solutions%3A-top-down-DP-Trie)\\n[212. Word Search II](https://leetcode.com/problems/word-search-ii/discuss/319071/Standard-Python-solution-with-Trie-%2B-Backtrack)\\n[336. Palindrome Pairs](https://leetcode.com/problems/palindrome-pairs/discuss/316960/Different-Python-solutions%3A-brute-force-dictionary-Trie)\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.isEnd = False\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        \\n    def insert(self, word):\\n        node = self.root\\n        for char in word:\\n            if char not in node.children:\\n                node.children[char] = TrieNode()\\n            node = node.children[char]\\n        node.isEnd = True\\n\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        def backtrack(node, curr, i, j):\\n            for char in node.children:\\n                if board[i][j] != char:\\n                    continue\\n                curr += char\\n                visited.add((i, j))\\n                nxt = node.children[char]\\n                if nxt.isEnd:\\n                    res.add(curr)\\n                for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\\n                    i1, j1 = i + di, j + dj\\n                    if 0 <= i1 < m and 0 <= j1 < n and (i1, j1) not in visited:\\n                        backtrack(nxt, curr, i1, j1)\\n                visited.remove((i, j))\\n                curr = curr[:-1]\\n                \\n        if not board or not board[0] or not words:\\n            return []  \\n        m, n = len(board), len(board[0])\\n        res = set()\\n        trie = Trie()\\n        for word in words:\\n            trie.insert(word)\\n        visited = set()\\n        for i in range(m):\\n            for j in range(n):\\n                backtrack(trie.root, \\'\\', i, j)\\n        return list(res)\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.isEnd = False\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        \\n    def insert(self, word):\\n        node = self.root\\n        for char in word:\\n            if char not in node.children:\\n                node.children[char] = TrieNode()\\n            node = node.children[char]\\n        node.isEnd = True\\n\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        def backtrack(node, curr, i, j):\\n            for char in node.children:\\n                if board[i][j] != char:\\n                    continue\\n                curr += char\\n                visited.add((i, j))\\n                nxt = node.children[char]\\n                if nxt.isEnd:\\n                    res.add(curr)\\n                for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\\n                    i1, j1 = i + di, j + dj\\n                    if 0 <= i1 < m and 0 <= j1 < n and (i1, j1) not in visited:\\n                        backtrack(nxt, curr, i1, j1)\\n                visited.remove((i, j))\\n                curr = curr[:-1]\\n                \\n        if not board or not board[0] or not words:\\n            return []  \\n        m, n = len(board), len(board[0])\\n        res = set()\\n        trie = Trie()\\n        for word in words:\\n            trie.insert(word)\\n        visited = set()\\n        for i in range(m):\\n            for j in range(n):\\n                backtrack(trie.root, \\'\\', i, j)\\n        return list(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59850,
                "title": "recommend-for-beginners-clean-c-implementation-with-detailed-explanation",
                "content": "AS I frist meet this question, I think we should grasp to implement Trie in 10 minutes. Then based the Trie,  we construct the Prefix Tree and traverse the board array and check whether the word exist in the dictionary.   \\n\\n\\n    const int MAX_CHARS=26;\\n    \\n    class TrieNode{\\n        public:\\n            TrieNode(string s) : isWord(false), word(s) {\\n                memset(children, 0, sizeof(children));\\n            }\\n        public:\\n            /*** store-the-root-cur-pos-word ***/\\n            string word;\\n            bool isWord;\\n            TrieNode* children[MAX_CHARS];\\n    };\\n    \\n    class TrieTree{\\n        public:\\n            TrieTree():root(new TrieNode(\"\")) {}\\n            ~TrieTree(){ freeTree(root); }\\n            TrieNode* getRoot(){\\n                return root;\\n            }\\n            \\n            void addWord(string& s){\\n                TrieNode* node=root;\\n                string t;\\n                for(int i=0; i<s.size(); i++){\\n                    t+=s[i];\\n                    if(node->children[s[i]-'a']==NULL){\\n                        node->children[s[i]-'a']=new TrieNode(t);\\n                    }\\n                    node=node->children[s[i]-'a'];\\n                }\\n                node->isWord=true;\\n            }\\n        private:\\n            void freeTree(TrieNode* node){\\n                for(int i=0; i<MAX_CHARS; i++){\\n                    if(node->children[i]!=NULL){\\n                        freeTree(node->children[i]);\\n                    }\\n                }\\n                delete node;\\n            }\\n            TrieNode* root;\\n    };\\n    \\n    class Solution {\\n    public:\\n        vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n            TrieTree t;\\n            for(int i=0; i<words.size(); i++)   t.addWord(words[i]);\\n            vector<string> result;\\n            for(int i=0; i<board.size(); i++){\\n                for(int j=0; j<board[i].size(); j++){\\n                    help(board, t.getRoot(), i, j, result);\\n                }\\n            }\\n            return result;\\n        }\\n        \\n        void help(vector<vector<char>>& board, TrieNode* root, int row, int col, vector<string>& result){\\n            if(row<0 || col<0 || row>=board.size() || col>=board[0].size() || board[row][col]=='*')  return;\\n            char ch=board[row][col];\\n            root=root->children[ch-'a'];\\n            if(root==NULL)   return;\\n            if(root->isWord){\\n                result.push_back(root->word);\\n                root->isWord=false;\\n            }\\n            board[row][col]='*';\\n            help(board, root, row+1, col, result);\\n            help(board, root, row-1, col, result);\\n            help(board, root, row, col+1, result);\\n            help(board, root, row, col-1, result);\\n            board[row][col]=ch;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n            TrieTree t;\\n            for(int i=0; i<words.size(); i++)   t.addWord(words[i]);\\n            vector<string> result;\\n            for(int i=0; i<board.size(); i++){\\n                for(int j=0; j<board[i].size(); j++){\\n                    help(board, t.getRoot(), i, j, result);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 59914,
                "title": "java-solution-with-trie-structure",
                "content": "Basically the solution will go in two steps:\\n\\n1. Build up the Trie structure for the dictionary;  \\n2. Search for words starting from each cell on the board, based on the Trie structure obtained above.\\n\\nFor step 1, you may refer to problem \"208 Implement Trie (Prefix Tree)\"(Here we only need the \"insert\" method). \\n\\nFor step 2, we can use a standard backtracing function. Two key points for designing your backtracing function are \"where to start\" and \"when to stop\". For this problem, a straightforward starting point would be   for each cell on the board, try to match the letter at current cell to the first level of the Trie structure (root is defined as the zeroth level). If there is a match, then continue to match the letter at one of its four neighbors to the next level of the Trie and so on. The termination condition is either there is no match in the Trie for the letter at current cell or there are no more available cells out of its four neighbors(all visited). So your Trie structure should provide a quick way to check whether there is a match for current letter. You also need to mark current cell if it has been visited. One more point is when to record the searching result. After each successful match of letter at current cell, your Trie structure should be able to tell whether this letter in the Trie is an end of a word. If so, record the word and remove it from the Trie structure to avoid repetition.\\n\\nThis is the function I used:\\n```\\nvoid findWordsSub(char[][] board, int i, int j, TrieNode trieNode, StringBuilder sb, List<String> res);\\n```\\nHere board is the given char board; i and j are the row and column indices of current cell;\\ntrieNode is the matching TrieNode of the letter at current cell in the Trie structure(It is null if there is no such matching); sb will hold a character sequence from root to current level(exclusive) in the Trie structure (depending on your design of Trie structure, you may or may not need this variable); res will hold the searching results.\\n\\nWhen entering the backtracing function,  first check if trieNode is null or not. If it's null, then there is no matching for the letter at current cell in the Trie structure so no further search is needed. Else, we append current letter to sb and check if we have obtained a complete word in the dictionary(record the word and remove it from the Trie if so). After we are done with current character, we modified it to '{' to indicate that current cell has been visited. Here character '{' is chosen for the following reason: In the TrieNode definition, I used an array of length 27 instead of 26. For words containing only lowercase letters, the last element of this array will always be null. For an visited cell on the board, if we set the character at that cell to be '{'  (in terms of ASCII, '{' = 'a' + 26), then whenever it's visited again, the corresponding trieNode will be null and the search will terminate. With current cell marked as visited, we do need further search if any of its four neighbors is available on the board. At last, when we are done with all the neighbors, we restore the letter at current cell and also StringBuilder sb so the backtracing can continue. Here is the complete program:\\n```\\n    // TrieNode for the Trie structure\\n    class TrieNode {\\n        TrieNode[] next;   // next level TrieNodes\\n        boolean isWordEnd; // true if this is the end of a word\\n        \\n        public TrieNode() {\\n            next = new TrieNode[27]; // Here I use an array of length 27 instead of 26 for later use\\n            isWordEnd = false;\\n        }\\n    }\\n    \\n    public List<String> findWords(char[][] board, String[] words) {   \\t\\n        int m = board.length;\\n        int n = (m == 0 ? 0 : board[0].length);\\n    \\t\\n    \\tList<String> res = new ArrayList<>();        // holding results\\n        StringBuilder sb = new StringBuilder(m * n); // holding the character sequence from root to current level(exclusive) in the Trie structure(initial capacity equal to the dimension of the board)\\n        TrieNode root = new TrieNode();              // root node for the Trie structure\\n        \\n        // Step 1: build up the Trie structure\\n        for (String word : words) {\\n            TrieNode trieNode = root;\\n        \\t\\n            for (int i = 0; i < word.length(); i++) {\\n        \\tif (trieNode.next[word.charAt(i) - 'a'] == null) {\\n        \\t    trieNode.next[word.charAt(i) - 'a'] = new TrieNode();\\n        \\t}\\n\\n        \\ttrieNode = trieNode.next[word.charAt(i) - 'a'];\\n            }\\n        \\t\\n            trieNode.isWordEnd = true;\\n        }             \\n        \\n        // Step 2: search for words starting from each cell on the board and record the results\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n        \\tfindWordsSub(board, i, j, root.next[board[i][j] - 'a'], sb, res);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    // helper function for backtracing searching. \\n    private void findWordsSub(char[][] board, int i, int j, TrieNode trieNode, StringBuilder sb, List<String> res) {\\n    \\t// only proceed if there is a match for the letter at current cell\\n    \\tif (trieNode != null) {\\n    \\t    char ch = board[i][j];           // save current letter\\n    \\t    sb.append(ch);                   // append the letter to sb\\n    \\t    if (trieNode.isWordEnd) {        // check if current letter is the end of a word\\n    \\t\\tres.add(sb.toString());      // if so, record the word\\n                trieNode.isWordEnd = false;  // remove this word from the Trie structure to avoid repetition\\n    \\t    }\\n    \\t\\t\\n    \\t    board[i][j] = '{';  // modify current letter to indicate that it's visited. Here '{' = 'a' + 26 (in terms of ASCII).\\n    \\t\\t\\n    \\t    // do further search if there are more cells available out of the four neighbors\\n    \\t    if (i + 1 < board.length) {\\n    \\t\\tfindWordsSub(board, i + 1, j, trieNode.next[board[i + 1][j] - 'a'], sb, res);\\n    \\t    }\\n    \\t\\t\\n    \\t    if (i - 1 >= 0) {\\n    \\t\\tfindWordsSub(board, i - 1, j, trieNode.next[board[i - 1][j] - 'a'], sb, res);\\n    \\t    }\\n    \\t\\t\\n    \\t    if (j + 1 < board[0].length ) {\\n    \\t\\tfindWordsSub(board, i, j + 1, trieNode.next[board[i][j + 1] - 'a'], sb, res);\\n    \\t    }\\n    \\t\\t\\n    \\t    if (j - 1 >= 0) {\\n    \\t\\tfindWordsSub(board, i, j - 1, trieNode.next[board[i][j - 1] - 'a'], sb, res);\\n    \\t    }  \\t\\t\\n    \\t\\t\\n            // restore the letter at current cell and sb for backtracing\\n    \\t    board[i][j] = ch;\\n            sb.deleteCharAt(sb.length() - 1);\\n    \\t}\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvoid findWordsSub(char[][] board, int i, int j, TrieNode trieNode, StringBuilder sb, List<String> res);\\n```\n```\\n    // TrieNode for the Trie structure\\n    class TrieNode {\\n        TrieNode[] next;   // next level TrieNodes\\n        boolean isWordEnd; // true if this is the end of a word\\n        \\n        public TrieNode() {\\n            next = new TrieNode[27]; // Here I use an array of length 27 instead of 26 for later use\\n            isWordEnd = false;\\n        }\\n    }\\n    \\n    public List<String> findWords(char[][] board, String[] words) {   \\t\\n        int m = board.length;\\n        int n = (m == 0 ? 0 : board[0].length);\\n    \\t\\n    \\tList<String> res = new ArrayList<>();        // holding results\\n        StringBuilder sb = new StringBuilder(m * n); // holding the character sequence from root to current level(exclusive) in the Trie structure(initial capacity equal to the dimension of the board)\\n        TrieNode root = new TrieNode();              // root node for the Trie structure\\n        \\n        // Step 1: build up the Trie structure\\n        for (String word : words) {\\n            TrieNode trieNode = root;\\n        \\t\\n            for (int i = 0; i < word.length(); i++) {\\n        \\tif (trieNode.next[word.charAt(i) - 'a'] == null) {\\n        \\t    trieNode.next[word.charAt(i) - 'a'] = new TrieNode();\\n        \\t}\\n\\n        \\ttrieNode = trieNode.next[word.charAt(i) - 'a'];\\n            }\\n        \\t\\n            trieNode.isWordEnd = true;\\n        }             \\n        \\n        // Step 2: search for words starting from each cell on the board and record the results\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n        \\tfindWordsSub(board, i, j, root.next[board[i][j] - 'a'], sb, res);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    // helper function for backtracing searching. \\n    private void findWordsSub(char[][] board, int i, int j, TrieNode trieNode, StringBuilder sb, List<String> res) {\\n    \\t// only proceed if there is a match for the letter at current cell\\n    \\tif (trieNode != null) {\\n    \\t    char ch = board[i][j];           // save current letter\\n    \\t    sb.append(ch);                   // append the letter to sb\\n    \\t    if (trieNode.isWordEnd) {        // check if current letter is the end of a word\\n    \\t\\tres.add(sb.toString());      // if so, record the word\\n                trieNode.isWordEnd = false;  // remove this word from the Trie structure to avoid repetition\\n    \\t    }\\n    \\t\\t\\n    \\t    board[i][j] = '{';  // modify current letter to indicate that it's visited. Here '{' = 'a' + 26 (in terms of ASCII).\\n    \\t\\t\\n    \\t    // do further search if there are more cells available out of the four neighbors\\n    \\t    if (i + 1 < board.length) {\\n    \\t\\tfindWordsSub(board, i + 1, j, trieNode.next[board[i + 1][j] - 'a'], sb, res);\\n    \\t    }\\n    \\t\\t\\n    \\t    if (i - 1 >= 0) {\\n    \\t\\tfindWordsSub(board, i - 1, j, trieNode.next[board[i - 1][j] - 'a'], sb, res);\\n    \\t    }\\n    \\t\\t\\n    \\t    if (j + 1 < board[0].length ) {\\n    \\t\\tfindWordsSub(board, i, j + 1, trieNode.next[board[i][j + 1] - 'a'], sb, res);\\n    \\t    }\\n    \\t\\t\\n    \\t    if (j - 1 >= 0) {\\n    \\t\\tfindWordsSub(board, i, j - 1, trieNode.next[board[i][j - 1] - 'a'], sb, res);\\n    \\t    }  \\t\\t\\n    \\t\\t\\n            // restore the letter at current cell and sb for backtracing\\n    \\t    board[i][j] = ch;\\n            sb.deleteCharAt(sb.length() - 1);\\n    \\t}\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3900776,
                "title": "only-backtracking-no-tle-no-trie-used-c-java",
                "content": "# Intuition \\n**``` Find out all possible strings of size less than or equal to 10 and if it is in the words array then adding it ans```**\\n# Approach\\n**```To find all the possible strings we can use basic backtracking approach as shown in the below code```**\\n\\n** Start from every index of the matrix and make words of length less than equal to 10**\\n\\n# Complexity\\n**- Time complexity:**\\n**```The overall time complexity of the code is O(N * M * 4^10)```**\\n\\n**- Space complexity:**\\n**```Since we are using the dp table space complexity goes up to O(N * 2) => O(N) ```**\\n\\n# Code (C++)\\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    bool isSafe(int x, int y, vector<vector<char>> &board)\\n    {\\n        int n = board.size(), m = board[0].size();\\n        return (x >= 0 && y >= 0 && x < n && y < m && board[x][y] != \\'#\\');\\n    }\\n    vector<pair<int, int>> movements = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    void func(int x, int y, string &curr, vector<vector<char>> &board, unordered_set<string> &st)\\n    {\\n        if (curr.size() >= 10)\\n            return;\\n        if (!isSafe(x, y, board))\\n            return;\\n        curr += board[x][y];\\n        if (st.find(curr) != st.end())\\n        {\\n            st.erase(curr);\\n            ans.push_back(curr);\\n        }\\n        curr.pop_back();\\n        char ch = board[x][y];\\n        for (auto it : movements)\\n        {\\n            int nx = x + it.first;\\n            int ny = y + it.second;\\n            curr += board[x][y];\\n            board[x][y] = \\'#\\';\\n            func(nx, ny, curr, board, st);\\n            curr.pop_back();\\n            board[x][y] = ch;\\n        }\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        unordered_set<string> st;\\n        for (auto it : words)\\n            st.insert(it);\\n        int n = board.size(), m = board[0].size();\\n        for (int i = 0; i < n; ++i)\\n        {\\n            for (int j = 0; j < m; ++j)\\n            {\\n                string curr = \"\";\\n                func(i, j, curr, board, st);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Code (Java)\\n```\\nimport java.util.ArrayList;\\nimport java.util.HashSet;\\nimport java.util.List;\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n    int[][] movements = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n\\n    boolean isSafe(int x, int y, char[][] board) {\\n        int n = board.length;\\n        int m = board[0].length;\\n        return x >= 0 && y >= 0 && x < n && y < m && board[x][y] != \\'#\\';\\n    }\\n\\n    void func(int x, int y, StringBuilder curr, char[][] board, HashSet<String> st) {\\n        if (curr.length() >= 10)\\n            return;\\n        if (!isSafe(x, y, board))\\n            return;\\n        curr.append(board[x][y]);\\n        if (st.contains(curr.toString())) {\\n            st.remove(curr.toString());\\n            ans.add(curr.toString());\\n        }\\n        curr.deleteCharAt(curr.length() - 1);\\n        char ch = board[x][y];\\n        for (int[] it : movements) {\\n            int nx = x + it[0];\\n            int ny = y + it[1];\\n            curr.append(board[x][y]);\\n            board[x][y] = \\'#\\';\\n            func(nx, ny, curr, board, st);\\n            curr.deleteCharAt(curr.length() - 1);\\n            board[x][y] = ch;\\n        }\\n    }\\n\\n    public List<String> findWords(char[][] board, String[] words) {\\n        HashSet<String> st = new HashSet<>();\\n        for (String it : words)\\n            st.add(it);\\n        int n = board.length, m = board[0].length;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                StringBuilder curr = new StringBuilder();\\n                func(i, j, curr, board, st);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n``` Please Upvote if it was helpful ```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "``` Find out all possible strings of size less than or equal to 10 and if it is in the words array then adding it ans```\n```To find all the possible strings we can use basic backtracking approach as shown in the below code```\n```The overall time complexity of the code is O(N * M * 4^10)```\n```Since we are using the dp table space complexity goes up to O(N * 2) => O(N) ```\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    bool isSafe(int x, int y, vector<vector<char>> &board)\\n    {\\n        int n = board.size(), m = board[0].size();\\n        return (x >= 0 && y >= 0 && x < n && y < m && board[x][y] != \\'#\\');\\n    }\\n    vector<pair<int, int>> movements = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    void func(int x, int y, string &curr, vector<vector<char>> &board, unordered_set<string> &st)\\n    {\\n        if (curr.size() >= 10)\\n            return;\\n        if (!isSafe(x, y, board))\\n            return;\\n        curr += board[x][y];\\n        if (st.find(curr) != st.end())\\n        {\\n            st.erase(curr);\\n            ans.push_back(curr);\\n        }\\n        curr.pop_back();\\n        char ch = board[x][y];\\n        for (auto it : movements)\\n        {\\n            int nx = x + it.first;\\n            int ny = y + it.second;\\n            curr += board[x][y];\\n            board[x][y] = \\'#\\';\\n            func(nx, ny, curr, board, st);\\n            curr.pop_back();\\n            board[x][y] = ch;\\n        }\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        unordered_set<string> st;\\n        for (auto it : words)\\n            st.insert(it);\\n        int n = board.size(), m = board[0].size();\\n        for (int i = 0; i < n; ++i)\\n        {\\n            for (int j = 0; j < m; ++j)\\n            {\\n                string curr = \"\";\\n                func(i, j, curr, board, st);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nimport java.util.ArrayList;\\nimport java.util.HashSet;\\nimport java.util.List;\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n    int[][] movements = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n\\n    boolean isSafe(int x, int y, char[][] board) {\\n        int n = board.length;\\n        int m = board[0].length;\\n        return x >= 0 && y >= 0 && x < n && y < m && board[x][y] != \\'#\\';\\n    }\\n\\n    void func(int x, int y, StringBuilder curr, char[][] board, HashSet<String> st) {\\n        if (curr.length() >= 10)\\n            return;\\n        if (!isSafe(x, y, board))\\n            return;\\n        curr.append(board[x][y]);\\n        if (st.contains(curr.toString())) {\\n            st.remove(curr.toString());\\n            ans.add(curr.toString());\\n        }\\n        curr.deleteCharAt(curr.length() - 1);\\n        char ch = board[x][y];\\n        for (int[] it : movements) {\\n            int nx = x + it[0];\\n            int ny = y + it[1];\\n            curr.append(board[x][y]);\\n            board[x][y] = \\'#\\';\\n            func(nx, ny, curr, board, st);\\n            curr.deleteCharAt(curr.length() - 1);\\n            board[x][y] = ch;\\n        }\\n    }\\n\\n    public List<String> findWords(char[][] board, String[] words) {\\n        HashSet<String> st = new HashSet<>();\\n        for (String it : words)\\n            st.add(it);\\n        int n = board.length, m = board[0].length;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                StringBuilder curr = new StringBuilder();\\n                func(i, j, curr, board, st);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\n``` Please Upvote if it was helpful ```",
                "codeTag": "Java"
            },
            {
                "id": 3781916,
                "title": "simple-c-map-solution-without-trie",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nunordered_map<string,int> m;\\n\\nvoid solve(int i,int j,string s,vector<vector<char>>& board,\\nvector<string> &ans,unordered_map<string,int> &mp){\\n     if(mp.find(s)==mp.end()) return; \\n    if(i<0 || j<0 || j>=board[0].size() || i>=board.size()) return;\\n\\n    char old=board[i][j];\\n    board[i][j]=\\'*\\';\\n   \\n    if(m.find(s)!=m.end()){ ans.push_back(s);\\n    m.erase(s);}\\n    if(i-1>=0 && board[i-1][j]!=\\'*\\'){\\n        solve(i-1,j,s+board[i-1][j],board,ans,mp);\\n    }\\n    if(i+1<board.size() && board[i+1][j]!=\\'*\\'){\\n        solve(i+1,j,s+board[i+1][j],board,ans,mp);\\n    }\\n    if(j-1>=0 && board[i][j-1]!=\\'*\\'){\\n        solve(i,j-1,s+board[i][j-1],board,ans,mp);\\n    }\\n    if(j+1<board[0].size() && board[i][j+1]!=\\'*\\'){\\n        solve(i,j+1,s+board[i][j+1],board,ans,mp);\\n    }\\n    board[i][j]=old;\\n}\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        for(int i=0;i<words.size();i++){\\n            m[words[i]]++;\\n        }\\n       \\n        vector<string> ans;\\n        unordered_map<string,int> mp; //for storing prefixes of words \\n        for(auto i:words)\\n        {\\n            string t=\"\";\\n            for(int j=0;j<i.size();j++)\\n            {\\n                t+=i[j];\\n                mp[t]=1;\\n            }\\n        }\\n     \\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[0].size();j++){\\n                if(m.size()==0) return ans;\\n                    string temp=\"\";\\n\\n                    temp+=board[i][j];\\n                    solve(i,j,temp,board,ans,mp);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nunordered_map<string,int> m;\\n\\nvoid solve(int i,int j,string s,vector<vector<char>>& board,\\nvector<string> &ans,unordered_map<string,int> &mp){\\n     if(mp.find(s)==mp.end()) return; \\n    if(i<0 || j<0 || j>=board[0].size() || i>=board.size()) return;\\n\\n    char old=board[i][j];\\n    board[i][j]=\\'*\\';\\n   \\n    if(m.find(s)!=m.end()){ ans.push_back(s);\\n    m.erase(s);}\\n    if(i-1>=0 && board[i-1][j]!=\\'*\\'){\\n        solve(i-1,j,s+board[i-1][j],board,ans,mp);\\n    }\\n    if(i+1<board.size() && board[i+1][j]!=\\'*\\'){\\n        solve(i+1,j,s+board[i+1][j],board,ans,mp);\\n    }\\n    if(j-1>=0 && board[i][j-1]!=\\'*\\'){\\n        solve(i,j-1,s+board[i][j-1],board,ans,mp);\\n    }\\n    if(j+1<board[0].size() && board[i][j+1]!=\\'*\\'){\\n        solve(i,j+1,s+board[i][j+1],board,ans,mp);\\n    }\\n    board[i][j]=old;\\n}\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        for(int i=0;i<words.size();i++){\\n            m[words[i]]++;\\n        }\\n       \\n        vector<string> ans;\\n        unordered_map<string,int> mp; //for storing prefixes of words \\n        for(auto i:words)\\n        {\\n            string t=\"\";\\n            for(int j=0;j<i.size();j++)\\n            {\\n                t+=i[j];\\n                mp[t]=1;\\n            }\\n        }\\n     \\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[0].size();j++){\\n                if(m.size()==0) return ans;\\n                    string temp=\"\";\\n\\n                    temp+=board[i][j];\\n                    solve(i,j,temp,board,ans,mp);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711288,
                "title": "w-explanation-c-backtracking-trie",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code implements a Trie data structure to efficiently find words in a given board. It performs a depth-first search on the board, tracking visited cells and matching word paths in the Trie. The found words are stored and returned as the result.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe depth-first search (DFS) function explores the board starting from a specific cell. It checks for boundary conditions and visited cells. If the current cell\\'s character matches a link in the Trie, it continues the search in that direction. If a word is found, it is added to the result. The function backtracks by undoing cell modifications to explore other paths.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(N * 4^m)$ where N is the number of cells in the board and m is the maximum length of the words. \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(total word length + N)\\n# Code\\n```\\nclass Trie {\\npublic:\\n    bool isEnd = 0;\\n    array<Trie*, 26> links = {};\\n\\n    Trie() {}\\n\\n    void insert(string word) {\\n        Trie* node = this;\\n        for (char c : word) {\\n            int i = c - \\'a\\';\\n            if (node->links[i] == NULL) {\\n                node->links[i] = new Trie();\\n            }\\n            node = node->links[i];\\n        }\\n        node->isEnd = 1;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<char>> board;\\n    vector<string> ans;\\n    int n, m;\\n\\n    void dfs(int i, int j, Trie* cur, string& word) {\\n        if (i < 0 || i >= n || j < 0 || j >= m || board[i][j] == \\'@\\')\\n            return;\\n\\n        char c = board[i][j];\\n\\n        if (cur->links[c - \\'a\\'] == NULL)\\n            return;\\n\\n        word.push_back(c);\\n        cur = cur->links[c - \\'a\\'];\\n        if (cur->isEnd) {\\n            ans.push_back(word);\\n            cur->isEnd = 0;\\n        }\\n       \\n        board[i][j] = \\'@\\';// Mark as visited\\n        \\n        dfs(i + 1, j, cur, word);\\n        dfs(i, j + 1, cur, word);\\n        dfs(i - 1, j, cur, word);\\n        dfs(i, j - 1, cur, word);\\n\\n        board[i][j] = c;//Backtracking\\n        word.pop_back();\\n    }\\n\\n    vector<string> findWords(vector<vector<char>>& _board, vector<string>& _words) {\\n        board = _board;\\n        n = board.size();\\n        m = board[0].size();\\n        Trie* root = new Trie();\\n\\n        for (auto& w : _words)\\n            root->insert(w);\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                string word;\\n                dfs(i, j, root, word);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n# code for class Trie with Explanation in comments\\n```\\nclass Trie {\\npublic:\\n    bool isEnd = 0;\\n    array<Trie*, 26> links = {}; // Array of Trie pointers to child nodes\\n\\n    Trie() {}\\n\\n    void insert(string word) {\\n        Trie* node = this;\\n        for (char c : word) {\\n            int i = c - \\'a\\'; // Calculate the index for the character\\n            if (node->links[i] == NULL) {\\n                node->links[i] = new Trie(); // Create a new Trie node if the link is empty\\n            }\\n            node = node->links[i]; // Move to the next Trie node\\n        }\\n        node->isEnd = 1; // Mark the last Trie node as the end of a word\\n    }\\n};\\n\\n```\\n# Solution part with comments\\n```\\nclass Solution {\\npublic:\\n    vector<vector<char>> board;\\n    vector<string> ans;\\n    int n, m;\\n\\n    void dfs(int i, int j, Trie* cur, string& word) {\\n        if (i < 0 || i >= n || j < 0 || j >= m || board[i][j] == \\'@\\')\\n            return;\\n\\n        char c = board[i][j];\\n\\n        if (cur->links[c - \\'a\\'] == NULL)\\n            return;\\n\\n        word.push_back(c);\\n        cur = cur->links[c - \\'a\\'];\\n        if (cur->isEnd) {\\n            ans.push_back(word);\\n            cur->isEnd = 0;\\n        }\\n       \\n        board[i][j] = \\'@\\'; // Mark the cell as visited\\n        \\n        dfs(i + 1, j, cur, word);\\n        dfs(i, j + 1, cur, word);\\n        dfs(i - 1, j, cur, word);\\n        dfs(i, j - 1, cur, word);\\n\\n        board[i][j] = c; // Backtrack by restoring the cell value\\n        word.pop_back(); // Remove the last character from the word\\n    }\\n\\n    vector<string> findWords(vector<vector<char>>& _board, vector<string>& _words) {\\n        board = _board;\\n        n = board.size();\\n        m = board[0].size();\\n        Trie* root = new Trie();\\n\\n        for (auto& w : _words)\\n            root->insert(w);\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                string word;\\n                dfs(i, j, root, word);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Trie {\\npublic:\\n    bool isEnd = 0;\\n    array<Trie*, 26> links = {};\\n\\n    Trie() {}\\n\\n    void insert(string word) {\\n        Trie* node = this;\\n        for (char c : word) {\\n            int i = c - \\'a\\';\\n            if (node->links[i] == NULL) {\\n                node->links[i] = new Trie();\\n            }\\n            node = node->links[i];\\n        }\\n        node->isEnd = 1;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<char>> board;\\n    vector<string> ans;\\n    int n, m;\\n\\n    void dfs(int i, int j, Trie* cur, string& word) {\\n        if (i < 0 || i >= n || j < 0 || j >= m || board[i][j] == \\'@\\')\\n            return;\\n\\n        char c = board[i][j];\\n\\n        if (cur->links[c - \\'a\\'] == NULL)\\n            return;\\n\\n        word.push_back(c);\\n        cur = cur->links[c - \\'a\\'];\\n        if (cur->isEnd) {\\n            ans.push_back(word);\\n            cur->isEnd = 0;\\n        }\\n       \\n        board[i][j] = \\'@\\';// Mark as visited\\n        \\n        dfs(i + 1, j, cur, word);\\n        dfs(i, j + 1, cur, word);\\n        dfs(i - 1, j, cur, word);\\n        dfs(i, j - 1, cur, word);\\n\\n        board[i][j] = c;//Backtracking\\n        word.pop_back();\\n    }\\n\\n    vector<string> findWords(vector<vector<char>>& _board, vector<string>& _words) {\\n        board = _board;\\n        n = board.size();\\n        m = board[0].size();\\n        Trie* root = new Trie();\\n\\n        for (auto& w : _words)\\n            root->insert(w);\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                string word;\\n                dfs(i, j, root, word);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Trie {\\npublic:\\n    bool isEnd = 0;\\n    array<Trie*, 26> links = {}; // Array of Trie pointers to child nodes\\n\\n    Trie() {}\\n\\n    void insert(string word) {\\n        Trie* node = this;\\n        for (char c : word) {\\n            int i = c - \\'a\\'; // Calculate the index for the character\\n            if (node->links[i] == NULL) {\\n                node->links[i] = new Trie(); // Create a new Trie node if the link is empty\\n            }\\n            node = node->links[i]; // Move to the next Trie node\\n        }\\n        node->isEnd = 1; // Mark the last Trie node as the end of a word\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<char>> board;\\n    vector<string> ans;\\n    int n, m;\\n\\n    void dfs(int i, int j, Trie* cur, string& word) {\\n        if (i < 0 || i >= n || j < 0 || j >= m || board[i][j] == \\'@\\')\\n            return;\\n\\n        char c = board[i][j];\\n\\n        if (cur->links[c - \\'a\\'] == NULL)\\n            return;\\n\\n        word.push_back(c);\\n        cur = cur->links[c - \\'a\\'];\\n        if (cur->isEnd) {\\n            ans.push_back(word);\\n            cur->isEnd = 0;\\n        }\\n       \\n        board[i][j] = \\'@\\'; // Mark the cell as visited\\n        \\n        dfs(i + 1, j, cur, word);\\n        dfs(i, j + 1, cur, word);\\n        dfs(i - 1, j, cur, word);\\n        dfs(i, j - 1, cur, word);\\n\\n        board[i][j] = c; // Backtrack by restoring the cell value\\n        word.pop_back(); // Remove the last character from the word\\n    }\\n\\n    vector<string> findWords(vector<vector<char>>& _board, vector<string>& _words) {\\n        board = _board;\\n        n = board.size();\\n        m = board[0].size();\\n        Trie* root = new Trie();\\n\\n        for (auto& w : _words)\\n            root->insert(w);\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                string word;\\n                dfs(i, j, root, word);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3156803,
                "title": "highly-commented-solution-using-trie",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    /*\\n    4 parts\\n    TrieNode definition and declaration of root\\n    dfs traversal logic\\n    insert word logic\\n    main function\\n    */\\n    //new trienode() ka syntax matlab?\\n    struct TrieNode\\n    {\\n        TrieNode* child[26];//node pointing to other 26 possible nodes...if they dont exist then null\\n        bool flag=false;//for knowing if the node is the end of a possible word or not\\n        bool Inserted=false;//to avoid duplicates in ans...if the word already inserted\\n        string str;//keeping record of string that has made its way to here\\n        bool containChar(char character)\\n        {\\n            return (child[character-\\'a\\']!=NULL);//to see if the node contains the character as next node\\n        }\\n        void putNode(char nxtchar,TrieNode* node)\\n        {\\n            child[nxtchar-\\'a\\']=node;//if next character doesnt exist in trie the to insert\\n        }\\n        TrieNode* getNode(char character)\\n        {\\n            return child[character-\\'a\\'];//maybe traverse the trie further if we get our way in dfs\\n        }\\n        void setEnd()\\n        {\\n            flag=true;//sets end tag to node denoting it being end of one word\\n        }\\n        bool isEnd()\\n        {\\n            return flag;//to know if its the end or not\\n        }\\n        bool didInsert()\\n        {\\n            return Inserted;//self explanatory\\n        }\\n        void setdidInsert()\\n        {\\n            Inserted=true;//      \"\\n        }\\n    };\\n    TrieNode* root=new TrieNode();//publicly define root of our Trie\\n    void insertWord(string word)//insert words from vector given into our Trie\\n    {\\n        TrieNode* node=root;\\n        int i;\\n        for(i=0;i<word.size();i++)\\n        {\\n            if(node->containChar(word[i]) ==false)\\n            {\\n                node->putNode(word[i],new TrieNode());//if not present then insert\\n            }\\n            node=node->getNode(word[i]);//traverse further in trie (now that the character is inserted if it didnt exist before)\\n        }\\n        node->setEnd();//set end to final node after traversal of word\\n        node->str=word;//assign str\\n    }\\n    void dfs(vector<vector<char>>&board,int i,int j,TrieNode* node,vector<string>&ans,vector<vector<bool>>&visited)\\n    {\\n        if((i<0)||(j<0)||(i>board.size()-1)||(j>board[0].size()-1))\\n        {\\n            return;//since while doing dfs we call in all four directions\\n            //like this we dont have to take caution while calling dfs in which directions\\n        }\\n        if(visited[i][j])\\n        {\\n            return;//if already visited then return\\n        }\\n        node=node->getNode(board[i][j]);\\n        if(node==NULL)\\n        {\\n            return;//if the node for that further character doesnt exist\\n        }\\n        if(node->isEnd() && !(node->Inserted))\\n        {\\n            ans.push_back(node->str);//if is end and not inserted before\\n            node->Inserted=true;//so no re pushing of same word back possibly\\n        }\\n        visited[i][j]=true;\\n        dfs(board,i+1,j,node,ans,visited);\\n        dfs(board,i,j+1,node,ans,visited);\\n        dfs(board,i-1,j,node,ans,visited);\\n        dfs(board,i,j-1,node,ans,visited);//calling in all 4 directions\\n        visited[i][j]=false;//while backtracking in dfs...it re assigns the previous value of false to assigned ones\\n    }\\n    vector<string> findWords(vector<vector<char>>& board,vector<string>& words) \\n    {\\n        vector<string>ans;\\n        for(string word:words)\\n        {\\n            insertWord(word);//makes our Trie/Inserting words one by one\\n        }\\n        vector<vector<bool>>visited(board.size(),vector<bool>(board[0].size(),false));//to avoid infinite looping in dfs and keep record of visited ones\\n        // size, value(size,value)\\n        int i,j;\\n        for(i=0;i<board.size();i++)\\n        {\\n            for(j=0;j<board[0].size();j++)//traverse matrix and check for all words but efficiently bcoz of trie\\n            {\\n                dfs(board,i,j,root,ans,visited);\\n                // board to traverse,i and j to know current position, root to check in trie,push word if found,visited to keep record\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n    4 parts\\n    TrieNode definition and declaration of root\\n    dfs traversal logic\\n    insert word logic\\n    main function\\n    */\\n    //new trienode() ka syntax matlab?\\n    struct TrieNode\\n    {\\n        TrieNode* child[26];//node pointing to other 26 possible nodes...if they dont exist then null\\n        bool flag=false;//for knowing if the node is the end of a possible word or not\\n        bool Inserted=false;//to avoid duplicates in ans...if the word already inserted\\n        string str;//keeping record of string that has made its way to here\\n        bool containChar(char character)\\n        {\\n            return (child[character-\\'a\\']!=NULL);//to see if the node contains the character as next node\\n        }\\n        void putNode(char nxtchar,TrieNode* node)\\n        {\\n            child[nxtchar-\\'a\\']=node;//if next character doesnt exist in trie the to insert\\n        }\\n        TrieNode* getNode(char character)\\n        {\\n            return child[character-\\'a\\'];//maybe traverse the trie further if we get our way in dfs\\n        }\\n        void setEnd()\\n        {\\n            flag=true;//sets end tag to node denoting it being end of one word\\n        }\\n        bool isEnd()\\n        {\\n            return flag;//to know if its the end or not\\n        }\\n        bool didInsert()\\n        {\\n            return Inserted;//self explanatory\\n        }\\n        void setdidInsert()\\n        {\\n            Inserted=true;//      \"\\n        }\\n    };\\n    TrieNode* root=new TrieNode();//publicly define root of our Trie\\n    void insertWord(string word)//insert words from vector given into our Trie\\n    {\\n        TrieNode* node=root;\\n        int i;\\n        for(i=0;i<word.size();i++)\\n        {\\n            if(node->containChar(word[i]) ==false)\\n            {\\n                node->putNode(word[i],new TrieNode());//if not present then insert\\n            }\\n            node=node->getNode(word[i]);//traverse further in trie (now that the character is inserted if it didnt exist before)\\n        }\\n        node->setEnd();//set end to final node after traversal of word\\n        node->str=word;//assign str\\n    }\\n    void dfs(vector<vector<char>>&board,int i,int j,TrieNode* node,vector<string>&ans,vector<vector<bool>>&visited)\\n    {\\n        if((i<0)||(j<0)||(i>board.size()-1)||(j>board[0].size()-1))\\n        {\\n            return;//since while doing dfs we call in all four directions\\n            //like this we dont have to take caution while calling dfs in which directions\\n        }\\n        if(visited[i][j])\\n        {\\n            return;//if already visited then return\\n        }\\n        node=node->getNode(board[i][j]);\\n        if(node==NULL)\\n        {\\n            return;//if the node for that further character doesnt exist\\n        }\\n        if(node->isEnd() && !(node->Inserted))\\n        {\\n            ans.push_back(node->str);//if is end and not inserted before\\n            node->Inserted=true;//so no re pushing of same word back possibly\\n        }\\n        visited[i][j]=true;\\n        dfs(board,i+1,j,node,ans,visited);\\n        dfs(board,i,j+1,node,ans,visited);\\n        dfs(board,i-1,j,node,ans,visited);\\n        dfs(board,i,j-1,node,ans,visited);//calling in all 4 directions\\n        visited[i][j]=false;//while backtracking in dfs...it re assigns the previous value of false to assigned ones\\n    }\\n    vector<string> findWords(vector<vector<char>>& board,vector<string>& words) \\n    {\\n        vector<string>ans;\\n        for(string word:words)\\n        {\\n            insertWord(word);//makes our Trie/Inserting words one by one\\n        }\\n        vector<vector<bool>>visited(board.size(),vector<bool>(board[0].size(),false));//to avoid infinite looping in dfs and keep record of visited ones\\n        // size, value(size,value)\\n        int i,j;\\n        for(i=0;i<board.size();i++)\\n        {\\n            for(j=0;j<board[0].size();j++)//traverse matrix and check for all words but efficiently bcoz of trie\\n            {\\n                dfs(board,i,j,root,ans,visited);\\n                // board to traverse,i and j to know current position, root to check in trie,push word if found,visited to keep record\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780345,
                "title": "c-2-approaches-dfs-trie-map",
                "content": "**Approach 1: (DFS + Map) TLE**\\n```\\nclass Solution {\\npublic:\\n    int n,m;\\n    void search(int i, int j, int ind, vector<vector<char>>& board, string &word, bool &found)\\n    {\\n        if(board[i][j]==\\'1\\' || found)     return;\\n        if(ind == word.size())\\n        { \\n            found = true;\\n            return;\\n        }\\n        char temp = board[i][j];\\n        board[i][j] = \\'1\\';\\n        if(i-1>=0 && board[i-1][j]==word[ind]) search(i-1,j,ind+1,board,word,found);\\n        if(i+1<n && board[i+1][j]==word[ind]) search(i+1,j,ind+1,board,word,found);\\n        if(j+1<m && board[i][j+1]==word[ind]) search(i,j+1,ind+1,board,word,found);\\n        if(j-1>=0 && board[i][j-1]==word[ind]) search(i,j-1,ind+1,board,word,found);\\n        board[i][j] = temp;\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        unordered_map<char,vector<string>>mp;\\n        vector<string> ans;\\n        n = board.size();\\n        m = board[0].size();\\n        for(int i=0;i<words.size();i++)     mp[words[i][0]].push_back(words[i]);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(mp[board[i][j]].size() > 0)\\n                {\\n                    for(auto m:mp[board[i][j]])\\n                    {\\n                        bool found = false;\\n                        search(i,j,1,board,m,found);\\n                        if(found && find(ans.begin(), ans.end(), m)==ans.end()) \\n                            ans.push_back(m);\\n\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Approach 2: (DFS + Trie) \\u2705**\\n```\\nclass Solution {\\n    struct node{\\n        char c;\\n        int ends;\\n        string word;\\n        node *child[26];\\n    };\\n    struct node *getNode(char c)\\n    {\\n        node *newnode = new node;\\n        newnode->c = c;\\n        newnode->ends = 0;\\n         newnode->word = \"\";\\n        for(int i=0;i<26;++i)\\n            newnode->child[i] = NULL;\\n        return newnode;\\n    }\\n    node *root = getNode(\\'/\\');  //root\\n    \\n    //Trie INSERT\\n    void insert(string s)\\n    {\\n        node *curr=root;\\n        int index,i=0;\\n        while(s[i])\\n        {\\n            index = s[i]-\\'a\\';\\n            if(curr->child[index]==NULL)\\n                curr->child[index] = getNode(s[i]);\\n            \\n            curr=curr->child[index];\\n            i+=1;\\n        }\\n        curr->ends += 1;\\n        curr->word = s;\\n    }\\n    \\n    void solve(vector<vector<char>>& board,int i,int j,int r,int c,vector<string>& ans,node *curr)\\n    {\\n        //Base case\\n        //If the trie doesn\\'t have the current char OR cell is Visited\\n        int index = board[i][j]-\\'a\\';\\n        if(board[i][j]==\\'$\\' || curr->child[index]==NULL)  \\n            return;\\n        \\n        curr = curr->child[index];\\n        if(curr->ends > 0)\\n        {\\n            ans.push_back(curr->word);\\n            curr->ends -=1;\\n        }\\n        \\n        //Body\\n        char ch = board[i][j];   //Store current char\\n        board[i][j] = \\'$\\';  //Mark current node visited\\n        \\n        if(i>0)     //TOP\\n            solve(board,i-1,j,r,c,ans,curr);\\n        if(i<r-1)   //DOWN\\n            solve(board,i+1,j,r,c,ans,curr);\\n        if(j>0)     //LEFT\\n            solve(board,i,j-1,r,c,ans,curr);\\n        if(j<c-1)   //RIGHT\\n            solve(board,i,j+1,r,c,ans,curr);\\n        \\n        board[i][j] = ch;    //Mark current node as Unvisited by restoring the value\\n    }\\n    \\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {        \\n        int r=board.size();\\n        int c=board[0].size();\\n        \\n        //Insert all words in TRIE\\n        for(int i=0;i<words.size();++i)\\n            insert(words[i]);\\n        \\n        //Now search words\\n        vector<string> ans;\\n        for(int i=0;i<r;++i)\\n        {\\n            for(int j=0;j<c;++j)\\n                solve(board,i,j,r,c,ans,root);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    void search(int i, int j, int ind, vector<vector<char>>& board, string &word, bool &found)\\n    {\\n        if(board[i][j]==\\'1\\' || found)     return;\\n        if(ind == word.size())\\n        { \\n            found = true;\\n            return;\\n        }\\n        char temp = board[i][j];\\n        board[i][j] = \\'1\\';\\n        if(i-1>=0 && board[i-1][j]==word[ind]) search(i-1,j,ind+1,board,word,found);\\n        if(i+1<n && board[i+1][j]==word[ind]) search(i+1,j,ind+1,board,word,found);\\n        if(j+1<m && board[i][j+1]==word[ind]) search(i,j+1,ind+1,board,word,found);\\n        if(j-1>=0 && board[i][j-1]==word[ind]) search(i,j-1,ind+1,board,word,found);\\n        board[i][j] = temp;\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        unordered_map<char,vector<string>>mp;\\n        vector<string> ans;\\n        n = board.size();\\n        m = board[0].size();\\n        for(int i=0;i<words.size();i++)     mp[words[i][0]].push_back(words[i]);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(mp[board[i][j]].size() > 0)\\n                {\\n                    for(auto m:mp[board[i][j]])\\n                    {\\n                        bool found = false;\\n                        search(i,j,1,board,m,found);\\n                        if(found && find(ans.begin(), ans.end(), m)==ans.end()) \\n                            ans.push_back(m);\\n\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    struct node{\\n        char c;\\n        int ends;\\n        string word;\\n        node *child[26];\\n    };\\n    struct node *getNode(char c)\\n    {\\n        node *newnode = new node;\\n        newnode->c = c;\\n        newnode->ends = 0;\\n         newnode->word = \"\";\\n        for(int i=0;i<26;++i)\\n            newnode->child[i] = NULL;\\n        return newnode;\\n    }\\n    node *root = getNode(\\'/\\');  //root\\n    \\n    //Trie INSERT\\n    void insert(string s)\\n    {\\n        node *curr=root;\\n        int index,i=0;\\n        while(s[i])\\n        {\\n            index = s[i]-\\'a\\';\\n            if(curr->child[index]==NULL)\\n                curr->child[index] = getNode(s[i]);\\n            \\n            curr=curr->child[index];\\n            i+=1;\\n        }\\n        curr->ends += 1;\\n        curr->word = s;\\n    }\\n    \\n    void solve(vector<vector<char>>& board,int i,int j,int r,int c,vector<string>& ans,node *curr)\\n    {\\n        //Base case\\n        //If the trie doesn\\'t have the current char OR cell is Visited\\n        int index = board[i][j]-\\'a\\';\\n        if(board[i][j]==\\'$\\' || curr->child[index]==NULL)  \\n            return;\\n        \\n        curr = curr->child[index];\\n        if(curr->ends > 0)\\n        {\\n            ans.push_back(curr->word);\\n            curr->ends -=1;\\n        }\\n        \\n        //Body\\n        char ch = board[i][j];   //Store current char\\n        board[i][j] = \\'$\\';  //Mark current node visited\\n        \\n        if(i>0)     //TOP\\n            solve(board,i-1,j,r,c,ans,curr);\\n        if(i<r-1)   //DOWN\\n            solve(board,i+1,j,r,c,ans,curr);\\n        if(j>0)     //LEFT\\n            solve(board,i,j-1,r,c,ans,curr);\\n        if(j<c-1)   //RIGHT\\n            solve(board,i,j+1,r,c,ans,curr);\\n        \\n        board[i][j] = ch;    //Mark current node as Unvisited by restoring the value\\n    }\\n    \\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {        \\n        int r=board.size();\\n        int c=board[0].size();\\n        \\n        //Insert all words in TRIE\\n        for(int i=0;i<words.size();++i)\\n            insert(words[i]);\\n        \\n        //Now search words\\n        vector<string> ans;\\n        for(int i=0;i<r;++i)\\n        {\\n            for(int j=0;j<c;++j)\\n                solve(board,i,j,r,c,ans,root);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2077152,
                "title": "python3-trie-dfs-easy-to-understand-solution",
                "content": "```\\n\\'\\'\\'\\nIn Brute Force DFS time complexity: O(k * m * n * 4^(m*n)) where k = len(words)\\nBut we can remove the k if we store all the words into a TRIE.\\n\\'\\'\\'\\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.endOfWord = False\\n    \\n    def addWord(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n        cur.endOfWord = True\\n    \\nclass Solution:\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.addWord(word)\\n        \\n        row = len(board); col = len(board[0])\\n        res = set()\\n        \\n        def dfs(r, c, node, word):\\n            if (r < 0 or c < 0 or r >= row or c >= col or \\n                board[r][c] not in node.children or board[r][c] == \\'#\\'):\\n                return\\n            \\n            word += board[r][c]\\n            node = node.children[board[r][c]]\\n            if node.endOfWord:\\n                res.add(word)\\n                node.endOfWord = False\\n            tmp = board[r][c]\\n            board[r][c] = \\'#\\'\\n            dfs(r-1, c, node, word)\\n            dfs(r+1, c, node, word)\\n            dfs(r, c-1, node, word)\\n            dfs(r, c+1, node, word)\\n            board[r][c] = tmp\\n            \\n        for r in range(row):\\n            for c in range(col):\\n                dfs(r, c, root, \"\")\\n        \\n        return res\\n    \\n# Time: O(m * n * 4^(m*n))\\n# Space: O(m*n + k)\\n```\\n**NOTE:** The above solution will pass all 63 / 63 test cases but takes too much time.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\n\\'\\'\\'\\nIn Brute Force DFS time complexity: O(k * m * n * 4^(m*n)) where k = len(words)\\nBut we can remove the k if we store all the words into a TRIE.\\n\\'\\'\\'\\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.endOfWord = False\\n    \\n    def addWord(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n        cur.endOfWord = True\\n    \\nclass Solution:\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.addWord(word)\\n        \\n        row = len(board); col = len(board[0])\\n        res = set()\\n        \\n        def dfs(r, c, node, word):\\n            if (r < 0 or c < 0 or r >= row or c >= col or \\n                board[r][c] not in node.children or board[r][c] == \\'#\\'):\\n                return\\n            \\n            word += board[r][c]\\n            node = node.children[board[r][c]]\\n            if node.endOfWord:\\n                res.add(word)\\n                node.endOfWord = False\\n            tmp = board[r][c]\\n            board[r][c] = \\'#\\'\\n            dfs(r-1, c, node, word)\\n            dfs(r+1, c, node, word)\\n            dfs(r, c-1, node, word)\\n            dfs(r, c+1, node, word)\\n            board[r][c] = tmp\\n            \\n        for r in range(row):\\n            for c in range(col):\\n                dfs(r, c, root, \"\")\\n        \\n        return res\\n    \\n# Time: O(m * n * 4^(m*n))\\n# Space: O(m*n + k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1858797,
                "title": "java-trie-dfs-simple-easy-explained-with-diagram-on-paper",
                "content": "If you like the explanation/diagram, do **UpVote** :)\\n\\n**Note**: There are many ways to shorten the Runtime, as I see many have mentioned Runtime of less than 50 or 100ms. But the overall runtime Complexity is still same/similar.\\n                Please note, in coding interview, interviewer may ask us to implement in various ways. \\n\\t\\t\\t\\t   a.   Example, we may be asked, not to replace character by some symbol like \"#\", but instead to use some extra space. Hence, I have used extra 2D matrix named \"visited\" to keep track of visited ones.\\n\\t\\t\\t\\t   b. I have tried to keep logic quite simple and commented it, for easy understanding. Hope that helps.\\n\\n## Explanation:\\nCheck the diagram, and the comments for explanation. Let me know and I can provide detailed explanation, if needed :)\\n## Trie Diagram (first test case)  \\n![image](https://assets.leetcode.com/users/images/ea0eadfa-9943-407d-88a4-3ced933c5796_1647541617.3269982.png)\\n\\n## Code\\n\\tclass Solution {\\n\\t\\tpublic List<String> findWords(char[][] board, String[] words) {\\n\\t\\t\\tint rows = board.length, cols = board[0].length;\\n\\t\\t\\tTrie trie = new Trie();\\n\\n\\t\\t\\tfillTrie(trie, words);                                                                                            // First, we will fill up the Trie with all words.  \\n\\t\\t\\treturn findWordInBoard(board, trie, rows, cols, new ArrayList<>());                                               // Then, call method to \"find Word In Board\"\\n\\t\\t}\\n\\n\\t\\t// ----------------------------------------------------------------------------------------------------------------------------------------------- //\\n\\t\\tpublic List<String> findWordInBoard(char[][] board, Trie trie, int rows, int cols, List<String> resultList){\\n\\t\\t\\tTrie.TrieNode node;\\n\\t\\t\\tfor(int r = 0; r < rows; r++){\\n\\t\\t\\t\\tfor(int c = 0; c < cols; c++){                                                                                 // traverese each char in Board.\\n\\t\\t\\t\\t\\tchar ch = board[r][c];\\n\\t\\t\\t\\t\\tnode = trie.root;                                                                                          // we need to reset node each time to root.\\n\\t\\t\\t\\t\\tif(node.children[ch - \\'a\\'] == null){ continue; }                                                           // if child exists at children[o - \\'a\\']. children[111-97] = children[14]\\n\\t\\t\\t\\t\\tresultList = dfsOnBoard(board, node.children[ch - \\'a\\'], new boolean[rows][cols], r, c, resultList);        // call method, DFS on board \\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn resultList;\\n\\t\\t}\\n\\n\\t\\t// ----------------------------------------------------------------------------------------------------------------------------------------------- //\\n\\t\\tpublic List<String> dfsOnBoard(char[][] board, Trie.TrieNode node, boolean[][] visited, int row, int col, List<String> resultList){\\n\\t\\t\\tint rows = board.length, cols = board[0].length;\\n\\t\\t\\tif( row < 0   ||   row >= rows   ||  col < 0   ||  col >= cols   ||   \\n\\t\\t\\t\\tvisited[row][col] == true    ||    board[row][col] != node.val ){\\n\\t\\t\\t\\treturn resultList;                                                                                             // check bounds, where it returns false   \\n\\t\\t\\t}\\n\\t\\t\\tif(node!= null && ! node.wordEnd.isEmpty() ){                                                                      // when we reach node in Trie, where we have got a word. \\n\\t\\t\\t\\tif(! node.isDone){                                                                                             // initially isDone = false            \\n\\t\\t\\t\\t\\tresultList.add(node.wordEnd);\\n\\t\\t\\t\\t\\tnode.isDone = true;                                                                                        // once we add this word to resultList, mark isDone = true. \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// So, we can avoid duplicate word (in case if same \"words\" array has duplicate words).\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tvisited[row][col] = true;\\n\\t\\t\\tfor(Trie.TrieNode childNode : node.children){\\n\\t\\t\\t\\tif(childNode == null){ continue; }\\n\\t\\t\\t\\tdfsOnBoard(board, childNode, visited, row, col-1, resultList);                                 // DFS on Left\\n\\t\\t\\t\\tdfsOnBoard(board, childNode, visited, row, col+1, resultList);                                 // DFS on Right\\n\\t\\t\\t\\tdfsOnBoard(board, childNode, visited, row-1, col, resultList);                                 // DFS on Up\\n\\t\\t\\t\\tdfsOnBoard(board, childNode, visited, row+1, col, resultList);                                 // DFS on Down                \\n\\t\\t\\t}        \\n\\t\\t\\tvisited[row][col] = false;\\n\\t\\t\\treturn resultList;\\n\\t\\t}\\n\\n\\t\\t// -----------------------------------------------------------------------\\n\\t\\tpublic void fillTrie(Trie trie, String[] words){\\n\\t\\t\\tfor(String word : words){\\n\\t\\t\\t\\ttrie.insert(word, trie.root);                                                                                   //  insert each word to Trie\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\n\\t\\t// ---------------------------------------------------------------------- TRIE ------------------------------------------------------------------------ //\\n\\t\\tstatic class Trie{\\n\\t\\t\\tTrieNode root;\\n\\t\\t\\tpublic Trie(){\\n\\t\\t\\t\\troot = new TrieNode(\\' \\');\\n\\t\\t\\t}\\n\\n\\t\\t\\t// ----------------------------------------------------------\\n\\t\\t\\tpublic void insert(String word, TrieNode node){\\n\\t\\t\\t\\tfor( char ch : word.toCharArray() ){\\n\\t\\t\\t\\t\\tnode = insertCharInTrie(node, ch);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnode.wordEnd = word;\\n\\t\\t\\t}\\n\\t\\t\\tpublic TrieNode insertCharInTrie(TrieNode node, char ch){\\n\\t\\t\\t\\tif(node.children[ch - \\'a\\'] == null){\\n\\t\\t\\t\\t\\tnode.children[ch - \\'a\\'] = new TrieNode(ch);                                \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnode = node.children[ch - \\'a\\'];\\n\\t\\t\\t\\treturn node;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// ---------------- TRIENODE ----------------------\\n\\t\\t\\tstatic class TrieNode{\\n\\t\\t\\t\\tchar val;                                                                                       // node\\'s char value e.g. \\'o\\'\\n\\t\\t\\t\\tString wordEnd = \"\";\\n\\t\\t\\t\\tboolean isDone = false;\\n\\t\\t\\t\\tTrieNode[] children;\\n\\t\\t\\t\\tTrieNode(char val){                                                                             // pass val in the constructor \\n\\t\\t\\t\\t\\tthis.val = val;\\n\\t\\t\\t\\t\\tchildren = new TrieNode[26];                                                                // each node can have upto 26 children.\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\nIf you like the explanation, do **UpVote** :)\\nIf you need more explanation or, if there is more optimized way, **comment** below.",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "class Solution {\\n\\t\\tpublic List<String> findWords(char[][] board, String[] words) {\\n\\t\\t\\tint rows = board.length, cols = board[0].length;\\n\\t\\t\\tTrie trie = new Trie();\\n\\n\\t\\t\\tfillTrie(trie, words);                                                                                            // First, we will fill up the Trie with all words.  \\n\\t\\t\\treturn findWordInBoard(board, trie, rows, cols, new ArrayList<>());                                               // Then, call method to \"find Word In Board\"\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1513064,
                "title": "dfs-runtime-4-ms-faster-than-98-23-of-c-online-submissions",
                "content": "- Variation of [word search-i](https://leetcode.com/problems/word-search) \\n```cpp\\nclass Solution {\\nprivate:\\n    //DFS :  if we get word of first letter seach all possible path upto its length\\n    bool searchWord(vector<vector<char>>&board,long long i,long long j,long long count,string word){\\n        //Base case : we get all the char of words \\n        if(count==word.length()){\\n            return true;\\n        }\\n\\n        //case : out of bound like i and j must be in board and word[count]==bord[i][j] other wise false return false\\n        if(i<0 or i>=board.size() or j<0 or j>=board[i].size() or board[i][j]!=word[count]){\\n            return false;    \\n        }\\n\\n        //mark for not visiting duplicate :\\n        char temp = board[i][j];\\n        board[i][j]=\\' \\';\\n\\n        //search for possible paths :\\n        bool found = searchWord(board,i+1,j,count+1,word) ||  //right\\n\\t\\t\\t\\t\\t searchWord(board,i-1,j,count+1,word) ||  //left\\n\\t\\t\\t\\t\\t searchWord(board,i,j+1,count+1,word)||  //down\\n\\t\\t\\t\\t\\t searchWord(board,i,j-1,count+1,word);   //up \\n        \\n        //unmark the word for next call  : \\n        board[i][j] = temp;\\n\\n        return found; \\n    }\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        vector<string>ans;\\n        string temp;\\n        for(int w=0;w<words.size();w++){\\n            bool flag=false;\\n            temp=words[w];\\n            reverse(temp.begin(),temp.end());\\n            for(long long i=0;i<board.size();i++){\\n                for(long long j=0;j<board[i].size();j++){\\n                    if(board[i][j] == temp[0] and searchWord(board,i,j,0,temp)){\\n                        reverse(temp.begin(),temp.end());\\n                        ans.push_back(temp);\\n                        flag=1;\\n                        break;\\n                    }\\n                }\\n                if(flag==true){\\n                    break;\\n                }\\n            }\\n        }    \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```cpp\\nclass Solution {\\nprivate:\\n    //DFS :  if we get word of first letter seach all possible path upto its length\\n    bool searchWord(vector<vector<char>>&board,long long i,long long j,long long count,string word){\\n        //Base case : we get all the char of words \\n        if(count==word.length()){\\n            return true;\\n        }\\n\\n        //case : out of bound like i and j must be in board and word[count]==bord[i][j] other wise false return false\\n        if(i<0 or i>=board.size() or j<0 or j>=board[i].size() or board[i][j]!=word[count]){\\n            return false;    \\n        }\\n\\n        //mark for not visiting duplicate :\\n        char temp = board[i][j];\\n        board[i][j]=\\' \\';\\n\\n        //search for possible paths :\\n        bool found = searchWord(board,i+1,j,count+1,word) ||  //right\\n\\t\\t\\t\\t\\t searchWord(board,i-1,j,count+1,word) ||  //left\\n\\t\\t\\t\\t\\t searchWord(board,i,j+1,count+1,word)||  //down\\n\\t\\t\\t\\t\\t searchWord(board,i,j-1,count+1,word);   //up \\n        \\n        //unmark the word for next call  : \\n        board[i][j] = temp;\\n\\n        return found; \\n    }\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        vector<string>ans;\\n        string temp;\\n        for(int w=0;w<words.size();w++){\\n            bool flag=false;\\n            temp=words[w];\\n            reverse(temp.begin(),temp.end());\\n            for(long long i=0;i<board.size();i++){\\n                for(long long j=0;j<board[i].size();j++){\\n                    if(board[i][j] == temp[0] and searchWord(board,i,j,0,temp)){\\n                        reverse(temp.begin(),temp.end());\\n                        ans.push_back(temp);\\n                        flag=1;\\n                        break;\\n                    }\\n                }\\n                if(flag==true){\\n                    break;\\n                }\\n            }\\n        }    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1511731,
                "title": "java-7ms-beat-98-trietree-node-with-counter-pruning",
                "content": "```\\nclass Solution {\\n    \\n    public class TrieNode {\\n        TrieNode[] next;\\n        String word;\\n        int refCnt;\\n        public TrieNode() {\\n            this.next = new TrieNode[26];   \\n        }\\n    }\\n    int[][] dirs = new int[][] {{1, 0}, {-1, 0}, {0, -1}, {0, 1}};\\n    \\n    TrieNode root;\\n    \\n    public List<String> findWords(char[][] board, String[] words) {\\n        root = new TrieNode();\\n        for (String word: words) {\\n            buildTree(word);\\n        }\\n        List<String> res = new ArrayList<>();\\n        int n = board.length;\\n        int m = board[0].length;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (root.next[board[i][j] - \\'a\\'] != null && root.next[board[i][j] - \\'a\\'].refCnt > 0) {\\n                    dfs(board, i, j, root, res);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private void dfs(char[][] board, int i, int j, TrieNode cur, List<String> res) {\\n        if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] == \\'@\\'  || cur.next[board[i][j] - \\'a\\'] == null || cur.next[board[i][j] - \\'a\\'].refCnt == 0) {\\n            return;\\n        }\\n        cur = cur.next[board[i][j] - \\'a\\'];\\n        if (cur != null && cur.word != null) {\\n            res.add(cur.word);\\n            subtract(cur.word);\\n            cur.word = null;\\n        }\\n\\n        char temp = board[i][j];\\n        board[i][j] = \\'@\\';\\n        for (int[] dir: dirs) {\\n            int x = i + dir[0];\\n            int y = j + dir[1];\\n            dfs(board, x, y, cur, res);\\n        }\\n        board[i][j] = temp;\\n    }\\n    \\n    private void buildTree(String word) {\\n        TrieNode cur = root;\\n        for (int i = 0; i < word.length(); i++) {\\n            if (cur.next[word.charAt(i) - \\'a\\'] == null) {\\n                cur.next[word.charAt(i) - \\'a\\'] = new TrieNode();\\n            }\\n            cur.next[word.charAt(i) - \\'a\\'].refCnt += 1;\\n            cur = cur.next[word.charAt(i) - \\'a\\'];\\n        }\\n        cur.word = word;\\n    }\\n    \\n    private void subtract(String word) {\\n        TrieNode cur = root;\\n        for (int i = 0; i < word.length(); i++) {\\n            if (cur == null) {\\n                return;\\n            }\\n            if (cur.next[word.charAt(i) - \\'a\\'] == null) {\\n                return;\\n            }\\n            cur.next[word.charAt(i) - \\'a\\'].refCnt -= 1;\\n            if (cur.next[word.charAt(i) - \\'a\\'].refCnt == 0) {\\n                cur.next[word.charAt(i) - \\'a\\'] = null;\\n            }\\n            cur = cur.next[word.charAt(i) - \\'a\\'];\\n        }\\n        if (cur != null && cur.refCnt == 0) {\\n            cur = null;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public class TrieNode {\\n        TrieNode[] next;\\n        String word;\\n        int refCnt;\\n        public TrieNode() {\\n            this.next = new TrieNode[26];   \\n        }\\n    }\\n    int[][] dirs = new int[][] {{1, 0}, {-1, 0}, {0, -1}, {0, 1}};\\n    \\n    TrieNode root;\\n    \\n    public List<String> findWords(char[][] board, String[] words) {\\n        root = new TrieNode();\\n        for (String word: words) {\\n            buildTree(word);\\n        }\\n        List<String> res = new ArrayList<>();\\n        int n = board.length;\\n        int m = board[0].length;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (root.next[board[i][j] - \\'a\\'] != null && root.next[board[i][j] - \\'a\\'].refCnt > 0) {\\n                    dfs(board, i, j, root, res);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private void dfs(char[][] board, int i, int j, TrieNode cur, List<String> res) {\\n        if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] == \\'@\\'  || cur.next[board[i][j] - \\'a\\'] == null || cur.next[board[i][j] - \\'a\\'].refCnt == 0) {\\n            return;\\n        }\\n        cur = cur.next[board[i][j] - \\'a\\'];\\n        if (cur != null && cur.word != null) {\\n            res.add(cur.word);\\n            subtract(cur.word);\\n            cur.word = null;\\n        }\\n\\n        char temp = board[i][j];\\n        board[i][j] = \\'@\\';\\n        for (int[] dir: dirs) {\\n            int x = i + dir[0];\\n            int y = j + dir[1];\\n            dfs(board, x, y, cur, res);\\n        }\\n        board[i][j] = temp;\\n    }\\n    \\n    private void buildTree(String word) {\\n        TrieNode cur = root;\\n        for (int i = 0; i < word.length(); i++) {\\n            if (cur.next[word.charAt(i) - \\'a\\'] == null) {\\n                cur.next[word.charAt(i) - \\'a\\'] = new TrieNode();\\n            }\\n            cur.next[word.charAt(i) - \\'a\\'].refCnt += 1;\\n            cur = cur.next[word.charAt(i) - \\'a\\'];\\n        }\\n        cur.word = word;\\n    }\\n    \\n    private void subtract(String word) {\\n        TrieNode cur = root;\\n        for (int i = 0; i < word.length(); i++) {\\n            if (cur == null) {\\n                return;\\n            }\\n            if (cur.next[word.charAt(i) - \\'a\\'] == null) {\\n                return;\\n            }\\n            cur.next[word.charAt(i) - \\'a\\'].refCnt -= 1;\\n            if (cur.next[word.charAt(i) - \\'a\\'].refCnt == 0) {\\n                cur.next[word.charAt(i) - \\'a\\'] = null;\\n            }\\n            cur = cur.next[word.charAt(i) - \\'a\\'];\\n        }\\n        if (cur != null && cur.refCnt == 0) {\\n            cur = null;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1510652,
                "title": "c-easy-clean-solution-fastest-dfs-backtracking-trie-detailed",
                "content": "```\\n// NOTE: we have used inserted flag in trie node to make sure\\n// that one word is inserted into ans vec only once o.w below \\n// commented testcase fails in which \"oa\" is inserted twice.\\n// trie node class\\nclass TrieNode {\\npublic:\\n    bool end, inserted;\\n    vector<TrieNode*> letters;\\n    TrieNode (bool end=false, bool inserted=false, int size=26) {\\n        this->end = end;\\n        this->inserted = inserted;\\n        this->letters = vector<TrieNode*>(size, NULL);\\n    }\\n};\\n// soluton class\\nclass Solution {\\n    typedef TrieNode node;\\npublic:\\n    // trie\\n    node* troot = NULL;\\n    node* insertWord(node *root, string &word, int i=0) {\\n        if (!root) return insertWord(new node(), word, i);\\n        if (i == word.size()) root->end = true;\\n        else root->letters[word[i] - \\'a\\'] = insertWord(root->letters[word[i] - \\'a\\'], word, i + 1);\\n        return root;\\n    }\\n    // solution\\n    char fill = \\'#\\';    // assuming # doesn\\'t exist in board\\n    vector<int> dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};\\n    string word;\\n    vector<string> ans;\\n    /*  testcase:\\n    [\"o\",\"a\",\"b\",\"n\"]\\n    [\"o\",\"t\",\"a\",\"e\"]\\n    [\"a\",\"h\",\"k\",\"r\"]\\n    [\"a\",\"f\",\"l\",\"v\"]\\n    [\"oa\",\"oaa\"]\\n    */\\n    // main func.\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        // IDEA is to use trie to optimise T(n) as it can be possible that in words list\\n        // we have prefixes present repeatedly of a word. Eg: [\\'u\\', \\'um\\', \\'ume\\', \\'umes\\', \\'umesh\\']\\n        // in that case, searching words one by one is not good method, instead, search from prefix to word\\n        // which can be done using help of trie. Trie also make sure that only unique words are searched i.e\\n        // if list is: [\\'o\\', \\'o\\', \\'o\\', oo\\'] trie will be: [\\'o\\', \\'oo\\'] only.\\n        // build Trie\\n        for (auto &word: words)\\n            troot = insertWord(troot, word);\\n        // build answer using dfs\\n        for (int row = 0; row < board.size(); row++)\\n            for (int col = 0; col < board[0].size(); col++)\\n                if (troot->letters[board[row][col] - \\'a\\'])\\n                    dfs(board, row, col, troot);\\n        return ans;\\n    }\\n    void dfs(vector<vector<char>> &board, int x, int y, node *root) {\\n        // base case\\n        if (!root or x < 0 or x >= board.size() or y < 0 or y >= board[0].size())\\n            return;\\n        // below cond.: board[x][y] == fill is IMP\\n        if (board[x][y] == fill or !root->letters[board[x][y] - \\'a\\'])\\n            return;\\n        // build word\\n        word.push_back(board[x][y]);\\n        // update root\\n        root = root->letters[board[x][y] - \\'a\\'];\\n        // if word exist in trie then push it to result and mark its inserted as true\\n        // so that this word is not inserted again into the result\\n        if (root->end and not root->inserted) {\\n            root->inserted = true;\\n            ans.push_back(word);\\n        }\\n        // save the original cell and fill it\\n        char orig = board[x][y];\\n        board[x][y] = fill;\\n        for (int d = 0; d < 4; d++)\\n            dfs(board, x + dx[d], y + dy[d], root);\\n        // Backtrack\\n        board[x][y] = orig;\\n        word.pop_back();\\n    }\\n};\\n```\\n\\n**NOTE:**\\n*If you find this post helpful then please **upvote**. It keeps me **motivated** to post such helpful solutions. Thanks!*\\n\\n**PS:**\\nI have also written posts on:\\n1. All C++ (15+) sorting algorithms in a cleaner way [here](https://leetcode.com/problems/sort-an-array/discuss/1401412/C%2B%2B-Clean-Code-Solution-or-Fastest-or-All-(15%2B)-Sorting-Methods-or-Detailed) on leetcode.\\n2. Kadane\\'s Algorithm and Follow up Questions [C++] in a cleaner way [here](https://leetcode.com/problems/maximum-subarray/discuss/1470547/C++-Easy-and-Clean-Solution-or-Fastest:-0ms-or-All-Methods-or-Follow-Ups-or-Detailed-Explanation) on leetcode.\\n\\n*Do check it out/ bookmark (and upvote :)) to revise those concepts for the interview. Thanks!*",
                "solutionTags": [],
                "code": "```\\n// NOTE: we have used inserted flag in trie node to make sure\\n// that one word is inserted into ans vec only once o.w below \\n// commented testcase fails in which \"oa\" is inserted twice.\\n// trie node class\\nclass TrieNode {\\npublic:\\n    bool end, inserted;\\n    vector<TrieNode*> letters;\\n    TrieNode (bool end=false, bool inserted=false, int size=26) {\\n        this->end = end;\\n        this->inserted = inserted;\\n        this->letters = vector<TrieNode*>(size, NULL);\\n    }\\n};\\n// soluton class\\nclass Solution {\\n    typedef TrieNode node;\\npublic:\\n    // trie\\n    node* troot = NULL;\\n    node* insertWord(node *root, string &word, int i=0) {\\n        if (!root) return insertWord(new node(), word, i);\\n        if (i == word.size()) root->end = true;\\n        else root->letters[word[i] - \\'a\\'] = insertWord(root->letters[word[i] - \\'a\\'], word, i + 1);\\n        return root;\\n    }\\n    // solution\\n    char fill = \\'#\\';    // assuming # doesn\\'t exist in board\\n    vector<int> dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};\\n    string word;\\n    vector<string> ans;\\n    /*  testcase:\\n    [\"o\",\"a\",\"b\",\"n\"]\\n    [\"o\",\"t\",\"a\",\"e\"]\\n    [\"a\",\"h\",\"k\",\"r\"]\\n    [\"a\",\"f\",\"l\",\"v\"]\\n    [\"oa\",\"oaa\"]\\n    */\\n    // main func.\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        // IDEA is to use trie to optimise T(n) as it can be possible that in words list\\n        // we have prefixes present repeatedly of a word. Eg: [\\'u\\', \\'um\\', \\'ume\\', \\'umes\\', \\'umesh\\']\\n        // in that case, searching words one by one is not good method, instead, search from prefix to word\\n        // which can be done using help of trie. Trie also make sure that only unique words are searched i.e\\n        // if list is: [\\'o\\', \\'o\\', \\'o\\', oo\\'] trie will be: [\\'o\\', \\'oo\\'] only.\\n        // build Trie\\n        for (auto &word: words)\\n            troot = insertWord(troot, word);\\n        // build answer using dfs\\n        for (int row = 0; row < board.size(); row++)\\n            for (int col = 0; col < board[0].size(); col++)\\n                if (troot->letters[board[row][col] - \\'a\\'])\\n                    dfs(board, row, col, troot);\\n        return ans;\\n    }\\n    void dfs(vector<vector<char>> &board, int x, int y, node *root) {\\n        // base case\\n        if (!root or x < 0 or x >= board.size() or y < 0 or y >= board[0].size())\\n            return;\\n        // below cond.: board[x][y] == fill is IMP\\n        if (board[x][y] == fill or !root->letters[board[x][y] - \\'a\\'])\\n            return;\\n        // build word\\n        word.push_back(board[x][y]);\\n        // update root\\n        root = root->letters[board[x][y] - \\'a\\'];\\n        // if word exist in trie then push it to result and mark its inserted as true\\n        // so that this word is not inserted again into the result\\n        if (root->end and not root->inserted) {\\n            root->inserted = true;\\n            ans.push_back(word);\\n        }\\n        // save the original cell and fill it\\n        char orig = board[x][y];\\n        board[x][y] = fill;\\n        for (int d = 0; d < 4; d++)\\n            dfs(board, x + dx[d], y + dy[d], root);\\n        // Backtrack\\n        board[x][y] = orig;\\n        word.pop_back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1497520,
                "title": "c-backtracking",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n**Approach:**\\nWe can use backtracking approach in an optimized manner, instead of searching for a word in complete matrix, we can store Last Character of every word in a Set. Later while traversing through matrix we can store Index where these words might end and while searching for word in a matrrix we will only need to start searching from these particular Indexes in grid rather than traversing whole grid again n again for each word.\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int dxy[4][2]={{-1,0},{0,1},{1,0},{0,-1}};\\n    bool solve(vector<vector<char>>& grid, int i, int j, string &s, int idx){\\n        int n=grid.size(), m=grid[0].size();\\n        if(idx==-1) return true;\\n        if(i<0 || j<0 || i==n || j==m || grid[i][j]!=s[idx]) return false;\\n        \\n        bool ans=false;\\n        char ch=grid[i][j];\\n        grid[i][j]=\\'*\\';\\n        for(int k=0;k<4;k++){\\n            int x=i+dxy[k][0], y=j+dxy[k][1];\\n            ans |= solve(grid,x,y,s,idx-1);\\n        }\\n        grid[i][j]=ch; // backtrack\\n        \\n        return ans;\\n    }\\n    vector<string> findWords(vector<vector<char>>& grid, vector<string>& words) {\\n        vector<string> ans;\\n        set<char> st;\\n        for(int k=0;k<words.size();k++){\\n            string s=words[k];\\n            char ch=s[s.length()-1]; // TLE happens if we insert first char to identify occurance of a word\\n            st.insert(ch);\\n        }\\n        map<char,vector<pair<int,int>>> mp;\\n        int n=grid.size(), m=grid[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                char ch=grid[i][j];\\n                if(st.find(ch)!=st.end()){\\n                    mp[ch].push_back({i,j});  Index where words ending at this charcter might end\\n                }\\n            }\\n        }\\n        for(int k=0;k<words.size();k++){\\n            string s=words[k];\\n            char ch=s[s.length()-1];\\n            vector<pair<int,int>> v=mp[ch];\\n            for(int i=0;i<v.size();i++){\\n                int x=v[i].first, y=v[i].second;\\n                bool found=solve(grid,x,y,s,s.length()-1);\\n                if(found){\\n                    ans.push_back(s);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dxy[4][2]={{-1,0},{0,1},{1,0},{0,-1}};\\n    bool solve(vector<vector<char>>& grid, int i, int j, string &s, int idx){\\n        int n=grid.size(), m=grid[0].size();\\n        if(idx==-1) return true;\\n        if(i<0 || j<0 || i==n || j==m || grid[i][j]!=s[idx]) return false;\\n        \\n        bool ans=false;\\n        char ch=grid[i][j];\\n        grid[i][j]=\\'*\\';\\n        for(int k=0;k<4;k++){\\n            int x=i+dxy[k][0], y=j+dxy[k][1];\\n            ans |= solve(grid,x,y,s,idx-1);\\n        }\\n        grid[i][j]=ch; // backtrack\\n        \\n        return ans;\\n    }\\n    vector<string> findWords(vector<vector<char>>& grid, vector<string>& words) {\\n        vector<string> ans;\\n        set<char> st;\\n        for(int k=0;k<words.size();k++){\\n            string s=words[k];\\n            char ch=s[s.length()-1]; // TLE happens if we insert first char to identify occurance of a word\\n            st.insert(ch);\\n        }\\n        map<char,vector<pair<int,int>>> mp;\\n        int n=grid.size(), m=grid[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                char ch=grid[i][j];\\n                if(st.find(ch)!=st.end()){\\n                    mp[ch].push_back({i,j});  Index where words ending at this charcter might end\\n                }\\n            }\\n        }\\n        for(int k=0;k<words.size();k++){\\n            string s=words[k];\\n            char ch=s[s.length()-1];\\n            vector<pair<int,int>> v=mp[ch];\\n            for(int i=0;i<v.size();i++){\\n                int x=v[i].first, y=v[i].second;\\n                bool found=solve(grid,x,y,s,s.length()-1);\\n                if(found){\\n                    ans.push_back(s);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1178002,
                "title": "js-pruning-advanced-optimization-100",
                "content": "Most of the solutions*, including the top rated one do not implement pruning. The reason is because it\\'s quite a bit more difficult to reason about. **However**, pruning improves the runtime massively. It is most likely the difference between a hire vs a **strong** hire when interviewing.\\n\\nFor Javascript,\\n1. Without pruning: 900ms\\n2. With pruning: 130ms\\n\\n*The leetcode official solution does implement pruning, but we can prune even **more aggressively**. The official solution also requires keeping track of the parent node, which I find a little confusing. Tbh, I\\'m a little unsure of how my solution compares with the official solution. The official solution travels down unnecessary paths, but leaf node removal is very efficient. On the other hand, my solution\\'s **remove()** method is a little expensive every time we find a word, but could possibly be worth it due to better pruning. Please let me know in comments what you think. \\n\\n**Algorithm**\\n1. The main algorithm is still pretty standard, but we introduce **prefixCount** and **remove()** method to our Trie. **prefixCount** = how many words current prefix is a part of. (Should be familiar if you did other Leetcode Trie problems). Now, whenever we find a word, we remove it from our Trie *immediately* (as opposed to the official solution, which does it \"lazily\"). By doing so, we can prune entire subtrees when prefixCount drops to 0.\\n\\n2. With **prefixCount**, we also now know exactly the max number of words we may find given a certain node. So now, we track how many words we have found while recursing. And we **break early** when we have found the **prefixCount**! This way, we do not unnecessarily recurse deeper when there are no more words to be found.\\n\\n```\\nclass Trie {\\n  constructor() {\\n    this.root = {};\\n  }\\n  \\n  insert(word) {\\n    let node = this.root;\\n    \\n    for(const char of word) {\\n      if(!node[char]) {\\n        node[char] = {};\\n      }\\n      \\n      node = node[char];\\n      node.prefixCount = (node.prefixCount || 0) + 1;\\n    }\\n    \\n    node.word = word;\\n  }\\n  \\n  remove(word) {\\n    let node = this.root;\\n    \\n    for(const char of word) {\\n      node[char].prefixCount--;\\n      \\n      if(node[char].prefixCount === 0) {\\n        delete node[char];\\n        return;\\n      }\\n      node = node[char];\\n    }\\n    \\n    delete node.word;\\n  }\\n}\\n\\nvar findWords = function(board, words) {\\n  const ROWS = board.length;\\n  const COLS = board[0].length;\\n  const foundWords = [];\\n  const trie = new Trie();\\n  \\n  // 1) construct the trie\\n  for(const word of words) {\\n    trie.insert(word);\\n  }\\n  \\n  const directions = [[1,0],[-1,0],[0,1],[0,-1]];\\n  function dfs(r, c, node) {\\n    let numFound1 = 0;\\n    \\n    if(node.word) {\\n      foundWords.push(node.word);\\n      trie.remove(node.word);\\n      numFound1++;\\n    }\\n    \\n    // coordinate (r,c) not within bounds\\n    if(r < 0 || r >= ROWS || c < 0 || c >= COLS) {\\n      return numFound1;\\n    }\\n    \\n    const char = board[r][c];\\n    // char continuation at (r,c) is not in trie\\n    if(!node[char]) {\\n      return numFound1;\\n    }\\n  \\n    // at this point, board[r][c] is a valid character continuation in trie\\n    board[r][c] = \\'#\\';\\n    // record max number of words we can find with current prefix\\n    const PREFIX_COUNT = node[char].prefixCount;\\n    let numFound2 = 0;\\n    for(const [dr, dc] of directions) {\\n      numFound2 += dfs(r + dr, c + dc, node[char]); \\n      \\n      // found all possible words with this prefix. Break early.\\n      if(numFound2 === PREFIX_COUNT) break;\\n    }\\n    \\n    board[r][c] = char;\\n    return numFound1 + numFound2;\\n  }\\n  \\n  // 2) iterate through board recursively square by square\\n  for(let r = 0; r < ROWS; r++) {\\n    for(let c = 0; c < COLS; c++) {\\n      dfs(r, c, trie.root);\\n    }\\n  }\\n  \\n  return foundWords;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Trie {\\n  constructor() {\\n    this.root = {};\\n  }\\n  \\n  insert(word) {\\n    let node = this.root;\\n    \\n    for(const char of word) {\\n      if(!node[char]) {\\n        node[char] = {};\\n      }\\n      \\n      node = node[char];\\n      node.prefixCount = (node.prefixCount || 0) + 1;\\n    }\\n    \\n    node.word = word;\\n  }\\n  \\n  remove(word) {\\n    let node = this.root;\\n    \\n    for(const char of word) {\\n      node[char].prefixCount--;\\n      \\n      if(node[char].prefixCount === 0) {\\n        delete node[char];\\n        return;\\n      }\\n      node = node[char];\\n    }\\n    \\n    delete node.word;\\n  }\\n}\\n\\nvar findWords = function(board, words) {\\n  const ROWS = board.length;\\n  const COLS = board[0].length;\\n  const foundWords = [];\\n  const trie = new Trie();\\n  \\n  // 1) construct the trie\\n  for(const word of words) {\\n    trie.insert(word);\\n  }\\n  \\n  const directions = [[1,0],[-1,0],[0,1],[0,-1]];\\n  function dfs(r, c, node) {\\n    let numFound1 = 0;\\n    \\n    if(node.word) {\\n      foundWords.push(node.word);\\n      trie.remove(node.word);\\n      numFound1++;\\n    }\\n    \\n    // coordinate (r,c) not within bounds\\n    if(r < 0 || r >= ROWS || c < 0 || c >= COLS) {\\n      return numFound1;\\n    }\\n    \\n    const char = board[r][c];\\n    // char continuation at (r,c) is not in trie\\n    if(!node[char]) {\\n      return numFound1;\\n    }\\n  \\n    // at this point, board[r][c] is a valid character continuation in trie\\n    board[r][c] = \\'#\\';\\n    // record max number of words we can find with current prefix\\n    const PREFIX_COUNT = node[char].prefixCount;\\n    let numFound2 = 0;\\n    for(const [dr, dc] of directions) {\\n      numFound2 += dfs(r + dr, c + dc, node[char]); \\n      \\n      // found all possible words with this prefix. Break early.\\n      if(numFound2 === PREFIX_COUNT) break;\\n    }\\n    \\n    board[r][c] = char;\\n    return numFound1 + numFound2;\\n  }\\n  \\n  // 2) iterate through board recursively square by square\\n  for(let r = 0; r < ROWS; r++) {\\n    for(let c = 0; c < COLS; c++) {\\n      dfs(r, c, trie.root);\\n    }\\n  }\\n  \\n  return foundWords;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1062830,
                "title": "swift-trie-with-the-speed-up-trick-explained",
                "content": "The folowing is not my own solution. Copied it from the fastest solution and added comments for the speed up trick. Scroll down to the bottom and check the inline comments.\\n```\\nclass Solution {\\n    func findWords(_ board: [[Character]], _ words: [String]) -> [String] {\\n        var root = TrieNode()\\n        // Building the Trie\\n        for word in words {\\n            var node = root\\n            for char in word {\\n                if let child = node.children[char] {\\n                    node = child\\n                } else {\\n                    let newNode = TrieNode()\\n                    node.children[char] = newNode\\n                    node = newNode\\n                }\\n            }\\n            node.word = word\\n        }\\n        \\n        var res: [String] = []\\n        var copy = board\\n        for i in 0..<board.count {\\n            for j in 0..<board[0].count {\\n                if root.children[board[i][j]] != nil {\\n                    backtrack(i, j, root, &copy, &res)\\n                }\\n            }\\n        }\\n        \\n        return res\\n    }\\n    \\n    func backtrack(_ row: Int, _ col: Int, _ parent: TrieNode, _ board: inout [[Character]], _ res: inout [String]) {\\n        let letter = board[row][col]\\n        if let node = parent.children[letter] {\\n            \\n            if let word = node.word {\\n                res.append(word)\\n                node.word = nil\\n            }\\n            \\n            // Marking the current location as visited\\n            board[row][col] = \"#\"\\n            \\n            let rowOffset = [-1, 0, 1, 0]\\n            let colOffset = [0, 1, 0, -1]\\n            for i in 0..<4 {\\n                let newRow = row + rowOffset[i]\\n                let newCol = col + colOffset[i]\\n                if newRow < 0 || newRow >= board.count || newCol < 0 || newCol >= board[0].count {\\n                    continue\\n                }\\n                if node.children[board[newRow][newCol]] != nil {\\n                    backtrack(newRow, newCol, node, &board, &res)\\n                }\\n            }\\n            \\n            board[row][col] = letter\\n\\t\\t\\t// SPEED UP TRICK:\\n            // What are we doing here?\\n            // While backtracking we removing all the leaf nodes and as we go up we would be also be removing some of\\n            // parent nodes that now became leaf nodes because of the removal of the children. By doing this we are making the \\n            // Trie much smaller \\n            \\n            // Now we know what we are doing here\\n            // Lets understand why we are doing this\\n            // We reach a leaf node only if we found a string matching that leaf node on the board\\n            // All leaf nodes would be the end of a complete word, so after we find the word there is no need to \\n            // keep the elements of the word as we dont need duplicates. Finding the word once is enough. Incase we also wanted\\n            // how many times a particular word occured in the board we should not do this but in this case we dont need that. So we can safely remove the leaf node and we would also be removing its parent while we backtrack till the beginning of the word until we see that the parent has atleast one child.\\n            \\n            // This severely speeds up the algorithm 2400ms -> 4ms!!!!!!\\n            if node.children.isEmpty {\\n                parent.children[letter] = nil\\n            }\\n        }\\n    }\\n}\\n\\nclass TrieNode {\\n    var children: [Character: TrieNode] = [:] \\n    var word: String?\\n    init() {}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func findWords(_ board: [[Character]], _ words: [String]) -> [String] {\\n        var root = TrieNode()\\n        // Building the Trie\\n        for word in words {\\n            var node = root\\n            for char in word {\\n                if let child = node.children[char] {\\n                    node = child\\n                } else {\\n                    let newNode = TrieNode()\\n                    node.children[char] = newNode\\n                    node = newNode\\n                }\\n            }\\n            node.word = word\\n        }\\n        \\n        var res: [String] = []\\n        var copy = board\\n        for i in 0..<board.count {\\n            for j in 0..<board[0].count {\\n                if root.children[board[i][j]] != nil {\\n                    backtrack(i, j, root, &copy, &res)\\n                }\\n            }\\n        }\\n        \\n        return res\\n    }\\n    \\n    func backtrack(_ row: Int, _ col: Int, _ parent: TrieNode, _ board: inout [[Character]], _ res: inout [String]) {\\n        let letter = board[row][col]\\n        if let node = parent.children[letter] {\\n            \\n            if let word = node.word {\\n                res.append(word)\\n                node.word = nil\\n            }\\n            \\n            // Marking the current location as visited\\n            board[row][col] = \"#\"\\n            \\n            let rowOffset = [-1, 0, 1, 0]\\n            let colOffset = [0, 1, 0, -1]\\n            for i in 0..<4 {\\n                let newRow = row + rowOffset[i]\\n                let newCol = col + colOffset[i]\\n                if newRow < 0 || newRow >= board.count || newCol < 0 || newCol >= board[0].count {\\n                    continue\\n                }\\n                if node.children[board[newRow][newCol]] != nil {\\n                    backtrack(newRow, newCol, node, &board, &res)\\n                }\\n            }\\n            \\n            board[row][col] = letter\\n\\t\\t\\t// SPEED UP TRICK:\\n            // What are we doing here?\\n            // While backtracking we removing all the leaf nodes and as we go up we would be also be removing some of\\n            // parent nodes that now became leaf nodes because of the removal of the children. By doing this we are making the \\n            // Trie much smaller \\n            \\n            // Now we know what we are doing here\\n            // Lets understand why we are doing this\\n            // We reach a leaf node only if we found a string matching that leaf node on the board\\n            // All leaf nodes would be the end of a complete word, so after we find the word there is no need to \\n            // keep the elements of the word as we dont need duplicates. Finding the word once is enough. Incase we also wanted\\n            // how many times a particular word occured in the board we should not do this but in this case we dont need that. So we can safely remove the leaf node and we would also be removing its parent while we backtrack till the beginning of the word until we see that the parent has atleast one child.\\n            \\n            // This severely speeds up the algorithm 2400ms -> 4ms!!!!!!\\n            if node.children.isEmpty {\\n                parent.children[letter] = nil\\n            }\\n        }\\n    }\\n}\\n\\nclass TrieNode {\\n    var children: [Character: TrieNode] = [:] \\n    var word: String?\\n    init() {}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1061088,
                "title": "python-ac-backtracking-in-three-steps-terminate-success-backtrack",
                "content": "- Create our backtracking function\\n- First condition is `terminate`\\n\\t- When do we want to terminate our backtracking?\\n- Second condition is `success`\\n\\t- When and how should we update our successful finding of a word?\\n- Third is `backtrack`\\n\\t- Use backtracking to explore and avoid going in circles\\n\\n```python\\nclass Solution:\\n    \\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:    \\n        \\n                     \\n        @functools.lru_cache(None)\\n        def backtrack(i, j, path):\\n            \\n            # 1) terminate\\n            if i not in range(0, len(board)): return\\n            if j not in range(0, len(board[0])): return\\n            if board[i][j] == \"#\": return\\n            \\n            # 2) success\\n            path += board[i][j]\\n            if path in self.words:\\n                self.result.add(path)\\n                \\n            # 3) backtrack\\n            c = board[i][j]\\n            board[i][j] = \"#\"\\n            \\n            for x, y in [(i+1, j), (i-1, j), (i, j-1), (i, j+1)]:\\n                backtrack(x, y, path)\\n            \\n            board[i][j] = c\\n            \\n    \\n    \\n        self.words = set(words)\\n        self.result = set()\\n        \\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                backtrack(i, j, \"\")        \\n        \\n        return self.result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    \\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:    \\n        \\n                     \\n        @functools.lru_cache(None)\\n        def backtrack(i, j, path):\\n            \\n            # 1) terminate\\n            if i not in range(0, len(board)): return\\n            if j not in range(0, len(board[0])): return\\n            if board[i][j] == \"#\": return\\n            \\n            # 2) success\\n            path += board[i][j]\\n            if path in self.words:\\n                self.result.add(path)\\n                \\n            # 3) backtrack\\n            c = board[i][j]\\n            board[i][j] = \"#\"\\n            \\n            for x, y in [(i+1, j), (i-1, j), (i, j-1), (i, j+1)]:\\n                backtrack(x, y, path)\\n            \\n            board[i][j] = c\\n            \\n    \\n    \\n        self.words = set(words)\\n        self.result = set()\\n        \\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                backtrack(i, j, \"\")        \\n        \\n        return self.result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1011904,
                "title": "python-dfs-beats-60",
                "content": "* Similar to [Word Search - 1](https://leetcode.com/problems/word-search/)\\n* Pass each **board[ i ][ j ]** to DFS function and check if it\\'s equal to current slicing of **word**\\n\\t* i.e. word[1:] = \"ello\" and board[i][j] = \"e\" indicates possibilites.\\n\\t* i.e. word[1:] = \"llo\" and board[i][j] = \"l\" indicates possibilites.\\n* Recusively call DFS until word has no slices left, return **True**\\n* Else return **False**\\n```\\n\\tclass Solution:\\n\\t\\tdef findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n\\n\\t\\t\\tdef DFS(board, i, j, word):\\n\\t\\t\\t\\tif len(word) == 0:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tif i < 0 or j < 0 or i >= len(board) or j >= len(board[0]) or word[0] != board[i][j]:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\ttemp = board[i][j]\\n\\t\\t\\t\\tboard[i][j] = \"#\"\\n\\t\\t\\t\\tres = DFS(board, i + 1, j, word[1:]) or DFS(board, i - 1, j, word[1:]) or DFS(board, i, j + 1, word[1:]) or DFS(board, i, j - 1, word[1:])\\n\\t\\t\\t\\tboard[i][j] = temp\\n\\t\\t\\t\\treturn res\\n\\n\\n\\t\\t\\tres = []\\n\\t\\t\\ttemp_board = []\\n\\t\\t\\tfor word in words:\\n\\t\\t\\t\\ttemp_board[:] = board\\n\\t\\t\\t\\tfor i in range(len(temp_board)):\\n\\t\\t\\t\\t\\tfor j in range(len(temp_board[0])):\\n\\t\\t\\t\\t\\t\\tif DFS(temp_board, i, j, word):\\n\\t\\t\\t\\t\\t\\t\\tif word not in res:\\n\\t\\t\\t\\t\\t\\t\\t\\tres.append(word)\\n\\t\\t\\treturn res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\n\\tclass Solution:\\n\\t\\tdef findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n\\n\\t\\t\\tdef DFS(board, i, j, word):\\n\\t\\t\\t\\tif len(word) == 0:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tif i < 0 or j < 0 or i >= len(board) or j >= len(board[0]) or word[0] != board[i][j]:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\ttemp = board[i][j]\\n\\t\\t\\t\\tboard[i][j] = \"#\"\\n\\t\\t\\t\\tres = DFS(board, i + 1, j, word[1:]) or DFS(board, i - 1, j, word[1:]) or DFS(board, i, j + 1, word[1:]) or DFS(board, i, j - 1, word[1:])\\n\\t\\t\\t\\tboard[i][j] = temp\\n\\t\\t\\t\\treturn res\\n\\n\\n\\t\\t\\tres = []\\n\\t\\t\\ttemp_board = []\\n\\t\\t\\tfor word in words:\\n\\t\\t\\t\\ttemp_board[:] = board\\n\\t\\t\\t\\tfor i in range(len(temp_board)):\\n\\t\\t\\t\\t\\tfor j in range(len(temp_board[0])):\\n\\t\\t\\t\\t\\t\\tif DFS(temp_board, i, j, word):\\n\\t\\t\\t\\t\\t\\t\\tif word not in res:\\n\\t\\t\\t\\t\\t\\t\\t\\tres.append(word)\\n\\t\\t\\treturn res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 939445,
                "title": "c-fast-95-just-dfs",
                "content": "\\tpublic class Solution \\n\\t{\\n\\t\\tpublic IList<string> FindWords(char[][] board, string[] words) \\n\\t\\t{\\n\\t\\t\\tvar res = new List<string>();\\n\\n\\t\\t\\tforeach(var word in words)\\n\\t\\t\\t{\\n\\t\\t\\t\\tvar found = false;\\n\\t\\t\\t\\tfor (var i = 0; i < board.Length; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfor (var j = 0; j < board[i].Length; j++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t   if ( board[i][j] == word[0] && Dfs(i,j,word, 0))\\n\\t\\t\\t\\t\\t   {\\n\\t\\t\\t\\t\\t\\t\\tres.Add(word);\\n\\t\\t\\t\\t\\t\\t\\tfound = true;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (found == true) break;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res;\\n\\n\\t\\t\\tbool Dfs(int i, int j, string word, int start)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (start == word.Length) return true;\\n\\n\\t\\t\\t\\t if (i < 0 || i >= board.Length || j < 0 || j >= board[i].Length \\n\\t\\t\\t\\t\\t || board[i][j] != word[start])\\n\\t\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\t\\tboard[i][j] = \\'#\\';\\n\\t\\t\\t\\tvar result = Dfs(i - 1, j, word, start + 1)\\n\\t\\t\\t\\t\\t\\t\\t|| Dfs(i + 1, j, word, start + 1)\\n\\t\\t\\t\\t\\t\\t\\t|| Dfs(i, j + 1, word, start + 1)\\n\\t\\t\\t\\t\\t\\t\\t|| Dfs(i, j - 1, word, start + 1);\\n\\t\\t\\t\\tboard[i][j] = word[start];\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n",
                "solutionTags": [
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "class Solution \\n\\t{\\n\\t\\tpublic IList<string> FindWords(char[][] board, string[] words) \\n\\t\\t{\\n\\t\\t\\tvar res = new List<string>();\\n\\n\\t\\t\\tforeach(var word in words)\\n\\t\\t\\t{\\n\\t\\t\\t\\tvar found = false;\\n\\t\\t\\t\\tfor (var i = 0; i < board.Length; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfor (var j = 0; j < board[i].Length; j++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t   if ( board[i][j] == word[0] && Dfs(i,j,word, 0))\\n\\t\\t\\t\\t\\t   {\\n\\t\\t\\t\\t\\t\\t\\tres.Add(word);\\n\\t\\t\\t\\t\\t\\t\\tfound = true;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 803052,
                "title": "easy-to-understand-python-3-solution-with-backtracking-trie",
                "content": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.isWord = False\\n        self.word = \"\"\\n        \\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        if not board or len(board) == 0 or not words or len(words) == 0:\\n            return []\\n        \\n        root = TrieNode()\\n        \\n        for word in words:\\n            temp = root\\n            for letter in word:\\n                if letter in temp.children:\\n                    temp = temp.children[letter]\\n                else:\\n                    currWord = temp.word\\n                    temp.children[letter] = TrieNode()\\n                    temp = temp.children[letter]\\n                    temp.word = currWord + letter\\n            temp.isWord = True\\n        res = []\\n        \\n        def backtrack(r, c, node):\\n            if node.isWord:\\n                res.append(node.word)\\n                node.isWord = False\\n            if r < 0 or r > len(board)-1 or c < 0 or c > len(board[r])-1:\\n                return\\n            if board[r][c] not in node.children:\\n                return\\n            \\n            tmpLetter = board[r][c]\\n            board[r][c] = \\'$\\'\\n            backtrack(r+1, c, node.children[tmpLetter])\\n            backtrack(r-1, c, node.children[tmpLetter])\\n            backtrack(r, c+1, node.children[tmpLetter])\\n            backtrack(r, c-1, node.children[tmpLetter])\\n            board[r][c] = tmpLetter\\n        \\n        for r in range(len(board)):\\n            for c in range(len(board[r])):\\n                if board[r][c] in root.children:\\n                    backtrack(r, c, root)\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.isWord = False\\n        self.word = \"\"\\n        \\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        if not board or len(board) == 0 or not words or len(words) == 0:\\n            return []\\n        \\n        root = TrieNode()\\n        \\n        for word in words:\\n            temp = root\\n            for letter in word:\\n                if letter in temp.children:\\n                    temp = temp.children[letter]\\n                else:\\n                    currWord = temp.word\\n                    temp.children[letter] = TrieNode()\\n                    temp = temp.children[letter]\\n                    temp.word = currWord + letter\\n            temp.isWord = True\\n        res = []\\n        \\n        def backtrack(r, c, node):\\n            if node.isWord:\\n                res.append(node.word)\\n                node.isWord = False\\n            if r < 0 or r > len(board)-1 or c < 0 or c > len(board[r])-1:\\n                return\\n            if board[r][c] not in node.children:\\n                return\\n            \\n            tmpLetter = board[r][c]\\n            board[r][c] = \\'$\\'\\n            backtrack(r+1, c, node.children[tmpLetter])\\n            backtrack(r-1, c, node.children[tmpLetter])\\n            backtrack(r, c+1, node.children[tmpLetter])\\n            backtrack(r, c-1, node.children[tmpLetter])\\n            board[r][c] = tmpLetter\\n        \\n        for r in range(len(board)):\\n            for c in range(len(board[r])):\\n                if board[r][c] in root.children:\\n                    backtrack(r, c, root)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 713181,
                "title": "simple-to-understand-java-solution-bactracking-trie-explanation",
                "content": "Video Explanation:\\n[Word Search II](https://www.youtube.com/watch?v=ZoMJbbYTWUo)\\n\\nThis question is basically asking you how to **stop before your recursion goes too far**. Therefore, a ***Trie structure*** would be perfect to do the job. After implementing the Trie structure all you need to do is to do a dfs of the grid, if the prefix doesn\\'t match during the recursion, then return. If it does, keep going until it finds the word, or it starts to not match. Other than understanding and implementing this concept, this quesion is relatively easy to do. Below, I implemented a Trie structure and did a search of the grid to find the words.\\n\\n```\\nclass Trie {\\n    Set<String> word;\\n    Set<String> pre;\\n    public Trie() {\\n        word = new HashSet<>();\\n        pre = new HashSet<>();\\n    }\\n\\n    public void insert(String word) {\\n        this.word.add(word);\\n        for(int i = 0; i<=word.length(); i++){\\n            pre.add(word.substring(0, i));\\n        }\\n    }\\n\\n    public boolean search(String word) {\\n        return this.word.contains(word);\\n    }\\n\\n    public boolean startsWith(String prefix) {\\n        return pre.contains(prefix);\\n    }\\n}\\n\\nclass Solution {\\n    Trie prefix = new Trie();\\n    char[][] gBoard;\\n    Set<String> rep = new HashSet<>();\\n    List<String> res = new ArrayList<>();\\n    public List<String> findWords(char[][] board, String[] words) {\\n        gBoard = board;\\n        for(int i = 0; i<words.length; i++){\\n            prefix.insert(words[i]);\\n        }\\n        for(int i = 0; i<board.length; i++){\\n            for(int j = 0; j<board[0].length; j++){\\n                if(prefix.startsWith(board[i][j]+\"\")){\\n                    dfs(i, j, \"\");\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    public void dfs(int i, int j, String store){\\n        if(i < 0 || j < 0 || j>=gBoard[0].length || i >= gBoard.length){\\n            return ;\\n        }\\n        if(gBoard[i][j] == \\'A\\'){\\n            return ;\\n        }\\n        if(!prefix.startsWith(store)){\\n            return ;\\n        }\\n        store += gBoard[i][j]+\"\";\\n        if(prefix.search(store) && !rep.contains(store)){\\n            res.add(store);\\n            rep.add(store);\\n        }\\n        char temp = gBoard[i][j];\\n        \\n        gBoard[i][j] = \\'A\\';\\n        dfs(i, j-1, store);\\n        dfs(i, j+1, store);\\n        dfs(i-1, j, store);\\n        dfs(i+1, j, store);\\n        gBoard[i][j] = temp;\\n        store = store.substring(0, store.length()-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Trie"
                ],
                "code": "```\\nclass Trie {\\n    Set<String> word;\\n    Set<String> pre;\\n    public Trie() {\\n        word = new HashSet<>();\\n        pre = new HashSet<>();\\n    }\\n\\n    public void insert(String word) {\\n        this.word.add(word);\\n        for(int i = 0; i<=word.length(); i++){\\n            pre.add(word.substring(0, i));\\n        }\\n    }\\n\\n    public boolean search(String word) {\\n        return this.word.contains(word);\\n    }\\n\\n    public boolean startsWith(String prefix) {\\n        return pre.contains(prefix);\\n    }\\n}\\n\\nclass Solution {\\n    Trie prefix = new Trie();\\n    char[][] gBoard;\\n    Set<String> rep = new HashSet<>();\\n    List<String> res = new ArrayList<>();\\n    public List<String> findWords(char[][] board, String[] words) {\\n        gBoard = board;\\n        for(int i = 0; i<words.length; i++){\\n            prefix.insert(words[i]);\\n        }\\n        for(int i = 0; i<board.length; i++){\\n            for(int j = 0; j<board[0].length; j++){\\n                if(prefix.startsWith(board[i][j]+\"\")){\\n                    dfs(i, j, \"\");\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    public void dfs(int i, int j, String store){\\n        if(i < 0 || j < 0 || j>=gBoard[0].length || i >= gBoard.length){\\n            return ;\\n        }\\n        if(gBoard[i][j] == \\'A\\'){\\n            return ;\\n        }\\n        if(!prefix.startsWith(store)){\\n            return ;\\n        }\\n        store += gBoard[i][j]+\"\";\\n        if(prefix.search(store) && !rep.contains(store)){\\n            res.add(store);\\n            rep.add(store);\\n        }\\n        char temp = gBoard[i][j];\\n        \\n        gBoard[i][j] = \\'A\\';\\n        dfs(i, j-1, store);\\n        dfs(i, j+1, store);\\n        dfs(i-1, j, store);\\n        dfs(i+1, j, store);\\n        gBoard[i][j] = temp;\\n        store = store.substring(0, store.length()-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 712869,
                "title": "c-using-backtracking-and-trie-data-structure-concise-code-and-well-commented",
                "content": "```\\nstruct TrieNode {\\n    unordered_map<char, TrieNode *> dict;   // hold mapping between character and child TrieNode\\n    bool endOfWord;                         // marks end of word\\n    string word;                            // holds complete word when marked as end\\n    TrieNode(): endOfWord(false) {}\\n};\\n\\nclass Solution {    \\npublic:\\n    // build trie data structure from words to search\\n    TrieNode *buildTrie(vector<string> words) {\\n        TrieNode *root = new TrieNode();\\n        // for each word in dictionary\\n        for(string w: words) {\\n            TrieNode *node = root;\\n            // iteratively populate trie nodes\\n            for(char c: w) {\\n                // if character does not exist in map of current trie node\\n                if(node->dict.empty() || node->dict.find(c) == node->dict.end()) {\\n                    node->dict.insert({c, new TrieNode});   // add character with new child trie node\\n                }\\n                node = node->dict[c];   // move trie node pointer to child node\\n            }\\n            node->endOfWord = true;     // mark node as end of word\\n            node->word = w;             // store complete word in that node\\n        }\\n        return root;\\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        TrieNode *root = buildTrie(words);      // returns root of trie data structure after building\\n        \\n        int m = board.size(), n = board[0].size();\\n        set<string> s;      // store found words in set to avoid duplicates\\n        // for each cell of the board recursively check if character is present in trie nodes\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                dfs(board, root, i, j, s);\\n            }\\n        }\\n            \\n        // throw every found word in vector and return\\n        vector<string> res;\\n        for(string word: s)     res.push_back(word);\\n        return res;\\n    }\\n    \\n    void dfs(vector<vector<char>> &board, TrieNode *node, int i, int j, set<string> &s) {\\n        // handles out of bounds or if board character is not present in trie node\\n        if(i < 0 || i >= board.size() || j < 0 || j >= board[0].size() || node->dict.find(board[i][j]) == node->dict.end())     return;\\n        \\n        // if current board character is found in trie node move node control to child of that character\\n        node = node->dict[board[i][j]];      \\n        if(node->endOfWord)     s.insert(node->word);   // check if node is marked as end of word and push word stored in that node to set of found words\\n        \\n        char c = board[i][j];   // store cell temporarily\\n        board[i][j] = \\' \\';      // mark cell as visited by invalidating\\n        \\n        // recursively check if characters to the up, right, down or left of current board character can be included in words to search\\n        dfs(board, node, i-1, j, s);\\n        dfs(board, node, i, j+1, s);\\n        dfs(board, node, i+1, j, s);\\n        dfs(board, node, i, j-1, s);\\n        \\n        board[i][j] = c;        // undo/backtrack changes to cell\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct TrieNode {\\n    unordered_map<char, TrieNode *> dict;   // hold mapping between character and child TrieNode\\n    bool endOfWord;                         // marks end of word\\n    string word;                            // holds complete word when marked as end\\n    TrieNode(): endOfWord(false) {}\\n};\\n\\nclass Solution {    \\npublic:\\n    // build trie data structure from words to search\\n    TrieNode *buildTrie(vector<string> words) {\\n        TrieNode *root = new TrieNode();\\n        // for each word in dictionary\\n        for(string w: words) {\\n            TrieNode *node = root;\\n            // iteratively populate trie nodes\\n            for(char c: w) {\\n                // if character does not exist in map of current trie node\\n                if(node->dict.empty() || node->dict.find(c) == node->dict.end()) {\\n                    node->dict.insert({c, new TrieNode});   // add character with new child trie node\\n                }\\n                node = node->dict[c];   // move trie node pointer to child node\\n            }\\n            node->endOfWord = true;     // mark node as end of word\\n            node->word = w;             // store complete word in that node\\n        }\\n        return root;\\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        TrieNode *root = buildTrie(words);      // returns root of trie data structure after building\\n        \\n        int m = board.size(), n = board[0].size();\\n        set<string> s;      // store found words in set to avoid duplicates\\n        // for each cell of the board recursively check if character is present in trie nodes\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                dfs(board, root, i, j, s);\\n            }\\n        }\\n            \\n        // throw every found word in vector and return\\n        vector<string> res;\\n        for(string word: s)     res.push_back(word);\\n        return res;\\n    }\\n    \\n    void dfs(vector<vector<char>> &board, TrieNode *node, int i, int j, set<string> &s) {\\n        // handles out of bounds or if board character is not present in trie node\\n        if(i < 0 || i >= board.size() || j < 0 || j >= board[0].size() || node->dict.find(board[i][j]) == node->dict.end())     return;\\n        \\n        // if current board character is found in trie node move node control to child of that character\\n        node = node->dict[board[i][j]];      \\n        if(node->endOfWord)     s.insert(node->word);   // check if node is marked as end of word and push word stored in that node to set of found words\\n        \\n        char c = board[i][j];   // store cell temporarily\\n        board[i][j] = \\' \\';      // mark cell as visited by invalidating\\n        \\n        // recursively check if characters to the up, right, down or left of current board character can be included in words to search\\n        dfs(board, node, i-1, j, s);\\n        dfs(board, node, i, j+1, s);\\n        dfs(board, node, i+1, j, s);\\n        dfs(board, node, i, j-1, s);\\n        \\n        board[i][j] = c;        // undo/backtrack changes to cell\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 654563,
                "title": "pure-evil-test-case",
                "content": "It should probably be illegal to have a test case like :\\n```\\n[[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"a\",\"a\",\"a\"]]\\n[\"aaaaaaaaaaaa\",\"aaaaaaaaaaaaa\",\"aaaaaaaaaaab\"]\\n```\\n\\nSome of us have families you know. \\n\\nBut in all seriousness, is it a big red flag if I could not think about this test case on my own and had to rely on WA solution to find it?",
                "solutionTags": [],
                "code": "```\\n[[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"a\",\"a\",\"a\"]]\\n[\"aaaaaaaaaaaa\",\"aaaaaaaaaaaaa\",\"aaaaaaaaaaab\"]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 428405,
                "title": "intuitive-python-solution-trie-backtrack-97",
                "content": "```python\\nclass Trie:\\n    WORD = \\'\\' # use empty string to mark end of a word\\n    \\n    def __init__(self):\\n        self.root = {}\\n\\n    def insert(self, word: str) -> None:\\n        node = self.root\\n        for char in word:\\n            if char not in node:\\n                node[char] = {}\\n            node = node[char]\\n        node[self.WORD] = word # save the word itself to node[\\'\\']\\n        \\n        \\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        results = set()\\n        m = len(board)    \\n        n = len(board[0])\\n        \\n        trie = Trie()\\n        for word in words:\\n            trie.insert(word)\\n            \\n        def backtrack(i: int, j: int, node: dict) -> None:\\n            char = board[i][j]\\n            if char not in node:\\n                return\\n            \\n            node = node[char]\\n            if trie.WORD in node:\\n                results.add(node[trie.WORD]) # node[\\'\\'] contains the word\\n\\n            board[i][j] = None\\n            if i > 0:\\n                backtrack(i-1, j, node)\\n            if i < m - 1:\\n                backtrack(i+1, j, node)\\n            if j > 0:\\n                backtrack(i, j-1, node)\\n            if j < n - 1:\\n                backtrack(i, j+1, node)\\n            board[i][j] = char\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                backtrack(i, j, trie.root)\\n                \\n        return results\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Trie:\\n    WORD = \\'\\' # use empty string to mark end of a word\\n    \\n    def __init__(self):\\n        self.root = {}\\n\\n    def insert(self, word: str) -> None:\\n        node = self.root\\n        for char in word:\\n            if char not in node:\\n                node[char] = {}\\n            node = node[char]\\n        node[self.WORD] = word # save the word itself to node[\\'\\']\\n        \\n        \\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        results = set()\\n        m = len(board)    \\n        n = len(board[0])\\n        \\n        trie = Trie()\\n        for word in words:\\n            trie.insert(word)\\n            \\n        def backtrack(i: int, j: int, node: dict) -> None:\\n            char = board[i][j]\\n            if char not in node:\\n                return\\n            \\n            node = node[char]\\n            if trie.WORD in node:\\n                results.add(node[trie.WORD]) # node[\\'\\'] contains the word\\n\\n            board[i][j] = None\\n            if i > 0:\\n                backtrack(i-1, j, node)\\n            if i < m - 1:\\n                backtrack(i+1, j, node)\\n            if j > 0:\\n                backtrack(i, j-1, node)\\n            if j < n - 1:\\n                backtrack(i, j+1, node)\\n            board[i][j] = char\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                backtrack(i, j, trie.root)\\n                \\n        return results\\n```",
                "codeTag": "Java"
            },
            {
                "id": 303250,
                "title": "c-faster-than-96-dfs-trie-with-comments",
                "content": "* Build a trie from the dictionary\\n* Starting from each cell, recursively visit all neighbors, check the next symbol in the trie\\n\\n```\\n    struct TrieNode{\\n        bool word = false;\\n        vector<TrieNode*> nodes = vector<TrieNode*>(26);\\n    };    \\n    \\n\\t// visit every adjansent cell, checking that the next symbol exists in trie\\n    void visit(vector<vector<char>>& board, \\n               TrieNode* node, \\n               int i, int j, \\n               string& word, \\n               vector<bool>& visited,\\n               unordered_set<string>& result)\\n    {\\n        int h = board.size();\\n        int w = board[0].size();\\n        if (i<0||j<0||i>=h||j>=w||visited[i*w+j]||!node->nodes[ board[i][j]-\\'a\\' ])\\n            return;\\n        \\n        visited[i*w+j] = true;\\n        word += board[i][j];\\n        \\n        node = node->nodes[board[i][j]-\\'a\\'];\\n        \\n        if (node->word)\\n            result.insert(word);\\n        \\n        visit(board, node, i+1, j, word, visited, result);\\n        visit(board, node, i-1, j, word, visited, result);\\n        visit(board, node, i, j+1, word, visited, result);\\n        visit(board, node, i, j-1, word, visited, result);\\n        \\n        word.pop_back();\\n        visited[i*w+j] = false;\\n    }\\n\\n\\t// buid trie data structure recursively \\n    void trie_insert_word(TrieNode* node, const char* word){\\n        if (!*word)\\n            node->word = true;\\n        else{\\n            int pos = *word-\\'a\\';\\n            if (!node->nodes[pos])\\n                node->nodes[pos] = new TrieNode;\\n\\n            trie_insert_word(node->nodes[pos], word+1);\\n        }\\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        if (board.empty()||board[0].empty())\\n            return vector<string>();        \\n        \\n        TrieNode root;\\n        for (string& s: words)\\n            trie_insert_word(&root, s.c_str());\\n        \\n\\t\\t// visit every board cell and run dfs\\n        unordered_set<string> result;\\n        string word;\\n        vector<bool> visited(board.size()*board[0].size());\\n        for (int i=0;i<board.size();++i)\\n            for (int j=0;j<board[0].size();++j)\\n                visit(board, &root, i, j, word, visited, result);\\n        \\n        return vector<string>(result.begin(), result.end());\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    struct TrieNode{\\n        bool word = false;\\n        vector<TrieNode*> nodes = vector<TrieNode*>(26);\\n    };    \\n    \\n\\t// visit every adjansent cell, checking that the next symbol exists in trie\\n    void visit(vector<vector<char>>& board, \\n               TrieNode* node, \\n               int i, int j, \\n               string& word, \\n               vector<bool>& visited,\\n               unordered_set<string>& result)\\n    {\\n        int h = board.size();\\n        int w = board[0].size();\\n        if (i<0||j<0||i>=h||j>=w||visited[i*w+j]||!node->nodes[ board[i][j]-\\'a\\' ])\\n            return;\\n        \\n        visited[i*w+j] = true;\\n        word += board[i][j];\\n        \\n        node = node->nodes[board[i][j]-\\'a\\'];\\n        \\n        if (node->word)\\n            result.insert(word);\\n        \\n        visit(board, node, i+1, j, word, visited, result);\\n        visit(board, node, i-1, j, word, visited, result);\\n        visit(board, node, i, j+1, word, visited, result);\\n        visit(board, node, i, j-1, word, visited, result);\\n        \\n        word.pop_back();\\n        visited[i*w+j] = false;\\n    }\\n\\n\\t// buid trie data structure recursively \\n    void trie_insert_word(TrieNode* node, const char* word){\\n        if (!*word)\\n            node->word = true;\\n        else{\\n            int pos = *word-\\'a\\';\\n            if (!node->nodes[pos])\\n                node->nodes[pos] = new TrieNode;\\n\\n            trie_insert_word(node->nodes[pos], word+1);\\n        }\\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        if (board.empty()||board[0].empty())\\n            return vector<string>();        \\n        \\n        TrieNode root;\\n        for (string& s: words)\\n            trie_insert_word(&root, s.c_str());\\n        \\n\\t\\t// visit every board cell and run dfs\\n        unordered_set<string> result;\\n        string word;\\n        vector<bool> visited(board.size()*board[0].size());\\n        for (int i=0;i<board.size();++i)\\n            for (int j=0;j<board[0].size();++j)\\n                visit(board, &root, i, j, word, visited, result);\\n        \\n        return vector<string>(result.begin(), result.end());\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 295076,
                "title": "c-trie-dfs",
                "content": "```\\npublic class Solution {\\n    public IList<string> FindWords(char[][] board, string[] words) {\\n        var result = new HashSet<string>();\\n        var n = board.Length;\\n        if (n == 0) return new List<string>();\\n        var m = board[0].Length;\\n\\n        var trie = new Trie();\\n        foreach (var word in words) {\\n            trie.Insert(word);\\n        }\\n\\n        var isVisited = new bool[n, m];\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                var index = board[i][j] - \\'a\\';\\n                if (trie.root.nodes[index] != null) {\\n                    DFS(i, j, trie.root, board, isVisited, result);\\n                }\\n            }\\n        }\\n\\n        return result.ToList();\\n    }\\n\\n    private void DFS(int x, int y, TrieNode node, char[][] board, bool[,] isVisited, HashSet<string> result) {\\n        var n = board.Length;\\n        var m = board[0].Length;\\n\\n        if (node.isWord) {\\n            result.Add(node.word);\\n        }\\n\\n        if (x >= n || x < 0 || y >= m || y < 0) {\\n            return;\\n        }\\n        if (isVisited[x, y]) return;\\n        var index = board[x][y] - \\'a\\';\\n        if (node.nodes[index] == null) return;\\n\\n        var next = node.nodes[index];\\n\\n        isVisited[x, y] = true;\\n\\n        var directions = new (int, int)[] { (0, 1), (0, -1), (1, 0), (-1, 0) };\\n        foreach (var direction in directions) {\\n            var nextX = x + direction.Item1;\\n            var nextY = y + direction.Item2;\\n\\n            DFS(nextX, nextY, next, board, isVisited, result);\\n        }\\n\\n        isVisited[x, y] = false;\\n    }\\n}\\n\\nclass Trie {\\n\\n    public TrieNode root;\\n    public Trie() {\\n        root = new TrieNode();\\n    }\\n    public void Insert(string word) {\\n        var n = word.Length;\\n        TrieNode curNode = root;\\n        for (int i = 0; i < n; i++) {\\n            var index = word[i] - \\'a\\';\\n            if (curNode.nodes[index] == null) {\\n                curNode.nodes[index] = new TrieNode();\\n            }\\n            curNode = curNode.nodes[index];\\n\\n            if (i == n - 1) {\\n                curNode.isWord = true;\\n                curNode.word = word;\\n            }\\n        }\\n    }\\n}\\n\\nclass TrieNode {\\n    public TrieNode[] nodes;\\n    public bool isWord;\\n    public string word;\\n\\n    public TrieNode() {\\n        nodes = new TrieNode[26];\\n        isWord = false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<string> FindWords(char[][] board, string[] words) {\\n        var result = new HashSet<string>();\\n        var n = board.Length;\\n        if (n == 0) return new List<string>();\\n        var m = board[0].Length;\\n\\n        var trie = new Trie();\\n        foreach (var word in words) {\\n            trie.Insert(word);\\n        }\\n\\n        var isVisited = new bool[n, m];\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                var index = board[i][j] - \\'a\\';\\n                if (trie.root.nodes[index] != null) {\\n                    DFS(i, j, trie.root, board, isVisited, result);\\n                }\\n            }\\n        }\\n\\n        return result.ToList();\\n    }\\n\\n    private void DFS(int x, int y, TrieNode node, char[][] board, bool[,] isVisited, HashSet<string> result) {\\n        var n = board.Length;\\n        var m = board[0].Length;\\n\\n        if (node.isWord) {\\n            result.Add(node.word);\\n        }\\n\\n        if (x >= n || x < 0 || y >= m || y < 0) {\\n            return;\\n        }\\n        if (isVisited[x, y]) return;\\n        var index = board[x][y] - \\'a\\';\\n        if (node.nodes[index] == null) return;\\n\\n        var next = node.nodes[index];\\n\\n        isVisited[x, y] = true;\\n\\n        var directions = new (int, int)[] { (0, 1), (0, -1), (1, 0), (-1, 0) };\\n        foreach (var direction in directions) {\\n            var nextX = x + direction.Item1;\\n            var nextY = y + direction.Item2;\\n\\n            DFS(nextX, nextY, next, board, isVisited, result);\\n        }\\n\\n        isVisited[x, y] = false;\\n    }\\n}\\n\\nclass Trie {\\n\\n    public TrieNode root;\\n    public Trie() {\\n        root = new TrieNode();\\n    }\\n    public void Insert(string word) {\\n        var n = word.Length;\\n        TrieNode curNode = root;\\n        for (int i = 0; i < n; i++) {\\n            var index = word[i] - \\'a\\';\\n            if (curNode.nodes[index] == null) {\\n                curNode.nodes[index] = new TrieNode();\\n            }\\n            curNode = curNode.nodes[index];\\n\\n            if (i == n - 1) {\\n                curNode.isWord = true;\\n                curNode.word = word;\\n            }\\n        }\\n    }\\n}\\n\\nclass TrieNode {\\n    public TrieNode[] nodes;\\n    public bool isWord;\\n    public string word;\\n\\n    public TrieNode() {\\n        nodes = new TrieNode[26];\\n        isWord = false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 248096,
                "title": "javascript-using-dfs-and-trie-beats-100",
                "content": "\\n\\n```javascript\\nvar findWords = function(board, words) {\\n    const ans = [];\\n    \\n    if (!board || !words || board.length < 1) return [];\\n    \\n    const root = buildTrie(words);\\n    \\n    for (let i = 0; i < board.length; i++) {\\n        for (let j = 0; j < board[0].length; j++) {\\n            dfs(board, i, j, root, ans);\\n        }\\n    }\\n    \\n    return ans;\\n};\\n\\nfunction dfs(board, i, j, trie, ans) {\\n    const w = board[i][j];\\n    \\n    if (!trie.children.has(w)) return;\\n    \\n    trie = trie.children.get(w);\\n    \\n    if (trie.word) {\\n        ans.push(trie.word);\\n        trie.word = null;\\n    }\\n    \\n    board[i][j] = \\'#\\';\\n    if (i > 0) dfs(board, i - 1, j, trie, ans); \\n    if (j > 0) dfs(board, i, j - 1, trie, ans);\\n    if (i < board.length - 1) dfs(board, i + 1, j, trie, ans); \\n    if (j < board[0].length - 1) dfs(board, i, j + 1, trie, ans); \\n    board[i][j] = w;\\n}\\n\\nfunction buildTrie(words) {\\n    const root = new TrieNode();\\n    \\n    words.forEach(w => {\\n        let node = root;\\n        \\n        for (let i = 0; i < w.length; i++) {\\n            let c = w[i];\\n            \\n            if (!node.children.has(c)) node.children.set(c, new TrieNode());\\n\\n            node = node.children.get(c);\\n        }\\n        \\n         node.word = w;\\n    })\\n    \\n    return root;\\n}\\n\\nclass TrieNode {\\n    constructor() {\\n        this.word = null;\\n        this.children = new Map();\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```javascript\\nvar findWords = function(board, words) {\\n    const ans = [];\\n    \\n    if (!board || !words || board.length < 1) return [];\\n    \\n    const root = buildTrie(words);\\n    \\n    for (let i = 0; i < board.length; i++) {\\n        for (let j = 0; j < board[0].length; j++) {\\n            dfs(board, i, j, root, ans);\\n        }\\n    }\\n    \\n    return ans;\\n};\\n\\nfunction dfs(board, i, j, trie, ans) {\\n    const w = board[i][j];\\n    \\n    if (!trie.children.has(w)) return;\\n    \\n    trie = trie.children.get(w);\\n    \\n    if (trie.word) {\\n        ans.push(trie.word);\\n        trie.word = null;\\n    }\\n    \\n    board[i][j] = \\'#\\';\\n    if (i > 0) dfs(board, i - 1, j, trie, ans); \\n    if (j > 0) dfs(board, i, j - 1, trie, ans);\\n    if (i < board.length - 1) dfs(board, i + 1, j, trie, ans); \\n    if (j < board[0].length - 1) dfs(board, i, j + 1, trie, ans); \\n    board[i][j] = w;\\n}\\n\\nfunction buildTrie(words) {\\n    const root = new TrieNode();\\n    \\n    words.forEach(w => {\\n        let node = root;\\n        \\n        for (let i = 0; i < w.length; i++) {\\n            let c = w[i];\\n            \\n            if (!node.children.has(c)) node.children.set(c, new TrieNode());\\n\\n            node = node.children.get(c);\\n        }\\n        \\n         node.word = w;\\n    })\\n    \\n    return root;\\n}\\n\\nclass TrieNode {\\n    constructor() {\\n        this.word = null;\\n        this.children = new Map();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 193926,
                "title": "concise-python-with-trie-and-dfs",
                "content": "```\\nclass TrieNode(object):\\n    def __init__(self, is_leaf = False):\\n        self.children = dict()\\n        self.is_leaf = is_leaf\\n        \\n    def add_s(self, s):\\n        curr = self\\n        for c in s:\\n            if c not in curr.children:\\n                curr.children[c] = TrieNode()\\n            curr = curr.children[c]\\n        curr.is_leaf = True\\n    \\nclass Solution(object):\\n    def findWords(self, board, words):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :type words: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        \\n        trie_root = TrieNode()\\n        for w in words:\\n            trie_root.add_s(w)\\n            \\n        result = set()\\n\\n        height = len(board)\\n        width = len(board[0])\\n        \\n        def go(i, j, node, word):\\n            \\n            if node.is_leaf:\\n                result.add(word)\\n                \\n            if i < 0 or i >= height or j < 0 or j >= width:\\n                return \\n            \\n            if board[i][j] in node.children:\\n                c = board[i][j]\\n                board[i][j] = \\'-\\'\\n                go(i + 1, j, node.children[c], word + c)\\n                go(i - 1, j, node.children[c], word + c)\\n                go(i, j + 1, node.children[c], word + c)\\n                go(i, j - 1, node.children[c], word + c)\\n                board[i][j] = c\\n            \\n            if word == \\'\\':\\n                go(i, j + 1, node, word) if j + 1 < width else go(i + 1, 0, node, word)\\n            \\n        go(0, 0, trie_root, \\'\\')    \\n        \\n        return list(result)\\n    \\n            \\n            \\n            \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode(object):\\n    def __init__(self, is_leaf = False):\\n        self.children = dict()\\n        self.is_leaf = is_leaf\\n        \\n    def add_s(self, s):\\n        curr = self\\n        for c in s:\\n            if c not in curr.children:\\n                curr.children[c] = TrieNode()\\n            curr = curr.children[c]\\n        curr.is_leaf = True\\n    \\nclass Solution(object):\\n    def findWords(self, board, words):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :type words: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        \\n        trie_root = TrieNode()\\n        for w in words:\\n            trie_root.add_s(w)\\n            \\n        result = set()\\n\\n        height = len(board)\\n        width = len(board[0])\\n        \\n        def go(i, j, node, word):\\n            \\n            if node.is_leaf:\\n                result.add(word)\\n                \\n            if i < 0 or i >= height or j < 0 or j >= width:\\n                return \\n            \\n            if board[i][j] in node.children:\\n                c = board[i][j]\\n                board[i][j] = \\'-\\'\\n                go(i + 1, j, node.children[c], word + c)\\n                go(i - 1, j, node.children[c], word + c)\\n                go(i, j + 1, node.children[c], word + c)\\n                go(i, j - 1, node.children[c], word + c)\\n                board[i][j] = c\\n            \\n            if word == \\'\\':\\n                go(i, j + 1, node, word) if j + 1 < width else go(i + 1, 0, node, word)\\n            \\n        go(0, 0, trie_root, \\'\\')    \\n        \\n        return list(result)\\n    \\n            \\n            \\n            \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 59808,
                "title": "python-dfs-362ms",
                "content": "Used the quick and dirty trie building from here: Re: Python code use trie and dfs 380ms\\n\\nMain difference is I exit out of the current recursive call by checking if the following \"Trie Node\" is empty.\\n\\nImproved performance slightly.\\n\\n```\\nclass Solution(object):\\n    def checkList(self, board, row, col, word, trie, rList):\\n        if row<0 or row>=len(board) or col<0 or col>=len(board[0]) or board[row][col] == '.' or board[row][col] not in trie: return\\n        c = board[row][col]\\n        _word= word + c\\n        if '#' in trie[c]: \\n            rList.add(_word)\\n            if len(trie[c]) == 1: return # if next node is empty, return as no there is no need to search further\\n        board[row][col] = '.'\\n        self.checkList(board, row-1, col, _word, trie[c], rList) #up\\n        self.checkList(board, row+1, col, _word, trie[c], rList) #down\\n        self.checkList(board, row, col-1, _word, trie[c], rList) #left\\n        self.checkList(board, row, col+1, _word, trie[c], rList) #right\\n        board[row][col] = c\\n    \\n    def findWords(self, board, words):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :type words: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        if not board or not words: return []\\n        # building Trie\\n        trie, rList = {}, set()\\n        for word in words:\\n            t = trie\\n            for c in word:\\n                if c not in t: t[c] = {}\\n                t = t[c]\\n            t['#'] = None\\n        for row in range(len(board)):\\n            for col in range(len(board[0])):\\n                if board[row][col] not in trie: continue\\n                self.checkList(board, row, col, \"\", trie, rList)\\n        return list(rList)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def checkList(self, board, row, col, word, trie, rList):\\n        if row<0 or row>=len(board) or col<0 or col>=len(board[0]) or board[row][col] == '.' or board[row][col] not in trie: return\\n        c = board[row][col]\\n        _word= word + c\\n        if '#' in trie[c]: \\n            rList.add(_word)\\n            if len(trie[c]) == 1: return # if next node is empty, return as no there is no need to search further\\n        board[row][col] = '.'\\n        self.checkList(board, row-1, col, _word, trie[c], rList) #up\\n        self.checkList(board, row+1, col, _word, trie[c], rList) #down\\n        self.checkList(board, row, col-1, _word, trie[c], rList) #left\\n        self.checkList(board, row, col+1, _word, trie[c], rList) #right\\n        board[row][col] = c\\n    \\n    def findWords(self, board, words):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :type words: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        if not board or not words: return []\\n        # building Trie\\n        trie, rList = {}, set()\\n        for word in words:\\n            t = trie\\n            for c in word:\\n                if c not in t: t[c] = {}\\n                t = t[c]\\n            t['#'] = None\\n        for row in range(len(board)):\\n            for col in range(len(board[0])):\\n                if board[row][col] not in trie: continue\\n                self.checkList(board, row, col, \"\", trie, rList)\\n        return list(rList)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475805,
                "title": "java-solution-for-word-search-ii-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires us to find all the words in the given words list that can be formed using the letters present on the given board matrix. We can use the Trie data structure to efficiently search for words in the given board\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach taken in the solution is to first build a Trie using the words list, and then perform a depth-first search (DFS) on the board matrix to find all the valid words.\\n\\nThe Trie data structure is built using the insert function, which inserts a word into the Trie by creating a new node for each character in the word. The search function checks if a given word exists in the Trie by traversing the Trie and checking if the end node of the word contains the word itself. The startsWith function checks if a given prefix exists in the Trie by traversing the Trie until the end of the prefix.\\n\\nThe findWords function initializes an empty set result, builds the Trie using the words list, and initializes a boolean matrix visited to keep track of the visited cells in the board matrix. It then performs a DFS on each cell in the board matrix, starting with an empty string str, and checks if the current prefix str exists in the Trie. If it does, it checks if str is a valid word by checking if the end node of str contains the word itself. If it is a valid word, it adds str to the result set. Finally, it marks the current cell as visited, and recursively performs DFS on its neighboring cells, adding the current cell\\'s character to the str prefix.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(M(4\\u22C53^(L\\u22121))), where M is the number of cells in the board, L is the maximum length of a word, and 4\\u22C53^(L\\u22121) is the maximum number of child nodes in the Trie\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n O(N), where N is the total number of characters in the words list, which is used to build the Trie.\\n\\n# Code\\n```\\nclass Solution {\\n    Set<String> result = new HashSet<String>();\\n    public List<String> findWords(char[][] board, String[] words) {\\n        //HashSet<String> result = new HashSet<String>();\\n        Trie trie = new Trie();\\n        for(String word: words)\\n        {\\n            trie.insert(word);\\n        }\\n        int m=board.length;\\n        int n=board[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                dfs(board, visited, \"\", i, j, trie);\\n            }\\n        }\\n        return new ArrayList<String>(result);\\n    }\\n    public void dfs(char[][] board, boolean[][] visited, String str, int i, int j, Trie trie)\\n    {\\n        int m=board.length;\\n        int n=board[0].length;\\n        if(i<0 || j<0||i>=m||j>=n)\\n        {\\n            return;\\n        }\\n        if(visited[i][j])\\n            return;\\n        str = str + board[i][j];\\n        if(!trie.startsWith(str))\\n            return;\\n        if(trie.search(str))\\n        {\\n            result.add(str);\\n        }\\n        visited[i][j]=true;\\n        dfs(board, visited, str, i-1, j, trie);\\n        dfs(board, visited, str, i+1, j, trie);\\n        dfs(board, visited, str, i, j-1, trie);\\n        dfs(board, visited, str, i, j+1, trie);\\n        visited[i][j]=false;\\n    }\\n}\\nclass TrieNode\\n{\\n    public TrieNode[] children = new TrieNode[26];\\n    public String item = \"\";\\n}\\n//Trie\\nclass Trie\\n{\\n    public TrieNode root = new TrieNode();\\n    public void insert(String word)\\n    {\\n        TrieNode node = root;\\n        for(char c: word.toCharArray())\\n        {\\n            if(node.children[c-\\'a\\']==null)\\n            {\\n                node.children[c-\\'a\\']= new TrieNode();\\n            }\\n            node = node.children[c-\\'a\\'];\\n        }\\n        node.item = word;\\n    }\\n    public boolean search(String word)\\n    {\\n        TrieNode node = root;\\n        for(char c: word.toCharArray())\\n        {\\n            if(node.children[c-\\'a\\']==null)\\n                return false;\\n            node = node.children[c-\\'a\\'];\\n        }\\n        if(node.item.equals(word))\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    public boolean startsWith(String prefix)\\n    {\\n        TrieNode node = root;\\n        for(char c: prefix.toCharArray())\\n        {\\n            if(node.children[c-\\'a\\']==null)\\n            return false;\\n            node = node.children[c-\\'a\\'];\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Set<String> result = new HashSet<String>();\\n    public List<String> findWords(char[][] board, String[] words) {\\n        //HashSet<String> result = new HashSet<String>();\\n        Trie trie = new Trie();\\n        for(String word: words)\\n        {\\n            trie.insert(word);\\n        }\\n        int m=board.length;\\n        int n=board[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                dfs(board, visited, \"\", i, j, trie);\\n            }\\n        }\\n        return new ArrayList<String>(result);\\n    }\\n    public void dfs(char[][] board, boolean[][] visited, String str, int i, int j, Trie trie)\\n    {\\n        int m=board.length;\\n        int n=board[0].length;\\n        if(i<0 || j<0||i>=m||j>=n)\\n        {\\n            return;\\n        }\\n        if(visited[i][j])\\n            return;\\n        str = str + board[i][j];\\n        if(!trie.startsWith(str))\\n            return;\\n        if(trie.search(str))\\n        {\\n            result.add(str);\\n        }\\n        visited[i][j]=true;\\n        dfs(board, visited, str, i-1, j, trie);\\n        dfs(board, visited, str, i+1, j, trie);\\n        dfs(board, visited, str, i, j-1, trie);\\n        dfs(board, visited, str, i, j+1, trie);\\n        visited[i][j]=false;\\n    }\\n}\\nclass TrieNode\\n{\\n    public TrieNode[] children = new TrieNode[26];\\n    public String item = \"\";\\n}\\n//Trie\\nclass Trie\\n{\\n    public TrieNode root = new TrieNode();\\n    public void insert(String word)\\n    {\\n        TrieNode node = root;\\n        for(char c: word.toCharArray())\\n        {\\n            if(node.children[c-\\'a\\']==null)\\n            {\\n                node.children[c-\\'a\\']= new TrieNode();\\n            }\\n            node = node.children[c-\\'a\\'];\\n        }\\n        node.item = word;\\n    }\\n    public boolean search(String word)\\n    {\\n        TrieNode node = root;\\n        for(char c: word.toCharArray())\\n        {\\n            if(node.children[c-\\'a\\']==null)\\n                return false;\\n            node = node.children[c-\\'a\\'];\\n        }\\n        if(node.item.equals(word))\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    public boolean startsWith(String prefix)\\n    {\\n        TrieNode node = root;\\n        for(char c: prefix.toCharArray())\\n        {\\n            if(node.children[c-\\'a\\']==null)\\n            return false;\\n            node = node.children[c-\\'a\\'];\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3309961,
                "title": "easy-to-understand-code-trie-and-dfs",
                "content": "```\\nstruct Node{\\n    Node* trie[26];\\n    bool flag = false;\\n    \\n    bool containsChar(char c){\\n        if(c ==\\'0\\') return false;\\n        return trie[c-\\'a\\'] != NULL;\\n    }\\n    \\n    void addNewChar(char c, Node* ref){\\n        trie[c-\\'a\\'] = ref;\\n    }\\n    Node* getToNode(char c){\\n        return trie[c-\\'a\\'];\\n    }\\n    \\n    void setEnd(){\\n        flag = true;\\n    }\\n    void resetEnd(){\\n        flag = false;\\n    }\\n    bool isEnd(){\\n        return flag;\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    void insert(string word, Node* root) {\\n        Node *head = root;\\n        int n = word.length();\\n        for(int i = 0; i < n; i++){\\n            if(!head->containsChar(word[i]))\\n                head->addNewChar(word[i], new Node());\\n            head = head->getToNode(word[i]);\\n        }\\n        head->setEnd();\\n    }\\n    \\n    vector<string>ans;\\n    void f(vector<vector<char>>& board, int i, int j, int m, int n, string s, Node* trie)\\n    {\\n        if(i < 0 || i >= m || j < 0 || j >= n || board[i][j] == \\'0\\') return;\\n        \\n        s += board[i][j];\\n        if(trie->containsChar(board[i][j]))\\n        {\\n            char temp = board[i][j];\\n            trie = trie->getToNode(temp);\\n            if(trie->isEnd()){\\n                ans.emplace_back(s);\\n                trie->resetEnd();\\n            }\\n            board[i][j] = \\'0\\';\\n            f(board, i-1, j, m, n, s, trie);\\n            f(board, i+1, j, m, n, s, trie);\\n            f(board, i, j-1, m, n, s, trie);\\n            f(board, i, j+1, m, n, s, trie);\\n            board[i][j] = temp;\\n            \\n        }\\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& word) {\\n        int m = board.size(), n = board[0].size();  \\n        Node* root = new Node();\\n        \\n        for(int i = 0; i < word.size(); i++){\\n            insert(word[i], root);\\n        }\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(root->containsChar(board[i][j]))\\n                   f(board, i, j, m, n, \"\", root);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Trie",
                    "Recursion"
                ],
                "code": "```\\nstruct Node{\\n    Node* trie[26];\\n    bool flag = false;\\n    \\n    bool containsChar(char c){\\n        if(c ==\\'0\\') return false;\\n        return trie[c-\\'a\\'] != NULL;\\n    }\\n    \\n    void addNewChar(char c, Node* ref){\\n        trie[c-\\'a\\'] = ref;\\n    }\\n    Node* getToNode(char c){\\n        return trie[c-\\'a\\'];\\n    }\\n    \\n    void setEnd(){\\n        flag = true;\\n    }\\n    void resetEnd(){\\n        flag = false;\\n    }\\n    bool isEnd(){\\n        return flag;\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    void insert(string word, Node* root) {\\n        Node *head = root;\\n        int n = word.length();\\n        for(int i = 0; i < n; i++){\\n            if(!head->containsChar(word[i]))\\n                head->addNewChar(word[i], new Node());\\n            head = head->getToNode(word[i]);\\n        }\\n        head->setEnd();\\n    }\\n    \\n    vector<string>ans;\\n    void f(vector<vector<char>>& board, int i, int j, int m, int n, string s, Node* trie)\\n    {\\n        if(i < 0 || i >= m || j < 0 || j >= n || board[i][j] == \\'0\\') return;\\n        \\n        s += board[i][j];\\n        if(trie->containsChar(board[i][j]))\\n        {\\n            char temp = board[i][j];\\n            trie = trie->getToNode(temp);\\n            if(trie->isEnd()){\\n                ans.emplace_back(s);\\n                trie->resetEnd();\\n            }\\n            board[i][j] = \\'0\\';\\n            f(board, i-1, j, m, n, s, trie);\\n            f(board, i+1, j, m, n, s, trie);\\n            f(board, i, j-1, m, n, s, trie);\\n            f(board, i, j+1, m, n, s, trie);\\n            board[i][j] = temp;\\n            \\n        }\\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& word) {\\n        int m = board.size(), n = board[0].size();  \\n        Node* root = new Node();\\n        \\n        for(int i = 0; i < word.size(); i++){\\n            insert(word[i], root);\\n        }\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(root->containsChar(board[i][j]))\\n                   f(board, i, j, m, n, \"\", root);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3134511,
                "title": "simple-algorithm-using-trie-data-structure-in-c-no-pruning",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe use the trie data-structure to store all the words, and iterate over the same to search for words in the board. \\nNote: No pruning is done, just simple plain algorithm! :)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMain Algorithm:- \\n1. Create an unordered set \\n2. Create a trie data-structure and store all the words in it\\n3. Now iterate through each cell in the word and see if any word starts from it in trie\\n    3.1 if it does, then call a search function for that letter node in trie\\n4. Create an answer vector and copy the set to it\\n5. retur the answer\\n\\nSearch() algorithm:-\\n1. Store the char at current position in board and replace it with some temperory symbol like dollar ( this is done to avoid multiple traversals through the same branch ) \\n2. If the current word is complete, add it to the answer set\\n3. Now for each of the four sides of current cell (right, above, left, below) - if it matches with next child of trie node, call function search on it recursively\\n4. replace the current position in board with its original symbol\\n\\n\\n# Complexity\\n- Time complexity: O(m*n*m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(w*l)\\n    where w=number of words, and l= average length of a word\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Node {    // a trie node\\npublic:\\n    char letter;\\n    bool isComplete;\\n    string word;\\n    unordered_map<char, Node*> childList;\\n\\n    Node(char c) {\\n        letter=c;\\n        isComplete=false;\\n        word=\"\";\\n    }\\n    bool hasChild(char c) {\\n        if(childList.find(c)==childList.end()) {\\n            return false;\\n        }\\n        return true;\\n    }\\n    Node* getChild(char c) {\\n        return childList.at(c);\\n    }\\n    void putNewChild(char c) {\\n        childList.insert({c, new Node(c)});\\n    }\\n};\\n\\n// functions to perform upon trie \\nvoid insert(string word, Node* root) {\\n    Node* ptr=root;\\n    for(int i=0; i<word.length(); i++) {\\n        if(ptr->hasChild(word[i])==true) {\\n            ptr=ptr->getChild(word[i]);\\n        }\\n        else {\\n            ptr->putNewChild(word[i]);\\n            ptr=ptr->getChild(word[i]);\\n        }\\n    }\\n    ptr->isComplete=true;\\n    ptr->word=word;\\n    return;\\n}\\n\\nvoid search(Node* curr, int i, int j, unordered_set<string>& ans, vector<vector<char>>& board) {\\n    int m=board.size(), n=board[0].size();  // m*n matrix board \\n    // store value of current position in board and mark it as \\'\\n``` \\n        char c=board[i][j];\\n        board[i][j]=\\'\\n```;\\n    // check if current word complete \\n        // if yes, insert it to answer set\\n        if(curr->isComplete==true) {\\n            ans.insert(curr->word);\\n        }\\n    // check for each of the four sides if it matches the next child \\n        // if it does match, then recursively call search for it\\n            if(j+1<n && curr->hasChild(board[i][j+1]) )// right-side \\n                search(curr->getChild(board[i][j+1]), i, j+1, ans, board);\\n            if(i-1>=0 && curr->hasChild(board[i-1][j]))// above\\n                search(curr->getChild(board[i-1][j]), i-1, j, ans, board);\\n            if(j-1>=0 && curr->hasChild(board[i][j-1]))// left-side\\n                search(curr->getChild(board[i][j-1]), i, j-1, ans, board);\\n            if(i+1<m && curr->hasChild(board[i+1][j]))// below\\n                search(curr->getChild(board[i+1][j]), i+1, j, ans, board);\\n    // unmark the current position by its previous value\\n        board[i][j]=c;\\n}\\n\\n// Question -->\\nclass Solution {\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        // Create a unordered set \\n            unordered_set<string> uset;\\n        // create a trie and store all words in it\\n            Node* trie= new Node(\\'0\\');\\n            for(int i=0; i<words.size(); i++) {\\n                insert(words[i], trie);\\n            }\\n        // now go through each cell in board and find if a word matches in it\\n            // if it does match, then insert it to the set\\n            int r=board.size(), c=board[0].size();\\n            for(int i=0; i<r; i++) {\\n                for(int j=0; j<c; j++) {\\n                    // for cell <i, j>, if any word starts with this letter -->\\n                        if(trie->hasChild(board[i][j])) {\\n                            // start searching through all paths ... \\n                                search(trie->getChild(board[i][j]), i, j, uset, board);\\n                        }\\n\\n                }\\n            }\\n        // Create a vector and copy set to it\\n            vector<string> ans;\\n            unordered_set<string>::iterator itr;\\n            for(itr=uset.begin(); itr!=uset.end(); itr++) {\\n                ans.push_back(*itr);\\n            }\\n        // return the vector\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "```\\nclass Node {    // a trie node\\npublic:\\n    char letter;\\n    bool isComplete;\\n    string word;\\n    unordered_map<char, Node*> childList;\\n\\n    Node(char c) {\\n        letter=c;\\n        isComplete=false;\\n        word=\"\";\\n    }\\n    bool hasChild(char c) {\\n        if(childList.find(c)==childList.end()) {\\n            return false;\\n        }\\n        return true;\\n    }\\n    Node* getChild(char c) {\\n        return childList.at(c);\\n    }\\n    void putNewChild(char c) {\\n        childList.insert({c, new Node(c)});\\n    }\\n};\\n\\n// functions to perform upon trie \\nvoid insert(string word, Node* root) {\\n    Node* ptr=root;\\n    for(int i=0; i<word.length(); i++) {\\n        if(ptr->hasChild(word[i])==true) {\\n            ptr=ptr->getChild(word[i]);\\n        }\\n        else {\\n            ptr->putNewChild(word[i]);\\n            ptr=ptr->getChild(word[i]);\\n        }\\n    }\\n    ptr->isComplete=true;\\n    ptr->word=word;\\n    return;\\n}\\n\\nvoid search(Node* curr, int i, int j, unordered_set<string>& ans, vector<vector<char>>& board) {\\n    int m=board.size(), n=board[0].size();  // m*n matrix board \\n    // store value of current position in board and mark it as \\'\\n```\n```;\\n    // check if current word complete \\n        // if yes, insert it to answer set\\n        if(curr->isComplete==true) {\\n            ans.insert(curr->word);\\n        }\\n    // check for each of the four sides if it matches the next child \\n        // if it does match, then recursively call search for it\\n            if(j+1<n && curr->hasChild(board[i][j+1]) )// right-side \\n                search(curr->getChild(board[i][j+1]), i, j+1, ans, board);\\n            if(i-1>=0 && curr->hasChild(board[i-1][j]))// above\\n                search(curr->getChild(board[i-1][j]), i-1, j, ans, board);\\n            if(j-1>=0 && curr->hasChild(board[i][j-1]))// left-side\\n                search(curr->getChild(board[i][j-1]), i, j-1, ans, board);\\n            if(i+1<m && curr->hasChild(board[i+1][j]))// below\\n                search(curr->getChild(board[i+1][j]), i+1, j, ans, board);\\n    // unmark the current position by its previous value\\n        board[i][j]=c;\\n}\\n\\n// Question -->\\nclass Solution {\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        // Create a unordered set \\n            unordered_set<string> uset;\\n        // create a trie and store all words in it\\n            Node* trie= new Node(\\'0\\');\\n            for(int i=0; i<words.size(); i++) {\\n                insert(words[i], trie);\\n            }\\n        // now go through each cell in board and find if a word matches in it\\n            // if it does match, then insert it to the set\\n            int r=board.size(), c=board[0].size();\\n            for(int i=0; i<r; i++) {\\n                for(int j=0; j<c; j++) {\\n                    // for cell <i, j>, if any word starts with this letter -->\\n                        if(trie->hasChild(board[i][j])) {\\n                            // start searching through all paths ... \\n                                search(trie->getChild(board[i][j]), i, j, uset, board);\\n                        }\\n\\n                }\\n            }\\n        // Create a vector and copy set to it\\n            vector<string> ans;\\n            unordered_set<string>::iterator itr;\\n            for(itr=uset.begin(); itr!=uset.end(); itr++) {\\n                ans.push_back(*itr);\\n            }\\n        // return the vector\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783455,
                "title": "python-3-one-line",
                "content": "First, we check it passes recent tests without TLE:\\n\\n```python\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        board = {i+j*1j: c for i, row in enumerate(board) for j, c in enumerate(row)}\\n        res, trie = [], (Trie:=lambda: defaultdict(Trie))()\\n        any(reduce(dict.__getitem__, w, trie).__setitem__(\\'$\\', w) for w in words)\\n        def dfs(z, parent):\\n            if not (c:=board.get(z)) in parent:\\n                return\\n            if (word:=(node:=parent[c]).pop(\\'$\\', None)):\\n                res.append(word)\\n            board[z] = None\\n            any(dfs(z+1j**k, node) for k in range(4))\\n            board[z] = c\\n            if not node:\\n                parent.pop(c)\\n        any(dfs(z, trie) for z in board)\\n        return res\\n```\\n\\nThen we put it all into a single line:\\n\\n```python\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        return ([b:={i+j*1j: c for i, row in enumerate(board) for j, c in enumerate(row)}, r:=[], t:=(T:=lambda: defaultdict(T))(), [reduce(dict.__getitem__, w, t).__setitem__(\\'$\\',w) for w in words], (f:=lambda z,p: (c:=b.get(z)) in p and (((w:=(n:=p[c]).pop(\\'$\\',0)) and r.append(w)) or ((b.__setitem__(z,0) or [f(z+1j**k, n) for k in range(4)] and b.__setitem__(z,c)) or (n or p.pop(c)))))] and [f(z,t) for z in b] and r)\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```python\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        board = {i+j*1j: c for i, row in enumerate(board) for j, c in enumerate(row)}\\n        res, trie = [], (Trie:=lambda: defaultdict(Trie))()\\n        any(reduce(dict.__getitem__, w, trie).__setitem__(\\'$\\', w) for w in words)\\n        def dfs(z, parent):\\n            if not (c:=board.get(z)) in parent:\\n                return\\n            if (word:=(node:=parent[c]).pop(\\'$\\', None)):\\n                res.append(word)\\n            board[z] = None\\n            any(dfs(z+1j**k, node) for k in range(4))\\n            board[z] = c\\n            if not node:\\n                parent.pop(c)\\n        any(dfs(z, trie) for z in board)\\n        return res\\n```\n```python\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        return ([b:={i+j*1j: c for i, row in enumerate(board) for j, c in enumerate(row)}, r:=[], t:=(T:=lambda: defaultdict(T))(), [reduce(dict.__getitem__, w, t).__setitem__(\\'$\\',w) for w in words], (f:=lambda z,p: (c:=b.get(z)) in p and (((w:=(n:=p[c]).pop(\\'$\\',0)) and r.append(w)) or ((b.__setitem__(z,0) or [f(z+1j**k, n) for k in range(4)] and b.__setitem__(z,c)) or (n or p.pop(c)))))] and [f(z,t) for z in b] and r)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782712,
                "title": "python-backtracking-and-trie-plus-advice-for-tle",
                "content": "I was getting `Time Limit Exceeded `until I added word counts to the trie. Specifically, each node in the trie stores the number of words at or beneath that node. When a word is found, the word is removed from the trie, and all the relevant word counts are decremented. This allows us to detect when there are no more words in the current branch of the trie, at which point we can backtrack.\\n```\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:       \\n        num_rows = len(board)\\n        num_cols = len(board[0])\\n        res = set()\\n        \\n        def find_words(row, col, letters_so_far, used_squares, trie):\\n            if not (0 <= row < num_rows) or not (0 <= col < num_cols):\\n                return\\n            if (row, col) in used_squares:\\n                return\\n            if not trie[\"NUM WORDS\"]:\\n                return\\n            \\n            letter = board[row][col]\\n            if letter not in trie:\\n                return\\n            \\n            new_trie = trie[letter]            \\n            letters_so_far.append(letter)\\n            used_squares.add((row, col))\\n            \\n            if \"END\" in new_trie:\\n                res.add(\"\".join(letters_so_far))\\n                del new_trie[\"END\"]\\n                \\n                trie_to_update = new_trie\\n                while trie_to_update:                    \\n                    trie_to_update[\"NUM WORDS\"] -= 1                        \\n                    trie_to_update = trie_to_update[\"PARENT\"]                    \\n            \\n            find_words(row + 1, col, letters_so_far, used_squares, new_trie)\\n            find_words(row - 1, col, letters_so_far, used_squares, new_trie)    \\n            find_words(row, col + 1, letters_so_far, used_squares, new_trie)    \\n            find_words(row, col - 1, letters_so_far, used_squares, new_trie)\\n            \\n            letters_so_far.pop()\\n            used_squares.remove((row, col))            \\n            \\n        trie = self.make_trie(words)\\n        for start_row in range(num_rows):\\n            for start_col in range(num_cols):\\n                find_words(start_row, start_col, [], set(), trie)\\n        \\n        return list(res)\\n    \\n    def make_trie(self, words):\\n        trie = {\"NUM WORDS\": 0, \"PARENT\": None}\\n        for word in words:\\n            trie_pos = trie\\n            trie_pos[\"NUM WORDS\"] += 1\\n\\n            for letter in word:\\n                if letter not in trie_pos:\\n                    trie_pos[letter] = {\"NUM WORDS\": 0, \"PARENT\": trie_pos}\\n                trie_pos = trie_pos[letter]\\n                trie_pos[\"NUM WORDS\"] += 1\\n\\n            trie_pos[\"END\"] = \"END\"     \\n            \\n        return trie\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:       \\n        num_rows = len(board)\\n        num_cols = len(board[0])\\n        res = set()\\n        \\n        def find_words(row, col, letters_so_far, used_squares, trie):\\n            if not (0 <= row < num_rows) or not (0 <= col < num_cols):\\n                return\\n            if (row, col) in used_squares:\\n                return\\n            if not trie[\"NUM WORDS\"]:\\n                return\\n            \\n            letter = board[row][col]\\n            if letter not in trie:\\n                return\\n            \\n            new_trie = trie[letter]            \\n            letters_so_far.append(letter)\\n            used_squares.add((row, col))\\n            \\n            if \"END\" in new_trie:\\n                res.add(\"\".join(letters_so_far))\\n                del new_trie[\"END\"]\\n                \\n                trie_to_update = new_trie\\n                while trie_to_update:                    \\n                    trie_to_update[\"NUM WORDS\"] -= 1                        \\n                    trie_to_update = trie_to_update[\"PARENT\"]                    \\n            \\n            find_words(row + 1, col, letters_so_far, used_squares, new_trie)\\n            find_words(row - 1, col, letters_so_far, used_squares, new_trie)    \\n            find_words(row, col + 1, letters_so_far, used_squares, new_trie)    \\n            find_words(row, col - 1, letters_so_far, used_squares, new_trie)\\n            \\n            letters_so_far.pop()\\n            used_squares.remove((row, col))            \\n            \\n        trie = self.make_trie(words)\\n        for start_row in range(num_rows):\\n            for start_col in range(num_cols):\\n                find_words(start_row, start_col, [], set(), trie)\\n        \\n        return list(res)\\n    \\n    def make_trie(self, words):\\n        trie = {\"NUM WORDS\": 0, \"PARENT\": None}",
                "codeTag": "Java"
            },
            {
                "id": 2782656,
                "title": "python-trie-dfs-solution-faster-than-25",
                "content": "I tried Word Search II with a Word Search I level solution, of course it TLEd - went to NeetCode to see their solution, implemented it for myself - It TLEd. This code is based off of their solution with a few small changes.\\n\\n\\n1) The important change: after we check if the current node `is_word`, we also check if it has any children, in which case we may prune it (`del node`) to save unnecessary traversals for future DFS calls. Else, we DFS onwards.\\n\\nThe following changes are minor.\\n\\n2) We use a list to track the results rather than a set, and avoid adding the same word twice by setting `is_word` to False instead.\\n3) Instead of using a set to track visited chars, we modify the cell to `\" \"`, and set things right before we leave the DFS function call. \\n\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.is_word = False\\n    \\n    def add_word(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n        cur.is_word = True\\n\\nclass Solution:    \\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        ROWS, COLS = len(board), len(board[0])\\n        results = []\\n        \\n        trie = TrieNode()\\n        for word in words:\\n            trie.add_word(word)\\n        \\n        def dfs(r, c, node, word):\\n            if (r < 0 or r == ROWS or\\n                c < 0 or c == COLS or\\n                board[r][c] == \" \" or board[r][c] not in node.children):\\n                return\\n            temp_char = board[r][c]\\n            board[r][c] = \" \"\\n            node = node.children[temp_char]\\n            word += temp_char\\n            \\n            if node.is_word:\\n                results.append(word)\\n                node.is_word = False\\n            \\n            if not node.children:\\n                del node\\n            else:\\n                dfs(r + 1, c, node, word)\\n                dfs(r - 1, c, node, word)\\n                dfs(r, c + 1, node, word)\\n                dfs(r, c - 1, node, word)\\n            \\n            board[r][c] = temp_char\\n            \\n\\n        for r in range(ROWS):\\n            for c in range(COLS):\\n                dfs(r, c, trie, \"\")\\n        return results\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.is_word = False\\n    \\n    def add_word(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n        cur.is_word = True\\n\\nclass Solution:    \\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        ROWS, COLS = len(board), len(board[0])\\n        results = []\\n        \\n        trie = TrieNode()\\n        for word in words:\\n            trie.add_word(word)\\n        \\n        def dfs(r, c, node, word):\\n            if (r < 0 or r == ROWS or\\n                c < 0 or c == COLS or\\n                board[r][c] == \" \" or board[r][c] not in node.children):\\n                return\\n            temp_char = board[r][c]\\n            board[r][c] = \" \"\\n            node = node.children[temp_char]\\n            word += temp_char\\n            \\n            if node.is_word:\\n                results.append(word)\\n                node.is_word = False\\n            \\n            if not node.children:\\n                del node\\n            else:\\n                dfs(r + 1, c, node, word)\\n                dfs(r - 1, c, node, word)\\n                dfs(r, c + 1, node, word)\\n                dfs(r, c - 1, node, word)\\n            \\n            board[r][c] = temp_char\\n            \\n\\n        for r in range(ROWS):\\n            for c in range(COLS):\\n                dfs(r, c, trie, \"\")\\n        return results\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782488,
                "title": "c-solution-without-trie",
                "content": "**Algorithm Overview**\\nDfs generates all string possible starting in each char of board, if any string matches then it is added to solution.\\n\\n**Optimizations**\\nUsing dfs for all possible string causes tle. So, max length of input string is found is used to limit the dfs calls.\\n\\n**Code**\\n```cpp\\nclass Solution {\\n    // stores words in a map, so that lookup in dfs can be done in O(1) time\\n    unordered_set<string> mp;\\n    // global state is used for easy insertion of ans by dfs\\n    vector<string> ans;\\n    // stores the maximum length of string\\n    int mx;\\n    \\nvoid dfs(vector<vector<char>>& board,int i,int j,vector<vector<bool>>& visit, string &word){ \\n    if(i<0 || j<0 || i>=board.size() || j>= board[0].size()) return ;\\n    if(visit[i][j] || word.length() >= mx)return ;\\n    \\n    word.push_back(board[i][j]);\\n    \\n    // if mp contains the word, it is added to the answer\\n    // also, word is removed imediately from the map, to prevent duplicates\\n    // in answer\\n    if(mp.count(word)){\\n        ans.push_back(word);\\n        mp.erase(word);\\n    }\\n    \\n    //dfs calls\\n    visit[i][j] = true;\\n    dfs(board,i+1,j,visit, word);\\n    dfs(board,i-1,j,visit, word);\\n    dfs(board,i,j+1,visit, word);\\n    dfs(board,i,j-1,visit, word);\\n    \\n    // reverting visit and word to previous state\\n    visit[i][j]= false;\\n    word.pop_back();\\n}\\n    \\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        // visit array for dfs calls\\n        vector<vector<bool>> visit(board.size(), vector<bool>(board[0].size(), false));\\n        mx = 0;\\n        \\n        // this loop adds words to the mp, and finds the max length string\\n        for(auto word: words){\\n            mp.insert(word);\\n            mx = max(mx, (int)word.length());\\n        }\\n            \\n        // this loop calls dfs for all cells of the board\\n        string s = \"\";\\n        for(int i = 0;i < board.size(); i++){\\n            for(int j = 0; j < board[0].size(); j++){\\n                dfs(board, i, j, visit, s);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```cpp\\nclass Solution {\\n    // stores words in a map, so that lookup in dfs can be done in O(1) time\\n    unordered_set<string> mp;\\n    // global state is used for easy insertion of ans by dfs\\n    vector<string> ans;\\n    // stores the maximum length of string\\n    int mx;\\n    \\nvoid dfs(vector<vector<char>>& board,int i,int j,vector<vector<bool>>& visit, string &word){ \\n    if(i<0 || j<0 || i>=board.size() || j>= board[0].size()) return ;\\n    if(visit[i][j] || word.length() >= mx)return ;\\n    \\n    word.push_back(board[i][j]);\\n    \\n    // if mp contains the word, it is added to the answer\\n    // also, word is removed imediately from the map, to prevent duplicates\\n    // in answer\\n    if(mp.count(word)){\\n        ans.push_back(word);\\n        mp.erase(word);\\n    }\\n    \\n    //dfs calls\\n    visit[i][j] = true;\\n    dfs(board,i+1,j,visit, word);\\n    dfs(board,i-1,j,visit, word);\\n    dfs(board,i,j+1,visit, word);\\n    dfs(board,i,j-1,visit, word);\\n    \\n    // reverting visit and word to previous state\\n    visit[i][j]= false;\\n    word.pop_back();\\n}\\n    \\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        // visit array for dfs calls\\n        vector<vector<bool>> visit(board.size(), vector<bool>(board[0].size(), false));\\n        mx = 0;\\n        \\n        // this loop adds words to the mp, and finds the max length string\\n        for(auto word: words){\\n            mp.insert(word);\\n            mx = max(mx, (int)word.length());\\n        }\\n            \\n        // this loop calls dfs for all cells of the board\\n        string s = \"\";\\n        for(int i = 0;i < board.size(); i++){\\n            for(int j = 0; j < board[0].size(); j++){\\n                dfs(board, i, j, visit, s);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2781988,
                "title": "c-backtracking-stl",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    string str;\\n    bool vis[13][13];\\n\\n    unordered_set<string> res;\\n    unordered_set<string> toFound;\\n    unordered_map<string, int> m;\\n\\n    void rec(int i, int j, vector<vector<char>> &a)\\n    {\\n        if (toFound.find(str) != toFound.end())\\n        {\\n            string curr;\\n\\n            for (auto x : str)\\n            {\\n                curr += x;\\n                m[curr]--;\\n            }\\n\\n            toFound.erase(curr);\\n            res.insert(str);\\n        }\\n\\n        if (i < 0 || j < 0 || i >= a.size() || j >= a[0].size() || vis[i][j] || m[str] == 0)\\n        {\\n            return;\\n        }\\n\\n        vis[i][j] = 1;\\n\\n        str += a[i][j];\\n\\n        rec(i + 1, j, a);\\n        rec(i, j + 1, a);\\n        rec(i, j - 1, a);\\n        rec(i - 1, j, a);\\n\\n        vis[i][j] = 0;\\n\\n        str.pop_back();\\n    }\\n\\n    vector<string> findWords(vector<vector<char>>& a, vector<string>& words) {\\n\\n\\n        for (auto x : words)\\n        {\\n            string curr;\\n\\n            toFound.insert(x);\\n\\n            for (auto y : x)\\n            {\\n                curr += y;\\n                m[curr]++;\\n            }\\n        }\\n\\n        m[\"\"]++;\\n\\n        for (int i = 0; i < a.size(); i++)\\n        {\\n            for (int j = 0; j < a[0].size(); j++)\\n            {\\n                memset(vis, 0, sizeof(vis));\\n                rec(i, j, a);\\n            }\\n        }\\n\\n        vector<string> ans;\\n\\n        for (auto x : res)\\n        {\\n            ans.push_back(x);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    string str;\\n    bool vis[13][13];\\n\\n    unordered_set<string> res;\\n    unordered_set<string> toFound;\\n    unordered_map<string, int> m;\\n\\n    void rec(int i, int j, vector<vector<char>> &a)\\n    {\\n        if (toFound.find(str) != toFound.end())\\n        {\\n            string curr;\\n\\n            for (auto x : str)\\n            {\\n                curr += x;\\n                m[curr]--;\\n            }\\n\\n            toFound.erase(curr);\\n            res.insert(str);\\n        }\\n\\n        if (i < 0 || j < 0 || i >= a.size() || j >= a[0].size() || vis[i][j] || m[str] == 0)\\n        {\\n            return;\\n        }\\n\\n        vis[i][j] = 1;\\n\\n        str += a[i][j];\\n\\n        rec(i + 1, j, a);\\n        rec(i, j + 1, a);\\n        rec(i, j - 1, a);\\n        rec(i - 1, j, a);\\n\\n        vis[i][j] = 0;\\n\\n        str.pop_back();\\n    }\\n\\n    vector<string> findWords(vector<vector<char>>& a, vector<string>& words) {\\n\\n\\n        for (auto x : words)\\n        {\\n            string curr;\\n\\n            toFound.insert(x);\\n\\n            for (auto y : x)\\n            {\\n                curr += y;\\n                m[curr]++;\\n            }\\n        }\\n\\n        m[\"\"]++;\\n\\n        for (int i = 0; i < a.size(); i++)\\n        {\\n            for (int j = 0; j < a[0].size(); j++)\\n            {\\n                memset(vis, 0, sizeof(vis));\\n                rec(i, j, a);\\n            }\\n        }\\n\\n        vector<string> ans;\\n\\n        for (auto x : res)\\n        {\\n            ans.push_back(x);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2781881,
                "title": "c-dfs-trie-backtracking-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    struct Node {\\n        Node *child[26];\\n        string word;\\n        bool end;\\n        Node()\\n        {\\n            end = false;\\n            word = \"\";\\n            for(int i = 0; i < 26; i++)\\n                child[i] = NULL;    \\n        }\\n    };\\n    \\n    Node *root = new Node();\\n    void insert(string &s)\\n    {\\n        Node *curr = root;\\n        for(int i = 0 ; i < s.size(); i++)\\n        {\\n            int idx = s[i] - \\'a\\';\\n            if(curr -> child[idx] == NULL)\\n            {\\n                curr -> child[idx] = new Node();\\n            }\\n            curr = curr -> child[idx];\\n        }\\n        curr -> end = true;\\n        curr -> word = s;\\n    }\\n    vector<string> ans;\\n    \\n    void dfs(vector<vector<char>> &grid, int i, int j, int m, int n, Node *curr)\\n    {\\n        if(i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == \\'#\\')\\n            return;\\n        int idx = grid[i][j] - \\'a\\';\\n        if(curr -> child[idx] == NULL)\\n            return;\\n        curr = curr -> child[idx];\\n        if(curr -> end == true)\\n        {\\n            ans.push_back(curr -> word);\\n            curr -> end = false;\\n        }\\n        char val = grid[i][j];\\n        grid[i][j] = \\'#\\';\\n        dfs(grid, i + 1, j, m, n, curr);\\n        dfs(grid, i, j + 1, m , n, curr);\\n        dfs(grid, i - 1, j, m , n , curr);\\n        dfs(grid, i, j - 1, m, n, curr);\\n        grid[i][j] = val;\\n    }\\n    vector<string> findWords(vector<vector<char>>& grid, vector<string>& words) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        for(auto word : words)\\n        {\\n            insert(word);\\n        }\\n        for(int i = 0 ; i < m; i++)\\n        {\\n            for(int j = 0 ; j < n; j++)\\n            {\\n                dfs(grid, i, j, m ,n , root);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct Node {\\n        Node *child[26];\\n        string word;\\n        bool end;\\n        Node()\\n        {\\n            end = false;\\n            word = \"\";\\n            for(int i = 0; i < 26; i++)\\n                child[i] = NULL;    \\n        }\\n    };\\n    \\n    Node *root = new Node();\\n    void insert(string &s)\\n    {\\n        Node *curr = root;\\n        for(int i = 0 ; i < s.size(); i++)\\n        {\\n            int idx = s[i] - \\'a\\';\\n            if(curr -> child[idx] == NULL)\\n            {\\n                curr -> child[idx] = new Node();\\n            }\\n            curr = curr -> child[idx];\\n        }\\n        curr -> end = true;\\n        curr -> word = s;\\n    }\\n    vector<string> ans;\\n    \\n    void dfs(vector<vector<char>> &grid, int i, int j, int m, int n, Node *curr)\\n    {\\n        if(i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == \\'#\\')\\n            return;\\n        int idx = grid[i][j] - \\'a\\';\\n        if(curr -> child[idx] == NULL)\\n            return;\\n        curr = curr -> child[idx];\\n        if(curr -> end == true)\\n        {\\n            ans.push_back(curr -> word);\\n            curr -> end = false;\\n        }\\n        char val = grid[i][j];\\n        grid[i][j] = \\'#\\';\\n        dfs(grid, i + 1, j, m, n, curr);\\n        dfs(grid, i, j + 1, m , n, curr);\\n        dfs(grid, i - 1, j, m , n , curr);\\n        dfs(grid, i, j - 1, m, n, curr);\\n        grid[i][j] = val;\\n    }\\n    vector<string> findWords(vector<vector<char>>& grid, vector<string>& words) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        for(auto word : words)\\n        {\\n            insert(word);\\n        }\\n        for(int i = 0 ; i < m; i++)\\n        {\\n            for(int j = 0 ; j < n; j++)\\n            {\\n                dfs(grid, i, j, m ,n , root);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780046,
                "title": "cleanest-c-code-detailed-youtube-explanation",
                "content": "```\\n//YouTube Link : https://www.youtube.com/watch?v=DMP2bqW6URA\\nclass Solution {\\npublic:\\n    vector<string> result;\\n    int r, c;\\n    vector<pair<int, int>> directions{{-1, 0},{1, 0},{0, 1},{0, -1}};\\n    struct trieNode {\\n        bool endOfWord;\\n        trieNode* children[26];\\n        string word;\\n    };\\n\\n    trieNode* getNode() {\\n        trieNode* temp = new trieNode();\\n        temp->endOfWord = false;\\n        for(int i = 0; i<26; i++) {\\n            temp->children[i] = NULL;\\n        }\\n        temp->word = \"\";\\n        return temp;\\n    }\\n\\n    void insert(trieNode* root, string str) {\\n        trieNode* pCrawl = root;\\n        for(char ch:str) {\\n            if(pCrawl->children[ch-\\'a\\'] == NULL) {\\n                pCrawl->children[ch-\\'a\\'] = getNode();\\n            }\\n            pCrawl = pCrawl->children[ch-\\'a\\'];\\n        }\\n        pCrawl->endOfWord = true;\\n        pCrawl->word = str;\\n    }\\n\\n    void DFS(vector<vector<char>>& board, int i, int j, trieNode* root) {\\n        if(i<0 || i >= r || j<0 || j >= c || board[i][j] == \\'$\\' || root->children[board[i][j]- \\'a\\'] == NULL) {\\n            return;\\n        }\\n        root = root->children[board[i][j]- \\'a\\'];\\n        if(root->endOfWord == true) {\\n            result.push_back(root->word);\\n            root->endOfWord = false;\\n        }\\n        char temp     = board[i][j];\\n        \\n        board[i][j] = \\'$\\';\\n        for(pair<int, int> p:directions) {\\n            int new_i = i+p.first;\\n            int new_j = j+p.second;\\n            DFS(board, new_i, new_j, root);\\n        }\\n        board[i][j] = temp;\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        r = board.size();\\n        c = board[0].size();\\n\\n        trieNode* root = getNode();\\n        for(string str:words) {\\n            insert(root, str);\\n        }\\n\\n        for(int i = 0; i<r; i++) {\\n            for(int j = 0; j<c; j++) {\\n                char ch = board[i][j];\\n                if(root->children[ch-\\'a\\'] != NULL) {\\n                    DFS(board, i, j, root);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\n//YouTube Link : https://www.youtube.com/watch?v=DMP2bqW6URA\\nclass Solution {\\npublic:\\n    vector<string> result;\\n    int r, c;\\n    vector<pair<int, int>> directions{{-1, 0},{1, 0},{0, 1},{0, -1}};\\n    struct trieNode {\\n        bool endOfWord;\\n        trieNode* children[26];\\n        string word;\\n    };\\n\\n    trieNode* getNode() {\\n        trieNode* temp = new trieNode();\\n        temp->endOfWord = false;\\n        for(int i = 0; i<26; i++) {\\n            temp->children[i] = NULL;\\n        }\\n        temp->word = \"\";\\n        return temp;\\n    }\\n\\n    void insert(trieNode* root, string str) {\\n        trieNode* pCrawl = root;\\n        for(char ch:str) {\\n            if(pCrawl->children[ch-\\'a\\'] == NULL) {\\n                pCrawl->children[ch-\\'a\\'] = getNode();\\n            }\\n            pCrawl = pCrawl->children[ch-\\'a\\'];\\n        }\\n        pCrawl->endOfWord = true;\\n        pCrawl->word = str;\\n    }\\n\\n    void DFS(vector<vector<char>>& board, int i, int j, trieNode* root) {\\n        if(i<0 || i >= r || j<0 || j >= c || board[i][j] == \\'$\\' || root->children[board[i][j]- \\'a\\'] == NULL) {\\n            return;\\n        }\\n        root = root->children[board[i][j]- \\'a\\'];\\n        if(root->endOfWord == true) {\\n            result.push_back(root->word);\\n            root->endOfWord = false;\\n        }\\n        char temp     = board[i][j];\\n        \\n        board[i][j] = \\'$\\';\\n        for(pair<int, int> p:directions) {\\n            int new_i = i+p.first;\\n            int new_j = j+p.second;\\n            DFS(board, new_i, new_j, root);\\n        }\\n        board[i][j] = temp;\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        r = board.size();\\n        c = board[0].size();\\n\\n        trieNode* root = getNode();\\n        for(string str:words) {\\n            insert(root, str);\\n        }\\n\\n        for(int i = 0; i<r; i++) {\\n            for(int j = 0; j<c; j++) {\\n                char ch = board[i][j];\\n                if(root->children[ch-\\'a\\'] != NULL) {\\n                    DFS(board, i, j, root);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780015,
                "title": "cpp-solution-using-trie-data-structure-trie-dfs",
                "content": "Here we are adding words in trie and than going through every cell of the grid and if we are at the end of the string of the trie than we add that to our result.\\n\\n```\\nclass TrieNode {\\n    public : \\n    TrieNode *next[26] = {};\\n    string s;\\n    bool endHere = false;\\n};\\n\\nclass Solution {\\npublic:\\n    vector<string> res;\\n    int vis[12][12];\\n    TrieNode *root;\\n    \\n    void insert(string s) {\\n        int n = s.size();\\n        TrieNode *cur = root;\\n        for(int i = 0; i < n; i++) {\\n            int val = s[i] - \\'a\\';\\n            if(!cur->next[val]) { \\n                cur->next[val] = new TrieNode();\\n            }\\n            cur = cur->next[val];\\n        }\\n        cur->endHere = true;\\n        cur->s = s;\\n    }\\n    \\n    void run(int i, int j, TrieNode* r, vector<vector<char>>& board) {\\n        if(r->endHere) {\\n            res.push_back(r->s);\\n            r->endHere = false;\\n        }\\n        \\n        int n = board.size(), m = board[0].size();\\n        if(i < 0 || i >= n || j < 0 || j >= m || vis[i][j]) return;\\n        \\n        vis[i][j] = 1;\\n        int val = board[i][j] - \\'a\\';\\n        if(r->next[val]) {\\n            int dx[4] = {1, -1, 0, 0};\\n            int dy[4] = {0, 0, 1, -1};\\n            \\n            for(int t = 0; t < 4; t++){\\n                int nx = i + dx[t];\\n                int ny = j + dy[t];\\n                run(nx, ny, r->next[val], board);\\n            }\\n        }\\n        vis[i][j] = 0;\\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        res.clear();\\n        memset(vis, 0, sizeof(vis));\\n        root = new TrieNode();\\n        for(auto word : words) insert(word);\\n        int n = board.size(), m = board[0].size();\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                run(i, j, root, board);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode {\\n    public : \\n    TrieNode *next[26] = {};\\n    string s;\\n    bool endHere = false;\\n};\\n\\nclass Solution {\\npublic:\\n    vector<string> res;\\n    int vis[12][12];\\n    TrieNode *root;\\n    \\n    void insert(string s) {\\n        int n = s.size();\\n        TrieNode *cur = root;\\n        for(int i = 0; i < n; i++) {\\n            int val = s[i] - \\'a\\';\\n            if(!cur->next[val]) { \\n                cur->next[val] = new TrieNode();\\n            }\\n            cur = cur->next[val];\\n        }\\n        cur->endHere = true;\\n        cur->s = s;\\n    }\\n    \\n    void run(int i, int j, TrieNode* r, vector<vector<char>>& board) {\\n        if(r->endHere) {\\n            res.push_back(r->s);\\n            r->endHere = false;\\n        }\\n        \\n        int n = board.size(), m = board[0].size();\\n        if(i < 0 || i >= n || j < 0 || j >= m || vis[i][j]) return;\\n        \\n        vis[i][j] = 1;\\n        int val = board[i][j] - \\'a\\';\\n        if(r->next[val]) {\\n            int dx[4] = {1, -1, 0, 0};\\n            int dy[4] = {0, 0, 1, -1};\\n            \\n            for(int t = 0; t < 4; t++){\\n                int nx = i + dx[t];\\n                int ny = j + dy[t];\\n                run(nx, ny, r->next[val], board);\\n            }\\n        }\\n        vis[i][j] = 0;\\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        res.clear();\\n        memset(vis, 0, sizeof(vis));\\n        root = new TrieNode();\\n        for(auto word : words) insert(word);\\n        int n = board.size(), m = board[0].size();\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                run(i, j, root, board);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779919,
                "title": "python-trie-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        res = []\\n        Trie = lambda : defaultdict(Trie)\\n        root = Trie()\\n        def add(s):\\n            cur = root\\n            for c in s: cur = cur[c]\\n            cur[\\'$\\'] = s\\n                \\n        for word in words: add(word)\\n        m, n = len(board), len(board[0])\\n        \\n        def dfs(i, j, root):\\n            ch = board[i][j]\\n            cur = root.get(ch)\\n            if not cur: return \\n\\n            if \\'$\\' in cur: \\n                res.append(cur[\\'$\\'])\\n                del cur[\\'$\\']\\n            \\n            board[i][j] = \\'#\\'\\n            if i<m-1: dfs(i+1, j, cur)\\n            if i>0: dfs(i-1, j, cur)\\n            if j<n-1: dfs(i, j+1, cur)\\n            if j>0: dfs(i, j-1, cur)\\n            board[i][j] = ch\\n\\n        for i in range(m):\\n            for j in range(n):\\n                dfs(i, j, root)\\n        return res\\n    \\n    \\n```",
                "solutionTags": [
                    "Python3",
                    "Trie"
                ],
                "code": "```\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        res = []\\n        Trie = lambda : defaultdict(Trie)\\n        root = Trie()\\n        def add(s):\\n            cur = root\\n            for c in s: cur = cur[c]\\n            cur[\\'$\\'] = s\\n                \\n        for word in words: add(word)\\n        m, n = len(board), len(board[0])\\n        \\n        def dfs(i, j, root):\\n            ch = board[i][j]\\n            cur = root.get(ch)\\n            if not cur: return \\n\\n            if \\'$\\' in cur: \\n                res.append(cur[\\'$\\'])\\n                del cur[\\'$\\']\\n            \\n            board[i][j] = \\'#\\'\\n            if i<m-1: dfs(i+1, j, cur)\\n            if i>0: dfs(i-1, j, cur)\\n            if j<n-1: dfs(i, j+1, cur)\\n            if j>0: dfs(i, j-1, cur)\\n            board[i][j] = ch\\n\\n        for i in range(m):\\n            for j in range(n):\\n                dfs(i, j, root)\\n        return res\\n    \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779704,
                "title": "python-accepted-2022-backtracking-tries",
                "content": "1. build tries\\n2. do backtracking based on each node.child\\n\\nIt\\'s my first post, seeking for votes. Thank you all!\\n\\n```\\nclass Node:\\n    def __init__(self):\\n        self.child = {}\\n        self.end = None  # word\\n        \\nclass Tries:\\n    def __init__(self):\\n        self.root = Node()\\n    \\n    def inser_word(self, word):\\n        \\n        cur = self.root\\n        for c in word:\\n            if c in cur.child:\\n                cur = cur.child[c]\\n            else:\\n                cur.child[c] = Node()\\n                cur = cur.child[c]\\n        cur.end = word\\n\\n    # O(M(4(3**L-1)))\\nclass Solution:\\n\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n    \\n        # tries build tries\\n        # backtracking in each node\\n        # if neibor in node.child\\n        Rows, Cols = len(board), len(board[0])\\n        \\n        tries = Tries()\\n        visited = set()\\n        RR = set(range(Rows))\\n        CC = set(range(Cols))\\n        \\n        for word in words:\\n            tries.inser_word(word)\\n            \\n        words = set(words)\\n        direction = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        \\n        res = set()\\n        \\n        def backtracking(r, c, node):\\n            \\n            if node.end:\\n                res.add(node.end)\\n                \\n            if not node.child:\\n                return\\n            \\n            for dr, dc in direction:\\n                row, col = r + dr, c + dc\\n                if row in RR and col in CC and (row, col) not in visited and board[row][col] in node.child:\\n                    visited.add((row, col))\\n                    backtracking(row, col, node.child[board[row][col]])\\n                    visited.remove((row, col))\\n            \\n\\n        for i in range(Rows):\\n            for j in range(Cols):\\n                if board[i][j] in tries.root.child:\\n                    visited.add((i, j))\\n                    backtracking(i, j, tries.root.child[board[i][j]])\\n                    visited.remove((i, j))\\n        return res\\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Node:\\n    def __init__(self):\\n        self.child = {}\\n        self.end = None  # word\\n        \\nclass Tries:\\n    def __init__(self):\\n        self.root = Node()\\n    \\n    def inser_word(self, word):\\n        \\n        cur = self.root\\n        for c in word:\\n            if c in cur.child:\\n                cur = cur.child[c]\\n            else:\\n                cur.child[c] = Node()\\n                cur = cur.child[c]\\n        cur.end = word\\n\\n    # O(M(4(3**L-1)))\\nclass Solution:\\n\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n    \\n        # tries build tries\\n        # backtracking in each node\\n        # if neibor in node.child\\n        Rows, Cols = len(board), len(board[0])\\n        \\n        tries = Tries()\\n        visited = set()\\n        RR = set(range(Rows))\\n        CC = set(range(Cols))\\n        \\n        for word in words:\\n            tries.inser_word(word)\\n            \\n        words = set(words)\\n        direction = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        \\n        res = set()\\n        \\n        def backtracking(r, c, node):\\n            \\n            if node.end:\\n                res.add(node.end)\\n                \\n            if not node.child:\\n                return\\n            \\n            for dr, dc in direction:\\n                row, col = r + dr, c + dc\\n                if row in RR and col in CC and (row, col) not in visited and board[row][col] in node.child:\\n                    visited.add((row, col))\\n                    backtracking(row, col, node.child[board[row][col]])\\n                    visited.remove((row, col))\\n            \\n\\n        for i in range(Rows):\\n            for j in range(Cols):\\n                if board[i][j] in tries.root.child:\\n                    visited.add((i, j))\\n                    backtracking(i, j, tries.root.child[board[i][j]])\\n                    visited.remove((i, j))\\n        return res\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779588,
                "title": "python-backtracking-with-trie",
                "content": "**Imports and constants**\\n```\\nfrom collections import deque\\nfrom dataclasses import dataclass, field\\nfrom itertools import product\\nfrom typing import Iterable, Optional\\n\\nMOVES = [\\n    (1, 0),\\n    (-1, 0),\\n    (0, 1),\\n    (0, -1),\\n]\\n\\nSPECIAL_CHR = \\'-\\'\\n```\\n\\n**The Solution**\\n```python\\nclass Solution:\\n    def findWords(self, B: list[list[str]], words: list[str]) -> list[str]:\\n        \"\"\"\\n        :param B:\\n        :param words:\\n        :return:\\n        \"\"\"\\n        trie = Trie()\\n        trie.insert_all(words)\\n\\n        m, n = len(B), len(B[0])\\n        output, cur_word = [], deque()\\n\\n        def dfs(x: int, y: int, rt: Node):\\n            if 0 <= x < m and 0 <= y < n and (c := B[x][y]) in rt:\\n                cur_word.append(c)\\n\\n                if (c_node := rt[c]).is_end_of_word:  # current traversal met the end of some word\\n                    output.append(word := \\'\\'.join(cur_word))\\n                    trie.delete(word)\\n\\n                # ------------------------------------------------------#\\n                B[x][y] = SPECIAL_CHR\\n\\n                for dx, dy in MOVES:\\n                    dfs(x + dx, y + dy, c_node)\\n\\n                B[x][y] = c\\n                # ------------------------------------------------------#\\n\\n                cur_word.pop()\\n\\n        for i, j in product(range(m), range(n)):\\n            if trie:  # there are some words in trie\\n                dfs(i, j, trie.root)\\n            else:\\n                # all the words from trie have been removed\\n                break\\n\\n        return output\\n```\\n\\n**Trie Implementation**\\n```python\\n@dataclass\\nclass Node:\\n    \"\"\"\\n    If we only need to do insertion and check if a text is prefix of some word in\\n    the trie, then we do not need \"is_end_of_word\" as well as \"char\"\\n    \"\"\"\\n    char: str = field(default=None)\\n    is_end_of_word: bool = field(default=False)  # True if \"char\" is end of some word in Trie\\n    children: dict[str, \\'Node\\'] = field(default_factory=dict)\\n\\n    def get_or_set(self, c: str) -> \\'Node\\':\\n        if c not in self.children:\\n            self.children[c] = Node(c)\\n\\n        return self.children[c]\\n\\n    def get(self, c: str) -> Optional[\\'Node\\']:\\n        return self.children.get(c)\\n\\n    def delete(self, c: str):\\n        self.children.pop(c)\\n\\n    def __contains__(self, c: str) -> bool:\\n        return c in self.children\\n\\n    def __getitem__(self, c: str) -> \\'Node\\':\\n        return self.children[c]\\n\\n\\n@dataclass\\nclass Trie:\\n    # for root, char is None and is_end_of_word is False, and it can not change ever\\n    root: Node = field(default_factory=Node, init=False)\\n\\n    def insert(self, text: str) -> bool:\\n        \"\"\"\\n        inserting this text into trie.\\n        :param text:\\n        :return: True if text is inserted into the Trie else False\\n        \"\"\"\\n        if not text:  # no text\\n            # inserting this in tries, will make root.is_end_of_word to True,\\n            # so better to return False at this stage\\n            return False\\n\\n        rt = self.root\\n\\n        for c in text:\\n            rt = rt.get_or_set(c)\\n\\n        rt.is_end_of_word = True\\n\\n        return True\\n\\n    def insert_all(self, words: Iterable[str]):\\n        for word in words:\\n            self.insert(word)\\n\\n    def delete(self, text: str) -> bool:\\n        \"\"\"\\n        :param text:\\n        :return: True if this text exists and gets deleted else False\\n        \"\"\"\\n        stk = deque([self.root])\\n\\n        for c in text:\\n            nxt = stk[-1].get(c)\\n\\n            if nxt is None:  # \"text\" is not even a prefix\\n                return False\\n\\n            stk.append(nxt)\\n\\n        peek = stk[-1]\\n\\n        if not peek.is_end_of_word:  # \"text\" is not in trie\\n            return False\\n\\n        peek.is_end_of_word = False\\n\\n        while peek is not self.root and not peek.children and not peek.is_end_of_word:\\n            node = stk.pop()\\n\\n            peek = stk[-1]\\n            peek.delete(node.char)\\n\\n        return True\\n\\n    def __bool__(self) -> bool:\\n        return bool(self.root.children)\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\nfrom dataclasses import dataclass, field\\nfrom itertools import product\\nfrom typing import Iterable, Optional\\n\\nMOVES = [\\n    (1, 0),\\n    (-1, 0),\\n    (0, 1),\\n    (0, -1),\\n]\\n\\nSPECIAL_CHR = \\'-\\'\\n```\n```python\\nclass Solution:\\n    def findWords(self, B: list[list[str]], words: list[str]) -> list[str]:\\n        \"\"\"\\n        :param B:\\n        :param words:\\n        :return:\\n        \"\"\"\\n        trie = Trie()\\n        trie.insert_all(words)\\n\\n        m, n = len(B), len(B[0])\\n        output, cur_word = [], deque()\\n\\n        def dfs(x: int, y: int, rt: Node):\\n            if 0 <= x < m and 0 <= y < n and (c := B[x][y]) in rt:\\n                cur_word.append(c)\\n\\n                if (c_node := rt[c]).is_end_of_word:  # current traversal met the end of some word\\n                    output.append(word := \\'\\'.join(cur_word))\\n                    trie.delete(word)\\n\\n                # ------------------------------------------------------#\\n                B[x][y] = SPECIAL_CHR\\n\\n                for dx, dy in MOVES:\\n                    dfs(x + dx, y + dy, c_node)\\n\\n                B[x][y] = c\\n                # ------------------------------------------------------#\\n\\n                cur_word.pop()\\n\\n        for i, j in product(range(m), range(n)):\\n            if trie:  # there are some words in trie\\n                dfs(i, j, trie.root)\\n            else:\\n                # all the words from trie have been removed\\n                break\\n\\n        return output\\n```\n```python\\n@dataclass\\nclass Node:\\n    \"\"\"\\n    If we only need to do insertion and check if a text is prefix of some word in\\n    the trie, then we do not need \"is_end_of_word\" as well as \"char\"\\n    \"\"\"\\n    char: str = field(default=None)\\n    is_end_of_word: bool = field(default=False)  # True if \"char\" is end of some word in Trie\\n    children: dict[str, \\'Node\\'] = field(default_factory=dict)\\n\\n    def get_or_set(self, c: str) -> \\'Node\\':\\n        if c not in self.children:\\n            self.children[c] = Node(c)\\n\\n        return self.children[c]\\n\\n    def get(self, c: str) -> Optional[\\'Node\\']:\\n        return self.children.get(c)\\n\\n    def delete(self, c: str):\\n        self.children.pop(c)\\n\\n    def __contains__(self, c: str) -> bool:\\n        return c in self.children\\n\\n    def __getitem__(self, c: str) -> \\'Node\\':\\n        return self.children[c]\\n\\n\\n@dataclass\\nclass Trie:\\n    # for root, char is None and is_end_of_word is False, and it can not change ever\\n    root: Node = field(default_factory=Node, init=False)\\n\\n    def insert(self, text: str) -> bool:\\n        \"\"\"\\n        inserting this text into trie.\\n        :param text:\\n        :return: True if text is inserted into the Trie else False\\n        \"\"\"\\n        if not text:  # no text\\n            # inserting this in tries, will make root.is_end_of_word to True,\\n            # so better to return False at this stage\\n            return False\\n\\n        rt = self.root\\n\\n        for c in text:\\n            rt = rt.get_or_set(c)\\n\\n        rt.is_end_of_word = True\\n\\n        return True\\n\\n    def insert_all(self, words: Iterable[str]):\\n        for word in words:\\n            self.insert(word)\\n\\n    def delete(self, text: str) -> bool:\\n        \"\"\"\\n        :param text:\\n        :return: True if this text exists and gets deleted else False\\n        \"\"\"\\n        stk = deque([self.root])\\n\\n        for c in text:\\n            nxt = stk[-1].get(c)\\n\\n            if nxt is None:  # \"text\" is not even a prefix\\n                return False\\n\\n            stk.append(nxt)\\n\\n        peek = stk[-1]\\n\\n        if not peek.is_end_of_word:  # \"text\" is not in trie\\n            return False\\n\\n        peek.is_end_of_word = False\\n\\n        while peek is not self.root and not peek.children and not peek.is_end_of_word:\\n            node = stk.pop()\\n\\n            peek = stk[-1]\\n            peek.delete(node.char)\\n\\n        return True\\n\\n    def __bool__(self) -> bool:\\n        return bool(self.root.children)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779573,
                "title": "javascript-trie-valid-true",
                "content": "```\\nvar findWords = function(board, words) {\\n    var i, j, tr;\\n    let used = new Array(board.length);\\n    let trie = {};\\n    let results = new Set();\\n    \\n    for( i of words ) {\\n        tr = trie;\\n        for( j=0; j<i.length; j++ ) {\\n            if( !(i[j] in tr) ) tr[i[j]] = {};\\n            tr = tr[i[j]];\\n        }\\n        tr.valid = i;\\n    }\\n    \\n    for( i=0; i<board.length; i++ ) {\\n        used[i] = new Array(board[0].length);\\n    }\\n        \\n    let search = function(i, j, trie) {\\n        var tr;\\n        if( i >= board.length || j >= board[0].length || i < 0 || j < 0 ) return;\\n        if( used[i][j] === true ) return;\\n        if( !(board[i][j] in trie) ) return;\\n\\n        tr = trie[ board[i][j] ];\\n        used[i][j] = true;\\n        if( \\'valid\\' in tr )\\n            results.add(tr.valid);\\n        search(i+1, j, tr);\\n        search(i-1, j, tr);\\n        search(i, j+1, tr);\\n        search(i, j-1, tr);\\n        used[i][j] = false;\\n    }\\n    \\n    for( i=0; i<board.length; i++ ) {\\n        for( j=0; j<board[0].length; j++ ) {\\n            search(i, j, trie);\\n        }\\n    }\\n    \\n    return [...results];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar findWords = function(board, words) {\\n    var i, j, tr;\\n    let used = new Array(board.length);\\n    let trie = {};\\n    let results = new Set();\\n    \\n    for( i of words ) {\\n        tr = trie;\\n        for( j=0; j<i.length; j++ ) {\\n            if( !(i[j] in tr) ) tr[i[j]] = {};\\n            tr = tr[i[j]];\\n        }\\n        tr.valid = i;\\n    }\\n    \\n    for( i=0; i<board.length; i++ ) {\\n        used[i] = new Array(board[0].length);\\n    }\\n        \\n    let search = function(i, j, trie) {\\n        var tr;\\n        if( i >= board.length || j >= board[0].length || i < 0 || j < 0 ) return;\\n        if( used[i][j] === true ) return;\\n        if( !(board[i][j] in trie) ) return;\\n\\n        tr = trie[ board[i][j] ];\\n        used[i][j] = true;\\n        if( \\'valid\\' in tr )\\n            results.add(tr.valid);\\n        search(i+1, j, tr);\\n        search(i-1, j, tr);\\n        search(i, j+1, tr);\\n        search(i, j-1, tr);\\n        used[i][j] = false;\\n    }\\n    \\n    for( i=0; i<board.length; i++ ) {\\n        for( j=0; j<board[0].length; j++ ) {\\n            search(i, j, trie);\\n        }\\n    }\\n    \\n    return [...results];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2778092,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\n    struct TrieNode {\\n        TrieNode *children[26];\\n        string word;\\n\\n        TrieNode() : word(\"\") {\\n            for (int i = 0; i < 26; i++) {\\n                children[i] = nullptr;\\n            }\\n        }\\n    };\\n\\npublic:\\n    vector<string> findWords(vector<vector<char>> &board, vector<string> &words) {\\n        TrieNode *root = buildTrie(words);\\n        vector<string> result;\\n        for (int i = 0; i < board.size(); i++) {\\n            for (int j = 0; j < board[0].size(); j++) {\\n                dfs(board, i, j, root, result);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /** Inserts a word into the trie. */\\n    TrieNode *buildTrie(vector<string> &words) {\\n        TrieNode *root = new TrieNode();\\n        for (int j = 0; j < words.size(); j++) {\\n            string word = words[j];\\n            TrieNode *curr = root;\\n            for (int i = 0; i < word.length(); i++) {\\n                char c = word[i] - \\'a\\';\\n                if (curr->children[c] == nullptr) {\\n                    curr->children[c] = new TrieNode();\\n                }\\n                curr = curr->children[c];\\n            }\\n            curr->word = word;\\n        }\\n        return root;\\n    }\\n\\n    void dfs(vector<vector<char>> &board, int i, int j, TrieNode *p, vector<string> &result) {\\n        char c = board[i][j];\\n        if (c == \\'#\\' || !p->children[c - \\'a\\']) return;\\n        p = p->children[c - \\'a\\'];\\n        if (p->word.size() > 0) {\\n            result.push_back(p->word);\\n            p->word = \"\";\\n        }\\n\\n        board[i][j] = \\'#\\';\\n        if (i > 0) dfs(board, i - 1, j, p, result);\\n        if (j > 0) dfs(board, i, j - 1, p, result);\\n        if (i < board.size() - 1) dfs(board, i + 1, j, p, result);\\n        if (j < board[0].size() - 1) dfs(board, i, j + 1, p, result);\\n        board[i][j] = c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    struct TrieNode {\\n        TrieNode *children[26];\\n        string word;\\n\\n        TrieNode() : word(\"\") {\\n            for (int i = 0; i < 26; i++) {\\n                children[i] = nullptr;\\n            }\\n        }\\n    };\\n\\npublic:\\n    vector<string> findWords(vector<vector<char>> &board, vector<string> &words) {\\n        TrieNode *root = buildTrie(words);\\n        vector<string> result;\\n        for (int i = 0; i < board.size(); i++) {\\n            for (int j = 0; j < board[0].size(); j++) {\\n                dfs(board, i, j, root, result);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /** Inserts a word into the trie. */\\n    TrieNode *buildTrie(vector<string> &words) {\\n        TrieNode *root = new TrieNode();\\n        for (int j = 0; j < words.size(); j++) {\\n            string word = words[j];\\n            TrieNode *curr = root;\\n            for (int i = 0; i < word.length(); i++) {\\n                char c = word[i] - \\'a\\';\\n                if (curr->children[c] == nullptr) {\\n                    curr->children[c] = new TrieNode();\\n                }\\n                curr = curr->children[c];\\n            }\\n            curr->word = word;\\n        }\\n        return root;\\n    }\\n\\n    void dfs(vector<vector<char>> &board, int i, int j, TrieNode *p, vector<string> &result) {\\n        char c = board[i][j];\\n        if (c == \\'#\\' || !p->children[c - \\'a\\']) return;\\n        p = p->children[c - \\'a\\'];\\n        if (p->word.size() > 0) {\\n            result.push_back(p->word);\\n            p->word = \"\";\\n        }\\n\\n        board[i][j] = \\'#\\';\\n        if (i > 0) dfs(board, i - 1, j, p, result);\\n        if (j > 0) dfs(board, i, j - 1, p, result);\\n        if (i < board.size() - 1) dfs(board, i + 1, j, p, result);\\n        if (j < board[0].size() - 1) dfs(board, i, j + 1, p, result);\\n        board[i][j] = c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678311,
                "title": "java-optimized-solution-with-easy-steps-and-tc-analysis",
                "content": "**UPVOTE if you found it helpful**\\n```\\n1 -> Create Trie with words\\n            2 -> iterate through the board \\n                -> run dfs (backtracking) for every pos pasing the root of the Trie\\n                    3 -> check if the current char is in the Trie and mark it as visited\\n                            -> if the current char forms a Word from the Trie\\n                                -> add it to ans list\\n                                -> remove the word from the Trie (duplicate, word apper in board > 1)\\n                            -> backtrack in all 4 directions\\n                                -> mark it as unvisted (remove it from visited)\\n\\n            4 -> return the list with the answers.\\n```\\n```\\nclass Solution {\\n    \\n    class TrieNode{\\n        HashMap<Character, TrieNode> chain;\\n        boolean isWord;\\n        String word;\\n        \\n        public TrieNode(){\\n            this.chain = new HashMap<>();\\n            isWord = false;\\n            word = \"\";\\n        }\\n        public boolean contains(char c){\\n            return this.chain.containsKey(c);\\n        }\\n        public void put(char c, TrieNode n){\\n            this.chain.put(c, n);\\n            n.word = this.word + c;\\n        }\\n        public TrieNode get(char c){\\n            return this.chain.get(c);\\n        }\\n        public void setWord(boolean b){\\n            this.isWord = b;\\n            \\n        }\\n        public boolean isWord(){\\n            return this.isWord;\\n        }\\n        public String getWord(){\\n            return this.word.toString();\\n        }\\n    }\\n    \\n    private TrieNode addWords(String [] words){\\n        TrieNode root = new TrieNode();\\n        \\n        for(String word : words){\\n            TrieNode curr = root;\\n            for(char c : word.toCharArray()){\\n                if(!curr.contains(c)){\\n                    curr.put(c, new TrieNode());\\n                }\\n                curr = curr.get(c);\\n            }\\n            curr.setWord(true);\\n        }\\n        \\n        return root;\\n    }\\n    \\n    //[OPTIMIZED] TC = O(m * n * dfs( min(4^word, m * n )) <- m = board.length, n = board[0].length, word = longest(length of word in words)\\n    // SC = min(word, m*n)\\n    public List<String> findWords(char[][] board, String[] words) {\\n       \\n        \\n        /*\\n            1 -> Create Trie with words\\n            2 -> iterate through the board \\n                -> run dfs (backtracking) for every pos pasing the root of the Trie\\n                    3 -> check if the current char is in the Trie and mark it as visited\\n                            -> if the current char forms a Word from the Trie\\n                                -> add it to ans list\\n                                -> remove the word from the Trie (duplicate, word apper in board > 1)\\n                            -> backtrack in all 4 directions\\n                                -> mark it as unvisted (remove it from visited)\\n\\n            4 -> return the list with the anwsers.\\n        */\\n        \\n        List<String> ans = new ArrayList<>();\\n        TrieNode root = addWords(words);\\n        \\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[0].length; j++){\\n                backtrack(board, root, i, j, ans);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private void backtrack(char[][]board, TrieNode node, int i, int j, List<String>ans){\\n\\n        if(i < 0 || j < 0 || i >= board.length || j >= board[0].length ||\\n           !node.contains(board[i][j]) || board[i][j] == \\'#\\'){\\n            return;\\n        }\\n        \\n        char c  = board[i][j];\\n        \\n        node = node.get(c);\\n        \\n        if(node.isWord()){\\n            ans.add(node.getWord());\\n            node.setWord(false);\\n        }\\n\\n        board[i][j] = \\'#\\'; // visited;\\n        \\n        backtrack(board, node, i+1, j, ans);\\n        backtrack(board, node, i-1, j, ans);\\n        backtrack(board, node, i, j+1, ans);\\n        backtrack(board, node, i, j-1, ans);\\n\\n        board[i][j] = c; // removed from visited        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\n1 -> Create Trie with words\\n            2 -> iterate through the board \\n                -> run dfs (backtracking) for every pos pasing the root of the Trie\\n                    3 -> check if the current char is in the Trie and mark it as visited\\n                            -> if the current char forms a Word from the Trie\\n                                -> add it to ans list\\n                                -> remove the word from the Trie (duplicate, word apper in board > 1)\\n                            -> backtrack in all 4 directions\\n                                -> mark it as unvisted (remove it from visited)\\n\\n            4 -> return the list with the answers.\\n```\n```\\nclass Solution {\\n    \\n    class TrieNode{\\n        HashMap<Character, TrieNode> chain;\\n        boolean isWord;\\n        String word;\\n        \\n        public TrieNode(){\\n            this.chain = new HashMap<>();\\n            isWord = false;\\n            word = \"\";\\n        }\\n        public boolean contains(char c){\\n            return this.chain.containsKey(c);\\n        }\\n        public void put(char c, TrieNode n){\\n            this.chain.put(c, n);\\n            n.word = this.word + c;\\n        }\\n        public TrieNode get(char c){\\n            return this.chain.get(c);\\n        }\\n        public void setWord(boolean b){\\n            this.isWord = b;\\n            \\n        }\\n        public boolean isWord(){\\n            return this.isWord;\\n        }\\n        public String getWord(){\\n            return this.word.toString();\\n        }\\n    }\\n    \\n    private TrieNode addWords(String [] words){\\n        TrieNode root = new TrieNode();\\n        \\n        for(String word : words){\\n            TrieNode curr = root;\\n            for(char c : word.toCharArray()){\\n                if(!curr.contains(c)){\\n                    curr.put(c, new TrieNode());\\n                }\\n                curr = curr.get(c);\\n            }\\n            curr.setWord(true);\\n        }\\n        \\n        return root;\\n    }\\n    \\n    //[OPTIMIZED] TC = O(m * n * dfs( min(4^word, m * n )) <- m = board.length, n = board[0].length, word = longest(length of word in words)\\n    // SC = min(word, m*n)\\n    public List<String> findWords(char[][] board, String[] words) {\\n       \\n        \\n        /*\\n            1 -> Create Trie with words\\n            2 -> iterate through the board \\n                -> run dfs (backtracking) for every pos pasing the root of the Trie\\n                    3 -> check if the current char is in the Trie and mark it as visited\\n                            -> if the current char forms a Word from the Trie\\n                                -> add it to ans list\\n                                -> remove the word from the Trie (duplicate, word apper in board > 1)\\n                            -> backtrack in all 4 directions\\n                                -> mark it as unvisted (remove it from visited)\\n\\n            4 -> return the list with the anwsers.\\n        */\\n        \\n        List<String> ans = new ArrayList<>();\\n        TrieNode root = addWords(words);\\n        \\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[0].length; j++){\\n                backtrack(board, root, i, j, ans);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private void backtrack(char[][]board, TrieNode node, int i, int j, List<String>ans){\\n\\n        if(i < 0 || j < 0 || i >= board.length || j >= board[0].length ||\\n           !node.contains(board[i][j]) || board[i][j] == \\'#\\'){\\n            return;\\n        }\\n        \\n        char c  = board[i][j];\\n        \\n        node = node.get(c);\\n        \\n        if(node.isWord()){\\n            ans.add(node.getWord());\\n            node.setWord(false);\\n        }\\n\\n        board[i][j] = \\'#\\'; // visited;\\n        \\n        backtrack(board, node, i+1, j, ans);\\n        backtrack(board, node, i-1, j, ans);\\n        backtrack(board, node, i, j+1, ans);\\n        backtrack(board, node, i, j-1, ans);\\n\\n        board[i][j] = c; // removed from visited        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2375535,
                "title": "python-dfs-trie-exhaustion",
                "content": "Idea 1: The idea is to trim the trie branches once all the words in the branch are found.\\nIdea 2: sort the words in reverse order to help trie trimming faster\\n\\n```\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        solution = set()\\n        trie = self.make_trie(words)\\n        visited = set()\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                self.dfs(i,j,board,trie,visited,\"\",solution)\\n        return solution\\n    \\n    def dfs(self,i,j,board,trie,visited,word,solution):\\n        if \"*\" in trie:\\n            if len(trie.keys()) == 0:\\n                return\\n            else:\\n                solution.add(word)\\n                del trie[\"*\"]\\n        if (i,j) in visited:\\n            return\\n        if (i < 0 or i == len(board) or j < 0 or j == len(board[0])):\\n            return\\n        if board[i][j] not in trie:\\n            return\\n        if len(trie[board[i][j]]) == 0:\\n            del trie[board[i][j]]\\n            return\\n        visited.add((i,j))\\n        neighbours = [(i,j-1),(i-1,j),(i,j+1),(i+1,j)]\\n        for n_x,n_y in neighbours:\\n            self.dfs(n_x,n_y,board,trie[board[i][j]],visited,word+board[i][j],solution)    \\n        visited.remove((i,j))\\n        \\n    def make_trie(self,words):\\n        trie = {}\\n        for word in words:\\n            current = trie\\n            for char in word:\\n                if char not in current:\\n                    current[char] = {}\\n                current = current[char]\\n            current[\"*\"] = \"*\"\\n        return trie\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        solution = set()\\n        trie = self.make_trie(words)\\n        visited = set()\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                self.dfs(i,j,board,trie,visited,\"\",solution)\\n        return solution\\n    \\n    def dfs(self,i,j,board,trie,visited,word,solution):\\n        if \"*\" in trie:\\n            if len(trie.keys()) == 0:\\n                return\\n            else:\\n                solution.add(word)\\n                del trie[\"*\"]\\n        if (i,j) in visited:\\n            return\\n        if (i < 0 or i == len(board) or j < 0 or j == len(board[0])):\\n            return\\n        if board[i][j] not in trie:\\n            return\\n        if len(trie[board[i][j]]) == 0:\\n            del trie[board[i][j]]\\n            return\\n        visited.add((i,j))\\n        neighbours = [(i,j-1),(i-1,j),(i,j+1),(i+1,j)]\\n        for n_x,n_y in neighbours:\\n            self.dfs(n_x,n_y,board,trie[board[i][j]],visited,word+board[i][j],solution)    \\n        visited.remove((i,j))\\n        \\n    def make_trie(self,words):\\n        trie = {}\\n        for word in words:\\n            current = trie\\n            for char in word:\\n                if char not in current:\\n                    current[char] = {}\\n                current = current[char]\\n            current[\"*\"] = \"*\"\\n        return trie\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2370977,
                "title": "c-trie-dfs-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> result;\\n    \\n    struct Trie {\\n        Trie *child[26];\\n        bool isEndOfWord;\\n        string str;\\n        \\n        Trie(){\\n            isEndOfWord = false;\\n            str = \"\";\\n            for(int i=0; i<26; i++)\\n                child[i] = NULL;\\n        }\\n    };\\n    \\n    Trie *root = new Trie();\\n    \\n    void insert(string &word) {\\n        \\n        Trie *curr = root;\\n        \\n        for(int i=0; i<word.size(); i++) {\\n            int index = word[i]-\\'a\\';\\n            \\n            if(!curr->child[index])\\n                curr->child[index] = new Trie();\\n            \\n            curr = curr->child[index];\\n        }\\n        \\n        curr->isEndOfWord = true;\\n        curr->str = word;\\n    }\\n    \\n    void trieSearchDFS(vector<vector<char>>& board, Trie *curr, int i, int j, int row, int col) {\\n        \\n        if(i<0 || i>row || j<0 || j>col || board[i][j] == \\'@\\')\\n            return;\\n        \\n        //int index = board[i][j]-\\'a\\';\\n        curr = curr->child[board[i][j]-\\'a\\'];\\n        \\n        if(curr == NULL)\\n            return;\\n        \\n        if(curr->isEndOfWord){\\n            result.push_back(curr->str);\\n            curr->isEndOfWord = false;\\n        }\\n        \\n        char ch = board[i][j];\\n        board[i][j] = \\'@\\';\\n        \\n        if(i-1>=0)\\n            trieSearchDFS(board,curr,i-1,j,row,col);\\n        if(j+1<col)\\n            trieSearchDFS(board,curr,i,j+1,row,col);\\n        if(i+1<row)\\n            trieSearchDFS(board,curr,i+1,j,row,col);\\n        if(j-1>=0)\\n            trieSearchDFS(board,curr,i,j-1,row,col);\\n        \\n        board[i][j] = ch;\\n        \\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        int row = board.size();\\n        int col = board[0].size();\\n        \\n        for(int i=0; i<words.size(); i++)\\n            insert(words[i]);\\n        \\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                trieSearchDFS(board,root,i,j,row,col);\\n            }\\n        }\\n       return result; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> result;\\n    \\n    struct Trie {\\n        Trie *child[26];\\n        bool isEndOfWord;\\n        string str;\\n        \\n        Trie(){\\n            isEndOfWord = false;\\n            str = \"\";\\n            for(int i=0; i<26; i++)\\n                child[i] = NULL;\\n        }\\n    };\\n    \\n    Trie *root = new Trie();\\n    \\n    void insert(string &word) {\\n        \\n        Trie *curr = root;\\n        \\n        for(int i=0; i<word.size(); i++) {\\n            int index = word[i]-\\'a\\';\\n            \\n            if(!curr->child[index])\\n                curr->child[index] = new Trie();\\n            \\n            curr = curr->child[index];\\n        }\\n        \\n        curr->isEndOfWord = true;\\n        curr->str = word;\\n    }\\n    \\n    void trieSearchDFS(vector<vector<char>>& board, Trie *curr, int i, int j, int row, int col) {\\n        \\n        if(i<0 || i>row || j<0 || j>col || board[i][j] == \\'@\\')\\n            return;\\n        \\n        //int index = board[i][j]-\\'a\\';\\n        curr = curr->child[board[i][j]-\\'a\\'];\\n        \\n        if(curr == NULL)\\n            return;\\n        \\n        if(curr->isEndOfWord){\\n            result.push_back(curr->str);\\n            curr->isEndOfWord = false;\\n        }\\n        \\n        char ch = board[i][j];\\n        board[i][j] = \\'@\\';\\n        \\n        if(i-1>=0)\\n            trieSearchDFS(board,curr,i-1,j,row,col);\\n        if(j+1<col)\\n            trieSearchDFS(board,curr,i,j+1,row,col);\\n        if(i+1<row)\\n            trieSearchDFS(board,curr,i+1,j,row,col);\\n        if(j-1>=0)\\n            trieSearchDFS(board,curr,i,j-1,row,col);\\n        \\n        board[i][j] = ch;\\n        \\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        int row = board.size();\\n        int col = board[0].size();\\n        \\n        for(int i=0; i<words.size(); i++)\\n            insert(words[i]);\\n        \\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                trieSearchDFS(board,root,i,j,row,col);\\n            }\\n        }\\n       return result; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2351408,
                "title": "python3-solution-99-more-faster-39-ms",
                "content": "![image](https://assets.leetcode.com/users/images/2c44c6a0-dbce-459d-a577-ef38d01bdcde_1659111005.250889.png)\\n```\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        m = len(board)\\n        n = len(board[0])\\n        res = []\\n\\n        d = [[0, 1], [0, -1], [1, 0], [-1, 0]]\\n\\n        ref = set()\\n        for i in range(m):\\n            for j in range(n-1):\\n                ref.add(board[i][j] + board[i][j+1])\\n        for j in range(n):\\n            for i in range(m-1):\\n                ref.add(board[i][j] + board[i+1][j])\\n\\n        for word in words:\\n            f = True\\n            for i in range(len(word)-1):\\n                if word[i:i+2] not in ref and word[i+1] + word[i] not in ref:\\n                    f = False\\n                    break\\n            if not f:\\n                continue\\n            if self.findWord(word, m, n, board, d):\\n                res.append(word)\\n        return res\\n    \\n    def findWord(self, word, m, n, board, d) -> bool:\\n        if word[:4] == word[0] * 4:\\n            word = \\'\\'.join([c for c in reversed(word)])\\n        starts = []\\n        stack = []\\n        visited = set()\\n        for i in range(m):\\n            for j in range(n):\\n                if board[i][j] == word[0]:\\n                    if len(word) == 1:\\n                        return True\\n                    starts.append((i, j))\\n        for start in starts:\\n            stack.append(start)\\n            visited.add((start, ))\\n            l = 1\\n            while stack != [] and l < len(word):\\n                x, y = stack[-1]\\n                for dxy in d:\\n                    nx, ny = x + dxy[0], y + dxy[1]\\n                    if 0 <= nx < m and 0 <= ny < n:\\n                        if board[nx][ny] == word[l]:\\n                            if (nx, ny) not in stack and tuple(stack) + ((nx, ny),) not in visited:\\n                                stack.append((nx, ny))\\n                                visited.add(tuple(stack))\\n                                l += 1\\n                                if l == len(word):\\n                                    return True\\n                                break\\n                else:\\n                    stack.pop()\\n                    l -= 1\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        m = len(board)\\n        n = len(board[0])\\n        res = []\\n\\n        d = [[0, 1], [0, -1], [1, 0], [-1, 0]]\\n\\n        ref = set()\\n        for i in range(m):\\n            for j in range(n-1):\\n                ref.add(board[i][j] + board[i][j+1])\\n        for j in range(n):\\n            for i in range(m-1):\\n                ref.add(board[i][j] + board[i+1][j])\\n\\n        for word in words:\\n            f = True\\n            for i in range(len(word)-1):\\n                if word[i:i+2] not in ref and word[i+1] + word[i] not in ref:\\n                    f = False\\n                    break\\n            if not f:\\n                continue\\n            if self.findWord(word, m, n, board, d):\\n                res.append(word)\\n        return res\\n    \\n    def findWord(self, word, m, n, board, d) -> bool:\\n        if word[:4] == word[0] * 4:\\n            word = \\'\\'.join([c for c in reversed(word)])\\n        starts = []\\n        stack = []\\n        visited = set()\\n        for i in range(m):\\n            for j in range(n):\\n                if board[i][j] == word[0]:\\n                    if len(word) == 1:\\n                        return True\\n                    starts.append((i, j))\\n        for start in starts:\\n            stack.append(start)\\n            visited.add((start, ))\\n            l = 1\\n            while stack != [] and l < len(word):\\n                x, y = stack[-1]\\n                for dxy in d:\\n                    nx, ny = x + dxy[0], y + dxy[1]\\n                    if 0 <= nx < m and 0 <= ny < n:\\n                        if board[nx][ny] == word[l]:\\n                            if (nx, ny) not in stack and tuple(stack) + ((nx, ny),) not in visited:\\n                                stack.append((nx, ny))\\n                                visited.add(tuple(stack))\\n                                l += 1\\n                                if l == len(word):\\n                                    return True\\n                                break\\n                else:\\n                    stack.pop()\\n                    l -= 1\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2041937,
                "title": "python-dfs-trie-99-with-trie-optimization",
                "content": "this solution is like the top [solution](https://leetcode.com/problems/word-search-ii/discuss/59790/Python-dfs-solution-(directly-use-Trie-implemented).) from OldCodingFarmer with an extra trick (TLE - 10% -> 80% - 100%).\\n\\nThe idea is to count the number of words with a specific prefix in the Trie.\\nThen at remove time, we traverse the Trie and delete a node if it has a count of 1 (the path contains only the word we want to remove).\\n\\nThis makes the DFS run way faster (since it will know earlier if a path doesn\\'t contain any word).\\n\\ncomment out the line `root.remove(s)` to see the effect of this optimization.\\n\\ncode:\\n\\n```\\nclass Trie(collections.defaultdict):\\n    def __init__(self):\\n        super().__init__(lambda: Trie())\\n        self._is_word = False\\n        self._count = 0\\n    \\n    def add(self, word):\\n        runner = self\\n        runner._count += 1\\n        for c in word:\\n            runner = runner[c]\\n            runner._count += 1\\n        runner._is_word = True\\n        \\n    def remove(self, word):\\n        runner = self\\n        runner._count -= 1\\n        for c in word:\\n            if runner[c]._count == 1:\\n                del runner[c]\\n                return\\n            runner = runner[c]\\n            runner._count -= 1\\n        runner._is_word = False\\n        \\n    def contains(self, word):\\n        runner = self\\n        for c in word:\\n            if runner._count == 0 or c not in runner:\\n                return False\\n            runner = runner[c]\\n        return runner._is_word\\n    \\n\\n\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        n, m = len(board), len(board[0])\\n        root = Trie()\\n        for word in words:\\n            root.add(word)\\n            \\n        def dfs(i, j, trie, s):\\n            s.append(board[i][j])\\n            trie = trie[board[i][j]]\\n            if trie._is_word:\\n                root.remove(s)\\n                trie._is_word = False\\n                res.append(\"\".join(s))\\n\\n            board[i][j] = \\'#\\'\\n            for di, dj in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\\n                ni, nj = i+di, j+dj\\n                if 0 <= ni < n and 0 <= nj < m and board[ni][nj] in trie:\\n                    dfs(ni, nj, trie, s)\\n            board[i][j] = s.pop()\\n                \\n        res = []    \\n        for i in range(n):\\n            for j in range(m):\\n                if board[i][j] in root:\\n                    dfs(i, j, root, [])\\n                 \\n        return res           \\n ```\\n",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Trie(collections.defaultdict):\\n    def __init__(self):\\n        super().__init__(lambda: Trie())\\n        self._is_word = False\\n        self._count = 0\\n    \\n    def add(self, word):\\n        runner = self\\n        runner._count += 1\\n        for c in word:\\n            runner = runner[c]\\n            runner._count += 1\\n        runner._is_word = True\\n        \\n    def remove(self, word):\\n        runner = self\\n        runner._count -= 1\\n        for c in word:\\n            if runner[c]._count == 1:\\n                del runner[c]\\n                return\\n            runner = runner[c]\\n            runner._count -= 1\\n        runner._is_word = False\\n        \\n    def contains(self, word):\\n        runner = self\\n        for c in word:\\n            if runner._count == 0 or c not in runner:\\n                return False\\n            runner = runner[c]\\n        return runner._is_word\\n    \\n\\n\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        n, m = len(board), len(board[0])\\n        root = Trie()\\n        for word in words:\\n            root.add(word)\\n            \\n        def dfs(i, j, trie, s):\\n            s.append(board[i][j])\\n            trie = trie[board[i][j]]\\n            if trie._is_word:\\n                root.remove(s)\\n                trie._is_word = False\\n                res.append(\"\".join(s))\\n\\n            board[i][j] = \\'#\\'\\n            for di, dj in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\\n                ni, nj = i+di, j+dj\\n                if 0 <= ni < n and 0 <= nj < m and board[ni][nj] in trie:\\n                    dfs(ni, nj, trie, s)\\n            board[i][j] = s.pop()\\n                \\n        res = []    \\n        for i in range(n):\\n            for j in range(m):\\n                if board[i][j] in root:\\n                    dfs(i, j, root, [])\\n                 \\n        return res           \\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2011717,
                "title": "c-simple-solution-using-trie-dfs",
                "content": "**[C++] Simple solution for searching words on board using DFS & Trie:**\\n\\n```\\nclass TrieNode {\\npublic:\\n    TrieNode* children[26] = {};\\n    bool isEnd = false;\\n    \\n    TrieNode() {}\\n    \\n    void addWord(string word) {\\n        TrieNode* curr = this;\\n        for(auto c: word) {\\n            if (!curr->children[c-\\'a\\']) curr->children[c-\\'a\\'] = new TrieNode();\\n            curr = curr->children[c-\\'a\\'];\\n        }\\n        curr->isEnd = true;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        TrieNode* dictionary = new TrieNode();\\n        for (string word: words) {\\n            dictionary->addWord(word);\\n        }\\n        \\n        int m = board.size(), n = board[0].size();\\n        vector<string> result;\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                searchRecursively(board, i, j, dictionary, \"\", result);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    void searchRecursively(vector<vector<char>>& board, int x, int y, TrieNode* dict, string s, vector<string>& result) {\\n        int m = board.size(), n = board[0].size();\\n        if (board[x][y]==\\'#\\' || !dict->children[board[x][y]-\\'a\\']) return;\\n        \\n        char temp = board[x][y];\\n        board[x][y] = \\'#\\';\\n        \\n        if (dict->children[temp-\\'a\\']->isEnd) {\\n            dict->children[temp-\\'a\\']->isEnd = false;\\n            result.push_back(s+temp);\\n        }\\n        \\n        if(x-1>=0) searchRecursively(board, x-1, y, dict->children[temp-\\'a\\'], s+temp, result);\\n        if(x+1<m) searchRecursively(board, x+1, y, dict->children[temp-\\'a\\'], s+temp, result);\\n        if(y-1>=0) searchRecursively(board, x, y-1, dict->children[temp-\\'a\\'], s+temp, result);\\n        if(y+1<n) searchRecursively(board, x, y+1, dict->children[temp-\\'a\\'], s+temp, result);\\n        \\n        board[x][y] = temp;\\n    }\\n};\\n```\\n\\nPlease do **upvote** if you find this helpful.\\nFeel free to ask queries or share feedback in comments.",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode {\\npublic:\\n    TrieNode* children[26] = {};\\n    bool isEnd = false;\\n    \\n    TrieNode() {}\\n    \\n    void addWord(string word) {\\n        TrieNode* curr = this;\\n        for(auto c: word) {\\n            if (!curr->children[c-\\'a\\']) curr->children[c-\\'a\\'] = new TrieNode();\\n            curr = curr->children[c-\\'a\\'];\\n        }\\n        curr->isEnd = true;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        TrieNode* dictionary = new TrieNode();\\n        for (string word: words) {\\n            dictionary->addWord(word);\\n        }\\n        \\n        int m = board.size(), n = board[0].size();\\n        vector<string> result;\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                searchRecursively(board, i, j, dictionary, \"\", result);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    void searchRecursively(vector<vector<char>>& board, int x, int y, TrieNode* dict, string s, vector<string>& result) {\\n        int m = board.size(), n = board[0].size();\\n        if (board[x][y]==\\'#\\' || !dict->children[board[x][y]-\\'a\\']) return;\\n        \\n        char temp = board[x][y];\\n        board[x][y] = \\'#\\';\\n        \\n        if (dict->children[temp-\\'a\\']->isEnd) {\\n            dict->children[temp-\\'a\\']->isEnd = false;\\n            result.push_back(s+temp);\\n        }\\n        \\n        if(x-1>=0) searchRecursively(board, x-1, y, dict->children[temp-\\'a\\'], s+temp, result);\\n        if(x+1<m) searchRecursively(board, x+1, y, dict->children[temp-\\'a\\'], s+temp, result);\\n        if(y-1>=0) searchRecursively(board, x, y-1, dict->children[temp-\\'a\\'], s+temp, result);\\n        if(y+1<n) searchRecursively(board, x, y+1, dict->children[temp-\\'a\\'], s+temp, result);\\n        \\n        board[x][y] = temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1862785,
                "title": "python-trie-dfs-solution",
                "content": "I used separate TrieNode to define the node and addword method in Trie.\\nInsert all words into Trie using addword method. \\nThen DFS. Check at each cell if its in  children of trie node by travesering through borad in all 4 directions.\\n\\n\\n\\t\\n\\tclass TrieNode:\\n\\t\\tdef __init__(self):\\n\\t\\t\\tself.children={}\\n\\t\\t\\tself.endOfWord=False\\n\\n\\t\\tdef insert(self,word):\\n\\t\\t\\troot = self\\n\\t\\t\\tfor c in word:\\n\\t\\t\\t\\tif c not in root.children:\\n\\t\\t\\t\\t\\troot.children[c]=TrieNode()\\n\\t\\t\\t\\troot=root.children[c]\\n\\t\\t\\troot.endOfWord = True\\n\\n\\tclass Solution:    \\n\\t\\tdef findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n\\t\\t\\troot = TrieNode()\\n\\t\\t\\tfor word in words:\\n\\t\\t\\t\\troot.insert(word)\\n\\n\\t\\t\\tresult,visit=set(),set()\\n\\t\\t\\tROWS,COLS=len(board),len(board[0])\\n\\n\\t\\t\\tdef dfs(row,col,node,word):\\n\\t\\t\\t\\tif row<0 or col<0  or row==ROWS  or col==COLS or (row,col) in visit or board[row][col] not in node.children:\\n\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\tnode = node.children[board[row][col]] #update node to current character we just visited\\n\\t\\t\\t\\tword += board[row][col] # we are adding the new character we just visited to the existing word\\n\\t\\t\\t\\tflag=True\\n\\t\\t\\t\\tif node.endOfWord:  #is it end of word\\n\\t\\t\\t\\t\\tresult.add(word) #add the word we built in the result\\n\\t\\t\\t\\t\\tif len(node.children)==0:\\n\\t\\t\\t\\t\\t\\tdel node\\n\\t\\t\\t\\t\\t\\tflag=False\\n\\t\\t\\t\\tif flag:\\n\\t\\t\\t\\t\\tvisit.add((row,col))\\n\\n\\t\\t\\t\\t\\t  # Traverse the words in 4 direction\\n\\t\\t\\t\\t\\tdfs(row+1,col,node,word)\\n\\t\\t\\t\\t\\tdfs(row-1,col,node,word)\\n\\t\\t\\t\\t\\tdfs(row,col+1,node,word)\\n\\t\\t\\t\\t\\tdfs(row,col-1,node,word)\\n\\t\\t\\t\\t\\tvisit.remove((row,col))\\n\\n\\t\\t\\tfor row in range(ROWS):\\n\\t\\t\\t\\tfor col in range(COLS):\\n\\t\\t\\t\\t\\tdfs(row,col,root,\"\") #call froom each starting position and word is gonna be empty\\n\\n\\t\\t\\treturn list(result) #cast to list as result is a set\\n",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "I used separate TrieNode to define the node and addword method in Trie.\\nInsert all words into Trie using addword method. \\nThen DFS. Check at each cell if its in  children of trie node by travesering through borad in all 4 directions.\\n\\n\\n\\t\\n\\tclass TrieNode:\\n\\t\\tdef __init__(self):\\n\\t\\t\\tself.children={}\\n\\t\\t\\tself.endOfWord=False\\n\\n\\t\\tdef insert(self,word):\\n\\t\\t\\troot = self\\n\\t\\t\\tfor c in word:\\n\\t\\t\\t\\tif c not in root.children:\\n\\t\\t\\t\\t\\troot.children[c]=TrieNode()\\n\\t\\t\\t\\troot=root.children[c]\\n\\t\\t\\troot.endOfWord = True\\n\\n\\tclass Solution:    \\n\\t\\tdef findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n\\t\\t\\troot = TrieNode()\\n\\t\\t\\tfor word in words:\\n\\t\\t\\t\\troot.insert(word)\\n\\n\\t\\t\\tresult,visit=set(),set()\\n\\t\\t\\tROWS,COLS=len(board),len(board[0])\\n\\n\\t\\t\\tdef dfs(row,col,node,word):\\n\\t\\t\\t\\tif row<0 or col<0  or row==ROWS  or col==COLS or (row,col) in visit or board[row][col] not in node.children:\\n\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\tnode = node.children[board[row][col]] #update node to current character we just visited\\n\\t\\t\\t\\tword += board[row][col] # we are adding the new character we just visited to the existing word\\n\\t\\t\\t\\tflag=True\\n\\t\\t\\t\\tif node.endOfWord:  #is it end of word\\n\\t\\t\\t\\t\\tresult.add(word) #add the word we built in the result\\n\\t\\t\\t\\t\\tif len(node.children)==0:\\n\\t\\t\\t\\t\\t\\tdel node\\n\\t\\t\\t\\t\\t\\tflag=False\\n\\t\\t\\t\\tif flag:\\n\\t\\t\\t\\t\\tvisit.add((row,col))\\n\\n\\t\\t\\t\\t\\t  # Traverse the words in 4 direction\\n\\t\\t\\t\\t\\tdfs(row+1,col,node,word)\\n\\t\\t\\t\\t\\tdfs(row-1,col,node,word)\\n\\t\\t\\t\\t\\tdfs(row,col+1,node,word)\\n\\t\\t\\t\\t\\tdfs(row,col-1,node,word)\\n\\t\\t\\t\\t\\tvisit.remove((row,col))\\n\\n\\t\\t\\tfor row in range(ROWS):\\n\\t\\t\\t\\tfor col in range(COLS):\\n\\t\\t\\t\\t\\tdfs(row,col,root,\"\") #call froom each starting position and word is gonna be empty\\n\\n\\t\\t\\treturn list(result) #cast to list as result is a set\\n",
                "codeTag": "Java"
            },
            {
                "id": 1771671,
                "title": "js-beats-100",
                "content": "Using two simple optimizations: \\n- We delete words from the Trie once they have been found.\\n\\t- This means that we will no longer search fruitlessly for them.\\n\\t- This also means that we do not need to use a Set but can instead simply append to an Array.\\n- We keep track of what the complete word looks like for each potential completion spot, so that we do not need to reconstruct it\\n\\n```\\nclass Trie {\\n    constructor(words) {\\n        this.data = {};\\n        for(let word of words) {\\n            let current = this.data;\\n            for(let c of word) {\\n                if(!current[c]) current[c] = {count:0};\\n                current = current[c];\\n                // Keep track of how many words are under each node for easy deletion\\n                current.count++;\\n            }\\n            current.complete = word;        \\n        }\\n    }\\n    \\n    remove(word)  {\\n        let current = this.data;\\n        for(let c of word) {\\n            // This method is reliant on Trie keeping a count of how many words are under each node\\n            if(current[c].count === 1) {\\n                // We don\\'t return here because we need to propagate the deletion down the entire chain\\n                let tmp = current;\\n                current = current[c];\\n                tmp[c] = null;\\n            } else {\\n                current[c].count--;\\n                current = current[c];                \\n            }\\n        }\\n        current.complete = null;\\n    }\\n}\\n\\nconst DIRECTIONS = [[0,1],[0,-1],[1,0],[-1,0]];\\n\\n/**\\n * @param {character[][]} board\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nconst findWords = (board, words) => {\\n    // build Trie\\n    const trie = new Trie(words);\\n    // Need to track visited locations\\n    const visited = Array.from({length: board.length}, \\n                               () => Array.from({length: board[0].length}, () => false));   \\n    // Result array\\n    const result = [];\\n\\n    const dfs = (i, j, trieNode) => {\\n        // Stop here if we have already traversed this location\\n        if(visited[i][j]) return 0;\\n        const c = board[i][j];\\n        // Stop here if we can\\'t continue down the Trie using this letter\\n        if(!trieNode[c]) return 0;\\n        const nextTrie = trieNode[c];\\n        \\n        if(nextTrie.complete) {\\n            result.push(nextTrie.complete);\\n            trie.remove(nextTrie.complete);\\n        }\\n        \\n        // Backtracking recursion in all 4 directions\\n        visited[i][j] = true;\\n        for(let direction of DIRECTIONS) {\\n            const nextI = i + direction[0];\\n            const nextJ = j + direction[1];\\n            if(nextI > -1 && nextI < board.length && \\n               nextJ > -1 && nextJ < board[0].length) {\\n                dfs(nextI, nextJ, nextTrie);\\n            }\\n        }\\n        visited[i][j] = false;\\n    }\\n\\n    // DFS starting at each board position\\n    for(let i = 0; i < board.length; i++) {\\n        for(let j = 0; j < board[0].length; j++) {\\n            dfs(i,j,trie.data);\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\nclass Trie {\\n    constructor(words) {\\n        this.data = {};\\n        for(let word of words) {\\n            let current = this.data;\\n            for(let c of word) {\\n                if(!current[c]) current[c] = {count:0};\\n                current = current[c];\\n                // Keep track of how many words are under each node for easy deletion\\n                current.count++;\\n            }\\n            current.complete = word;        \\n        }\\n    }\\n    \\n    remove(word)  {\\n        let current = this.data;\\n        for(let c of word) {\\n            // This method is reliant on Trie keeping a count of how many words are under each node\\n            if(current[c].count === 1) {\\n                // We don\\'t return here because we need to propagate the deletion down the entire chain\\n                let tmp = current;\\n                current = current[c];\\n                tmp[c] = null;\\n            } else {\\n                current[c].count--;\\n                current = current[c];                \\n            }\\n        }\\n        current.complete = null;\\n    }\\n}\\n\\nconst DIRECTIONS = [[0,1],[0,-1],[1,0],[-1,0]];\\n\\n/**\\n * @param {character[][]} board\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nconst findWords = (board, words) => {\\n    // build Trie\\n    const trie = new Trie(words);\\n    // Need to track visited locations\\n    const visited = Array.from({length: board.length}, \\n                               () => Array.from({length: board[0].length}, () => false));   \\n    // Result array\\n    const result = [];\\n\\n    const dfs = (i, j, trieNode) => {\\n        // Stop here if we have already traversed this location\\n        if(visited[i][j]) return 0;\\n        const c = board[i][j];\\n        // Stop here if we can\\'t continue down the Trie using this letter\\n        if(!trieNode[c]) return 0;\\n        const nextTrie = trieNode[c];\\n        \\n        if(nextTrie.complete) {\\n            result.push(nextTrie.complete);\\n            trie.remove(nextTrie.complete);\\n        }\\n        \\n        // Backtracking recursion in all 4 directions\\n        visited[i][j] = true;\\n        for(let direction of DIRECTIONS) {\\n            const nextI = i + direction[0];\\n            const nextJ = j + direction[1];\\n            if(nextI > -1 && nextI < board.length && \\n               nextJ > -1 && nextJ < board[0].length) {\\n                dfs(nextI, nextJ, nextTrie);\\n            }\\n        }\\n        visited[i][j] = false;\\n    }\\n\\n    // DFS starting at each board position\\n    for(let i = 0; i < board.length; i++) {\\n        for(let j = 0; j < board[0].length; j++) {\\n            dfs(i,j,trie.data);\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1667325,
                "title": "python-solution-with-optimization-and-comments",
                "content": "```python\\nclass TrieNode:\\n    def __init__(self):\\n        self.child = collections.defaultdict(TrieNode)\\n        self.isEnd = False\\n        self.word = None\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def insert(self, word):\\n        node = self.root\\n        for ch in word:\\n            node = node.child[ch]\\n        node.isEnd = True\\n        node.word = word\\n    \\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        if len(board) == 0 or len(words) == 0:\\n            return []\\n        \\n        trie = Trie()\\n        for word in words:\\n            trie.insert(word)\\n        \\n        res = []\\n        m, n = len(board), len(board[0])\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if board[i][j] in trie.root.child:\\n                    self.dfs(board, trie.root, m, n, i, j, res)\\n        return res\\n    \\n    def dfs(self, board, parent, m, n, x, y, res):\\n        ch = board[x][y]\\n        node = parent.child[ch]\\n        \\n        if node.isEnd:\\n            res.append(node.word)\\n            node.isEnd = False # avoid duplicates\\n            # Don\\'t RETURN since child.word can be a prefix of other words, e.g., \\'ane\\' and \\'aneis\\'\\n        \\n        board[x][y] = \"#\"\\n        for new_x, new_y in [[x-1, y], [x+1, y], [x, y-1], [x, y+1]]:\\n            if 0 <= new_x < m and 0 <= new_y < n and board[new_x][new_y] in node.child:\\n                self.dfs(board, node, m, n, new_x, new_y, res)\\n        board[x][y] = ch\\n        \\n        # hit the end of trie leaf node, if already checking \"abcd\" in trie leaf, (whether it works or not)\\n        # we don\\'t need to spend time checking \"abcde\" word \\n        if not node.child:\\n            parent.child.pop(ch)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass TrieNode:\\n    def __init__(self):\\n        self.child = collections.defaultdict(TrieNode)\\n        self.isEnd = False\\n        self.word = None\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def insert(self, word):\\n        node = self.root\\n        for ch in word:\\n            node = node.child[ch]\\n        node.isEnd = True\\n        node.word = word\\n    \\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        if len(board) == 0 or len(words) == 0:\\n            return []\\n        \\n        trie = Trie()\\n        for word in words:\\n            trie.insert(word)\\n        \\n        res = []\\n        m, n = len(board), len(board[0])\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if board[i][j] in trie.root.child:\\n                    self.dfs(board, trie.root, m, n, i, j, res)\\n        return res\\n    \\n    def dfs(self, board, parent, m, n, x, y, res):\\n        ch = board[x][y]\\n        node = parent.child[ch]\\n        \\n        if node.isEnd:\\n            res.append(node.word)\\n            node.isEnd = False # avoid duplicates\\n            # Don\\'t RETURN since child.word can be a prefix of other words, e.g., \\'ane\\' and \\'aneis\\'\\n        \\n        board[x][y] = \"#\"\\n        for new_x, new_y in [[x-1, y], [x+1, y], [x, y-1], [x, y+1]]:\\n            if 0 <= new_x < m and 0 <= new_y < n and board[new_x][new_y] in node.child:\\n                self.dfs(board, node, m, n, new_x, new_y, res)\\n        board[x][y] = ch\\n        \\n        # hit the end of trie leaf node, if already checking \"abcd\" in trie leaf, (whether it works or not)\\n        # we don\\'t need to spend time checking \"abcde\" word \\n        if not node.child:\\n            parent.child.pop(ch)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354554,
                "title": "hack-reverse-search-python3",
                "content": "Consider this simple algorithm:\\n\\n```\\nfor i in range(rows):\\n\\tfor j in range(cols):\\n\\t    for word in words:\\n\\t\\t    search(board[i][j], word)\\n```\\n\\nSimply, we are searching every cell for every word. This algorithm will fail on the final test case. Why?\\n\\nConsider this `board[][]` with `words[]`.\\n\\n```\\n words[] = [                +---+---+---+---+---+---+---+---+---+---+---+ \\n     \"ababababzo\",          | a | b | a | b | a | b | a | b | a | b | a | \\n     \"ababababzp\",          +---+---+---+---+---+---+---+---+---+---+---+ \\n     \"ababababzq\",          | a | b | a | b | a | b | a | b | a | b | a | \\n     \"ababababzr\",          +---+---+---+---+---+---+---+---+---+---+---+ \\n     \"ababababzs\",          | a | b | a | b | a | b | a | b | a | b | a | \\n     \"ababababzt\",          +---+---+---+---+---+---+---+---+---+---+---+ \\n     \"ababababzu\",          | a | b | a | b | a | b | a | b | a | b | a | \\n     \"ababababzv\",          +---+---+---+---+---+---+---+---+---+---+---+ \\n     \"ababababzw\",          | a | b | a | b | a | b | a | b | a | b | a | \\n     \"ababababzx\",          +---+---+---+---+---+---+---+---+---+---+---+ \\n     \"ababababzy\",          | a | b | a | b | a | b | a | b | a | b | a | \\n     \"ababababzz\",          +---+---+---+---+---+---+---+---+---+---+---+ \\n ]                          | a | b | a | b | a | b | a | b | a | b | a | \\n                            +---+---+---+---+---+---+---+---+---+---+---+ \\n                            | a | b | a | b | a | b | a | b | a | b | a | \\n                            +---+---+---+---+---+---+---+---+---+---+---+ \\n                            | a | b | a | b | a | b | a | b | a | b | a | \\n                            +---+---+---+---+---+---+---+---+---+---+---+ \\n```\\n\\nThe simple approach from before will fail because the worst-case inputs, `\"ababab...\"`, were deliberately crafted to increase our search time exponentially. But wait, notice how the last few characters of each `word` in `words[]` **have** to be distinct from the `\"ababab...\"` pattern? Do you know why this has to be the case? What do you think will happen if we search each cell for `reverse(word)` instead of `word`? The full solution, along with a screenshot of its performance, are attached at the bottom.\\n\\nThe [Trie](https://en.wikipedia.org/wiki/Trie) data structure, which is part of the intended solution, is extremely powerful. It can be used to solve a great number of complex problems. For this problem, however, the sample answer overly engineered.\\n\\n```Python\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        rows = len(board)\\n        cols = len(board[0])\\n        \\n        visited = set()\\n        results = set()\\n        \\n        # Hack. Reverse the string to look for.\\n        for i in range(len(words)):\\n            words[i] = words[i][::-1]\\n        \\n        # Normal dfs.\\n        def dfs(i, j, idx, word):\\n            if word in results   : return\\n            if i < 0 or rows <= i: return\\n            if j < 0 or cols <= j: return\\n            \\n            visited.add((i, j))\\n            \\n            if board[i][j] != word[idx]:\\n                pass\\n                \\n            elif idx == len(word)-1:\\n                results.add(word)\\n            \\n            else:\\n                if (i-1, j) not in visited: dfs(i-1, j, idx+1, word)\\n                if (i+1, j) not in visited: dfs(i+1, j, idx+1, word)\\n                if (i, j-1) not in visited: dfs(i, j-1, idx+1, word)\\n                if (i, j+1) not in visited: dfs(i, j+1, idx+1, word)\\n            \\n            visited.remove((i, j))\\n        \\n        # For every cell, search every word.\\n        for i in range(rows):\\n            for j in range(cols):\\n                for word in words:\\n                    if word not in results:\\n                        dfs(i, j, 0, word)\\n            \\n        return [word[::-1] for word in results]\\n```\\n![image](https://assets.leetcode.com/users/images/f609fc9f-7332-4007-a390-6d4e551ca55f_1626943852.1561491.png)",
                "solutionTags": [],
                "code": "```\\nfor i in range(rows):\\n\\tfor j in range(cols):\\n\\t    for word in words:\\n\\t\\t    search(board[i][j], word)\\n```\n```\\n words[] = [                +---+---+---+---+---+---+---+---+---+---+---+ \\n     \"ababababzo\",          | a | b | a | b | a | b | a | b | a | b | a | \\n     \"ababababzp\",          +---+---+---+---+---+---+---+---+---+---+---+ \\n     \"ababababzq\",          | a | b | a | b | a | b | a | b | a | b | a | \\n     \"ababababzr\",          +---+---+---+---+---+---+---+---+---+---+---+ \\n     \"ababababzs\",          | a | b | a | b | a | b | a | b | a | b | a | \\n     \"ababababzt\",          +---+---+---+---+---+---+---+---+---+---+---+ \\n     \"ababababzu\",          | a | b | a | b | a | b | a | b | a | b | a | \\n     \"ababababzv\",          +---+---+---+---+---+---+---+---+---+---+---+ \\n     \"ababababzw\",          | a | b | a | b | a | b | a | b | a | b | a | \\n     \"ababababzx\",          +---+---+---+---+---+---+---+---+---+---+---+ \\n     \"ababababzy\",          | a | b | a | b | a | b | a | b | a | b | a | \\n     \"ababababzz\",          +---+---+---+---+---+---+---+---+---+---+---+ \\n ]                          | a | b | a | b | a | b | a | b | a | b | a | \\n                            +---+---+---+---+---+---+---+---+---+---+---+ \\n                            | a | b | a | b | a | b | a | b | a | b | a | \\n                            +---+---+---+---+---+---+---+---+---+---+---+ \\n                            | a | b | a | b | a | b | a | b | a | b | a | \\n                            +---+---+---+---+---+---+---+---+---+---+---+ \\n```\n```Python\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        rows = len(board)\\n        cols = len(board[0])\\n        \\n        visited = set()\\n        results = set()\\n        \\n        # Hack. Reverse the string to look for.\\n        for i in range(len(words)):\\n            words[i] = words[i][::-1]\\n        \\n        # Normal dfs.\\n        def dfs(i, j, idx, word):\\n            if word in results   : return\\n            if i < 0 or rows <= i: return\\n            if j < 0 or cols <= j: return\\n            \\n            visited.add((i, j))\\n            \\n            if board[i][j] != word[idx]:\\n                pass\\n                \\n            elif idx == len(word)-1:\\n                results.add(word)\\n            \\n            else:\\n                if (i-1, j) not in visited: dfs(i-1, j, idx+1, word)\\n                if (i+1, j) not in visited: dfs(i+1, j, idx+1, word)\\n                if (i, j-1) not in visited: dfs(i, j-1, idx+1, word)\\n                if (i, j+1) not in visited: dfs(i, j+1, idx+1, word)\\n            \\n            visited.remove((i, j))\\n        \\n        # For every cell, search every word.\\n        for i in range(rows):\\n            for j in range(cols):\\n                for word in words:\\n                    if word not in results:\\n                        dfs(i, j, 0, word)\\n            \\n        return [word[::-1] for word in results]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1323358,
                "title": "c-simple-and-easy-trie-dfs-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    struct TrieNode{\\n        unordered_map <char, TrieNode*> children;\\n        bool endofword;\\n        string word = \"\";\\n    };\\n    \\n    TrieNode* getNewNode(){\\n        TrieNode *new_node= new TrieNode();\\n        new_node->endofword=false;\\n        return new_node;\\n    }\\n    \\n    void insertInTrie(string s, TrieNode **root){\\n        if(*root==NULL) *root= getNewNode();\\n        TrieNode* ptr= *root;\\n        for(int i=0;i<s.length();i++){\\n            if(ptr->children.find(s[i])==ptr->children.end()){\\n                ptr->children[s[i]]=getNewNode();\\n            }\\n            ptr= ptr->children[s[i]];\\n        }\\n        ptr->endofword=true;   \\n        ptr->word=s;\\n    }\\n    \\n    void dfs(vector<vector<char>>& board, int i, int j, TrieNode *root, vector <string> &res){\\n        char c= board[i][j];\\n        if(c==\\'#\\' || root->children.find(c)==root->children.end()) return;\\n        \\n        root = root->children[c];\\n        \\n        board[i][j]= \\'#\\';\\n        if(root->endofword==true) root->endofword=false, res.push_back(root->word);\\n        \\n        if (i > 0) dfs(board, i - 1, j, root, res);\\n        if (j > 0) dfs(board, i, j - 1, root, res);\\n        if (i < board.size() - 1) dfs(board, i + 1, j, root, res);\\n        if (j < board[0].size() - 1) dfs(board, i, j + 1, root, res);\\n        board[i][j] = c;\\n        \\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        TrieNode *head= NULL;\\n        vector <string> res;\\n        int m= board.size();\\n        int n= board[0].size();\\n        for(int i=0;i<words.size();i++){\\n            insertInTrie(words[i], &head);\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                dfs(board, i, j, head, res);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    struct TrieNode{\\n        unordered_map <char, TrieNode*> children;\\n        bool endofword;\\n        string word = \"\";\\n    };\\n    \\n    TrieNode* getNewNode(){\\n        TrieNode *new_node= new TrieNode();\\n        new_node->endofword=false;\\n        return new_node;\\n    }\\n    \\n    void insertInTrie(string s, TrieNode **root){\\n        if(*root==NULL) *root= getNewNode();\\n        TrieNode* ptr= *root;\\n        for(int i=0;i<s.length();i++){\\n            if(ptr->children.find(s[i])==ptr->children.end()){\\n                ptr->children[s[i]]=getNewNode();\\n            }\\n            ptr= ptr->children[s[i]];\\n        }\\n        ptr->endofword=true;   \\n        ptr->word=s;\\n    }\\n    \\n    void dfs(vector<vector<char>>& board, int i, int j, TrieNode *root, vector <string> &res){\\n        char c= board[i][j];\\n        if(c==\\'#\\' || root->children.find(c)==root->children.end()) return;\\n        \\n        root = root->children[c];\\n        \\n        board[i][j]= \\'#\\';\\n        if(root->endofword==true) root->endofword=false, res.push_back(root->word);\\n        \\n        if (i > 0) dfs(board, i - 1, j, root, res);\\n        if (j > 0) dfs(board, i, j - 1, root, res);\\n        if (i < board.size() - 1) dfs(board, i + 1, j, root, res);\\n        if (j < board[0].size() - 1) dfs(board, i, j + 1, root, res);\\n        board[i][j] = c;\\n        \\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        TrieNode *head= NULL;\\n        vector <string> res;\\n        int m= board.size();\\n        int n= board[0].size();\\n        for(int i=0;i<words.size();i++){\\n            insertInTrie(words[i], &head);\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                dfs(board, i, j, head, res);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186193,
                "title": "c-using-trie-dfs-set-for-storing-unique-result-mark-terminal-false-once-stored",
                "content": "int rows[]={1,-1,0,0};\\nint cols[]={0,0,1,-1};\\nclass node{\\npublic:\\n\\n\\tchar ch;\\n\\tbool isTerminal;\\n\\tstring name;\\n\\tunordered_map<char,node*> child;\\t\\n\\tnode(char ch){\\n\\t\\tthis->ch=ch;\\n\\t\\tisTerminal=false;\\n\\t}\\n};\\n\\nclass Trie{\\npublic:\\n\\n\\tnode*root;\\n\\tTrie(){\\n\\t\\troot=new node(\\'\\\\0\\');\\n\\t}\\n\\tvoid insert(string str){\\n\\t\\tnode*temp=root;\\n\\t\\tfor(int i=0;i<str.length();i++){\\n\\t\\t\\tchar ch=str[i];\\n\\t\\t\\tif(temp->child[ch]!=0){\\n\\t\\t\\t\\ttemp=temp->child[ch];\\n\\t\\t\\t}else{\\n\\t\\t\\t\\ttemp->child[ch]=new node(ch);\\n\\t\\t\\t\\ttemp=temp->child[ch];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\ttemp->isTerminal=true;\\n\\t\\ttemp->name=str;\\n\\t}\\n};\\nclass Solution {\\npublic:\\n\\n\\tbool visited[1000][1000]={false};\\n\\tvoid find_word(vector<vector<char>>&board,int i,int j,node*temp,set<string>&s){\\n\\t\\tif(temp->isTerminal){\\n\\t\\t\\tif(i<0 or j<0 or i>=board.size() or j>=board[i].size() ){\\n\\t\\t\\t\\ts.insert(temp->name);\\n\\t\\t\\t\\ttemp->isTerminal=false;\\n\\t\\t\\t\\treturn ;\\n\\t\\t\\t}\\n\\t\\t\\tif(temp->child.count(board[i][j])!=0){\\n\\t\\t\\t\\tfor(int k=0;k<4;k++){\\n\\t\\t\\t\\t\\tfind_word(board,i+rows[k],j+cols[k],temp->child[board[i][j]],s);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\t\\n\\t\\t\\ts.insert(temp->name);\\n\\t\\t\\ttemp->isTerminal=false;\\n\\t\\t    return ;\\n\\t\\t}\\n\\t\\tif(i<0 or j<0 or i>=board.size() or j>=board[i].size() or visited[i][j]){\\n\\t\\t\\treturn ;\\n\\t\\t}\\n\\t\\tchar ch=board[i][j];\\n\\t\\tvisited[i][j]=true;\\n\\t\\tif(temp->child.count(ch)==0){\\n\\t\\t\\tvisited[i][j]=false;\\n\\t\\t\\treturn ;\\n\\t\\t}\\n\\n\\t\\tfor(int k=0;k<4;k++){\\n\\t\\t\\tfind_word(board,i+rows[k],j+cols[k],temp->child[ch],s);\\n\\t\\t}\\n\\t\\tvisited[i][j]=false;\\n\\t\\treturn;\\n\\t}\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words){\\n    \\tTrie t;\\n    \\tfor(auto&it:words){\\n    \\t\\tt.insert(it);\\n    \\t}\\n    \\tvector<string> ans;\\n    \\tset<string> s;\\n    \\tfor(int i=0;i<board.size();i++){\\n    \\t\\tfor(int j=0;j<board[i].size();j++){\\n    \\t\\t\\tfind_word(board,i,j,t.root,s);\\n    \\t\\t}\\n    \\t}\\n    \\tfor(auto&it:s){\\n    \\t\\tans.push_back(it);\\n    \\t}\\n    \\treturn ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n\\tbool visited[1000][1000]={false}",
                "codeTag": "Java"
            },
            {
                "id": 1008081,
                "title": "1ms-beats-94-06-simplest-java-backtracking-without-using-a-trie-explanation",
                "content": "An alternative to building the trie is to loop through the words array and try to build that word starting at each cell in the board. This solution, however, will do some duplicate work as it will repeat the same search sequence for substrings of previously searched words. \\n\\nThe time complexity for searching one word starting at any arbitrary cell (which is in this case calling ```findWord(board, word, i, j, 0)```) is O(4^L) where L is the length of the word. This is because we are branching at most four times for the four neighbors of the starting cell, with a maximum search depth of L. We do this at most M * N times, where M is the number of rows and N is the number of columns in the board.\\n\\nSo, the time complexity to search for one word is O((M * N) * 4^L).\\n\\nIf we redefine L to be the length of the longest string in the array, we can define the overall time complexity as O(S * (M * N) * 4^L) where S is the number of words in the array.\\n\\nIf we don\\'t consider stack space, the space complexity is O(S), assuming worst case that every word ends up in our result array. \\n\\n```\\nclass Solution {\\n    public List<String> findWords(char[][] board, String[] words) {\\n        List<String> res = new ArrayList<>();\\n        \\n        for (String word : words) {\\n            if (this.findWord(board, word)) {\\n                res.add(word);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private boolean findWord(char[][] board, String word) {\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[0].length; j++) {\\n                if (findWord(board, word, i, j, 0)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private boolean findWord(char[][] board, String word, int rowIdx, int colIdx, int charIdx) {\\n        if (rowIdx < 0 || colIdx < 0 || rowIdx == board.length || colIdx == board[0].length) {\\n            return false;\\n        }\\n        \\n        if (charIdx == word.length() - 1 && board[rowIdx][colIdx] == word.charAt(charIdx)) {\\n            return true;\\n        }\\n        \\n        if (charIdx == word.length()) {\\n            return false;\\n        }\\n        \\n        if (board[rowIdx][colIdx] == \\' \\' || board[rowIdx][colIdx] != word.charAt(charIdx)) {\\n            return false;\\n        }\\n        \\n        boolean res = false;\\n        char temp = board[rowIdx][colIdx];\\n        board[rowIdx][colIdx] = \\' \\';\\n        \\n        // go left, right, up, down\\n        if (findWord(board, word, rowIdx, colIdx - 1, charIdx + 1)) {\\n            res = true;\\n        } else if (findWord(board, word, rowIdx, colIdx + 1, charIdx + 1)) {\\n            res = true;\\n        } else if (findWord(board, word, rowIdx + 1, colIdx, charIdx + 1)) {\\n            res = true;\\n        } else if (findWord(board, word, rowIdx - 1, colIdx, charIdx + 1)) {\\n            res = true;\\n        }\\n        \\n        board[rowIdx][colIdx] = temp;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```findWord(board, word, i, j, 0)```\n```\\nclass Solution {\\n    public List<String> findWords(char[][] board, String[] words) {\\n        List<String> res = new ArrayList<>();\\n        \\n        for (String word : words) {\\n            if (this.findWord(board, word)) {\\n                res.add(word);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private boolean findWord(char[][] board, String word) {\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[0].length; j++) {\\n                if (findWord(board, word, i, j, 0)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private boolean findWord(char[][] board, String word, int rowIdx, int colIdx, int charIdx) {\\n        if (rowIdx < 0 || colIdx < 0 || rowIdx == board.length || colIdx == board[0].length) {\\n            return false;\\n        }\\n        \\n        if (charIdx == word.length() - 1 && board[rowIdx][colIdx] == word.charAt(charIdx)) {\\n            return true;\\n        }\\n        \\n        if (charIdx == word.length()) {\\n            return false;\\n        }\\n        \\n        if (board[rowIdx][colIdx] == \\' \\' || board[rowIdx][colIdx] != word.charAt(charIdx)) {\\n            return false;\\n        }\\n        \\n        boolean res = false;\\n        char temp = board[rowIdx][colIdx];\\n        board[rowIdx][colIdx] = \\' \\';\\n        \\n        // go left, right, up, down\\n        if (findWord(board, word, rowIdx, colIdx - 1, charIdx + 1)) {\\n            res = true;\\n        } else if (findWord(board, word, rowIdx, colIdx + 1, charIdx + 1)) {\\n            res = true;\\n        } else if (findWord(board, word, rowIdx + 1, colIdx, charIdx + 1)) {\\n            res = true;\\n        } else if (findWord(board, word, rowIdx - 1, colIdx, charIdx + 1)) {\\n            res = true;\\n        }\\n        \\n        board[rowIdx][colIdx] = temp;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 938208,
                "title": "kotlin-dfs-backtracking",
                "content": "```\\nclass Solution {\\n    \\n    fun findWords(board: Array<CharArray>, words: Array<String>): List<String> {\\n        \\n        if(board.isEmpty()) return listOf()\\n        if(words.all{ it.isEmpty() }) return listOf()\\n        \\n        val result = HashSet<String>()\\n        \\n        for(i in 0 until board.size){\\n            for(j in 0 until board[0].size){\\n                words\\n                    .filter{ it[0] == board[i][j] && dfs(board, i , j, it, 0)}\\n                    .forEach{\\n                        result.add(it)\\n                    }\\n            }\\n        } \\n        return result.toList()\\n    }\\n    \\n    \\n    private fun dfs(board: Array<CharArray>, row: Int, col: Int,\\n                   word: String, index: Int): Boolean{\\n        \\n        if(row < 0 || row > board.lastIndex || col < 0 || col > board[0].lastIndex\\n                    || word[index] != board[row][col])\\n            return false\\n        \\n        if(index == word.lastIndex) return true\\n        \\n        val temp = board[row][col]\\n        board[row][col] = \\'#\\'\\n        \\n        val found = dfs(board, row + 1, col, word, index + 1)\\n                    || dfs(board, row - 1, col, word, index + 1)\\n                    || dfs(board, row, col + 1, word, index + 1)\\n                    || dfs(board, row, col - 1, word, index + 1)\\n        \\n        board[row][col] = temp\\n        return found\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    fun findWords(board: Array<CharArray>, words: Array<String>): List<String> {\\n        \\n        if(board.isEmpty()) return listOf()\\n        if(words.all{ it.isEmpty() }) return listOf()\\n        \\n        val result = HashSet<String>()\\n        \\n        for(i in 0 until board.size){\\n            for(j in 0 until board[0].size){\\n                words\\n                    .filter{ it[0] == board[i][j] && dfs(board, i , j, it, 0)}\\n                    .forEach{\\n                        result.add(it)\\n                    }\\n            }\\n        } \\n        return result.toList()\\n    }\\n    \\n    \\n    private fun dfs(board: Array<CharArray>, row: Int, col: Int,\\n                   word: String, index: Int): Boolean{\\n        \\n        if(row < 0 || row > board.lastIndex || col < 0 || col > board[0].lastIndex\\n                    || word[index] != board[row][col])\\n            return false\\n        \\n        if(index == word.lastIndex) return true\\n        \\n        val temp = board[row][col]\\n        board[row][col] = \\'#\\'\\n        \\n        val found = dfs(board, row + 1, col, word, index + 1)\\n                    || dfs(board, row - 1, col, word, index + 1)\\n                    || dfs(board, row, col + 1, word, index + 1)\\n                    || dfs(board, row, col - 1, word, index + 1)\\n        \\n        board[row][col] = temp\\n        return found\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934641,
                "title": "python-solution-with-trie-28-ms",
                "content": "Basic algo overview:\\n1. Setup trie with words\\n2. Iterate through board and explore possible words. We take advantage of Trie structure to quickly stop searching when no words start with a given prefix. We also keep state so we don\\'t start from the beginning of a prefix each time, instead we continue from the previous prefix\\n3. When a word is found, remove it from the Trie (unless it is a prefix to another word) and append it to list of answers\\n```\\nclass Node:\\n    def __init__(self, prev):\\n        self.children = {}\\n        self.isWord = False\\n        self.prev = prev\\nclass Trie:\\n    def __init__(self):\\n        self.root = Node(None)\\n### curNode keeps track of last character searched\\n        self.curNode = None\\n        \\n    def addWord(self,word):\\n        node = self.root\\n        for char in word:\\n            node = node.children.setdefault(char,Node(node))\\n        node.isWord = True\\n        \\n    def startsWith(self, prefix):\\n        node = self.curNode or self.root\\n        for char in prefix:\\n            if char not in node.children:\\n                return False\\n            node = node.children[char]\\n\\t### Once we\\'ve checked if a prefix is valid, we keep track of it with curNode\\n        self.curNode = node\\n        return True\\n    \\n    def remove(self, word):\\n        node = self.root\\n\\t### DFS to end of word, and only remove characters if they have no children AKA no other words start with the current prefix\\n        for char in word:\\n            if char not in node.children:\\n                return\\n            node = node.children[char]\\n    ### Set isWord to false, in case the word is a prefix to other words and we don\\'t remove it\\n        node.isWord = False\\n        for char in word[::-1]:\\n            if not node.children:\\n                node = node.prev\\n                del node.children[char]\\n            \\n    \\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        self.trie = Trie()\\n\\t### Directions we can move to construct a word on the board\\n        self.dirs = [[1,0],[-1,0],[0,1],[0,-1]]\\n        self.ans = []\\n\\t### Add words to our Trie\\n        for word in words:\\n            self.trie.addWord(word)\\n\\t### Iterate through board and explore possible words that start with each character\\n        for r in range(len(board)):\\n            for c in range(len(board[r])):\\n                self.explore(board,[r,c],\"\")\\n        return self.ans\\n            \\n    \\n    def explore(self,board, pos, word):\\n        r, c = pos\\n\\t### Keep track of curNode to reset it back to this after we\\'ve finished searching\\n        curNode = self.trie.curNode\\n\\t### Make sure position is within board params\\n        if 0 <= r < len(board) and 0 <= c < len(board[r]):\\n\\t### board[r][c] is only None if we have visited it, will see this later\\n            if board[r][c] is None: return\\n\\t### Keep track of what the current word is \\n            curWord = word + board[r][c]\\n\\t### Only continue exploring if the current word  continues to be a valid prefix\\n            if self.trie.startsWith(board[r][c]):\\n    ### If the curNode is the end of a word and the word has not been found yet, then we:\\n\\t\\t\\t# Add to our answer list\\n\\t\\t\\t# Remove the word from our Trie\\n                if self.trie.curNode.isWord:\\n                        self.ans.append(curWord)\\n                        self.trie.remove(curWord)\\n    ### Continue exploring and temporarily set the current position to None to indicate it has been explored\\n                temp = board[r][c]\\n                board[r][c] = None\\n\\t### Exploring in all directions\\n                for dir in self.dirs:\\n                    newPos = [pos[0] + dir[0], pos[1] + dir[1]]\\n                    self.explore(board, newPos, curWord)\\n\\t### After exploring in all directions, we reset board[r][c] so that it is no longer considered explored\\n\\t### Also reset the trie curNode because the current prefix is done being explored\\n                board[r][c] = temp\\n                self.trie.curNode = curNode\\n        return\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Node:\\n    def __init__(self, prev):\\n        self.children = {}\\n        self.isWord = False\\n        self.prev = prev\\nclass Trie:\\n    def __init__(self):\\n        self.root = Node(None)\\n### curNode keeps track of last character searched\\n        self.curNode = None\\n        \\n    def addWord(self,word):\\n        node = self.root\\n        for char in word:\\n            node = node.children.setdefault(char,Node(node))\\n        node.isWord = True\\n        \\n    def startsWith(self, prefix):\\n        node = self.curNode or self.root\\n        for char in prefix:\\n            if char not in node.children:\\n                return False\\n            node = node.children[char]\\n\\t### Once we\\'ve checked if a prefix is valid, we keep track of it with curNode\\n        self.curNode = node\\n        return True\\n    \\n    def remove(self, word):\\n        node = self.root\\n\\t### DFS to end of word, and only remove characters if they have no children AKA no other words start with the current prefix\\n        for char in word:\\n            if char not in node.children:\\n                return\\n            node = node.children[char]\\n    ### Set isWord to false, in case the word is a prefix to other words and we don\\'t remove it\\n        node.isWord = False\\n        for char in word[::-1]:\\n            if not node.children:\\n                node = node.prev\\n                del node.children[char]\\n            \\n    \\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        self.trie = Trie()\\n\\t### Directions we can move to construct a word on the board\\n        self.dirs = [[1,0],[-1,0],[0,1],[0,-1]]\\n        self.ans = []\\n\\t### Add words to our Trie\\n        for word in words:\\n            self.trie.addWord(word)\\n\\t### Iterate through board and explore possible words that start with each character\\n        for r in range(len(board)):\\n            for c in range(len(board[r])):\\n                self.explore(board,[r,c],\"\")\\n        return self.ans\\n            \\n    \\n    def explore(self,board, pos, word):\\n        r, c = pos\\n\\t### Keep track of curNode to reset it back to this after we\\'ve finished searching\\n        curNode = self.trie.curNode\\n\\t### Make sure position is within board params\\n        if 0 <= r < len(board) and 0 <= c < len(board[r]):\\n\\t### board[r][c] is only None if we have visited it, will see this later\\n            if board[r][c] is None: return\\n\\t### Keep track of what the current word is \\n            curWord = word + board[r][c]\\n\\t### Only continue exploring if the current word  continues to be a valid prefix\\n            if self.trie.startsWith(board[r][c]):\\n    ### If the curNode is the end of a word and the word has not been found yet, then we:\\n\\t\\t\\t# Add to our answer list\\n\\t\\t\\t# Remove the word from our Trie\\n                if self.trie.curNode.isWord:\\n                        self.ans.append(curWord)\\n                        self.trie.remove(curWord)\\n    ### Continue exploring and temporarily set the current position to None to indicate it has been explored\\n                temp = board[r][c]\\n                board[r][c] = None\\n\\t### Exploring in all directions\\n                for dir in self.dirs:\\n                    newPos = [pos[0] + dir[0], pos[1] + dir[1]]\\n                    self.explore(board, newPos, curWord)\\n\\t### After exploring in all directions, we reset board[r][c] so that it is no longer considered explored\\n\\t### Also reset the trie curNode because the current prefix is done being explored\\n                board[r][c] = temp\\n                self.trie.curNode = curNode\\n        return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 906795,
                "title": "rust-8-ms-solution-beats-all",
                "content": "I used Trie for words (as everyone) and special CPU-optimized matrix for board.\\nYou can learn about trie in [other discussions](https://leetcode.com/problems/word-search-ii/discuss/59780/Java-15ms-Easiest-Solution-(100.00) ) so I would concentrate on board.\\n\\nBoard is made as flattened matrix (Vec) of submatrices. Since it flattened, it uses one allocation instead of many default provided by input.\\nTo get position in flattened you can just calc `y*width + x`.\\nAlso I made matrix of smaller matrices 8x8. Its size is choosen as 8x8 because it would be 64 bytes which fit to the CPU cache-line. It is effective, because during backtracking we traverse from each cell to 4 different directions and some time we are in one smaller submatrix. So in most cases we never move far away from starting memory location.\\n\\nYou can learn more about data locality here: http://ithare.com/c-for-games-performance-allocations-and-data-locality/\\n\\n```rust\\nuse std::collections::HashSet;\\nuse std::ops::{Index, IndexMut};\\n\\nconst INNER_SIDE: usize = 8;\\nconst RANGE: usize = (b\\'z\\' - b\\'a\\') as usize + 1;\\n\\n#[inline(always)]\\nfn alph_to_idx(c: u8) -> usize {\\n    (c - b\\'a\\').into()\\n}\\n\\nstruct Board<T>\\nwhere\\n    T: Copy + Default,\\n{\\n    b_width: usize,\\n    width: usize,\\n    height: usize,\\n    buff: Vec<[[T; INNER_SIDE]; INNER_SIDE]>,\\n}\\n\\nimpl<T: Copy + Default> Board<T> {\\n    fn zeroed(width: usize, height: usize) -> Self {\\n        assert!(width > 0 && height > 0);\\n        let b_width = width / INNER_SIDE + if width % INNER_SIDE > 0 { 1 } else { 0 };\\n        let b_height = height / INNER_SIDE + if height % INNER_SIDE > 0 { 1 } else { 0 };\\n        Self {\\n            b_width,\\n            width,\\n            height,\\n            buff: vec![[[T::default(); INNER_SIDE]; INNER_SIDE]; b_height * b_width],\\n        }\\n    }\\n}\\n\\nfn from_chars(board: Vec<Vec<char>>) -> Board<u8> {\\n    assert!(board.len() > 0, \"Expected square\");\\n    assert!(board.first().unwrap().len() > 0, \"Expected square\");\\n    assert!(\\n        board.windows(2).all(|w| w[0].len() == w[1].len()),\\n        \"Expected square\"\\n    );\\n    assert!(\\n        board\\n            .iter()\\n            .all(|sub| sub.iter().all(char::is_ascii_lowercase)),\\n        \"Expected ascii lowercase\"\\n    );\\n    let width = board[0].len();\\n    let height = board.len();\\n    let mut res = Board::zeroed(width, height);\\n    for (y, row) in board.into_iter().enumerate() {\\n        for (x, elem) in row.into_iter().enumerate() {\\n            res[(x, y)] = elem as u8;\\n        }\\n    }\\n    res\\n}\\n\\nfn calc_existing_chars(board: &Board<u8>) -> [usize; RANGE] {\\n    let mut result = [0; RANGE];\\n    for block in board.buff.iter() {\\n        if block.iter().flatten().any(|&x| x == 0) {\\n            for b in block\\n                .iter()\\n                .flatten()\\n                .copied()\\n                .filter(|&x| x != 0)\\n                .map(alph_to_idx)\\n            {\\n                result[b] += 1;\\n            }\\n        } else {\\n            for b in block.iter().flatten().copied().map(alph_to_idx) {\\n                result[b] += 1;\\n            }\\n        }\\n    }\\n    result\\n}\\n\\nimpl<T: Copy + Default> Index<(usize, usize)> for Board<T> {\\n    type Output = T;\\n\\n    fn index(&self, (x, y): (usize, usize)) -> &Self::Output {\\n        assert!(x < self.width && y < self.height, \"Should be in bounds\");\\n        let block_x = x / INNER_SIDE;\\n        let inner_x = x % INNER_SIDE;\\n        let block_y = y / INNER_SIDE;\\n        let inner_y = y % INNER_SIDE;\\n        let block = &self.buff[self.b_width * block_y + block_x];\\n        &block[inner_y][inner_x]\\n    }\\n}\\n\\nimpl<T: Copy + Default> IndexMut<(usize, usize)> for Board<T> {\\n    fn index_mut(&mut self, (x, y): (usize, usize)) -> &mut Self::Output {\\n        assert!(x < self.width && y < self.height, \"Should be in bounds\");\\n        let block_x = x / INNER_SIDE;\\n        let inner_x = x % INNER_SIDE;\\n        let block_y = y / INNER_SIDE;\\n        let inner_y = y % INNER_SIDE;\\n        let block = &mut self.buff[self.b_width * block_y + block_x];\\n        &mut block[inner_y][inner_x]\\n    }\\n}\\n\\nfn remove_all_invalid_words(words: &mut Vec<String>, board: &Board<u8>) {\\n    let allowed_chars = calc_existing_chars(board);\\n    words.retain(|w| {\\n        if w.as_bytes()\\n            .iter()\\n            .any(|&c| allowed_chars[alph_to_idx(c)] == 0)\\n        {\\n            return false;\\n        }\\n        let mut chars = [0usize; RANGE];\\n        for b in w.as_bytes().iter().copied().map(alph_to_idx) {\\n            chars[b] += 1;\\n        }\\n        chars.iter().zip(&allowed_chars).all(|(&a, &b)| a <= b)\\n    });\\n}\\n\\n#[derive(Default)]\\nstruct TrieNode<\\'a> {\\n    children: [Option<Box<TrieNode<\\'a>>>; RANGE],\\n    word: Option<&\\'a str>,\\n}\\n\\nimpl<\\'a> TrieNode<\\'a> {\\n    fn produce(words: &\\'a [String]) -> Box<Self> {\\n        let mut root = Self::default();\\n        for w in words {\\n            let word = w.as_str();\\n            let bytes = word.as_bytes();\\n            let mut current = &mut root;\\n            for &b in bytes {\\n                let idx = alph_to_idx(b);\\n                if current.children[idx].is_none() {\\n                    current.children[idx] = Some(Box::new(Self::default()));\\n                }\\n                let next = current.children[idx].as_mut().unwrap().as_mut();\\n                current = next;\\n            }\\n            current.word = Some(word);\\n        }\\n        Box::new(root)\\n    }\\n}\\n\\nfn traverse<\\'a>(\\n    pos: (usize, usize),\\n    board: &Board<u8>,\\n    visited: &mut Board<bool>,\\n    found: &mut HashSet<&\\'a str>,\\n    trie: &TrieNode<\\'a>,\\n) {\\n    let c = board[pos];\\n    if let Some(ref next) = trie.children[alph_to_idx(c)] {\\n        let next = next.as_ref();\\n        if let Some(w) = next.word {\\n            found.insert(w);\\n        }\\n        visited[pos] = true;\\n\\n        if pos.0 > 0 {\\n            let candidate = (pos.0 - 1, pos.1);\\n            if !visited[candidate] {\\n                traverse(candidate, board, visited, found, next);\\n            }\\n        }\\n        if pos.1 > 0 {\\n            let candidate = (pos.0, pos.1 - 1);\\n            if !visited[candidate] {\\n                traverse(candidate, board, visited, found, next);\\n            }\\n        }\\n        if pos.0 + 1 < board.width {\\n            let candidate = (pos.0 + 1, pos.1);\\n            if !visited[candidate] {\\n                traverse(candidate, board, visited, found, next);\\n            }\\n        }\\n        if pos.1 + 1 < board.height {\\n            let candidate = (pos.0, pos.1 + 1);\\n            if !visited[candidate] {\\n                traverse(candidate, board, visited, found, next);\\n            }\\n        }\\n\\n        visited[pos] = false;\\n    }\\n}\\n\\n\\nimpl Solution {\\n    pub fn find_words(board: Vec<Vec<char>>, mut words: Vec<String>) -> Vec<String> {\\n        words.sort_unstable();\\n        words.dedup();\\n\\n        assert!(words\\n            .iter()\\n            .flat_map(|w| w.as_bytes())\\n            .all(|&b| b.is_ascii_lowercase()));\\n\\n        let board = from_chars(board);\\n        words.retain(|x| x.len() <= board.width * board.height);\\n\\n        remove_all_invalid_words(&mut words, &board);\\n\\n        if words.is_empty() {\\n            return words;\\n        }\\n\\n        let mut result = HashSet::new();\\n        let trie = TrieNode::produce(&words);\\n        let mut visited: Board<bool> = Board::zeroed(board.width, board.height);\\n        for y in 0..board.height {\\n            for x in 0..board.width {\\n                if result.len() == words.len() {\\n                    return words;\\n                }\\n                traverse((x, y), &board, &mut visited, &mut result, trie.as_ref());\\n            }\\n        }\\n        result.into_iter().map(|x| x.to_string()).collect()\\n    }\\n}\\n\\n```\\n\\nAnd, finally, the pic :)\\n![image](https://assets.leetcode.com/users/images/25729a7e-ae0d-4182-95fc-4e629221b2fe_1603438722.3488445.png)\\n",
                "solutionTags": [
                    "Rust",
                    "Trie",
                    "Matrix"
                ],
                "code": "```rust\\nuse std::collections::HashSet;\\nuse std::ops::{Index, IndexMut};\\n\\nconst INNER_SIDE: usize = 8;\\nconst RANGE: usize = (b\\'z\\' - b\\'a\\') as usize + 1;\\n\\n#[inline(always)]\\nfn alph_to_idx(c: u8) -> usize {\\n    (c - b\\'a\\').into()\\n}\\n\\nstruct Board<T>\\nwhere\\n    T: Copy + Default,\\n{\\n    b_width: usize,\\n    width: usize,\\n    height: usize,\\n    buff: Vec<[[T; INNER_SIDE]; INNER_SIDE]>,\\n}\\n\\nimpl<T: Copy + Default> Board<T> {\\n    fn zeroed(width: usize, height: usize) -> Self {\\n        assert!(width > 0 && height > 0);\\n        let b_width = width / INNER_SIDE + if width % INNER_SIDE > 0 { 1 } else { 0 };\\n        let b_height = height / INNER_SIDE + if height % INNER_SIDE > 0 { 1 } else { 0 };\\n        Self {\\n            b_width,\\n            width,\\n            height,\\n            buff: vec![[[T::default(); INNER_SIDE]; INNER_SIDE]; b_height * b_width],\\n        }\\n    }\\n}\\n\\nfn from_chars(board: Vec<Vec<char>>) -> Board<u8> {\\n    assert!(board.len() > 0, \"Expected square\");\\n    assert!(board.first().unwrap().len() > 0, \"Expected square\");\\n    assert!(\\n        board.windows(2).all(|w| w[0].len() == w[1].len()),\\n        \"Expected square\"\\n    );\\n    assert!(\\n        board\\n            .iter()\\n            .all(|sub| sub.iter().all(char::is_ascii_lowercase)),\\n        \"Expected ascii lowercase\"\\n    );\\n    let width = board[0].len();\\n    let height = board.len();\\n    let mut res = Board::zeroed(width, height);\\n    for (y, row) in board.into_iter().enumerate() {\\n        for (x, elem) in row.into_iter().enumerate() {\\n            res[(x, y)] = elem as u8;\\n        }\\n    }\\n    res\\n}\\n\\nfn calc_existing_chars(board: &Board<u8>) -> [usize; RANGE] {\\n    let mut result = [0; RANGE];\\n    for block in board.buff.iter() {\\n        if block.iter().flatten().any(|&x| x == 0) {\\n            for b in block\\n                .iter()\\n                .flatten()\\n                .copied()\\n                .filter(|&x| x != 0)\\n                .map(alph_to_idx)\\n            {\\n                result[b] += 1;\\n            }\\n        } else {\\n            for b in block.iter().flatten().copied().map(alph_to_idx) {\\n                result[b] += 1;\\n            }\\n        }\\n    }\\n    result\\n}\\n\\nimpl<T: Copy + Default> Index<(usize, usize)> for Board<T> {\\n    type Output = T;\\n\\n    fn index(&self, (x, y): (usize, usize)) -> &Self::Output {\\n        assert!(x < self.width && y < self.height, \"Should be in bounds\");\\n        let block_x = x / INNER_SIDE;\\n        let inner_x = x % INNER_SIDE;\\n        let block_y = y / INNER_SIDE;\\n        let inner_y = y % INNER_SIDE;\\n        let block = &self.buff[self.b_width * block_y + block_x];\\n        &block[inner_y][inner_x]\\n    }\\n}\\n\\nimpl<T: Copy + Default> IndexMut<(usize, usize)> for Board<T> {\\n    fn index_mut(&mut self, (x, y): (usize, usize)) -> &mut Self::Output {\\n        assert!(x < self.width && y < self.height, \"Should be in bounds\");\\n        let block_x = x / INNER_SIDE;\\n        let inner_x = x % INNER_SIDE;\\n        let block_y = y / INNER_SIDE;\\n        let inner_y = y % INNER_SIDE;\\n        let block = &mut self.buff[self.b_width * block_y + block_x];\\n        &mut block[inner_y][inner_x]\\n    }\\n}\\n\\nfn remove_all_invalid_words(words: &mut Vec<String>, board: &Board<u8>) {\\n    let allowed_chars = calc_existing_chars(board);\\n    words.retain(|w| {\\n        if w.as_bytes()\\n            .iter()\\n            .any(|&c| allowed_chars[alph_to_idx(c)] == 0)\\n        {\\n            return false;\\n        }\\n        let mut chars = [0usize; RANGE];\\n        for b in w.as_bytes().iter().copied().map(alph_to_idx) {\\n            chars[b] += 1;\\n        }\\n        chars.iter().zip(&allowed_chars).all(|(&a, &b)| a <= b)\\n    });\\n}\\n\\n#[derive(Default)]\\nstruct TrieNode<\\'a> {\\n    children: [Option<Box<TrieNode<\\'a>>>; RANGE],\\n    word: Option<&\\'a str>,\\n}\\n\\nimpl<\\'a> TrieNode<\\'a> {\\n    fn produce(words: &\\'a [String]) -> Box<Self> {\\n        let mut root = Self::default();\\n        for w in words {\\n            let word = w.as_str();\\n            let bytes = word.as_bytes();\\n            let mut current = &mut root;\\n            for &b in bytes {\\n                let idx = alph_to_idx(b);\\n                if current.children[idx].is_none() {\\n                    current.children[idx] = Some(Box::new(Self::default()));\\n                }\\n                let next = current.children[idx].as_mut().unwrap().as_mut();\\n                current = next;\\n            }\\n            current.word = Some(word);\\n        }\\n        Box::new(root)\\n    }\\n}\\n\\nfn traverse<\\'a>(\\n    pos: (usize, usize),\\n    board: &Board<u8>,\\n    visited: &mut Board<bool>,\\n    found: &mut HashSet<&\\'a str>,\\n    trie: &TrieNode<\\'a>,\\n) {\\n    let c = board[pos];\\n    if let Some(ref next) = trie.children[alph_to_idx(c)] {\\n        let next = next.as_ref();\\n        if let Some(w) = next.word {\\n            found.insert(w);\\n        }\\n        visited[pos] = true;\\n\\n        if pos.0 > 0 {\\n            let candidate = (pos.0 - 1, pos.1);\\n            if !visited[candidate] {\\n                traverse(candidate, board, visited, found, next);\\n            }\\n        }\\n        if pos.1 > 0 {\\n            let candidate = (pos.0, pos.1 - 1);\\n            if !visited[candidate] {\\n                traverse(candidate, board, visited, found, next);\\n            }\\n        }\\n        if pos.0 + 1 < board.width {\\n            let candidate = (pos.0 + 1, pos.1);\\n            if !visited[candidate] {\\n                traverse(candidate, board, visited, found, next);\\n            }\\n        }\\n        if pos.1 + 1 < board.height {\\n            let candidate = (pos.0, pos.1 + 1);\\n            if !visited[candidate] {\\n                traverse(candidate, board, visited, found, next);\\n            }\\n        }\\n\\n        visited[pos] = false;\\n    }\\n}\\n\\n\\nimpl Solution {\\n    pub fn find_words(board: Vec<Vec<char>>, mut words: Vec<String>) -> Vec<String> {\\n        words.sort_unstable();\\n        words.dedup();\\n\\n        assert!(words\\n            .iter()\\n            .flat_map(|w| w.as_bytes())\\n            .all(|&b| b.is_ascii_lowercase()));\\n\\n        let board = from_chars(board);\\n        words.retain(|x| x.len() <= board.width * board.height);\\n\\n        remove_all_invalid_words(&mut words, &board);\\n\\n        if words.is_empty() {\\n            return words;\\n        }\\n\\n        let mut result = HashSet::new();\\n        let trie = TrieNode::produce(&words);\\n        let mut visited: Board<bool> = Board::zeroed(board.width, board.height);\\n        for y in 0..board.height {\\n            for x in 0..board.width {\\n                if result.len() == words.len() {\\n                    return words;\\n                }\\n                traverse((x, y), &board, &mut visited, &mut result, trie.as_ref());\\n            }\\n        }\\n        result.into_iter().map(|x| x.to_string()).collect()\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 889671,
                "title": "easy-backtracking-trie-c-solution",
                "content": "```\\nclass Trie{\\n    public:\\n    unordered_map<char, Trie*> children;\\n    bool isEnd=false;\\n    \\n    void insert(string word){\\n        Trie* node=this;\\n        for(char c : word){\\n            if(node->children.find(c)==node->children.end())\\n                node->children[c]=new Trie();\\n            node=node->children[c];\\n        }\\n        node->isEnd=true;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> direction={0, -1, 0, 1, 0};\\n    void Backtracking(vector<vector<char>>& board, Trie* trie, int i, int j, string& partial, vector<string>& result){\\n        if(trie->isEnd==true){\\n            result.push_back(partial);\\n            trie->isEnd=false;\\n        }\\n        \\n        for(int d=0; d<4; d++){\\n            int row=i+direction[d];\\n            int col=j+direction[d+1];\\n            if(row>=0 && col>=0 && row<board.size() && col<board[0].size() && board[row][col]!=\\'#\\' && \\n               trie->children.find(board[row][col])!=trie->children.end()){\\n                char temp=board[row][col];\\n                board[row][col]=\\'#\\';\\n                partial.push_back(temp);\\n                \\n                Backtracking(board, trie->children[temp], row, col, partial, result); \\n                \\n                partial.pop_back();\\n                board[row][col]=temp;\\n            }\\n            \\n        }\\n        \\n        \\n    }\\n    \\n    vector<string> exist(vector<vector<char>>& board, Trie* trie){\\n        int m=board.size(), n=board[0].size();\\n        \\n        vector<string> result;\\n        string partial;\\n        \\n        for(int i=0; i<m; i++)\\n            for(int j=0; j<n; j++){\\n                if(trie->children.find(board[i][j])!=trie->children.end()){\\n                    char temp=board[i][j];\\n                    board[i][j]=\\'#\\';\\n                    partial.push_back(temp);\\n\\n                    Backtracking(board, trie->children[temp], i, j, partial, result);\\n\\n                    partial.pop_back();\\n                    board[i][j]=temp;\\n                }\\n                \\n            }\\n        \\n        return result;\\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        Trie* trie=new Trie();\\n        for(string word : words)\\n            trie->insert(word);\\n        \\n        return exist(board, trie);\\n    }\\n};\\n```\\nI appreciate yoru upvote !!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Trie{\\n    public:\\n    unordered_map<char, Trie*> children;\\n    bool isEnd=false;\\n    \\n    void insert(string word){\\n        Trie* node=this;\\n        for(char c : word){\\n            if(node->children.find(c)==node->children.end())\\n                node->children[c]=new Trie();\\n            node=node->children[c];\\n        }\\n        node->isEnd=true;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> direction={0, -1, 0, 1, 0};\\n    void Backtracking(vector<vector<char>>& board, Trie* trie, int i, int j, string& partial, vector<string>& result){\\n        if(trie->isEnd==true){\\n            result.push_back(partial);\\n            trie->isEnd=false;\\n        }\\n        \\n        for(int d=0; d<4; d++){\\n            int row=i+direction[d];\\n            int col=j+direction[d+1];\\n            if(row>=0 && col>=0 && row<board.size() && col<board[0].size() && board[row][col]!=\\'#\\' && \\n               trie->children.find(board[row][col])!=trie->children.end()){\\n                char temp=board[row][col];\\n                board[row][col]=\\'#\\';\\n                partial.push_back(temp);\\n                \\n                Backtracking(board, trie->children[temp], row, col, partial, result); \\n                \\n                partial.pop_back();\\n                board[row][col]=temp;\\n            }\\n            \\n        }\\n        \\n        \\n    }\\n    \\n    vector<string> exist(vector<vector<char>>& board, Trie* trie){\\n        int m=board.size(), n=board[0].size();\\n        \\n        vector<string> result;\\n        string partial;\\n        \\n        for(int i=0; i<m; i++)\\n            for(int j=0; j<n; j++){\\n                if(trie->children.find(board[i][j])!=trie->children.end()){\\n                    char temp=board[i][j];\\n                    board[i][j]=\\'#\\';\\n                    partial.push_back(temp);\\n\\n                    Backtracking(board, trie->children[temp], i, j, partial, result);\\n\\n                    partial.pop_back();\\n                    board[i][j]=temp;\\n                }\\n                \\n            }\\n        \\n        return result;\\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        Trie* trie=new Trie();\\n        for(string word : words)\\n            trie->insert(word);\\n        \\n        return exist(board, trie);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 802511,
                "title": "complete-process-to-do-with-well-comment-using-unordered-map-dfs-tries",
                "content": "This question is basically of DFS but the problem is we have to reduce in dfs(recall we were exploring all the path into DFS) but here we can not do like that cause that would TLE..\\nSo i decided to insert all the words into tries first and we will explore only those path which has a prefix in tries .. and we are storing the number of prefix in tries because it will reduce again extra calls..\\nEach time when we counter the end of word we store the word(since we are storing the index of that word or we can store as char extra in tries class)..\\nAvoid recursive call:-\\n1. if we have 0 prefix counter on current node because we don\\'t need any word with such prefix just return\\n2. if we don\\'t have any next node in tries because we don\\'t need any word more than that or we our tries has no node with such char that\\'s means we don\\'t have requirement with a word which start with char board[i][j]  for which we don\\'t have any node in tries for particular root\\n3. all the boundry condition as we did in dfs and if any position is allready visited then avoid to call\\nRest of job my comment should do:)\\n```\\nclass Trie{\\n  public:\\n    unordered_map<char , Trie*> leaf;\\n    bool endOfWord;\\n    int wordIdx;\\n    int prefixCount;\\n    Trie(){\\n      endOfWord=false;\\n      wordIdx=0;\\n      prefixCount=0;\\n    }\\n  ~Trie(){\\n    for(auto x : leaf) delete x.second;\\n  }\\n};\\nclass Solution {\\npublic:\\nvoid insert(Trie *root , string& word  , int index , int len=0){\\n  if(len==word.size()){\\n    //mark current root as end of word and assign the index value\\n    root->endOfWord=true;\\n    root->wordIdx=index;\\n    return;\\n  }\\n  root->prefixCount+=1;\\n  if(!root->leaf[word[len]]){\\n    //make a root value\\n    root->leaf[word[len]]=new Trie();\\n  }\\n  root=root->leaf[word[len]];\\n  root->prefixCount +=1;\\n  insert(root , word , index , len+1);\\n}\\nvoid buildTrie(vector<string>& words , Trie *root){\\n  for(int i=0 ; i<words.size() ;i++) insert(root , words[i] , i);\\n}\\n\\nint dfs_tries(vector<string>&output , Trie *root , vector<vector<char>>& board ,vector<string>& words , int i , int j){\\n  //cout<<i<<\" \"<<j<<\\'\\\\n\\';\\n  int detected=0;//how many word is detected till now\\n  if(root->endOfWord){\\n    //then we have a word which needs to find let\\'s store that word\\n    output.push_back(words[root->wordIdx]);\\n    //and unmark the current root as not end of word\\n    root->endOfWord=false;\\n    //increase detected cause we found one word\\n    detected++;\\n  }\\n  //boundry condition\\n  if(i<0 || j<0 || i>=board.size() || j>=board[0].size()){\\n    return detected;\\n  }\\n  //shift root\\n  Trie *child=root->leaf[board[i][j]];\\n  //base case(invalid condition)\\n  if( board[i][j]==\\'*\\' || !child || child->prefixCount<=0 ){\\n    return detected;\\n  }\\n  char temp=board[i][j];\\n  board[i][j]=\\'*\\';//mark as visited\\n  //explore all the path from i and j\\n  detected += dfs_tries(output , child , board , words , i+1 , j);\\n  detected += dfs_tries(output , child , board , words , i , j+1);\\n  detected += dfs_tries(output , child , board , words , i-1 , j);\\n  detected += dfs_tries(output , child , board , words , i , j-1);\\n  //while backtracking we are going to reduce detected with prefixCount\\n  root->prefixCount -= detected;\\n  //and reset the val what i changed for further use\\n  board[i][j]=temp;\\n  return detected;\\n}\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n  int row , col , wordLen=words.size();\\n  vector<string> output;\\n  //base case\\n  if( !(row=board.size()) || !(col=board[0].size()) || !wordLen){\\n    return output;\\n  }\\n  Trie *root=new Trie();\\n  //build the tree i.e. insert all words into the tries\\n  buildTrie(words , root);\\n  //do dfs\\n  //if no prefix count then we have not any element in words which is in board\\n  for(int i=0 ; i<row  && root->prefixCount; i++){\\n    for(int j=0 ; j<col ; j++){\\n     int x= dfs_tries(output , root  , board , words , i ,j);\\n    }\\n  }\\n  delete root;\\n  return output;\\n    }\\n};\\n```\\nPlease vote if it helps you..\\nHappy coding:)",
                "solutionTags": [],
                "code": "```\\nclass Trie{\\n  public:\\n    unordered_map<char , Trie*> leaf;\\n    bool endOfWord;\\n    int wordIdx;\\n    int prefixCount;\\n    Trie(){\\n      endOfWord=false;\\n      wordIdx=0;\\n      prefixCount=0;\\n    }\\n  ~Trie(){\\n    for(auto x : leaf) delete x.second;\\n  }\\n};\\nclass Solution {\\npublic:\\nvoid insert(Trie *root , string& word  , int index , int len=0){\\n  if(len==word.size()){\\n    //mark current root as end of word and assign the index value\\n    root->endOfWord=true;\\n    root->wordIdx=index;\\n    return;\\n  }\\n  root->prefixCount+=1;\\n  if(!root->leaf[word[len]]){\\n    //make a root value\\n    root->leaf[word[len]]=new Trie();\\n  }\\n  root=root->leaf[word[len]];\\n  root->prefixCount +=1;\\n  insert(root , word , index , len+1);\\n}\\nvoid buildTrie(vector<string>& words , Trie *root){\\n  for(int i=0 ; i<words.size() ;i++) insert(root , words[i] , i);\\n}\\n\\nint dfs_tries(vector<string>&output , Trie *root , vector<vector<char>>& board ,vector<string>& words , int i , int j){\\n  //cout<<i<<\" \"<<j<<\\'\\\\n\\';\\n  int detected=0;//how many word is detected till now\\n  if(root->endOfWord){\\n    //then we have a word which needs to find let\\'s store that word\\n    output.push_back(words[root->wordIdx]);\\n    //and unmark the current root as not end of word\\n    root->endOfWord=false;\\n    //increase detected cause we found one word\\n    detected++;\\n  }\\n  //boundry condition\\n  if(i<0 || j<0 || i>=board.size() || j>=board[0].size()){\\n    return detected;\\n  }\\n  //shift root\\n  Trie *child=root->leaf[board[i][j]];\\n  //base case(invalid condition)\\n  if( board[i][j]==\\'*\\' || !child || child->prefixCount<=0 ){\\n    return detected;\\n  }\\n  char temp=board[i][j];\\n  board[i][j]=\\'*\\';//mark as visited\\n  //explore all the path from i and j\\n  detected += dfs_tries(output , child , board , words , i+1 , j);\\n  detected += dfs_tries(output , child , board , words , i , j+1);\\n  detected += dfs_tries(output , child , board , words , i-1 , j);\\n  detected += dfs_tries(output , child , board , words , i , j-1);\\n  //while backtracking we are going to reduce detected with prefixCount\\n  root->prefixCount -= detected;\\n  //and reset the val what i changed for further use\\n  board[i][j]=temp;\\n  return detected;\\n}\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n  int row , col , wordLen=words.size();\\n  vector<string> output;\\n  //base case\\n  if( !(row=board.size()) || !(col=board[0].size()) || !wordLen){\\n    return output;\\n  }\\n  Trie *root=new Trie();\\n  //build the tree i.e. insert all words into the tries\\n  buildTrie(words , root);\\n  //do dfs\\n  //if no prefix count then we have not any element in words which is in board\\n  for(int i=0 ; i<row  && root->prefixCount; i++){\\n    for(int j=0 ; j<col ; j++){\\n     int x= dfs_tries(output , root  , board , words , i ,j);\\n    }\\n  }\\n  delete root;\\n  return output;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 748617,
                "title": "c-trie-dfs-backtracking-with-comments-and-explanation",
                "content": "We can go for normal DFS search with backtracking but that would not be efficient since for every string in words we would have to do dfs on the whole board again.\\nBy making a trie of the words we can check for every character and move to that as and when it matches so only need one dfs for the board.\\n```\\n//Trie Node Class\\nclass TrieNode{\\n    public:\\n\\t// To Store Child Nodes\\n    unordered_map<char,TrieNode*> children;\\n    bool isLeaf;\\n    // To check if found\\n\\tbool found;\\n    TrieNode() {\\n        isLeaf = false;\\n        found = false;\\n    }\\n    void insert(string s) {\\n        TrieNode* current = this;\\n        for(int i=0;i<s.length();i++) {\\n\\t\\t\\t// if node doesnt exist\\n            if(current->children.find(s[i]) == current->children.end()){\\n                current->children[s[i]] = new TrieNode();\\n            }\\n\\t\\t\\t// move to next node\\n            current = current->children[s[i]];\\n        }\\n\\t\\t// make it leaf node\\n        current->isLeaf = true;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        TrieNode* trie = new TrieNode();\\n        for(int i=0;i<words.size();i++) {\\n\\t\\t\\t// adding all words to trie\\n            trie->insert(words[i]);\\n        }\\n\\t\\t// visited 2d vector for dfs\\n        vector<vector<bool>> visited;\\n        for(int i=0;i<board.size();i++) {\\n            vector<bool> v;\\n            for(int j=0;j<board[0].size();j++) {\\n                v.push_back(false);\\n            }\\n            visited.push_back(v);\\n        }\\n\\t\\t// find first matching character and call dfs\\n        for(int i=0;i<board.size();i++) {\\n            for(int j=0;j<board[0].size();j++) {\\n                if(trie->children.find(board[i][j]) != trie->children.end()) {\\n                    visited[i][j] = true;\\n                    dfs(trie->children[board[i][j]],board,i,j,visited);\\n\\t\\t\\t\\t\\t//set visited false for the next word\\n                    visited[i][j] = false;\\n                }\\n            }\\n        }\\n        vector<string> foundStrings;\\n        addFoundStrings(foundStrings,\"\",trie);\\n        return foundStrings;\\n    }\\n\\t// add all strings with found == true\\n    void addFoundStrings(vector<string>& foundStrings,string s,TrieNode* trie) {\\n        if(trie->isLeaf == true && trie->found == true) {\\n            foundStrings.push_back(s);\\n        }\\n        for(auto it = trie->children.begin();it!= trie->children.end();it++) {\\n            addFoundStrings(foundStrings,s+it->first,it->second);\\n        }\\n    }\\n\\t// to check if we are out of the board or not\\n    bool isSafe(int i,int j,vector<vector<char>>& board) {\\n        if(i>=0 && j>=0 && i<board.size() && j<board[0].size()) \\n            return true;\\n        return false;\\n    }\\n    void dfs(TrieNode* trie,vector<vector<char>>& board,int i,int j,vector<vector<bool>> visited) {\\n        if(trie->isLeaf == true) {\\n\\t\\t\\t// setting found\\n            trie->found = true;\\n        }\\n\\t\\t// adjacent moves\\n        int x[] = {1,0,-1,0};\\n        int y[] = {0,1,0,-1};\\n        for(int k=0;k<4;k++) {\\n            int newi = i + x[k];\\n            int newj = j + y[k];\\n\\t\\t\\t// first check i,j to be safe then check if they are visited and then check if child exists for this character\\n            if(isSafe(newi,newj,board) && !visited[newi][newj] && trie->children.find(board[newi][newj]) != trie->children.end()) {\\n                visited[newi][newj] = true;\\n                dfs(trie->children[board[newi][newj]],board,newi,newj,visited);\\n                //set visited false for the next word\\n\\t\\t\\t\\tvisited[newi][newj] = false;\\n            }\\n        }\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\n//Trie Node Class\\nclass TrieNode{\\n    public:\\n\\t// To Store Child Nodes\\n    unordered_map<char,TrieNode*> children;\\n    bool isLeaf;\\n    // To check if found\\n\\tbool found;\\n    TrieNode() {\\n        isLeaf = false;\\n        found = false;\\n    }\\n    void insert(string s) {\\n        TrieNode* current = this;\\n        for(int i=0;i<s.length();i++) {\\n\\t\\t\\t// if node doesnt exist\\n            if(current->children.find(s[i]) == current->children.end()){\\n                current->children[s[i]] = new TrieNode();\\n            }\\n\\t\\t\\t// move to next node\\n            current = current->children[s[i]];\\n        }\\n\\t\\t// make it leaf node\\n        current->isLeaf = true;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        TrieNode* trie = new TrieNode();\\n        for(int i=0;i<words.size();i++) {\\n\\t\\t\\t// adding all words to trie\\n            trie->insert(words[i]);\\n        }\\n\\t\\t// visited 2d vector for dfs\\n        vector<vector<bool>> visited;\\n        for(int i=0;i<board.size();i++) {\\n            vector<bool> v;\\n            for(int j=0;j<board[0].size();j++) {\\n                v.push_back(false);\\n            }\\n            visited.push_back(v);\\n        }\\n\\t\\t// find first matching character and call dfs\\n        for(int i=0;i<board.size();i++) {\\n            for(int j=0;j<board[0].size();j++) {\\n                if(trie->children.find(board[i][j]) != trie->children.end()) {\\n                    visited[i][j] = true;\\n                    dfs(trie->children[board[i][j]],board,i,j,visited);\\n\\t\\t\\t\\t\\t//set visited false for the next word\\n                    visited[i][j] = false;\\n                }\\n            }\\n        }\\n        vector<string> foundStrings;\\n        addFoundStrings(foundStrings,\"\",trie);\\n        return foundStrings;\\n    }\\n\\t// add all strings with found == true\\n    void addFoundStrings(vector<string>& foundStrings,string s,TrieNode* trie) {\\n        if(trie->isLeaf == true && trie->found == true) {\\n            foundStrings.push_back(s);\\n        }\\n        for(auto it = trie->children.begin();it!= trie->children.end();it++) {\\n            addFoundStrings(foundStrings,s+it->first,it->second);\\n        }\\n    }\\n\\t// to check if we are out of the board or not\\n    bool isSafe(int i,int j,vector<vector<char>>& board) {\\n        if(i>=0 && j>=0 && i<board.size() && j<board[0].size()) \\n            return true;\\n        return false;\\n    }\\n    void dfs(TrieNode* trie,vector<vector<char>>& board,int i,int j,vector<vector<bool>> visited) {\\n        if(trie->isLeaf == true) {\\n\\t\\t\\t// setting found\\n            trie->found = true;\\n        }\\n\\t\\t// adjacent moves\\n        int x[] = {1,0,-1,0};\\n        int y[] = {0,1,0,-1};\\n        for(int k=0;k<4;k++) {\\n            int newi = i + x[k];\\n            int newj = j + y[k];\\n\\t\\t\\t// first check i,j to be safe then check if they are visited and then check if child exists for this character\\n            if(isSafe(newi,newj,board) && !visited[newi][newj] && trie->children.find(board[newi][newj]) != trie->children.end()) {\\n                visited[newi][newj] = true;\\n                dfs(trie->children[board[newi][newj]],board,newi,newj,visited);\\n                //set visited false for the next word\\n\\t\\t\\t\\tvisited[newi][newj] = false;\\n            }\\n        }\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 745010,
                "title": "swift-minimal-solution-with-dfs-and-trie-with-complexity-analysis-100",
                "content": "Let \\nm,n be the width and height of the 2D array\\nL be the average length of words in \"words\"\\nW be the number of words\\n\\n1. *result*: takes O(W) space\\n2. *buildTrie()*: takes O(LW) runtime and O(LW) space\\n3. going through every cell takes O(mn) runtime\\n4. *check():* at each cell, we *check* until we either reach all possible leaf nodes OR reach the end of the board (in case one word is longer than the size of the board) => takes O(min(LW, mn)) runtime,  O(L) call stack space\\n\\nIn total,\\n**Time: O(mn * min(LW, mn) + LW), Space: O(LW)**\\nor simpler: **Time: O(mn * LW), Space: O(LW)**\\n\\n\\n```\\nclass TrieNode {\\n\\tvar word: String?\\n\\tvar children = [Character: TrieNode]()\\n}\\n\\nfunc findWords(_ board: [[Character]], _ words: [String]) -> [String] {\\n\\tif board.isEmpty { return [] }\\n\\n\\tvar result = [String]()\\n\\tvar board = board\\n\\tlet root = buildTrie(with: words)\\n\\n\\tfor i in 0..<board.count {\\n\\t\\tfor j in 0..<board[0].count {\\n\\t\\t\\tcheck(&board, i, j, root, &result)\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n\\nfunc buildTrie(with words: [String]) -> TrieNode {\\n\\tlet root = TrieNode()\\n\\n\\tfor word in words {\\n\\t\\tvar node = root\\n\\t\\tfor char in word {\\n\\t\\t\\tif node.children[char] == nil{\\n\\t\\t\\t\\tnode.children[char] = TrieNode()\\n\\t\\t\\t}\\n\\t\\t\\tnode = node.children[char]!\\n\\t\\t}\\n\\t\\tnode.word = word\\n\\t}\\n\\n\\treturn root\\n}\\n\\nfunc check(_ board: inout [[Character]], _ i: Int, _ j: Int, _ node: TrieNode, _ result: inout [String]) {\\n\\tif i < 0 || j < 0 || i >= board.count || j >= board[0].count { return }\\n\\tguard let currNode = node.children[board[i][j]] else { return }\\n\\n\\tif let word = currNode.word { \\n\\t\\tresult.append(word) \\n\\t\\tcurrNode.word = nil\\n\\t}\\n\\tlet char = board[i][j]\\n\\tboard[i][j] = \"0\"\\n\\n\\tcheck(&board, i - 1, j, currNode, &result)\\n\\tcheck(&board, i + 1, j, currNode, &result)\\n\\tcheck(&board, i, j - 1, currNode, &result)\\n\\tcheck(&board, i, j + 1, currNode, &result)\\n\\tboard[i][j] = char\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode {\\n\\tvar word: String?\\n\\tvar children = [Character: TrieNode]()\\n}\\n\\nfunc findWords(_ board: [[Character]], _ words: [String]) -> [String] {\\n\\tif board.isEmpty { return [] }\\n\\n\\tvar result = [String]()\\n\\tvar board = board\\n\\tlet root = buildTrie(with: words)\\n\\n\\tfor i in 0..<board.count {\\n\\t\\tfor j in 0..<board[0].count {\\n\\t\\t\\tcheck(&board, i, j, root, &result)\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n\\nfunc buildTrie(with words: [String]) -> TrieNode {\\n\\tlet root = TrieNode()\\n\\n\\tfor word in words {\\n\\t\\tvar node = root\\n\\t\\tfor char in word {\\n\\t\\t\\tif node.children[char] == nil{\\n\\t\\t\\t\\tnode.children[char] = TrieNode()\\n\\t\\t\\t}\\n\\t\\t\\tnode = node.children[char]!\\n\\t\\t}\\n\\t\\tnode.word = word\\n\\t}\\n\\n\\treturn root\\n}\\n\\nfunc check(_ board: inout [[Character]], _ i: Int, _ j: Int, _ node: TrieNode, _ result: inout [String]) {\\n\\tif i < 0 || j < 0 || i >= board.count || j >= board[0].count { return }\\n\\tguard let currNode = node.children[board[i][j]] else { return }\\n\\n\\tif let word = currNode.word { \\n\\t\\tresult.append(word) \\n\\t\\tcurrNode.word = nil\\n\\t}\\n\\tlet char = board[i][j]\\n\\tboard[i][j] = \"0\"\\n\\n\\tcheck(&board, i - 1, j, currNode, &result)\\n\\tcheck(&board, i + 1, j, currNode, &result)\\n\\tcheck(&board, i, j - 1, currNode, &result)\\n\\tcheck(&board, i, j + 1, currNode, &result)\\n\\tboard[i][j] = char\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1576003,
                "content": [
                    {
                        "username": "okinawa",
                        "content": "This question is the reason I lost Uber interview.\\nRead the solution well guys and don\\'t be in my position \\uD83D\\uDE13"
                    },
                    {
                        "username": "arjun202",
                        "content": "which region was it for ? Was it India or somewhere else?"
                    },
                    {
                        "username": "palakons",
                        "content": "finally avoid TLE with Trie (with capability to remove)\\nthe last eight hours has been fun"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Lol \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "bonagirimahaveer",
                        "content": "\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "\\uD83D\\uDC80"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seriously. So frustrating. I had the optimal algorithm pretty quickly, but it still TLE'd. Then I spent hours trying to figure out which optimization to apply.\n\nI finally figured out how to implemented removal, and it immediately passed. It didn't even help that much on the test case I TLE'd on. It was probably a cumulative thing where it helped a little on each test case."
                    },
                    {
                        "username": "ahmdsolmn",
                        "content": "I believe the description of this problem should be changed to clearly explain that the output should not contain duplicate words."
                    },
                    {
                        "username": "shamoonmohd",
                        "content": "Yeah in question it says that you can\\'t use same character in a word again, but official testcase fails if you do so,\\ninstead it should be no repeated word in the result."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I feel like the question description can be more explicit instead of making us discover certain requirements (no duplicates etc) on our own."
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am trying to understand the time complexity of searching one single word (forget about tires and so).\\n\\nSo if we have a \\n- One single word of lenght = l   \\n- A boar of M x N. \\nUsingl DFS with 4 directions to search for that word, what should be the time complexity??\\n\\nM * N * 4^l?\\nM * N *  M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI hvae seen all those different complexities for the same code\\nIf you can help to clarify that would be great!\\n"
                    },
                    {
                        "username": "JackingChen",
                        "content": "I think it\\'s the worst case of dfs times the board size. Please correct me if I have missed anything"
                    },
                    {
                        "username": "palakons",
                        "content": "[@shyam-2002](/shyam-2002) good thing I mention \"big oh\", lol. just kidding, yours will be a more conservative (better) estimate"
                    },
                    {
                        "username": "shyam-2002",
                        "content": "It will be m*n*3^l as you wouldn\\'t go in the direction from where you have come."
                    },
                    {
                        "username": "palakons",
                        "content": "M * N * 4^l  for single word with length l"
                    },
                    {
                        "username": "mickey3d",
                        "content": "The problem statement implies that you have to put words into a Trie and run DFS on the adjacent letters on board, with checking if given DFS iteration backtracked solution is included in a Trie, built with words.\\n\\nI was trying to do vise versa and ended up with time-exceeded error, cos if you try to build a Trie with all combinations of adjacent letter on the board, you end up with really big Trie and instant search. The majority of time is spent building Trie and few last leetcode tests time out during this stage.\\n\\nThere is tradeoff b/w search time of dfs based on the board info (leetcode accepted)  and time spent on building Trie based on board letters (leetcode does not accept this solution)."
                    },
                    {
                        "username": "anwei40",
                        "content": "Wondered about that - in the case of relatively small grid, relatively big dictionary, it\\'s still faster to build a board Trie and search words instead of the accepted way."
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "[@charant587](/charant587) \\n\\nThis is problematic\\n\\n```py\\ndef remove(self, word):\\n    cur = self\\n    cur.refs -= 1\\n    for c in word:\\n        if c in cur.children:\\n            cur = cur.children[c]\\n            cur.refs -= 1\\n```\\n\\nlet\\'s say c isn\\'t in cur.children, what happens? cur doesn\\'t change and it checks if the next c is in cur. This could potentially result in cur.refs being wrong for multiple curs. \\n\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "bro can you tell me please why this code is not giving output                                                                                            class TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I guess can\\'t avoid Trie anymore."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen man... I thought I could avoid it too "
                    },
                    {
                        "username": "icehcamp",
                        "content": "Input:\\t[\"a\"], [\"a\",\"a\"]\\nOutput:\\t[\"a\",\"a\"]\\nExpected:\\t[\"a\"]\\n\\nNot quite sure why this output is incorrect. Can someone help clarify the question."
                    },
                    {
                        "username": "Finesse",
                        "content": "The result must contain each of the `words` at most once"
                    },
                    {
                        "username": "Praval791",
                        "content": "Cause \"a\" is uniquely present in words and your answer tells that there are 2 \"a\" words.\\nYou have to delete your string from trie after successully finding it."
                    },
                    {
                        "username": "scy_2020",
                        "content": "I have thought the Trie to build the board and use words to query the Trie. The time complexity is exponential. So I gave up. Then for the standard solution of this question, which is backtrack + Trie, the complexity should be exponential as well since the dfs tree size is O(4^n). I am wondering during the interview, whether it is  a good solution or not???\\n\\nThanks in advance."
                    },
                    {
                        "username": "palakons",
                        "content": "I am not sure, but I think a huge help would be pruning (i.e., removing the visited word from trie) That would make search space shrinks as the search goes on"
                    },
                    {
                        "username": "chui",
                        "content": "In the description, it says the longest word length will be 10. If you also keep getting TLE, maybe try this trick, works for mine."
                    }
                ]
            },
            {
                "id": 1671852,
                "content": [
                    {
                        "username": "okinawa",
                        "content": "This question is the reason I lost Uber interview.\\nRead the solution well guys and don\\'t be in my position \\uD83D\\uDE13"
                    },
                    {
                        "username": "arjun202",
                        "content": "which region was it for ? Was it India or somewhere else?"
                    },
                    {
                        "username": "palakons",
                        "content": "finally avoid TLE with Trie (with capability to remove)\\nthe last eight hours has been fun"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Lol \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "bonagirimahaveer",
                        "content": "\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "\\uD83D\\uDC80"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seriously. So frustrating. I had the optimal algorithm pretty quickly, but it still TLE'd. Then I spent hours trying to figure out which optimization to apply.\n\nI finally figured out how to implemented removal, and it immediately passed. It didn't even help that much on the test case I TLE'd on. It was probably a cumulative thing where it helped a little on each test case."
                    },
                    {
                        "username": "ahmdsolmn",
                        "content": "I believe the description of this problem should be changed to clearly explain that the output should not contain duplicate words."
                    },
                    {
                        "username": "shamoonmohd",
                        "content": "Yeah in question it says that you can\\'t use same character in a word again, but official testcase fails if you do so,\\ninstead it should be no repeated word in the result."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I feel like the question description can be more explicit instead of making us discover certain requirements (no duplicates etc) on our own."
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am trying to understand the time complexity of searching one single word (forget about tires and so).\\n\\nSo if we have a \\n- One single word of lenght = l   \\n- A boar of M x N. \\nUsingl DFS with 4 directions to search for that word, what should be the time complexity??\\n\\nM * N * 4^l?\\nM * N *  M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI hvae seen all those different complexities for the same code\\nIf you can help to clarify that would be great!\\n"
                    },
                    {
                        "username": "JackingChen",
                        "content": "I think it\\'s the worst case of dfs times the board size. Please correct me if I have missed anything"
                    },
                    {
                        "username": "palakons",
                        "content": "[@shyam-2002](/shyam-2002) good thing I mention \"big oh\", lol. just kidding, yours will be a more conservative (better) estimate"
                    },
                    {
                        "username": "shyam-2002",
                        "content": "It will be m*n*3^l as you wouldn\\'t go in the direction from where you have come."
                    },
                    {
                        "username": "palakons",
                        "content": "M * N * 4^l  for single word with length l"
                    },
                    {
                        "username": "mickey3d",
                        "content": "The problem statement implies that you have to put words into a Trie and run DFS on the adjacent letters on board, with checking if given DFS iteration backtracked solution is included in a Trie, built with words.\\n\\nI was trying to do vise versa and ended up with time-exceeded error, cos if you try to build a Trie with all combinations of adjacent letter on the board, you end up with really big Trie and instant search. The majority of time is spent building Trie and few last leetcode tests time out during this stage.\\n\\nThere is tradeoff b/w search time of dfs based on the board info (leetcode accepted)  and time spent on building Trie based on board letters (leetcode does not accept this solution)."
                    },
                    {
                        "username": "anwei40",
                        "content": "Wondered about that - in the case of relatively small grid, relatively big dictionary, it\\'s still faster to build a board Trie and search words instead of the accepted way."
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "[@charant587](/charant587) \\n\\nThis is problematic\\n\\n```py\\ndef remove(self, word):\\n    cur = self\\n    cur.refs -= 1\\n    for c in word:\\n        if c in cur.children:\\n            cur = cur.children[c]\\n            cur.refs -= 1\\n```\\n\\nlet\\'s say c isn\\'t in cur.children, what happens? cur doesn\\'t change and it checks if the next c is in cur. This could potentially result in cur.refs being wrong for multiple curs. \\n\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "bro can you tell me please why this code is not giving output                                                                                            class TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I guess can\\'t avoid Trie anymore."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen man... I thought I could avoid it too "
                    },
                    {
                        "username": "icehcamp",
                        "content": "Input:\\t[\"a\"], [\"a\",\"a\"]\\nOutput:\\t[\"a\",\"a\"]\\nExpected:\\t[\"a\"]\\n\\nNot quite sure why this output is incorrect. Can someone help clarify the question."
                    },
                    {
                        "username": "Finesse",
                        "content": "The result must contain each of the `words` at most once"
                    },
                    {
                        "username": "Praval791",
                        "content": "Cause \"a\" is uniquely present in words and your answer tells that there are 2 \"a\" words.\\nYou have to delete your string from trie after successully finding it."
                    },
                    {
                        "username": "scy_2020",
                        "content": "I have thought the Trie to build the board and use words to query the Trie. The time complexity is exponential. So I gave up. Then for the standard solution of this question, which is backtrack + Trie, the complexity should be exponential as well since the dfs tree size is O(4^n). I am wondering during the interview, whether it is  a good solution or not???\\n\\nThanks in advance."
                    },
                    {
                        "username": "palakons",
                        "content": "I am not sure, but I think a huge help would be pruning (i.e., removing the visited word from trie) That would make search space shrinks as the search goes on"
                    },
                    {
                        "username": "chui",
                        "content": "In the description, it says the longest word length will be 10. If you also keep getting TLE, maybe try this trick, works for mine."
                    }
                ]
            },
            {
                "id": 1671886,
                "content": [
                    {
                        "username": "okinawa",
                        "content": "This question is the reason I lost Uber interview.\\nRead the solution well guys and don\\'t be in my position \\uD83D\\uDE13"
                    },
                    {
                        "username": "arjun202",
                        "content": "which region was it for ? Was it India or somewhere else?"
                    },
                    {
                        "username": "palakons",
                        "content": "finally avoid TLE with Trie (with capability to remove)\\nthe last eight hours has been fun"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Lol \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "bonagirimahaveer",
                        "content": "\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "\\uD83D\\uDC80"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seriously. So frustrating. I had the optimal algorithm pretty quickly, but it still TLE'd. Then I spent hours trying to figure out which optimization to apply.\n\nI finally figured out how to implemented removal, and it immediately passed. It didn't even help that much on the test case I TLE'd on. It was probably a cumulative thing where it helped a little on each test case."
                    },
                    {
                        "username": "ahmdsolmn",
                        "content": "I believe the description of this problem should be changed to clearly explain that the output should not contain duplicate words."
                    },
                    {
                        "username": "shamoonmohd",
                        "content": "Yeah in question it says that you can\\'t use same character in a word again, but official testcase fails if you do so,\\ninstead it should be no repeated word in the result."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I feel like the question description can be more explicit instead of making us discover certain requirements (no duplicates etc) on our own."
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am trying to understand the time complexity of searching one single word (forget about tires and so).\\n\\nSo if we have a \\n- One single word of lenght = l   \\n- A boar of M x N. \\nUsingl DFS with 4 directions to search for that word, what should be the time complexity??\\n\\nM * N * 4^l?\\nM * N *  M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI hvae seen all those different complexities for the same code\\nIf you can help to clarify that would be great!\\n"
                    },
                    {
                        "username": "JackingChen",
                        "content": "I think it\\'s the worst case of dfs times the board size. Please correct me if I have missed anything"
                    },
                    {
                        "username": "palakons",
                        "content": "[@shyam-2002](/shyam-2002) good thing I mention \"big oh\", lol. just kidding, yours will be a more conservative (better) estimate"
                    },
                    {
                        "username": "shyam-2002",
                        "content": "It will be m*n*3^l as you wouldn\\'t go in the direction from where you have come."
                    },
                    {
                        "username": "palakons",
                        "content": "M * N * 4^l  for single word with length l"
                    },
                    {
                        "username": "mickey3d",
                        "content": "The problem statement implies that you have to put words into a Trie and run DFS on the adjacent letters on board, with checking if given DFS iteration backtracked solution is included in a Trie, built with words.\\n\\nI was trying to do vise versa and ended up with time-exceeded error, cos if you try to build a Trie with all combinations of adjacent letter on the board, you end up with really big Trie and instant search. The majority of time is spent building Trie and few last leetcode tests time out during this stage.\\n\\nThere is tradeoff b/w search time of dfs based on the board info (leetcode accepted)  and time spent on building Trie based on board letters (leetcode does not accept this solution)."
                    },
                    {
                        "username": "anwei40",
                        "content": "Wondered about that - in the case of relatively small grid, relatively big dictionary, it\\'s still faster to build a board Trie and search words instead of the accepted way."
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "[@charant587](/charant587) \\n\\nThis is problematic\\n\\n```py\\ndef remove(self, word):\\n    cur = self\\n    cur.refs -= 1\\n    for c in word:\\n        if c in cur.children:\\n            cur = cur.children[c]\\n            cur.refs -= 1\\n```\\n\\nlet\\'s say c isn\\'t in cur.children, what happens? cur doesn\\'t change and it checks if the next c is in cur. This could potentially result in cur.refs being wrong for multiple curs. \\n\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "bro can you tell me please why this code is not giving output                                                                                            class TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I guess can\\'t avoid Trie anymore."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen man... I thought I could avoid it too "
                    },
                    {
                        "username": "icehcamp",
                        "content": "Input:\\t[\"a\"], [\"a\",\"a\"]\\nOutput:\\t[\"a\",\"a\"]\\nExpected:\\t[\"a\"]\\n\\nNot quite sure why this output is incorrect. Can someone help clarify the question."
                    },
                    {
                        "username": "Finesse",
                        "content": "The result must contain each of the `words` at most once"
                    },
                    {
                        "username": "Praval791",
                        "content": "Cause \"a\" is uniquely present in words and your answer tells that there are 2 \"a\" words.\\nYou have to delete your string from trie after successully finding it."
                    },
                    {
                        "username": "scy_2020",
                        "content": "I have thought the Trie to build the board and use words to query the Trie. The time complexity is exponential. So I gave up. Then for the standard solution of this question, which is backtrack + Trie, the complexity should be exponential as well since the dfs tree size is O(4^n). I am wondering during the interview, whether it is  a good solution or not???\\n\\nThanks in advance."
                    },
                    {
                        "username": "palakons",
                        "content": "I am not sure, but I think a huge help would be pruning (i.e., removing the visited word from trie) That would make search space shrinks as the search goes on"
                    },
                    {
                        "username": "chui",
                        "content": "In the description, it says the longest word length will be 10. If you also keep getting TLE, maybe try this trick, works for mine."
                    }
                ]
            },
            {
                "id": 1672262,
                "content": [
                    {
                        "username": "okinawa",
                        "content": "This question is the reason I lost Uber interview.\\nRead the solution well guys and don\\'t be in my position \\uD83D\\uDE13"
                    },
                    {
                        "username": "arjun202",
                        "content": "which region was it for ? Was it India or somewhere else?"
                    },
                    {
                        "username": "palakons",
                        "content": "finally avoid TLE with Trie (with capability to remove)\\nthe last eight hours has been fun"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Lol \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "bonagirimahaveer",
                        "content": "\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "\\uD83D\\uDC80"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seriously. So frustrating. I had the optimal algorithm pretty quickly, but it still TLE'd. Then I spent hours trying to figure out which optimization to apply.\n\nI finally figured out how to implemented removal, and it immediately passed. It didn't even help that much on the test case I TLE'd on. It was probably a cumulative thing where it helped a little on each test case."
                    },
                    {
                        "username": "ahmdsolmn",
                        "content": "I believe the description of this problem should be changed to clearly explain that the output should not contain duplicate words."
                    },
                    {
                        "username": "shamoonmohd",
                        "content": "Yeah in question it says that you can\\'t use same character in a word again, but official testcase fails if you do so,\\ninstead it should be no repeated word in the result."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I feel like the question description can be more explicit instead of making us discover certain requirements (no duplicates etc) on our own."
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am trying to understand the time complexity of searching one single word (forget about tires and so).\\n\\nSo if we have a \\n- One single word of lenght = l   \\n- A boar of M x N. \\nUsingl DFS with 4 directions to search for that word, what should be the time complexity??\\n\\nM * N * 4^l?\\nM * N *  M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI hvae seen all those different complexities for the same code\\nIf you can help to clarify that would be great!\\n"
                    },
                    {
                        "username": "JackingChen",
                        "content": "I think it\\'s the worst case of dfs times the board size. Please correct me if I have missed anything"
                    },
                    {
                        "username": "palakons",
                        "content": "[@shyam-2002](/shyam-2002) good thing I mention \"big oh\", lol. just kidding, yours will be a more conservative (better) estimate"
                    },
                    {
                        "username": "shyam-2002",
                        "content": "It will be m*n*3^l as you wouldn\\'t go in the direction from where you have come."
                    },
                    {
                        "username": "palakons",
                        "content": "M * N * 4^l  for single word with length l"
                    },
                    {
                        "username": "mickey3d",
                        "content": "The problem statement implies that you have to put words into a Trie and run DFS on the adjacent letters on board, with checking if given DFS iteration backtracked solution is included in a Trie, built with words.\\n\\nI was trying to do vise versa and ended up with time-exceeded error, cos if you try to build a Trie with all combinations of adjacent letter on the board, you end up with really big Trie and instant search. The majority of time is spent building Trie and few last leetcode tests time out during this stage.\\n\\nThere is tradeoff b/w search time of dfs based on the board info (leetcode accepted)  and time spent on building Trie based on board letters (leetcode does not accept this solution)."
                    },
                    {
                        "username": "anwei40",
                        "content": "Wondered about that - in the case of relatively small grid, relatively big dictionary, it\\'s still faster to build a board Trie and search words instead of the accepted way."
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "[@charant587](/charant587) \\n\\nThis is problematic\\n\\n```py\\ndef remove(self, word):\\n    cur = self\\n    cur.refs -= 1\\n    for c in word:\\n        if c in cur.children:\\n            cur = cur.children[c]\\n            cur.refs -= 1\\n```\\n\\nlet\\'s say c isn\\'t in cur.children, what happens? cur doesn\\'t change and it checks if the next c is in cur. This could potentially result in cur.refs being wrong for multiple curs. \\n\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "bro can you tell me please why this code is not giving output                                                                                            class TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I guess can\\'t avoid Trie anymore."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen man... I thought I could avoid it too "
                    },
                    {
                        "username": "icehcamp",
                        "content": "Input:\\t[\"a\"], [\"a\",\"a\"]\\nOutput:\\t[\"a\",\"a\"]\\nExpected:\\t[\"a\"]\\n\\nNot quite sure why this output is incorrect. Can someone help clarify the question."
                    },
                    {
                        "username": "Finesse",
                        "content": "The result must contain each of the `words` at most once"
                    },
                    {
                        "username": "Praval791",
                        "content": "Cause \"a\" is uniquely present in words and your answer tells that there are 2 \"a\" words.\\nYou have to delete your string from trie after successully finding it."
                    },
                    {
                        "username": "scy_2020",
                        "content": "I have thought the Trie to build the board and use words to query the Trie. The time complexity is exponential. So I gave up. Then for the standard solution of this question, which is backtrack + Trie, the complexity should be exponential as well since the dfs tree size is O(4^n). I am wondering during the interview, whether it is  a good solution or not???\\n\\nThanks in advance."
                    },
                    {
                        "username": "palakons",
                        "content": "I am not sure, but I think a huge help would be pruning (i.e., removing the visited word from trie) That would make search space shrinks as the search goes on"
                    },
                    {
                        "username": "chui",
                        "content": "In the description, it says the longest word length will be 10. If you also keep getting TLE, maybe try this trick, works for mine."
                    }
                ]
            },
            {
                "id": 1566849,
                "content": [
                    {
                        "username": "okinawa",
                        "content": "This question is the reason I lost Uber interview.\\nRead the solution well guys and don\\'t be in my position \\uD83D\\uDE13"
                    },
                    {
                        "username": "arjun202",
                        "content": "which region was it for ? Was it India or somewhere else?"
                    },
                    {
                        "username": "palakons",
                        "content": "finally avoid TLE with Trie (with capability to remove)\\nthe last eight hours has been fun"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Lol \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "bonagirimahaveer",
                        "content": "\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "\\uD83D\\uDC80"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seriously. So frustrating. I had the optimal algorithm pretty quickly, but it still TLE'd. Then I spent hours trying to figure out which optimization to apply.\n\nI finally figured out how to implemented removal, and it immediately passed. It didn't even help that much on the test case I TLE'd on. It was probably a cumulative thing where it helped a little on each test case."
                    },
                    {
                        "username": "ahmdsolmn",
                        "content": "I believe the description of this problem should be changed to clearly explain that the output should not contain duplicate words."
                    },
                    {
                        "username": "shamoonmohd",
                        "content": "Yeah in question it says that you can\\'t use same character in a word again, but official testcase fails if you do so,\\ninstead it should be no repeated word in the result."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I feel like the question description can be more explicit instead of making us discover certain requirements (no duplicates etc) on our own."
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am trying to understand the time complexity of searching one single word (forget about tires and so).\\n\\nSo if we have a \\n- One single word of lenght = l   \\n- A boar of M x N. \\nUsingl DFS with 4 directions to search for that word, what should be the time complexity??\\n\\nM * N * 4^l?\\nM * N *  M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI hvae seen all those different complexities for the same code\\nIf you can help to clarify that would be great!\\n"
                    },
                    {
                        "username": "JackingChen",
                        "content": "I think it\\'s the worst case of dfs times the board size. Please correct me if I have missed anything"
                    },
                    {
                        "username": "palakons",
                        "content": "[@shyam-2002](/shyam-2002) good thing I mention \"big oh\", lol. just kidding, yours will be a more conservative (better) estimate"
                    },
                    {
                        "username": "shyam-2002",
                        "content": "It will be m*n*3^l as you wouldn\\'t go in the direction from where you have come."
                    },
                    {
                        "username": "palakons",
                        "content": "M * N * 4^l  for single word with length l"
                    },
                    {
                        "username": "mickey3d",
                        "content": "The problem statement implies that you have to put words into a Trie and run DFS on the adjacent letters on board, with checking if given DFS iteration backtracked solution is included in a Trie, built with words.\\n\\nI was trying to do vise versa and ended up with time-exceeded error, cos if you try to build a Trie with all combinations of adjacent letter on the board, you end up with really big Trie and instant search. The majority of time is spent building Trie and few last leetcode tests time out during this stage.\\n\\nThere is tradeoff b/w search time of dfs based on the board info (leetcode accepted)  and time spent on building Trie based on board letters (leetcode does not accept this solution)."
                    },
                    {
                        "username": "anwei40",
                        "content": "Wondered about that - in the case of relatively small grid, relatively big dictionary, it\\'s still faster to build a board Trie and search words instead of the accepted way."
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "[@charant587](/charant587) \\n\\nThis is problematic\\n\\n```py\\ndef remove(self, word):\\n    cur = self\\n    cur.refs -= 1\\n    for c in word:\\n        if c in cur.children:\\n            cur = cur.children[c]\\n            cur.refs -= 1\\n```\\n\\nlet\\'s say c isn\\'t in cur.children, what happens? cur doesn\\'t change and it checks if the next c is in cur. This could potentially result in cur.refs being wrong for multiple curs. \\n\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "bro can you tell me please why this code is not giving output                                                                                            class TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I guess can\\'t avoid Trie anymore."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen man... I thought I could avoid it too "
                    },
                    {
                        "username": "icehcamp",
                        "content": "Input:\\t[\"a\"], [\"a\",\"a\"]\\nOutput:\\t[\"a\",\"a\"]\\nExpected:\\t[\"a\"]\\n\\nNot quite sure why this output is incorrect. Can someone help clarify the question."
                    },
                    {
                        "username": "Finesse",
                        "content": "The result must contain each of the `words` at most once"
                    },
                    {
                        "username": "Praval791",
                        "content": "Cause \"a\" is uniquely present in words and your answer tells that there are 2 \"a\" words.\\nYou have to delete your string from trie after successully finding it."
                    },
                    {
                        "username": "scy_2020",
                        "content": "I have thought the Trie to build the board and use words to query the Trie. The time complexity is exponential. So I gave up. Then for the standard solution of this question, which is backtrack + Trie, the complexity should be exponential as well since the dfs tree size is O(4^n). I am wondering during the interview, whether it is  a good solution or not???\\n\\nThanks in advance."
                    },
                    {
                        "username": "palakons",
                        "content": "I am not sure, but I think a huge help would be pruning (i.e., removing the visited word from trie) That would make search space shrinks as the search goes on"
                    },
                    {
                        "username": "chui",
                        "content": "In the description, it says the longest word length will be 10. If you also keep getting TLE, maybe try this trick, works for mine."
                    }
                ]
            },
            {
                "id": 1574381,
                "content": [
                    {
                        "username": "okinawa",
                        "content": "This question is the reason I lost Uber interview.\\nRead the solution well guys and don\\'t be in my position \\uD83D\\uDE13"
                    },
                    {
                        "username": "arjun202",
                        "content": "which region was it for ? Was it India or somewhere else?"
                    },
                    {
                        "username": "palakons",
                        "content": "finally avoid TLE with Trie (with capability to remove)\\nthe last eight hours has been fun"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Lol \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "bonagirimahaveer",
                        "content": "\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "\\uD83D\\uDC80"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seriously. So frustrating. I had the optimal algorithm pretty quickly, but it still TLE'd. Then I spent hours trying to figure out which optimization to apply.\n\nI finally figured out how to implemented removal, and it immediately passed. It didn't even help that much on the test case I TLE'd on. It was probably a cumulative thing where it helped a little on each test case."
                    },
                    {
                        "username": "ahmdsolmn",
                        "content": "I believe the description of this problem should be changed to clearly explain that the output should not contain duplicate words."
                    },
                    {
                        "username": "shamoonmohd",
                        "content": "Yeah in question it says that you can\\'t use same character in a word again, but official testcase fails if you do so,\\ninstead it should be no repeated word in the result."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I feel like the question description can be more explicit instead of making us discover certain requirements (no duplicates etc) on our own."
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am trying to understand the time complexity of searching one single word (forget about tires and so).\\n\\nSo if we have a \\n- One single word of lenght = l   \\n- A boar of M x N. \\nUsingl DFS with 4 directions to search for that word, what should be the time complexity??\\n\\nM * N * 4^l?\\nM * N *  M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI hvae seen all those different complexities for the same code\\nIf you can help to clarify that would be great!\\n"
                    },
                    {
                        "username": "JackingChen",
                        "content": "I think it\\'s the worst case of dfs times the board size. Please correct me if I have missed anything"
                    },
                    {
                        "username": "palakons",
                        "content": "[@shyam-2002](/shyam-2002) good thing I mention \"big oh\", lol. just kidding, yours will be a more conservative (better) estimate"
                    },
                    {
                        "username": "shyam-2002",
                        "content": "It will be m*n*3^l as you wouldn\\'t go in the direction from where you have come."
                    },
                    {
                        "username": "palakons",
                        "content": "M * N * 4^l  for single word with length l"
                    },
                    {
                        "username": "mickey3d",
                        "content": "The problem statement implies that you have to put words into a Trie and run DFS on the adjacent letters on board, with checking if given DFS iteration backtracked solution is included in a Trie, built with words.\\n\\nI was trying to do vise versa and ended up with time-exceeded error, cos if you try to build a Trie with all combinations of adjacent letter on the board, you end up with really big Trie and instant search. The majority of time is spent building Trie and few last leetcode tests time out during this stage.\\n\\nThere is tradeoff b/w search time of dfs based on the board info (leetcode accepted)  and time spent on building Trie based on board letters (leetcode does not accept this solution)."
                    },
                    {
                        "username": "anwei40",
                        "content": "Wondered about that - in the case of relatively small grid, relatively big dictionary, it\\'s still faster to build a board Trie and search words instead of the accepted way."
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "[@charant587](/charant587) \\n\\nThis is problematic\\n\\n```py\\ndef remove(self, word):\\n    cur = self\\n    cur.refs -= 1\\n    for c in word:\\n        if c in cur.children:\\n            cur = cur.children[c]\\n            cur.refs -= 1\\n```\\n\\nlet\\'s say c isn\\'t in cur.children, what happens? cur doesn\\'t change and it checks if the next c is in cur. This could potentially result in cur.refs being wrong for multiple curs. \\n\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "bro can you tell me please why this code is not giving output                                                                                            class TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I guess can\\'t avoid Trie anymore."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen man... I thought I could avoid it too "
                    },
                    {
                        "username": "icehcamp",
                        "content": "Input:\\t[\"a\"], [\"a\",\"a\"]\\nOutput:\\t[\"a\",\"a\"]\\nExpected:\\t[\"a\"]\\n\\nNot quite sure why this output is incorrect. Can someone help clarify the question."
                    },
                    {
                        "username": "Finesse",
                        "content": "The result must contain each of the `words` at most once"
                    },
                    {
                        "username": "Praval791",
                        "content": "Cause \"a\" is uniquely present in words and your answer tells that there are 2 \"a\" words.\\nYou have to delete your string from trie after successully finding it."
                    },
                    {
                        "username": "scy_2020",
                        "content": "I have thought the Trie to build the board and use words to query the Trie. The time complexity is exponential. So I gave up. Then for the standard solution of this question, which is backtrack + Trie, the complexity should be exponential as well since the dfs tree size is O(4^n). I am wondering during the interview, whether it is  a good solution or not???\\n\\nThanks in advance."
                    },
                    {
                        "username": "palakons",
                        "content": "I am not sure, but I think a huge help would be pruning (i.e., removing the visited word from trie) That would make search space shrinks as the search goes on"
                    },
                    {
                        "username": "chui",
                        "content": "In the description, it says the longest word length will be 10. If you also keep getting TLE, maybe try this trick, works for mine."
                    }
                ]
            },
            {
                "id": 1676645,
                "content": [
                    {
                        "username": "okinawa",
                        "content": "This question is the reason I lost Uber interview.\\nRead the solution well guys and don\\'t be in my position \\uD83D\\uDE13"
                    },
                    {
                        "username": "arjun202",
                        "content": "which region was it for ? Was it India or somewhere else?"
                    },
                    {
                        "username": "palakons",
                        "content": "finally avoid TLE with Trie (with capability to remove)\\nthe last eight hours has been fun"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Lol \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "bonagirimahaveer",
                        "content": "\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "\\uD83D\\uDC80"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seriously. So frustrating. I had the optimal algorithm pretty quickly, but it still TLE'd. Then I spent hours trying to figure out which optimization to apply.\n\nI finally figured out how to implemented removal, and it immediately passed. It didn't even help that much on the test case I TLE'd on. It was probably a cumulative thing where it helped a little on each test case."
                    },
                    {
                        "username": "ahmdsolmn",
                        "content": "I believe the description of this problem should be changed to clearly explain that the output should not contain duplicate words."
                    },
                    {
                        "username": "shamoonmohd",
                        "content": "Yeah in question it says that you can\\'t use same character in a word again, but official testcase fails if you do so,\\ninstead it should be no repeated word in the result."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I feel like the question description can be more explicit instead of making us discover certain requirements (no duplicates etc) on our own."
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am trying to understand the time complexity of searching one single word (forget about tires and so).\\n\\nSo if we have a \\n- One single word of lenght = l   \\n- A boar of M x N. \\nUsingl DFS with 4 directions to search for that word, what should be the time complexity??\\n\\nM * N * 4^l?\\nM * N *  M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI hvae seen all those different complexities for the same code\\nIf you can help to clarify that would be great!\\n"
                    },
                    {
                        "username": "JackingChen",
                        "content": "I think it\\'s the worst case of dfs times the board size. Please correct me if I have missed anything"
                    },
                    {
                        "username": "palakons",
                        "content": "[@shyam-2002](/shyam-2002) good thing I mention \"big oh\", lol. just kidding, yours will be a more conservative (better) estimate"
                    },
                    {
                        "username": "shyam-2002",
                        "content": "It will be m*n*3^l as you wouldn\\'t go in the direction from where you have come."
                    },
                    {
                        "username": "palakons",
                        "content": "M * N * 4^l  for single word with length l"
                    },
                    {
                        "username": "mickey3d",
                        "content": "The problem statement implies that you have to put words into a Trie and run DFS on the adjacent letters on board, with checking if given DFS iteration backtracked solution is included in a Trie, built with words.\\n\\nI was trying to do vise versa and ended up with time-exceeded error, cos if you try to build a Trie with all combinations of adjacent letter on the board, you end up with really big Trie and instant search. The majority of time is spent building Trie and few last leetcode tests time out during this stage.\\n\\nThere is tradeoff b/w search time of dfs based on the board info (leetcode accepted)  and time spent on building Trie based on board letters (leetcode does not accept this solution)."
                    },
                    {
                        "username": "anwei40",
                        "content": "Wondered about that - in the case of relatively small grid, relatively big dictionary, it\\'s still faster to build a board Trie and search words instead of the accepted way."
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "[@charant587](/charant587) \\n\\nThis is problematic\\n\\n```py\\ndef remove(self, word):\\n    cur = self\\n    cur.refs -= 1\\n    for c in word:\\n        if c in cur.children:\\n            cur = cur.children[c]\\n            cur.refs -= 1\\n```\\n\\nlet\\'s say c isn\\'t in cur.children, what happens? cur doesn\\'t change and it checks if the next c is in cur. This could potentially result in cur.refs being wrong for multiple curs. \\n\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "bro can you tell me please why this code is not giving output                                                                                            class TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I guess can\\'t avoid Trie anymore."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen man... I thought I could avoid it too "
                    },
                    {
                        "username": "icehcamp",
                        "content": "Input:\\t[\"a\"], [\"a\",\"a\"]\\nOutput:\\t[\"a\",\"a\"]\\nExpected:\\t[\"a\"]\\n\\nNot quite sure why this output is incorrect. Can someone help clarify the question."
                    },
                    {
                        "username": "Finesse",
                        "content": "The result must contain each of the `words` at most once"
                    },
                    {
                        "username": "Praval791",
                        "content": "Cause \"a\" is uniquely present in words and your answer tells that there are 2 \"a\" words.\\nYou have to delete your string from trie after successully finding it."
                    },
                    {
                        "username": "scy_2020",
                        "content": "I have thought the Trie to build the board and use words to query the Trie. The time complexity is exponential. So I gave up. Then for the standard solution of this question, which is backtrack + Trie, the complexity should be exponential as well since the dfs tree size is O(4^n). I am wondering during the interview, whether it is  a good solution or not???\\n\\nThanks in advance."
                    },
                    {
                        "username": "palakons",
                        "content": "I am not sure, but I think a huge help would be pruning (i.e., removing the visited word from trie) That would make search space shrinks as the search goes on"
                    },
                    {
                        "username": "chui",
                        "content": "In the description, it says the longest word length will be 10. If you also keep getting TLE, maybe try this trick, works for mine."
                    }
                ]
            },
            {
                "id": 1567225,
                "content": [
                    {
                        "username": "okinawa",
                        "content": "This question is the reason I lost Uber interview.\\nRead the solution well guys and don\\'t be in my position \\uD83D\\uDE13"
                    },
                    {
                        "username": "arjun202",
                        "content": "which region was it for ? Was it India or somewhere else?"
                    },
                    {
                        "username": "palakons",
                        "content": "finally avoid TLE with Trie (with capability to remove)\\nthe last eight hours has been fun"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Lol \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "bonagirimahaveer",
                        "content": "\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "\\uD83D\\uDC80"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seriously. So frustrating. I had the optimal algorithm pretty quickly, but it still TLE'd. Then I spent hours trying to figure out which optimization to apply.\n\nI finally figured out how to implemented removal, and it immediately passed. It didn't even help that much on the test case I TLE'd on. It was probably a cumulative thing where it helped a little on each test case."
                    },
                    {
                        "username": "ahmdsolmn",
                        "content": "I believe the description of this problem should be changed to clearly explain that the output should not contain duplicate words."
                    },
                    {
                        "username": "shamoonmohd",
                        "content": "Yeah in question it says that you can\\'t use same character in a word again, but official testcase fails if you do so,\\ninstead it should be no repeated word in the result."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I feel like the question description can be more explicit instead of making us discover certain requirements (no duplicates etc) on our own."
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am trying to understand the time complexity of searching one single word (forget about tires and so).\\n\\nSo if we have a \\n- One single word of lenght = l   \\n- A boar of M x N. \\nUsingl DFS with 4 directions to search for that word, what should be the time complexity??\\n\\nM * N * 4^l?\\nM * N *  M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI hvae seen all those different complexities for the same code\\nIf you can help to clarify that would be great!\\n"
                    },
                    {
                        "username": "JackingChen",
                        "content": "I think it\\'s the worst case of dfs times the board size. Please correct me if I have missed anything"
                    },
                    {
                        "username": "palakons",
                        "content": "[@shyam-2002](/shyam-2002) good thing I mention \"big oh\", lol. just kidding, yours will be a more conservative (better) estimate"
                    },
                    {
                        "username": "shyam-2002",
                        "content": "It will be m*n*3^l as you wouldn\\'t go in the direction from where you have come."
                    },
                    {
                        "username": "palakons",
                        "content": "M * N * 4^l  for single word with length l"
                    },
                    {
                        "username": "mickey3d",
                        "content": "The problem statement implies that you have to put words into a Trie and run DFS on the adjacent letters on board, with checking if given DFS iteration backtracked solution is included in a Trie, built with words.\\n\\nI was trying to do vise versa and ended up with time-exceeded error, cos if you try to build a Trie with all combinations of adjacent letter on the board, you end up with really big Trie and instant search. The majority of time is spent building Trie and few last leetcode tests time out during this stage.\\n\\nThere is tradeoff b/w search time of dfs based on the board info (leetcode accepted)  and time spent on building Trie based on board letters (leetcode does not accept this solution)."
                    },
                    {
                        "username": "anwei40",
                        "content": "Wondered about that - in the case of relatively small grid, relatively big dictionary, it\\'s still faster to build a board Trie and search words instead of the accepted way."
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "[@charant587](/charant587) \\n\\nThis is problematic\\n\\n```py\\ndef remove(self, word):\\n    cur = self\\n    cur.refs -= 1\\n    for c in word:\\n        if c in cur.children:\\n            cur = cur.children[c]\\n            cur.refs -= 1\\n```\\n\\nlet\\'s say c isn\\'t in cur.children, what happens? cur doesn\\'t change and it checks if the next c is in cur. This could potentially result in cur.refs being wrong for multiple curs. \\n\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "bro can you tell me please why this code is not giving output                                                                                            class TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I guess can\\'t avoid Trie anymore."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen man... I thought I could avoid it too "
                    },
                    {
                        "username": "icehcamp",
                        "content": "Input:\\t[\"a\"], [\"a\",\"a\"]\\nOutput:\\t[\"a\",\"a\"]\\nExpected:\\t[\"a\"]\\n\\nNot quite sure why this output is incorrect. Can someone help clarify the question."
                    },
                    {
                        "username": "Finesse",
                        "content": "The result must contain each of the `words` at most once"
                    },
                    {
                        "username": "Praval791",
                        "content": "Cause \"a\" is uniquely present in words and your answer tells that there are 2 \"a\" words.\\nYou have to delete your string from trie after successully finding it."
                    },
                    {
                        "username": "scy_2020",
                        "content": "I have thought the Trie to build the board and use words to query the Trie. The time complexity is exponential. So I gave up. Then for the standard solution of this question, which is backtrack + Trie, the complexity should be exponential as well since the dfs tree size is O(4^n). I am wondering during the interview, whether it is  a good solution or not???\\n\\nThanks in advance."
                    },
                    {
                        "username": "palakons",
                        "content": "I am not sure, but I think a huge help would be pruning (i.e., removing the visited word from trie) That would make search space shrinks as the search goes on"
                    },
                    {
                        "username": "chui",
                        "content": "In the description, it says the longest word length will be 10. If you also keep getting TLE, maybe try this trick, works for mine."
                    }
                ]
            },
            {
                "id": 1566535,
                "content": [
                    {
                        "username": "okinawa",
                        "content": "This question is the reason I lost Uber interview.\\nRead the solution well guys and don\\'t be in my position \\uD83D\\uDE13"
                    },
                    {
                        "username": "arjun202",
                        "content": "which region was it for ? Was it India or somewhere else?"
                    },
                    {
                        "username": "palakons",
                        "content": "finally avoid TLE with Trie (with capability to remove)\\nthe last eight hours has been fun"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Lol \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "bonagirimahaveer",
                        "content": "\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "\\uD83D\\uDC80"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seriously. So frustrating. I had the optimal algorithm pretty quickly, but it still TLE'd. Then I spent hours trying to figure out which optimization to apply.\n\nI finally figured out how to implemented removal, and it immediately passed. It didn't even help that much on the test case I TLE'd on. It was probably a cumulative thing where it helped a little on each test case."
                    },
                    {
                        "username": "ahmdsolmn",
                        "content": "I believe the description of this problem should be changed to clearly explain that the output should not contain duplicate words."
                    },
                    {
                        "username": "shamoonmohd",
                        "content": "Yeah in question it says that you can\\'t use same character in a word again, but official testcase fails if you do so,\\ninstead it should be no repeated word in the result."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I feel like the question description can be more explicit instead of making us discover certain requirements (no duplicates etc) on our own."
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am trying to understand the time complexity of searching one single word (forget about tires and so).\\n\\nSo if we have a \\n- One single word of lenght = l   \\n- A boar of M x N. \\nUsingl DFS with 4 directions to search for that word, what should be the time complexity??\\n\\nM * N * 4^l?\\nM * N *  M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI hvae seen all those different complexities for the same code\\nIf you can help to clarify that would be great!\\n"
                    },
                    {
                        "username": "JackingChen",
                        "content": "I think it\\'s the worst case of dfs times the board size. Please correct me if I have missed anything"
                    },
                    {
                        "username": "palakons",
                        "content": "[@shyam-2002](/shyam-2002) good thing I mention \"big oh\", lol. just kidding, yours will be a more conservative (better) estimate"
                    },
                    {
                        "username": "shyam-2002",
                        "content": "It will be m*n*3^l as you wouldn\\'t go in the direction from where you have come."
                    },
                    {
                        "username": "palakons",
                        "content": "M * N * 4^l  for single word with length l"
                    },
                    {
                        "username": "mickey3d",
                        "content": "The problem statement implies that you have to put words into a Trie and run DFS on the adjacent letters on board, with checking if given DFS iteration backtracked solution is included in a Trie, built with words.\\n\\nI was trying to do vise versa and ended up with time-exceeded error, cos if you try to build a Trie with all combinations of adjacent letter on the board, you end up with really big Trie and instant search. The majority of time is spent building Trie and few last leetcode tests time out during this stage.\\n\\nThere is tradeoff b/w search time of dfs based on the board info (leetcode accepted)  and time spent on building Trie based on board letters (leetcode does not accept this solution)."
                    },
                    {
                        "username": "anwei40",
                        "content": "Wondered about that - in the case of relatively small grid, relatively big dictionary, it\\'s still faster to build a board Trie and search words instead of the accepted way."
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "[@charant587](/charant587) \\n\\nThis is problematic\\n\\n```py\\ndef remove(self, word):\\n    cur = self\\n    cur.refs -= 1\\n    for c in word:\\n        if c in cur.children:\\n            cur = cur.children[c]\\n            cur.refs -= 1\\n```\\n\\nlet\\'s say c isn\\'t in cur.children, what happens? cur doesn\\'t change and it checks if the next c is in cur. This could potentially result in cur.refs being wrong for multiple curs. \\n\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "bro can you tell me please why this code is not giving output                                                                                            class TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I guess can\\'t avoid Trie anymore."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen man... I thought I could avoid it too "
                    },
                    {
                        "username": "icehcamp",
                        "content": "Input:\\t[\"a\"], [\"a\",\"a\"]\\nOutput:\\t[\"a\",\"a\"]\\nExpected:\\t[\"a\"]\\n\\nNot quite sure why this output is incorrect. Can someone help clarify the question."
                    },
                    {
                        "username": "Finesse",
                        "content": "The result must contain each of the `words` at most once"
                    },
                    {
                        "username": "Praval791",
                        "content": "Cause \"a\" is uniquely present in words and your answer tells that there are 2 \"a\" words.\\nYou have to delete your string from trie after successully finding it."
                    },
                    {
                        "username": "scy_2020",
                        "content": "I have thought the Trie to build the board and use words to query the Trie. The time complexity is exponential. So I gave up. Then for the standard solution of this question, which is backtrack + Trie, the complexity should be exponential as well since the dfs tree size is O(4^n). I am wondering during the interview, whether it is  a good solution or not???\\n\\nThanks in advance."
                    },
                    {
                        "username": "palakons",
                        "content": "I am not sure, but I think a huge help would be pruning (i.e., removing the visited word from trie) That would make search space shrinks as the search goes on"
                    },
                    {
                        "username": "chui",
                        "content": "In the description, it says the longest word length will be 10. If you also keep getting TLE, maybe try this trick, works for mine."
                    }
                ]
            },
            {
                "id": 1570400,
                "content": [
                    {
                        "username": "okinawa",
                        "content": "This question is the reason I lost Uber interview.\\nRead the solution well guys and don\\'t be in my position \\uD83D\\uDE13"
                    },
                    {
                        "username": "arjun202",
                        "content": "which region was it for ? Was it India or somewhere else?"
                    },
                    {
                        "username": "palakons",
                        "content": "finally avoid TLE with Trie (with capability to remove)\\nthe last eight hours has been fun"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Lol \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "bonagirimahaveer",
                        "content": "\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "\\uD83D\\uDC80"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seriously. So frustrating. I had the optimal algorithm pretty quickly, but it still TLE'd. Then I spent hours trying to figure out which optimization to apply.\n\nI finally figured out how to implemented removal, and it immediately passed. It didn't even help that much on the test case I TLE'd on. It was probably a cumulative thing where it helped a little on each test case."
                    },
                    {
                        "username": "ahmdsolmn",
                        "content": "I believe the description of this problem should be changed to clearly explain that the output should not contain duplicate words."
                    },
                    {
                        "username": "shamoonmohd",
                        "content": "Yeah in question it says that you can\\'t use same character in a word again, but official testcase fails if you do so,\\ninstead it should be no repeated word in the result."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I feel like the question description can be more explicit instead of making us discover certain requirements (no duplicates etc) on our own."
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am trying to understand the time complexity of searching one single word (forget about tires and so).\\n\\nSo if we have a \\n- One single word of lenght = l   \\n- A boar of M x N. \\nUsingl DFS with 4 directions to search for that word, what should be the time complexity??\\n\\nM * N * 4^l?\\nM * N *  M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI hvae seen all those different complexities for the same code\\nIf you can help to clarify that would be great!\\n"
                    },
                    {
                        "username": "JackingChen",
                        "content": "I think it\\'s the worst case of dfs times the board size. Please correct me if I have missed anything"
                    },
                    {
                        "username": "palakons",
                        "content": "[@shyam-2002](/shyam-2002) good thing I mention \"big oh\", lol. just kidding, yours will be a more conservative (better) estimate"
                    },
                    {
                        "username": "shyam-2002",
                        "content": "It will be m*n*3^l as you wouldn\\'t go in the direction from where you have come."
                    },
                    {
                        "username": "palakons",
                        "content": "M * N * 4^l  for single word with length l"
                    },
                    {
                        "username": "mickey3d",
                        "content": "The problem statement implies that you have to put words into a Trie and run DFS on the adjacent letters on board, with checking if given DFS iteration backtracked solution is included in a Trie, built with words.\\n\\nI was trying to do vise versa and ended up with time-exceeded error, cos if you try to build a Trie with all combinations of adjacent letter on the board, you end up with really big Trie and instant search. The majority of time is spent building Trie and few last leetcode tests time out during this stage.\\n\\nThere is tradeoff b/w search time of dfs based on the board info (leetcode accepted)  and time spent on building Trie based on board letters (leetcode does not accept this solution)."
                    },
                    {
                        "username": "anwei40",
                        "content": "Wondered about that - in the case of relatively small grid, relatively big dictionary, it\\'s still faster to build a board Trie and search words instead of the accepted way."
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "[@charant587](/charant587) \\n\\nThis is problematic\\n\\n```py\\ndef remove(self, word):\\n    cur = self\\n    cur.refs -= 1\\n    for c in word:\\n        if c in cur.children:\\n            cur = cur.children[c]\\n            cur.refs -= 1\\n```\\n\\nlet\\'s say c isn\\'t in cur.children, what happens? cur doesn\\'t change and it checks if the next c is in cur. This could potentially result in cur.refs being wrong for multiple curs. \\n\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "bro can you tell me please why this code is not giving output                                                                                            class TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I guess can\\'t avoid Trie anymore."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen man... I thought I could avoid it too "
                    },
                    {
                        "username": "icehcamp",
                        "content": "Input:\\t[\"a\"], [\"a\",\"a\"]\\nOutput:\\t[\"a\",\"a\"]\\nExpected:\\t[\"a\"]\\n\\nNot quite sure why this output is incorrect. Can someone help clarify the question."
                    },
                    {
                        "username": "Finesse",
                        "content": "The result must contain each of the `words` at most once"
                    },
                    {
                        "username": "Praval791",
                        "content": "Cause \"a\" is uniquely present in words and your answer tells that there are 2 \"a\" words.\\nYou have to delete your string from trie after successully finding it."
                    },
                    {
                        "username": "scy_2020",
                        "content": "I have thought the Trie to build the board and use words to query the Trie. The time complexity is exponential. So I gave up. Then for the standard solution of this question, which is backtrack + Trie, the complexity should be exponential as well since the dfs tree size is O(4^n). I am wondering during the interview, whether it is  a good solution or not???\\n\\nThanks in advance."
                    },
                    {
                        "username": "palakons",
                        "content": "I am not sure, but I think a huge help would be pruning (i.e., removing the visited word from trie) That would make search space shrinks as the search goes on"
                    },
                    {
                        "username": "chui",
                        "content": "In the description, it says the longest word length will be 10. If you also keep getting TLE, maybe try this trick, works for mine."
                    }
                ]
            },
            {
                "id": 1576003,
                "content": [
                    {
                        "username": "okinawa",
                        "content": "This question is the reason I lost Uber interview.\\nRead the solution well guys and don\\'t be in my position \\uD83D\\uDE13"
                    },
                    {
                        "username": "arjun202",
                        "content": "which region was it for ? Was it India or somewhere else?"
                    },
                    {
                        "username": "palakons",
                        "content": "finally avoid TLE with Trie (with capability to remove)\\nthe last eight hours has been fun"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Lol \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "bonagirimahaveer",
                        "content": "\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "\\uD83D\\uDC80"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seriously. So frustrating. I had the optimal algorithm pretty quickly, but it still TLE'd. Then I spent hours trying to figure out which optimization to apply.\n\nI finally figured out how to implemented removal, and it immediately passed. It didn't even help that much on the test case I TLE'd on. It was probably a cumulative thing where it helped a little on each test case."
                    },
                    {
                        "username": "ahmdsolmn",
                        "content": "I believe the description of this problem should be changed to clearly explain that the output should not contain duplicate words."
                    },
                    {
                        "username": "shamoonmohd",
                        "content": "Yeah in question it says that you can\\'t use same character in a word again, but official testcase fails if you do so,\\ninstead it should be no repeated word in the result."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I feel like the question description can be more explicit instead of making us discover certain requirements (no duplicates etc) on our own."
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am trying to understand the time complexity of searching one single word (forget about tires and so).\\n\\nSo if we have a \\n- One single word of lenght = l   \\n- A boar of M x N. \\nUsingl DFS with 4 directions to search for that word, what should be the time complexity??\\n\\nM * N * 4^l?\\nM * N *  M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI hvae seen all those different complexities for the same code\\nIf you can help to clarify that would be great!\\n"
                    },
                    {
                        "username": "JackingChen",
                        "content": "I think it\\'s the worst case of dfs times the board size. Please correct me if I have missed anything"
                    },
                    {
                        "username": "palakons",
                        "content": "[@shyam-2002](/shyam-2002) good thing I mention \"big oh\", lol. just kidding, yours will be a more conservative (better) estimate"
                    },
                    {
                        "username": "shyam-2002",
                        "content": "It will be m*n*3^l as you wouldn\\'t go in the direction from where you have come."
                    },
                    {
                        "username": "palakons",
                        "content": "M * N * 4^l  for single word with length l"
                    },
                    {
                        "username": "mickey3d",
                        "content": "The problem statement implies that you have to put words into a Trie and run DFS on the adjacent letters on board, with checking if given DFS iteration backtracked solution is included in a Trie, built with words.\\n\\nI was trying to do vise versa and ended up with time-exceeded error, cos if you try to build a Trie with all combinations of adjacent letter on the board, you end up with really big Trie and instant search. The majority of time is spent building Trie and few last leetcode tests time out during this stage.\\n\\nThere is tradeoff b/w search time of dfs based on the board info (leetcode accepted)  and time spent on building Trie based on board letters (leetcode does not accept this solution)."
                    },
                    {
                        "username": "anwei40",
                        "content": "Wondered about that - in the case of relatively small grid, relatively big dictionary, it\\'s still faster to build a board Trie and search words instead of the accepted way."
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "[@charant587](/charant587) \\n\\nThis is problematic\\n\\n```py\\ndef remove(self, word):\\n    cur = self\\n    cur.refs -= 1\\n    for c in word:\\n        if c in cur.children:\\n            cur = cur.children[c]\\n            cur.refs -= 1\\n```\\n\\nlet\\'s say c isn\\'t in cur.children, what happens? cur doesn\\'t change and it checks if the next c is in cur. This could potentially result in cur.refs being wrong for multiple curs. \\n\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "bro can you tell me please why this code is not giving output                                                                                            class TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I guess can\\'t avoid Trie anymore."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen man... I thought I could avoid it too "
                    },
                    {
                        "username": "icehcamp",
                        "content": "Input:\\t[\"a\"], [\"a\",\"a\"]\\nOutput:\\t[\"a\",\"a\"]\\nExpected:\\t[\"a\"]\\n\\nNot quite sure why this output is incorrect. Can someone help clarify the question."
                    },
                    {
                        "username": "Finesse",
                        "content": "The result must contain each of the `words` at most once"
                    },
                    {
                        "username": "Praval791",
                        "content": "Cause \"a\" is uniquely present in words and your answer tells that there are 2 \"a\" words.\\nYou have to delete your string from trie after successully finding it."
                    },
                    {
                        "username": "scy_2020",
                        "content": "I have thought the Trie to build the board and use words to query the Trie. The time complexity is exponential. So I gave up. Then for the standard solution of this question, which is backtrack + Trie, the complexity should be exponential as well since the dfs tree size is O(4^n). I am wondering during the interview, whether it is  a good solution or not???\\n\\nThanks in advance."
                    },
                    {
                        "username": "palakons",
                        "content": "I am not sure, but I think a huge help would be pruning (i.e., removing the visited word from trie) That would make search space shrinks as the search goes on"
                    },
                    {
                        "username": "chui",
                        "content": "In the description, it says the longest word length will be 10. If you also keep getting TLE, maybe try this trick, works for mine."
                    }
                ]
            },
            {
                "id": 1671852,
                "content": [
                    {
                        "username": "okinawa",
                        "content": "This question is the reason I lost Uber interview.\\nRead the solution well guys and don\\'t be in my position \\uD83D\\uDE13"
                    },
                    {
                        "username": "arjun202",
                        "content": "which region was it for ? Was it India or somewhere else?"
                    },
                    {
                        "username": "palakons",
                        "content": "finally avoid TLE with Trie (with capability to remove)\\nthe last eight hours has been fun"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Lol \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "bonagirimahaveer",
                        "content": "\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "\\uD83D\\uDC80"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seriously. So frustrating. I had the optimal algorithm pretty quickly, but it still TLE'd. Then I spent hours trying to figure out which optimization to apply.\n\nI finally figured out how to implemented removal, and it immediately passed. It didn't even help that much on the test case I TLE'd on. It was probably a cumulative thing where it helped a little on each test case."
                    },
                    {
                        "username": "ahmdsolmn",
                        "content": "I believe the description of this problem should be changed to clearly explain that the output should not contain duplicate words."
                    },
                    {
                        "username": "shamoonmohd",
                        "content": "Yeah in question it says that you can\\'t use same character in a word again, but official testcase fails if you do so,\\ninstead it should be no repeated word in the result."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I feel like the question description can be more explicit instead of making us discover certain requirements (no duplicates etc) on our own."
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am trying to understand the time complexity of searching one single word (forget about tires and so).\\n\\nSo if we have a \\n- One single word of lenght = l   \\n- A boar of M x N. \\nUsingl DFS with 4 directions to search for that word, what should be the time complexity??\\n\\nM * N * 4^l?\\nM * N *  M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI hvae seen all those different complexities for the same code\\nIf you can help to clarify that would be great!\\n"
                    },
                    {
                        "username": "JackingChen",
                        "content": "I think it\\'s the worst case of dfs times the board size. Please correct me if I have missed anything"
                    },
                    {
                        "username": "palakons",
                        "content": "[@shyam-2002](/shyam-2002) good thing I mention \"big oh\", lol. just kidding, yours will be a more conservative (better) estimate"
                    },
                    {
                        "username": "shyam-2002",
                        "content": "It will be m*n*3^l as you wouldn\\'t go in the direction from where you have come."
                    },
                    {
                        "username": "palakons",
                        "content": "M * N * 4^l  for single word with length l"
                    },
                    {
                        "username": "mickey3d",
                        "content": "The problem statement implies that you have to put words into a Trie and run DFS on the adjacent letters on board, with checking if given DFS iteration backtracked solution is included in a Trie, built with words.\\n\\nI was trying to do vise versa and ended up with time-exceeded error, cos if you try to build a Trie with all combinations of adjacent letter on the board, you end up with really big Trie and instant search. The majority of time is spent building Trie and few last leetcode tests time out during this stage.\\n\\nThere is tradeoff b/w search time of dfs based on the board info (leetcode accepted)  and time spent on building Trie based on board letters (leetcode does not accept this solution)."
                    },
                    {
                        "username": "anwei40",
                        "content": "Wondered about that - in the case of relatively small grid, relatively big dictionary, it\\'s still faster to build a board Trie and search words instead of the accepted way."
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "[@charant587](/charant587) \\n\\nThis is problematic\\n\\n```py\\ndef remove(self, word):\\n    cur = self\\n    cur.refs -= 1\\n    for c in word:\\n        if c in cur.children:\\n            cur = cur.children[c]\\n            cur.refs -= 1\\n```\\n\\nlet\\'s say c isn\\'t in cur.children, what happens? cur doesn\\'t change and it checks if the next c is in cur. This could potentially result in cur.refs being wrong for multiple curs. \\n\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "bro can you tell me please why this code is not giving output                                                                                            class TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I guess can\\'t avoid Trie anymore."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen man... I thought I could avoid it too "
                    },
                    {
                        "username": "icehcamp",
                        "content": "Input:\\t[\"a\"], [\"a\",\"a\"]\\nOutput:\\t[\"a\",\"a\"]\\nExpected:\\t[\"a\"]\\n\\nNot quite sure why this output is incorrect. Can someone help clarify the question."
                    },
                    {
                        "username": "Finesse",
                        "content": "The result must contain each of the `words` at most once"
                    },
                    {
                        "username": "Praval791",
                        "content": "Cause \"a\" is uniquely present in words and your answer tells that there are 2 \"a\" words.\\nYou have to delete your string from trie after successully finding it."
                    },
                    {
                        "username": "scy_2020",
                        "content": "I have thought the Trie to build the board and use words to query the Trie. The time complexity is exponential. So I gave up. Then for the standard solution of this question, which is backtrack + Trie, the complexity should be exponential as well since the dfs tree size is O(4^n). I am wondering during the interview, whether it is  a good solution or not???\\n\\nThanks in advance."
                    },
                    {
                        "username": "palakons",
                        "content": "I am not sure, but I think a huge help would be pruning (i.e., removing the visited word from trie) That would make search space shrinks as the search goes on"
                    },
                    {
                        "username": "chui",
                        "content": "In the description, it says the longest word length will be 10. If you also keep getting TLE, maybe try this trick, works for mine."
                    }
                ]
            },
            {
                "id": 1671886,
                "content": [
                    {
                        "username": "okinawa",
                        "content": "This question is the reason I lost Uber interview.\\nRead the solution well guys and don\\'t be in my position \\uD83D\\uDE13"
                    },
                    {
                        "username": "arjun202",
                        "content": "which region was it for ? Was it India or somewhere else?"
                    },
                    {
                        "username": "palakons",
                        "content": "finally avoid TLE with Trie (with capability to remove)\\nthe last eight hours has been fun"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Lol \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "bonagirimahaveer",
                        "content": "\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "\\uD83D\\uDC80"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seriously. So frustrating. I had the optimal algorithm pretty quickly, but it still TLE'd. Then I spent hours trying to figure out which optimization to apply.\n\nI finally figured out how to implemented removal, and it immediately passed. It didn't even help that much on the test case I TLE'd on. It was probably a cumulative thing where it helped a little on each test case."
                    },
                    {
                        "username": "ahmdsolmn",
                        "content": "I believe the description of this problem should be changed to clearly explain that the output should not contain duplicate words."
                    },
                    {
                        "username": "shamoonmohd",
                        "content": "Yeah in question it says that you can\\'t use same character in a word again, but official testcase fails if you do so,\\ninstead it should be no repeated word in the result."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I feel like the question description can be more explicit instead of making us discover certain requirements (no duplicates etc) on our own."
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am trying to understand the time complexity of searching one single word (forget about tires and so).\\n\\nSo if we have a \\n- One single word of lenght = l   \\n- A boar of M x N. \\nUsingl DFS with 4 directions to search for that word, what should be the time complexity??\\n\\nM * N * 4^l?\\nM * N *  M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI hvae seen all those different complexities for the same code\\nIf you can help to clarify that would be great!\\n"
                    },
                    {
                        "username": "JackingChen",
                        "content": "I think it\\'s the worst case of dfs times the board size. Please correct me if I have missed anything"
                    },
                    {
                        "username": "palakons",
                        "content": "[@shyam-2002](/shyam-2002) good thing I mention \"big oh\", lol. just kidding, yours will be a more conservative (better) estimate"
                    },
                    {
                        "username": "shyam-2002",
                        "content": "It will be m*n*3^l as you wouldn\\'t go in the direction from where you have come."
                    },
                    {
                        "username": "palakons",
                        "content": "M * N * 4^l  for single word with length l"
                    },
                    {
                        "username": "mickey3d",
                        "content": "The problem statement implies that you have to put words into a Trie and run DFS on the adjacent letters on board, with checking if given DFS iteration backtracked solution is included in a Trie, built with words.\\n\\nI was trying to do vise versa and ended up with time-exceeded error, cos if you try to build a Trie with all combinations of adjacent letter on the board, you end up with really big Trie and instant search. The majority of time is spent building Trie and few last leetcode tests time out during this stage.\\n\\nThere is tradeoff b/w search time of dfs based on the board info (leetcode accepted)  and time spent on building Trie based on board letters (leetcode does not accept this solution)."
                    },
                    {
                        "username": "anwei40",
                        "content": "Wondered about that - in the case of relatively small grid, relatively big dictionary, it\\'s still faster to build a board Trie and search words instead of the accepted way."
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "[@charant587](/charant587) \\n\\nThis is problematic\\n\\n```py\\ndef remove(self, word):\\n    cur = self\\n    cur.refs -= 1\\n    for c in word:\\n        if c in cur.children:\\n            cur = cur.children[c]\\n            cur.refs -= 1\\n```\\n\\nlet\\'s say c isn\\'t in cur.children, what happens? cur doesn\\'t change and it checks if the next c is in cur. This could potentially result in cur.refs being wrong for multiple curs. \\n\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "bro can you tell me please why this code is not giving output                                                                                            class TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I guess can\\'t avoid Trie anymore."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen man... I thought I could avoid it too "
                    },
                    {
                        "username": "icehcamp",
                        "content": "Input:\\t[\"a\"], [\"a\",\"a\"]\\nOutput:\\t[\"a\",\"a\"]\\nExpected:\\t[\"a\"]\\n\\nNot quite sure why this output is incorrect. Can someone help clarify the question."
                    },
                    {
                        "username": "Finesse",
                        "content": "The result must contain each of the `words` at most once"
                    },
                    {
                        "username": "Praval791",
                        "content": "Cause \"a\" is uniquely present in words and your answer tells that there are 2 \"a\" words.\\nYou have to delete your string from trie after successully finding it."
                    },
                    {
                        "username": "scy_2020",
                        "content": "I have thought the Trie to build the board and use words to query the Trie. The time complexity is exponential. So I gave up. Then for the standard solution of this question, which is backtrack + Trie, the complexity should be exponential as well since the dfs tree size is O(4^n). I am wondering during the interview, whether it is  a good solution or not???\\n\\nThanks in advance."
                    },
                    {
                        "username": "palakons",
                        "content": "I am not sure, but I think a huge help would be pruning (i.e., removing the visited word from trie) That would make search space shrinks as the search goes on"
                    },
                    {
                        "username": "chui",
                        "content": "In the description, it says the longest word length will be 10. If you also keep getting TLE, maybe try this trick, works for mine."
                    }
                ]
            },
            {
                "id": 1672262,
                "content": [
                    {
                        "username": "okinawa",
                        "content": "This question is the reason I lost Uber interview.\\nRead the solution well guys and don\\'t be in my position \\uD83D\\uDE13"
                    },
                    {
                        "username": "arjun202",
                        "content": "which region was it for ? Was it India or somewhere else?"
                    },
                    {
                        "username": "palakons",
                        "content": "finally avoid TLE with Trie (with capability to remove)\\nthe last eight hours has been fun"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Lol \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "bonagirimahaveer",
                        "content": "\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "\\uD83D\\uDC80"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seriously. So frustrating. I had the optimal algorithm pretty quickly, but it still TLE'd. Then I spent hours trying to figure out which optimization to apply.\n\nI finally figured out how to implemented removal, and it immediately passed. It didn't even help that much on the test case I TLE'd on. It was probably a cumulative thing where it helped a little on each test case."
                    },
                    {
                        "username": "ahmdsolmn",
                        "content": "I believe the description of this problem should be changed to clearly explain that the output should not contain duplicate words."
                    },
                    {
                        "username": "shamoonmohd",
                        "content": "Yeah in question it says that you can\\'t use same character in a word again, but official testcase fails if you do so,\\ninstead it should be no repeated word in the result."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I feel like the question description can be more explicit instead of making us discover certain requirements (no duplicates etc) on our own."
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am trying to understand the time complexity of searching one single word (forget about tires and so).\\n\\nSo if we have a \\n- One single word of lenght = l   \\n- A boar of M x N. \\nUsingl DFS with 4 directions to search for that word, what should be the time complexity??\\n\\nM * N * 4^l?\\nM * N *  M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI hvae seen all those different complexities for the same code\\nIf you can help to clarify that would be great!\\n"
                    },
                    {
                        "username": "JackingChen",
                        "content": "I think it\\'s the worst case of dfs times the board size. Please correct me if I have missed anything"
                    },
                    {
                        "username": "palakons",
                        "content": "[@shyam-2002](/shyam-2002) good thing I mention \"big oh\", lol. just kidding, yours will be a more conservative (better) estimate"
                    },
                    {
                        "username": "shyam-2002",
                        "content": "It will be m*n*3^l as you wouldn\\'t go in the direction from where you have come."
                    },
                    {
                        "username": "palakons",
                        "content": "M * N * 4^l  for single word with length l"
                    },
                    {
                        "username": "mickey3d",
                        "content": "The problem statement implies that you have to put words into a Trie and run DFS on the adjacent letters on board, with checking if given DFS iteration backtracked solution is included in a Trie, built with words.\\n\\nI was trying to do vise versa and ended up with time-exceeded error, cos if you try to build a Trie with all combinations of adjacent letter on the board, you end up with really big Trie and instant search. The majority of time is spent building Trie and few last leetcode tests time out during this stage.\\n\\nThere is tradeoff b/w search time of dfs based on the board info (leetcode accepted)  and time spent on building Trie based on board letters (leetcode does not accept this solution)."
                    },
                    {
                        "username": "anwei40",
                        "content": "Wondered about that - in the case of relatively small grid, relatively big dictionary, it\\'s still faster to build a board Trie and search words instead of the accepted way."
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "[@charant587](/charant587) \\n\\nThis is problematic\\n\\n```py\\ndef remove(self, word):\\n    cur = self\\n    cur.refs -= 1\\n    for c in word:\\n        if c in cur.children:\\n            cur = cur.children[c]\\n            cur.refs -= 1\\n```\\n\\nlet\\'s say c isn\\'t in cur.children, what happens? cur doesn\\'t change and it checks if the next c is in cur. This could potentially result in cur.refs being wrong for multiple curs. \\n\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "bro can you tell me please why this code is not giving output                                                                                            class TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I guess can\\'t avoid Trie anymore."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen man... I thought I could avoid it too "
                    },
                    {
                        "username": "icehcamp",
                        "content": "Input:\\t[\"a\"], [\"a\",\"a\"]\\nOutput:\\t[\"a\",\"a\"]\\nExpected:\\t[\"a\"]\\n\\nNot quite sure why this output is incorrect. Can someone help clarify the question."
                    },
                    {
                        "username": "Finesse",
                        "content": "The result must contain each of the `words` at most once"
                    },
                    {
                        "username": "Praval791",
                        "content": "Cause \"a\" is uniquely present in words and your answer tells that there are 2 \"a\" words.\\nYou have to delete your string from trie after successully finding it."
                    },
                    {
                        "username": "scy_2020",
                        "content": "I have thought the Trie to build the board and use words to query the Trie. The time complexity is exponential. So I gave up. Then for the standard solution of this question, which is backtrack + Trie, the complexity should be exponential as well since the dfs tree size is O(4^n). I am wondering during the interview, whether it is  a good solution or not???\\n\\nThanks in advance."
                    },
                    {
                        "username": "palakons",
                        "content": "I am not sure, but I think a huge help would be pruning (i.e., removing the visited word from trie) That would make search space shrinks as the search goes on"
                    },
                    {
                        "username": "chui",
                        "content": "In the description, it says the longest word length will be 10. If you also keep getting TLE, maybe try this trick, works for mine."
                    }
                ]
            },
            {
                "id": 1566849,
                "content": [
                    {
                        "username": "okinawa",
                        "content": "This question is the reason I lost Uber interview.\\nRead the solution well guys and don\\'t be in my position \\uD83D\\uDE13"
                    },
                    {
                        "username": "arjun202",
                        "content": "which region was it for ? Was it India or somewhere else?"
                    },
                    {
                        "username": "palakons",
                        "content": "finally avoid TLE with Trie (with capability to remove)\\nthe last eight hours has been fun"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Lol \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "bonagirimahaveer",
                        "content": "\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "\\uD83D\\uDC80"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seriously. So frustrating. I had the optimal algorithm pretty quickly, but it still TLE'd. Then I spent hours trying to figure out which optimization to apply.\n\nI finally figured out how to implemented removal, and it immediately passed. It didn't even help that much on the test case I TLE'd on. It was probably a cumulative thing where it helped a little on each test case."
                    },
                    {
                        "username": "ahmdsolmn",
                        "content": "I believe the description of this problem should be changed to clearly explain that the output should not contain duplicate words."
                    },
                    {
                        "username": "shamoonmohd",
                        "content": "Yeah in question it says that you can\\'t use same character in a word again, but official testcase fails if you do so,\\ninstead it should be no repeated word in the result."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I feel like the question description can be more explicit instead of making us discover certain requirements (no duplicates etc) on our own."
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am trying to understand the time complexity of searching one single word (forget about tires and so).\\n\\nSo if we have a \\n- One single word of lenght = l   \\n- A boar of M x N. \\nUsingl DFS with 4 directions to search for that word, what should be the time complexity??\\n\\nM * N * 4^l?\\nM * N *  M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI hvae seen all those different complexities for the same code\\nIf you can help to clarify that would be great!\\n"
                    },
                    {
                        "username": "JackingChen",
                        "content": "I think it\\'s the worst case of dfs times the board size. Please correct me if I have missed anything"
                    },
                    {
                        "username": "palakons",
                        "content": "[@shyam-2002](/shyam-2002) good thing I mention \"big oh\", lol. just kidding, yours will be a more conservative (better) estimate"
                    },
                    {
                        "username": "shyam-2002",
                        "content": "It will be m*n*3^l as you wouldn\\'t go in the direction from where you have come."
                    },
                    {
                        "username": "palakons",
                        "content": "M * N * 4^l  for single word with length l"
                    },
                    {
                        "username": "mickey3d",
                        "content": "The problem statement implies that you have to put words into a Trie and run DFS on the adjacent letters on board, with checking if given DFS iteration backtracked solution is included in a Trie, built with words.\\n\\nI was trying to do vise versa and ended up with time-exceeded error, cos if you try to build a Trie with all combinations of adjacent letter on the board, you end up with really big Trie and instant search. The majority of time is spent building Trie and few last leetcode tests time out during this stage.\\n\\nThere is tradeoff b/w search time of dfs based on the board info (leetcode accepted)  and time spent on building Trie based on board letters (leetcode does not accept this solution)."
                    },
                    {
                        "username": "anwei40",
                        "content": "Wondered about that - in the case of relatively small grid, relatively big dictionary, it\\'s still faster to build a board Trie and search words instead of the accepted way."
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "[@charant587](/charant587) \\n\\nThis is problematic\\n\\n```py\\ndef remove(self, word):\\n    cur = self\\n    cur.refs -= 1\\n    for c in word:\\n        if c in cur.children:\\n            cur = cur.children[c]\\n            cur.refs -= 1\\n```\\n\\nlet\\'s say c isn\\'t in cur.children, what happens? cur doesn\\'t change and it checks if the next c is in cur. This could potentially result in cur.refs being wrong for multiple curs. \\n\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "bro can you tell me please why this code is not giving output                                                                                            class TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I guess can\\'t avoid Trie anymore."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen man... I thought I could avoid it too "
                    },
                    {
                        "username": "icehcamp",
                        "content": "Input:\\t[\"a\"], [\"a\",\"a\"]\\nOutput:\\t[\"a\",\"a\"]\\nExpected:\\t[\"a\"]\\n\\nNot quite sure why this output is incorrect. Can someone help clarify the question."
                    },
                    {
                        "username": "Finesse",
                        "content": "The result must contain each of the `words` at most once"
                    },
                    {
                        "username": "Praval791",
                        "content": "Cause \"a\" is uniquely present in words and your answer tells that there are 2 \"a\" words.\\nYou have to delete your string from trie after successully finding it."
                    },
                    {
                        "username": "scy_2020",
                        "content": "I have thought the Trie to build the board and use words to query the Trie. The time complexity is exponential. So I gave up. Then for the standard solution of this question, which is backtrack + Trie, the complexity should be exponential as well since the dfs tree size is O(4^n). I am wondering during the interview, whether it is  a good solution or not???\\n\\nThanks in advance."
                    },
                    {
                        "username": "palakons",
                        "content": "I am not sure, but I think a huge help would be pruning (i.e., removing the visited word from trie) That would make search space shrinks as the search goes on"
                    },
                    {
                        "username": "chui",
                        "content": "In the description, it says the longest word length will be 10. If you also keep getting TLE, maybe try this trick, works for mine."
                    }
                ]
            },
            {
                "id": 1574381,
                "content": [
                    {
                        "username": "okinawa",
                        "content": "This question is the reason I lost Uber interview.\\nRead the solution well guys and don\\'t be in my position \\uD83D\\uDE13"
                    },
                    {
                        "username": "arjun202",
                        "content": "which region was it for ? Was it India or somewhere else?"
                    },
                    {
                        "username": "palakons",
                        "content": "finally avoid TLE with Trie (with capability to remove)\\nthe last eight hours has been fun"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Lol \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "bonagirimahaveer",
                        "content": "\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "\\uD83D\\uDC80"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seriously. So frustrating. I had the optimal algorithm pretty quickly, but it still TLE'd. Then I spent hours trying to figure out which optimization to apply.\n\nI finally figured out how to implemented removal, and it immediately passed. It didn't even help that much on the test case I TLE'd on. It was probably a cumulative thing where it helped a little on each test case."
                    },
                    {
                        "username": "ahmdsolmn",
                        "content": "I believe the description of this problem should be changed to clearly explain that the output should not contain duplicate words."
                    },
                    {
                        "username": "shamoonmohd",
                        "content": "Yeah in question it says that you can\\'t use same character in a word again, but official testcase fails if you do so,\\ninstead it should be no repeated word in the result."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I feel like the question description can be more explicit instead of making us discover certain requirements (no duplicates etc) on our own."
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am trying to understand the time complexity of searching one single word (forget about tires and so).\\n\\nSo if we have a \\n- One single word of lenght = l   \\n- A boar of M x N. \\nUsingl DFS with 4 directions to search for that word, what should be the time complexity??\\n\\nM * N * 4^l?\\nM * N *  M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI hvae seen all those different complexities for the same code\\nIf you can help to clarify that would be great!\\n"
                    },
                    {
                        "username": "JackingChen",
                        "content": "I think it\\'s the worst case of dfs times the board size. Please correct me if I have missed anything"
                    },
                    {
                        "username": "palakons",
                        "content": "[@shyam-2002](/shyam-2002) good thing I mention \"big oh\", lol. just kidding, yours will be a more conservative (better) estimate"
                    },
                    {
                        "username": "shyam-2002",
                        "content": "It will be m*n*3^l as you wouldn\\'t go in the direction from where you have come."
                    },
                    {
                        "username": "palakons",
                        "content": "M * N * 4^l  for single word with length l"
                    },
                    {
                        "username": "mickey3d",
                        "content": "The problem statement implies that you have to put words into a Trie and run DFS on the adjacent letters on board, with checking if given DFS iteration backtracked solution is included in a Trie, built with words.\\n\\nI was trying to do vise versa and ended up with time-exceeded error, cos if you try to build a Trie with all combinations of adjacent letter on the board, you end up with really big Trie and instant search. The majority of time is spent building Trie and few last leetcode tests time out during this stage.\\n\\nThere is tradeoff b/w search time of dfs based on the board info (leetcode accepted)  and time spent on building Trie based on board letters (leetcode does not accept this solution)."
                    },
                    {
                        "username": "anwei40",
                        "content": "Wondered about that - in the case of relatively small grid, relatively big dictionary, it\\'s still faster to build a board Trie and search words instead of the accepted way."
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "[@charant587](/charant587) \\n\\nThis is problematic\\n\\n```py\\ndef remove(self, word):\\n    cur = self\\n    cur.refs -= 1\\n    for c in word:\\n        if c in cur.children:\\n            cur = cur.children[c]\\n            cur.refs -= 1\\n```\\n\\nlet\\'s say c isn\\'t in cur.children, what happens? cur doesn\\'t change and it checks if the next c is in cur. This could potentially result in cur.refs being wrong for multiple curs. \\n\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "bro can you tell me please why this code is not giving output                                                                                            class TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I guess can\\'t avoid Trie anymore."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen man... I thought I could avoid it too "
                    },
                    {
                        "username": "icehcamp",
                        "content": "Input:\\t[\"a\"], [\"a\",\"a\"]\\nOutput:\\t[\"a\",\"a\"]\\nExpected:\\t[\"a\"]\\n\\nNot quite sure why this output is incorrect. Can someone help clarify the question."
                    },
                    {
                        "username": "Finesse",
                        "content": "The result must contain each of the `words` at most once"
                    },
                    {
                        "username": "Praval791",
                        "content": "Cause \"a\" is uniquely present in words and your answer tells that there are 2 \"a\" words.\\nYou have to delete your string from trie after successully finding it."
                    },
                    {
                        "username": "scy_2020",
                        "content": "I have thought the Trie to build the board and use words to query the Trie. The time complexity is exponential. So I gave up. Then for the standard solution of this question, which is backtrack + Trie, the complexity should be exponential as well since the dfs tree size is O(4^n). I am wondering during the interview, whether it is  a good solution or not???\\n\\nThanks in advance."
                    },
                    {
                        "username": "palakons",
                        "content": "I am not sure, but I think a huge help would be pruning (i.e., removing the visited word from trie) That would make search space shrinks as the search goes on"
                    },
                    {
                        "username": "chui",
                        "content": "In the description, it says the longest word length will be 10. If you also keep getting TLE, maybe try this trick, works for mine."
                    }
                ]
            },
            {
                "id": 1676645,
                "content": [
                    {
                        "username": "okinawa",
                        "content": "This question is the reason I lost Uber interview.\\nRead the solution well guys and don\\'t be in my position \\uD83D\\uDE13"
                    },
                    {
                        "username": "arjun202",
                        "content": "which region was it for ? Was it India or somewhere else?"
                    },
                    {
                        "username": "palakons",
                        "content": "finally avoid TLE with Trie (with capability to remove)\\nthe last eight hours has been fun"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Lol \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "bonagirimahaveer",
                        "content": "\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "\\uD83D\\uDC80"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seriously. So frustrating. I had the optimal algorithm pretty quickly, but it still TLE'd. Then I spent hours trying to figure out which optimization to apply.\n\nI finally figured out how to implemented removal, and it immediately passed. It didn't even help that much on the test case I TLE'd on. It was probably a cumulative thing where it helped a little on each test case."
                    },
                    {
                        "username": "ahmdsolmn",
                        "content": "I believe the description of this problem should be changed to clearly explain that the output should not contain duplicate words."
                    },
                    {
                        "username": "shamoonmohd",
                        "content": "Yeah in question it says that you can\\'t use same character in a word again, but official testcase fails if you do so,\\ninstead it should be no repeated word in the result."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I feel like the question description can be more explicit instead of making us discover certain requirements (no duplicates etc) on our own."
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am trying to understand the time complexity of searching one single word (forget about tires and so).\\n\\nSo if we have a \\n- One single word of lenght = l   \\n- A boar of M x N. \\nUsingl DFS with 4 directions to search for that word, what should be the time complexity??\\n\\nM * N * 4^l?\\nM * N *  M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI hvae seen all those different complexities for the same code\\nIf you can help to clarify that would be great!\\n"
                    },
                    {
                        "username": "JackingChen",
                        "content": "I think it\\'s the worst case of dfs times the board size. Please correct me if I have missed anything"
                    },
                    {
                        "username": "palakons",
                        "content": "[@shyam-2002](/shyam-2002) good thing I mention \"big oh\", lol. just kidding, yours will be a more conservative (better) estimate"
                    },
                    {
                        "username": "shyam-2002",
                        "content": "It will be m*n*3^l as you wouldn\\'t go in the direction from where you have come."
                    },
                    {
                        "username": "palakons",
                        "content": "M * N * 4^l  for single word with length l"
                    },
                    {
                        "username": "mickey3d",
                        "content": "The problem statement implies that you have to put words into a Trie and run DFS on the adjacent letters on board, with checking if given DFS iteration backtracked solution is included in a Trie, built with words.\\n\\nI was trying to do vise versa and ended up with time-exceeded error, cos if you try to build a Trie with all combinations of adjacent letter on the board, you end up with really big Trie and instant search. The majority of time is spent building Trie and few last leetcode tests time out during this stage.\\n\\nThere is tradeoff b/w search time of dfs based on the board info (leetcode accepted)  and time spent on building Trie based on board letters (leetcode does not accept this solution)."
                    },
                    {
                        "username": "anwei40",
                        "content": "Wondered about that - in the case of relatively small grid, relatively big dictionary, it\\'s still faster to build a board Trie and search words instead of the accepted way."
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "[@charant587](/charant587) \\n\\nThis is problematic\\n\\n```py\\ndef remove(self, word):\\n    cur = self\\n    cur.refs -= 1\\n    for c in word:\\n        if c in cur.children:\\n            cur = cur.children[c]\\n            cur.refs -= 1\\n```\\n\\nlet\\'s say c isn\\'t in cur.children, what happens? cur doesn\\'t change and it checks if the next c is in cur. This could potentially result in cur.refs being wrong for multiple curs. \\n\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "bro can you tell me please why this code is not giving output                                                                                            class TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I guess can\\'t avoid Trie anymore."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen man... I thought I could avoid it too "
                    },
                    {
                        "username": "icehcamp",
                        "content": "Input:\\t[\"a\"], [\"a\",\"a\"]\\nOutput:\\t[\"a\",\"a\"]\\nExpected:\\t[\"a\"]\\n\\nNot quite sure why this output is incorrect. Can someone help clarify the question."
                    },
                    {
                        "username": "Finesse",
                        "content": "The result must contain each of the `words` at most once"
                    },
                    {
                        "username": "Praval791",
                        "content": "Cause \"a\" is uniquely present in words and your answer tells that there are 2 \"a\" words.\\nYou have to delete your string from trie after successully finding it."
                    },
                    {
                        "username": "scy_2020",
                        "content": "I have thought the Trie to build the board and use words to query the Trie. The time complexity is exponential. So I gave up. Then for the standard solution of this question, which is backtrack + Trie, the complexity should be exponential as well since the dfs tree size is O(4^n). I am wondering during the interview, whether it is  a good solution or not???\\n\\nThanks in advance."
                    },
                    {
                        "username": "palakons",
                        "content": "I am not sure, but I think a huge help would be pruning (i.e., removing the visited word from trie) That would make search space shrinks as the search goes on"
                    },
                    {
                        "username": "chui",
                        "content": "In the description, it says the longest word length will be 10. If you also keep getting TLE, maybe try this trick, works for mine."
                    }
                ]
            },
            {
                "id": 1567225,
                "content": [
                    {
                        "username": "okinawa",
                        "content": "This question is the reason I lost Uber interview.\\nRead the solution well guys and don\\'t be in my position \\uD83D\\uDE13"
                    },
                    {
                        "username": "arjun202",
                        "content": "which region was it for ? Was it India or somewhere else?"
                    },
                    {
                        "username": "palakons",
                        "content": "finally avoid TLE with Trie (with capability to remove)\\nthe last eight hours has been fun"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Lol \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "bonagirimahaveer",
                        "content": "\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "\\uD83D\\uDC80"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seriously. So frustrating. I had the optimal algorithm pretty quickly, but it still TLE'd. Then I spent hours trying to figure out which optimization to apply.\n\nI finally figured out how to implemented removal, and it immediately passed. It didn't even help that much on the test case I TLE'd on. It was probably a cumulative thing where it helped a little on each test case."
                    },
                    {
                        "username": "ahmdsolmn",
                        "content": "I believe the description of this problem should be changed to clearly explain that the output should not contain duplicate words."
                    },
                    {
                        "username": "shamoonmohd",
                        "content": "Yeah in question it says that you can\\'t use same character in a word again, but official testcase fails if you do so,\\ninstead it should be no repeated word in the result."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I feel like the question description can be more explicit instead of making us discover certain requirements (no duplicates etc) on our own."
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am trying to understand the time complexity of searching one single word (forget about tires and so).\\n\\nSo if we have a \\n- One single word of lenght = l   \\n- A boar of M x N. \\nUsingl DFS with 4 directions to search for that word, what should be the time complexity??\\n\\nM * N * 4^l?\\nM * N *  M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI hvae seen all those different complexities for the same code\\nIf you can help to clarify that would be great!\\n"
                    },
                    {
                        "username": "JackingChen",
                        "content": "I think it\\'s the worst case of dfs times the board size. Please correct me if I have missed anything"
                    },
                    {
                        "username": "palakons",
                        "content": "[@shyam-2002](/shyam-2002) good thing I mention \"big oh\", lol. just kidding, yours will be a more conservative (better) estimate"
                    },
                    {
                        "username": "shyam-2002",
                        "content": "It will be m*n*3^l as you wouldn\\'t go in the direction from where you have come."
                    },
                    {
                        "username": "palakons",
                        "content": "M * N * 4^l  for single word with length l"
                    },
                    {
                        "username": "mickey3d",
                        "content": "The problem statement implies that you have to put words into a Trie and run DFS on the adjacent letters on board, with checking if given DFS iteration backtracked solution is included in a Trie, built with words.\\n\\nI was trying to do vise versa and ended up with time-exceeded error, cos if you try to build a Trie with all combinations of adjacent letter on the board, you end up with really big Trie and instant search. The majority of time is spent building Trie and few last leetcode tests time out during this stage.\\n\\nThere is tradeoff b/w search time of dfs based on the board info (leetcode accepted)  and time spent on building Trie based on board letters (leetcode does not accept this solution)."
                    },
                    {
                        "username": "anwei40",
                        "content": "Wondered about that - in the case of relatively small grid, relatively big dictionary, it\\'s still faster to build a board Trie and search words instead of the accepted way."
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "[@charant587](/charant587) \\n\\nThis is problematic\\n\\n```py\\ndef remove(self, word):\\n    cur = self\\n    cur.refs -= 1\\n    for c in word:\\n        if c in cur.children:\\n            cur = cur.children[c]\\n            cur.refs -= 1\\n```\\n\\nlet\\'s say c isn\\'t in cur.children, what happens? cur doesn\\'t change and it checks if the next c is in cur. This could potentially result in cur.refs being wrong for multiple curs. \\n\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "bro can you tell me please why this code is not giving output                                                                                            class TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I guess can\\'t avoid Trie anymore."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen man... I thought I could avoid it too "
                    },
                    {
                        "username": "icehcamp",
                        "content": "Input:\\t[\"a\"], [\"a\",\"a\"]\\nOutput:\\t[\"a\",\"a\"]\\nExpected:\\t[\"a\"]\\n\\nNot quite sure why this output is incorrect. Can someone help clarify the question."
                    },
                    {
                        "username": "Finesse",
                        "content": "The result must contain each of the `words` at most once"
                    },
                    {
                        "username": "Praval791",
                        "content": "Cause \"a\" is uniquely present in words and your answer tells that there are 2 \"a\" words.\\nYou have to delete your string from trie after successully finding it."
                    },
                    {
                        "username": "scy_2020",
                        "content": "I have thought the Trie to build the board and use words to query the Trie. The time complexity is exponential. So I gave up. Then for the standard solution of this question, which is backtrack + Trie, the complexity should be exponential as well since the dfs tree size is O(4^n). I am wondering during the interview, whether it is  a good solution or not???\\n\\nThanks in advance."
                    },
                    {
                        "username": "palakons",
                        "content": "I am not sure, but I think a huge help would be pruning (i.e., removing the visited word from trie) That would make search space shrinks as the search goes on"
                    },
                    {
                        "username": "chui",
                        "content": "In the description, it says the longest word length will be 10. If you also keep getting TLE, maybe try this trick, works for mine."
                    }
                ]
            },
            {
                "id": 1566535,
                "content": [
                    {
                        "username": "okinawa",
                        "content": "This question is the reason I lost Uber interview.\\nRead the solution well guys and don\\'t be in my position \\uD83D\\uDE13"
                    },
                    {
                        "username": "arjun202",
                        "content": "which region was it for ? Was it India or somewhere else?"
                    },
                    {
                        "username": "palakons",
                        "content": "finally avoid TLE with Trie (with capability to remove)\\nthe last eight hours has been fun"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Lol \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "bonagirimahaveer",
                        "content": "\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "\\uD83D\\uDC80"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seriously. So frustrating. I had the optimal algorithm pretty quickly, but it still TLE'd. Then I spent hours trying to figure out which optimization to apply.\n\nI finally figured out how to implemented removal, and it immediately passed. It didn't even help that much on the test case I TLE'd on. It was probably a cumulative thing where it helped a little on each test case."
                    },
                    {
                        "username": "ahmdsolmn",
                        "content": "I believe the description of this problem should be changed to clearly explain that the output should not contain duplicate words."
                    },
                    {
                        "username": "shamoonmohd",
                        "content": "Yeah in question it says that you can\\'t use same character in a word again, but official testcase fails if you do so,\\ninstead it should be no repeated word in the result."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I feel like the question description can be more explicit instead of making us discover certain requirements (no duplicates etc) on our own."
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am trying to understand the time complexity of searching one single word (forget about tires and so).\\n\\nSo if we have a \\n- One single word of lenght = l   \\n- A boar of M x N. \\nUsingl DFS with 4 directions to search for that word, what should be the time complexity??\\n\\nM * N * 4^l?\\nM * N *  M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI hvae seen all those different complexities for the same code\\nIf you can help to clarify that would be great!\\n"
                    },
                    {
                        "username": "JackingChen",
                        "content": "I think it\\'s the worst case of dfs times the board size. Please correct me if I have missed anything"
                    },
                    {
                        "username": "palakons",
                        "content": "[@shyam-2002](/shyam-2002) good thing I mention \"big oh\", lol. just kidding, yours will be a more conservative (better) estimate"
                    },
                    {
                        "username": "shyam-2002",
                        "content": "It will be m*n*3^l as you wouldn\\'t go in the direction from where you have come."
                    },
                    {
                        "username": "palakons",
                        "content": "M * N * 4^l  for single word with length l"
                    },
                    {
                        "username": "mickey3d",
                        "content": "The problem statement implies that you have to put words into a Trie and run DFS on the adjacent letters on board, with checking if given DFS iteration backtracked solution is included in a Trie, built with words.\\n\\nI was trying to do vise versa and ended up with time-exceeded error, cos if you try to build a Trie with all combinations of adjacent letter on the board, you end up with really big Trie and instant search. The majority of time is spent building Trie and few last leetcode tests time out during this stage.\\n\\nThere is tradeoff b/w search time of dfs based on the board info (leetcode accepted)  and time spent on building Trie based on board letters (leetcode does not accept this solution)."
                    },
                    {
                        "username": "anwei40",
                        "content": "Wondered about that - in the case of relatively small grid, relatively big dictionary, it\\'s still faster to build a board Trie and search words instead of the accepted way."
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "[@charant587](/charant587) \\n\\nThis is problematic\\n\\n```py\\ndef remove(self, word):\\n    cur = self\\n    cur.refs -= 1\\n    for c in word:\\n        if c in cur.children:\\n            cur = cur.children[c]\\n            cur.refs -= 1\\n```\\n\\nlet\\'s say c isn\\'t in cur.children, what happens? cur doesn\\'t change and it checks if the next c is in cur. This could potentially result in cur.refs being wrong for multiple curs. \\n\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "bro can you tell me please why this code is not giving output                                                                                            class TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I guess can\\'t avoid Trie anymore."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen man... I thought I could avoid it too "
                    },
                    {
                        "username": "icehcamp",
                        "content": "Input:\\t[\"a\"], [\"a\",\"a\"]\\nOutput:\\t[\"a\",\"a\"]\\nExpected:\\t[\"a\"]\\n\\nNot quite sure why this output is incorrect. Can someone help clarify the question."
                    },
                    {
                        "username": "Finesse",
                        "content": "The result must contain each of the `words` at most once"
                    },
                    {
                        "username": "Praval791",
                        "content": "Cause \"a\" is uniquely present in words and your answer tells that there are 2 \"a\" words.\\nYou have to delete your string from trie after successully finding it."
                    },
                    {
                        "username": "scy_2020",
                        "content": "I have thought the Trie to build the board and use words to query the Trie. The time complexity is exponential. So I gave up. Then for the standard solution of this question, which is backtrack + Trie, the complexity should be exponential as well since the dfs tree size is O(4^n). I am wondering during the interview, whether it is  a good solution or not???\\n\\nThanks in advance."
                    },
                    {
                        "username": "palakons",
                        "content": "I am not sure, but I think a huge help would be pruning (i.e., removing the visited word from trie) That would make search space shrinks as the search goes on"
                    },
                    {
                        "username": "chui",
                        "content": "In the description, it says the longest word length will be 10. If you also keep getting TLE, maybe try this trick, works for mine."
                    }
                ]
            },
            {
                "id": 1570400,
                "content": [
                    {
                        "username": "okinawa",
                        "content": "This question is the reason I lost Uber interview.\\nRead the solution well guys and don\\'t be in my position \\uD83D\\uDE13"
                    },
                    {
                        "username": "arjun202",
                        "content": "which region was it for ? Was it India or somewhere else?"
                    },
                    {
                        "username": "palakons",
                        "content": "finally avoid TLE with Trie (with capability to remove)\\nthe last eight hours has been fun"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Lol \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "bonagirimahaveer",
                        "content": "\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "\\uD83D\\uDC80"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seriously. So frustrating. I had the optimal algorithm pretty quickly, but it still TLE'd. Then I spent hours trying to figure out which optimization to apply.\n\nI finally figured out how to implemented removal, and it immediately passed. It didn't even help that much on the test case I TLE'd on. It was probably a cumulative thing where it helped a little on each test case."
                    },
                    {
                        "username": "ahmdsolmn",
                        "content": "I believe the description of this problem should be changed to clearly explain that the output should not contain duplicate words."
                    },
                    {
                        "username": "shamoonmohd",
                        "content": "Yeah in question it says that you can\\'t use same character in a word again, but official testcase fails if you do so,\\ninstead it should be no repeated word in the result."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I feel like the question description can be more explicit instead of making us discover certain requirements (no duplicates etc) on our own."
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am trying to understand the time complexity of searching one single word (forget about tires and so).\\n\\nSo if we have a \\n- One single word of lenght = l   \\n- A boar of M x N. \\nUsingl DFS with 4 directions to search for that word, what should be the time complexity??\\n\\nM * N * 4^l?\\nM * N *  M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI hvae seen all those different complexities for the same code\\nIf you can help to clarify that would be great!\\n"
                    },
                    {
                        "username": "JackingChen",
                        "content": "I think it\\'s the worst case of dfs times the board size. Please correct me if I have missed anything"
                    },
                    {
                        "username": "palakons",
                        "content": "[@shyam-2002](/shyam-2002) good thing I mention \"big oh\", lol. just kidding, yours will be a more conservative (better) estimate"
                    },
                    {
                        "username": "shyam-2002",
                        "content": "It will be m*n*3^l as you wouldn\\'t go in the direction from where you have come."
                    },
                    {
                        "username": "palakons",
                        "content": "M * N * 4^l  for single word with length l"
                    },
                    {
                        "username": "mickey3d",
                        "content": "The problem statement implies that you have to put words into a Trie and run DFS on the adjacent letters on board, with checking if given DFS iteration backtracked solution is included in a Trie, built with words.\\n\\nI was trying to do vise versa and ended up with time-exceeded error, cos if you try to build a Trie with all combinations of adjacent letter on the board, you end up with really big Trie and instant search. The majority of time is spent building Trie and few last leetcode tests time out during this stage.\\n\\nThere is tradeoff b/w search time of dfs based on the board info (leetcode accepted)  and time spent on building Trie based on board letters (leetcode does not accept this solution)."
                    },
                    {
                        "username": "anwei40",
                        "content": "Wondered about that - in the case of relatively small grid, relatively big dictionary, it\\'s still faster to build a board Trie and search words instead of the accepted way."
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "[@charant587](/charant587) \\n\\nThis is problematic\\n\\n```py\\ndef remove(self, word):\\n    cur = self\\n    cur.refs -= 1\\n    for c in word:\\n        if c in cur.children:\\n            cur = cur.children[c]\\n            cur.refs -= 1\\n```\\n\\nlet\\'s say c isn\\'t in cur.children, what happens? cur doesn\\'t change and it checks if the next c is in cur. This could potentially result in cur.refs being wrong for multiple curs. \\n\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "bro can you tell me please why this code is not giving output                                                                                            class TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I guess can\\'t avoid Trie anymore."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen man... I thought I could avoid it too "
                    },
                    {
                        "username": "icehcamp",
                        "content": "Input:\\t[\"a\"], [\"a\",\"a\"]\\nOutput:\\t[\"a\",\"a\"]\\nExpected:\\t[\"a\"]\\n\\nNot quite sure why this output is incorrect. Can someone help clarify the question."
                    },
                    {
                        "username": "Finesse",
                        "content": "The result must contain each of the `words` at most once"
                    },
                    {
                        "username": "Praval791",
                        "content": "Cause \"a\" is uniquely present in words and your answer tells that there are 2 \"a\" words.\\nYou have to delete your string from trie after successully finding it."
                    },
                    {
                        "username": "scy_2020",
                        "content": "I have thought the Trie to build the board and use words to query the Trie. The time complexity is exponential. So I gave up. Then for the standard solution of this question, which is backtrack + Trie, the complexity should be exponential as well since the dfs tree size is O(4^n). I am wondering during the interview, whether it is  a good solution or not???\\n\\nThanks in advance."
                    },
                    {
                        "username": "palakons",
                        "content": "I am not sure, but I think a huge help would be pruning (i.e., removing the visited word from trie) That would make search space shrinks as the search goes on"
                    },
                    {
                        "username": "chui",
                        "content": "In the description, it says the longest word length will be 10. If you also keep getting TLE, maybe try this trick, works for mine."
                    }
                ]
            },
            {
                "id": 2050697,
                "content": [
                    {
                        "username": "ak_3101",
                        "content": "After 2.5 hours of debugging and struggle, I officially hate this question. "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I do not understand testcase 65 / 65.\\nI\\'ve got TLE.\\nBut what does it mean:\\n\\nboard =\\n\\n?\\nWhit empty info about this testcase..."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "This is ridiculous. How am I supposed to solve this in an interview if I\\'ve never seen it before lol"
                    },
                    {
                        "username": "CyrilKamal",
                        "content": "you dont"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "Test case 65 is broken?\\nBoard is empty and no words input is provided"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Yeah. I think so"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Getting TLE at 65th testcase"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Solve this one before :https://leetcode.com/problems/word-search/"
                    },
                    {
                        "username": "JorgeLDB",
                        "content": "![image](https://i.ibb.co/FHXHs0d/leet.jpg)\\n\\nHmm... at least I\\'m almost there. "
                    },
                    {
                        "username": "Gizmy",
                        "content": "![image](https://assets.leetcode.com/users/gizmy/image_1568395306.png)\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Going from `b` to `c` is a diagonal move which is forbidden"
                    },
                    {
                        "username": "durgaprasad1541996",
                        "content": "This problem do not expect you to traverse diagonally, that is the reason expected is empty."
                    },
                    {
                        "username": "lance6716",
                        "content": "That\\'s deliberately introduce trie, I can\\'t agree that query words share a long prefix without clearly stated in problem description. If we should consider these case, we should also consider words share suffix, common substring, etc. and trie won\\'t help."
                    },
                    {
                        "username": "piggysolucky",
                        "content": "Because the normal backtracking gave me an error (stack overflow) here."
                    }
                ]
            },
            {
                "id": 1927304,
                "content": [
                    {
                        "username": "ak_3101",
                        "content": "After 2.5 hours of debugging and struggle, I officially hate this question. "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I do not understand testcase 65 / 65.\\nI\\'ve got TLE.\\nBut what does it mean:\\n\\nboard =\\n\\n?\\nWhit empty info about this testcase..."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "This is ridiculous. How am I supposed to solve this in an interview if I\\'ve never seen it before lol"
                    },
                    {
                        "username": "CyrilKamal",
                        "content": "you dont"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "Test case 65 is broken?\\nBoard is empty and no words input is provided"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Yeah. I think so"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Getting TLE at 65th testcase"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Solve this one before :https://leetcode.com/problems/word-search/"
                    },
                    {
                        "username": "JorgeLDB",
                        "content": "![image](https://i.ibb.co/FHXHs0d/leet.jpg)\\n\\nHmm... at least I\\'m almost there. "
                    },
                    {
                        "username": "Gizmy",
                        "content": "![image](https://assets.leetcode.com/users/gizmy/image_1568395306.png)\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Going from `b` to `c` is a diagonal move which is forbidden"
                    },
                    {
                        "username": "durgaprasad1541996",
                        "content": "This problem do not expect you to traverse diagonally, that is the reason expected is empty."
                    },
                    {
                        "username": "lance6716",
                        "content": "That\\'s deliberately introduce trie, I can\\'t agree that query words share a long prefix without clearly stated in problem description. If we should consider these case, we should also consider words share suffix, common substring, etc. and trie won\\'t help."
                    },
                    {
                        "username": "piggysolucky",
                        "content": "Because the normal backtracking gave me an error (stack overflow) here."
                    }
                ]
            },
            {
                "id": 1899346,
                "content": [
                    {
                        "username": "ak_3101",
                        "content": "After 2.5 hours of debugging and struggle, I officially hate this question. "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I do not understand testcase 65 / 65.\\nI\\'ve got TLE.\\nBut what does it mean:\\n\\nboard =\\n\\n?\\nWhit empty info about this testcase..."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "This is ridiculous. How am I supposed to solve this in an interview if I\\'ve never seen it before lol"
                    },
                    {
                        "username": "CyrilKamal",
                        "content": "you dont"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "Test case 65 is broken?\\nBoard is empty and no words input is provided"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Yeah. I think so"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Getting TLE at 65th testcase"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Solve this one before :https://leetcode.com/problems/word-search/"
                    },
                    {
                        "username": "JorgeLDB",
                        "content": "![image](https://i.ibb.co/FHXHs0d/leet.jpg)\\n\\nHmm... at least I\\'m almost there. "
                    },
                    {
                        "username": "Gizmy",
                        "content": "![image](https://assets.leetcode.com/users/gizmy/image_1568395306.png)\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Going from `b` to `c` is a diagonal move which is forbidden"
                    },
                    {
                        "username": "durgaprasad1541996",
                        "content": "This problem do not expect you to traverse diagonally, that is the reason expected is empty."
                    },
                    {
                        "username": "lance6716",
                        "content": "That\\'s deliberately introduce trie, I can\\'t agree that query words share a long prefix without clearly stated in problem description. If we should consider these case, we should also consider words share suffix, common substring, etc. and trie won\\'t help."
                    },
                    {
                        "username": "piggysolucky",
                        "content": "Because the normal backtracking gave me an error (stack overflow) here."
                    }
                ]
            },
            {
                "id": 1839998,
                "content": [
                    {
                        "username": "ak_3101",
                        "content": "After 2.5 hours of debugging and struggle, I officially hate this question. "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I do not understand testcase 65 / 65.\\nI\\'ve got TLE.\\nBut what does it mean:\\n\\nboard =\\n\\n?\\nWhit empty info about this testcase..."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "This is ridiculous. How am I supposed to solve this in an interview if I\\'ve never seen it before lol"
                    },
                    {
                        "username": "CyrilKamal",
                        "content": "you dont"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "Test case 65 is broken?\\nBoard is empty and no words input is provided"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Yeah. I think so"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Getting TLE at 65th testcase"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Solve this one before :https://leetcode.com/problems/word-search/"
                    },
                    {
                        "username": "JorgeLDB",
                        "content": "![image](https://i.ibb.co/FHXHs0d/leet.jpg)\\n\\nHmm... at least I\\'m almost there. "
                    },
                    {
                        "username": "Gizmy",
                        "content": "![image](https://assets.leetcode.com/users/gizmy/image_1568395306.png)\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Going from `b` to `c` is a diagonal move which is forbidden"
                    },
                    {
                        "username": "durgaprasad1541996",
                        "content": "This problem do not expect you to traverse diagonally, that is the reason expected is empty."
                    },
                    {
                        "username": "lance6716",
                        "content": "That\\'s deliberately introduce trie, I can\\'t agree that query words share a long prefix without clearly stated in problem description. If we should consider these case, we should also consider words share suffix, common substring, etc. and trie won\\'t help."
                    },
                    {
                        "username": "piggysolucky",
                        "content": "Because the normal backtracking gave me an error (stack overflow) here."
                    }
                ]
            },
            {
                "id": 1979900,
                "content": [
                    {
                        "username": "ak_3101",
                        "content": "After 2.5 hours of debugging and struggle, I officially hate this question. "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I do not understand testcase 65 / 65.\\nI\\'ve got TLE.\\nBut what does it mean:\\n\\nboard =\\n\\n?\\nWhit empty info about this testcase..."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "This is ridiculous. How am I supposed to solve this in an interview if I\\'ve never seen it before lol"
                    },
                    {
                        "username": "CyrilKamal",
                        "content": "you dont"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "Test case 65 is broken?\\nBoard is empty and no words input is provided"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Yeah. I think so"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Getting TLE at 65th testcase"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Solve this one before :https://leetcode.com/problems/word-search/"
                    },
                    {
                        "username": "JorgeLDB",
                        "content": "![image](https://i.ibb.co/FHXHs0d/leet.jpg)\\n\\nHmm... at least I\\'m almost there. "
                    },
                    {
                        "username": "Gizmy",
                        "content": "![image](https://assets.leetcode.com/users/gizmy/image_1568395306.png)\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Going from `b` to `c` is a diagonal move which is forbidden"
                    },
                    {
                        "username": "durgaprasad1541996",
                        "content": "This problem do not expect you to traverse diagonally, that is the reason expected is empty."
                    },
                    {
                        "username": "lance6716",
                        "content": "That\\'s deliberately introduce trie, I can\\'t agree that query words share a long prefix without clearly stated in problem description. If we should consider these case, we should also consider words share suffix, common substring, etc. and trie won\\'t help."
                    },
                    {
                        "username": "piggysolucky",
                        "content": "Because the normal backtracking gave me an error (stack overflow) here."
                    }
                ]
            },
            {
                "id": 1952808,
                "content": [
                    {
                        "username": "ak_3101",
                        "content": "After 2.5 hours of debugging and struggle, I officially hate this question. "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I do not understand testcase 65 / 65.\\nI\\'ve got TLE.\\nBut what does it mean:\\n\\nboard =\\n\\n?\\nWhit empty info about this testcase..."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "This is ridiculous. How am I supposed to solve this in an interview if I\\'ve never seen it before lol"
                    },
                    {
                        "username": "CyrilKamal",
                        "content": "you dont"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "Test case 65 is broken?\\nBoard is empty and no words input is provided"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Yeah. I think so"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Getting TLE at 65th testcase"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Solve this one before :https://leetcode.com/problems/word-search/"
                    },
                    {
                        "username": "JorgeLDB",
                        "content": "![image](https://i.ibb.co/FHXHs0d/leet.jpg)\\n\\nHmm... at least I\\'m almost there. "
                    },
                    {
                        "username": "Gizmy",
                        "content": "![image](https://assets.leetcode.com/users/gizmy/image_1568395306.png)\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Going from `b` to `c` is a diagonal move which is forbidden"
                    },
                    {
                        "username": "durgaprasad1541996",
                        "content": "This problem do not expect you to traverse diagonally, that is the reason expected is empty."
                    },
                    {
                        "username": "lance6716",
                        "content": "That\\'s deliberately introduce trie, I can\\'t agree that query words share a long prefix without clearly stated in problem description. If we should consider these case, we should also consider words share suffix, common substring, etc. and trie won\\'t help."
                    },
                    {
                        "username": "piggysolucky",
                        "content": "Because the normal backtracking gave me an error (stack overflow) here."
                    }
                ]
            },
            {
                "id": 1672515,
                "content": [
                    {
                        "username": "ak_3101",
                        "content": "After 2.5 hours of debugging and struggle, I officially hate this question. "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I do not understand testcase 65 / 65.\\nI\\'ve got TLE.\\nBut what does it mean:\\n\\nboard =\\n\\n?\\nWhit empty info about this testcase..."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "This is ridiculous. How am I supposed to solve this in an interview if I\\'ve never seen it before lol"
                    },
                    {
                        "username": "CyrilKamal",
                        "content": "you dont"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "Test case 65 is broken?\\nBoard is empty and no words input is provided"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Yeah. I think so"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Getting TLE at 65th testcase"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Solve this one before :https://leetcode.com/problems/word-search/"
                    },
                    {
                        "username": "JorgeLDB",
                        "content": "![image](https://i.ibb.co/FHXHs0d/leet.jpg)\\n\\nHmm... at least I\\'m almost there. "
                    },
                    {
                        "username": "Gizmy",
                        "content": "![image](https://assets.leetcode.com/users/gizmy/image_1568395306.png)\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Going from `b` to `c` is a diagonal move which is forbidden"
                    },
                    {
                        "username": "durgaprasad1541996",
                        "content": "This problem do not expect you to traverse diagonally, that is the reason expected is empty."
                    },
                    {
                        "username": "lance6716",
                        "content": "That\\'s deliberately introduce trie, I can\\'t agree that query words share a long prefix without clearly stated in problem description. If we should consider these case, we should also consider words share suffix, common substring, etc. and trie won\\'t help."
                    },
                    {
                        "username": "piggysolucky",
                        "content": "Because the normal backtracking gave me an error (stack overflow) here."
                    }
                ]
            },
            {
                "id": 1572999,
                "content": [
                    {
                        "username": "ak_3101",
                        "content": "After 2.5 hours of debugging and struggle, I officially hate this question. "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I do not understand testcase 65 / 65.\\nI\\'ve got TLE.\\nBut what does it mean:\\n\\nboard =\\n\\n?\\nWhit empty info about this testcase..."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "This is ridiculous. How am I supposed to solve this in an interview if I\\'ve never seen it before lol"
                    },
                    {
                        "username": "CyrilKamal",
                        "content": "you dont"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "Test case 65 is broken?\\nBoard is empty and no words input is provided"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Yeah. I think so"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Getting TLE at 65th testcase"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Solve this one before :https://leetcode.com/problems/word-search/"
                    },
                    {
                        "username": "JorgeLDB",
                        "content": "![image](https://i.ibb.co/FHXHs0d/leet.jpg)\\n\\nHmm... at least I\\'m almost there. "
                    },
                    {
                        "username": "Gizmy",
                        "content": "![image](https://assets.leetcode.com/users/gizmy/image_1568395306.png)\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Going from `b` to `c` is a diagonal move which is forbidden"
                    },
                    {
                        "username": "durgaprasad1541996",
                        "content": "This problem do not expect you to traverse diagonally, that is the reason expected is empty."
                    },
                    {
                        "username": "lance6716",
                        "content": "That\\'s deliberately introduce trie, I can\\'t agree that query words share a long prefix without clearly stated in problem description. If we should consider these case, we should also consider words share suffix, common substring, etc. and trie won\\'t help."
                    },
                    {
                        "username": "piggysolucky",
                        "content": "Because the normal backtracking gave me an error (stack overflow) here."
                    }
                ]
            },
            {
                "id": 1572494,
                "content": [
                    {
                        "username": "ak_3101",
                        "content": "After 2.5 hours of debugging and struggle, I officially hate this question. "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I do not understand testcase 65 / 65.\\nI\\'ve got TLE.\\nBut what does it mean:\\n\\nboard =\\n\\n?\\nWhit empty info about this testcase..."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "This is ridiculous. How am I supposed to solve this in an interview if I\\'ve never seen it before lol"
                    },
                    {
                        "username": "CyrilKamal",
                        "content": "you dont"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "Test case 65 is broken?\\nBoard is empty and no words input is provided"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Yeah. I think so"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Getting TLE at 65th testcase"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Solve this one before :https://leetcode.com/problems/word-search/"
                    },
                    {
                        "username": "JorgeLDB",
                        "content": "![image](https://i.ibb.co/FHXHs0d/leet.jpg)\\n\\nHmm... at least I\\'m almost there. "
                    },
                    {
                        "username": "Gizmy",
                        "content": "![image](https://assets.leetcode.com/users/gizmy/image_1568395306.png)\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Going from `b` to `c` is a diagonal move which is forbidden"
                    },
                    {
                        "username": "durgaprasad1541996",
                        "content": "This problem do not expect you to traverse diagonally, that is the reason expected is empty."
                    },
                    {
                        "username": "lance6716",
                        "content": "That\\'s deliberately introduce trie, I can\\'t agree that query words share a long prefix without clearly stated in problem description. If we should consider these case, we should also consider words share suffix, common substring, etc. and trie won\\'t help."
                    },
                    {
                        "username": "piggysolucky",
                        "content": "Because the normal backtracking gave me an error (stack overflow) here."
                    }
                ]
            },
            {
                "id": 1571438,
                "content": [
                    {
                        "username": "ak_3101",
                        "content": "After 2.5 hours of debugging and struggle, I officially hate this question. "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I do not understand testcase 65 / 65.\\nI\\'ve got TLE.\\nBut what does it mean:\\n\\nboard =\\n\\n?\\nWhit empty info about this testcase..."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "This is ridiculous. How am I supposed to solve this in an interview if I\\'ve never seen it before lol"
                    },
                    {
                        "username": "CyrilKamal",
                        "content": "you dont"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "Test case 65 is broken?\\nBoard is empty and no words input is provided"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Yeah. I think so"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Getting TLE at 65th testcase"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Solve this one before :https://leetcode.com/problems/word-search/"
                    },
                    {
                        "username": "JorgeLDB",
                        "content": "![image](https://i.ibb.co/FHXHs0d/leet.jpg)\\n\\nHmm... at least I\\'m almost there. "
                    },
                    {
                        "username": "Gizmy",
                        "content": "![image](https://assets.leetcode.com/users/gizmy/image_1568395306.png)\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Going from `b` to `c` is a diagonal move which is forbidden"
                    },
                    {
                        "username": "durgaprasad1541996",
                        "content": "This problem do not expect you to traverse diagonally, that is the reason expected is empty."
                    },
                    {
                        "username": "lance6716",
                        "content": "That\\'s deliberately introduce trie, I can\\'t agree that query words share a long prefix without clearly stated in problem description. If we should consider these case, we should also consider words share suffix, common substring, etc. and trie won\\'t help."
                    },
                    {
                        "username": "piggysolucky",
                        "content": "Because the normal backtracking gave me an error (stack overflow) here."
                    }
                ]
            },
            {
                "id": 1863478,
                "content": [
                    {
                        "username": "Heisenburgerrr",
                        "content": "Solving this question made me feel so high lol"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I don\\'t think use of tries is at all intuitive because generally words don\\'t share this big prefixes. I feel it should be mentioned somewhere in the question. \\nboard = [[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"]]\\n\\nwords = [\"ababababaa\",\"ababababab\",\"ababababac\",\"ababababad\",\"ababababae\",\"ababababaf\",\"ababababag\",\"ababababah\",\"ababababai\",\"ababababaj\",\"ababababak\",\"ababababal\",\"ababababam\",\"ababababan\",\"ababababao\",\"ababababap\",\"ababababaq\",\"ababababar\",\"ababababas\",\"ababababat\",\"ababababau\",\"ababababav\",\"ababababaw\",\"ababababax\",\"ababababay\",\"ababababaz\",\"ababababba\",\"ababababbb\",\"ababababbc\",\"ababababbd\",\"ababababbe\",\"ababababbf\",\"ababababbg\",\"ababababbh\",\"ababababbi\",\"ababababbj\",\"ababababbk\",\"ababababbl\",\"ababababbm\",\"ababababbn\",\"ababababbo\",\"ababababbp\",\"ababababbq\",\"ababababbr\",\"ababababbs\",\"ababababbt\",\"ababababbu\",\"ababababbv\",\"ababababbw\",\"ababababbx\",\"ababababby\",\"ababababbz\",\"ababababca\",\"ababababcb\",\"ababababcc\",\"ababababcd\",\"ababababce\",\"ababababcf\",\"ababababcg\",\"ababababch\",\"ababababci\",\"ababababcj\",\"ababababck\",\"ababababcl\",\"ababababcm\",\"ababababcn\",\"ababababco\",\"ababababcp\",\"ababababcq\",\"ababababcr\",\"ababababcs\",\"ababababct\",\"ababababcu\",\"ababababcv\",\"ababababcw\",\"ababababcx\",\"ababababcy\",\"ababababcz\",\"ababababda\",\"ababababdb\",\"ababababdc\",\"ababababdd\",\"ababababde\",\"ababababdf\",\"ababababdg\",\"ababababdh\",\"ababababdi\",\"ababababdj\",\"ababababdk\",\"ababababdl\",\"ababababdm\",\"ababababdn\",\"ababababdo\",\"ababababdp\",\"ababababdq\",\"ababababdr\",\"ababababds\",\"ababababdt\",\"ababababdu\",\"ababababdv\",\"ababababdw\",\"ababababdx\",\"ababababdy\",\"ababababdz\",\"ababababea\",\"ababababeb\",\"ababababec\",\"ababababed\",\"ababababee\",\"ababababef\",\"ababababeg\",\"ababababeh\",\"ababababei\",\"ababababej\",\"ababababek\",\"ababababel\",\"ababababem\",\"ababababen\",\"ababababeo\",\"ababababep\",\"ababababeq\",\"ababababer\",\"ababababes\",\"ababababet\",\"ababababeu\",\"ababababev\",\"ababababew\",\"ababababex\",\"ababababey\",\"ababababez\",\"ababababfa\",\"ababababfb\",\"ababababfc\",\"ababababfd\",\"ababababfe\",\"ababababff\",\"ababababfg\",\"ababababfh\",\"ababababfi\",\"ababababfj\",\"ababababfk\",\"ababababfl\",\"ababababfm\",\"ababababfn\",\"ababababfo\",\"ababababfp\",\"ababababfq\",\"ababababfr\",\"ababababfs\",\"ababababft\",\"ababababfu\",\"ababababfv\",\"ababababfw\",\"ababababfx\",\"ababababfy\",\"ababababfz\",\"ababababga\",\"ababababgb\",\"ababababgc\",\"ababababgd\",\"ababababge\",\"ababababgf\",\"ababababgg\",\"ababababgh\",\"ababababgi\",\"ababababgj\",\"ababababgk\",\"ababababgl\",\"ababababgm\",\"ababababgn\",\"ababababgo\",\"ababababgp\",\"ababababgq\",\"ababababgr\",\"ababababgs\",\"ababababgt\",\"ababababgu\",\"ababababgv\",\"ababababgw\",\"ababababgx\",\"ababababgy\",\"ababababgz\",\"ababababha\",\"ababababhb\",\"ababababhc\",\"ababababhd\",\"ababababhe\",\"ababababhf\",\"ababababhg\",\"ababababhh\",\"ababababhi\",\"ababababhj\",\"ababababhk\",\"ababababhl\",\"ababababhm\",\"ababababhn\",\"ababababho\",\"ababababhp\",\"ababababhq\",\"ababababhr\",\"ababababhs\",\"ababababht\",\"ababababhu\",\"ababababhv\",\"ababababhw\",\"ababababhx\",\"ababababhy\",\"ababababhz\",\"ababababia\",\"ababababib\",\"ababababic\",\"ababababid\",\"ababababie\",\"ababababif\",\"ababababig\",\"ababababih\",\"ababababii\",\"ababababij\",\"ababababik\",\"ababababil\",\"ababababim\",\"ababababin\",\"ababababio\",\"ababababip\",\"ababababiq\",\"ababababir\",\"ababababis\",\"ababababit\",\"ababababiu\",\"ababababiv\",\"ababababiw\",\"ababababix\",\"ababababiy\",\"ababababiz\",\"ababababja\",\"ababababjb\",\"ababababjc\",\"ababababjd\",\"ababababje\",\"ababababjf\",\"ababababjg\",\"ababababjh\",\"ababababji\",\"ababababjj\",\"ababababjk\",\"ababababjl\",\"ababababjm\",\"ababababjn\",\"ababababjo\",\"ababababjp\",\"ababababjq\",\"ababababjr\",\"ababababjs\",\"ababababjt\",\"ababababju\",\"ababababjv\",\"ababababjw\",\"ababababjx\",\"ababababjy\",\"ababababjz\",\"ababababka\",\"ababababkb\",\"ababababkc\",\"ababababkd\",\"ababababke\",\"ababababkf\",\"ababababkg\",\"ababababkh\",\"ababababki\",\"ababababkj\",\"ababababkk\",\"ababababkl\",\"ababababkm\",\"ababababkn\",\"ababababko\",\"ababababkp\",\"ababababkq\",\"ababababkr\",\"ababababks\",\"ababababkt\",\"ababababku\",\"ababababkv\",\"ababababkw\",\"ababababkx\",\"ababababky\",\"ababababkz\",\"ababababla\",\"abababablb\",\"abababablc\",\"ababababld\",\"abababable\",\"abababablf\",\"abababablg\",\"abababablh\",\"ababababli\",\"abababablj\",\"abababablk\",\"ababababll\",\"abababablm\",\"ababababln\",\"abababablo\",\"abababablp\",\"abababablq\",\"abababablr\",\"ababababls\",\"abababablt\",\"abababablu\",\"abababablv\",\"abababablw\",\"abababablx\",\"abababably\",\"abababablz\",\"ababababma\",\"ababababmb\",\"ababababmc\",\"ababababmd\",\"ababababme\",\"ababababmf\",\"ababababmg\",\"ababababmh\",\"ababababmi\",\"ababababmj\",\"ababababmk\",\"ababababml\",\"ababababmm\",\"ababababmn\",\"ababababmo\",\"ababababmp\",\"ababababmq\",\"ababababmr\",\"ababababms\",\"ababababmt\",\"ababababmu\",\"ababababmv\",\"ababababmw\",\"ababababmx\",\"ababababmy\",\"ababababmz\",\"ababababna\",\"ababababnb\",\"ababababnc\",\"ababababnd\",\"ababababne\",\"ababababnf\",\"ababababng\",\"ababababnh\",\"ababababni\",\"ababababnj\",\"ababababnk\",\"ababababnl\",\"ababababnm\",\"ababababnn\",\"ababababno\",\"ababababnp\",\"ababababnq\",\"ababababnr\",\"ababababns\",\"ababababnt\",\"ababababnu\",\"ababababnv\",\"ababababnw\",\"ababababnx\",\"ababababny\",\"ababababnz\",\"ababababoa\",\"ababababob\",\"ababababoc\",\"ababababod\",\"ababababoe\",\"ababababof\",\"ababababog\",\"ababababoh\",\"ababababoi\",\"ababababoj\",\"ababababok\",\"ababababol\",\"ababababom\",\"ababababon\",\"ababababoo\",\"ababababop\",\"ababababoq\",\"ababababor\",\"ababababos\",\"ababababot\",\"ababababou\",\"ababababov\",\"ababababow\",\"ababababox\",\"ababababoy\",\"ababababoz\",\"ababababpa\",\"ababababpb\",\"ababababpc\",\"ababababpd\",\"ababababpe\",\"ababababpf\",\"ababababpg\",\"ababababph\",\"ababababpi\",\"ababababpj\",\"ababababpk\",\"ababababpl\",\"ababababpm\",\"ababababpn\",\"ababababpo\",\"ababababpp\",\"ababababpq\",\"ababababpr\",\"ababababps\",\"ababababpt\",\"ababababpu\",\"ababababpv\",\"ababababpw\",\"ababababpx\",\"ababababpy\",\"ababababpz\",\"ababababqa\",\"ababababqb\",\"ababababqc\",\"ababababqd\",\"ababababqe\",\"ababababqf\",\"ababababqg\",\"ababababqh\",\"ababababqi\",\"ababababqj\",\"ababababqk\",\"ababababql\",\"ababababqm\",\"ababababqn\",\"ababababqo\",\"ababababqp\",\"ababababqq\",\"ababababqr\",\"ababababqs\",\"ababababqt\",\"ababababqu\",\"ababababqv\",\"ababababqw\",\"ababababqx\",\"ababababqy\",\"ababababqz\",\"ababababra\",\"ababababrb\",\"ababababrc\",\"ababababrd\",\"ababababre\",\"ababababrf\",\"ababababrg\",\"ababababrh\",\"ababababri\",\"ababababrj\",\"ababababrk\",\"ababababrl\",\"ababababrm\",\"ababababrn\",\"ababababro\",\"ababababrp\",\"ababababrq\",\"ababababrr\",\"ababababrs\",\"ababababrt\",\"ababababru\",\"ababababrv\",\"ababababrw\",\"ababababrx\",\"ababababry\",\"ababababrz\",\"ababababsa\",\"ababababsb\",\"ababababsc\",\"ababababsd\",\"ababababse\",\"ababababsf\",\"ababababsg\",\"ababababsh\",\"ababababsi\",\"ababababsj\",\"ababababsk\",\"ababababsl\",\"ababababsm\",\"ababababsn\",\"ababababso\",\"ababababsp\",\"ababababsq\",\"ababababsr\",\"ababababss\",\"ababababst\",\"ababababsu\",\"ababababsv\",\"ababababsw\",\"ababababsx\",\"ababababsy\",\"ababababsz\",\"ababababta\",\"ababababtb\",\"ababababtc\",\"ababababtd\",\"ababababte\",\"ababababtf\",\"ababababtg\",\"ababababth\",\"ababababti\",\"ababababtj\",\"ababababtk\",\"ababababtl\",\"ababababtm\",\"ababababtn\",\"ababababto\",\"ababababtp\",\"ababababtq\",\"ababababtr\",\"ababababts\",\"ababababtt\",\"ababababtu\",\"ababababtv\",\"ababababtw\",\"ababababtx\",\"ababababty\",\"ababababtz\",\"ababababua\",\"ababababub\",\"ababababuc\",\"ababababud\",\"ababababue\",\"ababababuf\",\"ababababug\",\"ababababuh\",\"ababababui\",\"ababababuj\",\"ababababuk\",\"ababababul\",\"ababababum\",\"ababababun\",\"ababababuo\",\"ababababup\",\"ababababuq\",\"ababababur\",\"ababababus\",\"ababababut\",\"ababababuu\",\"ababababuv\",\"ababababuw\",\"ababababux\",\"ababababuy\",\"ababababuz\",\"ababababva\",\"ababababvb\",\"ababababvc\",\"ababababvd\",\"ababababve\",\"ababababvf\",\"ababababvg\",\"ababababvh\",\"ababababvi\",\"ababababvj\",\"ababababvk\",\"ababababvl\",\"ababababvm\",\"ababababvn\",\"ababababvo\",\"ababababvp\",\"ababababvq\",\"ababababvr\",\"ababababvs\",\"ababababvt\",\"ababababvu\",\"ababababvv\",\"ababababvw\",\"ababababvx\",\"ababababvy\",\"ababababvz\",\"ababababwa\",\"ababababwb\",\"ababababwc\",\"ababababwd\",\"ababababwe\",\"ababababwf\",\"ababababwg\",\"ababababwh\",\"ababababwi\",\"ababababwj\",\"ababababwk\",\"ababababwl\",\"ababababwm\",\"ababababwn\",\"ababababwo\",\"ababababwp\",\"ababababwq\",\"ababababwr\",\"ababababws\",\"ababababwt\",\"ababababwu\",\"ababababwv\",\"ababababww\",\"ababababwx\",\"ababababwy\",\"ababababwz\",\"ababababxa\",\"ababababxb\",\"ababababxc\",\"ababababxd\",\"ababababxe\",\"ababababxf\",\"ababababxg\",\"ababababxh\",\"ababababxi\",\"ababababxj\",\"ababababxk\",\"ababababxl\",\"ababababxm\",\"ababababxn\",\"ababababxo\",\"ababababxp\",\"ababababxq\",\"ababababxr\",\"ababababxs\",\"ababababxt\",\"ababababxu\",\"ababababxv\",\"ababababxw\",\"ababababxx\",\"ababababxy\",\"ababababxz\",\"ababababya\",\"ababababyb\",\"ababababyc\",\"ababababyd\",\"ababababye\",\"ababababyf\",\"ababababyg\",\"ababababyh\",\"ababababyi\",\"ababababyj\",\"ababababyk\",\"ababababyl\",\"ababababym\",\"ababababyn\",\"ababababyo\",\"ababababyp\",\"ababababyq\",\"ababababyr\",\"ababababys\",\"ababababyt\",\"ababababyu\",\"ababababyv\",\"ababababyw\",\"ababababyx\",\"ababababyy\",\"ababababyz\",\"ababababza\",\"ababababzb\",\"ababababzc\",\"ababababzd\",\"ababababze\",\"ababababzf\",\"ababababzg\",\"ababababzh\",\"ababababzi\",\"ababababzj\",\"ababababzk\",\"ababababzl\",\"ababababzm\",\"ababababzn\",\"ababababzo\",\"ababababzp\",\"ababababzq\",\"ababababzr\",\"ababababzs\",\"ababababzt\",\"ababababzu\",\"ababababzv\",\"ababababzw\",\"ababababzx\",\"ababababzy\",\"ababababzz\"]"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "hashmap fails at this test case:)"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "After solving this problem, I can\\n- Build a crossword puzzle app\\n- Add it to my resume\\n- Hope to get a job"
                    },
                    {
                        "username": "Vikas_Sen",
                        "content": "can not this question be solved without Trie. I have not covered this topic yet. I\\'ve solved word search problem-I easily. how can this question be solved with that methos?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Vikas Sen](/Codeverse_1) Yes!"
                    },
                    {
                        "username": "zooperman",
                        "content": "Hello Mods,\\n\\nthe program seems to run fine with TC-3, when run stand-alone, or with other TC\\'s, but when this is submitted for evaluation, it fails.\\nPlease check this.\\nThe TC-3, runs as expected on my laptop as well, along with other TC\\'s.![image](https://assets.leetcode.com/users/zooperman/image_1589425337.png)\\n"
                    },
                    {
                        "username": "greedycat",
                        "content": "They seem the same but Q212 is ranked hard and Q079 is ranked medium. Am I missing something? The only difference I can spot is in Q212 you search for multiple words in a list. But isn\\'t this change trivial because I can just repeat Q079 for the list?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@greedycat](/greedycat) For P79: length.word is15 and board is 6*6, only a single word. A mere DFS can pass without TLE. But for a list of words, Trie/treenode or dict are far from good. \nI try so hard to improve my DFS/path&graph. Finally, It works! But it's nothing compare to Trie."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Yes but I think they want something else, it looks like a trie or something. for multiple words that starts with same prefix rather than applying 79 on each word, use the prefix and search for both words."
                    },
                    {
                        "username": "user5502m",
                        "content": "I was thinking that too"
                    },
                    {
                        "username": "sarthak13",
                        "content": "[[\"a\"]]\\n[\"a\",\"a\"]\\n\\nOutput is \"a\".\\nAs per the question it should be \"a\",\"a\".\\n\\nAm I missing anything?"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "How is the matching any different than https://leetcode.com/problems/word-break-ii/ ?"
                    },
                    {
                        "username": "gglmg",
                        "content": "Question  says you cannot use same letter more than once but the example given has used 't' in both oath and eat.\\n\\nWhat am I missing here.\\n'"
                    },
                    {
                        "username": "palakons",
                        "content": "also, not the same letter per se, but same (row,col) position"
                    },
                    {
                        "username": "AyushSinha",
                        "content": "I think the same letter shouldn\\'t be used twice in the same word."
                    },
                    {
                        "username": "dskloet",
                        "content": "Why is this problem about speed? The inputs were crafted to fail some non-optimized solutions but not others. I bet none of the posted solutions pass this input:\\n\\n[[\"x\",\"x\",\"a\",\"x\",\"x\"],[\"x\",\"o\",\"o\",\"o\",\"o\"],[\"x\",\"o\",\"o\",\"o\",\"o\"],[\"x\",\"x\",\"o\",\"x\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"x\"],[\"x\",\"x\",\"o\",\"x\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"b\"]]\\n[\"aooooooooooooooooooooooooooooooooooooooooooooooooooooob\"]"
                    },
                    {
                        "username": "charonme",
                        "content": "it says: \"Invalid Testcase\\nexpected \\'board\\' to have 1 <= size <= 12 but got 15\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@dskloet](/dskloet)\nMy pure DFS solution 989ms in Leetcode, solve your problem only: 1.9944 miliseconds\n\ncheck data  # | i&j = [14, 4], word= b b 54\n['aooooooooooooooooooooooooooooooooooooooooooooooooooooob']\n\nBut Trie gets TLE for sure.\n\t"
                    },
                    {
                        "username": "echobeacon",
                        "content": "Problem constraints say all words are 10 characters or less"
                    },
                    {
                        "username": "Fluffy_Memory_6238",
                        "content": "If word exceeds m or n we can simply leave that one? also m,n<=12"
                    }
                ]
            },
            {
                "id": 1722308,
                "content": [
                    {
                        "username": "Heisenburgerrr",
                        "content": "Solving this question made me feel so high lol"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I don\\'t think use of tries is at all intuitive because generally words don\\'t share this big prefixes. I feel it should be mentioned somewhere in the question. \\nboard = [[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"]]\\n\\nwords = [\"ababababaa\",\"ababababab\",\"ababababac\",\"ababababad\",\"ababababae\",\"ababababaf\",\"ababababag\",\"ababababah\",\"ababababai\",\"ababababaj\",\"ababababak\",\"ababababal\",\"ababababam\",\"ababababan\",\"ababababao\",\"ababababap\",\"ababababaq\",\"ababababar\",\"ababababas\",\"ababababat\",\"ababababau\",\"ababababav\",\"ababababaw\",\"ababababax\",\"ababababay\",\"ababababaz\",\"ababababba\",\"ababababbb\",\"ababababbc\",\"ababababbd\",\"ababababbe\",\"ababababbf\",\"ababababbg\",\"ababababbh\",\"ababababbi\",\"ababababbj\",\"ababababbk\",\"ababababbl\",\"ababababbm\",\"ababababbn\",\"ababababbo\",\"ababababbp\",\"ababababbq\",\"ababababbr\",\"ababababbs\",\"ababababbt\",\"ababababbu\",\"ababababbv\",\"ababababbw\",\"ababababbx\",\"ababababby\",\"ababababbz\",\"ababababca\",\"ababababcb\",\"ababababcc\",\"ababababcd\",\"ababababce\",\"ababababcf\",\"ababababcg\",\"ababababch\",\"ababababci\",\"ababababcj\",\"ababababck\",\"ababababcl\",\"ababababcm\",\"ababababcn\",\"ababababco\",\"ababababcp\",\"ababababcq\",\"ababababcr\",\"ababababcs\",\"ababababct\",\"ababababcu\",\"ababababcv\",\"ababababcw\",\"ababababcx\",\"ababababcy\",\"ababababcz\",\"ababababda\",\"ababababdb\",\"ababababdc\",\"ababababdd\",\"ababababde\",\"ababababdf\",\"ababababdg\",\"ababababdh\",\"ababababdi\",\"ababababdj\",\"ababababdk\",\"ababababdl\",\"ababababdm\",\"ababababdn\",\"ababababdo\",\"ababababdp\",\"ababababdq\",\"ababababdr\",\"ababababds\",\"ababababdt\",\"ababababdu\",\"ababababdv\",\"ababababdw\",\"ababababdx\",\"ababababdy\",\"ababababdz\",\"ababababea\",\"ababababeb\",\"ababababec\",\"ababababed\",\"ababababee\",\"ababababef\",\"ababababeg\",\"ababababeh\",\"ababababei\",\"ababababej\",\"ababababek\",\"ababababel\",\"ababababem\",\"ababababen\",\"ababababeo\",\"ababababep\",\"ababababeq\",\"ababababer\",\"ababababes\",\"ababababet\",\"ababababeu\",\"ababababev\",\"ababababew\",\"ababababex\",\"ababababey\",\"ababababez\",\"ababababfa\",\"ababababfb\",\"ababababfc\",\"ababababfd\",\"ababababfe\",\"ababababff\",\"ababababfg\",\"ababababfh\",\"ababababfi\",\"ababababfj\",\"ababababfk\",\"ababababfl\",\"ababababfm\",\"ababababfn\",\"ababababfo\",\"ababababfp\",\"ababababfq\",\"ababababfr\",\"ababababfs\",\"ababababft\",\"ababababfu\",\"ababababfv\",\"ababababfw\",\"ababababfx\",\"ababababfy\",\"ababababfz\",\"ababababga\",\"ababababgb\",\"ababababgc\",\"ababababgd\",\"ababababge\",\"ababababgf\",\"ababababgg\",\"ababababgh\",\"ababababgi\",\"ababababgj\",\"ababababgk\",\"ababababgl\",\"ababababgm\",\"ababababgn\",\"ababababgo\",\"ababababgp\",\"ababababgq\",\"ababababgr\",\"ababababgs\",\"ababababgt\",\"ababababgu\",\"ababababgv\",\"ababababgw\",\"ababababgx\",\"ababababgy\",\"ababababgz\",\"ababababha\",\"ababababhb\",\"ababababhc\",\"ababababhd\",\"ababababhe\",\"ababababhf\",\"ababababhg\",\"ababababhh\",\"ababababhi\",\"ababababhj\",\"ababababhk\",\"ababababhl\",\"ababababhm\",\"ababababhn\",\"ababababho\",\"ababababhp\",\"ababababhq\",\"ababababhr\",\"ababababhs\",\"ababababht\",\"ababababhu\",\"ababababhv\",\"ababababhw\",\"ababababhx\",\"ababababhy\",\"ababababhz\",\"ababababia\",\"ababababib\",\"ababababic\",\"ababababid\",\"ababababie\",\"ababababif\",\"ababababig\",\"ababababih\",\"ababababii\",\"ababababij\",\"ababababik\",\"ababababil\",\"ababababim\",\"ababababin\",\"ababababio\",\"ababababip\",\"ababababiq\",\"ababababir\",\"ababababis\",\"ababababit\",\"ababababiu\",\"ababababiv\",\"ababababiw\",\"ababababix\",\"ababababiy\",\"ababababiz\",\"ababababja\",\"ababababjb\",\"ababababjc\",\"ababababjd\",\"ababababje\",\"ababababjf\",\"ababababjg\",\"ababababjh\",\"ababababji\",\"ababababjj\",\"ababababjk\",\"ababababjl\",\"ababababjm\",\"ababababjn\",\"ababababjo\",\"ababababjp\",\"ababababjq\",\"ababababjr\",\"ababababjs\",\"ababababjt\",\"ababababju\",\"ababababjv\",\"ababababjw\",\"ababababjx\",\"ababababjy\",\"ababababjz\",\"ababababka\",\"ababababkb\",\"ababababkc\",\"ababababkd\",\"ababababke\",\"ababababkf\",\"ababababkg\",\"ababababkh\",\"ababababki\",\"ababababkj\",\"ababababkk\",\"ababababkl\",\"ababababkm\",\"ababababkn\",\"ababababko\",\"ababababkp\",\"ababababkq\",\"ababababkr\",\"ababababks\",\"ababababkt\",\"ababababku\",\"ababababkv\",\"ababababkw\",\"ababababkx\",\"ababababky\",\"ababababkz\",\"ababababla\",\"abababablb\",\"abababablc\",\"ababababld\",\"abababable\",\"abababablf\",\"abababablg\",\"abababablh\",\"ababababli\",\"abababablj\",\"abababablk\",\"ababababll\",\"abababablm\",\"ababababln\",\"abababablo\",\"abababablp\",\"abababablq\",\"abababablr\",\"ababababls\",\"abababablt\",\"abababablu\",\"abababablv\",\"abababablw\",\"abababablx\",\"abababably\",\"abababablz\",\"ababababma\",\"ababababmb\",\"ababababmc\",\"ababababmd\",\"ababababme\",\"ababababmf\",\"ababababmg\",\"ababababmh\",\"ababababmi\",\"ababababmj\",\"ababababmk\",\"ababababml\",\"ababababmm\",\"ababababmn\",\"ababababmo\",\"ababababmp\",\"ababababmq\",\"ababababmr\",\"ababababms\",\"ababababmt\",\"ababababmu\",\"ababababmv\",\"ababababmw\",\"ababababmx\",\"ababababmy\",\"ababababmz\",\"ababababna\",\"ababababnb\",\"ababababnc\",\"ababababnd\",\"ababababne\",\"ababababnf\",\"ababababng\",\"ababababnh\",\"ababababni\",\"ababababnj\",\"ababababnk\",\"ababababnl\",\"ababababnm\",\"ababababnn\",\"ababababno\",\"ababababnp\",\"ababababnq\",\"ababababnr\",\"ababababns\",\"ababababnt\",\"ababababnu\",\"ababababnv\",\"ababababnw\",\"ababababnx\",\"ababababny\",\"ababababnz\",\"ababababoa\",\"ababababob\",\"ababababoc\",\"ababababod\",\"ababababoe\",\"ababababof\",\"ababababog\",\"ababababoh\",\"ababababoi\",\"ababababoj\",\"ababababok\",\"ababababol\",\"ababababom\",\"ababababon\",\"ababababoo\",\"ababababop\",\"ababababoq\",\"ababababor\",\"ababababos\",\"ababababot\",\"ababababou\",\"ababababov\",\"ababababow\",\"ababababox\",\"ababababoy\",\"ababababoz\",\"ababababpa\",\"ababababpb\",\"ababababpc\",\"ababababpd\",\"ababababpe\",\"ababababpf\",\"ababababpg\",\"ababababph\",\"ababababpi\",\"ababababpj\",\"ababababpk\",\"ababababpl\",\"ababababpm\",\"ababababpn\",\"ababababpo\",\"ababababpp\",\"ababababpq\",\"ababababpr\",\"ababababps\",\"ababababpt\",\"ababababpu\",\"ababababpv\",\"ababababpw\",\"ababababpx\",\"ababababpy\",\"ababababpz\",\"ababababqa\",\"ababababqb\",\"ababababqc\",\"ababababqd\",\"ababababqe\",\"ababababqf\",\"ababababqg\",\"ababababqh\",\"ababababqi\",\"ababababqj\",\"ababababqk\",\"ababababql\",\"ababababqm\",\"ababababqn\",\"ababababqo\",\"ababababqp\",\"ababababqq\",\"ababababqr\",\"ababababqs\",\"ababababqt\",\"ababababqu\",\"ababababqv\",\"ababababqw\",\"ababababqx\",\"ababababqy\",\"ababababqz\",\"ababababra\",\"ababababrb\",\"ababababrc\",\"ababababrd\",\"ababababre\",\"ababababrf\",\"ababababrg\",\"ababababrh\",\"ababababri\",\"ababababrj\",\"ababababrk\",\"ababababrl\",\"ababababrm\",\"ababababrn\",\"ababababro\",\"ababababrp\",\"ababababrq\",\"ababababrr\",\"ababababrs\",\"ababababrt\",\"ababababru\",\"ababababrv\",\"ababababrw\",\"ababababrx\",\"ababababry\",\"ababababrz\",\"ababababsa\",\"ababababsb\",\"ababababsc\",\"ababababsd\",\"ababababse\",\"ababababsf\",\"ababababsg\",\"ababababsh\",\"ababababsi\",\"ababababsj\",\"ababababsk\",\"ababababsl\",\"ababababsm\",\"ababababsn\",\"ababababso\",\"ababababsp\",\"ababababsq\",\"ababababsr\",\"ababababss\",\"ababababst\",\"ababababsu\",\"ababababsv\",\"ababababsw\",\"ababababsx\",\"ababababsy\",\"ababababsz\",\"ababababta\",\"ababababtb\",\"ababababtc\",\"ababababtd\",\"ababababte\",\"ababababtf\",\"ababababtg\",\"ababababth\",\"ababababti\",\"ababababtj\",\"ababababtk\",\"ababababtl\",\"ababababtm\",\"ababababtn\",\"ababababto\",\"ababababtp\",\"ababababtq\",\"ababababtr\",\"ababababts\",\"ababababtt\",\"ababababtu\",\"ababababtv\",\"ababababtw\",\"ababababtx\",\"ababababty\",\"ababababtz\",\"ababababua\",\"ababababub\",\"ababababuc\",\"ababababud\",\"ababababue\",\"ababababuf\",\"ababababug\",\"ababababuh\",\"ababababui\",\"ababababuj\",\"ababababuk\",\"ababababul\",\"ababababum\",\"ababababun\",\"ababababuo\",\"ababababup\",\"ababababuq\",\"ababababur\",\"ababababus\",\"ababababut\",\"ababababuu\",\"ababababuv\",\"ababababuw\",\"ababababux\",\"ababababuy\",\"ababababuz\",\"ababababva\",\"ababababvb\",\"ababababvc\",\"ababababvd\",\"ababababve\",\"ababababvf\",\"ababababvg\",\"ababababvh\",\"ababababvi\",\"ababababvj\",\"ababababvk\",\"ababababvl\",\"ababababvm\",\"ababababvn\",\"ababababvo\",\"ababababvp\",\"ababababvq\",\"ababababvr\",\"ababababvs\",\"ababababvt\",\"ababababvu\",\"ababababvv\",\"ababababvw\",\"ababababvx\",\"ababababvy\",\"ababababvz\",\"ababababwa\",\"ababababwb\",\"ababababwc\",\"ababababwd\",\"ababababwe\",\"ababababwf\",\"ababababwg\",\"ababababwh\",\"ababababwi\",\"ababababwj\",\"ababababwk\",\"ababababwl\",\"ababababwm\",\"ababababwn\",\"ababababwo\",\"ababababwp\",\"ababababwq\",\"ababababwr\",\"ababababws\",\"ababababwt\",\"ababababwu\",\"ababababwv\",\"ababababww\",\"ababababwx\",\"ababababwy\",\"ababababwz\",\"ababababxa\",\"ababababxb\",\"ababababxc\",\"ababababxd\",\"ababababxe\",\"ababababxf\",\"ababababxg\",\"ababababxh\",\"ababababxi\",\"ababababxj\",\"ababababxk\",\"ababababxl\",\"ababababxm\",\"ababababxn\",\"ababababxo\",\"ababababxp\",\"ababababxq\",\"ababababxr\",\"ababababxs\",\"ababababxt\",\"ababababxu\",\"ababababxv\",\"ababababxw\",\"ababababxx\",\"ababababxy\",\"ababababxz\",\"ababababya\",\"ababababyb\",\"ababababyc\",\"ababababyd\",\"ababababye\",\"ababababyf\",\"ababababyg\",\"ababababyh\",\"ababababyi\",\"ababababyj\",\"ababababyk\",\"ababababyl\",\"ababababym\",\"ababababyn\",\"ababababyo\",\"ababababyp\",\"ababababyq\",\"ababababyr\",\"ababababys\",\"ababababyt\",\"ababababyu\",\"ababababyv\",\"ababababyw\",\"ababababyx\",\"ababababyy\",\"ababababyz\",\"ababababza\",\"ababababzb\",\"ababababzc\",\"ababababzd\",\"ababababze\",\"ababababzf\",\"ababababzg\",\"ababababzh\",\"ababababzi\",\"ababababzj\",\"ababababzk\",\"ababababzl\",\"ababababzm\",\"ababababzn\",\"ababababzo\",\"ababababzp\",\"ababababzq\",\"ababababzr\",\"ababababzs\",\"ababababzt\",\"ababababzu\",\"ababababzv\",\"ababababzw\",\"ababababzx\",\"ababababzy\",\"ababababzz\"]"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "hashmap fails at this test case:)"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "After solving this problem, I can\\n- Build a crossword puzzle app\\n- Add it to my resume\\n- Hope to get a job"
                    },
                    {
                        "username": "Vikas_Sen",
                        "content": "can not this question be solved without Trie. I have not covered this topic yet. I\\'ve solved word search problem-I easily. how can this question be solved with that methos?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Vikas Sen](/Codeverse_1) Yes!"
                    },
                    {
                        "username": "zooperman",
                        "content": "Hello Mods,\\n\\nthe program seems to run fine with TC-3, when run stand-alone, or with other TC\\'s, but when this is submitted for evaluation, it fails.\\nPlease check this.\\nThe TC-3, runs as expected on my laptop as well, along with other TC\\'s.![image](https://assets.leetcode.com/users/zooperman/image_1589425337.png)\\n"
                    },
                    {
                        "username": "greedycat",
                        "content": "They seem the same but Q212 is ranked hard and Q079 is ranked medium. Am I missing something? The only difference I can spot is in Q212 you search for multiple words in a list. But isn\\'t this change trivial because I can just repeat Q079 for the list?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@greedycat](/greedycat) For P79: length.word is15 and board is 6*6, only a single word. A mere DFS can pass without TLE. But for a list of words, Trie/treenode or dict are far from good. \nI try so hard to improve my DFS/path&graph. Finally, It works! But it's nothing compare to Trie."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Yes but I think they want something else, it looks like a trie or something. for multiple words that starts with same prefix rather than applying 79 on each word, use the prefix and search for both words."
                    },
                    {
                        "username": "user5502m",
                        "content": "I was thinking that too"
                    },
                    {
                        "username": "sarthak13",
                        "content": "[[\"a\"]]\\n[\"a\",\"a\"]\\n\\nOutput is \"a\".\\nAs per the question it should be \"a\",\"a\".\\n\\nAm I missing anything?"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "How is the matching any different than https://leetcode.com/problems/word-break-ii/ ?"
                    },
                    {
                        "username": "gglmg",
                        "content": "Question  says you cannot use same letter more than once but the example given has used 't' in both oath and eat.\\n\\nWhat am I missing here.\\n'"
                    },
                    {
                        "username": "palakons",
                        "content": "also, not the same letter per se, but same (row,col) position"
                    },
                    {
                        "username": "AyushSinha",
                        "content": "I think the same letter shouldn\\'t be used twice in the same word."
                    },
                    {
                        "username": "dskloet",
                        "content": "Why is this problem about speed? The inputs were crafted to fail some non-optimized solutions but not others. I bet none of the posted solutions pass this input:\\n\\n[[\"x\",\"x\",\"a\",\"x\",\"x\"],[\"x\",\"o\",\"o\",\"o\",\"o\"],[\"x\",\"o\",\"o\",\"o\",\"o\"],[\"x\",\"x\",\"o\",\"x\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"x\"],[\"x\",\"x\",\"o\",\"x\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"b\"]]\\n[\"aooooooooooooooooooooooooooooooooooooooooooooooooooooob\"]"
                    },
                    {
                        "username": "charonme",
                        "content": "it says: \"Invalid Testcase\\nexpected \\'board\\' to have 1 <= size <= 12 but got 15\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@dskloet](/dskloet)\nMy pure DFS solution 989ms in Leetcode, solve your problem only: 1.9944 miliseconds\n\ncheck data  # | i&j = [14, 4], word= b b 54\n['aooooooooooooooooooooooooooooooooooooooooooooooooooooob']\n\nBut Trie gets TLE for sure.\n\t"
                    },
                    {
                        "username": "echobeacon",
                        "content": "Problem constraints say all words are 10 characters or less"
                    },
                    {
                        "username": "Fluffy_Memory_6238",
                        "content": "If word exceeds m or n we can simply leave that one? also m,n<=12"
                    }
                ]
            },
            {
                "id": 1676889,
                "content": [
                    {
                        "username": "Heisenburgerrr",
                        "content": "Solving this question made me feel so high lol"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I don\\'t think use of tries is at all intuitive because generally words don\\'t share this big prefixes. I feel it should be mentioned somewhere in the question. \\nboard = [[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"]]\\n\\nwords = [\"ababababaa\",\"ababababab\",\"ababababac\",\"ababababad\",\"ababababae\",\"ababababaf\",\"ababababag\",\"ababababah\",\"ababababai\",\"ababababaj\",\"ababababak\",\"ababababal\",\"ababababam\",\"ababababan\",\"ababababao\",\"ababababap\",\"ababababaq\",\"ababababar\",\"ababababas\",\"ababababat\",\"ababababau\",\"ababababav\",\"ababababaw\",\"ababababax\",\"ababababay\",\"ababababaz\",\"ababababba\",\"ababababbb\",\"ababababbc\",\"ababababbd\",\"ababababbe\",\"ababababbf\",\"ababababbg\",\"ababababbh\",\"ababababbi\",\"ababababbj\",\"ababababbk\",\"ababababbl\",\"ababababbm\",\"ababababbn\",\"ababababbo\",\"ababababbp\",\"ababababbq\",\"ababababbr\",\"ababababbs\",\"ababababbt\",\"ababababbu\",\"ababababbv\",\"ababababbw\",\"ababababbx\",\"ababababby\",\"ababababbz\",\"ababababca\",\"ababababcb\",\"ababababcc\",\"ababababcd\",\"ababababce\",\"ababababcf\",\"ababababcg\",\"ababababch\",\"ababababci\",\"ababababcj\",\"ababababck\",\"ababababcl\",\"ababababcm\",\"ababababcn\",\"ababababco\",\"ababababcp\",\"ababababcq\",\"ababababcr\",\"ababababcs\",\"ababababct\",\"ababababcu\",\"ababababcv\",\"ababababcw\",\"ababababcx\",\"ababababcy\",\"ababababcz\",\"ababababda\",\"ababababdb\",\"ababababdc\",\"ababababdd\",\"ababababde\",\"ababababdf\",\"ababababdg\",\"ababababdh\",\"ababababdi\",\"ababababdj\",\"ababababdk\",\"ababababdl\",\"ababababdm\",\"ababababdn\",\"ababababdo\",\"ababababdp\",\"ababababdq\",\"ababababdr\",\"ababababds\",\"ababababdt\",\"ababababdu\",\"ababababdv\",\"ababababdw\",\"ababababdx\",\"ababababdy\",\"ababababdz\",\"ababababea\",\"ababababeb\",\"ababababec\",\"ababababed\",\"ababababee\",\"ababababef\",\"ababababeg\",\"ababababeh\",\"ababababei\",\"ababababej\",\"ababababek\",\"ababababel\",\"ababababem\",\"ababababen\",\"ababababeo\",\"ababababep\",\"ababababeq\",\"ababababer\",\"ababababes\",\"ababababet\",\"ababababeu\",\"ababababev\",\"ababababew\",\"ababababex\",\"ababababey\",\"ababababez\",\"ababababfa\",\"ababababfb\",\"ababababfc\",\"ababababfd\",\"ababababfe\",\"ababababff\",\"ababababfg\",\"ababababfh\",\"ababababfi\",\"ababababfj\",\"ababababfk\",\"ababababfl\",\"ababababfm\",\"ababababfn\",\"ababababfo\",\"ababababfp\",\"ababababfq\",\"ababababfr\",\"ababababfs\",\"ababababft\",\"ababababfu\",\"ababababfv\",\"ababababfw\",\"ababababfx\",\"ababababfy\",\"ababababfz\",\"ababababga\",\"ababababgb\",\"ababababgc\",\"ababababgd\",\"ababababge\",\"ababababgf\",\"ababababgg\",\"ababababgh\",\"ababababgi\",\"ababababgj\",\"ababababgk\",\"ababababgl\",\"ababababgm\",\"ababababgn\",\"ababababgo\",\"ababababgp\",\"ababababgq\",\"ababababgr\",\"ababababgs\",\"ababababgt\",\"ababababgu\",\"ababababgv\",\"ababababgw\",\"ababababgx\",\"ababababgy\",\"ababababgz\",\"ababababha\",\"ababababhb\",\"ababababhc\",\"ababababhd\",\"ababababhe\",\"ababababhf\",\"ababababhg\",\"ababababhh\",\"ababababhi\",\"ababababhj\",\"ababababhk\",\"ababababhl\",\"ababababhm\",\"ababababhn\",\"ababababho\",\"ababababhp\",\"ababababhq\",\"ababababhr\",\"ababababhs\",\"ababababht\",\"ababababhu\",\"ababababhv\",\"ababababhw\",\"ababababhx\",\"ababababhy\",\"ababababhz\",\"ababababia\",\"ababababib\",\"ababababic\",\"ababababid\",\"ababababie\",\"ababababif\",\"ababababig\",\"ababababih\",\"ababababii\",\"ababababij\",\"ababababik\",\"ababababil\",\"ababababim\",\"ababababin\",\"ababababio\",\"ababababip\",\"ababababiq\",\"ababababir\",\"ababababis\",\"ababababit\",\"ababababiu\",\"ababababiv\",\"ababababiw\",\"ababababix\",\"ababababiy\",\"ababababiz\",\"ababababja\",\"ababababjb\",\"ababababjc\",\"ababababjd\",\"ababababje\",\"ababababjf\",\"ababababjg\",\"ababababjh\",\"ababababji\",\"ababababjj\",\"ababababjk\",\"ababababjl\",\"ababababjm\",\"ababababjn\",\"ababababjo\",\"ababababjp\",\"ababababjq\",\"ababababjr\",\"ababababjs\",\"ababababjt\",\"ababababju\",\"ababababjv\",\"ababababjw\",\"ababababjx\",\"ababababjy\",\"ababababjz\",\"ababababka\",\"ababababkb\",\"ababababkc\",\"ababababkd\",\"ababababke\",\"ababababkf\",\"ababababkg\",\"ababababkh\",\"ababababki\",\"ababababkj\",\"ababababkk\",\"ababababkl\",\"ababababkm\",\"ababababkn\",\"ababababko\",\"ababababkp\",\"ababababkq\",\"ababababkr\",\"ababababks\",\"ababababkt\",\"ababababku\",\"ababababkv\",\"ababababkw\",\"ababababkx\",\"ababababky\",\"ababababkz\",\"ababababla\",\"abababablb\",\"abababablc\",\"ababababld\",\"abababable\",\"abababablf\",\"abababablg\",\"abababablh\",\"ababababli\",\"abababablj\",\"abababablk\",\"ababababll\",\"abababablm\",\"ababababln\",\"abababablo\",\"abababablp\",\"abababablq\",\"abababablr\",\"ababababls\",\"abababablt\",\"abababablu\",\"abababablv\",\"abababablw\",\"abababablx\",\"abababably\",\"abababablz\",\"ababababma\",\"ababababmb\",\"ababababmc\",\"ababababmd\",\"ababababme\",\"ababababmf\",\"ababababmg\",\"ababababmh\",\"ababababmi\",\"ababababmj\",\"ababababmk\",\"ababababml\",\"ababababmm\",\"ababababmn\",\"ababababmo\",\"ababababmp\",\"ababababmq\",\"ababababmr\",\"ababababms\",\"ababababmt\",\"ababababmu\",\"ababababmv\",\"ababababmw\",\"ababababmx\",\"ababababmy\",\"ababababmz\",\"ababababna\",\"ababababnb\",\"ababababnc\",\"ababababnd\",\"ababababne\",\"ababababnf\",\"ababababng\",\"ababababnh\",\"ababababni\",\"ababababnj\",\"ababababnk\",\"ababababnl\",\"ababababnm\",\"ababababnn\",\"ababababno\",\"ababababnp\",\"ababababnq\",\"ababababnr\",\"ababababns\",\"ababababnt\",\"ababababnu\",\"ababababnv\",\"ababababnw\",\"ababababnx\",\"ababababny\",\"ababababnz\",\"ababababoa\",\"ababababob\",\"ababababoc\",\"ababababod\",\"ababababoe\",\"ababababof\",\"ababababog\",\"ababababoh\",\"ababababoi\",\"ababababoj\",\"ababababok\",\"ababababol\",\"ababababom\",\"ababababon\",\"ababababoo\",\"ababababop\",\"ababababoq\",\"ababababor\",\"ababababos\",\"ababababot\",\"ababababou\",\"ababababov\",\"ababababow\",\"ababababox\",\"ababababoy\",\"ababababoz\",\"ababababpa\",\"ababababpb\",\"ababababpc\",\"ababababpd\",\"ababababpe\",\"ababababpf\",\"ababababpg\",\"ababababph\",\"ababababpi\",\"ababababpj\",\"ababababpk\",\"ababababpl\",\"ababababpm\",\"ababababpn\",\"ababababpo\",\"ababababpp\",\"ababababpq\",\"ababababpr\",\"ababababps\",\"ababababpt\",\"ababababpu\",\"ababababpv\",\"ababababpw\",\"ababababpx\",\"ababababpy\",\"ababababpz\",\"ababababqa\",\"ababababqb\",\"ababababqc\",\"ababababqd\",\"ababababqe\",\"ababababqf\",\"ababababqg\",\"ababababqh\",\"ababababqi\",\"ababababqj\",\"ababababqk\",\"ababababql\",\"ababababqm\",\"ababababqn\",\"ababababqo\",\"ababababqp\",\"ababababqq\",\"ababababqr\",\"ababababqs\",\"ababababqt\",\"ababababqu\",\"ababababqv\",\"ababababqw\",\"ababababqx\",\"ababababqy\",\"ababababqz\",\"ababababra\",\"ababababrb\",\"ababababrc\",\"ababababrd\",\"ababababre\",\"ababababrf\",\"ababababrg\",\"ababababrh\",\"ababababri\",\"ababababrj\",\"ababababrk\",\"ababababrl\",\"ababababrm\",\"ababababrn\",\"ababababro\",\"ababababrp\",\"ababababrq\",\"ababababrr\",\"ababababrs\",\"ababababrt\",\"ababababru\",\"ababababrv\",\"ababababrw\",\"ababababrx\",\"ababababry\",\"ababababrz\",\"ababababsa\",\"ababababsb\",\"ababababsc\",\"ababababsd\",\"ababababse\",\"ababababsf\",\"ababababsg\",\"ababababsh\",\"ababababsi\",\"ababababsj\",\"ababababsk\",\"ababababsl\",\"ababababsm\",\"ababababsn\",\"ababababso\",\"ababababsp\",\"ababababsq\",\"ababababsr\",\"ababababss\",\"ababababst\",\"ababababsu\",\"ababababsv\",\"ababababsw\",\"ababababsx\",\"ababababsy\",\"ababababsz\",\"ababababta\",\"ababababtb\",\"ababababtc\",\"ababababtd\",\"ababababte\",\"ababababtf\",\"ababababtg\",\"ababababth\",\"ababababti\",\"ababababtj\",\"ababababtk\",\"ababababtl\",\"ababababtm\",\"ababababtn\",\"ababababto\",\"ababababtp\",\"ababababtq\",\"ababababtr\",\"ababababts\",\"ababababtt\",\"ababababtu\",\"ababababtv\",\"ababababtw\",\"ababababtx\",\"ababababty\",\"ababababtz\",\"ababababua\",\"ababababub\",\"ababababuc\",\"ababababud\",\"ababababue\",\"ababababuf\",\"ababababug\",\"ababababuh\",\"ababababui\",\"ababababuj\",\"ababababuk\",\"ababababul\",\"ababababum\",\"ababababun\",\"ababababuo\",\"ababababup\",\"ababababuq\",\"ababababur\",\"ababababus\",\"ababababut\",\"ababababuu\",\"ababababuv\",\"ababababuw\",\"ababababux\",\"ababababuy\",\"ababababuz\",\"ababababva\",\"ababababvb\",\"ababababvc\",\"ababababvd\",\"ababababve\",\"ababababvf\",\"ababababvg\",\"ababababvh\",\"ababababvi\",\"ababababvj\",\"ababababvk\",\"ababababvl\",\"ababababvm\",\"ababababvn\",\"ababababvo\",\"ababababvp\",\"ababababvq\",\"ababababvr\",\"ababababvs\",\"ababababvt\",\"ababababvu\",\"ababababvv\",\"ababababvw\",\"ababababvx\",\"ababababvy\",\"ababababvz\",\"ababababwa\",\"ababababwb\",\"ababababwc\",\"ababababwd\",\"ababababwe\",\"ababababwf\",\"ababababwg\",\"ababababwh\",\"ababababwi\",\"ababababwj\",\"ababababwk\",\"ababababwl\",\"ababababwm\",\"ababababwn\",\"ababababwo\",\"ababababwp\",\"ababababwq\",\"ababababwr\",\"ababababws\",\"ababababwt\",\"ababababwu\",\"ababababwv\",\"ababababww\",\"ababababwx\",\"ababababwy\",\"ababababwz\",\"ababababxa\",\"ababababxb\",\"ababababxc\",\"ababababxd\",\"ababababxe\",\"ababababxf\",\"ababababxg\",\"ababababxh\",\"ababababxi\",\"ababababxj\",\"ababababxk\",\"ababababxl\",\"ababababxm\",\"ababababxn\",\"ababababxo\",\"ababababxp\",\"ababababxq\",\"ababababxr\",\"ababababxs\",\"ababababxt\",\"ababababxu\",\"ababababxv\",\"ababababxw\",\"ababababxx\",\"ababababxy\",\"ababababxz\",\"ababababya\",\"ababababyb\",\"ababababyc\",\"ababababyd\",\"ababababye\",\"ababababyf\",\"ababababyg\",\"ababababyh\",\"ababababyi\",\"ababababyj\",\"ababababyk\",\"ababababyl\",\"ababababym\",\"ababababyn\",\"ababababyo\",\"ababababyp\",\"ababababyq\",\"ababababyr\",\"ababababys\",\"ababababyt\",\"ababababyu\",\"ababababyv\",\"ababababyw\",\"ababababyx\",\"ababababyy\",\"ababababyz\",\"ababababza\",\"ababababzb\",\"ababababzc\",\"ababababzd\",\"ababababze\",\"ababababzf\",\"ababababzg\",\"ababababzh\",\"ababababzi\",\"ababababzj\",\"ababababzk\",\"ababababzl\",\"ababababzm\",\"ababababzn\",\"ababababzo\",\"ababababzp\",\"ababababzq\",\"ababababzr\",\"ababababzs\",\"ababababzt\",\"ababababzu\",\"ababababzv\",\"ababababzw\",\"ababababzx\",\"ababababzy\",\"ababababzz\"]"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "hashmap fails at this test case:)"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "After solving this problem, I can\\n- Build a crossword puzzle app\\n- Add it to my resume\\n- Hope to get a job"
                    },
                    {
                        "username": "Vikas_Sen",
                        "content": "can not this question be solved without Trie. I have not covered this topic yet. I\\'ve solved word search problem-I easily. how can this question be solved with that methos?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Vikas Sen](/Codeverse_1) Yes!"
                    },
                    {
                        "username": "zooperman",
                        "content": "Hello Mods,\\n\\nthe program seems to run fine with TC-3, when run stand-alone, or with other TC\\'s, but when this is submitted for evaluation, it fails.\\nPlease check this.\\nThe TC-3, runs as expected on my laptop as well, along with other TC\\'s.![image](https://assets.leetcode.com/users/zooperman/image_1589425337.png)\\n"
                    },
                    {
                        "username": "greedycat",
                        "content": "They seem the same but Q212 is ranked hard and Q079 is ranked medium. Am I missing something? The only difference I can spot is in Q212 you search for multiple words in a list. But isn\\'t this change trivial because I can just repeat Q079 for the list?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@greedycat](/greedycat) For P79: length.word is15 and board is 6*6, only a single word. A mere DFS can pass without TLE. But for a list of words, Trie/treenode or dict are far from good. \nI try so hard to improve my DFS/path&graph. Finally, It works! But it's nothing compare to Trie."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Yes but I think they want something else, it looks like a trie or something. for multiple words that starts with same prefix rather than applying 79 on each word, use the prefix and search for both words."
                    },
                    {
                        "username": "user5502m",
                        "content": "I was thinking that too"
                    },
                    {
                        "username": "sarthak13",
                        "content": "[[\"a\"]]\\n[\"a\",\"a\"]\\n\\nOutput is \"a\".\\nAs per the question it should be \"a\",\"a\".\\n\\nAm I missing anything?"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "How is the matching any different than https://leetcode.com/problems/word-break-ii/ ?"
                    },
                    {
                        "username": "gglmg",
                        "content": "Question  says you cannot use same letter more than once but the example given has used 't' in both oath and eat.\\n\\nWhat am I missing here.\\n'"
                    },
                    {
                        "username": "palakons",
                        "content": "also, not the same letter per se, but same (row,col) position"
                    },
                    {
                        "username": "AyushSinha",
                        "content": "I think the same letter shouldn\\'t be used twice in the same word."
                    },
                    {
                        "username": "dskloet",
                        "content": "Why is this problem about speed? The inputs were crafted to fail some non-optimized solutions but not others. I bet none of the posted solutions pass this input:\\n\\n[[\"x\",\"x\",\"a\",\"x\",\"x\"],[\"x\",\"o\",\"o\",\"o\",\"o\"],[\"x\",\"o\",\"o\",\"o\",\"o\"],[\"x\",\"x\",\"o\",\"x\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"x\"],[\"x\",\"x\",\"o\",\"x\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"b\"]]\\n[\"aooooooooooooooooooooooooooooooooooooooooooooooooooooob\"]"
                    },
                    {
                        "username": "charonme",
                        "content": "it says: \"Invalid Testcase\\nexpected \\'board\\' to have 1 <= size <= 12 but got 15\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@dskloet](/dskloet)\nMy pure DFS solution 989ms in Leetcode, solve your problem only: 1.9944 miliseconds\n\ncheck data  # | i&j = [14, 4], word= b b 54\n['aooooooooooooooooooooooooooooooooooooooooooooooooooooob']\n\nBut Trie gets TLE for sure.\n\t"
                    },
                    {
                        "username": "echobeacon",
                        "content": "Problem constraints say all words are 10 characters or less"
                    },
                    {
                        "username": "Fluffy_Memory_6238",
                        "content": "If word exceeds m or n we can simply leave that one? also m,n<=12"
                    }
                ]
            },
            {
                "id": 1671781,
                "content": [
                    {
                        "username": "Heisenburgerrr",
                        "content": "Solving this question made me feel so high lol"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I don\\'t think use of tries is at all intuitive because generally words don\\'t share this big prefixes. I feel it should be mentioned somewhere in the question. \\nboard = [[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"]]\\n\\nwords = [\"ababababaa\",\"ababababab\",\"ababababac\",\"ababababad\",\"ababababae\",\"ababababaf\",\"ababababag\",\"ababababah\",\"ababababai\",\"ababababaj\",\"ababababak\",\"ababababal\",\"ababababam\",\"ababababan\",\"ababababao\",\"ababababap\",\"ababababaq\",\"ababababar\",\"ababababas\",\"ababababat\",\"ababababau\",\"ababababav\",\"ababababaw\",\"ababababax\",\"ababababay\",\"ababababaz\",\"ababababba\",\"ababababbb\",\"ababababbc\",\"ababababbd\",\"ababababbe\",\"ababababbf\",\"ababababbg\",\"ababababbh\",\"ababababbi\",\"ababababbj\",\"ababababbk\",\"ababababbl\",\"ababababbm\",\"ababababbn\",\"ababababbo\",\"ababababbp\",\"ababababbq\",\"ababababbr\",\"ababababbs\",\"ababababbt\",\"ababababbu\",\"ababababbv\",\"ababababbw\",\"ababababbx\",\"ababababby\",\"ababababbz\",\"ababababca\",\"ababababcb\",\"ababababcc\",\"ababababcd\",\"ababababce\",\"ababababcf\",\"ababababcg\",\"ababababch\",\"ababababci\",\"ababababcj\",\"ababababck\",\"ababababcl\",\"ababababcm\",\"ababababcn\",\"ababababco\",\"ababababcp\",\"ababababcq\",\"ababababcr\",\"ababababcs\",\"ababababct\",\"ababababcu\",\"ababababcv\",\"ababababcw\",\"ababababcx\",\"ababababcy\",\"ababababcz\",\"ababababda\",\"ababababdb\",\"ababababdc\",\"ababababdd\",\"ababababde\",\"ababababdf\",\"ababababdg\",\"ababababdh\",\"ababababdi\",\"ababababdj\",\"ababababdk\",\"ababababdl\",\"ababababdm\",\"ababababdn\",\"ababababdo\",\"ababababdp\",\"ababababdq\",\"ababababdr\",\"ababababds\",\"ababababdt\",\"ababababdu\",\"ababababdv\",\"ababababdw\",\"ababababdx\",\"ababababdy\",\"ababababdz\",\"ababababea\",\"ababababeb\",\"ababababec\",\"ababababed\",\"ababababee\",\"ababababef\",\"ababababeg\",\"ababababeh\",\"ababababei\",\"ababababej\",\"ababababek\",\"ababababel\",\"ababababem\",\"ababababen\",\"ababababeo\",\"ababababep\",\"ababababeq\",\"ababababer\",\"ababababes\",\"ababababet\",\"ababababeu\",\"ababababev\",\"ababababew\",\"ababababex\",\"ababababey\",\"ababababez\",\"ababababfa\",\"ababababfb\",\"ababababfc\",\"ababababfd\",\"ababababfe\",\"ababababff\",\"ababababfg\",\"ababababfh\",\"ababababfi\",\"ababababfj\",\"ababababfk\",\"ababababfl\",\"ababababfm\",\"ababababfn\",\"ababababfo\",\"ababababfp\",\"ababababfq\",\"ababababfr\",\"ababababfs\",\"ababababft\",\"ababababfu\",\"ababababfv\",\"ababababfw\",\"ababababfx\",\"ababababfy\",\"ababababfz\",\"ababababga\",\"ababababgb\",\"ababababgc\",\"ababababgd\",\"ababababge\",\"ababababgf\",\"ababababgg\",\"ababababgh\",\"ababababgi\",\"ababababgj\",\"ababababgk\",\"ababababgl\",\"ababababgm\",\"ababababgn\",\"ababababgo\",\"ababababgp\",\"ababababgq\",\"ababababgr\",\"ababababgs\",\"ababababgt\",\"ababababgu\",\"ababababgv\",\"ababababgw\",\"ababababgx\",\"ababababgy\",\"ababababgz\",\"ababababha\",\"ababababhb\",\"ababababhc\",\"ababababhd\",\"ababababhe\",\"ababababhf\",\"ababababhg\",\"ababababhh\",\"ababababhi\",\"ababababhj\",\"ababababhk\",\"ababababhl\",\"ababababhm\",\"ababababhn\",\"ababababho\",\"ababababhp\",\"ababababhq\",\"ababababhr\",\"ababababhs\",\"ababababht\",\"ababababhu\",\"ababababhv\",\"ababababhw\",\"ababababhx\",\"ababababhy\",\"ababababhz\",\"ababababia\",\"ababababib\",\"ababababic\",\"ababababid\",\"ababababie\",\"ababababif\",\"ababababig\",\"ababababih\",\"ababababii\",\"ababababij\",\"ababababik\",\"ababababil\",\"ababababim\",\"ababababin\",\"ababababio\",\"ababababip\",\"ababababiq\",\"ababababir\",\"ababababis\",\"ababababit\",\"ababababiu\",\"ababababiv\",\"ababababiw\",\"ababababix\",\"ababababiy\",\"ababababiz\",\"ababababja\",\"ababababjb\",\"ababababjc\",\"ababababjd\",\"ababababje\",\"ababababjf\",\"ababababjg\",\"ababababjh\",\"ababababji\",\"ababababjj\",\"ababababjk\",\"ababababjl\",\"ababababjm\",\"ababababjn\",\"ababababjo\",\"ababababjp\",\"ababababjq\",\"ababababjr\",\"ababababjs\",\"ababababjt\",\"ababababju\",\"ababababjv\",\"ababababjw\",\"ababababjx\",\"ababababjy\",\"ababababjz\",\"ababababka\",\"ababababkb\",\"ababababkc\",\"ababababkd\",\"ababababke\",\"ababababkf\",\"ababababkg\",\"ababababkh\",\"ababababki\",\"ababababkj\",\"ababababkk\",\"ababababkl\",\"ababababkm\",\"ababababkn\",\"ababababko\",\"ababababkp\",\"ababababkq\",\"ababababkr\",\"ababababks\",\"ababababkt\",\"ababababku\",\"ababababkv\",\"ababababkw\",\"ababababkx\",\"ababababky\",\"ababababkz\",\"ababababla\",\"abababablb\",\"abababablc\",\"ababababld\",\"abababable\",\"abababablf\",\"abababablg\",\"abababablh\",\"ababababli\",\"abababablj\",\"abababablk\",\"ababababll\",\"abababablm\",\"ababababln\",\"abababablo\",\"abababablp\",\"abababablq\",\"abababablr\",\"ababababls\",\"abababablt\",\"abababablu\",\"abababablv\",\"abababablw\",\"abababablx\",\"abababably\",\"abababablz\",\"ababababma\",\"ababababmb\",\"ababababmc\",\"ababababmd\",\"ababababme\",\"ababababmf\",\"ababababmg\",\"ababababmh\",\"ababababmi\",\"ababababmj\",\"ababababmk\",\"ababababml\",\"ababababmm\",\"ababababmn\",\"ababababmo\",\"ababababmp\",\"ababababmq\",\"ababababmr\",\"ababababms\",\"ababababmt\",\"ababababmu\",\"ababababmv\",\"ababababmw\",\"ababababmx\",\"ababababmy\",\"ababababmz\",\"ababababna\",\"ababababnb\",\"ababababnc\",\"ababababnd\",\"ababababne\",\"ababababnf\",\"ababababng\",\"ababababnh\",\"ababababni\",\"ababababnj\",\"ababababnk\",\"ababababnl\",\"ababababnm\",\"ababababnn\",\"ababababno\",\"ababababnp\",\"ababababnq\",\"ababababnr\",\"ababababns\",\"ababababnt\",\"ababababnu\",\"ababababnv\",\"ababababnw\",\"ababababnx\",\"ababababny\",\"ababababnz\",\"ababababoa\",\"ababababob\",\"ababababoc\",\"ababababod\",\"ababababoe\",\"ababababof\",\"ababababog\",\"ababababoh\",\"ababababoi\",\"ababababoj\",\"ababababok\",\"ababababol\",\"ababababom\",\"ababababon\",\"ababababoo\",\"ababababop\",\"ababababoq\",\"ababababor\",\"ababababos\",\"ababababot\",\"ababababou\",\"ababababov\",\"ababababow\",\"ababababox\",\"ababababoy\",\"ababababoz\",\"ababababpa\",\"ababababpb\",\"ababababpc\",\"ababababpd\",\"ababababpe\",\"ababababpf\",\"ababababpg\",\"ababababph\",\"ababababpi\",\"ababababpj\",\"ababababpk\",\"ababababpl\",\"ababababpm\",\"ababababpn\",\"ababababpo\",\"ababababpp\",\"ababababpq\",\"ababababpr\",\"ababababps\",\"ababababpt\",\"ababababpu\",\"ababababpv\",\"ababababpw\",\"ababababpx\",\"ababababpy\",\"ababababpz\",\"ababababqa\",\"ababababqb\",\"ababababqc\",\"ababababqd\",\"ababababqe\",\"ababababqf\",\"ababababqg\",\"ababababqh\",\"ababababqi\",\"ababababqj\",\"ababababqk\",\"ababababql\",\"ababababqm\",\"ababababqn\",\"ababababqo\",\"ababababqp\",\"ababababqq\",\"ababababqr\",\"ababababqs\",\"ababababqt\",\"ababababqu\",\"ababababqv\",\"ababababqw\",\"ababababqx\",\"ababababqy\",\"ababababqz\",\"ababababra\",\"ababababrb\",\"ababababrc\",\"ababababrd\",\"ababababre\",\"ababababrf\",\"ababababrg\",\"ababababrh\",\"ababababri\",\"ababababrj\",\"ababababrk\",\"ababababrl\",\"ababababrm\",\"ababababrn\",\"ababababro\",\"ababababrp\",\"ababababrq\",\"ababababrr\",\"ababababrs\",\"ababababrt\",\"ababababru\",\"ababababrv\",\"ababababrw\",\"ababababrx\",\"ababababry\",\"ababababrz\",\"ababababsa\",\"ababababsb\",\"ababababsc\",\"ababababsd\",\"ababababse\",\"ababababsf\",\"ababababsg\",\"ababababsh\",\"ababababsi\",\"ababababsj\",\"ababababsk\",\"ababababsl\",\"ababababsm\",\"ababababsn\",\"ababababso\",\"ababababsp\",\"ababababsq\",\"ababababsr\",\"ababababss\",\"ababababst\",\"ababababsu\",\"ababababsv\",\"ababababsw\",\"ababababsx\",\"ababababsy\",\"ababababsz\",\"ababababta\",\"ababababtb\",\"ababababtc\",\"ababababtd\",\"ababababte\",\"ababababtf\",\"ababababtg\",\"ababababth\",\"ababababti\",\"ababababtj\",\"ababababtk\",\"ababababtl\",\"ababababtm\",\"ababababtn\",\"ababababto\",\"ababababtp\",\"ababababtq\",\"ababababtr\",\"ababababts\",\"ababababtt\",\"ababababtu\",\"ababababtv\",\"ababababtw\",\"ababababtx\",\"ababababty\",\"ababababtz\",\"ababababua\",\"ababababub\",\"ababababuc\",\"ababababud\",\"ababababue\",\"ababababuf\",\"ababababug\",\"ababababuh\",\"ababababui\",\"ababababuj\",\"ababababuk\",\"ababababul\",\"ababababum\",\"ababababun\",\"ababababuo\",\"ababababup\",\"ababababuq\",\"ababababur\",\"ababababus\",\"ababababut\",\"ababababuu\",\"ababababuv\",\"ababababuw\",\"ababababux\",\"ababababuy\",\"ababababuz\",\"ababababva\",\"ababababvb\",\"ababababvc\",\"ababababvd\",\"ababababve\",\"ababababvf\",\"ababababvg\",\"ababababvh\",\"ababababvi\",\"ababababvj\",\"ababababvk\",\"ababababvl\",\"ababababvm\",\"ababababvn\",\"ababababvo\",\"ababababvp\",\"ababababvq\",\"ababababvr\",\"ababababvs\",\"ababababvt\",\"ababababvu\",\"ababababvv\",\"ababababvw\",\"ababababvx\",\"ababababvy\",\"ababababvz\",\"ababababwa\",\"ababababwb\",\"ababababwc\",\"ababababwd\",\"ababababwe\",\"ababababwf\",\"ababababwg\",\"ababababwh\",\"ababababwi\",\"ababababwj\",\"ababababwk\",\"ababababwl\",\"ababababwm\",\"ababababwn\",\"ababababwo\",\"ababababwp\",\"ababababwq\",\"ababababwr\",\"ababababws\",\"ababababwt\",\"ababababwu\",\"ababababwv\",\"ababababww\",\"ababababwx\",\"ababababwy\",\"ababababwz\",\"ababababxa\",\"ababababxb\",\"ababababxc\",\"ababababxd\",\"ababababxe\",\"ababababxf\",\"ababababxg\",\"ababababxh\",\"ababababxi\",\"ababababxj\",\"ababababxk\",\"ababababxl\",\"ababababxm\",\"ababababxn\",\"ababababxo\",\"ababababxp\",\"ababababxq\",\"ababababxr\",\"ababababxs\",\"ababababxt\",\"ababababxu\",\"ababababxv\",\"ababababxw\",\"ababababxx\",\"ababababxy\",\"ababababxz\",\"ababababya\",\"ababababyb\",\"ababababyc\",\"ababababyd\",\"ababababye\",\"ababababyf\",\"ababababyg\",\"ababababyh\",\"ababababyi\",\"ababababyj\",\"ababababyk\",\"ababababyl\",\"ababababym\",\"ababababyn\",\"ababababyo\",\"ababababyp\",\"ababababyq\",\"ababababyr\",\"ababababys\",\"ababababyt\",\"ababababyu\",\"ababababyv\",\"ababababyw\",\"ababababyx\",\"ababababyy\",\"ababababyz\",\"ababababza\",\"ababababzb\",\"ababababzc\",\"ababababzd\",\"ababababze\",\"ababababzf\",\"ababababzg\",\"ababababzh\",\"ababababzi\",\"ababababzj\",\"ababababzk\",\"ababababzl\",\"ababababzm\",\"ababababzn\",\"ababababzo\",\"ababababzp\",\"ababababzq\",\"ababababzr\",\"ababababzs\",\"ababababzt\",\"ababababzu\",\"ababababzv\",\"ababababzw\",\"ababababzx\",\"ababababzy\",\"ababababzz\"]"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "hashmap fails at this test case:)"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "After solving this problem, I can\\n- Build a crossword puzzle app\\n- Add it to my resume\\n- Hope to get a job"
                    },
                    {
                        "username": "Vikas_Sen",
                        "content": "can not this question be solved without Trie. I have not covered this topic yet. I\\'ve solved word search problem-I easily. how can this question be solved with that methos?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Vikas Sen](/Codeverse_1) Yes!"
                    },
                    {
                        "username": "zooperman",
                        "content": "Hello Mods,\\n\\nthe program seems to run fine with TC-3, when run stand-alone, or with other TC\\'s, but when this is submitted for evaluation, it fails.\\nPlease check this.\\nThe TC-3, runs as expected on my laptop as well, along with other TC\\'s.![image](https://assets.leetcode.com/users/zooperman/image_1589425337.png)\\n"
                    },
                    {
                        "username": "greedycat",
                        "content": "They seem the same but Q212 is ranked hard and Q079 is ranked medium. Am I missing something? The only difference I can spot is in Q212 you search for multiple words in a list. But isn\\'t this change trivial because I can just repeat Q079 for the list?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@greedycat](/greedycat) For P79: length.word is15 and board is 6*6, only a single word. A mere DFS can pass without TLE. But for a list of words, Trie/treenode or dict are far from good. \nI try so hard to improve my DFS/path&graph. Finally, It works! But it's nothing compare to Trie."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Yes but I think they want something else, it looks like a trie or something. for multiple words that starts with same prefix rather than applying 79 on each word, use the prefix and search for both words."
                    },
                    {
                        "username": "user5502m",
                        "content": "I was thinking that too"
                    },
                    {
                        "username": "sarthak13",
                        "content": "[[\"a\"]]\\n[\"a\",\"a\"]\\n\\nOutput is \"a\".\\nAs per the question it should be \"a\",\"a\".\\n\\nAm I missing anything?"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "How is the matching any different than https://leetcode.com/problems/word-break-ii/ ?"
                    },
                    {
                        "username": "gglmg",
                        "content": "Question  says you cannot use same letter more than once but the example given has used 't' in both oath and eat.\\n\\nWhat am I missing here.\\n'"
                    },
                    {
                        "username": "palakons",
                        "content": "also, not the same letter per se, but same (row,col) position"
                    },
                    {
                        "username": "AyushSinha",
                        "content": "I think the same letter shouldn\\'t be used twice in the same word."
                    },
                    {
                        "username": "dskloet",
                        "content": "Why is this problem about speed? The inputs were crafted to fail some non-optimized solutions but not others. I bet none of the posted solutions pass this input:\\n\\n[[\"x\",\"x\",\"a\",\"x\",\"x\"],[\"x\",\"o\",\"o\",\"o\",\"o\"],[\"x\",\"o\",\"o\",\"o\",\"o\"],[\"x\",\"x\",\"o\",\"x\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"x\"],[\"x\",\"x\",\"o\",\"x\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"b\"]]\\n[\"aooooooooooooooooooooooooooooooooooooooooooooooooooooob\"]"
                    },
                    {
                        "username": "charonme",
                        "content": "it says: \"Invalid Testcase\\nexpected \\'board\\' to have 1 <= size <= 12 but got 15\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@dskloet](/dskloet)\nMy pure DFS solution 989ms in Leetcode, solve your problem only: 1.9944 miliseconds\n\ncheck data  # | i&j = [14, 4], word= b b 54\n['aooooooooooooooooooooooooooooooooooooooooooooooooooooob']\n\nBut Trie gets TLE for sure.\n\t"
                    },
                    {
                        "username": "echobeacon",
                        "content": "Problem constraints say all words are 10 characters or less"
                    },
                    {
                        "username": "Fluffy_Memory_6238",
                        "content": "If word exceeds m or n we can simply leave that one? also m,n<=12"
                    }
                ]
            },
            {
                "id": 1573745,
                "content": [
                    {
                        "username": "Heisenburgerrr",
                        "content": "Solving this question made me feel so high lol"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I don\\'t think use of tries is at all intuitive because generally words don\\'t share this big prefixes. I feel it should be mentioned somewhere in the question. \\nboard = [[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"]]\\n\\nwords = [\"ababababaa\",\"ababababab\",\"ababababac\",\"ababababad\",\"ababababae\",\"ababababaf\",\"ababababag\",\"ababababah\",\"ababababai\",\"ababababaj\",\"ababababak\",\"ababababal\",\"ababababam\",\"ababababan\",\"ababababao\",\"ababababap\",\"ababababaq\",\"ababababar\",\"ababababas\",\"ababababat\",\"ababababau\",\"ababababav\",\"ababababaw\",\"ababababax\",\"ababababay\",\"ababababaz\",\"ababababba\",\"ababababbb\",\"ababababbc\",\"ababababbd\",\"ababababbe\",\"ababababbf\",\"ababababbg\",\"ababababbh\",\"ababababbi\",\"ababababbj\",\"ababababbk\",\"ababababbl\",\"ababababbm\",\"ababababbn\",\"ababababbo\",\"ababababbp\",\"ababababbq\",\"ababababbr\",\"ababababbs\",\"ababababbt\",\"ababababbu\",\"ababababbv\",\"ababababbw\",\"ababababbx\",\"ababababby\",\"ababababbz\",\"ababababca\",\"ababababcb\",\"ababababcc\",\"ababababcd\",\"ababababce\",\"ababababcf\",\"ababababcg\",\"ababababch\",\"ababababci\",\"ababababcj\",\"ababababck\",\"ababababcl\",\"ababababcm\",\"ababababcn\",\"ababababco\",\"ababababcp\",\"ababababcq\",\"ababababcr\",\"ababababcs\",\"ababababct\",\"ababababcu\",\"ababababcv\",\"ababababcw\",\"ababababcx\",\"ababababcy\",\"ababababcz\",\"ababababda\",\"ababababdb\",\"ababababdc\",\"ababababdd\",\"ababababde\",\"ababababdf\",\"ababababdg\",\"ababababdh\",\"ababababdi\",\"ababababdj\",\"ababababdk\",\"ababababdl\",\"ababababdm\",\"ababababdn\",\"ababababdo\",\"ababababdp\",\"ababababdq\",\"ababababdr\",\"ababababds\",\"ababababdt\",\"ababababdu\",\"ababababdv\",\"ababababdw\",\"ababababdx\",\"ababababdy\",\"ababababdz\",\"ababababea\",\"ababababeb\",\"ababababec\",\"ababababed\",\"ababababee\",\"ababababef\",\"ababababeg\",\"ababababeh\",\"ababababei\",\"ababababej\",\"ababababek\",\"ababababel\",\"ababababem\",\"ababababen\",\"ababababeo\",\"ababababep\",\"ababababeq\",\"ababababer\",\"ababababes\",\"ababababet\",\"ababababeu\",\"ababababev\",\"ababababew\",\"ababababex\",\"ababababey\",\"ababababez\",\"ababababfa\",\"ababababfb\",\"ababababfc\",\"ababababfd\",\"ababababfe\",\"ababababff\",\"ababababfg\",\"ababababfh\",\"ababababfi\",\"ababababfj\",\"ababababfk\",\"ababababfl\",\"ababababfm\",\"ababababfn\",\"ababababfo\",\"ababababfp\",\"ababababfq\",\"ababababfr\",\"ababababfs\",\"ababababft\",\"ababababfu\",\"ababababfv\",\"ababababfw\",\"ababababfx\",\"ababababfy\",\"ababababfz\",\"ababababga\",\"ababababgb\",\"ababababgc\",\"ababababgd\",\"ababababge\",\"ababababgf\",\"ababababgg\",\"ababababgh\",\"ababababgi\",\"ababababgj\",\"ababababgk\",\"ababababgl\",\"ababababgm\",\"ababababgn\",\"ababababgo\",\"ababababgp\",\"ababababgq\",\"ababababgr\",\"ababababgs\",\"ababababgt\",\"ababababgu\",\"ababababgv\",\"ababababgw\",\"ababababgx\",\"ababababgy\",\"ababababgz\",\"ababababha\",\"ababababhb\",\"ababababhc\",\"ababababhd\",\"ababababhe\",\"ababababhf\",\"ababababhg\",\"ababababhh\",\"ababababhi\",\"ababababhj\",\"ababababhk\",\"ababababhl\",\"ababababhm\",\"ababababhn\",\"ababababho\",\"ababababhp\",\"ababababhq\",\"ababababhr\",\"ababababhs\",\"ababababht\",\"ababababhu\",\"ababababhv\",\"ababababhw\",\"ababababhx\",\"ababababhy\",\"ababababhz\",\"ababababia\",\"ababababib\",\"ababababic\",\"ababababid\",\"ababababie\",\"ababababif\",\"ababababig\",\"ababababih\",\"ababababii\",\"ababababij\",\"ababababik\",\"ababababil\",\"ababababim\",\"ababababin\",\"ababababio\",\"ababababip\",\"ababababiq\",\"ababababir\",\"ababababis\",\"ababababit\",\"ababababiu\",\"ababababiv\",\"ababababiw\",\"ababababix\",\"ababababiy\",\"ababababiz\",\"ababababja\",\"ababababjb\",\"ababababjc\",\"ababababjd\",\"ababababje\",\"ababababjf\",\"ababababjg\",\"ababababjh\",\"ababababji\",\"ababababjj\",\"ababababjk\",\"ababababjl\",\"ababababjm\",\"ababababjn\",\"ababababjo\",\"ababababjp\",\"ababababjq\",\"ababababjr\",\"ababababjs\",\"ababababjt\",\"ababababju\",\"ababababjv\",\"ababababjw\",\"ababababjx\",\"ababababjy\",\"ababababjz\",\"ababababka\",\"ababababkb\",\"ababababkc\",\"ababababkd\",\"ababababke\",\"ababababkf\",\"ababababkg\",\"ababababkh\",\"ababababki\",\"ababababkj\",\"ababababkk\",\"ababababkl\",\"ababababkm\",\"ababababkn\",\"ababababko\",\"ababababkp\",\"ababababkq\",\"ababababkr\",\"ababababks\",\"ababababkt\",\"ababababku\",\"ababababkv\",\"ababababkw\",\"ababababkx\",\"ababababky\",\"ababababkz\",\"ababababla\",\"abababablb\",\"abababablc\",\"ababababld\",\"abababable\",\"abababablf\",\"abababablg\",\"abababablh\",\"ababababli\",\"abababablj\",\"abababablk\",\"ababababll\",\"abababablm\",\"ababababln\",\"abababablo\",\"abababablp\",\"abababablq\",\"abababablr\",\"ababababls\",\"abababablt\",\"abababablu\",\"abababablv\",\"abababablw\",\"abababablx\",\"abababably\",\"abababablz\",\"ababababma\",\"ababababmb\",\"ababababmc\",\"ababababmd\",\"ababababme\",\"ababababmf\",\"ababababmg\",\"ababababmh\",\"ababababmi\",\"ababababmj\",\"ababababmk\",\"ababababml\",\"ababababmm\",\"ababababmn\",\"ababababmo\",\"ababababmp\",\"ababababmq\",\"ababababmr\",\"ababababms\",\"ababababmt\",\"ababababmu\",\"ababababmv\",\"ababababmw\",\"ababababmx\",\"ababababmy\",\"ababababmz\",\"ababababna\",\"ababababnb\",\"ababababnc\",\"ababababnd\",\"ababababne\",\"ababababnf\",\"ababababng\",\"ababababnh\",\"ababababni\",\"ababababnj\",\"ababababnk\",\"ababababnl\",\"ababababnm\",\"ababababnn\",\"ababababno\",\"ababababnp\",\"ababababnq\",\"ababababnr\",\"ababababns\",\"ababababnt\",\"ababababnu\",\"ababababnv\",\"ababababnw\",\"ababababnx\",\"ababababny\",\"ababababnz\",\"ababababoa\",\"ababababob\",\"ababababoc\",\"ababababod\",\"ababababoe\",\"ababababof\",\"ababababog\",\"ababababoh\",\"ababababoi\",\"ababababoj\",\"ababababok\",\"ababababol\",\"ababababom\",\"ababababon\",\"ababababoo\",\"ababababop\",\"ababababoq\",\"ababababor\",\"ababababos\",\"ababababot\",\"ababababou\",\"ababababov\",\"ababababow\",\"ababababox\",\"ababababoy\",\"ababababoz\",\"ababababpa\",\"ababababpb\",\"ababababpc\",\"ababababpd\",\"ababababpe\",\"ababababpf\",\"ababababpg\",\"ababababph\",\"ababababpi\",\"ababababpj\",\"ababababpk\",\"ababababpl\",\"ababababpm\",\"ababababpn\",\"ababababpo\",\"ababababpp\",\"ababababpq\",\"ababababpr\",\"ababababps\",\"ababababpt\",\"ababababpu\",\"ababababpv\",\"ababababpw\",\"ababababpx\",\"ababababpy\",\"ababababpz\",\"ababababqa\",\"ababababqb\",\"ababababqc\",\"ababababqd\",\"ababababqe\",\"ababababqf\",\"ababababqg\",\"ababababqh\",\"ababababqi\",\"ababababqj\",\"ababababqk\",\"ababababql\",\"ababababqm\",\"ababababqn\",\"ababababqo\",\"ababababqp\",\"ababababqq\",\"ababababqr\",\"ababababqs\",\"ababababqt\",\"ababababqu\",\"ababababqv\",\"ababababqw\",\"ababababqx\",\"ababababqy\",\"ababababqz\",\"ababababra\",\"ababababrb\",\"ababababrc\",\"ababababrd\",\"ababababre\",\"ababababrf\",\"ababababrg\",\"ababababrh\",\"ababababri\",\"ababababrj\",\"ababababrk\",\"ababababrl\",\"ababababrm\",\"ababababrn\",\"ababababro\",\"ababababrp\",\"ababababrq\",\"ababababrr\",\"ababababrs\",\"ababababrt\",\"ababababru\",\"ababababrv\",\"ababababrw\",\"ababababrx\",\"ababababry\",\"ababababrz\",\"ababababsa\",\"ababababsb\",\"ababababsc\",\"ababababsd\",\"ababababse\",\"ababababsf\",\"ababababsg\",\"ababababsh\",\"ababababsi\",\"ababababsj\",\"ababababsk\",\"ababababsl\",\"ababababsm\",\"ababababsn\",\"ababababso\",\"ababababsp\",\"ababababsq\",\"ababababsr\",\"ababababss\",\"ababababst\",\"ababababsu\",\"ababababsv\",\"ababababsw\",\"ababababsx\",\"ababababsy\",\"ababababsz\",\"ababababta\",\"ababababtb\",\"ababababtc\",\"ababababtd\",\"ababababte\",\"ababababtf\",\"ababababtg\",\"ababababth\",\"ababababti\",\"ababababtj\",\"ababababtk\",\"ababababtl\",\"ababababtm\",\"ababababtn\",\"ababababto\",\"ababababtp\",\"ababababtq\",\"ababababtr\",\"ababababts\",\"ababababtt\",\"ababababtu\",\"ababababtv\",\"ababababtw\",\"ababababtx\",\"ababababty\",\"ababababtz\",\"ababababua\",\"ababababub\",\"ababababuc\",\"ababababud\",\"ababababue\",\"ababababuf\",\"ababababug\",\"ababababuh\",\"ababababui\",\"ababababuj\",\"ababababuk\",\"ababababul\",\"ababababum\",\"ababababun\",\"ababababuo\",\"ababababup\",\"ababababuq\",\"ababababur\",\"ababababus\",\"ababababut\",\"ababababuu\",\"ababababuv\",\"ababababuw\",\"ababababux\",\"ababababuy\",\"ababababuz\",\"ababababva\",\"ababababvb\",\"ababababvc\",\"ababababvd\",\"ababababve\",\"ababababvf\",\"ababababvg\",\"ababababvh\",\"ababababvi\",\"ababababvj\",\"ababababvk\",\"ababababvl\",\"ababababvm\",\"ababababvn\",\"ababababvo\",\"ababababvp\",\"ababababvq\",\"ababababvr\",\"ababababvs\",\"ababababvt\",\"ababababvu\",\"ababababvv\",\"ababababvw\",\"ababababvx\",\"ababababvy\",\"ababababvz\",\"ababababwa\",\"ababababwb\",\"ababababwc\",\"ababababwd\",\"ababababwe\",\"ababababwf\",\"ababababwg\",\"ababababwh\",\"ababababwi\",\"ababababwj\",\"ababababwk\",\"ababababwl\",\"ababababwm\",\"ababababwn\",\"ababababwo\",\"ababababwp\",\"ababababwq\",\"ababababwr\",\"ababababws\",\"ababababwt\",\"ababababwu\",\"ababababwv\",\"ababababww\",\"ababababwx\",\"ababababwy\",\"ababababwz\",\"ababababxa\",\"ababababxb\",\"ababababxc\",\"ababababxd\",\"ababababxe\",\"ababababxf\",\"ababababxg\",\"ababababxh\",\"ababababxi\",\"ababababxj\",\"ababababxk\",\"ababababxl\",\"ababababxm\",\"ababababxn\",\"ababababxo\",\"ababababxp\",\"ababababxq\",\"ababababxr\",\"ababababxs\",\"ababababxt\",\"ababababxu\",\"ababababxv\",\"ababababxw\",\"ababababxx\",\"ababababxy\",\"ababababxz\",\"ababababya\",\"ababababyb\",\"ababababyc\",\"ababababyd\",\"ababababye\",\"ababababyf\",\"ababababyg\",\"ababababyh\",\"ababababyi\",\"ababababyj\",\"ababababyk\",\"ababababyl\",\"ababababym\",\"ababababyn\",\"ababababyo\",\"ababababyp\",\"ababababyq\",\"ababababyr\",\"ababababys\",\"ababababyt\",\"ababababyu\",\"ababababyv\",\"ababababyw\",\"ababababyx\",\"ababababyy\",\"ababababyz\",\"ababababza\",\"ababababzb\",\"ababababzc\",\"ababababzd\",\"ababababze\",\"ababababzf\",\"ababababzg\",\"ababababzh\",\"ababababzi\",\"ababababzj\",\"ababababzk\",\"ababababzl\",\"ababababzm\",\"ababababzn\",\"ababababzo\",\"ababababzp\",\"ababababzq\",\"ababababzr\",\"ababababzs\",\"ababababzt\",\"ababababzu\",\"ababababzv\",\"ababababzw\",\"ababababzx\",\"ababababzy\",\"ababababzz\"]"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "hashmap fails at this test case:)"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "After solving this problem, I can\\n- Build a crossword puzzle app\\n- Add it to my resume\\n- Hope to get a job"
                    },
                    {
                        "username": "Vikas_Sen",
                        "content": "can not this question be solved without Trie. I have not covered this topic yet. I\\'ve solved word search problem-I easily. how can this question be solved with that methos?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Vikas Sen](/Codeverse_1) Yes!"
                    },
                    {
                        "username": "zooperman",
                        "content": "Hello Mods,\\n\\nthe program seems to run fine with TC-3, when run stand-alone, or with other TC\\'s, but when this is submitted for evaluation, it fails.\\nPlease check this.\\nThe TC-3, runs as expected on my laptop as well, along with other TC\\'s.![image](https://assets.leetcode.com/users/zooperman/image_1589425337.png)\\n"
                    },
                    {
                        "username": "greedycat",
                        "content": "They seem the same but Q212 is ranked hard and Q079 is ranked medium. Am I missing something? The only difference I can spot is in Q212 you search for multiple words in a list. But isn\\'t this change trivial because I can just repeat Q079 for the list?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@greedycat](/greedycat) For P79: length.word is15 and board is 6*6, only a single word. A mere DFS can pass without TLE. But for a list of words, Trie/treenode or dict are far from good. \nI try so hard to improve my DFS/path&graph. Finally, It works! But it's nothing compare to Trie."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Yes but I think they want something else, it looks like a trie or something. for multiple words that starts with same prefix rather than applying 79 on each word, use the prefix and search for both words."
                    },
                    {
                        "username": "user5502m",
                        "content": "I was thinking that too"
                    },
                    {
                        "username": "sarthak13",
                        "content": "[[\"a\"]]\\n[\"a\",\"a\"]\\n\\nOutput is \"a\".\\nAs per the question it should be \"a\",\"a\".\\n\\nAm I missing anything?"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "How is the matching any different than https://leetcode.com/problems/word-break-ii/ ?"
                    },
                    {
                        "username": "gglmg",
                        "content": "Question  says you cannot use same letter more than once but the example given has used 't' in both oath and eat.\\n\\nWhat am I missing here.\\n'"
                    },
                    {
                        "username": "palakons",
                        "content": "also, not the same letter per se, but same (row,col) position"
                    },
                    {
                        "username": "AyushSinha",
                        "content": "I think the same letter shouldn\\'t be used twice in the same word."
                    },
                    {
                        "username": "dskloet",
                        "content": "Why is this problem about speed? The inputs were crafted to fail some non-optimized solutions but not others. I bet none of the posted solutions pass this input:\\n\\n[[\"x\",\"x\",\"a\",\"x\",\"x\"],[\"x\",\"o\",\"o\",\"o\",\"o\"],[\"x\",\"o\",\"o\",\"o\",\"o\"],[\"x\",\"x\",\"o\",\"x\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"x\"],[\"x\",\"x\",\"o\",\"x\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"b\"]]\\n[\"aooooooooooooooooooooooooooooooooooooooooooooooooooooob\"]"
                    },
                    {
                        "username": "charonme",
                        "content": "it says: \"Invalid Testcase\\nexpected \\'board\\' to have 1 <= size <= 12 but got 15\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@dskloet](/dskloet)\nMy pure DFS solution 989ms in Leetcode, solve your problem only: 1.9944 miliseconds\n\ncheck data  # | i&j = [14, 4], word= b b 54\n['aooooooooooooooooooooooooooooooooooooooooooooooooooooob']\n\nBut Trie gets TLE for sure.\n\t"
                    },
                    {
                        "username": "echobeacon",
                        "content": "Problem constraints say all words are 10 characters or less"
                    },
                    {
                        "username": "Fluffy_Memory_6238",
                        "content": "If word exceeds m or n we can simply leave that one? also m,n<=12"
                    }
                ]
            },
            {
                "id": 1572943,
                "content": [
                    {
                        "username": "Heisenburgerrr",
                        "content": "Solving this question made me feel so high lol"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I don\\'t think use of tries is at all intuitive because generally words don\\'t share this big prefixes. I feel it should be mentioned somewhere in the question. \\nboard = [[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"]]\\n\\nwords = [\"ababababaa\",\"ababababab\",\"ababababac\",\"ababababad\",\"ababababae\",\"ababababaf\",\"ababababag\",\"ababababah\",\"ababababai\",\"ababababaj\",\"ababababak\",\"ababababal\",\"ababababam\",\"ababababan\",\"ababababao\",\"ababababap\",\"ababababaq\",\"ababababar\",\"ababababas\",\"ababababat\",\"ababababau\",\"ababababav\",\"ababababaw\",\"ababababax\",\"ababababay\",\"ababababaz\",\"ababababba\",\"ababababbb\",\"ababababbc\",\"ababababbd\",\"ababababbe\",\"ababababbf\",\"ababababbg\",\"ababababbh\",\"ababababbi\",\"ababababbj\",\"ababababbk\",\"ababababbl\",\"ababababbm\",\"ababababbn\",\"ababababbo\",\"ababababbp\",\"ababababbq\",\"ababababbr\",\"ababababbs\",\"ababababbt\",\"ababababbu\",\"ababababbv\",\"ababababbw\",\"ababababbx\",\"ababababby\",\"ababababbz\",\"ababababca\",\"ababababcb\",\"ababababcc\",\"ababababcd\",\"ababababce\",\"ababababcf\",\"ababababcg\",\"ababababch\",\"ababababci\",\"ababababcj\",\"ababababck\",\"ababababcl\",\"ababababcm\",\"ababababcn\",\"ababababco\",\"ababababcp\",\"ababababcq\",\"ababababcr\",\"ababababcs\",\"ababababct\",\"ababababcu\",\"ababababcv\",\"ababababcw\",\"ababababcx\",\"ababababcy\",\"ababababcz\",\"ababababda\",\"ababababdb\",\"ababababdc\",\"ababababdd\",\"ababababde\",\"ababababdf\",\"ababababdg\",\"ababababdh\",\"ababababdi\",\"ababababdj\",\"ababababdk\",\"ababababdl\",\"ababababdm\",\"ababababdn\",\"ababababdo\",\"ababababdp\",\"ababababdq\",\"ababababdr\",\"ababababds\",\"ababababdt\",\"ababababdu\",\"ababababdv\",\"ababababdw\",\"ababababdx\",\"ababababdy\",\"ababababdz\",\"ababababea\",\"ababababeb\",\"ababababec\",\"ababababed\",\"ababababee\",\"ababababef\",\"ababababeg\",\"ababababeh\",\"ababababei\",\"ababababej\",\"ababababek\",\"ababababel\",\"ababababem\",\"ababababen\",\"ababababeo\",\"ababababep\",\"ababababeq\",\"ababababer\",\"ababababes\",\"ababababet\",\"ababababeu\",\"ababababev\",\"ababababew\",\"ababababex\",\"ababababey\",\"ababababez\",\"ababababfa\",\"ababababfb\",\"ababababfc\",\"ababababfd\",\"ababababfe\",\"ababababff\",\"ababababfg\",\"ababababfh\",\"ababababfi\",\"ababababfj\",\"ababababfk\",\"ababababfl\",\"ababababfm\",\"ababababfn\",\"ababababfo\",\"ababababfp\",\"ababababfq\",\"ababababfr\",\"ababababfs\",\"ababababft\",\"ababababfu\",\"ababababfv\",\"ababababfw\",\"ababababfx\",\"ababababfy\",\"ababababfz\",\"ababababga\",\"ababababgb\",\"ababababgc\",\"ababababgd\",\"ababababge\",\"ababababgf\",\"ababababgg\",\"ababababgh\",\"ababababgi\",\"ababababgj\",\"ababababgk\",\"ababababgl\",\"ababababgm\",\"ababababgn\",\"ababababgo\",\"ababababgp\",\"ababababgq\",\"ababababgr\",\"ababababgs\",\"ababababgt\",\"ababababgu\",\"ababababgv\",\"ababababgw\",\"ababababgx\",\"ababababgy\",\"ababababgz\",\"ababababha\",\"ababababhb\",\"ababababhc\",\"ababababhd\",\"ababababhe\",\"ababababhf\",\"ababababhg\",\"ababababhh\",\"ababababhi\",\"ababababhj\",\"ababababhk\",\"ababababhl\",\"ababababhm\",\"ababababhn\",\"ababababho\",\"ababababhp\",\"ababababhq\",\"ababababhr\",\"ababababhs\",\"ababababht\",\"ababababhu\",\"ababababhv\",\"ababababhw\",\"ababababhx\",\"ababababhy\",\"ababababhz\",\"ababababia\",\"ababababib\",\"ababababic\",\"ababababid\",\"ababababie\",\"ababababif\",\"ababababig\",\"ababababih\",\"ababababii\",\"ababababij\",\"ababababik\",\"ababababil\",\"ababababim\",\"ababababin\",\"ababababio\",\"ababababip\",\"ababababiq\",\"ababababir\",\"ababababis\",\"ababababit\",\"ababababiu\",\"ababababiv\",\"ababababiw\",\"ababababix\",\"ababababiy\",\"ababababiz\",\"ababababja\",\"ababababjb\",\"ababababjc\",\"ababababjd\",\"ababababje\",\"ababababjf\",\"ababababjg\",\"ababababjh\",\"ababababji\",\"ababababjj\",\"ababababjk\",\"ababababjl\",\"ababababjm\",\"ababababjn\",\"ababababjo\",\"ababababjp\",\"ababababjq\",\"ababababjr\",\"ababababjs\",\"ababababjt\",\"ababababju\",\"ababababjv\",\"ababababjw\",\"ababababjx\",\"ababababjy\",\"ababababjz\",\"ababababka\",\"ababababkb\",\"ababababkc\",\"ababababkd\",\"ababababke\",\"ababababkf\",\"ababababkg\",\"ababababkh\",\"ababababki\",\"ababababkj\",\"ababababkk\",\"ababababkl\",\"ababababkm\",\"ababababkn\",\"ababababko\",\"ababababkp\",\"ababababkq\",\"ababababkr\",\"ababababks\",\"ababababkt\",\"ababababku\",\"ababababkv\",\"ababababkw\",\"ababababkx\",\"ababababky\",\"ababababkz\",\"ababababla\",\"abababablb\",\"abababablc\",\"ababababld\",\"abababable\",\"abababablf\",\"abababablg\",\"abababablh\",\"ababababli\",\"abababablj\",\"abababablk\",\"ababababll\",\"abababablm\",\"ababababln\",\"abababablo\",\"abababablp\",\"abababablq\",\"abababablr\",\"ababababls\",\"abababablt\",\"abababablu\",\"abababablv\",\"abababablw\",\"abababablx\",\"abababably\",\"abababablz\",\"ababababma\",\"ababababmb\",\"ababababmc\",\"ababababmd\",\"ababababme\",\"ababababmf\",\"ababababmg\",\"ababababmh\",\"ababababmi\",\"ababababmj\",\"ababababmk\",\"ababababml\",\"ababababmm\",\"ababababmn\",\"ababababmo\",\"ababababmp\",\"ababababmq\",\"ababababmr\",\"ababababms\",\"ababababmt\",\"ababababmu\",\"ababababmv\",\"ababababmw\",\"ababababmx\",\"ababababmy\",\"ababababmz\",\"ababababna\",\"ababababnb\",\"ababababnc\",\"ababababnd\",\"ababababne\",\"ababababnf\",\"ababababng\",\"ababababnh\",\"ababababni\",\"ababababnj\",\"ababababnk\",\"ababababnl\",\"ababababnm\",\"ababababnn\",\"ababababno\",\"ababababnp\",\"ababababnq\",\"ababababnr\",\"ababababns\",\"ababababnt\",\"ababababnu\",\"ababababnv\",\"ababababnw\",\"ababababnx\",\"ababababny\",\"ababababnz\",\"ababababoa\",\"ababababob\",\"ababababoc\",\"ababababod\",\"ababababoe\",\"ababababof\",\"ababababog\",\"ababababoh\",\"ababababoi\",\"ababababoj\",\"ababababok\",\"ababababol\",\"ababababom\",\"ababababon\",\"ababababoo\",\"ababababop\",\"ababababoq\",\"ababababor\",\"ababababos\",\"ababababot\",\"ababababou\",\"ababababov\",\"ababababow\",\"ababababox\",\"ababababoy\",\"ababababoz\",\"ababababpa\",\"ababababpb\",\"ababababpc\",\"ababababpd\",\"ababababpe\",\"ababababpf\",\"ababababpg\",\"ababababph\",\"ababababpi\",\"ababababpj\",\"ababababpk\",\"ababababpl\",\"ababababpm\",\"ababababpn\",\"ababababpo\",\"ababababpp\",\"ababababpq\",\"ababababpr\",\"ababababps\",\"ababababpt\",\"ababababpu\",\"ababababpv\",\"ababababpw\",\"ababababpx\",\"ababababpy\",\"ababababpz\",\"ababababqa\",\"ababababqb\",\"ababababqc\",\"ababababqd\",\"ababababqe\",\"ababababqf\",\"ababababqg\",\"ababababqh\",\"ababababqi\",\"ababababqj\",\"ababababqk\",\"ababababql\",\"ababababqm\",\"ababababqn\",\"ababababqo\",\"ababababqp\",\"ababababqq\",\"ababababqr\",\"ababababqs\",\"ababababqt\",\"ababababqu\",\"ababababqv\",\"ababababqw\",\"ababababqx\",\"ababababqy\",\"ababababqz\",\"ababababra\",\"ababababrb\",\"ababababrc\",\"ababababrd\",\"ababababre\",\"ababababrf\",\"ababababrg\",\"ababababrh\",\"ababababri\",\"ababababrj\",\"ababababrk\",\"ababababrl\",\"ababababrm\",\"ababababrn\",\"ababababro\",\"ababababrp\",\"ababababrq\",\"ababababrr\",\"ababababrs\",\"ababababrt\",\"ababababru\",\"ababababrv\",\"ababababrw\",\"ababababrx\",\"ababababry\",\"ababababrz\",\"ababababsa\",\"ababababsb\",\"ababababsc\",\"ababababsd\",\"ababababse\",\"ababababsf\",\"ababababsg\",\"ababababsh\",\"ababababsi\",\"ababababsj\",\"ababababsk\",\"ababababsl\",\"ababababsm\",\"ababababsn\",\"ababababso\",\"ababababsp\",\"ababababsq\",\"ababababsr\",\"ababababss\",\"ababababst\",\"ababababsu\",\"ababababsv\",\"ababababsw\",\"ababababsx\",\"ababababsy\",\"ababababsz\",\"ababababta\",\"ababababtb\",\"ababababtc\",\"ababababtd\",\"ababababte\",\"ababababtf\",\"ababababtg\",\"ababababth\",\"ababababti\",\"ababababtj\",\"ababababtk\",\"ababababtl\",\"ababababtm\",\"ababababtn\",\"ababababto\",\"ababababtp\",\"ababababtq\",\"ababababtr\",\"ababababts\",\"ababababtt\",\"ababababtu\",\"ababababtv\",\"ababababtw\",\"ababababtx\",\"ababababty\",\"ababababtz\",\"ababababua\",\"ababababub\",\"ababababuc\",\"ababababud\",\"ababababue\",\"ababababuf\",\"ababababug\",\"ababababuh\",\"ababababui\",\"ababababuj\",\"ababababuk\",\"ababababul\",\"ababababum\",\"ababababun\",\"ababababuo\",\"ababababup\",\"ababababuq\",\"ababababur\",\"ababababus\",\"ababababut\",\"ababababuu\",\"ababababuv\",\"ababababuw\",\"ababababux\",\"ababababuy\",\"ababababuz\",\"ababababva\",\"ababababvb\",\"ababababvc\",\"ababababvd\",\"ababababve\",\"ababababvf\",\"ababababvg\",\"ababababvh\",\"ababababvi\",\"ababababvj\",\"ababababvk\",\"ababababvl\",\"ababababvm\",\"ababababvn\",\"ababababvo\",\"ababababvp\",\"ababababvq\",\"ababababvr\",\"ababababvs\",\"ababababvt\",\"ababababvu\",\"ababababvv\",\"ababababvw\",\"ababababvx\",\"ababababvy\",\"ababababvz\",\"ababababwa\",\"ababababwb\",\"ababababwc\",\"ababababwd\",\"ababababwe\",\"ababababwf\",\"ababababwg\",\"ababababwh\",\"ababababwi\",\"ababababwj\",\"ababababwk\",\"ababababwl\",\"ababababwm\",\"ababababwn\",\"ababababwo\",\"ababababwp\",\"ababababwq\",\"ababababwr\",\"ababababws\",\"ababababwt\",\"ababababwu\",\"ababababwv\",\"ababababww\",\"ababababwx\",\"ababababwy\",\"ababababwz\",\"ababababxa\",\"ababababxb\",\"ababababxc\",\"ababababxd\",\"ababababxe\",\"ababababxf\",\"ababababxg\",\"ababababxh\",\"ababababxi\",\"ababababxj\",\"ababababxk\",\"ababababxl\",\"ababababxm\",\"ababababxn\",\"ababababxo\",\"ababababxp\",\"ababababxq\",\"ababababxr\",\"ababababxs\",\"ababababxt\",\"ababababxu\",\"ababababxv\",\"ababababxw\",\"ababababxx\",\"ababababxy\",\"ababababxz\",\"ababababya\",\"ababababyb\",\"ababababyc\",\"ababababyd\",\"ababababye\",\"ababababyf\",\"ababababyg\",\"ababababyh\",\"ababababyi\",\"ababababyj\",\"ababababyk\",\"ababababyl\",\"ababababym\",\"ababababyn\",\"ababababyo\",\"ababababyp\",\"ababababyq\",\"ababababyr\",\"ababababys\",\"ababababyt\",\"ababababyu\",\"ababababyv\",\"ababababyw\",\"ababababyx\",\"ababababyy\",\"ababababyz\",\"ababababza\",\"ababababzb\",\"ababababzc\",\"ababababzd\",\"ababababze\",\"ababababzf\",\"ababababzg\",\"ababababzh\",\"ababababzi\",\"ababababzj\",\"ababababzk\",\"ababababzl\",\"ababababzm\",\"ababababzn\",\"ababababzo\",\"ababababzp\",\"ababababzq\",\"ababababzr\",\"ababababzs\",\"ababababzt\",\"ababababzu\",\"ababababzv\",\"ababababzw\",\"ababababzx\",\"ababababzy\",\"ababababzz\"]"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "hashmap fails at this test case:)"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "After solving this problem, I can\\n- Build a crossword puzzle app\\n- Add it to my resume\\n- Hope to get a job"
                    },
                    {
                        "username": "Vikas_Sen",
                        "content": "can not this question be solved without Trie. I have not covered this topic yet. I\\'ve solved word search problem-I easily. how can this question be solved with that methos?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Vikas Sen](/Codeverse_1) Yes!"
                    },
                    {
                        "username": "zooperman",
                        "content": "Hello Mods,\\n\\nthe program seems to run fine with TC-3, when run stand-alone, or with other TC\\'s, but when this is submitted for evaluation, it fails.\\nPlease check this.\\nThe TC-3, runs as expected on my laptop as well, along with other TC\\'s.![image](https://assets.leetcode.com/users/zooperman/image_1589425337.png)\\n"
                    },
                    {
                        "username": "greedycat",
                        "content": "They seem the same but Q212 is ranked hard and Q079 is ranked medium. Am I missing something? The only difference I can spot is in Q212 you search for multiple words in a list. But isn\\'t this change trivial because I can just repeat Q079 for the list?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@greedycat](/greedycat) For P79: length.word is15 and board is 6*6, only a single word. A mere DFS can pass without TLE. But for a list of words, Trie/treenode or dict are far from good. \nI try so hard to improve my DFS/path&graph. Finally, It works! But it's nothing compare to Trie."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Yes but I think they want something else, it looks like a trie or something. for multiple words that starts with same prefix rather than applying 79 on each word, use the prefix and search for both words."
                    },
                    {
                        "username": "user5502m",
                        "content": "I was thinking that too"
                    },
                    {
                        "username": "sarthak13",
                        "content": "[[\"a\"]]\\n[\"a\",\"a\"]\\n\\nOutput is \"a\".\\nAs per the question it should be \"a\",\"a\".\\n\\nAm I missing anything?"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "How is the matching any different than https://leetcode.com/problems/word-break-ii/ ?"
                    },
                    {
                        "username": "gglmg",
                        "content": "Question  says you cannot use same letter more than once but the example given has used 't' in both oath and eat.\\n\\nWhat am I missing here.\\n'"
                    },
                    {
                        "username": "palakons",
                        "content": "also, not the same letter per se, but same (row,col) position"
                    },
                    {
                        "username": "AyushSinha",
                        "content": "I think the same letter shouldn\\'t be used twice in the same word."
                    },
                    {
                        "username": "dskloet",
                        "content": "Why is this problem about speed? The inputs were crafted to fail some non-optimized solutions but not others. I bet none of the posted solutions pass this input:\\n\\n[[\"x\",\"x\",\"a\",\"x\",\"x\"],[\"x\",\"o\",\"o\",\"o\",\"o\"],[\"x\",\"o\",\"o\",\"o\",\"o\"],[\"x\",\"x\",\"o\",\"x\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"x\"],[\"x\",\"x\",\"o\",\"x\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"b\"]]\\n[\"aooooooooooooooooooooooooooooooooooooooooooooooooooooob\"]"
                    },
                    {
                        "username": "charonme",
                        "content": "it says: \"Invalid Testcase\\nexpected \\'board\\' to have 1 <= size <= 12 but got 15\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@dskloet](/dskloet)\nMy pure DFS solution 989ms in Leetcode, solve your problem only: 1.9944 miliseconds\n\ncheck data  # | i&j = [14, 4], word= b b 54\n['aooooooooooooooooooooooooooooooooooooooooooooooooooooob']\n\nBut Trie gets TLE for sure.\n\t"
                    },
                    {
                        "username": "echobeacon",
                        "content": "Problem constraints say all words are 10 characters or less"
                    },
                    {
                        "username": "Fluffy_Memory_6238",
                        "content": "If word exceeds m or n we can simply leave that one? also m,n<=12"
                    }
                ]
            },
            {
                "id": 1572554,
                "content": [
                    {
                        "username": "Heisenburgerrr",
                        "content": "Solving this question made me feel so high lol"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I don\\'t think use of tries is at all intuitive because generally words don\\'t share this big prefixes. I feel it should be mentioned somewhere in the question. \\nboard = [[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"]]\\n\\nwords = [\"ababababaa\",\"ababababab\",\"ababababac\",\"ababababad\",\"ababababae\",\"ababababaf\",\"ababababag\",\"ababababah\",\"ababababai\",\"ababababaj\",\"ababababak\",\"ababababal\",\"ababababam\",\"ababababan\",\"ababababao\",\"ababababap\",\"ababababaq\",\"ababababar\",\"ababababas\",\"ababababat\",\"ababababau\",\"ababababav\",\"ababababaw\",\"ababababax\",\"ababababay\",\"ababababaz\",\"ababababba\",\"ababababbb\",\"ababababbc\",\"ababababbd\",\"ababababbe\",\"ababababbf\",\"ababababbg\",\"ababababbh\",\"ababababbi\",\"ababababbj\",\"ababababbk\",\"ababababbl\",\"ababababbm\",\"ababababbn\",\"ababababbo\",\"ababababbp\",\"ababababbq\",\"ababababbr\",\"ababababbs\",\"ababababbt\",\"ababababbu\",\"ababababbv\",\"ababababbw\",\"ababababbx\",\"ababababby\",\"ababababbz\",\"ababababca\",\"ababababcb\",\"ababababcc\",\"ababababcd\",\"ababababce\",\"ababababcf\",\"ababababcg\",\"ababababch\",\"ababababci\",\"ababababcj\",\"ababababck\",\"ababababcl\",\"ababababcm\",\"ababababcn\",\"ababababco\",\"ababababcp\",\"ababababcq\",\"ababababcr\",\"ababababcs\",\"ababababct\",\"ababababcu\",\"ababababcv\",\"ababababcw\",\"ababababcx\",\"ababababcy\",\"ababababcz\",\"ababababda\",\"ababababdb\",\"ababababdc\",\"ababababdd\",\"ababababde\",\"ababababdf\",\"ababababdg\",\"ababababdh\",\"ababababdi\",\"ababababdj\",\"ababababdk\",\"ababababdl\",\"ababababdm\",\"ababababdn\",\"ababababdo\",\"ababababdp\",\"ababababdq\",\"ababababdr\",\"ababababds\",\"ababababdt\",\"ababababdu\",\"ababababdv\",\"ababababdw\",\"ababababdx\",\"ababababdy\",\"ababababdz\",\"ababababea\",\"ababababeb\",\"ababababec\",\"ababababed\",\"ababababee\",\"ababababef\",\"ababababeg\",\"ababababeh\",\"ababababei\",\"ababababej\",\"ababababek\",\"ababababel\",\"ababababem\",\"ababababen\",\"ababababeo\",\"ababababep\",\"ababababeq\",\"ababababer\",\"ababababes\",\"ababababet\",\"ababababeu\",\"ababababev\",\"ababababew\",\"ababababex\",\"ababababey\",\"ababababez\",\"ababababfa\",\"ababababfb\",\"ababababfc\",\"ababababfd\",\"ababababfe\",\"ababababff\",\"ababababfg\",\"ababababfh\",\"ababababfi\",\"ababababfj\",\"ababababfk\",\"ababababfl\",\"ababababfm\",\"ababababfn\",\"ababababfo\",\"ababababfp\",\"ababababfq\",\"ababababfr\",\"ababababfs\",\"ababababft\",\"ababababfu\",\"ababababfv\",\"ababababfw\",\"ababababfx\",\"ababababfy\",\"ababababfz\",\"ababababga\",\"ababababgb\",\"ababababgc\",\"ababababgd\",\"ababababge\",\"ababababgf\",\"ababababgg\",\"ababababgh\",\"ababababgi\",\"ababababgj\",\"ababababgk\",\"ababababgl\",\"ababababgm\",\"ababababgn\",\"ababababgo\",\"ababababgp\",\"ababababgq\",\"ababababgr\",\"ababababgs\",\"ababababgt\",\"ababababgu\",\"ababababgv\",\"ababababgw\",\"ababababgx\",\"ababababgy\",\"ababababgz\",\"ababababha\",\"ababababhb\",\"ababababhc\",\"ababababhd\",\"ababababhe\",\"ababababhf\",\"ababababhg\",\"ababababhh\",\"ababababhi\",\"ababababhj\",\"ababababhk\",\"ababababhl\",\"ababababhm\",\"ababababhn\",\"ababababho\",\"ababababhp\",\"ababababhq\",\"ababababhr\",\"ababababhs\",\"ababababht\",\"ababababhu\",\"ababababhv\",\"ababababhw\",\"ababababhx\",\"ababababhy\",\"ababababhz\",\"ababababia\",\"ababababib\",\"ababababic\",\"ababababid\",\"ababababie\",\"ababababif\",\"ababababig\",\"ababababih\",\"ababababii\",\"ababababij\",\"ababababik\",\"ababababil\",\"ababababim\",\"ababababin\",\"ababababio\",\"ababababip\",\"ababababiq\",\"ababababir\",\"ababababis\",\"ababababit\",\"ababababiu\",\"ababababiv\",\"ababababiw\",\"ababababix\",\"ababababiy\",\"ababababiz\",\"ababababja\",\"ababababjb\",\"ababababjc\",\"ababababjd\",\"ababababje\",\"ababababjf\",\"ababababjg\",\"ababababjh\",\"ababababji\",\"ababababjj\",\"ababababjk\",\"ababababjl\",\"ababababjm\",\"ababababjn\",\"ababababjo\",\"ababababjp\",\"ababababjq\",\"ababababjr\",\"ababababjs\",\"ababababjt\",\"ababababju\",\"ababababjv\",\"ababababjw\",\"ababababjx\",\"ababababjy\",\"ababababjz\",\"ababababka\",\"ababababkb\",\"ababababkc\",\"ababababkd\",\"ababababke\",\"ababababkf\",\"ababababkg\",\"ababababkh\",\"ababababki\",\"ababababkj\",\"ababababkk\",\"ababababkl\",\"ababababkm\",\"ababababkn\",\"ababababko\",\"ababababkp\",\"ababababkq\",\"ababababkr\",\"ababababks\",\"ababababkt\",\"ababababku\",\"ababababkv\",\"ababababkw\",\"ababababkx\",\"ababababky\",\"ababababkz\",\"ababababla\",\"abababablb\",\"abababablc\",\"ababababld\",\"abababable\",\"abababablf\",\"abababablg\",\"abababablh\",\"ababababli\",\"abababablj\",\"abababablk\",\"ababababll\",\"abababablm\",\"ababababln\",\"abababablo\",\"abababablp\",\"abababablq\",\"abababablr\",\"ababababls\",\"abababablt\",\"abababablu\",\"abababablv\",\"abababablw\",\"abababablx\",\"abababably\",\"abababablz\",\"ababababma\",\"ababababmb\",\"ababababmc\",\"ababababmd\",\"ababababme\",\"ababababmf\",\"ababababmg\",\"ababababmh\",\"ababababmi\",\"ababababmj\",\"ababababmk\",\"ababababml\",\"ababababmm\",\"ababababmn\",\"ababababmo\",\"ababababmp\",\"ababababmq\",\"ababababmr\",\"ababababms\",\"ababababmt\",\"ababababmu\",\"ababababmv\",\"ababababmw\",\"ababababmx\",\"ababababmy\",\"ababababmz\",\"ababababna\",\"ababababnb\",\"ababababnc\",\"ababababnd\",\"ababababne\",\"ababababnf\",\"ababababng\",\"ababababnh\",\"ababababni\",\"ababababnj\",\"ababababnk\",\"ababababnl\",\"ababababnm\",\"ababababnn\",\"ababababno\",\"ababababnp\",\"ababababnq\",\"ababababnr\",\"ababababns\",\"ababababnt\",\"ababababnu\",\"ababababnv\",\"ababababnw\",\"ababababnx\",\"ababababny\",\"ababababnz\",\"ababababoa\",\"ababababob\",\"ababababoc\",\"ababababod\",\"ababababoe\",\"ababababof\",\"ababababog\",\"ababababoh\",\"ababababoi\",\"ababababoj\",\"ababababok\",\"ababababol\",\"ababababom\",\"ababababon\",\"ababababoo\",\"ababababop\",\"ababababoq\",\"ababababor\",\"ababababos\",\"ababababot\",\"ababababou\",\"ababababov\",\"ababababow\",\"ababababox\",\"ababababoy\",\"ababababoz\",\"ababababpa\",\"ababababpb\",\"ababababpc\",\"ababababpd\",\"ababababpe\",\"ababababpf\",\"ababababpg\",\"ababababph\",\"ababababpi\",\"ababababpj\",\"ababababpk\",\"ababababpl\",\"ababababpm\",\"ababababpn\",\"ababababpo\",\"ababababpp\",\"ababababpq\",\"ababababpr\",\"ababababps\",\"ababababpt\",\"ababababpu\",\"ababababpv\",\"ababababpw\",\"ababababpx\",\"ababababpy\",\"ababababpz\",\"ababababqa\",\"ababababqb\",\"ababababqc\",\"ababababqd\",\"ababababqe\",\"ababababqf\",\"ababababqg\",\"ababababqh\",\"ababababqi\",\"ababababqj\",\"ababababqk\",\"ababababql\",\"ababababqm\",\"ababababqn\",\"ababababqo\",\"ababababqp\",\"ababababqq\",\"ababababqr\",\"ababababqs\",\"ababababqt\",\"ababababqu\",\"ababababqv\",\"ababababqw\",\"ababababqx\",\"ababababqy\",\"ababababqz\",\"ababababra\",\"ababababrb\",\"ababababrc\",\"ababababrd\",\"ababababre\",\"ababababrf\",\"ababababrg\",\"ababababrh\",\"ababababri\",\"ababababrj\",\"ababababrk\",\"ababababrl\",\"ababababrm\",\"ababababrn\",\"ababababro\",\"ababababrp\",\"ababababrq\",\"ababababrr\",\"ababababrs\",\"ababababrt\",\"ababababru\",\"ababababrv\",\"ababababrw\",\"ababababrx\",\"ababababry\",\"ababababrz\",\"ababababsa\",\"ababababsb\",\"ababababsc\",\"ababababsd\",\"ababababse\",\"ababababsf\",\"ababababsg\",\"ababababsh\",\"ababababsi\",\"ababababsj\",\"ababababsk\",\"ababababsl\",\"ababababsm\",\"ababababsn\",\"ababababso\",\"ababababsp\",\"ababababsq\",\"ababababsr\",\"ababababss\",\"ababababst\",\"ababababsu\",\"ababababsv\",\"ababababsw\",\"ababababsx\",\"ababababsy\",\"ababababsz\",\"ababababta\",\"ababababtb\",\"ababababtc\",\"ababababtd\",\"ababababte\",\"ababababtf\",\"ababababtg\",\"ababababth\",\"ababababti\",\"ababababtj\",\"ababababtk\",\"ababababtl\",\"ababababtm\",\"ababababtn\",\"ababababto\",\"ababababtp\",\"ababababtq\",\"ababababtr\",\"ababababts\",\"ababababtt\",\"ababababtu\",\"ababababtv\",\"ababababtw\",\"ababababtx\",\"ababababty\",\"ababababtz\",\"ababababua\",\"ababababub\",\"ababababuc\",\"ababababud\",\"ababababue\",\"ababababuf\",\"ababababug\",\"ababababuh\",\"ababababui\",\"ababababuj\",\"ababababuk\",\"ababababul\",\"ababababum\",\"ababababun\",\"ababababuo\",\"ababababup\",\"ababababuq\",\"ababababur\",\"ababababus\",\"ababababut\",\"ababababuu\",\"ababababuv\",\"ababababuw\",\"ababababux\",\"ababababuy\",\"ababababuz\",\"ababababva\",\"ababababvb\",\"ababababvc\",\"ababababvd\",\"ababababve\",\"ababababvf\",\"ababababvg\",\"ababababvh\",\"ababababvi\",\"ababababvj\",\"ababababvk\",\"ababababvl\",\"ababababvm\",\"ababababvn\",\"ababababvo\",\"ababababvp\",\"ababababvq\",\"ababababvr\",\"ababababvs\",\"ababababvt\",\"ababababvu\",\"ababababvv\",\"ababababvw\",\"ababababvx\",\"ababababvy\",\"ababababvz\",\"ababababwa\",\"ababababwb\",\"ababababwc\",\"ababababwd\",\"ababababwe\",\"ababababwf\",\"ababababwg\",\"ababababwh\",\"ababababwi\",\"ababababwj\",\"ababababwk\",\"ababababwl\",\"ababababwm\",\"ababababwn\",\"ababababwo\",\"ababababwp\",\"ababababwq\",\"ababababwr\",\"ababababws\",\"ababababwt\",\"ababababwu\",\"ababababwv\",\"ababababww\",\"ababababwx\",\"ababababwy\",\"ababababwz\",\"ababababxa\",\"ababababxb\",\"ababababxc\",\"ababababxd\",\"ababababxe\",\"ababababxf\",\"ababababxg\",\"ababababxh\",\"ababababxi\",\"ababababxj\",\"ababababxk\",\"ababababxl\",\"ababababxm\",\"ababababxn\",\"ababababxo\",\"ababababxp\",\"ababababxq\",\"ababababxr\",\"ababababxs\",\"ababababxt\",\"ababababxu\",\"ababababxv\",\"ababababxw\",\"ababababxx\",\"ababababxy\",\"ababababxz\",\"ababababya\",\"ababababyb\",\"ababababyc\",\"ababababyd\",\"ababababye\",\"ababababyf\",\"ababababyg\",\"ababababyh\",\"ababababyi\",\"ababababyj\",\"ababababyk\",\"ababababyl\",\"ababababym\",\"ababababyn\",\"ababababyo\",\"ababababyp\",\"ababababyq\",\"ababababyr\",\"ababababys\",\"ababababyt\",\"ababababyu\",\"ababababyv\",\"ababababyw\",\"ababababyx\",\"ababababyy\",\"ababababyz\",\"ababababza\",\"ababababzb\",\"ababababzc\",\"ababababzd\",\"ababababze\",\"ababababzf\",\"ababababzg\",\"ababababzh\",\"ababababzi\",\"ababababzj\",\"ababababzk\",\"ababababzl\",\"ababababzm\",\"ababababzn\",\"ababababzo\",\"ababababzp\",\"ababababzq\",\"ababababzr\",\"ababababzs\",\"ababababzt\",\"ababababzu\",\"ababababzv\",\"ababababzw\",\"ababababzx\",\"ababababzy\",\"ababababzz\"]"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "hashmap fails at this test case:)"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "After solving this problem, I can\\n- Build a crossword puzzle app\\n- Add it to my resume\\n- Hope to get a job"
                    },
                    {
                        "username": "Vikas_Sen",
                        "content": "can not this question be solved without Trie. I have not covered this topic yet. I\\'ve solved word search problem-I easily. how can this question be solved with that methos?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Vikas Sen](/Codeverse_1) Yes!"
                    },
                    {
                        "username": "zooperman",
                        "content": "Hello Mods,\\n\\nthe program seems to run fine with TC-3, when run stand-alone, or with other TC\\'s, but when this is submitted for evaluation, it fails.\\nPlease check this.\\nThe TC-3, runs as expected on my laptop as well, along with other TC\\'s.![image](https://assets.leetcode.com/users/zooperman/image_1589425337.png)\\n"
                    },
                    {
                        "username": "greedycat",
                        "content": "They seem the same but Q212 is ranked hard and Q079 is ranked medium. Am I missing something? The only difference I can spot is in Q212 you search for multiple words in a list. But isn\\'t this change trivial because I can just repeat Q079 for the list?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@greedycat](/greedycat) For P79: length.word is15 and board is 6*6, only a single word. A mere DFS can pass without TLE. But for a list of words, Trie/treenode or dict are far from good. \nI try so hard to improve my DFS/path&graph. Finally, It works! But it's nothing compare to Trie."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Yes but I think they want something else, it looks like a trie or something. for multiple words that starts with same prefix rather than applying 79 on each word, use the prefix and search for both words."
                    },
                    {
                        "username": "user5502m",
                        "content": "I was thinking that too"
                    },
                    {
                        "username": "sarthak13",
                        "content": "[[\"a\"]]\\n[\"a\",\"a\"]\\n\\nOutput is \"a\".\\nAs per the question it should be \"a\",\"a\".\\n\\nAm I missing anything?"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "How is the matching any different than https://leetcode.com/problems/word-break-ii/ ?"
                    },
                    {
                        "username": "gglmg",
                        "content": "Question  says you cannot use same letter more than once but the example given has used 't' in both oath and eat.\\n\\nWhat am I missing here.\\n'"
                    },
                    {
                        "username": "palakons",
                        "content": "also, not the same letter per se, but same (row,col) position"
                    },
                    {
                        "username": "AyushSinha",
                        "content": "I think the same letter shouldn\\'t be used twice in the same word."
                    },
                    {
                        "username": "dskloet",
                        "content": "Why is this problem about speed? The inputs were crafted to fail some non-optimized solutions but not others. I bet none of the posted solutions pass this input:\\n\\n[[\"x\",\"x\",\"a\",\"x\",\"x\"],[\"x\",\"o\",\"o\",\"o\",\"o\"],[\"x\",\"o\",\"o\",\"o\",\"o\"],[\"x\",\"x\",\"o\",\"x\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"x\"],[\"x\",\"x\",\"o\",\"x\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"b\"]]\\n[\"aooooooooooooooooooooooooooooooooooooooooooooooooooooob\"]"
                    },
                    {
                        "username": "charonme",
                        "content": "it says: \"Invalid Testcase\\nexpected \\'board\\' to have 1 <= size <= 12 but got 15\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@dskloet](/dskloet)\nMy pure DFS solution 989ms in Leetcode, solve your problem only: 1.9944 miliseconds\n\ncheck data  # | i&j = [14, 4], word= b b 54\n['aooooooooooooooooooooooooooooooooooooooooooooooooooooob']\n\nBut Trie gets TLE for sure.\n\t"
                    },
                    {
                        "username": "echobeacon",
                        "content": "Problem constraints say all words are 10 characters or less"
                    },
                    {
                        "username": "Fluffy_Memory_6238",
                        "content": "If word exceeds m or n we can simply leave that one? also m,n<=12"
                    }
                ]
            },
            {
                "id": 1572547,
                "content": [
                    {
                        "username": "Heisenburgerrr",
                        "content": "Solving this question made me feel so high lol"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I don\\'t think use of tries is at all intuitive because generally words don\\'t share this big prefixes. I feel it should be mentioned somewhere in the question. \\nboard = [[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"]]\\n\\nwords = [\"ababababaa\",\"ababababab\",\"ababababac\",\"ababababad\",\"ababababae\",\"ababababaf\",\"ababababag\",\"ababababah\",\"ababababai\",\"ababababaj\",\"ababababak\",\"ababababal\",\"ababababam\",\"ababababan\",\"ababababao\",\"ababababap\",\"ababababaq\",\"ababababar\",\"ababababas\",\"ababababat\",\"ababababau\",\"ababababav\",\"ababababaw\",\"ababababax\",\"ababababay\",\"ababababaz\",\"ababababba\",\"ababababbb\",\"ababababbc\",\"ababababbd\",\"ababababbe\",\"ababababbf\",\"ababababbg\",\"ababababbh\",\"ababababbi\",\"ababababbj\",\"ababababbk\",\"ababababbl\",\"ababababbm\",\"ababababbn\",\"ababababbo\",\"ababababbp\",\"ababababbq\",\"ababababbr\",\"ababababbs\",\"ababababbt\",\"ababababbu\",\"ababababbv\",\"ababababbw\",\"ababababbx\",\"ababababby\",\"ababababbz\",\"ababababca\",\"ababababcb\",\"ababababcc\",\"ababababcd\",\"ababababce\",\"ababababcf\",\"ababababcg\",\"ababababch\",\"ababababci\",\"ababababcj\",\"ababababck\",\"ababababcl\",\"ababababcm\",\"ababababcn\",\"ababababco\",\"ababababcp\",\"ababababcq\",\"ababababcr\",\"ababababcs\",\"ababababct\",\"ababababcu\",\"ababababcv\",\"ababababcw\",\"ababababcx\",\"ababababcy\",\"ababababcz\",\"ababababda\",\"ababababdb\",\"ababababdc\",\"ababababdd\",\"ababababde\",\"ababababdf\",\"ababababdg\",\"ababababdh\",\"ababababdi\",\"ababababdj\",\"ababababdk\",\"ababababdl\",\"ababababdm\",\"ababababdn\",\"ababababdo\",\"ababababdp\",\"ababababdq\",\"ababababdr\",\"ababababds\",\"ababababdt\",\"ababababdu\",\"ababababdv\",\"ababababdw\",\"ababababdx\",\"ababababdy\",\"ababababdz\",\"ababababea\",\"ababababeb\",\"ababababec\",\"ababababed\",\"ababababee\",\"ababababef\",\"ababababeg\",\"ababababeh\",\"ababababei\",\"ababababej\",\"ababababek\",\"ababababel\",\"ababababem\",\"ababababen\",\"ababababeo\",\"ababababep\",\"ababababeq\",\"ababababer\",\"ababababes\",\"ababababet\",\"ababababeu\",\"ababababev\",\"ababababew\",\"ababababex\",\"ababababey\",\"ababababez\",\"ababababfa\",\"ababababfb\",\"ababababfc\",\"ababababfd\",\"ababababfe\",\"ababababff\",\"ababababfg\",\"ababababfh\",\"ababababfi\",\"ababababfj\",\"ababababfk\",\"ababababfl\",\"ababababfm\",\"ababababfn\",\"ababababfo\",\"ababababfp\",\"ababababfq\",\"ababababfr\",\"ababababfs\",\"ababababft\",\"ababababfu\",\"ababababfv\",\"ababababfw\",\"ababababfx\",\"ababababfy\",\"ababababfz\",\"ababababga\",\"ababababgb\",\"ababababgc\",\"ababababgd\",\"ababababge\",\"ababababgf\",\"ababababgg\",\"ababababgh\",\"ababababgi\",\"ababababgj\",\"ababababgk\",\"ababababgl\",\"ababababgm\",\"ababababgn\",\"ababababgo\",\"ababababgp\",\"ababababgq\",\"ababababgr\",\"ababababgs\",\"ababababgt\",\"ababababgu\",\"ababababgv\",\"ababababgw\",\"ababababgx\",\"ababababgy\",\"ababababgz\",\"ababababha\",\"ababababhb\",\"ababababhc\",\"ababababhd\",\"ababababhe\",\"ababababhf\",\"ababababhg\",\"ababababhh\",\"ababababhi\",\"ababababhj\",\"ababababhk\",\"ababababhl\",\"ababababhm\",\"ababababhn\",\"ababababho\",\"ababababhp\",\"ababababhq\",\"ababababhr\",\"ababababhs\",\"ababababht\",\"ababababhu\",\"ababababhv\",\"ababababhw\",\"ababababhx\",\"ababababhy\",\"ababababhz\",\"ababababia\",\"ababababib\",\"ababababic\",\"ababababid\",\"ababababie\",\"ababababif\",\"ababababig\",\"ababababih\",\"ababababii\",\"ababababij\",\"ababababik\",\"ababababil\",\"ababababim\",\"ababababin\",\"ababababio\",\"ababababip\",\"ababababiq\",\"ababababir\",\"ababababis\",\"ababababit\",\"ababababiu\",\"ababababiv\",\"ababababiw\",\"ababababix\",\"ababababiy\",\"ababababiz\",\"ababababja\",\"ababababjb\",\"ababababjc\",\"ababababjd\",\"ababababje\",\"ababababjf\",\"ababababjg\",\"ababababjh\",\"ababababji\",\"ababababjj\",\"ababababjk\",\"ababababjl\",\"ababababjm\",\"ababababjn\",\"ababababjo\",\"ababababjp\",\"ababababjq\",\"ababababjr\",\"ababababjs\",\"ababababjt\",\"ababababju\",\"ababababjv\",\"ababababjw\",\"ababababjx\",\"ababababjy\",\"ababababjz\",\"ababababka\",\"ababababkb\",\"ababababkc\",\"ababababkd\",\"ababababke\",\"ababababkf\",\"ababababkg\",\"ababababkh\",\"ababababki\",\"ababababkj\",\"ababababkk\",\"ababababkl\",\"ababababkm\",\"ababababkn\",\"ababababko\",\"ababababkp\",\"ababababkq\",\"ababababkr\",\"ababababks\",\"ababababkt\",\"ababababku\",\"ababababkv\",\"ababababkw\",\"ababababkx\",\"ababababky\",\"ababababkz\",\"ababababla\",\"abababablb\",\"abababablc\",\"ababababld\",\"abababable\",\"abababablf\",\"abababablg\",\"abababablh\",\"ababababli\",\"abababablj\",\"abababablk\",\"ababababll\",\"abababablm\",\"ababababln\",\"abababablo\",\"abababablp\",\"abababablq\",\"abababablr\",\"ababababls\",\"abababablt\",\"abababablu\",\"abababablv\",\"abababablw\",\"abababablx\",\"abababably\",\"abababablz\",\"ababababma\",\"ababababmb\",\"ababababmc\",\"ababababmd\",\"ababababme\",\"ababababmf\",\"ababababmg\",\"ababababmh\",\"ababababmi\",\"ababababmj\",\"ababababmk\",\"ababababml\",\"ababababmm\",\"ababababmn\",\"ababababmo\",\"ababababmp\",\"ababababmq\",\"ababababmr\",\"ababababms\",\"ababababmt\",\"ababababmu\",\"ababababmv\",\"ababababmw\",\"ababababmx\",\"ababababmy\",\"ababababmz\",\"ababababna\",\"ababababnb\",\"ababababnc\",\"ababababnd\",\"ababababne\",\"ababababnf\",\"ababababng\",\"ababababnh\",\"ababababni\",\"ababababnj\",\"ababababnk\",\"ababababnl\",\"ababababnm\",\"ababababnn\",\"ababababno\",\"ababababnp\",\"ababababnq\",\"ababababnr\",\"ababababns\",\"ababababnt\",\"ababababnu\",\"ababababnv\",\"ababababnw\",\"ababababnx\",\"ababababny\",\"ababababnz\",\"ababababoa\",\"ababababob\",\"ababababoc\",\"ababababod\",\"ababababoe\",\"ababababof\",\"ababababog\",\"ababababoh\",\"ababababoi\",\"ababababoj\",\"ababababok\",\"ababababol\",\"ababababom\",\"ababababon\",\"ababababoo\",\"ababababop\",\"ababababoq\",\"ababababor\",\"ababababos\",\"ababababot\",\"ababababou\",\"ababababov\",\"ababababow\",\"ababababox\",\"ababababoy\",\"ababababoz\",\"ababababpa\",\"ababababpb\",\"ababababpc\",\"ababababpd\",\"ababababpe\",\"ababababpf\",\"ababababpg\",\"ababababph\",\"ababababpi\",\"ababababpj\",\"ababababpk\",\"ababababpl\",\"ababababpm\",\"ababababpn\",\"ababababpo\",\"ababababpp\",\"ababababpq\",\"ababababpr\",\"ababababps\",\"ababababpt\",\"ababababpu\",\"ababababpv\",\"ababababpw\",\"ababababpx\",\"ababababpy\",\"ababababpz\",\"ababababqa\",\"ababababqb\",\"ababababqc\",\"ababababqd\",\"ababababqe\",\"ababababqf\",\"ababababqg\",\"ababababqh\",\"ababababqi\",\"ababababqj\",\"ababababqk\",\"ababababql\",\"ababababqm\",\"ababababqn\",\"ababababqo\",\"ababababqp\",\"ababababqq\",\"ababababqr\",\"ababababqs\",\"ababababqt\",\"ababababqu\",\"ababababqv\",\"ababababqw\",\"ababababqx\",\"ababababqy\",\"ababababqz\",\"ababababra\",\"ababababrb\",\"ababababrc\",\"ababababrd\",\"ababababre\",\"ababababrf\",\"ababababrg\",\"ababababrh\",\"ababababri\",\"ababababrj\",\"ababababrk\",\"ababababrl\",\"ababababrm\",\"ababababrn\",\"ababababro\",\"ababababrp\",\"ababababrq\",\"ababababrr\",\"ababababrs\",\"ababababrt\",\"ababababru\",\"ababababrv\",\"ababababrw\",\"ababababrx\",\"ababababry\",\"ababababrz\",\"ababababsa\",\"ababababsb\",\"ababababsc\",\"ababababsd\",\"ababababse\",\"ababababsf\",\"ababababsg\",\"ababababsh\",\"ababababsi\",\"ababababsj\",\"ababababsk\",\"ababababsl\",\"ababababsm\",\"ababababsn\",\"ababababso\",\"ababababsp\",\"ababababsq\",\"ababababsr\",\"ababababss\",\"ababababst\",\"ababababsu\",\"ababababsv\",\"ababababsw\",\"ababababsx\",\"ababababsy\",\"ababababsz\",\"ababababta\",\"ababababtb\",\"ababababtc\",\"ababababtd\",\"ababababte\",\"ababababtf\",\"ababababtg\",\"ababababth\",\"ababababti\",\"ababababtj\",\"ababababtk\",\"ababababtl\",\"ababababtm\",\"ababababtn\",\"ababababto\",\"ababababtp\",\"ababababtq\",\"ababababtr\",\"ababababts\",\"ababababtt\",\"ababababtu\",\"ababababtv\",\"ababababtw\",\"ababababtx\",\"ababababty\",\"ababababtz\",\"ababababua\",\"ababababub\",\"ababababuc\",\"ababababud\",\"ababababue\",\"ababababuf\",\"ababababug\",\"ababababuh\",\"ababababui\",\"ababababuj\",\"ababababuk\",\"ababababul\",\"ababababum\",\"ababababun\",\"ababababuo\",\"ababababup\",\"ababababuq\",\"ababababur\",\"ababababus\",\"ababababut\",\"ababababuu\",\"ababababuv\",\"ababababuw\",\"ababababux\",\"ababababuy\",\"ababababuz\",\"ababababva\",\"ababababvb\",\"ababababvc\",\"ababababvd\",\"ababababve\",\"ababababvf\",\"ababababvg\",\"ababababvh\",\"ababababvi\",\"ababababvj\",\"ababababvk\",\"ababababvl\",\"ababababvm\",\"ababababvn\",\"ababababvo\",\"ababababvp\",\"ababababvq\",\"ababababvr\",\"ababababvs\",\"ababababvt\",\"ababababvu\",\"ababababvv\",\"ababababvw\",\"ababababvx\",\"ababababvy\",\"ababababvz\",\"ababababwa\",\"ababababwb\",\"ababababwc\",\"ababababwd\",\"ababababwe\",\"ababababwf\",\"ababababwg\",\"ababababwh\",\"ababababwi\",\"ababababwj\",\"ababababwk\",\"ababababwl\",\"ababababwm\",\"ababababwn\",\"ababababwo\",\"ababababwp\",\"ababababwq\",\"ababababwr\",\"ababababws\",\"ababababwt\",\"ababababwu\",\"ababababwv\",\"ababababww\",\"ababababwx\",\"ababababwy\",\"ababababwz\",\"ababababxa\",\"ababababxb\",\"ababababxc\",\"ababababxd\",\"ababababxe\",\"ababababxf\",\"ababababxg\",\"ababababxh\",\"ababababxi\",\"ababababxj\",\"ababababxk\",\"ababababxl\",\"ababababxm\",\"ababababxn\",\"ababababxo\",\"ababababxp\",\"ababababxq\",\"ababababxr\",\"ababababxs\",\"ababababxt\",\"ababababxu\",\"ababababxv\",\"ababababxw\",\"ababababxx\",\"ababababxy\",\"ababababxz\",\"ababababya\",\"ababababyb\",\"ababababyc\",\"ababababyd\",\"ababababye\",\"ababababyf\",\"ababababyg\",\"ababababyh\",\"ababababyi\",\"ababababyj\",\"ababababyk\",\"ababababyl\",\"ababababym\",\"ababababyn\",\"ababababyo\",\"ababababyp\",\"ababababyq\",\"ababababyr\",\"ababababys\",\"ababababyt\",\"ababababyu\",\"ababababyv\",\"ababababyw\",\"ababababyx\",\"ababababyy\",\"ababababyz\",\"ababababza\",\"ababababzb\",\"ababababzc\",\"ababababzd\",\"ababababze\",\"ababababzf\",\"ababababzg\",\"ababababzh\",\"ababababzi\",\"ababababzj\",\"ababababzk\",\"ababababzl\",\"ababababzm\",\"ababababzn\",\"ababababzo\",\"ababababzp\",\"ababababzq\",\"ababababzr\",\"ababababzs\",\"ababababzt\",\"ababababzu\",\"ababababzv\",\"ababababzw\",\"ababababzx\",\"ababababzy\",\"ababababzz\"]"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "hashmap fails at this test case:)"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "After solving this problem, I can\\n- Build a crossword puzzle app\\n- Add it to my resume\\n- Hope to get a job"
                    },
                    {
                        "username": "Vikas_Sen",
                        "content": "can not this question be solved without Trie. I have not covered this topic yet. I\\'ve solved word search problem-I easily. how can this question be solved with that methos?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Vikas Sen](/Codeverse_1) Yes!"
                    },
                    {
                        "username": "zooperman",
                        "content": "Hello Mods,\\n\\nthe program seems to run fine with TC-3, when run stand-alone, or with other TC\\'s, but when this is submitted for evaluation, it fails.\\nPlease check this.\\nThe TC-3, runs as expected on my laptop as well, along with other TC\\'s.![image](https://assets.leetcode.com/users/zooperman/image_1589425337.png)\\n"
                    },
                    {
                        "username": "greedycat",
                        "content": "They seem the same but Q212 is ranked hard and Q079 is ranked medium. Am I missing something? The only difference I can spot is in Q212 you search for multiple words in a list. But isn\\'t this change trivial because I can just repeat Q079 for the list?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@greedycat](/greedycat) For P79: length.word is15 and board is 6*6, only a single word. A mere DFS can pass without TLE. But for a list of words, Trie/treenode or dict are far from good. \nI try so hard to improve my DFS/path&graph. Finally, It works! But it's nothing compare to Trie."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Yes but I think they want something else, it looks like a trie or something. for multiple words that starts with same prefix rather than applying 79 on each word, use the prefix and search for both words."
                    },
                    {
                        "username": "user5502m",
                        "content": "I was thinking that too"
                    },
                    {
                        "username": "sarthak13",
                        "content": "[[\"a\"]]\\n[\"a\",\"a\"]\\n\\nOutput is \"a\".\\nAs per the question it should be \"a\",\"a\".\\n\\nAm I missing anything?"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "How is the matching any different than https://leetcode.com/problems/word-break-ii/ ?"
                    },
                    {
                        "username": "gglmg",
                        "content": "Question  says you cannot use same letter more than once but the example given has used 't' in both oath and eat.\\n\\nWhat am I missing here.\\n'"
                    },
                    {
                        "username": "palakons",
                        "content": "also, not the same letter per se, but same (row,col) position"
                    },
                    {
                        "username": "AyushSinha",
                        "content": "I think the same letter shouldn\\'t be used twice in the same word."
                    },
                    {
                        "username": "dskloet",
                        "content": "Why is this problem about speed? The inputs were crafted to fail some non-optimized solutions but not others. I bet none of the posted solutions pass this input:\\n\\n[[\"x\",\"x\",\"a\",\"x\",\"x\"],[\"x\",\"o\",\"o\",\"o\",\"o\"],[\"x\",\"o\",\"o\",\"o\",\"o\"],[\"x\",\"x\",\"o\",\"x\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"x\"],[\"x\",\"x\",\"o\",\"x\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"b\"]]\\n[\"aooooooooooooooooooooooooooooooooooooooooooooooooooooob\"]"
                    },
                    {
                        "username": "charonme",
                        "content": "it says: \"Invalid Testcase\\nexpected \\'board\\' to have 1 <= size <= 12 but got 15\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@dskloet](/dskloet)\nMy pure DFS solution 989ms in Leetcode, solve your problem only: 1.9944 miliseconds\n\ncheck data  # | i&j = [14, 4], word= b b 54\n['aooooooooooooooooooooooooooooooooooooooooooooooooooooob']\n\nBut Trie gets TLE for sure.\n\t"
                    },
                    {
                        "username": "echobeacon",
                        "content": "Problem constraints say all words are 10 characters or less"
                    },
                    {
                        "username": "Fluffy_Memory_6238",
                        "content": "If word exceeds m or n we can simply leave that one? also m,n<=12"
                    }
                ]
            },
            {
                "id": 1571436,
                "content": [
                    {
                        "username": "Heisenburgerrr",
                        "content": "Solving this question made me feel so high lol"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I don\\'t think use of tries is at all intuitive because generally words don\\'t share this big prefixes. I feel it should be mentioned somewhere in the question. \\nboard = [[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"]]\\n\\nwords = [\"ababababaa\",\"ababababab\",\"ababababac\",\"ababababad\",\"ababababae\",\"ababababaf\",\"ababababag\",\"ababababah\",\"ababababai\",\"ababababaj\",\"ababababak\",\"ababababal\",\"ababababam\",\"ababababan\",\"ababababao\",\"ababababap\",\"ababababaq\",\"ababababar\",\"ababababas\",\"ababababat\",\"ababababau\",\"ababababav\",\"ababababaw\",\"ababababax\",\"ababababay\",\"ababababaz\",\"ababababba\",\"ababababbb\",\"ababababbc\",\"ababababbd\",\"ababababbe\",\"ababababbf\",\"ababababbg\",\"ababababbh\",\"ababababbi\",\"ababababbj\",\"ababababbk\",\"ababababbl\",\"ababababbm\",\"ababababbn\",\"ababababbo\",\"ababababbp\",\"ababababbq\",\"ababababbr\",\"ababababbs\",\"ababababbt\",\"ababababbu\",\"ababababbv\",\"ababababbw\",\"ababababbx\",\"ababababby\",\"ababababbz\",\"ababababca\",\"ababababcb\",\"ababababcc\",\"ababababcd\",\"ababababce\",\"ababababcf\",\"ababababcg\",\"ababababch\",\"ababababci\",\"ababababcj\",\"ababababck\",\"ababababcl\",\"ababababcm\",\"ababababcn\",\"ababababco\",\"ababababcp\",\"ababababcq\",\"ababababcr\",\"ababababcs\",\"ababababct\",\"ababababcu\",\"ababababcv\",\"ababababcw\",\"ababababcx\",\"ababababcy\",\"ababababcz\",\"ababababda\",\"ababababdb\",\"ababababdc\",\"ababababdd\",\"ababababde\",\"ababababdf\",\"ababababdg\",\"ababababdh\",\"ababababdi\",\"ababababdj\",\"ababababdk\",\"ababababdl\",\"ababababdm\",\"ababababdn\",\"ababababdo\",\"ababababdp\",\"ababababdq\",\"ababababdr\",\"ababababds\",\"ababababdt\",\"ababababdu\",\"ababababdv\",\"ababababdw\",\"ababababdx\",\"ababababdy\",\"ababababdz\",\"ababababea\",\"ababababeb\",\"ababababec\",\"ababababed\",\"ababababee\",\"ababababef\",\"ababababeg\",\"ababababeh\",\"ababababei\",\"ababababej\",\"ababababek\",\"ababababel\",\"ababababem\",\"ababababen\",\"ababababeo\",\"ababababep\",\"ababababeq\",\"ababababer\",\"ababababes\",\"ababababet\",\"ababababeu\",\"ababababev\",\"ababababew\",\"ababababex\",\"ababababey\",\"ababababez\",\"ababababfa\",\"ababababfb\",\"ababababfc\",\"ababababfd\",\"ababababfe\",\"ababababff\",\"ababababfg\",\"ababababfh\",\"ababababfi\",\"ababababfj\",\"ababababfk\",\"ababababfl\",\"ababababfm\",\"ababababfn\",\"ababababfo\",\"ababababfp\",\"ababababfq\",\"ababababfr\",\"ababababfs\",\"ababababft\",\"ababababfu\",\"ababababfv\",\"ababababfw\",\"ababababfx\",\"ababababfy\",\"ababababfz\",\"ababababga\",\"ababababgb\",\"ababababgc\",\"ababababgd\",\"ababababge\",\"ababababgf\",\"ababababgg\",\"ababababgh\",\"ababababgi\",\"ababababgj\",\"ababababgk\",\"ababababgl\",\"ababababgm\",\"ababababgn\",\"ababababgo\",\"ababababgp\",\"ababababgq\",\"ababababgr\",\"ababababgs\",\"ababababgt\",\"ababababgu\",\"ababababgv\",\"ababababgw\",\"ababababgx\",\"ababababgy\",\"ababababgz\",\"ababababha\",\"ababababhb\",\"ababababhc\",\"ababababhd\",\"ababababhe\",\"ababababhf\",\"ababababhg\",\"ababababhh\",\"ababababhi\",\"ababababhj\",\"ababababhk\",\"ababababhl\",\"ababababhm\",\"ababababhn\",\"ababababho\",\"ababababhp\",\"ababababhq\",\"ababababhr\",\"ababababhs\",\"ababababht\",\"ababababhu\",\"ababababhv\",\"ababababhw\",\"ababababhx\",\"ababababhy\",\"ababababhz\",\"ababababia\",\"ababababib\",\"ababababic\",\"ababababid\",\"ababababie\",\"ababababif\",\"ababababig\",\"ababababih\",\"ababababii\",\"ababababij\",\"ababababik\",\"ababababil\",\"ababababim\",\"ababababin\",\"ababababio\",\"ababababip\",\"ababababiq\",\"ababababir\",\"ababababis\",\"ababababit\",\"ababababiu\",\"ababababiv\",\"ababababiw\",\"ababababix\",\"ababababiy\",\"ababababiz\",\"ababababja\",\"ababababjb\",\"ababababjc\",\"ababababjd\",\"ababababje\",\"ababababjf\",\"ababababjg\",\"ababababjh\",\"ababababji\",\"ababababjj\",\"ababababjk\",\"ababababjl\",\"ababababjm\",\"ababababjn\",\"ababababjo\",\"ababababjp\",\"ababababjq\",\"ababababjr\",\"ababababjs\",\"ababababjt\",\"ababababju\",\"ababababjv\",\"ababababjw\",\"ababababjx\",\"ababababjy\",\"ababababjz\",\"ababababka\",\"ababababkb\",\"ababababkc\",\"ababababkd\",\"ababababke\",\"ababababkf\",\"ababababkg\",\"ababababkh\",\"ababababki\",\"ababababkj\",\"ababababkk\",\"ababababkl\",\"ababababkm\",\"ababababkn\",\"ababababko\",\"ababababkp\",\"ababababkq\",\"ababababkr\",\"ababababks\",\"ababababkt\",\"ababababku\",\"ababababkv\",\"ababababkw\",\"ababababkx\",\"ababababky\",\"ababababkz\",\"ababababla\",\"abababablb\",\"abababablc\",\"ababababld\",\"abababable\",\"abababablf\",\"abababablg\",\"abababablh\",\"ababababli\",\"abababablj\",\"abababablk\",\"ababababll\",\"abababablm\",\"ababababln\",\"abababablo\",\"abababablp\",\"abababablq\",\"abababablr\",\"ababababls\",\"abababablt\",\"abababablu\",\"abababablv\",\"abababablw\",\"abababablx\",\"abababably\",\"abababablz\",\"ababababma\",\"ababababmb\",\"ababababmc\",\"ababababmd\",\"ababababme\",\"ababababmf\",\"ababababmg\",\"ababababmh\",\"ababababmi\",\"ababababmj\",\"ababababmk\",\"ababababml\",\"ababababmm\",\"ababababmn\",\"ababababmo\",\"ababababmp\",\"ababababmq\",\"ababababmr\",\"ababababms\",\"ababababmt\",\"ababababmu\",\"ababababmv\",\"ababababmw\",\"ababababmx\",\"ababababmy\",\"ababababmz\",\"ababababna\",\"ababababnb\",\"ababababnc\",\"ababababnd\",\"ababababne\",\"ababababnf\",\"ababababng\",\"ababababnh\",\"ababababni\",\"ababababnj\",\"ababababnk\",\"ababababnl\",\"ababababnm\",\"ababababnn\",\"ababababno\",\"ababababnp\",\"ababababnq\",\"ababababnr\",\"ababababns\",\"ababababnt\",\"ababababnu\",\"ababababnv\",\"ababababnw\",\"ababababnx\",\"ababababny\",\"ababababnz\",\"ababababoa\",\"ababababob\",\"ababababoc\",\"ababababod\",\"ababababoe\",\"ababababof\",\"ababababog\",\"ababababoh\",\"ababababoi\",\"ababababoj\",\"ababababok\",\"ababababol\",\"ababababom\",\"ababababon\",\"ababababoo\",\"ababababop\",\"ababababoq\",\"ababababor\",\"ababababos\",\"ababababot\",\"ababababou\",\"ababababov\",\"ababababow\",\"ababababox\",\"ababababoy\",\"ababababoz\",\"ababababpa\",\"ababababpb\",\"ababababpc\",\"ababababpd\",\"ababababpe\",\"ababababpf\",\"ababababpg\",\"ababababph\",\"ababababpi\",\"ababababpj\",\"ababababpk\",\"ababababpl\",\"ababababpm\",\"ababababpn\",\"ababababpo\",\"ababababpp\",\"ababababpq\",\"ababababpr\",\"ababababps\",\"ababababpt\",\"ababababpu\",\"ababababpv\",\"ababababpw\",\"ababababpx\",\"ababababpy\",\"ababababpz\",\"ababababqa\",\"ababababqb\",\"ababababqc\",\"ababababqd\",\"ababababqe\",\"ababababqf\",\"ababababqg\",\"ababababqh\",\"ababababqi\",\"ababababqj\",\"ababababqk\",\"ababababql\",\"ababababqm\",\"ababababqn\",\"ababababqo\",\"ababababqp\",\"ababababqq\",\"ababababqr\",\"ababababqs\",\"ababababqt\",\"ababababqu\",\"ababababqv\",\"ababababqw\",\"ababababqx\",\"ababababqy\",\"ababababqz\",\"ababababra\",\"ababababrb\",\"ababababrc\",\"ababababrd\",\"ababababre\",\"ababababrf\",\"ababababrg\",\"ababababrh\",\"ababababri\",\"ababababrj\",\"ababababrk\",\"ababababrl\",\"ababababrm\",\"ababababrn\",\"ababababro\",\"ababababrp\",\"ababababrq\",\"ababababrr\",\"ababababrs\",\"ababababrt\",\"ababababru\",\"ababababrv\",\"ababababrw\",\"ababababrx\",\"ababababry\",\"ababababrz\",\"ababababsa\",\"ababababsb\",\"ababababsc\",\"ababababsd\",\"ababababse\",\"ababababsf\",\"ababababsg\",\"ababababsh\",\"ababababsi\",\"ababababsj\",\"ababababsk\",\"ababababsl\",\"ababababsm\",\"ababababsn\",\"ababababso\",\"ababababsp\",\"ababababsq\",\"ababababsr\",\"ababababss\",\"ababababst\",\"ababababsu\",\"ababababsv\",\"ababababsw\",\"ababababsx\",\"ababababsy\",\"ababababsz\",\"ababababta\",\"ababababtb\",\"ababababtc\",\"ababababtd\",\"ababababte\",\"ababababtf\",\"ababababtg\",\"ababababth\",\"ababababti\",\"ababababtj\",\"ababababtk\",\"ababababtl\",\"ababababtm\",\"ababababtn\",\"ababababto\",\"ababababtp\",\"ababababtq\",\"ababababtr\",\"ababababts\",\"ababababtt\",\"ababababtu\",\"ababababtv\",\"ababababtw\",\"ababababtx\",\"ababababty\",\"ababababtz\",\"ababababua\",\"ababababub\",\"ababababuc\",\"ababababud\",\"ababababue\",\"ababababuf\",\"ababababug\",\"ababababuh\",\"ababababui\",\"ababababuj\",\"ababababuk\",\"ababababul\",\"ababababum\",\"ababababun\",\"ababababuo\",\"ababababup\",\"ababababuq\",\"ababababur\",\"ababababus\",\"ababababut\",\"ababababuu\",\"ababababuv\",\"ababababuw\",\"ababababux\",\"ababababuy\",\"ababababuz\",\"ababababva\",\"ababababvb\",\"ababababvc\",\"ababababvd\",\"ababababve\",\"ababababvf\",\"ababababvg\",\"ababababvh\",\"ababababvi\",\"ababababvj\",\"ababababvk\",\"ababababvl\",\"ababababvm\",\"ababababvn\",\"ababababvo\",\"ababababvp\",\"ababababvq\",\"ababababvr\",\"ababababvs\",\"ababababvt\",\"ababababvu\",\"ababababvv\",\"ababababvw\",\"ababababvx\",\"ababababvy\",\"ababababvz\",\"ababababwa\",\"ababababwb\",\"ababababwc\",\"ababababwd\",\"ababababwe\",\"ababababwf\",\"ababababwg\",\"ababababwh\",\"ababababwi\",\"ababababwj\",\"ababababwk\",\"ababababwl\",\"ababababwm\",\"ababababwn\",\"ababababwo\",\"ababababwp\",\"ababababwq\",\"ababababwr\",\"ababababws\",\"ababababwt\",\"ababababwu\",\"ababababwv\",\"ababababww\",\"ababababwx\",\"ababababwy\",\"ababababwz\",\"ababababxa\",\"ababababxb\",\"ababababxc\",\"ababababxd\",\"ababababxe\",\"ababababxf\",\"ababababxg\",\"ababababxh\",\"ababababxi\",\"ababababxj\",\"ababababxk\",\"ababababxl\",\"ababababxm\",\"ababababxn\",\"ababababxo\",\"ababababxp\",\"ababababxq\",\"ababababxr\",\"ababababxs\",\"ababababxt\",\"ababababxu\",\"ababababxv\",\"ababababxw\",\"ababababxx\",\"ababababxy\",\"ababababxz\",\"ababababya\",\"ababababyb\",\"ababababyc\",\"ababababyd\",\"ababababye\",\"ababababyf\",\"ababababyg\",\"ababababyh\",\"ababababyi\",\"ababababyj\",\"ababababyk\",\"ababababyl\",\"ababababym\",\"ababababyn\",\"ababababyo\",\"ababababyp\",\"ababababyq\",\"ababababyr\",\"ababababys\",\"ababababyt\",\"ababababyu\",\"ababababyv\",\"ababababyw\",\"ababababyx\",\"ababababyy\",\"ababababyz\",\"ababababza\",\"ababababzb\",\"ababababzc\",\"ababababzd\",\"ababababze\",\"ababababzf\",\"ababababzg\",\"ababababzh\",\"ababababzi\",\"ababababzj\",\"ababababzk\",\"ababababzl\",\"ababababzm\",\"ababababzn\",\"ababababzo\",\"ababababzp\",\"ababababzq\",\"ababababzr\",\"ababababzs\",\"ababababzt\",\"ababababzu\",\"ababababzv\",\"ababababzw\",\"ababababzx\",\"ababababzy\",\"ababababzz\"]"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "hashmap fails at this test case:)"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "After solving this problem, I can\\n- Build a crossword puzzle app\\n- Add it to my resume\\n- Hope to get a job"
                    },
                    {
                        "username": "Vikas_Sen",
                        "content": "can not this question be solved without Trie. I have not covered this topic yet. I\\'ve solved word search problem-I easily. how can this question be solved with that methos?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Vikas Sen](/Codeverse_1) Yes!"
                    },
                    {
                        "username": "zooperman",
                        "content": "Hello Mods,\\n\\nthe program seems to run fine with TC-3, when run stand-alone, or with other TC\\'s, but when this is submitted for evaluation, it fails.\\nPlease check this.\\nThe TC-3, runs as expected on my laptop as well, along with other TC\\'s.![image](https://assets.leetcode.com/users/zooperman/image_1589425337.png)\\n"
                    },
                    {
                        "username": "greedycat",
                        "content": "They seem the same but Q212 is ranked hard and Q079 is ranked medium. Am I missing something? The only difference I can spot is in Q212 you search for multiple words in a list. But isn\\'t this change trivial because I can just repeat Q079 for the list?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@greedycat](/greedycat) For P79: length.word is15 and board is 6*6, only a single word. A mere DFS can pass without TLE. But for a list of words, Trie/treenode or dict are far from good. \nI try so hard to improve my DFS/path&graph. Finally, It works! But it's nothing compare to Trie."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Yes but I think they want something else, it looks like a trie or something. for multiple words that starts with same prefix rather than applying 79 on each word, use the prefix and search for both words."
                    },
                    {
                        "username": "user5502m",
                        "content": "I was thinking that too"
                    },
                    {
                        "username": "sarthak13",
                        "content": "[[\"a\"]]\\n[\"a\",\"a\"]\\n\\nOutput is \"a\".\\nAs per the question it should be \"a\",\"a\".\\n\\nAm I missing anything?"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "How is the matching any different than https://leetcode.com/problems/word-break-ii/ ?"
                    },
                    {
                        "username": "gglmg",
                        "content": "Question  says you cannot use same letter more than once but the example given has used 't' in both oath and eat.\\n\\nWhat am I missing here.\\n'"
                    },
                    {
                        "username": "palakons",
                        "content": "also, not the same letter per se, but same (row,col) position"
                    },
                    {
                        "username": "AyushSinha",
                        "content": "I think the same letter shouldn\\'t be used twice in the same word."
                    },
                    {
                        "username": "dskloet",
                        "content": "Why is this problem about speed? The inputs were crafted to fail some non-optimized solutions but not others. I bet none of the posted solutions pass this input:\\n\\n[[\"x\",\"x\",\"a\",\"x\",\"x\"],[\"x\",\"o\",\"o\",\"o\",\"o\"],[\"x\",\"o\",\"o\",\"o\",\"o\"],[\"x\",\"x\",\"o\",\"x\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"x\"],[\"x\",\"x\",\"o\",\"x\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"b\"]]\\n[\"aooooooooooooooooooooooooooooooooooooooooooooooooooooob\"]"
                    },
                    {
                        "username": "charonme",
                        "content": "it says: \"Invalid Testcase\\nexpected \\'board\\' to have 1 <= size <= 12 but got 15\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@dskloet](/dskloet)\nMy pure DFS solution 989ms in Leetcode, solve your problem only: 1.9944 miliseconds\n\ncheck data  # | i&j = [14, 4], word= b b 54\n['aooooooooooooooooooooooooooooooooooooooooooooooooooooob']\n\nBut Trie gets TLE for sure.\n\t"
                    },
                    {
                        "username": "echobeacon",
                        "content": "Problem constraints say all words are 10 characters or less"
                    },
                    {
                        "username": "Fluffy_Memory_6238",
                        "content": "If word exceeds m or n we can simply leave that one? also m,n<=12"
                    }
                ]
            },
            {
                "id": 1573996,
                "content": [
                    {
                        "username": "Heisenburgerrr",
                        "content": "Solving this question made me feel so high lol"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I don\\'t think use of tries is at all intuitive because generally words don\\'t share this big prefixes. I feel it should be mentioned somewhere in the question. \\nboard = [[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"]]\\n\\nwords = [\"ababababaa\",\"ababababab\",\"ababababac\",\"ababababad\",\"ababababae\",\"ababababaf\",\"ababababag\",\"ababababah\",\"ababababai\",\"ababababaj\",\"ababababak\",\"ababababal\",\"ababababam\",\"ababababan\",\"ababababao\",\"ababababap\",\"ababababaq\",\"ababababar\",\"ababababas\",\"ababababat\",\"ababababau\",\"ababababav\",\"ababababaw\",\"ababababax\",\"ababababay\",\"ababababaz\",\"ababababba\",\"ababababbb\",\"ababababbc\",\"ababababbd\",\"ababababbe\",\"ababababbf\",\"ababababbg\",\"ababababbh\",\"ababababbi\",\"ababababbj\",\"ababababbk\",\"ababababbl\",\"ababababbm\",\"ababababbn\",\"ababababbo\",\"ababababbp\",\"ababababbq\",\"ababababbr\",\"ababababbs\",\"ababababbt\",\"ababababbu\",\"ababababbv\",\"ababababbw\",\"ababababbx\",\"ababababby\",\"ababababbz\",\"ababababca\",\"ababababcb\",\"ababababcc\",\"ababababcd\",\"ababababce\",\"ababababcf\",\"ababababcg\",\"ababababch\",\"ababababci\",\"ababababcj\",\"ababababck\",\"ababababcl\",\"ababababcm\",\"ababababcn\",\"ababababco\",\"ababababcp\",\"ababababcq\",\"ababababcr\",\"ababababcs\",\"ababababct\",\"ababababcu\",\"ababababcv\",\"ababababcw\",\"ababababcx\",\"ababababcy\",\"ababababcz\",\"ababababda\",\"ababababdb\",\"ababababdc\",\"ababababdd\",\"ababababde\",\"ababababdf\",\"ababababdg\",\"ababababdh\",\"ababababdi\",\"ababababdj\",\"ababababdk\",\"ababababdl\",\"ababababdm\",\"ababababdn\",\"ababababdo\",\"ababababdp\",\"ababababdq\",\"ababababdr\",\"ababababds\",\"ababababdt\",\"ababababdu\",\"ababababdv\",\"ababababdw\",\"ababababdx\",\"ababababdy\",\"ababababdz\",\"ababababea\",\"ababababeb\",\"ababababec\",\"ababababed\",\"ababababee\",\"ababababef\",\"ababababeg\",\"ababababeh\",\"ababababei\",\"ababababej\",\"ababababek\",\"ababababel\",\"ababababem\",\"ababababen\",\"ababababeo\",\"ababababep\",\"ababababeq\",\"ababababer\",\"ababababes\",\"ababababet\",\"ababababeu\",\"ababababev\",\"ababababew\",\"ababababex\",\"ababababey\",\"ababababez\",\"ababababfa\",\"ababababfb\",\"ababababfc\",\"ababababfd\",\"ababababfe\",\"ababababff\",\"ababababfg\",\"ababababfh\",\"ababababfi\",\"ababababfj\",\"ababababfk\",\"ababababfl\",\"ababababfm\",\"ababababfn\",\"ababababfo\",\"ababababfp\",\"ababababfq\",\"ababababfr\",\"ababababfs\",\"ababababft\",\"ababababfu\",\"ababababfv\",\"ababababfw\",\"ababababfx\",\"ababababfy\",\"ababababfz\",\"ababababga\",\"ababababgb\",\"ababababgc\",\"ababababgd\",\"ababababge\",\"ababababgf\",\"ababababgg\",\"ababababgh\",\"ababababgi\",\"ababababgj\",\"ababababgk\",\"ababababgl\",\"ababababgm\",\"ababababgn\",\"ababababgo\",\"ababababgp\",\"ababababgq\",\"ababababgr\",\"ababababgs\",\"ababababgt\",\"ababababgu\",\"ababababgv\",\"ababababgw\",\"ababababgx\",\"ababababgy\",\"ababababgz\",\"ababababha\",\"ababababhb\",\"ababababhc\",\"ababababhd\",\"ababababhe\",\"ababababhf\",\"ababababhg\",\"ababababhh\",\"ababababhi\",\"ababababhj\",\"ababababhk\",\"ababababhl\",\"ababababhm\",\"ababababhn\",\"ababababho\",\"ababababhp\",\"ababababhq\",\"ababababhr\",\"ababababhs\",\"ababababht\",\"ababababhu\",\"ababababhv\",\"ababababhw\",\"ababababhx\",\"ababababhy\",\"ababababhz\",\"ababababia\",\"ababababib\",\"ababababic\",\"ababababid\",\"ababababie\",\"ababababif\",\"ababababig\",\"ababababih\",\"ababababii\",\"ababababij\",\"ababababik\",\"ababababil\",\"ababababim\",\"ababababin\",\"ababababio\",\"ababababip\",\"ababababiq\",\"ababababir\",\"ababababis\",\"ababababit\",\"ababababiu\",\"ababababiv\",\"ababababiw\",\"ababababix\",\"ababababiy\",\"ababababiz\",\"ababababja\",\"ababababjb\",\"ababababjc\",\"ababababjd\",\"ababababje\",\"ababababjf\",\"ababababjg\",\"ababababjh\",\"ababababji\",\"ababababjj\",\"ababababjk\",\"ababababjl\",\"ababababjm\",\"ababababjn\",\"ababababjo\",\"ababababjp\",\"ababababjq\",\"ababababjr\",\"ababababjs\",\"ababababjt\",\"ababababju\",\"ababababjv\",\"ababababjw\",\"ababababjx\",\"ababababjy\",\"ababababjz\",\"ababababka\",\"ababababkb\",\"ababababkc\",\"ababababkd\",\"ababababke\",\"ababababkf\",\"ababababkg\",\"ababababkh\",\"ababababki\",\"ababababkj\",\"ababababkk\",\"ababababkl\",\"ababababkm\",\"ababababkn\",\"ababababko\",\"ababababkp\",\"ababababkq\",\"ababababkr\",\"ababababks\",\"ababababkt\",\"ababababku\",\"ababababkv\",\"ababababkw\",\"ababababkx\",\"ababababky\",\"ababababkz\",\"ababababla\",\"abababablb\",\"abababablc\",\"ababababld\",\"abababable\",\"abababablf\",\"abababablg\",\"abababablh\",\"ababababli\",\"abababablj\",\"abababablk\",\"ababababll\",\"abababablm\",\"ababababln\",\"abababablo\",\"abababablp\",\"abababablq\",\"abababablr\",\"ababababls\",\"abababablt\",\"abababablu\",\"abababablv\",\"abababablw\",\"abababablx\",\"abababably\",\"abababablz\",\"ababababma\",\"ababababmb\",\"ababababmc\",\"ababababmd\",\"ababababme\",\"ababababmf\",\"ababababmg\",\"ababababmh\",\"ababababmi\",\"ababababmj\",\"ababababmk\",\"ababababml\",\"ababababmm\",\"ababababmn\",\"ababababmo\",\"ababababmp\",\"ababababmq\",\"ababababmr\",\"ababababms\",\"ababababmt\",\"ababababmu\",\"ababababmv\",\"ababababmw\",\"ababababmx\",\"ababababmy\",\"ababababmz\",\"ababababna\",\"ababababnb\",\"ababababnc\",\"ababababnd\",\"ababababne\",\"ababababnf\",\"ababababng\",\"ababababnh\",\"ababababni\",\"ababababnj\",\"ababababnk\",\"ababababnl\",\"ababababnm\",\"ababababnn\",\"ababababno\",\"ababababnp\",\"ababababnq\",\"ababababnr\",\"ababababns\",\"ababababnt\",\"ababababnu\",\"ababababnv\",\"ababababnw\",\"ababababnx\",\"ababababny\",\"ababababnz\",\"ababababoa\",\"ababababob\",\"ababababoc\",\"ababababod\",\"ababababoe\",\"ababababof\",\"ababababog\",\"ababababoh\",\"ababababoi\",\"ababababoj\",\"ababababok\",\"ababababol\",\"ababababom\",\"ababababon\",\"ababababoo\",\"ababababop\",\"ababababoq\",\"ababababor\",\"ababababos\",\"ababababot\",\"ababababou\",\"ababababov\",\"ababababow\",\"ababababox\",\"ababababoy\",\"ababababoz\",\"ababababpa\",\"ababababpb\",\"ababababpc\",\"ababababpd\",\"ababababpe\",\"ababababpf\",\"ababababpg\",\"ababababph\",\"ababababpi\",\"ababababpj\",\"ababababpk\",\"ababababpl\",\"ababababpm\",\"ababababpn\",\"ababababpo\",\"ababababpp\",\"ababababpq\",\"ababababpr\",\"ababababps\",\"ababababpt\",\"ababababpu\",\"ababababpv\",\"ababababpw\",\"ababababpx\",\"ababababpy\",\"ababababpz\",\"ababababqa\",\"ababababqb\",\"ababababqc\",\"ababababqd\",\"ababababqe\",\"ababababqf\",\"ababababqg\",\"ababababqh\",\"ababababqi\",\"ababababqj\",\"ababababqk\",\"ababababql\",\"ababababqm\",\"ababababqn\",\"ababababqo\",\"ababababqp\",\"ababababqq\",\"ababababqr\",\"ababababqs\",\"ababababqt\",\"ababababqu\",\"ababababqv\",\"ababababqw\",\"ababababqx\",\"ababababqy\",\"ababababqz\",\"ababababra\",\"ababababrb\",\"ababababrc\",\"ababababrd\",\"ababababre\",\"ababababrf\",\"ababababrg\",\"ababababrh\",\"ababababri\",\"ababababrj\",\"ababababrk\",\"ababababrl\",\"ababababrm\",\"ababababrn\",\"ababababro\",\"ababababrp\",\"ababababrq\",\"ababababrr\",\"ababababrs\",\"ababababrt\",\"ababababru\",\"ababababrv\",\"ababababrw\",\"ababababrx\",\"ababababry\",\"ababababrz\",\"ababababsa\",\"ababababsb\",\"ababababsc\",\"ababababsd\",\"ababababse\",\"ababababsf\",\"ababababsg\",\"ababababsh\",\"ababababsi\",\"ababababsj\",\"ababababsk\",\"ababababsl\",\"ababababsm\",\"ababababsn\",\"ababababso\",\"ababababsp\",\"ababababsq\",\"ababababsr\",\"ababababss\",\"ababababst\",\"ababababsu\",\"ababababsv\",\"ababababsw\",\"ababababsx\",\"ababababsy\",\"ababababsz\",\"ababababta\",\"ababababtb\",\"ababababtc\",\"ababababtd\",\"ababababte\",\"ababababtf\",\"ababababtg\",\"ababababth\",\"ababababti\",\"ababababtj\",\"ababababtk\",\"ababababtl\",\"ababababtm\",\"ababababtn\",\"ababababto\",\"ababababtp\",\"ababababtq\",\"ababababtr\",\"ababababts\",\"ababababtt\",\"ababababtu\",\"ababababtv\",\"ababababtw\",\"ababababtx\",\"ababababty\",\"ababababtz\",\"ababababua\",\"ababababub\",\"ababababuc\",\"ababababud\",\"ababababue\",\"ababababuf\",\"ababababug\",\"ababababuh\",\"ababababui\",\"ababababuj\",\"ababababuk\",\"ababababul\",\"ababababum\",\"ababababun\",\"ababababuo\",\"ababababup\",\"ababababuq\",\"ababababur\",\"ababababus\",\"ababababut\",\"ababababuu\",\"ababababuv\",\"ababababuw\",\"ababababux\",\"ababababuy\",\"ababababuz\",\"ababababva\",\"ababababvb\",\"ababababvc\",\"ababababvd\",\"ababababve\",\"ababababvf\",\"ababababvg\",\"ababababvh\",\"ababababvi\",\"ababababvj\",\"ababababvk\",\"ababababvl\",\"ababababvm\",\"ababababvn\",\"ababababvo\",\"ababababvp\",\"ababababvq\",\"ababababvr\",\"ababababvs\",\"ababababvt\",\"ababababvu\",\"ababababvv\",\"ababababvw\",\"ababababvx\",\"ababababvy\",\"ababababvz\",\"ababababwa\",\"ababababwb\",\"ababababwc\",\"ababababwd\",\"ababababwe\",\"ababababwf\",\"ababababwg\",\"ababababwh\",\"ababababwi\",\"ababababwj\",\"ababababwk\",\"ababababwl\",\"ababababwm\",\"ababababwn\",\"ababababwo\",\"ababababwp\",\"ababababwq\",\"ababababwr\",\"ababababws\",\"ababababwt\",\"ababababwu\",\"ababababwv\",\"ababababww\",\"ababababwx\",\"ababababwy\",\"ababababwz\",\"ababababxa\",\"ababababxb\",\"ababababxc\",\"ababababxd\",\"ababababxe\",\"ababababxf\",\"ababababxg\",\"ababababxh\",\"ababababxi\",\"ababababxj\",\"ababababxk\",\"ababababxl\",\"ababababxm\",\"ababababxn\",\"ababababxo\",\"ababababxp\",\"ababababxq\",\"ababababxr\",\"ababababxs\",\"ababababxt\",\"ababababxu\",\"ababababxv\",\"ababababxw\",\"ababababxx\",\"ababababxy\",\"ababababxz\",\"ababababya\",\"ababababyb\",\"ababababyc\",\"ababababyd\",\"ababababye\",\"ababababyf\",\"ababababyg\",\"ababababyh\",\"ababababyi\",\"ababababyj\",\"ababababyk\",\"ababababyl\",\"ababababym\",\"ababababyn\",\"ababababyo\",\"ababababyp\",\"ababababyq\",\"ababababyr\",\"ababababys\",\"ababababyt\",\"ababababyu\",\"ababababyv\",\"ababababyw\",\"ababababyx\",\"ababababyy\",\"ababababyz\",\"ababababza\",\"ababababzb\",\"ababababzc\",\"ababababzd\",\"ababababze\",\"ababababzf\",\"ababababzg\",\"ababababzh\",\"ababababzi\",\"ababababzj\",\"ababababzk\",\"ababababzl\",\"ababababzm\",\"ababababzn\",\"ababababzo\",\"ababababzp\",\"ababababzq\",\"ababababzr\",\"ababababzs\",\"ababababzt\",\"ababababzu\",\"ababababzv\",\"ababababzw\",\"ababababzx\",\"ababababzy\",\"ababababzz\"]"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "hashmap fails at this test case:)"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "After solving this problem, I can\\n- Build a crossword puzzle app\\n- Add it to my resume\\n- Hope to get a job"
                    },
                    {
                        "username": "Vikas_Sen",
                        "content": "can not this question be solved without Trie. I have not covered this topic yet. I\\'ve solved word search problem-I easily. how can this question be solved with that methos?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Vikas Sen](/Codeverse_1) Yes!"
                    },
                    {
                        "username": "zooperman",
                        "content": "Hello Mods,\\n\\nthe program seems to run fine with TC-3, when run stand-alone, or with other TC\\'s, but when this is submitted for evaluation, it fails.\\nPlease check this.\\nThe TC-3, runs as expected on my laptop as well, along with other TC\\'s.![image](https://assets.leetcode.com/users/zooperman/image_1589425337.png)\\n"
                    },
                    {
                        "username": "greedycat",
                        "content": "They seem the same but Q212 is ranked hard and Q079 is ranked medium. Am I missing something? The only difference I can spot is in Q212 you search for multiple words in a list. But isn\\'t this change trivial because I can just repeat Q079 for the list?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@greedycat](/greedycat) For P79: length.word is15 and board is 6*6, only a single word. A mere DFS can pass without TLE. But for a list of words, Trie/treenode or dict are far from good. \nI try so hard to improve my DFS/path&graph. Finally, It works! But it's nothing compare to Trie."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Yes but I think they want something else, it looks like a trie or something. for multiple words that starts with same prefix rather than applying 79 on each word, use the prefix and search for both words."
                    },
                    {
                        "username": "user5502m",
                        "content": "I was thinking that too"
                    },
                    {
                        "username": "sarthak13",
                        "content": "[[\"a\"]]\\n[\"a\",\"a\"]\\n\\nOutput is \"a\".\\nAs per the question it should be \"a\",\"a\".\\n\\nAm I missing anything?"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "How is the matching any different than https://leetcode.com/problems/word-break-ii/ ?"
                    },
                    {
                        "username": "gglmg",
                        "content": "Question  says you cannot use same letter more than once but the example given has used 't' in both oath and eat.\\n\\nWhat am I missing here.\\n'"
                    },
                    {
                        "username": "palakons",
                        "content": "also, not the same letter per se, but same (row,col) position"
                    },
                    {
                        "username": "AyushSinha",
                        "content": "I think the same letter shouldn\\'t be used twice in the same word."
                    },
                    {
                        "username": "dskloet",
                        "content": "Why is this problem about speed? The inputs were crafted to fail some non-optimized solutions but not others. I bet none of the posted solutions pass this input:\\n\\n[[\"x\",\"x\",\"a\",\"x\",\"x\"],[\"x\",\"o\",\"o\",\"o\",\"o\"],[\"x\",\"o\",\"o\",\"o\",\"o\"],[\"x\",\"x\",\"o\",\"x\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"x\"],[\"x\",\"x\",\"o\",\"x\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"b\"]]\\n[\"aooooooooooooooooooooooooooooooooooooooooooooooooooooob\"]"
                    },
                    {
                        "username": "charonme",
                        "content": "it says: \"Invalid Testcase\\nexpected \\'board\\' to have 1 <= size <= 12 but got 15\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@dskloet](/dskloet)\nMy pure DFS solution 989ms in Leetcode, solve your problem only: 1.9944 miliseconds\n\ncheck data  # | i&j = [14, 4], word= b b 54\n['aooooooooooooooooooooooooooooooooooooooooooooooooooooob']\n\nBut Trie gets TLE for sure.\n\t"
                    },
                    {
                        "username": "echobeacon",
                        "content": "Problem constraints say all words are 10 characters or less"
                    },
                    {
                        "username": "Fluffy_Memory_6238",
                        "content": "If word exceeds m or n we can simply leave that one? also m,n<=12"
                    }
                ]
            },
            {
                "id": 1567917,
                "content": [
                    {
                        "username": "scott",
                        "content": "my submitted code  was using pure back track and passed OJ \\n\\nI cannot see any need of using trie for the problem"
                    },
                    {
                        "username": "omkashyap007",
                        "content": "Anyone please help . Why this is not working . I made a simple dfs solution with backtracking . It seems to work with 58 test cases but fails at 59 .\\n\\nthis is board : [[\"a\",\"b\",\"c\"],[\"a\",\"e\",\"d\"],[\"a\",\"f\",\"g\"]]\\nwords : [\"abcdefg\",\"gfedcbaaa\",\"eaabcdgfa\",\"befa\",\"dgc\",\"ade\"]\\noutput : [\"gfedcbaaa\",\"abcdefg\",\"befa\"]\\nexpected : [\"abcdefg\",\"befa\",\"eaabcdgfa\",\"gfedcbaaa\"]\\n\\nwhat is wrong with the code : \\ncode : \\n ```\\nclass Solution:\\n\\n    def inside(self , i , j , grid):\\n        if i>= 0 and i < len(grid) and j>=0 and j < len(grid[0]) :\\n            return True\\n        return False\\n\\n    def dfs(self , i , j , index , word , grid , visited):\\n        if index >= len(word) : \\n            return True\\n        elif self.inside(i , j , grid) and not visited[i][j] and word[index] == grid[i][j] : \\n            found = False\\n            visited[i][j] = True\\n            found = any(\\n                [\\n                    self.dfs(i+1 , j , index+1 , word , grid , visited) ,\\n                    self.dfs(i-1 , j , index+1 , word , grid , visited) ,\\n                    self.dfs(i , j+1 , index+1 , word , grid , visited) ,\\n                    self.dfs(i , j-1 , index+1 , word , grid , visited) ,\\n                ]\\n            )\\n            visited = False\\n            return found\\n        else :\\n            return False\\n\\n    def findWords(self, grid: List[List[str]], words: List[str]) -> List[str]:\\n        wordMap = {}\\n        for word in words : \\n            char = word[0]\\n            wordMap[char] = wordMap.get(char , []) + [word]\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        answer = set()\\n        for i in range(rows) :\\n            for j in range(cols) :\\n                start_char = grid[i][j]\\n                if start_char not in wordMap :\\n                    continue\\n                wordList = wordMap[start_char]\\n                for word in wordList : \\n                    visited = [[False for _ in range(cols)] for _ in range(rows)]\\n                    if self.dfs(i , j , 0 , word , grid , visited) :\\n                        answer.add(word)\\n        return answer\\n```"
                    },
                    {
                        "username": "deadpool1205",
                        "content": "- You have set visited = False, it should be visited[i][j] = False \\n- While returning answer as list(answer) for convert set to list for the final result"
                    },
                    {
                        "username": "deadpool1205",
                        "content": "There should not be any duplicate words in answer keep that in mind for avoiding wrong submissions  :)"
                    },
                    {
                        "username": "user2075nF",
                        "content": "is the only way to pass last few test cases is to use prefix tree? or is there any other magic available?"
                    },
                    {
                        "username": "Jagadish_Shankar",
                        "content": "class Solution {\\n\\n    public boolean recursive_function(int i , int j , int rows , int columns , char[][] board , boolean[][] visited_cells , int index , String word , int word_length) {\\n\\n        if(index == word_length){\\n            return true;\\n        }\\n\\n        visited_cells[i][j] = true;\\n\\n        boolean top = (((i - 1) >= 0) && (word.charAt(index) == board[(i - 1)][j]) && (!visited_cells[(i - 1)][j]) && (recursive_function((i - 1) , j , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean bottom = (((i + 1) < rows) && (word.charAt(index) == board[(i + 1)][j]) && (!visited_cells[(i + 1)][j]) && (recursive_function((i + 1) , j , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean left = (((j - 1) >= 0) && (word.charAt(index) == board[i][(j - 1)]) && (!visited_cells[i][(j - 1)]) && (recursive_function(i , (j - 1) , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean right = (((j + 1) < columns) && (word.charAt(index) == board[i][(j + 1)]) && (!visited_cells[i][(j + 1)]) && (recursive_function(i , (j + 1) , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        visited_cells[i][j] = false;\\n\\n        return (top || bottom || left || right);\\n    }\\n\\n    public List<String> findWords(char[][] board , String[] words) {\\n\\n        int rows = board.length;\\n        \\n        int columns = board[0].length;\\n\\n        Set<String> all_words_in_board = new HashSet<String>();\\n        \\n        for(String word : (new HashSet<String>(Arrays.asList(words)))){\\n\\n            boolean word_found_flag = false;\\n            \\n            for (int i=0 ; (i < rows) ; i++) {\\n                \\n                for (int j=0 ; (j < columns) ; j++) {\\n                    \\n                    if((board[i][j] == word.charAt(0)) && (recursive_function(i , j , rows , columns , board , (new boolean[rows][columns]) , 1 , word , (word.length())))){\\n                        all_words_in_board.add(word);\\n                        word_found_flag = true;\\n                        break;\\n                    }\\n                }\\n\\n                if(word_found_flag){\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return (new ArrayList<String>(all_words_in_board));\\n    }\\n}\\n\\ncan somebody help me to optimize my program since it\\'s failing the last 3 test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "can some one tell why this code is not giving output \\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "arushi-08",
                        "content": "I have spent a lot of time trying to debug this solution, but I am still facing TLE error while submitting code (while the testcase itself gets accepted). Please suggest an optimization:\\n\\nPython:\\n```\\nclass Node:\\n    def __init__(self):\\n        self.children = {}\\n        self.endofword = False\\n\\n    def addWord(self, word):\\n        curr = self\\n        for c in word:\\n            if c not in curr.children:\\n                curr.children[c] = Node()\\n            curr = curr.children[c]\\n        curr.endofword = True\\n\\nclass Solution:\\n\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        root = Node()\\n        for w in words:\\n            root.addWord(w)\\n        \\n        self.res = []\\n        word = \\'\\'\\n        visited = set()\\n        rows = len(board)\\n        cols = len(board[0])\\n\\n        def dfs(x, y, node, word):\\n            if (x,y) in visited or board[x][y] not in node.children:\\n                return\\n            \\n            visited.add((x,y))\\n            node = node.children[board[x][y]]\\n            word += board[x][y]\\n            \\n            if node.endofword:\\n                self.res.append(word)\\n\\n            rrows = [-1, 0, 1, 0]\\n            ccols = [0, 1, 0, -1]\\n            for r,c in zip(rrows, ccols):\\n                if x+r >= 0 and y+c >= 0 and x+r < rows and y+c < cols:\\n                    dfs(x+r, y+c, node, word)\\n\\n            visited.remove((x,y))\\n        \\n        for i in range(rows):\\n            for j in range(cols):\\n                if board[i][j] in root.children:\\n                    dfs(i, j, root, word)\\n        \\n        return list(set(self.res))\\n\\n```"
                    },
                    {
                        "username": "sianliu1997",
                        "content": "\\nIn PyCharm, my code works fine, but when I submit it to LeetCode, an extra \\'oa\\' is added to the output. Why is this happening?\\n\\n```py\\nclass Solution:\\n    def findWords(self, board, words):\\n        m, n = len(board), len(board[0])\\n\\n        def dfs(board, i, j, word, k=0):\\n            b = copy.deepcopy(board)\\n            if k == len(word):\\n                return True\\n            if not 0 <= i < m or not 0 <= j < n or b[i][j] == \\'#\\' or b[i][j] != word[k]:\\n                return False\\n            b[i][j] = \\'#\\'\\n            return dfs(b, i + 1, j, word, k + 1) or \\\\\\n                   dfs(b, i - 1, j, word, k + 1) or \\\\\\n                   dfs(b, i, j + 1, word, k + 1) or \\\\\\n                   dfs(b, i, j - 1, word, k + 1)\\n\\n        res = []\\n        for i in range(m):\\n            for j in range(n):\\n                for w in words:\\n                    if board[i][j] == w[0] and dfs(board, i, j, w):\\n                        res.append(w)\\n        return res\\n```"
                    },
                    {
                        "username": "cagils",
                        "content": "Tips for general algorithm structure using Trie, Backtracing, and DFS with JS:\\n\\n```js\\nvar findWords = function (board, words) {\\n    const contains = []\\n    const trie = {} // A simple object is enough for a simple trie here\\n\\n    buildTrie()\\n\\n    *** HERE CALL DFS() ON EACH CELL ***\\n\\n    return contains\\n\\n    function buildTrie() {\\n        *** HERE BUILD TRIE FOR WORDS IN WORDS LIST ***\\n    }\\n\\n    function dfs(i, j, node, word) {\\n        *** HERE RECURSIVE DFS ON EACH DIRECTION ***\\n        *** IF WORD FINISHES ADD TO CONTAINS ***\\n        *** STORE CURRENT CHAR ON TEMP AND CHANGE IT TO INVALID CHARACTER ***\\n        *** AFTER DFS CALLS RESTORE THE CHARACTER (BACKTRACING) ***\\n    }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 2030936,
                "content": [
                    {
                        "username": "scott",
                        "content": "my submitted code  was using pure back track and passed OJ \\n\\nI cannot see any need of using trie for the problem"
                    },
                    {
                        "username": "omkashyap007",
                        "content": "Anyone please help . Why this is not working . I made a simple dfs solution with backtracking . It seems to work with 58 test cases but fails at 59 .\\n\\nthis is board : [[\"a\",\"b\",\"c\"],[\"a\",\"e\",\"d\"],[\"a\",\"f\",\"g\"]]\\nwords : [\"abcdefg\",\"gfedcbaaa\",\"eaabcdgfa\",\"befa\",\"dgc\",\"ade\"]\\noutput : [\"gfedcbaaa\",\"abcdefg\",\"befa\"]\\nexpected : [\"abcdefg\",\"befa\",\"eaabcdgfa\",\"gfedcbaaa\"]\\n\\nwhat is wrong with the code : \\ncode : \\n ```\\nclass Solution:\\n\\n    def inside(self , i , j , grid):\\n        if i>= 0 and i < len(grid) and j>=0 and j < len(grid[0]) :\\n            return True\\n        return False\\n\\n    def dfs(self , i , j , index , word , grid , visited):\\n        if index >= len(word) : \\n            return True\\n        elif self.inside(i , j , grid) and not visited[i][j] and word[index] == grid[i][j] : \\n            found = False\\n            visited[i][j] = True\\n            found = any(\\n                [\\n                    self.dfs(i+1 , j , index+1 , word , grid , visited) ,\\n                    self.dfs(i-1 , j , index+1 , word , grid , visited) ,\\n                    self.dfs(i , j+1 , index+1 , word , grid , visited) ,\\n                    self.dfs(i , j-1 , index+1 , word , grid , visited) ,\\n                ]\\n            )\\n            visited = False\\n            return found\\n        else :\\n            return False\\n\\n    def findWords(self, grid: List[List[str]], words: List[str]) -> List[str]:\\n        wordMap = {}\\n        for word in words : \\n            char = word[0]\\n            wordMap[char] = wordMap.get(char , []) + [word]\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        answer = set()\\n        for i in range(rows) :\\n            for j in range(cols) :\\n                start_char = grid[i][j]\\n                if start_char not in wordMap :\\n                    continue\\n                wordList = wordMap[start_char]\\n                for word in wordList : \\n                    visited = [[False for _ in range(cols)] for _ in range(rows)]\\n                    if self.dfs(i , j , 0 , word , grid , visited) :\\n                        answer.add(word)\\n        return answer\\n```"
                    },
                    {
                        "username": "deadpool1205",
                        "content": "- You have set visited = False, it should be visited[i][j] = False \\n- While returning answer as list(answer) for convert set to list for the final result"
                    },
                    {
                        "username": "deadpool1205",
                        "content": "There should not be any duplicate words in answer keep that in mind for avoiding wrong submissions  :)"
                    },
                    {
                        "username": "user2075nF",
                        "content": "is the only way to pass last few test cases is to use prefix tree? or is there any other magic available?"
                    },
                    {
                        "username": "Jagadish_Shankar",
                        "content": "class Solution {\\n\\n    public boolean recursive_function(int i , int j , int rows , int columns , char[][] board , boolean[][] visited_cells , int index , String word , int word_length) {\\n\\n        if(index == word_length){\\n            return true;\\n        }\\n\\n        visited_cells[i][j] = true;\\n\\n        boolean top = (((i - 1) >= 0) && (word.charAt(index) == board[(i - 1)][j]) && (!visited_cells[(i - 1)][j]) && (recursive_function((i - 1) , j , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean bottom = (((i + 1) < rows) && (word.charAt(index) == board[(i + 1)][j]) && (!visited_cells[(i + 1)][j]) && (recursive_function((i + 1) , j , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean left = (((j - 1) >= 0) && (word.charAt(index) == board[i][(j - 1)]) && (!visited_cells[i][(j - 1)]) && (recursive_function(i , (j - 1) , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean right = (((j + 1) < columns) && (word.charAt(index) == board[i][(j + 1)]) && (!visited_cells[i][(j + 1)]) && (recursive_function(i , (j + 1) , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        visited_cells[i][j] = false;\\n\\n        return (top || bottom || left || right);\\n    }\\n\\n    public List<String> findWords(char[][] board , String[] words) {\\n\\n        int rows = board.length;\\n        \\n        int columns = board[0].length;\\n\\n        Set<String> all_words_in_board = new HashSet<String>();\\n        \\n        for(String word : (new HashSet<String>(Arrays.asList(words)))){\\n\\n            boolean word_found_flag = false;\\n            \\n            for (int i=0 ; (i < rows) ; i++) {\\n                \\n                for (int j=0 ; (j < columns) ; j++) {\\n                    \\n                    if((board[i][j] == word.charAt(0)) && (recursive_function(i , j , rows , columns , board , (new boolean[rows][columns]) , 1 , word , (word.length())))){\\n                        all_words_in_board.add(word);\\n                        word_found_flag = true;\\n                        break;\\n                    }\\n                }\\n\\n                if(word_found_flag){\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return (new ArrayList<String>(all_words_in_board));\\n    }\\n}\\n\\ncan somebody help me to optimize my program since it\\'s failing the last 3 test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "can some one tell why this code is not giving output \\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "arushi-08",
                        "content": "I have spent a lot of time trying to debug this solution, but I am still facing TLE error while submitting code (while the testcase itself gets accepted). Please suggest an optimization:\\n\\nPython:\\n```\\nclass Node:\\n    def __init__(self):\\n        self.children = {}\\n        self.endofword = False\\n\\n    def addWord(self, word):\\n        curr = self\\n        for c in word:\\n            if c not in curr.children:\\n                curr.children[c] = Node()\\n            curr = curr.children[c]\\n        curr.endofword = True\\n\\nclass Solution:\\n\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        root = Node()\\n        for w in words:\\n            root.addWord(w)\\n        \\n        self.res = []\\n        word = \\'\\'\\n        visited = set()\\n        rows = len(board)\\n        cols = len(board[0])\\n\\n        def dfs(x, y, node, word):\\n            if (x,y) in visited or board[x][y] not in node.children:\\n                return\\n            \\n            visited.add((x,y))\\n            node = node.children[board[x][y]]\\n            word += board[x][y]\\n            \\n            if node.endofword:\\n                self.res.append(word)\\n\\n            rrows = [-1, 0, 1, 0]\\n            ccols = [0, 1, 0, -1]\\n            for r,c in zip(rrows, ccols):\\n                if x+r >= 0 and y+c >= 0 and x+r < rows and y+c < cols:\\n                    dfs(x+r, y+c, node, word)\\n\\n            visited.remove((x,y))\\n        \\n        for i in range(rows):\\n            for j in range(cols):\\n                if board[i][j] in root.children:\\n                    dfs(i, j, root, word)\\n        \\n        return list(set(self.res))\\n\\n```"
                    },
                    {
                        "username": "sianliu1997",
                        "content": "\\nIn PyCharm, my code works fine, but when I submit it to LeetCode, an extra \\'oa\\' is added to the output. Why is this happening?\\n\\n```py\\nclass Solution:\\n    def findWords(self, board, words):\\n        m, n = len(board), len(board[0])\\n\\n        def dfs(board, i, j, word, k=0):\\n            b = copy.deepcopy(board)\\n            if k == len(word):\\n                return True\\n            if not 0 <= i < m or not 0 <= j < n or b[i][j] == \\'#\\' or b[i][j] != word[k]:\\n                return False\\n            b[i][j] = \\'#\\'\\n            return dfs(b, i + 1, j, word, k + 1) or \\\\\\n                   dfs(b, i - 1, j, word, k + 1) or \\\\\\n                   dfs(b, i, j + 1, word, k + 1) or \\\\\\n                   dfs(b, i, j - 1, word, k + 1)\\n\\n        res = []\\n        for i in range(m):\\n            for j in range(n):\\n                for w in words:\\n                    if board[i][j] == w[0] and dfs(board, i, j, w):\\n                        res.append(w)\\n        return res\\n```"
                    },
                    {
                        "username": "cagils",
                        "content": "Tips for general algorithm structure using Trie, Backtracing, and DFS with JS:\\n\\n```js\\nvar findWords = function (board, words) {\\n    const contains = []\\n    const trie = {} // A simple object is enough for a simple trie here\\n\\n    buildTrie()\\n\\n    *** HERE CALL DFS() ON EACH CELL ***\\n\\n    return contains\\n\\n    function buildTrie() {\\n        *** HERE BUILD TRIE FOR WORDS IN WORDS LIST ***\\n    }\\n\\n    function dfs(i, j, node, word) {\\n        *** HERE RECURSIVE DFS ON EACH DIRECTION ***\\n        *** IF WORD FINISHES ADD TO CONTAINS ***\\n        *** STORE CURRENT CHAR ON TEMP AND CHANGE IT TO INVALID CHARACTER ***\\n        *** AFTER DFS CALLS RESTORE THE CHARACTER (BACKTRACING) ***\\n    }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 2028010,
                "content": [
                    {
                        "username": "scott",
                        "content": "my submitted code  was using pure back track and passed OJ \\n\\nI cannot see any need of using trie for the problem"
                    },
                    {
                        "username": "omkashyap007",
                        "content": "Anyone please help . Why this is not working . I made a simple dfs solution with backtracking . It seems to work with 58 test cases but fails at 59 .\\n\\nthis is board : [[\"a\",\"b\",\"c\"],[\"a\",\"e\",\"d\"],[\"a\",\"f\",\"g\"]]\\nwords : [\"abcdefg\",\"gfedcbaaa\",\"eaabcdgfa\",\"befa\",\"dgc\",\"ade\"]\\noutput : [\"gfedcbaaa\",\"abcdefg\",\"befa\"]\\nexpected : [\"abcdefg\",\"befa\",\"eaabcdgfa\",\"gfedcbaaa\"]\\n\\nwhat is wrong with the code : \\ncode : \\n ```\\nclass Solution:\\n\\n    def inside(self , i , j , grid):\\n        if i>= 0 and i < len(grid) and j>=0 and j < len(grid[0]) :\\n            return True\\n        return False\\n\\n    def dfs(self , i , j , index , word , grid , visited):\\n        if index >= len(word) : \\n            return True\\n        elif self.inside(i , j , grid) and not visited[i][j] and word[index] == grid[i][j] : \\n            found = False\\n            visited[i][j] = True\\n            found = any(\\n                [\\n                    self.dfs(i+1 , j , index+1 , word , grid , visited) ,\\n                    self.dfs(i-1 , j , index+1 , word , grid , visited) ,\\n                    self.dfs(i , j+1 , index+1 , word , grid , visited) ,\\n                    self.dfs(i , j-1 , index+1 , word , grid , visited) ,\\n                ]\\n            )\\n            visited = False\\n            return found\\n        else :\\n            return False\\n\\n    def findWords(self, grid: List[List[str]], words: List[str]) -> List[str]:\\n        wordMap = {}\\n        for word in words : \\n            char = word[0]\\n            wordMap[char] = wordMap.get(char , []) + [word]\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        answer = set()\\n        for i in range(rows) :\\n            for j in range(cols) :\\n                start_char = grid[i][j]\\n                if start_char not in wordMap :\\n                    continue\\n                wordList = wordMap[start_char]\\n                for word in wordList : \\n                    visited = [[False for _ in range(cols)] for _ in range(rows)]\\n                    if self.dfs(i , j , 0 , word , grid , visited) :\\n                        answer.add(word)\\n        return answer\\n```"
                    },
                    {
                        "username": "deadpool1205",
                        "content": "- You have set visited = False, it should be visited[i][j] = False \\n- While returning answer as list(answer) for convert set to list for the final result"
                    },
                    {
                        "username": "deadpool1205",
                        "content": "There should not be any duplicate words in answer keep that in mind for avoiding wrong submissions  :)"
                    },
                    {
                        "username": "user2075nF",
                        "content": "is the only way to pass last few test cases is to use prefix tree? or is there any other magic available?"
                    },
                    {
                        "username": "Jagadish_Shankar",
                        "content": "class Solution {\\n\\n    public boolean recursive_function(int i , int j , int rows , int columns , char[][] board , boolean[][] visited_cells , int index , String word , int word_length) {\\n\\n        if(index == word_length){\\n            return true;\\n        }\\n\\n        visited_cells[i][j] = true;\\n\\n        boolean top = (((i - 1) >= 0) && (word.charAt(index) == board[(i - 1)][j]) && (!visited_cells[(i - 1)][j]) && (recursive_function((i - 1) , j , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean bottom = (((i + 1) < rows) && (word.charAt(index) == board[(i + 1)][j]) && (!visited_cells[(i + 1)][j]) && (recursive_function((i + 1) , j , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean left = (((j - 1) >= 0) && (word.charAt(index) == board[i][(j - 1)]) && (!visited_cells[i][(j - 1)]) && (recursive_function(i , (j - 1) , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean right = (((j + 1) < columns) && (word.charAt(index) == board[i][(j + 1)]) && (!visited_cells[i][(j + 1)]) && (recursive_function(i , (j + 1) , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        visited_cells[i][j] = false;\\n\\n        return (top || bottom || left || right);\\n    }\\n\\n    public List<String> findWords(char[][] board , String[] words) {\\n\\n        int rows = board.length;\\n        \\n        int columns = board[0].length;\\n\\n        Set<String> all_words_in_board = new HashSet<String>();\\n        \\n        for(String word : (new HashSet<String>(Arrays.asList(words)))){\\n\\n            boolean word_found_flag = false;\\n            \\n            for (int i=0 ; (i < rows) ; i++) {\\n                \\n                for (int j=0 ; (j < columns) ; j++) {\\n                    \\n                    if((board[i][j] == word.charAt(0)) && (recursive_function(i , j , rows , columns , board , (new boolean[rows][columns]) , 1 , word , (word.length())))){\\n                        all_words_in_board.add(word);\\n                        word_found_flag = true;\\n                        break;\\n                    }\\n                }\\n\\n                if(word_found_flag){\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return (new ArrayList<String>(all_words_in_board));\\n    }\\n}\\n\\ncan somebody help me to optimize my program since it\\'s failing the last 3 test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "can some one tell why this code is not giving output \\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "arushi-08",
                        "content": "I have spent a lot of time trying to debug this solution, but I am still facing TLE error while submitting code (while the testcase itself gets accepted). Please suggest an optimization:\\n\\nPython:\\n```\\nclass Node:\\n    def __init__(self):\\n        self.children = {}\\n        self.endofword = False\\n\\n    def addWord(self, word):\\n        curr = self\\n        for c in word:\\n            if c not in curr.children:\\n                curr.children[c] = Node()\\n            curr = curr.children[c]\\n        curr.endofword = True\\n\\nclass Solution:\\n\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        root = Node()\\n        for w in words:\\n            root.addWord(w)\\n        \\n        self.res = []\\n        word = \\'\\'\\n        visited = set()\\n        rows = len(board)\\n        cols = len(board[0])\\n\\n        def dfs(x, y, node, word):\\n            if (x,y) in visited or board[x][y] not in node.children:\\n                return\\n            \\n            visited.add((x,y))\\n            node = node.children[board[x][y]]\\n            word += board[x][y]\\n            \\n            if node.endofword:\\n                self.res.append(word)\\n\\n            rrows = [-1, 0, 1, 0]\\n            ccols = [0, 1, 0, -1]\\n            for r,c in zip(rrows, ccols):\\n                if x+r >= 0 and y+c >= 0 and x+r < rows and y+c < cols:\\n                    dfs(x+r, y+c, node, word)\\n\\n            visited.remove((x,y))\\n        \\n        for i in range(rows):\\n            for j in range(cols):\\n                if board[i][j] in root.children:\\n                    dfs(i, j, root, word)\\n        \\n        return list(set(self.res))\\n\\n```"
                    },
                    {
                        "username": "sianliu1997",
                        "content": "\\nIn PyCharm, my code works fine, but when I submit it to LeetCode, an extra \\'oa\\' is added to the output. Why is this happening?\\n\\n```py\\nclass Solution:\\n    def findWords(self, board, words):\\n        m, n = len(board), len(board[0])\\n\\n        def dfs(board, i, j, word, k=0):\\n            b = copy.deepcopy(board)\\n            if k == len(word):\\n                return True\\n            if not 0 <= i < m or not 0 <= j < n or b[i][j] == \\'#\\' or b[i][j] != word[k]:\\n                return False\\n            b[i][j] = \\'#\\'\\n            return dfs(b, i + 1, j, word, k + 1) or \\\\\\n                   dfs(b, i - 1, j, word, k + 1) or \\\\\\n                   dfs(b, i, j + 1, word, k + 1) or \\\\\\n                   dfs(b, i, j - 1, word, k + 1)\\n\\n        res = []\\n        for i in range(m):\\n            for j in range(n):\\n                for w in words:\\n                    if board[i][j] == w[0] and dfs(board, i, j, w):\\n                        res.append(w)\\n        return res\\n```"
                    },
                    {
                        "username": "cagils",
                        "content": "Tips for general algorithm structure using Trie, Backtracing, and DFS with JS:\\n\\n```js\\nvar findWords = function (board, words) {\\n    const contains = []\\n    const trie = {} // A simple object is enough for a simple trie here\\n\\n    buildTrie()\\n\\n    *** HERE CALL DFS() ON EACH CELL ***\\n\\n    return contains\\n\\n    function buildTrie() {\\n        *** HERE BUILD TRIE FOR WORDS IN WORDS LIST ***\\n    }\\n\\n    function dfs(i, j, node, word) {\\n        *** HERE RECURSIVE DFS ON EACH DIRECTION ***\\n        *** IF WORD FINISHES ADD TO CONTAINS ***\\n        *** STORE CURRENT CHAR ON TEMP AND CHANGE IT TO INVALID CHARACTER ***\\n        *** AFTER DFS CALLS RESTORE THE CHARACTER (BACKTRACING) ***\\n    }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 2010884,
                "content": [
                    {
                        "username": "scott",
                        "content": "my submitted code  was using pure back track and passed OJ \\n\\nI cannot see any need of using trie for the problem"
                    },
                    {
                        "username": "omkashyap007",
                        "content": "Anyone please help . Why this is not working . I made a simple dfs solution with backtracking . It seems to work with 58 test cases but fails at 59 .\\n\\nthis is board : [[\"a\",\"b\",\"c\"],[\"a\",\"e\",\"d\"],[\"a\",\"f\",\"g\"]]\\nwords : [\"abcdefg\",\"gfedcbaaa\",\"eaabcdgfa\",\"befa\",\"dgc\",\"ade\"]\\noutput : [\"gfedcbaaa\",\"abcdefg\",\"befa\"]\\nexpected : [\"abcdefg\",\"befa\",\"eaabcdgfa\",\"gfedcbaaa\"]\\n\\nwhat is wrong with the code : \\ncode : \\n ```\\nclass Solution:\\n\\n    def inside(self , i , j , grid):\\n        if i>= 0 and i < len(grid) and j>=0 and j < len(grid[0]) :\\n            return True\\n        return False\\n\\n    def dfs(self , i , j , index , word , grid , visited):\\n        if index >= len(word) : \\n            return True\\n        elif self.inside(i , j , grid) and not visited[i][j] and word[index] == grid[i][j] : \\n            found = False\\n            visited[i][j] = True\\n            found = any(\\n                [\\n                    self.dfs(i+1 , j , index+1 , word , grid , visited) ,\\n                    self.dfs(i-1 , j , index+1 , word , grid , visited) ,\\n                    self.dfs(i , j+1 , index+1 , word , grid , visited) ,\\n                    self.dfs(i , j-1 , index+1 , word , grid , visited) ,\\n                ]\\n            )\\n            visited = False\\n            return found\\n        else :\\n            return False\\n\\n    def findWords(self, grid: List[List[str]], words: List[str]) -> List[str]:\\n        wordMap = {}\\n        for word in words : \\n            char = word[0]\\n            wordMap[char] = wordMap.get(char , []) + [word]\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        answer = set()\\n        for i in range(rows) :\\n            for j in range(cols) :\\n                start_char = grid[i][j]\\n                if start_char not in wordMap :\\n                    continue\\n                wordList = wordMap[start_char]\\n                for word in wordList : \\n                    visited = [[False for _ in range(cols)] for _ in range(rows)]\\n                    if self.dfs(i , j , 0 , word , grid , visited) :\\n                        answer.add(word)\\n        return answer\\n```"
                    },
                    {
                        "username": "deadpool1205",
                        "content": "- You have set visited = False, it should be visited[i][j] = False \\n- While returning answer as list(answer) for convert set to list for the final result"
                    },
                    {
                        "username": "deadpool1205",
                        "content": "There should not be any duplicate words in answer keep that in mind for avoiding wrong submissions  :)"
                    },
                    {
                        "username": "user2075nF",
                        "content": "is the only way to pass last few test cases is to use prefix tree? or is there any other magic available?"
                    },
                    {
                        "username": "Jagadish_Shankar",
                        "content": "class Solution {\\n\\n    public boolean recursive_function(int i , int j , int rows , int columns , char[][] board , boolean[][] visited_cells , int index , String word , int word_length) {\\n\\n        if(index == word_length){\\n            return true;\\n        }\\n\\n        visited_cells[i][j] = true;\\n\\n        boolean top = (((i - 1) >= 0) && (word.charAt(index) == board[(i - 1)][j]) && (!visited_cells[(i - 1)][j]) && (recursive_function((i - 1) , j , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean bottom = (((i + 1) < rows) && (word.charAt(index) == board[(i + 1)][j]) && (!visited_cells[(i + 1)][j]) && (recursive_function((i + 1) , j , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean left = (((j - 1) >= 0) && (word.charAt(index) == board[i][(j - 1)]) && (!visited_cells[i][(j - 1)]) && (recursive_function(i , (j - 1) , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean right = (((j + 1) < columns) && (word.charAt(index) == board[i][(j + 1)]) && (!visited_cells[i][(j + 1)]) && (recursive_function(i , (j + 1) , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        visited_cells[i][j] = false;\\n\\n        return (top || bottom || left || right);\\n    }\\n\\n    public List<String> findWords(char[][] board , String[] words) {\\n\\n        int rows = board.length;\\n        \\n        int columns = board[0].length;\\n\\n        Set<String> all_words_in_board = new HashSet<String>();\\n        \\n        for(String word : (new HashSet<String>(Arrays.asList(words)))){\\n\\n            boolean word_found_flag = false;\\n            \\n            for (int i=0 ; (i < rows) ; i++) {\\n                \\n                for (int j=0 ; (j < columns) ; j++) {\\n                    \\n                    if((board[i][j] == word.charAt(0)) && (recursive_function(i , j , rows , columns , board , (new boolean[rows][columns]) , 1 , word , (word.length())))){\\n                        all_words_in_board.add(word);\\n                        word_found_flag = true;\\n                        break;\\n                    }\\n                }\\n\\n                if(word_found_flag){\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return (new ArrayList<String>(all_words_in_board));\\n    }\\n}\\n\\ncan somebody help me to optimize my program since it\\'s failing the last 3 test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "can some one tell why this code is not giving output \\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "arushi-08",
                        "content": "I have spent a lot of time trying to debug this solution, but I am still facing TLE error while submitting code (while the testcase itself gets accepted). Please suggest an optimization:\\n\\nPython:\\n```\\nclass Node:\\n    def __init__(self):\\n        self.children = {}\\n        self.endofword = False\\n\\n    def addWord(self, word):\\n        curr = self\\n        for c in word:\\n            if c not in curr.children:\\n                curr.children[c] = Node()\\n            curr = curr.children[c]\\n        curr.endofword = True\\n\\nclass Solution:\\n\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        root = Node()\\n        for w in words:\\n            root.addWord(w)\\n        \\n        self.res = []\\n        word = \\'\\'\\n        visited = set()\\n        rows = len(board)\\n        cols = len(board[0])\\n\\n        def dfs(x, y, node, word):\\n            if (x,y) in visited or board[x][y] not in node.children:\\n                return\\n            \\n            visited.add((x,y))\\n            node = node.children[board[x][y]]\\n            word += board[x][y]\\n            \\n            if node.endofword:\\n                self.res.append(word)\\n\\n            rrows = [-1, 0, 1, 0]\\n            ccols = [0, 1, 0, -1]\\n            for r,c in zip(rrows, ccols):\\n                if x+r >= 0 and y+c >= 0 and x+r < rows and y+c < cols:\\n                    dfs(x+r, y+c, node, word)\\n\\n            visited.remove((x,y))\\n        \\n        for i in range(rows):\\n            for j in range(cols):\\n                if board[i][j] in root.children:\\n                    dfs(i, j, root, word)\\n        \\n        return list(set(self.res))\\n\\n```"
                    },
                    {
                        "username": "sianliu1997",
                        "content": "\\nIn PyCharm, my code works fine, but when I submit it to LeetCode, an extra \\'oa\\' is added to the output. Why is this happening?\\n\\n```py\\nclass Solution:\\n    def findWords(self, board, words):\\n        m, n = len(board), len(board[0])\\n\\n        def dfs(board, i, j, word, k=0):\\n            b = copy.deepcopy(board)\\n            if k == len(word):\\n                return True\\n            if not 0 <= i < m or not 0 <= j < n or b[i][j] == \\'#\\' or b[i][j] != word[k]:\\n                return False\\n            b[i][j] = \\'#\\'\\n            return dfs(b, i + 1, j, word, k + 1) or \\\\\\n                   dfs(b, i - 1, j, word, k + 1) or \\\\\\n                   dfs(b, i, j + 1, word, k + 1) or \\\\\\n                   dfs(b, i, j - 1, word, k + 1)\\n\\n        res = []\\n        for i in range(m):\\n            for j in range(n):\\n                for w in words:\\n                    if board[i][j] == w[0] and dfs(board, i, j, w):\\n                        res.append(w)\\n        return res\\n```"
                    },
                    {
                        "username": "cagils",
                        "content": "Tips for general algorithm structure using Trie, Backtracing, and DFS with JS:\\n\\n```js\\nvar findWords = function (board, words) {\\n    const contains = []\\n    const trie = {} // A simple object is enough for a simple trie here\\n\\n    buildTrie()\\n\\n    *** HERE CALL DFS() ON EACH CELL ***\\n\\n    return contains\\n\\n    function buildTrie() {\\n        *** HERE BUILD TRIE FOR WORDS IN WORDS LIST ***\\n    }\\n\\n    function dfs(i, j, node, word) {\\n        *** HERE RECURSIVE DFS ON EACH DIRECTION ***\\n        *** IF WORD FINISHES ADD TO CONTAINS ***\\n        *** STORE CURRENT CHAR ON TEMP AND CHANGE IT TO INVALID CHARACTER ***\\n        *** AFTER DFS CALLS RESTORE THE CHARACTER (BACKTRACING) ***\\n    }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1962211,
                "content": [
                    {
                        "username": "scott",
                        "content": "my submitted code  was using pure back track and passed OJ \\n\\nI cannot see any need of using trie for the problem"
                    },
                    {
                        "username": "omkashyap007",
                        "content": "Anyone please help . Why this is not working . I made a simple dfs solution with backtracking . It seems to work with 58 test cases but fails at 59 .\\n\\nthis is board : [[\"a\",\"b\",\"c\"],[\"a\",\"e\",\"d\"],[\"a\",\"f\",\"g\"]]\\nwords : [\"abcdefg\",\"gfedcbaaa\",\"eaabcdgfa\",\"befa\",\"dgc\",\"ade\"]\\noutput : [\"gfedcbaaa\",\"abcdefg\",\"befa\"]\\nexpected : [\"abcdefg\",\"befa\",\"eaabcdgfa\",\"gfedcbaaa\"]\\n\\nwhat is wrong with the code : \\ncode : \\n ```\\nclass Solution:\\n\\n    def inside(self , i , j , grid):\\n        if i>= 0 and i < len(grid) and j>=0 and j < len(grid[0]) :\\n            return True\\n        return False\\n\\n    def dfs(self , i , j , index , word , grid , visited):\\n        if index >= len(word) : \\n            return True\\n        elif self.inside(i , j , grid) and not visited[i][j] and word[index] == grid[i][j] : \\n            found = False\\n            visited[i][j] = True\\n            found = any(\\n                [\\n                    self.dfs(i+1 , j , index+1 , word , grid , visited) ,\\n                    self.dfs(i-1 , j , index+1 , word , grid , visited) ,\\n                    self.dfs(i , j+1 , index+1 , word , grid , visited) ,\\n                    self.dfs(i , j-1 , index+1 , word , grid , visited) ,\\n                ]\\n            )\\n            visited = False\\n            return found\\n        else :\\n            return False\\n\\n    def findWords(self, grid: List[List[str]], words: List[str]) -> List[str]:\\n        wordMap = {}\\n        for word in words : \\n            char = word[0]\\n            wordMap[char] = wordMap.get(char , []) + [word]\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        answer = set()\\n        for i in range(rows) :\\n            for j in range(cols) :\\n                start_char = grid[i][j]\\n                if start_char not in wordMap :\\n                    continue\\n                wordList = wordMap[start_char]\\n                for word in wordList : \\n                    visited = [[False for _ in range(cols)] for _ in range(rows)]\\n                    if self.dfs(i , j , 0 , word , grid , visited) :\\n                        answer.add(word)\\n        return answer\\n```"
                    },
                    {
                        "username": "deadpool1205",
                        "content": "- You have set visited = False, it should be visited[i][j] = False \\n- While returning answer as list(answer) for convert set to list for the final result"
                    },
                    {
                        "username": "deadpool1205",
                        "content": "There should not be any duplicate words in answer keep that in mind for avoiding wrong submissions  :)"
                    },
                    {
                        "username": "user2075nF",
                        "content": "is the only way to pass last few test cases is to use prefix tree? or is there any other magic available?"
                    },
                    {
                        "username": "Jagadish_Shankar",
                        "content": "class Solution {\\n\\n    public boolean recursive_function(int i , int j , int rows , int columns , char[][] board , boolean[][] visited_cells , int index , String word , int word_length) {\\n\\n        if(index == word_length){\\n            return true;\\n        }\\n\\n        visited_cells[i][j] = true;\\n\\n        boolean top = (((i - 1) >= 0) && (word.charAt(index) == board[(i - 1)][j]) && (!visited_cells[(i - 1)][j]) && (recursive_function((i - 1) , j , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean bottom = (((i + 1) < rows) && (word.charAt(index) == board[(i + 1)][j]) && (!visited_cells[(i + 1)][j]) && (recursive_function((i + 1) , j , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean left = (((j - 1) >= 0) && (word.charAt(index) == board[i][(j - 1)]) && (!visited_cells[i][(j - 1)]) && (recursive_function(i , (j - 1) , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean right = (((j + 1) < columns) && (word.charAt(index) == board[i][(j + 1)]) && (!visited_cells[i][(j + 1)]) && (recursive_function(i , (j + 1) , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        visited_cells[i][j] = false;\\n\\n        return (top || bottom || left || right);\\n    }\\n\\n    public List<String> findWords(char[][] board , String[] words) {\\n\\n        int rows = board.length;\\n        \\n        int columns = board[0].length;\\n\\n        Set<String> all_words_in_board = new HashSet<String>();\\n        \\n        for(String word : (new HashSet<String>(Arrays.asList(words)))){\\n\\n            boolean word_found_flag = false;\\n            \\n            for (int i=0 ; (i < rows) ; i++) {\\n                \\n                for (int j=0 ; (j < columns) ; j++) {\\n                    \\n                    if((board[i][j] == word.charAt(0)) && (recursive_function(i , j , rows , columns , board , (new boolean[rows][columns]) , 1 , word , (word.length())))){\\n                        all_words_in_board.add(word);\\n                        word_found_flag = true;\\n                        break;\\n                    }\\n                }\\n\\n                if(word_found_flag){\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return (new ArrayList<String>(all_words_in_board));\\n    }\\n}\\n\\ncan somebody help me to optimize my program since it\\'s failing the last 3 test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "can some one tell why this code is not giving output \\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "arushi-08",
                        "content": "I have spent a lot of time trying to debug this solution, but I am still facing TLE error while submitting code (while the testcase itself gets accepted). Please suggest an optimization:\\n\\nPython:\\n```\\nclass Node:\\n    def __init__(self):\\n        self.children = {}\\n        self.endofword = False\\n\\n    def addWord(self, word):\\n        curr = self\\n        for c in word:\\n            if c not in curr.children:\\n                curr.children[c] = Node()\\n            curr = curr.children[c]\\n        curr.endofword = True\\n\\nclass Solution:\\n\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        root = Node()\\n        for w in words:\\n            root.addWord(w)\\n        \\n        self.res = []\\n        word = \\'\\'\\n        visited = set()\\n        rows = len(board)\\n        cols = len(board[0])\\n\\n        def dfs(x, y, node, word):\\n            if (x,y) in visited or board[x][y] not in node.children:\\n                return\\n            \\n            visited.add((x,y))\\n            node = node.children[board[x][y]]\\n            word += board[x][y]\\n            \\n            if node.endofword:\\n                self.res.append(word)\\n\\n            rrows = [-1, 0, 1, 0]\\n            ccols = [0, 1, 0, -1]\\n            for r,c in zip(rrows, ccols):\\n                if x+r >= 0 and y+c >= 0 and x+r < rows and y+c < cols:\\n                    dfs(x+r, y+c, node, word)\\n\\n            visited.remove((x,y))\\n        \\n        for i in range(rows):\\n            for j in range(cols):\\n                if board[i][j] in root.children:\\n                    dfs(i, j, root, word)\\n        \\n        return list(set(self.res))\\n\\n```"
                    },
                    {
                        "username": "sianliu1997",
                        "content": "\\nIn PyCharm, my code works fine, but when I submit it to LeetCode, an extra \\'oa\\' is added to the output. Why is this happening?\\n\\n```py\\nclass Solution:\\n    def findWords(self, board, words):\\n        m, n = len(board), len(board[0])\\n\\n        def dfs(board, i, j, word, k=0):\\n            b = copy.deepcopy(board)\\n            if k == len(word):\\n                return True\\n            if not 0 <= i < m or not 0 <= j < n or b[i][j] == \\'#\\' or b[i][j] != word[k]:\\n                return False\\n            b[i][j] = \\'#\\'\\n            return dfs(b, i + 1, j, word, k + 1) or \\\\\\n                   dfs(b, i - 1, j, word, k + 1) or \\\\\\n                   dfs(b, i, j + 1, word, k + 1) or \\\\\\n                   dfs(b, i, j - 1, word, k + 1)\\n\\n        res = []\\n        for i in range(m):\\n            for j in range(n):\\n                for w in words:\\n                    if board[i][j] == w[0] and dfs(board, i, j, w):\\n                        res.append(w)\\n        return res\\n```"
                    },
                    {
                        "username": "cagils",
                        "content": "Tips for general algorithm structure using Trie, Backtracing, and DFS with JS:\\n\\n```js\\nvar findWords = function (board, words) {\\n    const contains = []\\n    const trie = {} // A simple object is enough for a simple trie here\\n\\n    buildTrie()\\n\\n    *** HERE CALL DFS() ON EACH CELL ***\\n\\n    return contains\\n\\n    function buildTrie() {\\n        *** HERE BUILD TRIE FOR WORDS IN WORDS LIST ***\\n    }\\n\\n    function dfs(i, j, node, word) {\\n        *** HERE RECURSIVE DFS ON EACH DIRECTION ***\\n        *** IF WORD FINISHES ADD TO CONTAINS ***\\n        *** STORE CURRENT CHAR ON TEMP AND CHANGE IT TO INVALID CHARACTER ***\\n        *** AFTER DFS CALLS RESTORE THE CHARACTER (BACKTRACING) ***\\n    }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1944125,
                "content": [
                    {
                        "username": "scott",
                        "content": "my submitted code  was using pure back track and passed OJ \\n\\nI cannot see any need of using trie for the problem"
                    },
                    {
                        "username": "omkashyap007",
                        "content": "Anyone please help . Why this is not working . I made a simple dfs solution with backtracking . It seems to work with 58 test cases but fails at 59 .\\n\\nthis is board : [[\"a\",\"b\",\"c\"],[\"a\",\"e\",\"d\"],[\"a\",\"f\",\"g\"]]\\nwords : [\"abcdefg\",\"gfedcbaaa\",\"eaabcdgfa\",\"befa\",\"dgc\",\"ade\"]\\noutput : [\"gfedcbaaa\",\"abcdefg\",\"befa\"]\\nexpected : [\"abcdefg\",\"befa\",\"eaabcdgfa\",\"gfedcbaaa\"]\\n\\nwhat is wrong with the code : \\ncode : \\n ```\\nclass Solution:\\n\\n    def inside(self , i , j , grid):\\n        if i>= 0 and i < len(grid) and j>=0 and j < len(grid[0]) :\\n            return True\\n        return False\\n\\n    def dfs(self , i , j , index , word , grid , visited):\\n        if index >= len(word) : \\n            return True\\n        elif self.inside(i , j , grid) and not visited[i][j] and word[index] == grid[i][j] : \\n            found = False\\n            visited[i][j] = True\\n            found = any(\\n                [\\n                    self.dfs(i+1 , j , index+1 , word , grid , visited) ,\\n                    self.dfs(i-1 , j , index+1 , word , grid , visited) ,\\n                    self.dfs(i , j+1 , index+1 , word , grid , visited) ,\\n                    self.dfs(i , j-1 , index+1 , word , grid , visited) ,\\n                ]\\n            )\\n            visited = False\\n            return found\\n        else :\\n            return False\\n\\n    def findWords(self, grid: List[List[str]], words: List[str]) -> List[str]:\\n        wordMap = {}\\n        for word in words : \\n            char = word[0]\\n            wordMap[char] = wordMap.get(char , []) + [word]\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        answer = set()\\n        for i in range(rows) :\\n            for j in range(cols) :\\n                start_char = grid[i][j]\\n                if start_char not in wordMap :\\n                    continue\\n                wordList = wordMap[start_char]\\n                for word in wordList : \\n                    visited = [[False for _ in range(cols)] for _ in range(rows)]\\n                    if self.dfs(i , j , 0 , word , grid , visited) :\\n                        answer.add(word)\\n        return answer\\n```"
                    },
                    {
                        "username": "deadpool1205",
                        "content": "- You have set visited = False, it should be visited[i][j] = False \\n- While returning answer as list(answer) for convert set to list for the final result"
                    },
                    {
                        "username": "deadpool1205",
                        "content": "There should not be any duplicate words in answer keep that in mind for avoiding wrong submissions  :)"
                    },
                    {
                        "username": "user2075nF",
                        "content": "is the only way to pass last few test cases is to use prefix tree? or is there any other magic available?"
                    },
                    {
                        "username": "Jagadish_Shankar",
                        "content": "class Solution {\\n\\n    public boolean recursive_function(int i , int j , int rows , int columns , char[][] board , boolean[][] visited_cells , int index , String word , int word_length) {\\n\\n        if(index == word_length){\\n            return true;\\n        }\\n\\n        visited_cells[i][j] = true;\\n\\n        boolean top = (((i - 1) >= 0) && (word.charAt(index) == board[(i - 1)][j]) && (!visited_cells[(i - 1)][j]) && (recursive_function((i - 1) , j , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean bottom = (((i + 1) < rows) && (word.charAt(index) == board[(i + 1)][j]) && (!visited_cells[(i + 1)][j]) && (recursive_function((i + 1) , j , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean left = (((j - 1) >= 0) && (word.charAt(index) == board[i][(j - 1)]) && (!visited_cells[i][(j - 1)]) && (recursive_function(i , (j - 1) , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean right = (((j + 1) < columns) && (word.charAt(index) == board[i][(j + 1)]) && (!visited_cells[i][(j + 1)]) && (recursive_function(i , (j + 1) , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        visited_cells[i][j] = false;\\n\\n        return (top || bottom || left || right);\\n    }\\n\\n    public List<String> findWords(char[][] board , String[] words) {\\n\\n        int rows = board.length;\\n        \\n        int columns = board[0].length;\\n\\n        Set<String> all_words_in_board = new HashSet<String>();\\n        \\n        for(String word : (new HashSet<String>(Arrays.asList(words)))){\\n\\n            boolean word_found_flag = false;\\n            \\n            for (int i=0 ; (i < rows) ; i++) {\\n                \\n                for (int j=0 ; (j < columns) ; j++) {\\n                    \\n                    if((board[i][j] == word.charAt(0)) && (recursive_function(i , j , rows , columns , board , (new boolean[rows][columns]) , 1 , word , (word.length())))){\\n                        all_words_in_board.add(word);\\n                        word_found_flag = true;\\n                        break;\\n                    }\\n                }\\n\\n                if(word_found_flag){\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return (new ArrayList<String>(all_words_in_board));\\n    }\\n}\\n\\ncan somebody help me to optimize my program since it\\'s failing the last 3 test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "can some one tell why this code is not giving output \\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "arushi-08",
                        "content": "I have spent a lot of time trying to debug this solution, but I am still facing TLE error while submitting code (while the testcase itself gets accepted). Please suggest an optimization:\\n\\nPython:\\n```\\nclass Node:\\n    def __init__(self):\\n        self.children = {}\\n        self.endofword = False\\n\\n    def addWord(self, word):\\n        curr = self\\n        for c in word:\\n            if c not in curr.children:\\n                curr.children[c] = Node()\\n            curr = curr.children[c]\\n        curr.endofword = True\\n\\nclass Solution:\\n\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        root = Node()\\n        for w in words:\\n            root.addWord(w)\\n        \\n        self.res = []\\n        word = \\'\\'\\n        visited = set()\\n        rows = len(board)\\n        cols = len(board[0])\\n\\n        def dfs(x, y, node, word):\\n            if (x,y) in visited or board[x][y] not in node.children:\\n                return\\n            \\n            visited.add((x,y))\\n            node = node.children[board[x][y]]\\n            word += board[x][y]\\n            \\n            if node.endofword:\\n                self.res.append(word)\\n\\n            rrows = [-1, 0, 1, 0]\\n            ccols = [0, 1, 0, -1]\\n            for r,c in zip(rrows, ccols):\\n                if x+r >= 0 and y+c >= 0 and x+r < rows and y+c < cols:\\n                    dfs(x+r, y+c, node, word)\\n\\n            visited.remove((x,y))\\n        \\n        for i in range(rows):\\n            for j in range(cols):\\n                if board[i][j] in root.children:\\n                    dfs(i, j, root, word)\\n        \\n        return list(set(self.res))\\n\\n```"
                    },
                    {
                        "username": "sianliu1997",
                        "content": "\\nIn PyCharm, my code works fine, but when I submit it to LeetCode, an extra \\'oa\\' is added to the output. Why is this happening?\\n\\n```py\\nclass Solution:\\n    def findWords(self, board, words):\\n        m, n = len(board), len(board[0])\\n\\n        def dfs(board, i, j, word, k=0):\\n            b = copy.deepcopy(board)\\n            if k == len(word):\\n                return True\\n            if not 0 <= i < m or not 0 <= j < n or b[i][j] == \\'#\\' or b[i][j] != word[k]:\\n                return False\\n            b[i][j] = \\'#\\'\\n            return dfs(b, i + 1, j, word, k + 1) or \\\\\\n                   dfs(b, i - 1, j, word, k + 1) or \\\\\\n                   dfs(b, i, j + 1, word, k + 1) or \\\\\\n                   dfs(b, i, j - 1, word, k + 1)\\n\\n        res = []\\n        for i in range(m):\\n            for j in range(n):\\n                for w in words:\\n                    if board[i][j] == w[0] and dfs(board, i, j, w):\\n                        res.append(w)\\n        return res\\n```"
                    },
                    {
                        "username": "cagils",
                        "content": "Tips for general algorithm structure using Trie, Backtracing, and DFS with JS:\\n\\n```js\\nvar findWords = function (board, words) {\\n    const contains = []\\n    const trie = {} // A simple object is enough for a simple trie here\\n\\n    buildTrie()\\n\\n    *** HERE CALL DFS() ON EACH CELL ***\\n\\n    return contains\\n\\n    function buildTrie() {\\n        *** HERE BUILD TRIE FOR WORDS IN WORDS LIST ***\\n    }\\n\\n    function dfs(i, j, node, word) {\\n        *** HERE RECURSIVE DFS ON EACH DIRECTION ***\\n        *** IF WORD FINISHES ADD TO CONTAINS ***\\n        *** STORE CURRENT CHAR ON TEMP AND CHANGE IT TO INVALID CHARACTER ***\\n        *** AFTER DFS CALLS RESTORE THE CHARACTER (BACKTRACING) ***\\n    }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1933664,
                "content": [
                    {
                        "username": "scott",
                        "content": "my submitted code  was using pure back track and passed OJ \\n\\nI cannot see any need of using trie for the problem"
                    },
                    {
                        "username": "omkashyap007",
                        "content": "Anyone please help . Why this is not working . I made a simple dfs solution with backtracking . It seems to work with 58 test cases but fails at 59 .\\n\\nthis is board : [[\"a\",\"b\",\"c\"],[\"a\",\"e\",\"d\"],[\"a\",\"f\",\"g\"]]\\nwords : [\"abcdefg\",\"gfedcbaaa\",\"eaabcdgfa\",\"befa\",\"dgc\",\"ade\"]\\noutput : [\"gfedcbaaa\",\"abcdefg\",\"befa\"]\\nexpected : [\"abcdefg\",\"befa\",\"eaabcdgfa\",\"gfedcbaaa\"]\\n\\nwhat is wrong with the code : \\ncode : \\n ```\\nclass Solution:\\n\\n    def inside(self , i , j , grid):\\n        if i>= 0 and i < len(grid) and j>=0 and j < len(grid[0]) :\\n            return True\\n        return False\\n\\n    def dfs(self , i , j , index , word , grid , visited):\\n        if index >= len(word) : \\n            return True\\n        elif self.inside(i , j , grid) and not visited[i][j] and word[index] == grid[i][j] : \\n            found = False\\n            visited[i][j] = True\\n            found = any(\\n                [\\n                    self.dfs(i+1 , j , index+1 , word , grid , visited) ,\\n                    self.dfs(i-1 , j , index+1 , word , grid , visited) ,\\n                    self.dfs(i , j+1 , index+1 , word , grid , visited) ,\\n                    self.dfs(i , j-1 , index+1 , word , grid , visited) ,\\n                ]\\n            )\\n            visited = False\\n            return found\\n        else :\\n            return False\\n\\n    def findWords(self, grid: List[List[str]], words: List[str]) -> List[str]:\\n        wordMap = {}\\n        for word in words : \\n            char = word[0]\\n            wordMap[char] = wordMap.get(char , []) + [word]\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        answer = set()\\n        for i in range(rows) :\\n            for j in range(cols) :\\n                start_char = grid[i][j]\\n                if start_char not in wordMap :\\n                    continue\\n                wordList = wordMap[start_char]\\n                for word in wordList : \\n                    visited = [[False for _ in range(cols)] for _ in range(rows)]\\n                    if self.dfs(i , j , 0 , word , grid , visited) :\\n                        answer.add(word)\\n        return answer\\n```"
                    },
                    {
                        "username": "deadpool1205",
                        "content": "- You have set visited = False, it should be visited[i][j] = False \\n- While returning answer as list(answer) for convert set to list for the final result"
                    },
                    {
                        "username": "deadpool1205",
                        "content": "There should not be any duplicate words in answer keep that in mind for avoiding wrong submissions  :)"
                    },
                    {
                        "username": "user2075nF",
                        "content": "is the only way to pass last few test cases is to use prefix tree? or is there any other magic available?"
                    },
                    {
                        "username": "Jagadish_Shankar",
                        "content": "class Solution {\\n\\n    public boolean recursive_function(int i , int j , int rows , int columns , char[][] board , boolean[][] visited_cells , int index , String word , int word_length) {\\n\\n        if(index == word_length){\\n            return true;\\n        }\\n\\n        visited_cells[i][j] = true;\\n\\n        boolean top = (((i - 1) >= 0) && (word.charAt(index) == board[(i - 1)][j]) && (!visited_cells[(i - 1)][j]) && (recursive_function((i - 1) , j , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean bottom = (((i + 1) < rows) && (word.charAt(index) == board[(i + 1)][j]) && (!visited_cells[(i + 1)][j]) && (recursive_function((i + 1) , j , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean left = (((j - 1) >= 0) && (word.charAt(index) == board[i][(j - 1)]) && (!visited_cells[i][(j - 1)]) && (recursive_function(i , (j - 1) , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean right = (((j + 1) < columns) && (word.charAt(index) == board[i][(j + 1)]) && (!visited_cells[i][(j + 1)]) && (recursive_function(i , (j + 1) , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        visited_cells[i][j] = false;\\n\\n        return (top || bottom || left || right);\\n    }\\n\\n    public List<String> findWords(char[][] board , String[] words) {\\n\\n        int rows = board.length;\\n        \\n        int columns = board[0].length;\\n\\n        Set<String> all_words_in_board = new HashSet<String>();\\n        \\n        for(String word : (new HashSet<String>(Arrays.asList(words)))){\\n\\n            boolean word_found_flag = false;\\n            \\n            for (int i=0 ; (i < rows) ; i++) {\\n                \\n                for (int j=0 ; (j < columns) ; j++) {\\n                    \\n                    if((board[i][j] == word.charAt(0)) && (recursive_function(i , j , rows , columns , board , (new boolean[rows][columns]) , 1 , word , (word.length())))){\\n                        all_words_in_board.add(word);\\n                        word_found_flag = true;\\n                        break;\\n                    }\\n                }\\n\\n                if(word_found_flag){\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return (new ArrayList<String>(all_words_in_board));\\n    }\\n}\\n\\ncan somebody help me to optimize my program since it\\'s failing the last 3 test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "can some one tell why this code is not giving output \\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "arushi-08",
                        "content": "I have spent a lot of time trying to debug this solution, but I am still facing TLE error while submitting code (while the testcase itself gets accepted). Please suggest an optimization:\\n\\nPython:\\n```\\nclass Node:\\n    def __init__(self):\\n        self.children = {}\\n        self.endofword = False\\n\\n    def addWord(self, word):\\n        curr = self\\n        for c in word:\\n            if c not in curr.children:\\n                curr.children[c] = Node()\\n            curr = curr.children[c]\\n        curr.endofword = True\\n\\nclass Solution:\\n\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        root = Node()\\n        for w in words:\\n            root.addWord(w)\\n        \\n        self.res = []\\n        word = \\'\\'\\n        visited = set()\\n        rows = len(board)\\n        cols = len(board[0])\\n\\n        def dfs(x, y, node, word):\\n            if (x,y) in visited or board[x][y] not in node.children:\\n                return\\n            \\n            visited.add((x,y))\\n            node = node.children[board[x][y]]\\n            word += board[x][y]\\n            \\n            if node.endofword:\\n                self.res.append(word)\\n\\n            rrows = [-1, 0, 1, 0]\\n            ccols = [0, 1, 0, -1]\\n            for r,c in zip(rrows, ccols):\\n                if x+r >= 0 and y+c >= 0 and x+r < rows and y+c < cols:\\n                    dfs(x+r, y+c, node, word)\\n\\n            visited.remove((x,y))\\n        \\n        for i in range(rows):\\n            for j in range(cols):\\n                if board[i][j] in root.children:\\n                    dfs(i, j, root, word)\\n        \\n        return list(set(self.res))\\n\\n```"
                    },
                    {
                        "username": "sianliu1997",
                        "content": "\\nIn PyCharm, my code works fine, but when I submit it to LeetCode, an extra \\'oa\\' is added to the output. Why is this happening?\\n\\n```py\\nclass Solution:\\n    def findWords(self, board, words):\\n        m, n = len(board), len(board[0])\\n\\n        def dfs(board, i, j, word, k=0):\\n            b = copy.deepcopy(board)\\n            if k == len(word):\\n                return True\\n            if not 0 <= i < m or not 0 <= j < n or b[i][j] == \\'#\\' or b[i][j] != word[k]:\\n                return False\\n            b[i][j] = \\'#\\'\\n            return dfs(b, i + 1, j, word, k + 1) or \\\\\\n                   dfs(b, i - 1, j, word, k + 1) or \\\\\\n                   dfs(b, i, j + 1, word, k + 1) or \\\\\\n                   dfs(b, i, j - 1, word, k + 1)\\n\\n        res = []\\n        for i in range(m):\\n            for j in range(n):\\n                for w in words:\\n                    if board[i][j] == w[0] and dfs(board, i, j, w):\\n                        res.append(w)\\n        return res\\n```"
                    },
                    {
                        "username": "cagils",
                        "content": "Tips for general algorithm structure using Trie, Backtracing, and DFS with JS:\\n\\n```js\\nvar findWords = function (board, words) {\\n    const contains = []\\n    const trie = {} // A simple object is enough for a simple trie here\\n\\n    buildTrie()\\n\\n    *** HERE CALL DFS() ON EACH CELL ***\\n\\n    return contains\\n\\n    function buildTrie() {\\n        *** HERE BUILD TRIE FOR WORDS IN WORDS LIST ***\\n    }\\n\\n    function dfs(i, j, node, word) {\\n        *** HERE RECURSIVE DFS ON EACH DIRECTION ***\\n        *** IF WORD FINISHES ADD TO CONTAINS ***\\n        *** STORE CURRENT CHAR ON TEMP AND CHANGE IT TO INVALID CHARACTER ***\\n        *** AFTER DFS CALLS RESTORE THE CHARACTER (BACKTRACING) ***\\n    }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1889051,
                "content": [
                    {
                        "username": "scott",
                        "content": "my submitted code  was using pure back track and passed OJ \\n\\nI cannot see any need of using trie for the problem"
                    },
                    {
                        "username": "omkashyap007",
                        "content": "Anyone please help . Why this is not working . I made a simple dfs solution with backtracking . It seems to work with 58 test cases but fails at 59 .\\n\\nthis is board : [[\"a\",\"b\",\"c\"],[\"a\",\"e\",\"d\"],[\"a\",\"f\",\"g\"]]\\nwords : [\"abcdefg\",\"gfedcbaaa\",\"eaabcdgfa\",\"befa\",\"dgc\",\"ade\"]\\noutput : [\"gfedcbaaa\",\"abcdefg\",\"befa\"]\\nexpected : [\"abcdefg\",\"befa\",\"eaabcdgfa\",\"gfedcbaaa\"]\\n\\nwhat is wrong with the code : \\ncode : \\n ```\\nclass Solution:\\n\\n    def inside(self , i , j , grid):\\n        if i>= 0 and i < len(grid) and j>=0 and j < len(grid[0]) :\\n            return True\\n        return False\\n\\n    def dfs(self , i , j , index , word , grid , visited):\\n        if index >= len(word) : \\n            return True\\n        elif self.inside(i , j , grid) and not visited[i][j] and word[index] == grid[i][j] : \\n            found = False\\n            visited[i][j] = True\\n            found = any(\\n                [\\n                    self.dfs(i+1 , j , index+1 , word , grid , visited) ,\\n                    self.dfs(i-1 , j , index+1 , word , grid , visited) ,\\n                    self.dfs(i , j+1 , index+1 , word , grid , visited) ,\\n                    self.dfs(i , j-1 , index+1 , word , grid , visited) ,\\n                ]\\n            )\\n            visited = False\\n            return found\\n        else :\\n            return False\\n\\n    def findWords(self, grid: List[List[str]], words: List[str]) -> List[str]:\\n        wordMap = {}\\n        for word in words : \\n            char = word[0]\\n            wordMap[char] = wordMap.get(char , []) + [word]\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        answer = set()\\n        for i in range(rows) :\\n            for j in range(cols) :\\n                start_char = grid[i][j]\\n                if start_char not in wordMap :\\n                    continue\\n                wordList = wordMap[start_char]\\n                for word in wordList : \\n                    visited = [[False for _ in range(cols)] for _ in range(rows)]\\n                    if self.dfs(i , j , 0 , word , grid , visited) :\\n                        answer.add(word)\\n        return answer\\n```"
                    },
                    {
                        "username": "deadpool1205",
                        "content": "- You have set visited = False, it should be visited[i][j] = False \\n- While returning answer as list(answer) for convert set to list for the final result"
                    },
                    {
                        "username": "deadpool1205",
                        "content": "There should not be any duplicate words in answer keep that in mind for avoiding wrong submissions  :)"
                    },
                    {
                        "username": "user2075nF",
                        "content": "is the only way to pass last few test cases is to use prefix tree? or is there any other magic available?"
                    },
                    {
                        "username": "Jagadish_Shankar",
                        "content": "class Solution {\\n\\n    public boolean recursive_function(int i , int j , int rows , int columns , char[][] board , boolean[][] visited_cells , int index , String word , int word_length) {\\n\\n        if(index == word_length){\\n            return true;\\n        }\\n\\n        visited_cells[i][j] = true;\\n\\n        boolean top = (((i - 1) >= 0) && (word.charAt(index) == board[(i - 1)][j]) && (!visited_cells[(i - 1)][j]) && (recursive_function((i - 1) , j , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean bottom = (((i + 1) < rows) && (word.charAt(index) == board[(i + 1)][j]) && (!visited_cells[(i + 1)][j]) && (recursive_function((i + 1) , j , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean left = (((j - 1) >= 0) && (word.charAt(index) == board[i][(j - 1)]) && (!visited_cells[i][(j - 1)]) && (recursive_function(i , (j - 1) , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean right = (((j + 1) < columns) && (word.charAt(index) == board[i][(j + 1)]) && (!visited_cells[i][(j + 1)]) && (recursive_function(i , (j + 1) , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        visited_cells[i][j] = false;\\n\\n        return (top || bottom || left || right);\\n    }\\n\\n    public List<String> findWords(char[][] board , String[] words) {\\n\\n        int rows = board.length;\\n        \\n        int columns = board[0].length;\\n\\n        Set<String> all_words_in_board = new HashSet<String>();\\n        \\n        for(String word : (new HashSet<String>(Arrays.asList(words)))){\\n\\n            boolean word_found_flag = false;\\n            \\n            for (int i=0 ; (i < rows) ; i++) {\\n                \\n                for (int j=0 ; (j < columns) ; j++) {\\n                    \\n                    if((board[i][j] == word.charAt(0)) && (recursive_function(i , j , rows , columns , board , (new boolean[rows][columns]) , 1 , word , (word.length())))){\\n                        all_words_in_board.add(word);\\n                        word_found_flag = true;\\n                        break;\\n                    }\\n                }\\n\\n                if(word_found_flag){\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return (new ArrayList<String>(all_words_in_board));\\n    }\\n}\\n\\ncan somebody help me to optimize my program since it\\'s failing the last 3 test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "can some one tell why this code is not giving output \\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "arushi-08",
                        "content": "I have spent a lot of time trying to debug this solution, but I am still facing TLE error while submitting code (while the testcase itself gets accepted). Please suggest an optimization:\\n\\nPython:\\n```\\nclass Node:\\n    def __init__(self):\\n        self.children = {}\\n        self.endofword = False\\n\\n    def addWord(self, word):\\n        curr = self\\n        for c in word:\\n            if c not in curr.children:\\n                curr.children[c] = Node()\\n            curr = curr.children[c]\\n        curr.endofword = True\\n\\nclass Solution:\\n\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        root = Node()\\n        for w in words:\\n            root.addWord(w)\\n        \\n        self.res = []\\n        word = \\'\\'\\n        visited = set()\\n        rows = len(board)\\n        cols = len(board[0])\\n\\n        def dfs(x, y, node, word):\\n            if (x,y) in visited or board[x][y] not in node.children:\\n                return\\n            \\n            visited.add((x,y))\\n            node = node.children[board[x][y]]\\n            word += board[x][y]\\n            \\n            if node.endofword:\\n                self.res.append(word)\\n\\n            rrows = [-1, 0, 1, 0]\\n            ccols = [0, 1, 0, -1]\\n            for r,c in zip(rrows, ccols):\\n                if x+r >= 0 and y+c >= 0 and x+r < rows and y+c < cols:\\n                    dfs(x+r, y+c, node, word)\\n\\n            visited.remove((x,y))\\n        \\n        for i in range(rows):\\n            for j in range(cols):\\n                if board[i][j] in root.children:\\n                    dfs(i, j, root, word)\\n        \\n        return list(set(self.res))\\n\\n```"
                    },
                    {
                        "username": "sianliu1997",
                        "content": "\\nIn PyCharm, my code works fine, but when I submit it to LeetCode, an extra \\'oa\\' is added to the output. Why is this happening?\\n\\n```py\\nclass Solution:\\n    def findWords(self, board, words):\\n        m, n = len(board), len(board[0])\\n\\n        def dfs(board, i, j, word, k=0):\\n            b = copy.deepcopy(board)\\n            if k == len(word):\\n                return True\\n            if not 0 <= i < m or not 0 <= j < n or b[i][j] == \\'#\\' or b[i][j] != word[k]:\\n                return False\\n            b[i][j] = \\'#\\'\\n            return dfs(b, i + 1, j, word, k + 1) or \\\\\\n                   dfs(b, i - 1, j, word, k + 1) or \\\\\\n                   dfs(b, i, j + 1, word, k + 1) or \\\\\\n                   dfs(b, i, j - 1, word, k + 1)\\n\\n        res = []\\n        for i in range(m):\\n            for j in range(n):\\n                for w in words:\\n                    if board[i][j] == w[0] and dfs(board, i, j, w):\\n                        res.append(w)\\n        return res\\n```"
                    },
                    {
                        "username": "cagils",
                        "content": "Tips for general algorithm structure using Trie, Backtracing, and DFS with JS:\\n\\n```js\\nvar findWords = function (board, words) {\\n    const contains = []\\n    const trie = {} // A simple object is enough for a simple trie here\\n\\n    buildTrie()\\n\\n    *** HERE CALL DFS() ON EACH CELL ***\\n\\n    return contains\\n\\n    function buildTrie() {\\n        *** HERE BUILD TRIE FOR WORDS IN WORDS LIST ***\\n    }\\n\\n    function dfs(i, j, node, word) {\\n        *** HERE RECURSIVE DFS ON EACH DIRECTION ***\\n        *** IF WORD FINISHES ADD TO CONTAINS ***\\n        *** STORE CURRENT CHAR ON TEMP AND CHANGE IT TO INVALID CHARACTER ***\\n        *** AFTER DFS CALLS RESTORE THE CHARACTER (BACKTRACING) ***\\n    }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1840446,
                "content": [
                    {
                        "username": "scott",
                        "content": "my submitted code  was using pure back track and passed OJ \\n\\nI cannot see any need of using trie for the problem"
                    },
                    {
                        "username": "omkashyap007",
                        "content": "Anyone please help . Why this is not working . I made a simple dfs solution with backtracking . It seems to work with 58 test cases but fails at 59 .\\n\\nthis is board : [[\"a\",\"b\",\"c\"],[\"a\",\"e\",\"d\"],[\"a\",\"f\",\"g\"]]\\nwords : [\"abcdefg\",\"gfedcbaaa\",\"eaabcdgfa\",\"befa\",\"dgc\",\"ade\"]\\noutput : [\"gfedcbaaa\",\"abcdefg\",\"befa\"]\\nexpected : [\"abcdefg\",\"befa\",\"eaabcdgfa\",\"gfedcbaaa\"]\\n\\nwhat is wrong with the code : \\ncode : \\n ```\\nclass Solution:\\n\\n    def inside(self , i , j , grid):\\n        if i>= 0 and i < len(grid) and j>=0 and j < len(grid[0]) :\\n            return True\\n        return False\\n\\n    def dfs(self , i , j , index , word , grid , visited):\\n        if index >= len(word) : \\n            return True\\n        elif self.inside(i , j , grid) and not visited[i][j] and word[index] == grid[i][j] : \\n            found = False\\n            visited[i][j] = True\\n            found = any(\\n                [\\n                    self.dfs(i+1 , j , index+1 , word , grid , visited) ,\\n                    self.dfs(i-1 , j , index+1 , word , grid , visited) ,\\n                    self.dfs(i , j+1 , index+1 , word , grid , visited) ,\\n                    self.dfs(i , j-1 , index+1 , word , grid , visited) ,\\n                ]\\n            )\\n            visited = False\\n            return found\\n        else :\\n            return False\\n\\n    def findWords(self, grid: List[List[str]], words: List[str]) -> List[str]:\\n        wordMap = {}\\n        for word in words : \\n            char = word[0]\\n            wordMap[char] = wordMap.get(char , []) + [word]\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        answer = set()\\n        for i in range(rows) :\\n            for j in range(cols) :\\n                start_char = grid[i][j]\\n                if start_char not in wordMap :\\n                    continue\\n                wordList = wordMap[start_char]\\n                for word in wordList : \\n                    visited = [[False for _ in range(cols)] for _ in range(rows)]\\n                    if self.dfs(i , j , 0 , word , grid , visited) :\\n                        answer.add(word)\\n        return answer\\n```"
                    },
                    {
                        "username": "deadpool1205",
                        "content": "- You have set visited = False, it should be visited[i][j] = False \\n- While returning answer as list(answer) for convert set to list for the final result"
                    },
                    {
                        "username": "deadpool1205",
                        "content": "There should not be any duplicate words in answer keep that in mind for avoiding wrong submissions  :)"
                    },
                    {
                        "username": "user2075nF",
                        "content": "is the only way to pass last few test cases is to use prefix tree? or is there any other magic available?"
                    },
                    {
                        "username": "Jagadish_Shankar",
                        "content": "class Solution {\\n\\n    public boolean recursive_function(int i , int j , int rows , int columns , char[][] board , boolean[][] visited_cells , int index , String word , int word_length) {\\n\\n        if(index == word_length){\\n            return true;\\n        }\\n\\n        visited_cells[i][j] = true;\\n\\n        boolean top = (((i - 1) >= 0) && (word.charAt(index) == board[(i - 1)][j]) && (!visited_cells[(i - 1)][j]) && (recursive_function((i - 1) , j , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean bottom = (((i + 1) < rows) && (word.charAt(index) == board[(i + 1)][j]) && (!visited_cells[(i + 1)][j]) && (recursive_function((i + 1) , j , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean left = (((j - 1) >= 0) && (word.charAt(index) == board[i][(j - 1)]) && (!visited_cells[i][(j - 1)]) && (recursive_function(i , (j - 1) , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean right = (((j + 1) < columns) && (word.charAt(index) == board[i][(j + 1)]) && (!visited_cells[i][(j + 1)]) && (recursive_function(i , (j + 1) , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        visited_cells[i][j] = false;\\n\\n        return (top || bottom || left || right);\\n    }\\n\\n    public List<String> findWords(char[][] board , String[] words) {\\n\\n        int rows = board.length;\\n        \\n        int columns = board[0].length;\\n\\n        Set<String> all_words_in_board = new HashSet<String>();\\n        \\n        for(String word : (new HashSet<String>(Arrays.asList(words)))){\\n\\n            boolean word_found_flag = false;\\n            \\n            for (int i=0 ; (i < rows) ; i++) {\\n                \\n                for (int j=0 ; (j < columns) ; j++) {\\n                    \\n                    if((board[i][j] == word.charAt(0)) && (recursive_function(i , j , rows , columns , board , (new boolean[rows][columns]) , 1 , word , (word.length())))){\\n                        all_words_in_board.add(word);\\n                        word_found_flag = true;\\n                        break;\\n                    }\\n                }\\n\\n                if(word_found_flag){\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return (new ArrayList<String>(all_words_in_board));\\n    }\\n}\\n\\ncan somebody help me to optimize my program since it\\'s failing the last 3 test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "can some one tell why this code is not giving output \\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "arushi-08",
                        "content": "I have spent a lot of time trying to debug this solution, but I am still facing TLE error while submitting code (while the testcase itself gets accepted). Please suggest an optimization:\\n\\nPython:\\n```\\nclass Node:\\n    def __init__(self):\\n        self.children = {}\\n        self.endofword = False\\n\\n    def addWord(self, word):\\n        curr = self\\n        for c in word:\\n            if c not in curr.children:\\n                curr.children[c] = Node()\\n            curr = curr.children[c]\\n        curr.endofword = True\\n\\nclass Solution:\\n\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        root = Node()\\n        for w in words:\\n            root.addWord(w)\\n        \\n        self.res = []\\n        word = \\'\\'\\n        visited = set()\\n        rows = len(board)\\n        cols = len(board[0])\\n\\n        def dfs(x, y, node, word):\\n            if (x,y) in visited or board[x][y] not in node.children:\\n                return\\n            \\n            visited.add((x,y))\\n            node = node.children[board[x][y]]\\n            word += board[x][y]\\n            \\n            if node.endofword:\\n                self.res.append(word)\\n\\n            rrows = [-1, 0, 1, 0]\\n            ccols = [0, 1, 0, -1]\\n            for r,c in zip(rrows, ccols):\\n                if x+r >= 0 and y+c >= 0 and x+r < rows and y+c < cols:\\n                    dfs(x+r, y+c, node, word)\\n\\n            visited.remove((x,y))\\n        \\n        for i in range(rows):\\n            for j in range(cols):\\n                if board[i][j] in root.children:\\n                    dfs(i, j, root, word)\\n        \\n        return list(set(self.res))\\n\\n```"
                    },
                    {
                        "username": "sianliu1997",
                        "content": "\\nIn PyCharm, my code works fine, but when I submit it to LeetCode, an extra \\'oa\\' is added to the output. Why is this happening?\\n\\n```py\\nclass Solution:\\n    def findWords(self, board, words):\\n        m, n = len(board), len(board[0])\\n\\n        def dfs(board, i, j, word, k=0):\\n            b = copy.deepcopy(board)\\n            if k == len(word):\\n                return True\\n            if not 0 <= i < m or not 0 <= j < n or b[i][j] == \\'#\\' or b[i][j] != word[k]:\\n                return False\\n            b[i][j] = \\'#\\'\\n            return dfs(b, i + 1, j, word, k + 1) or \\\\\\n                   dfs(b, i - 1, j, word, k + 1) or \\\\\\n                   dfs(b, i, j + 1, word, k + 1) or \\\\\\n                   dfs(b, i, j - 1, word, k + 1)\\n\\n        res = []\\n        for i in range(m):\\n            for j in range(n):\\n                for w in words:\\n                    if board[i][j] == w[0] and dfs(board, i, j, w):\\n                        res.append(w)\\n        return res\\n```"
                    },
                    {
                        "username": "cagils",
                        "content": "Tips for general algorithm structure using Trie, Backtracing, and DFS with JS:\\n\\n```js\\nvar findWords = function (board, words) {\\n    const contains = []\\n    const trie = {} // A simple object is enough for a simple trie here\\n\\n    buildTrie()\\n\\n    *** HERE CALL DFS() ON EACH CELL ***\\n\\n    return contains\\n\\n    function buildTrie() {\\n        *** HERE BUILD TRIE FOR WORDS IN WORDS LIST ***\\n    }\\n\\n    function dfs(i, j, node, word) {\\n        *** HERE RECURSIVE DFS ON EACH DIRECTION ***\\n        *** IF WORD FINISHES ADD TO CONTAINS ***\\n        *** STORE CURRENT CHAR ON TEMP AND CHANGE IT TO INVALID CHARACTER ***\\n        *** AFTER DFS CALLS RESTORE THE CHARACTER (BACKTRACING) ***\\n    }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1757517,
                "content": [
                    {
                        "username": "scott",
                        "content": "my submitted code  was using pure back track and passed OJ \\n\\nI cannot see any need of using trie for the problem"
                    },
                    {
                        "username": "omkashyap007",
                        "content": "Anyone please help . Why this is not working . I made a simple dfs solution with backtracking . It seems to work with 58 test cases but fails at 59 .\\n\\nthis is board : [[\"a\",\"b\",\"c\"],[\"a\",\"e\",\"d\"],[\"a\",\"f\",\"g\"]]\\nwords : [\"abcdefg\",\"gfedcbaaa\",\"eaabcdgfa\",\"befa\",\"dgc\",\"ade\"]\\noutput : [\"gfedcbaaa\",\"abcdefg\",\"befa\"]\\nexpected : [\"abcdefg\",\"befa\",\"eaabcdgfa\",\"gfedcbaaa\"]\\n\\nwhat is wrong with the code : \\ncode : \\n ```\\nclass Solution:\\n\\n    def inside(self , i , j , grid):\\n        if i>= 0 and i < len(grid) and j>=0 and j < len(grid[0]) :\\n            return True\\n        return False\\n\\n    def dfs(self , i , j , index , word , grid , visited):\\n        if index >= len(word) : \\n            return True\\n        elif self.inside(i , j , grid) and not visited[i][j] and word[index] == grid[i][j] : \\n            found = False\\n            visited[i][j] = True\\n            found = any(\\n                [\\n                    self.dfs(i+1 , j , index+1 , word , grid , visited) ,\\n                    self.dfs(i-1 , j , index+1 , word , grid , visited) ,\\n                    self.dfs(i , j+1 , index+1 , word , grid , visited) ,\\n                    self.dfs(i , j-1 , index+1 , word , grid , visited) ,\\n                ]\\n            )\\n            visited = False\\n            return found\\n        else :\\n            return False\\n\\n    def findWords(self, grid: List[List[str]], words: List[str]) -> List[str]:\\n        wordMap = {}\\n        for word in words : \\n            char = word[0]\\n            wordMap[char] = wordMap.get(char , []) + [word]\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        answer = set()\\n        for i in range(rows) :\\n            for j in range(cols) :\\n                start_char = grid[i][j]\\n                if start_char not in wordMap :\\n                    continue\\n                wordList = wordMap[start_char]\\n                for word in wordList : \\n                    visited = [[False for _ in range(cols)] for _ in range(rows)]\\n                    if self.dfs(i , j , 0 , word , grid , visited) :\\n                        answer.add(word)\\n        return answer\\n```"
                    },
                    {
                        "username": "deadpool1205",
                        "content": "- You have set visited = False, it should be visited[i][j] = False \\n- While returning answer as list(answer) for convert set to list for the final result"
                    },
                    {
                        "username": "deadpool1205",
                        "content": "There should not be any duplicate words in answer keep that in mind for avoiding wrong submissions  :)"
                    },
                    {
                        "username": "user2075nF",
                        "content": "is the only way to pass last few test cases is to use prefix tree? or is there any other magic available?"
                    },
                    {
                        "username": "Jagadish_Shankar",
                        "content": "class Solution {\\n\\n    public boolean recursive_function(int i , int j , int rows , int columns , char[][] board , boolean[][] visited_cells , int index , String word , int word_length) {\\n\\n        if(index == word_length){\\n            return true;\\n        }\\n\\n        visited_cells[i][j] = true;\\n\\n        boolean top = (((i - 1) >= 0) && (word.charAt(index) == board[(i - 1)][j]) && (!visited_cells[(i - 1)][j]) && (recursive_function((i - 1) , j , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean bottom = (((i + 1) < rows) && (word.charAt(index) == board[(i + 1)][j]) && (!visited_cells[(i + 1)][j]) && (recursive_function((i + 1) , j , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean left = (((j - 1) >= 0) && (word.charAt(index) == board[i][(j - 1)]) && (!visited_cells[i][(j - 1)]) && (recursive_function(i , (j - 1) , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean right = (((j + 1) < columns) && (word.charAt(index) == board[i][(j + 1)]) && (!visited_cells[i][(j + 1)]) && (recursive_function(i , (j + 1) , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        visited_cells[i][j] = false;\\n\\n        return (top || bottom || left || right);\\n    }\\n\\n    public List<String> findWords(char[][] board , String[] words) {\\n\\n        int rows = board.length;\\n        \\n        int columns = board[0].length;\\n\\n        Set<String> all_words_in_board = new HashSet<String>();\\n        \\n        for(String word : (new HashSet<String>(Arrays.asList(words)))){\\n\\n            boolean word_found_flag = false;\\n            \\n            for (int i=0 ; (i < rows) ; i++) {\\n                \\n                for (int j=0 ; (j < columns) ; j++) {\\n                    \\n                    if((board[i][j] == word.charAt(0)) && (recursive_function(i , j , rows , columns , board , (new boolean[rows][columns]) , 1 , word , (word.length())))){\\n                        all_words_in_board.add(word);\\n                        word_found_flag = true;\\n                        break;\\n                    }\\n                }\\n\\n                if(word_found_flag){\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return (new ArrayList<String>(all_words_in_board));\\n    }\\n}\\n\\ncan somebody help me to optimize my program since it\\'s failing the last 3 test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "can some one tell why this code is not giving output \\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "arushi-08",
                        "content": "I have spent a lot of time trying to debug this solution, but I am still facing TLE error while submitting code (while the testcase itself gets accepted). Please suggest an optimization:\\n\\nPython:\\n```\\nclass Node:\\n    def __init__(self):\\n        self.children = {}\\n        self.endofword = False\\n\\n    def addWord(self, word):\\n        curr = self\\n        for c in word:\\n            if c not in curr.children:\\n                curr.children[c] = Node()\\n            curr = curr.children[c]\\n        curr.endofword = True\\n\\nclass Solution:\\n\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        root = Node()\\n        for w in words:\\n            root.addWord(w)\\n        \\n        self.res = []\\n        word = \\'\\'\\n        visited = set()\\n        rows = len(board)\\n        cols = len(board[0])\\n\\n        def dfs(x, y, node, word):\\n            if (x,y) in visited or board[x][y] not in node.children:\\n                return\\n            \\n            visited.add((x,y))\\n            node = node.children[board[x][y]]\\n            word += board[x][y]\\n            \\n            if node.endofword:\\n                self.res.append(word)\\n\\n            rrows = [-1, 0, 1, 0]\\n            ccols = [0, 1, 0, -1]\\n            for r,c in zip(rrows, ccols):\\n                if x+r >= 0 and y+c >= 0 and x+r < rows and y+c < cols:\\n                    dfs(x+r, y+c, node, word)\\n\\n            visited.remove((x,y))\\n        \\n        for i in range(rows):\\n            for j in range(cols):\\n                if board[i][j] in root.children:\\n                    dfs(i, j, root, word)\\n        \\n        return list(set(self.res))\\n\\n```"
                    },
                    {
                        "username": "sianliu1997",
                        "content": "\\nIn PyCharm, my code works fine, but when I submit it to LeetCode, an extra \\'oa\\' is added to the output. Why is this happening?\\n\\n```py\\nclass Solution:\\n    def findWords(self, board, words):\\n        m, n = len(board), len(board[0])\\n\\n        def dfs(board, i, j, word, k=0):\\n            b = copy.deepcopy(board)\\n            if k == len(word):\\n                return True\\n            if not 0 <= i < m or not 0 <= j < n or b[i][j] == \\'#\\' or b[i][j] != word[k]:\\n                return False\\n            b[i][j] = \\'#\\'\\n            return dfs(b, i + 1, j, word, k + 1) or \\\\\\n                   dfs(b, i - 1, j, word, k + 1) or \\\\\\n                   dfs(b, i, j + 1, word, k + 1) or \\\\\\n                   dfs(b, i, j - 1, word, k + 1)\\n\\n        res = []\\n        for i in range(m):\\n            for j in range(n):\\n                for w in words:\\n                    if board[i][j] == w[0] and dfs(board, i, j, w):\\n                        res.append(w)\\n        return res\\n```"
                    },
                    {
                        "username": "cagils",
                        "content": "Tips for general algorithm structure using Trie, Backtracing, and DFS with JS:\\n\\n```js\\nvar findWords = function (board, words) {\\n    const contains = []\\n    const trie = {} // A simple object is enough for a simple trie here\\n\\n    buildTrie()\\n\\n    *** HERE CALL DFS() ON EACH CELL ***\\n\\n    return contains\\n\\n    function buildTrie() {\\n        *** HERE BUILD TRIE FOR WORDS IN WORDS LIST ***\\n    }\\n\\n    function dfs(i, j, node, word) {\\n        *** HERE RECURSIVE DFS ON EACH DIRECTION ***\\n        *** IF WORD FINISHES ADD TO CONTAINS ***\\n        *** STORE CURRENT CHAR ON TEMP AND CHANGE IT TO INVALID CHARACTER ***\\n        *** AFTER DFS CALLS RESTORE THE CHARACTER (BACKTRACING) ***\\n    }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1751965,
                "content": [
                    {
                        "username": "ramadanizm",
                        "content": "What is the wrong with my solution ? why some test cases do not pass\\n```\\nclass TrieNode{\\n    Map<Character , TrieNode> children;\\n    boolean endOfWord;\\n\\n   public TrieNode(){ // no input  :) \\n        children = new HashMap<>();\\n        endOfWord = false;\\n   }\\n\\n    public void addWord(String word) {\\n        TrieNode curr = this;\\n        for(char c : word.toCharArray() ){\\n            if (curr.children.get(c) == null){\\n                curr.children.put(c , new TrieNode());\\n            }\\n            curr = curr.children.get(c);\\n        }\\n        curr.endOfWord = true;\\n    }\\n}\\n    \\nclass Solution {\\n    static final int[][] DIRECTIONS = new int [][]{{1,0} , {-1,0} , {0,1}, {0,-1}};\\n         public List<String> findWords(char[][] board, String[] words) {\\n            int rows = board.length ; int cols = board[0].length;\\n            TrieNode root = new TrieNode();\\n             for(String word : words){\\n                root.addWord(word);\\n             }\\n\\n             boolean [][] visit  = new boolean[rows][cols];\\n             for(boolean[] row: visit)\\n                Arrays.fill(row , false);\\n           \\n\\n             Set<String> result  = new HashSet<>();\\n             for (int r= 0 ; r < rows ; r++){\\n                 for(int c= 0 ; c < cols ; c++){\\n\\n                     dfs(board , r, c , visit , new StringBuilder()  , result, root );\\n                 }\\n             }\\n         /*\\n            System.out.print(result );\\n            List<String> list = new ArrayList<>();\\n            for(String word:words){\\n                if (result.contains(word)){\\n                  list.add(word);  \\n                } \\n                    \\n            }\\n            */\\n            \\n             return new ArrayList<>(result);\\n             \\n\\n}\\n\\nvoid dfs(char[][] board, int r, int c ,boolean [][] visit , StringBuilder path ,  Set<String>  result, TrieNode root   ){\\n\\nif (outOfBound(board  , r, c) || visit[r][c] || root.children.get(board[r][c])  == null){\\n    return ;\\n}\\n\\npath.append(board[r][c]);\\nvisit[r][c] = true;\\nroot = root.children.get(board[r][c]);\\nif (root.endOfWord){\\n    result.add(path.toString());\\n}\\n\\nfor(int[] dir:DIRECTIONS){\\n    dfs(board, r+ dir[0] , c+dir[1] , visit, path,result ,root );\\n}\\n\\nvisit[r][c] = false; // the c could be used in another path (backtracking )\\n\\n}\\n\\nprivate boolean outOfBound(char [][] board , int r , int c){\\n    if ( r < 0 || c < 0 || r >= board.length || c >= board[0].length){\\n        return true;\\n    }\\n    return false;\\n}\\n\\n}\\n```"
                    },
                    {
                        "username": "ababuji",
                        "content": "Language specific TLE  shouldn\\'t be happening. I see asymptotic time complexities being the same regardless of whether the solution is being implemented in Python or Java. \\n\\n"
                    },
                    {
                        "username": "heckervarun",
                        "content": "guys i\\'m getting TLE , can anyone give me some reason why ?, i used dfs on the matrix, any idea to reduce time complexity ?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@VaruN](/heckervarun) Trie, or you need to improve your dfs function if you dont want to use Trie-dic/set.\\nHope you will get new ideas for dfs algorithm, I would like to share my solution on Python3 for 2 direction searchs.\\nhttps://leetcode.com/problems/word-search-ii/solutions/2998236/dfs-no-trie-python-3-path-following-beats-96-12-95-0/"
                    },
                    {
                        "username": "pratikvijayakar31",
                        "content": "I am confused. For example 1, why do we output \"oath\" and \"eat\". Since \"t\" alphabet is common in both strings and hence I believe it cannot be used for both words. Can someone clarify the rule \"The same letter cell may not be used more than once in a word.\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Pratik Vijayakar](/pratikvijayakar31) \"not be used more than once in a word\", t may be presented once in _previous_ \"oath\", then you should not count it on _new_ word search, i.e. \"eat\"!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "Test case 22 is evil.\n\nEdit: managed to pass it by removing nodes from the prefix tree once I've already seen it and it doesnt have any children of its own."
                    },
                    {
                        "username": "pankajnegi010795",
                        "content": "Can anybody tell that why my following code showing TLE and same code in java accepted all test cases.\\n java code ref  https://leetcode.com/problems/word-search-ii/solutions/59780/java-15ms-easiest-solution-100-00/\\n\\nMy code\\n\\nclass Solution {\\n    struct Node\\n    {\\n        Node * next[26];\\n       string isend;\\n    };\\npublic:\\n    Node * newnode()\\n    {\\n        Node * node=new Node();\\n        for(int i=0;i<26;i++)\\n        node->next[i]=nullptr;\\n        node->isend=\"\";\\n        return node;\\n    }\\n    void createtrie(Node* head,string s1)\\n    {\\n        for(int i=0;i<s1.length();i++)\\n        {\\n            if(head->next[s1[i]-\\'a\\']==nullptr)\\n            head->next[s1[i]-\\'a\\']=newnode();\\n            head=head->next[s1[i]-\\'a\\'];\\n        }\\n        head->isend=s1;\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n      vector<string> res;\\n       Node * head=newnode();\\n       unordered_set<string> ve;\\n        for(int i=0;i<words.size();i++)\\n       {\\n           createtrie(head,words[i]);\\n       }\\n\\n        \\n            for(int l=0;l<board.size();l++)\\n            {\\n                for(int m=0;m<board[0].size();m++)\\n                {\\n                   \\n             vector<vector<int>> vis(board.size(),vector<int>(board[0].size(),0));\\n                checkfor(board,l,m,vis,ve,head);\\n   \\n                }\\n           \\n            }\\n            for(auto i=ve.begin();i!=ve.end();i++)\\n            {\\n                res.push_back(*i);\\n            }\\n        \\n        return res;\\n        \\n    }\\n   void checkfor(vector<vector<char>>& b,int i,int j,vector<vector<int>> vis,unordered_set<string>&ve,Node* head)\\n    {\\n        if(i>=b.size() or i<0 or j<0 or j>=b[0].size() )\\n            return ;\\n       if(vis[i][j]==true)\\n            return ;\\n\\n        if(head->next[b[i][j]-\\'a\\']==nullptr)\\n        return ;\\n              head=head->next[b[i][j]-\\'a\\'];\\n        if(head->isend.size()>0)\\n        {\\n            ve.insert(head->isend);\\n            head->isend=\"\";\\n        }\\n        vis[i][j]=true;\\n       checkfor(b,i+1,j,vis,ve,head) ;\\n       checkfor(b,i,j+1,vis,ve,head);\\n        checkfor(b,i-1,j,vis,ve,head) ;\\n        checkfor(b,i,j-1,vis,ve,head);\\n\\n\\n        vis[i][j]=false;\\n       return ;\\n    }\\n};\\n"
                    },
                    {
                        "username": "nickpavini",
                        "content": "Here is a DP solution I am working on that currently passes 55 of 64 cases. It fails on the test:\\n\\n`board =\\n[[\"a\",\"a\"]]\\nwords =\\n[\"aaa\"]\\nExpected = \\n[]`\\n\\nBasically we break words down and check if the left overs have been found and if this current letter is next to a location of the rest of the word.\\n\\nThe issue I have right now with that test case, is that after `aa` is found going 2 directions, the third `a` doesnt realize that we have overlap.\\n\\nAny ideas on a way to close off this solution?\\n\\n```\\ndef findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        if not board:\\n            return []\\n\\n        rtn = []\\n        memo = {}\\n        for word in words:\\n            self.dp(board, word, memo)\\n            if not (-1,-1) in memo[word]:\\n                rtn.append(word)        \\n        return rtn\\n\\n    def dp(self, board, word,  memo):\\n        if word in memo:\\n            return\\n\\n        leftOver = word[1:]\\n        if leftOver != \\'\\':\\n            self.dp(board, leftOver, memo)\\n            if (-1, -1) in memo[leftOver]:\\n                memo[word] = {(-1,-1): 1}\\n                return\\n\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == word[0]:\\n                    if leftOver == \\'\\' or (i,j+1) in memo[leftOver] or (i,j-1) in memo[leftOver] or (i+1,j) in memo[leftOver] or (i-1,j) in memo[leftOver]:\\n                        if word in memo:\\n                            memo[word][(i,j)] = 1\\n                        else:\\n                            memo[word] = {(i,j): 1}\\n                    \\n\\n        if not word in memo:\\n            memo[word] = {(-1,-1): 1}\\n```"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I dont really understand how a trie is faster than a set. I was able to get my python version running with a set of acceptable prefixes... once. Everytime after that I got TLE. But isnt a tree pretty much a hashed set anyhow? I thought set lookups were O(1). I dont understand how looking up a given prefix in the Trie, returning a small set of acceptable \"following\" letters, and comparing neighbors to the current cell to see if they fall in this set is any different than looking up the entire prefix so far + one of the neighbors in a big list of acceptable prefixes. Both involve at least one set check, and as a hashed structure, should take the same amount of time? Similarly, how does pruning help? It doesnt take less time to find inclusion in a hashed set if the set is smaller I thought? Look ups HASH the target and see if it exists, regardless of other hashed values: its the entire point of hashing, so look ups are O(1)"
                    },
                    {
                        "username": "palakons",
                        "content": "pruning helps, and prefix \"set\" would work f you could prune the prefix set... which is difficult"
                    },
                    {
                        "username": "drap5468",
                        "content": "The way pruning works for this problem is you *entirely* remove a word you already visited, including its prefixes. That way in future traversal you'll know to stop if the only valid route remaining leads to a used word.\n\nIf you never prune, that means you keep traversing routes that are no longer useful to you. Specifically in your code, the condition to continue down a path is whether the current sequence is in prefix_set. Since you never update prefix_set, you end up with a lot of very expensive false positives, going down paths that *used to be* relevant, but no longer are, since that word has been used up.\n\nI agree that your hashing method probably simulates a trie closely enough to work for this problem, so if you implement pruning I bet it will consistently finish running on time."
                    },
                    {
                        "username": "siseendri",
                        "content": " @ `your inline code...your inline code...` `your inline code...your inline code...` @"
                    },
                    {
                        "username": "Ar_2000",
                        "content": "can anyone help me why am I getting TLE for this solution -\\n\\n  class trieNode {\\n    public:\\n        char ch;\\n        vector<trieNode*> child;\\n        bool isEnd;\\n\\n        trieNode() {\\n            for (int i = 0; i < 26; i++) {\\n                child.push_back(NULL);\\n            }\\n\\n            isEnd = false;\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> change = {{0,1},{1,0},{0,-1},{-1,0}};\\n    void buildTrie (trieNode* root, string& s, int i) {\\n        if (i == s.size()) {\\n            root->isEnd = true;\\n            return;\\n        }\\n\\n        trieNode* child = new trieNode();\\n        if (root->child[s[i]-\\'a\\'] == NULL) {\\n            child->ch = s[i];\\n            root->child[s[i]-\\'a\\'] = child;\\n        } else {\\n            child = root->child[s[i]-\\'a\\'];\\n        }\\n\\n        buildTrie(child, s, i+1);\\n    }\\n\\n    void p (vector<vector<char>>& b, int i, int j, trieNode* node, set<string>& ans, string& str) {\\n        int n = b.size(), m = b[0].size();\\n        str += node->ch;\\n\\n        b[i][j] = \\'?\\';\\n\\n        if (node->isEnd) ans.insert(str);\\n\\n        for (vector<int> a : change) {\\n            int nx = i+a[0], ny = j+a[1];\\n            if (nx >= 0 && nx < n && ny >= 0 && ny < m && b[nx][ny] != \\'?\\') {\\n                if (node->child[b[nx][ny]-\\'a\\'] != NULL)  p (b, nx, ny, node->child[b[nx][ny]-\\'a\\'], ans, str);\\n            }\\n        }\\n\\n        b[i][j] = node->ch;\\n        str.pop_back();\\n    }\\n\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        // time complexity -> words.length * words[i].length = 3*(10^5)\\n        trieNode* root = new trieNode();\\n        root->ch = \\'$\\';\\n        for (string& w : words) {\\n            buildTrie(root, w, 0);\\n        }\\n\\n        set<string> ans;\\n        int n = board.size(), m = board[0].size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                char ch = board[i][j];\\n                if (root->child[ch-\\'a\\'] != NULL) {\\n                    string str = \"\";\\n                    p(board, i, j, root->child[ch-\\'a\\'], ans, str);\\n                }\\n            }\\n        }\\n\\n        vector<string> res;\\n\\n        for (string s : ans) {\\n            res.push_back(s);\\n        }\\n\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "[@Ar_2000](/Ar_2000) I implemented in the similar way you did in java that gave me TLE when I implemented in the way I told you that accepted my solution. If you want I can give you my java based solution so that you can compare where you are going wrong."
                    },
                    {
                        "username": "Ar_2000",
                        "content": "[@nikhil97agra](/nikhil97agra) but it still gives tle. and it should be. Adding and poping in and from a string in O(1) operation only"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "I\\'m not sure but I think variable str you used to append character at each and every call that is causing you TLE.  Instead try this : instead isEnd variable in your class make it a string variable with initial value as null and when you are constructing your trie whenever some word ends just assign that variable to that word so what will happen is when you do recursion call to search for the word and you come at that trie node whose string variable is not null that means your word exist in the list in this way that extra overhead of appending and removing character from str variable will not be there."
                    }
                ]
            },
            {
                "id": 1734144,
                "content": [
                    {
                        "username": "ramadanizm",
                        "content": "What is the wrong with my solution ? why some test cases do not pass\\n```\\nclass TrieNode{\\n    Map<Character , TrieNode> children;\\n    boolean endOfWord;\\n\\n   public TrieNode(){ // no input  :) \\n        children = new HashMap<>();\\n        endOfWord = false;\\n   }\\n\\n    public void addWord(String word) {\\n        TrieNode curr = this;\\n        for(char c : word.toCharArray() ){\\n            if (curr.children.get(c) == null){\\n                curr.children.put(c , new TrieNode());\\n            }\\n            curr = curr.children.get(c);\\n        }\\n        curr.endOfWord = true;\\n    }\\n}\\n    \\nclass Solution {\\n    static final int[][] DIRECTIONS = new int [][]{{1,0} , {-1,0} , {0,1}, {0,-1}};\\n         public List<String> findWords(char[][] board, String[] words) {\\n            int rows = board.length ; int cols = board[0].length;\\n            TrieNode root = new TrieNode();\\n             for(String word : words){\\n                root.addWord(word);\\n             }\\n\\n             boolean [][] visit  = new boolean[rows][cols];\\n             for(boolean[] row: visit)\\n                Arrays.fill(row , false);\\n           \\n\\n             Set<String> result  = new HashSet<>();\\n             for (int r= 0 ; r < rows ; r++){\\n                 for(int c= 0 ; c < cols ; c++){\\n\\n                     dfs(board , r, c , visit , new StringBuilder()  , result, root );\\n                 }\\n             }\\n         /*\\n            System.out.print(result );\\n            List<String> list = new ArrayList<>();\\n            for(String word:words){\\n                if (result.contains(word)){\\n                  list.add(word);  \\n                } \\n                    \\n            }\\n            */\\n            \\n             return new ArrayList<>(result);\\n             \\n\\n}\\n\\nvoid dfs(char[][] board, int r, int c ,boolean [][] visit , StringBuilder path ,  Set<String>  result, TrieNode root   ){\\n\\nif (outOfBound(board  , r, c) || visit[r][c] || root.children.get(board[r][c])  == null){\\n    return ;\\n}\\n\\npath.append(board[r][c]);\\nvisit[r][c] = true;\\nroot = root.children.get(board[r][c]);\\nif (root.endOfWord){\\n    result.add(path.toString());\\n}\\n\\nfor(int[] dir:DIRECTIONS){\\n    dfs(board, r+ dir[0] , c+dir[1] , visit, path,result ,root );\\n}\\n\\nvisit[r][c] = false; // the c could be used in another path (backtracking )\\n\\n}\\n\\nprivate boolean outOfBound(char [][] board , int r , int c){\\n    if ( r < 0 || c < 0 || r >= board.length || c >= board[0].length){\\n        return true;\\n    }\\n    return false;\\n}\\n\\n}\\n```"
                    },
                    {
                        "username": "ababuji",
                        "content": "Language specific TLE  shouldn\\'t be happening. I see asymptotic time complexities being the same regardless of whether the solution is being implemented in Python or Java. \\n\\n"
                    },
                    {
                        "username": "heckervarun",
                        "content": "guys i\\'m getting TLE , can anyone give me some reason why ?, i used dfs on the matrix, any idea to reduce time complexity ?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@VaruN](/heckervarun) Trie, or you need to improve your dfs function if you dont want to use Trie-dic/set.\\nHope you will get new ideas for dfs algorithm, I would like to share my solution on Python3 for 2 direction searchs.\\nhttps://leetcode.com/problems/word-search-ii/solutions/2998236/dfs-no-trie-python-3-path-following-beats-96-12-95-0/"
                    },
                    {
                        "username": "pratikvijayakar31",
                        "content": "I am confused. For example 1, why do we output \"oath\" and \"eat\". Since \"t\" alphabet is common in both strings and hence I believe it cannot be used for both words. Can someone clarify the rule \"The same letter cell may not be used more than once in a word.\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Pratik Vijayakar](/pratikvijayakar31) \"not be used more than once in a word\", t may be presented once in _previous_ \"oath\", then you should not count it on _new_ word search, i.e. \"eat\"!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "Test case 22 is evil.\n\nEdit: managed to pass it by removing nodes from the prefix tree once I've already seen it and it doesnt have any children of its own."
                    },
                    {
                        "username": "pankajnegi010795",
                        "content": "Can anybody tell that why my following code showing TLE and same code in java accepted all test cases.\\n java code ref  https://leetcode.com/problems/word-search-ii/solutions/59780/java-15ms-easiest-solution-100-00/\\n\\nMy code\\n\\nclass Solution {\\n    struct Node\\n    {\\n        Node * next[26];\\n       string isend;\\n    };\\npublic:\\n    Node * newnode()\\n    {\\n        Node * node=new Node();\\n        for(int i=0;i<26;i++)\\n        node->next[i]=nullptr;\\n        node->isend=\"\";\\n        return node;\\n    }\\n    void createtrie(Node* head,string s1)\\n    {\\n        for(int i=0;i<s1.length();i++)\\n        {\\n            if(head->next[s1[i]-\\'a\\']==nullptr)\\n            head->next[s1[i]-\\'a\\']=newnode();\\n            head=head->next[s1[i]-\\'a\\'];\\n        }\\n        head->isend=s1;\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n      vector<string> res;\\n       Node * head=newnode();\\n       unordered_set<string> ve;\\n        for(int i=0;i<words.size();i++)\\n       {\\n           createtrie(head,words[i]);\\n       }\\n\\n        \\n            for(int l=0;l<board.size();l++)\\n            {\\n                for(int m=0;m<board[0].size();m++)\\n                {\\n                   \\n             vector<vector<int>> vis(board.size(),vector<int>(board[0].size(),0));\\n                checkfor(board,l,m,vis,ve,head);\\n   \\n                }\\n           \\n            }\\n            for(auto i=ve.begin();i!=ve.end();i++)\\n            {\\n                res.push_back(*i);\\n            }\\n        \\n        return res;\\n        \\n    }\\n   void checkfor(vector<vector<char>>& b,int i,int j,vector<vector<int>> vis,unordered_set<string>&ve,Node* head)\\n    {\\n        if(i>=b.size() or i<0 or j<0 or j>=b[0].size() )\\n            return ;\\n       if(vis[i][j]==true)\\n            return ;\\n\\n        if(head->next[b[i][j]-\\'a\\']==nullptr)\\n        return ;\\n              head=head->next[b[i][j]-\\'a\\'];\\n        if(head->isend.size()>0)\\n        {\\n            ve.insert(head->isend);\\n            head->isend=\"\";\\n        }\\n        vis[i][j]=true;\\n       checkfor(b,i+1,j,vis,ve,head) ;\\n       checkfor(b,i,j+1,vis,ve,head);\\n        checkfor(b,i-1,j,vis,ve,head) ;\\n        checkfor(b,i,j-1,vis,ve,head);\\n\\n\\n        vis[i][j]=false;\\n       return ;\\n    }\\n};\\n"
                    },
                    {
                        "username": "nickpavini",
                        "content": "Here is a DP solution I am working on that currently passes 55 of 64 cases. It fails on the test:\\n\\n`board =\\n[[\"a\",\"a\"]]\\nwords =\\n[\"aaa\"]\\nExpected = \\n[]`\\n\\nBasically we break words down and check if the left overs have been found and if this current letter is next to a location of the rest of the word.\\n\\nThe issue I have right now with that test case, is that after `aa` is found going 2 directions, the third `a` doesnt realize that we have overlap.\\n\\nAny ideas on a way to close off this solution?\\n\\n```\\ndef findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        if not board:\\n            return []\\n\\n        rtn = []\\n        memo = {}\\n        for word in words:\\n            self.dp(board, word, memo)\\n            if not (-1,-1) in memo[word]:\\n                rtn.append(word)        \\n        return rtn\\n\\n    def dp(self, board, word,  memo):\\n        if word in memo:\\n            return\\n\\n        leftOver = word[1:]\\n        if leftOver != \\'\\':\\n            self.dp(board, leftOver, memo)\\n            if (-1, -1) in memo[leftOver]:\\n                memo[word] = {(-1,-1): 1}\\n                return\\n\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == word[0]:\\n                    if leftOver == \\'\\' or (i,j+1) in memo[leftOver] or (i,j-1) in memo[leftOver] or (i+1,j) in memo[leftOver] or (i-1,j) in memo[leftOver]:\\n                        if word in memo:\\n                            memo[word][(i,j)] = 1\\n                        else:\\n                            memo[word] = {(i,j): 1}\\n                    \\n\\n        if not word in memo:\\n            memo[word] = {(-1,-1): 1}\\n```"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I dont really understand how a trie is faster than a set. I was able to get my python version running with a set of acceptable prefixes... once. Everytime after that I got TLE. But isnt a tree pretty much a hashed set anyhow? I thought set lookups were O(1). I dont understand how looking up a given prefix in the Trie, returning a small set of acceptable \"following\" letters, and comparing neighbors to the current cell to see if they fall in this set is any different than looking up the entire prefix so far + one of the neighbors in a big list of acceptable prefixes. Both involve at least one set check, and as a hashed structure, should take the same amount of time? Similarly, how does pruning help? It doesnt take less time to find inclusion in a hashed set if the set is smaller I thought? Look ups HASH the target and see if it exists, regardless of other hashed values: its the entire point of hashing, so look ups are O(1)"
                    },
                    {
                        "username": "palakons",
                        "content": "pruning helps, and prefix \"set\" would work f you could prune the prefix set... which is difficult"
                    },
                    {
                        "username": "drap5468",
                        "content": "The way pruning works for this problem is you *entirely* remove a word you already visited, including its prefixes. That way in future traversal you'll know to stop if the only valid route remaining leads to a used word.\n\nIf you never prune, that means you keep traversing routes that are no longer useful to you. Specifically in your code, the condition to continue down a path is whether the current sequence is in prefix_set. Since you never update prefix_set, you end up with a lot of very expensive false positives, going down paths that *used to be* relevant, but no longer are, since that word has been used up.\n\nI agree that your hashing method probably simulates a trie closely enough to work for this problem, so if you implement pruning I bet it will consistently finish running on time."
                    },
                    {
                        "username": "siseendri",
                        "content": " @ `your inline code...your inline code...` `your inline code...your inline code...` @"
                    },
                    {
                        "username": "Ar_2000",
                        "content": "can anyone help me why am I getting TLE for this solution -\\n\\n  class trieNode {\\n    public:\\n        char ch;\\n        vector<trieNode*> child;\\n        bool isEnd;\\n\\n        trieNode() {\\n            for (int i = 0; i < 26; i++) {\\n                child.push_back(NULL);\\n            }\\n\\n            isEnd = false;\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> change = {{0,1},{1,0},{0,-1},{-1,0}};\\n    void buildTrie (trieNode* root, string& s, int i) {\\n        if (i == s.size()) {\\n            root->isEnd = true;\\n            return;\\n        }\\n\\n        trieNode* child = new trieNode();\\n        if (root->child[s[i]-\\'a\\'] == NULL) {\\n            child->ch = s[i];\\n            root->child[s[i]-\\'a\\'] = child;\\n        } else {\\n            child = root->child[s[i]-\\'a\\'];\\n        }\\n\\n        buildTrie(child, s, i+1);\\n    }\\n\\n    void p (vector<vector<char>>& b, int i, int j, trieNode* node, set<string>& ans, string& str) {\\n        int n = b.size(), m = b[0].size();\\n        str += node->ch;\\n\\n        b[i][j] = \\'?\\';\\n\\n        if (node->isEnd) ans.insert(str);\\n\\n        for (vector<int> a : change) {\\n            int nx = i+a[0], ny = j+a[1];\\n            if (nx >= 0 && nx < n && ny >= 0 && ny < m && b[nx][ny] != \\'?\\') {\\n                if (node->child[b[nx][ny]-\\'a\\'] != NULL)  p (b, nx, ny, node->child[b[nx][ny]-\\'a\\'], ans, str);\\n            }\\n        }\\n\\n        b[i][j] = node->ch;\\n        str.pop_back();\\n    }\\n\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        // time complexity -> words.length * words[i].length = 3*(10^5)\\n        trieNode* root = new trieNode();\\n        root->ch = \\'$\\';\\n        for (string& w : words) {\\n            buildTrie(root, w, 0);\\n        }\\n\\n        set<string> ans;\\n        int n = board.size(), m = board[0].size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                char ch = board[i][j];\\n                if (root->child[ch-\\'a\\'] != NULL) {\\n                    string str = \"\";\\n                    p(board, i, j, root->child[ch-\\'a\\'], ans, str);\\n                }\\n            }\\n        }\\n\\n        vector<string> res;\\n\\n        for (string s : ans) {\\n            res.push_back(s);\\n        }\\n\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "[@Ar_2000](/Ar_2000) I implemented in the similar way you did in java that gave me TLE when I implemented in the way I told you that accepted my solution. If you want I can give you my java based solution so that you can compare where you are going wrong."
                    },
                    {
                        "username": "Ar_2000",
                        "content": "[@nikhil97agra](/nikhil97agra) but it still gives tle. and it should be. Adding and poping in and from a string in O(1) operation only"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "I\\'m not sure but I think variable str you used to append character at each and every call that is causing you TLE.  Instead try this : instead isEnd variable in your class make it a string variable with initial value as null and when you are constructing your trie whenever some word ends just assign that variable to that word so what will happen is when you do recursion call to search for the word and you come at that trie node whose string variable is not null that means your word exist in the list in this way that extra overhead of appending and removing character from str variable will not be there."
                    }
                ]
            },
            {
                "id": 1730080,
                "content": [
                    {
                        "username": "ramadanizm",
                        "content": "What is the wrong with my solution ? why some test cases do not pass\\n```\\nclass TrieNode{\\n    Map<Character , TrieNode> children;\\n    boolean endOfWord;\\n\\n   public TrieNode(){ // no input  :) \\n        children = new HashMap<>();\\n        endOfWord = false;\\n   }\\n\\n    public void addWord(String word) {\\n        TrieNode curr = this;\\n        for(char c : word.toCharArray() ){\\n            if (curr.children.get(c) == null){\\n                curr.children.put(c , new TrieNode());\\n            }\\n            curr = curr.children.get(c);\\n        }\\n        curr.endOfWord = true;\\n    }\\n}\\n    \\nclass Solution {\\n    static final int[][] DIRECTIONS = new int [][]{{1,0} , {-1,0} , {0,1}, {0,-1}};\\n         public List<String> findWords(char[][] board, String[] words) {\\n            int rows = board.length ; int cols = board[0].length;\\n            TrieNode root = new TrieNode();\\n             for(String word : words){\\n                root.addWord(word);\\n             }\\n\\n             boolean [][] visit  = new boolean[rows][cols];\\n             for(boolean[] row: visit)\\n                Arrays.fill(row , false);\\n           \\n\\n             Set<String> result  = new HashSet<>();\\n             for (int r= 0 ; r < rows ; r++){\\n                 for(int c= 0 ; c < cols ; c++){\\n\\n                     dfs(board , r, c , visit , new StringBuilder()  , result, root );\\n                 }\\n             }\\n         /*\\n            System.out.print(result );\\n            List<String> list = new ArrayList<>();\\n            for(String word:words){\\n                if (result.contains(word)){\\n                  list.add(word);  \\n                } \\n                    \\n            }\\n            */\\n            \\n             return new ArrayList<>(result);\\n             \\n\\n}\\n\\nvoid dfs(char[][] board, int r, int c ,boolean [][] visit , StringBuilder path ,  Set<String>  result, TrieNode root   ){\\n\\nif (outOfBound(board  , r, c) || visit[r][c] || root.children.get(board[r][c])  == null){\\n    return ;\\n}\\n\\npath.append(board[r][c]);\\nvisit[r][c] = true;\\nroot = root.children.get(board[r][c]);\\nif (root.endOfWord){\\n    result.add(path.toString());\\n}\\n\\nfor(int[] dir:DIRECTIONS){\\n    dfs(board, r+ dir[0] , c+dir[1] , visit, path,result ,root );\\n}\\n\\nvisit[r][c] = false; // the c could be used in another path (backtracking )\\n\\n}\\n\\nprivate boolean outOfBound(char [][] board , int r , int c){\\n    if ( r < 0 || c < 0 || r >= board.length || c >= board[0].length){\\n        return true;\\n    }\\n    return false;\\n}\\n\\n}\\n```"
                    },
                    {
                        "username": "ababuji",
                        "content": "Language specific TLE  shouldn\\'t be happening. I see asymptotic time complexities being the same regardless of whether the solution is being implemented in Python or Java. \\n\\n"
                    },
                    {
                        "username": "heckervarun",
                        "content": "guys i\\'m getting TLE , can anyone give me some reason why ?, i used dfs on the matrix, any idea to reduce time complexity ?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@VaruN](/heckervarun) Trie, or you need to improve your dfs function if you dont want to use Trie-dic/set.\\nHope you will get new ideas for dfs algorithm, I would like to share my solution on Python3 for 2 direction searchs.\\nhttps://leetcode.com/problems/word-search-ii/solutions/2998236/dfs-no-trie-python-3-path-following-beats-96-12-95-0/"
                    },
                    {
                        "username": "pratikvijayakar31",
                        "content": "I am confused. For example 1, why do we output \"oath\" and \"eat\". Since \"t\" alphabet is common in both strings and hence I believe it cannot be used for both words. Can someone clarify the rule \"The same letter cell may not be used more than once in a word.\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Pratik Vijayakar](/pratikvijayakar31) \"not be used more than once in a word\", t may be presented once in _previous_ \"oath\", then you should not count it on _new_ word search, i.e. \"eat\"!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "Test case 22 is evil.\n\nEdit: managed to pass it by removing nodes from the prefix tree once I've already seen it and it doesnt have any children of its own."
                    },
                    {
                        "username": "pankajnegi010795",
                        "content": "Can anybody tell that why my following code showing TLE and same code in java accepted all test cases.\\n java code ref  https://leetcode.com/problems/word-search-ii/solutions/59780/java-15ms-easiest-solution-100-00/\\n\\nMy code\\n\\nclass Solution {\\n    struct Node\\n    {\\n        Node * next[26];\\n       string isend;\\n    };\\npublic:\\n    Node * newnode()\\n    {\\n        Node * node=new Node();\\n        for(int i=0;i<26;i++)\\n        node->next[i]=nullptr;\\n        node->isend=\"\";\\n        return node;\\n    }\\n    void createtrie(Node* head,string s1)\\n    {\\n        for(int i=0;i<s1.length();i++)\\n        {\\n            if(head->next[s1[i]-\\'a\\']==nullptr)\\n            head->next[s1[i]-\\'a\\']=newnode();\\n            head=head->next[s1[i]-\\'a\\'];\\n        }\\n        head->isend=s1;\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n      vector<string> res;\\n       Node * head=newnode();\\n       unordered_set<string> ve;\\n        for(int i=0;i<words.size();i++)\\n       {\\n           createtrie(head,words[i]);\\n       }\\n\\n        \\n            for(int l=0;l<board.size();l++)\\n            {\\n                for(int m=0;m<board[0].size();m++)\\n                {\\n                   \\n             vector<vector<int>> vis(board.size(),vector<int>(board[0].size(),0));\\n                checkfor(board,l,m,vis,ve,head);\\n   \\n                }\\n           \\n            }\\n            for(auto i=ve.begin();i!=ve.end();i++)\\n            {\\n                res.push_back(*i);\\n            }\\n        \\n        return res;\\n        \\n    }\\n   void checkfor(vector<vector<char>>& b,int i,int j,vector<vector<int>> vis,unordered_set<string>&ve,Node* head)\\n    {\\n        if(i>=b.size() or i<0 or j<0 or j>=b[0].size() )\\n            return ;\\n       if(vis[i][j]==true)\\n            return ;\\n\\n        if(head->next[b[i][j]-\\'a\\']==nullptr)\\n        return ;\\n              head=head->next[b[i][j]-\\'a\\'];\\n        if(head->isend.size()>0)\\n        {\\n            ve.insert(head->isend);\\n            head->isend=\"\";\\n        }\\n        vis[i][j]=true;\\n       checkfor(b,i+1,j,vis,ve,head) ;\\n       checkfor(b,i,j+1,vis,ve,head);\\n        checkfor(b,i-1,j,vis,ve,head) ;\\n        checkfor(b,i,j-1,vis,ve,head);\\n\\n\\n        vis[i][j]=false;\\n       return ;\\n    }\\n};\\n"
                    },
                    {
                        "username": "nickpavini",
                        "content": "Here is a DP solution I am working on that currently passes 55 of 64 cases. It fails on the test:\\n\\n`board =\\n[[\"a\",\"a\"]]\\nwords =\\n[\"aaa\"]\\nExpected = \\n[]`\\n\\nBasically we break words down and check if the left overs have been found and if this current letter is next to a location of the rest of the word.\\n\\nThe issue I have right now with that test case, is that after `aa` is found going 2 directions, the third `a` doesnt realize that we have overlap.\\n\\nAny ideas on a way to close off this solution?\\n\\n```\\ndef findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        if not board:\\n            return []\\n\\n        rtn = []\\n        memo = {}\\n        for word in words:\\n            self.dp(board, word, memo)\\n            if not (-1,-1) in memo[word]:\\n                rtn.append(word)        \\n        return rtn\\n\\n    def dp(self, board, word,  memo):\\n        if word in memo:\\n            return\\n\\n        leftOver = word[1:]\\n        if leftOver != \\'\\':\\n            self.dp(board, leftOver, memo)\\n            if (-1, -1) in memo[leftOver]:\\n                memo[word] = {(-1,-1): 1}\\n                return\\n\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == word[0]:\\n                    if leftOver == \\'\\' or (i,j+1) in memo[leftOver] or (i,j-1) in memo[leftOver] or (i+1,j) in memo[leftOver] or (i-1,j) in memo[leftOver]:\\n                        if word in memo:\\n                            memo[word][(i,j)] = 1\\n                        else:\\n                            memo[word] = {(i,j): 1}\\n                    \\n\\n        if not word in memo:\\n            memo[word] = {(-1,-1): 1}\\n```"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I dont really understand how a trie is faster than a set. I was able to get my python version running with a set of acceptable prefixes... once. Everytime after that I got TLE. But isnt a tree pretty much a hashed set anyhow? I thought set lookups were O(1). I dont understand how looking up a given prefix in the Trie, returning a small set of acceptable \"following\" letters, and comparing neighbors to the current cell to see if they fall in this set is any different than looking up the entire prefix so far + one of the neighbors in a big list of acceptable prefixes. Both involve at least one set check, and as a hashed structure, should take the same amount of time? Similarly, how does pruning help? It doesnt take less time to find inclusion in a hashed set if the set is smaller I thought? Look ups HASH the target and see if it exists, regardless of other hashed values: its the entire point of hashing, so look ups are O(1)"
                    },
                    {
                        "username": "palakons",
                        "content": "pruning helps, and prefix \"set\" would work f you could prune the prefix set... which is difficult"
                    },
                    {
                        "username": "drap5468",
                        "content": "The way pruning works for this problem is you *entirely* remove a word you already visited, including its prefixes. That way in future traversal you'll know to stop if the only valid route remaining leads to a used word.\n\nIf you never prune, that means you keep traversing routes that are no longer useful to you. Specifically in your code, the condition to continue down a path is whether the current sequence is in prefix_set. Since you never update prefix_set, you end up with a lot of very expensive false positives, going down paths that *used to be* relevant, but no longer are, since that word has been used up.\n\nI agree that your hashing method probably simulates a trie closely enough to work for this problem, so if you implement pruning I bet it will consistently finish running on time."
                    },
                    {
                        "username": "siseendri",
                        "content": " @ `your inline code...your inline code...` `your inline code...your inline code...` @"
                    },
                    {
                        "username": "Ar_2000",
                        "content": "can anyone help me why am I getting TLE for this solution -\\n\\n  class trieNode {\\n    public:\\n        char ch;\\n        vector<trieNode*> child;\\n        bool isEnd;\\n\\n        trieNode() {\\n            for (int i = 0; i < 26; i++) {\\n                child.push_back(NULL);\\n            }\\n\\n            isEnd = false;\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> change = {{0,1},{1,0},{0,-1},{-1,0}};\\n    void buildTrie (trieNode* root, string& s, int i) {\\n        if (i == s.size()) {\\n            root->isEnd = true;\\n            return;\\n        }\\n\\n        trieNode* child = new trieNode();\\n        if (root->child[s[i]-\\'a\\'] == NULL) {\\n            child->ch = s[i];\\n            root->child[s[i]-\\'a\\'] = child;\\n        } else {\\n            child = root->child[s[i]-\\'a\\'];\\n        }\\n\\n        buildTrie(child, s, i+1);\\n    }\\n\\n    void p (vector<vector<char>>& b, int i, int j, trieNode* node, set<string>& ans, string& str) {\\n        int n = b.size(), m = b[0].size();\\n        str += node->ch;\\n\\n        b[i][j] = \\'?\\';\\n\\n        if (node->isEnd) ans.insert(str);\\n\\n        for (vector<int> a : change) {\\n            int nx = i+a[0], ny = j+a[1];\\n            if (nx >= 0 && nx < n && ny >= 0 && ny < m && b[nx][ny] != \\'?\\') {\\n                if (node->child[b[nx][ny]-\\'a\\'] != NULL)  p (b, nx, ny, node->child[b[nx][ny]-\\'a\\'], ans, str);\\n            }\\n        }\\n\\n        b[i][j] = node->ch;\\n        str.pop_back();\\n    }\\n\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        // time complexity -> words.length * words[i].length = 3*(10^5)\\n        trieNode* root = new trieNode();\\n        root->ch = \\'$\\';\\n        for (string& w : words) {\\n            buildTrie(root, w, 0);\\n        }\\n\\n        set<string> ans;\\n        int n = board.size(), m = board[0].size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                char ch = board[i][j];\\n                if (root->child[ch-\\'a\\'] != NULL) {\\n                    string str = \"\";\\n                    p(board, i, j, root->child[ch-\\'a\\'], ans, str);\\n                }\\n            }\\n        }\\n\\n        vector<string> res;\\n\\n        for (string s : ans) {\\n            res.push_back(s);\\n        }\\n\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "[@Ar_2000](/Ar_2000) I implemented in the similar way you did in java that gave me TLE when I implemented in the way I told you that accepted my solution. If you want I can give you my java based solution so that you can compare where you are going wrong."
                    },
                    {
                        "username": "Ar_2000",
                        "content": "[@nikhil97agra](/nikhil97agra) but it still gives tle. and it should be. Adding and poping in and from a string in O(1) operation only"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "I\\'m not sure but I think variable str you used to append character at each and every call that is causing you TLE.  Instead try this : instead isEnd variable in your class make it a string variable with initial value as null and when you are constructing your trie whenever some word ends just assign that variable to that word so what will happen is when you do recursion call to search for the word and you come at that trie node whose string variable is not null that means your word exist in the list in this way that extra overhead of appending and removing character from str variable will not be there."
                    }
                ]
            },
            {
                "id": 1719253,
                "content": [
                    {
                        "username": "ramadanizm",
                        "content": "What is the wrong with my solution ? why some test cases do not pass\\n```\\nclass TrieNode{\\n    Map<Character , TrieNode> children;\\n    boolean endOfWord;\\n\\n   public TrieNode(){ // no input  :) \\n        children = new HashMap<>();\\n        endOfWord = false;\\n   }\\n\\n    public void addWord(String word) {\\n        TrieNode curr = this;\\n        for(char c : word.toCharArray() ){\\n            if (curr.children.get(c) == null){\\n                curr.children.put(c , new TrieNode());\\n            }\\n            curr = curr.children.get(c);\\n        }\\n        curr.endOfWord = true;\\n    }\\n}\\n    \\nclass Solution {\\n    static final int[][] DIRECTIONS = new int [][]{{1,0} , {-1,0} , {0,1}, {0,-1}};\\n         public List<String> findWords(char[][] board, String[] words) {\\n            int rows = board.length ; int cols = board[0].length;\\n            TrieNode root = new TrieNode();\\n             for(String word : words){\\n                root.addWord(word);\\n             }\\n\\n             boolean [][] visit  = new boolean[rows][cols];\\n             for(boolean[] row: visit)\\n                Arrays.fill(row , false);\\n           \\n\\n             Set<String> result  = new HashSet<>();\\n             for (int r= 0 ; r < rows ; r++){\\n                 for(int c= 0 ; c < cols ; c++){\\n\\n                     dfs(board , r, c , visit , new StringBuilder()  , result, root );\\n                 }\\n             }\\n         /*\\n            System.out.print(result );\\n            List<String> list = new ArrayList<>();\\n            for(String word:words){\\n                if (result.contains(word)){\\n                  list.add(word);  \\n                } \\n                    \\n            }\\n            */\\n            \\n             return new ArrayList<>(result);\\n             \\n\\n}\\n\\nvoid dfs(char[][] board, int r, int c ,boolean [][] visit , StringBuilder path ,  Set<String>  result, TrieNode root   ){\\n\\nif (outOfBound(board  , r, c) || visit[r][c] || root.children.get(board[r][c])  == null){\\n    return ;\\n}\\n\\npath.append(board[r][c]);\\nvisit[r][c] = true;\\nroot = root.children.get(board[r][c]);\\nif (root.endOfWord){\\n    result.add(path.toString());\\n}\\n\\nfor(int[] dir:DIRECTIONS){\\n    dfs(board, r+ dir[0] , c+dir[1] , visit, path,result ,root );\\n}\\n\\nvisit[r][c] = false; // the c could be used in another path (backtracking )\\n\\n}\\n\\nprivate boolean outOfBound(char [][] board , int r , int c){\\n    if ( r < 0 || c < 0 || r >= board.length || c >= board[0].length){\\n        return true;\\n    }\\n    return false;\\n}\\n\\n}\\n```"
                    },
                    {
                        "username": "ababuji",
                        "content": "Language specific TLE  shouldn\\'t be happening. I see asymptotic time complexities being the same regardless of whether the solution is being implemented in Python or Java. \\n\\n"
                    },
                    {
                        "username": "heckervarun",
                        "content": "guys i\\'m getting TLE , can anyone give me some reason why ?, i used dfs on the matrix, any idea to reduce time complexity ?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@VaruN](/heckervarun) Trie, or you need to improve your dfs function if you dont want to use Trie-dic/set.\\nHope you will get new ideas for dfs algorithm, I would like to share my solution on Python3 for 2 direction searchs.\\nhttps://leetcode.com/problems/word-search-ii/solutions/2998236/dfs-no-trie-python-3-path-following-beats-96-12-95-0/"
                    },
                    {
                        "username": "pratikvijayakar31",
                        "content": "I am confused. For example 1, why do we output \"oath\" and \"eat\". Since \"t\" alphabet is common in both strings and hence I believe it cannot be used for both words. Can someone clarify the rule \"The same letter cell may not be used more than once in a word.\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Pratik Vijayakar](/pratikvijayakar31) \"not be used more than once in a word\", t may be presented once in _previous_ \"oath\", then you should not count it on _new_ word search, i.e. \"eat\"!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "Test case 22 is evil.\n\nEdit: managed to pass it by removing nodes from the prefix tree once I've already seen it and it doesnt have any children of its own."
                    },
                    {
                        "username": "pankajnegi010795",
                        "content": "Can anybody tell that why my following code showing TLE and same code in java accepted all test cases.\\n java code ref  https://leetcode.com/problems/word-search-ii/solutions/59780/java-15ms-easiest-solution-100-00/\\n\\nMy code\\n\\nclass Solution {\\n    struct Node\\n    {\\n        Node * next[26];\\n       string isend;\\n    };\\npublic:\\n    Node * newnode()\\n    {\\n        Node * node=new Node();\\n        for(int i=0;i<26;i++)\\n        node->next[i]=nullptr;\\n        node->isend=\"\";\\n        return node;\\n    }\\n    void createtrie(Node* head,string s1)\\n    {\\n        for(int i=0;i<s1.length();i++)\\n        {\\n            if(head->next[s1[i]-\\'a\\']==nullptr)\\n            head->next[s1[i]-\\'a\\']=newnode();\\n            head=head->next[s1[i]-\\'a\\'];\\n        }\\n        head->isend=s1;\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n      vector<string> res;\\n       Node * head=newnode();\\n       unordered_set<string> ve;\\n        for(int i=0;i<words.size();i++)\\n       {\\n           createtrie(head,words[i]);\\n       }\\n\\n        \\n            for(int l=0;l<board.size();l++)\\n            {\\n                for(int m=0;m<board[0].size();m++)\\n                {\\n                   \\n             vector<vector<int>> vis(board.size(),vector<int>(board[0].size(),0));\\n                checkfor(board,l,m,vis,ve,head);\\n   \\n                }\\n           \\n            }\\n            for(auto i=ve.begin();i!=ve.end();i++)\\n            {\\n                res.push_back(*i);\\n            }\\n        \\n        return res;\\n        \\n    }\\n   void checkfor(vector<vector<char>>& b,int i,int j,vector<vector<int>> vis,unordered_set<string>&ve,Node* head)\\n    {\\n        if(i>=b.size() or i<0 or j<0 or j>=b[0].size() )\\n            return ;\\n       if(vis[i][j]==true)\\n            return ;\\n\\n        if(head->next[b[i][j]-\\'a\\']==nullptr)\\n        return ;\\n              head=head->next[b[i][j]-\\'a\\'];\\n        if(head->isend.size()>0)\\n        {\\n            ve.insert(head->isend);\\n            head->isend=\"\";\\n        }\\n        vis[i][j]=true;\\n       checkfor(b,i+1,j,vis,ve,head) ;\\n       checkfor(b,i,j+1,vis,ve,head);\\n        checkfor(b,i-1,j,vis,ve,head) ;\\n        checkfor(b,i,j-1,vis,ve,head);\\n\\n\\n        vis[i][j]=false;\\n       return ;\\n    }\\n};\\n"
                    },
                    {
                        "username": "nickpavini",
                        "content": "Here is a DP solution I am working on that currently passes 55 of 64 cases. It fails on the test:\\n\\n`board =\\n[[\"a\",\"a\"]]\\nwords =\\n[\"aaa\"]\\nExpected = \\n[]`\\n\\nBasically we break words down and check if the left overs have been found and if this current letter is next to a location of the rest of the word.\\n\\nThe issue I have right now with that test case, is that after `aa` is found going 2 directions, the third `a` doesnt realize that we have overlap.\\n\\nAny ideas on a way to close off this solution?\\n\\n```\\ndef findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        if not board:\\n            return []\\n\\n        rtn = []\\n        memo = {}\\n        for word in words:\\n            self.dp(board, word, memo)\\n            if not (-1,-1) in memo[word]:\\n                rtn.append(word)        \\n        return rtn\\n\\n    def dp(self, board, word,  memo):\\n        if word in memo:\\n            return\\n\\n        leftOver = word[1:]\\n        if leftOver != \\'\\':\\n            self.dp(board, leftOver, memo)\\n            if (-1, -1) in memo[leftOver]:\\n                memo[word] = {(-1,-1): 1}\\n                return\\n\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == word[0]:\\n                    if leftOver == \\'\\' or (i,j+1) in memo[leftOver] or (i,j-1) in memo[leftOver] or (i+1,j) in memo[leftOver] or (i-1,j) in memo[leftOver]:\\n                        if word in memo:\\n                            memo[word][(i,j)] = 1\\n                        else:\\n                            memo[word] = {(i,j): 1}\\n                    \\n\\n        if not word in memo:\\n            memo[word] = {(-1,-1): 1}\\n```"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I dont really understand how a trie is faster than a set. I was able to get my python version running with a set of acceptable prefixes... once. Everytime after that I got TLE. But isnt a tree pretty much a hashed set anyhow? I thought set lookups were O(1). I dont understand how looking up a given prefix in the Trie, returning a small set of acceptable \"following\" letters, and comparing neighbors to the current cell to see if they fall in this set is any different than looking up the entire prefix so far + one of the neighbors in a big list of acceptable prefixes. Both involve at least one set check, and as a hashed structure, should take the same amount of time? Similarly, how does pruning help? It doesnt take less time to find inclusion in a hashed set if the set is smaller I thought? Look ups HASH the target and see if it exists, regardless of other hashed values: its the entire point of hashing, so look ups are O(1)"
                    },
                    {
                        "username": "palakons",
                        "content": "pruning helps, and prefix \"set\" would work f you could prune the prefix set... which is difficult"
                    },
                    {
                        "username": "drap5468",
                        "content": "The way pruning works for this problem is you *entirely* remove a word you already visited, including its prefixes. That way in future traversal you'll know to stop if the only valid route remaining leads to a used word.\n\nIf you never prune, that means you keep traversing routes that are no longer useful to you. Specifically in your code, the condition to continue down a path is whether the current sequence is in prefix_set. Since you never update prefix_set, you end up with a lot of very expensive false positives, going down paths that *used to be* relevant, but no longer are, since that word has been used up.\n\nI agree that your hashing method probably simulates a trie closely enough to work for this problem, so if you implement pruning I bet it will consistently finish running on time."
                    },
                    {
                        "username": "siseendri",
                        "content": " @ `your inline code...your inline code...` `your inline code...your inline code...` @"
                    },
                    {
                        "username": "Ar_2000",
                        "content": "can anyone help me why am I getting TLE for this solution -\\n\\n  class trieNode {\\n    public:\\n        char ch;\\n        vector<trieNode*> child;\\n        bool isEnd;\\n\\n        trieNode() {\\n            for (int i = 0; i < 26; i++) {\\n                child.push_back(NULL);\\n            }\\n\\n            isEnd = false;\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> change = {{0,1},{1,0},{0,-1},{-1,0}};\\n    void buildTrie (trieNode* root, string& s, int i) {\\n        if (i == s.size()) {\\n            root->isEnd = true;\\n            return;\\n        }\\n\\n        trieNode* child = new trieNode();\\n        if (root->child[s[i]-\\'a\\'] == NULL) {\\n            child->ch = s[i];\\n            root->child[s[i]-\\'a\\'] = child;\\n        } else {\\n            child = root->child[s[i]-\\'a\\'];\\n        }\\n\\n        buildTrie(child, s, i+1);\\n    }\\n\\n    void p (vector<vector<char>>& b, int i, int j, trieNode* node, set<string>& ans, string& str) {\\n        int n = b.size(), m = b[0].size();\\n        str += node->ch;\\n\\n        b[i][j] = \\'?\\';\\n\\n        if (node->isEnd) ans.insert(str);\\n\\n        for (vector<int> a : change) {\\n            int nx = i+a[0], ny = j+a[1];\\n            if (nx >= 0 && nx < n && ny >= 0 && ny < m && b[nx][ny] != \\'?\\') {\\n                if (node->child[b[nx][ny]-\\'a\\'] != NULL)  p (b, nx, ny, node->child[b[nx][ny]-\\'a\\'], ans, str);\\n            }\\n        }\\n\\n        b[i][j] = node->ch;\\n        str.pop_back();\\n    }\\n\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        // time complexity -> words.length * words[i].length = 3*(10^5)\\n        trieNode* root = new trieNode();\\n        root->ch = \\'$\\';\\n        for (string& w : words) {\\n            buildTrie(root, w, 0);\\n        }\\n\\n        set<string> ans;\\n        int n = board.size(), m = board[0].size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                char ch = board[i][j];\\n                if (root->child[ch-\\'a\\'] != NULL) {\\n                    string str = \"\";\\n                    p(board, i, j, root->child[ch-\\'a\\'], ans, str);\\n                }\\n            }\\n        }\\n\\n        vector<string> res;\\n\\n        for (string s : ans) {\\n            res.push_back(s);\\n        }\\n\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "[@Ar_2000](/Ar_2000) I implemented in the similar way you did in java that gave me TLE when I implemented in the way I told you that accepted my solution. If you want I can give you my java based solution so that you can compare where you are going wrong."
                    },
                    {
                        "username": "Ar_2000",
                        "content": "[@nikhil97agra](/nikhil97agra) but it still gives tle. and it should be. Adding and poping in and from a string in O(1) operation only"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "I\\'m not sure but I think variable str you used to append character at each and every call that is causing you TLE.  Instead try this : instead isEnd variable in your class make it a string variable with initial value as null and when you are constructing your trie whenever some word ends just assign that variable to that word so what will happen is when you do recursion call to search for the word and you come at that trie node whose string variable is not null that means your word exist in the list in this way that extra overhead of appending and removing character from str variable will not be there."
                    }
                ]
            },
            {
                "id": 1714251,
                "content": [
                    {
                        "username": "ramadanizm",
                        "content": "What is the wrong with my solution ? why some test cases do not pass\\n```\\nclass TrieNode{\\n    Map<Character , TrieNode> children;\\n    boolean endOfWord;\\n\\n   public TrieNode(){ // no input  :) \\n        children = new HashMap<>();\\n        endOfWord = false;\\n   }\\n\\n    public void addWord(String word) {\\n        TrieNode curr = this;\\n        for(char c : word.toCharArray() ){\\n            if (curr.children.get(c) == null){\\n                curr.children.put(c , new TrieNode());\\n            }\\n            curr = curr.children.get(c);\\n        }\\n        curr.endOfWord = true;\\n    }\\n}\\n    \\nclass Solution {\\n    static final int[][] DIRECTIONS = new int [][]{{1,0} , {-1,0} , {0,1}, {0,-1}};\\n         public List<String> findWords(char[][] board, String[] words) {\\n            int rows = board.length ; int cols = board[0].length;\\n            TrieNode root = new TrieNode();\\n             for(String word : words){\\n                root.addWord(word);\\n             }\\n\\n             boolean [][] visit  = new boolean[rows][cols];\\n             for(boolean[] row: visit)\\n                Arrays.fill(row , false);\\n           \\n\\n             Set<String> result  = new HashSet<>();\\n             for (int r= 0 ; r < rows ; r++){\\n                 for(int c= 0 ; c < cols ; c++){\\n\\n                     dfs(board , r, c , visit , new StringBuilder()  , result, root );\\n                 }\\n             }\\n         /*\\n            System.out.print(result );\\n            List<String> list = new ArrayList<>();\\n            for(String word:words){\\n                if (result.contains(word)){\\n                  list.add(word);  \\n                } \\n                    \\n            }\\n            */\\n            \\n             return new ArrayList<>(result);\\n             \\n\\n}\\n\\nvoid dfs(char[][] board, int r, int c ,boolean [][] visit , StringBuilder path ,  Set<String>  result, TrieNode root   ){\\n\\nif (outOfBound(board  , r, c) || visit[r][c] || root.children.get(board[r][c])  == null){\\n    return ;\\n}\\n\\npath.append(board[r][c]);\\nvisit[r][c] = true;\\nroot = root.children.get(board[r][c]);\\nif (root.endOfWord){\\n    result.add(path.toString());\\n}\\n\\nfor(int[] dir:DIRECTIONS){\\n    dfs(board, r+ dir[0] , c+dir[1] , visit, path,result ,root );\\n}\\n\\nvisit[r][c] = false; // the c could be used in another path (backtracking )\\n\\n}\\n\\nprivate boolean outOfBound(char [][] board , int r , int c){\\n    if ( r < 0 || c < 0 || r >= board.length || c >= board[0].length){\\n        return true;\\n    }\\n    return false;\\n}\\n\\n}\\n```"
                    },
                    {
                        "username": "ababuji",
                        "content": "Language specific TLE  shouldn\\'t be happening. I see asymptotic time complexities being the same regardless of whether the solution is being implemented in Python or Java. \\n\\n"
                    },
                    {
                        "username": "heckervarun",
                        "content": "guys i\\'m getting TLE , can anyone give me some reason why ?, i used dfs on the matrix, any idea to reduce time complexity ?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@VaruN](/heckervarun) Trie, or you need to improve your dfs function if you dont want to use Trie-dic/set.\\nHope you will get new ideas for dfs algorithm, I would like to share my solution on Python3 for 2 direction searchs.\\nhttps://leetcode.com/problems/word-search-ii/solutions/2998236/dfs-no-trie-python-3-path-following-beats-96-12-95-0/"
                    },
                    {
                        "username": "pratikvijayakar31",
                        "content": "I am confused. For example 1, why do we output \"oath\" and \"eat\". Since \"t\" alphabet is common in both strings and hence I believe it cannot be used for both words. Can someone clarify the rule \"The same letter cell may not be used more than once in a word.\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Pratik Vijayakar](/pratikvijayakar31) \"not be used more than once in a word\", t may be presented once in _previous_ \"oath\", then you should not count it on _new_ word search, i.e. \"eat\"!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "Test case 22 is evil.\n\nEdit: managed to pass it by removing nodes from the prefix tree once I've already seen it and it doesnt have any children of its own."
                    },
                    {
                        "username": "pankajnegi010795",
                        "content": "Can anybody tell that why my following code showing TLE and same code in java accepted all test cases.\\n java code ref  https://leetcode.com/problems/word-search-ii/solutions/59780/java-15ms-easiest-solution-100-00/\\n\\nMy code\\n\\nclass Solution {\\n    struct Node\\n    {\\n        Node * next[26];\\n       string isend;\\n    };\\npublic:\\n    Node * newnode()\\n    {\\n        Node * node=new Node();\\n        for(int i=0;i<26;i++)\\n        node->next[i]=nullptr;\\n        node->isend=\"\";\\n        return node;\\n    }\\n    void createtrie(Node* head,string s1)\\n    {\\n        for(int i=0;i<s1.length();i++)\\n        {\\n            if(head->next[s1[i]-\\'a\\']==nullptr)\\n            head->next[s1[i]-\\'a\\']=newnode();\\n            head=head->next[s1[i]-\\'a\\'];\\n        }\\n        head->isend=s1;\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n      vector<string> res;\\n       Node * head=newnode();\\n       unordered_set<string> ve;\\n        for(int i=0;i<words.size();i++)\\n       {\\n           createtrie(head,words[i]);\\n       }\\n\\n        \\n            for(int l=0;l<board.size();l++)\\n            {\\n                for(int m=0;m<board[0].size();m++)\\n                {\\n                   \\n             vector<vector<int>> vis(board.size(),vector<int>(board[0].size(),0));\\n                checkfor(board,l,m,vis,ve,head);\\n   \\n                }\\n           \\n            }\\n            for(auto i=ve.begin();i!=ve.end();i++)\\n            {\\n                res.push_back(*i);\\n            }\\n        \\n        return res;\\n        \\n    }\\n   void checkfor(vector<vector<char>>& b,int i,int j,vector<vector<int>> vis,unordered_set<string>&ve,Node* head)\\n    {\\n        if(i>=b.size() or i<0 or j<0 or j>=b[0].size() )\\n            return ;\\n       if(vis[i][j]==true)\\n            return ;\\n\\n        if(head->next[b[i][j]-\\'a\\']==nullptr)\\n        return ;\\n              head=head->next[b[i][j]-\\'a\\'];\\n        if(head->isend.size()>0)\\n        {\\n            ve.insert(head->isend);\\n            head->isend=\"\";\\n        }\\n        vis[i][j]=true;\\n       checkfor(b,i+1,j,vis,ve,head) ;\\n       checkfor(b,i,j+1,vis,ve,head);\\n        checkfor(b,i-1,j,vis,ve,head) ;\\n        checkfor(b,i,j-1,vis,ve,head);\\n\\n\\n        vis[i][j]=false;\\n       return ;\\n    }\\n};\\n"
                    },
                    {
                        "username": "nickpavini",
                        "content": "Here is a DP solution I am working on that currently passes 55 of 64 cases. It fails on the test:\\n\\n`board =\\n[[\"a\",\"a\"]]\\nwords =\\n[\"aaa\"]\\nExpected = \\n[]`\\n\\nBasically we break words down and check if the left overs have been found and if this current letter is next to a location of the rest of the word.\\n\\nThe issue I have right now with that test case, is that after `aa` is found going 2 directions, the third `a` doesnt realize that we have overlap.\\n\\nAny ideas on a way to close off this solution?\\n\\n```\\ndef findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        if not board:\\n            return []\\n\\n        rtn = []\\n        memo = {}\\n        for word in words:\\n            self.dp(board, word, memo)\\n            if not (-1,-1) in memo[word]:\\n                rtn.append(word)        \\n        return rtn\\n\\n    def dp(self, board, word,  memo):\\n        if word in memo:\\n            return\\n\\n        leftOver = word[1:]\\n        if leftOver != \\'\\':\\n            self.dp(board, leftOver, memo)\\n            if (-1, -1) in memo[leftOver]:\\n                memo[word] = {(-1,-1): 1}\\n                return\\n\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == word[0]:\\n                    if leftOver == \\'\\' or (i,j+1) in memo[leftOver] or (i,j-1) in memo[leftOver] or (i+1,j) in memo[leftOver] or (i-1,j) in memo[leftOver]:\\n                        if word in memo:\\n                            memo[word][(i,j)] = 1\\n                        else:\\n                            memo[word] = {(i,j): 1}\\n                    \\n\\n        if not word in memo:\\n            memo[word] = {(-1,-1): 1}\\n```"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I dont really understand how a trie is faster than a set. I was able to get my python version running with a set of acceptable prefixes... once. Everytime after that I got TLE. But isnt a tree pretty much a hashed set anyhow? I thought set lookups were O(1). I dont understand how looking up a given prefix in the Trie, returning a small set of acceptable \"following\" letters, and comparing neighbors to the current cell to see if they fall in this set is any different than looking up the entire prefix so far + one of the neighbors in a big list of acceptable prefixes. Both involve at least one set check, and as a hashed structure, should take the same amount of time? Similarly, how does pruning help? It doesnt take less time to find inclusion in a hashed set if the set is smaller I thought? Look ups HASH the target and see if it exists, regardless of other hashed values: its the entire point of hashing, so look ups are O(1)"
                    },
                    {
                        "username": "palakons",
                        "content": "pruning helps, and prefix \"set\" would work f you could prune the prefix set... which is difficult"
                    },
                    {
                        "username": "drap5468",
                        "content": "The way pruning works for this problem is you *entirely* remove a word you already visited, including its prefixes. That way in future traversal you'll know to stop if the only valid route remaining leads to a used word.\n\nIf you never prune, that means you keep traversing routes that are no longer useful to you. Specifically in your code, the condition to continue down a path is whether the current sequence is in prefix_set. Since you never update prefix_set, you end up with a lot of very expensive false positives, going down paths that *used to be* relevant, but no longer are, since that word has been used up.\n\nI agree that your hashing method probably simulates a trie closely enough to work for this problem, so if you implement pruning I bet it will consistently finish running on time."
                    },
                    {
                        "username": "siseendri",
                        "content": " @ `your inline code...your inline code...` `your inline code...your inline code...` @"
                    },
                    {
                        "username": "Ar_2000",
                        "content": "can anyone help me why am I getting TLE for this solution -\\n\\n  class trieNode {\\n    public:\\n        char ch;\\n        vector<trieNode*> child;\\n        bool isEnd;\\n\\n        trieNode() {\\n            for (int i = 0; i < 26; i++) {\\n                child.push_back(NULL);\\n            }\\n\\n            isEnd = false;\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> change = {{0,1},{1,0},{0,-1},{-1,0}};\\n    void buildTrie (trieNode* root, string& s, int i) {\\n        if (i == s.size()) {\\n            root->isEnd = true;\\n            return;\\n        }\\n\\n        trieNode* child = new trieNode();\\n        if (root->child[s[i]-\\'a\\'] == NULL) {\\n            child->ch = s[i];\\n            root->child[s[i]-\\'a\\'] = child;\\n        } else {\\n            child = root->child[s[i]-\\'a\\'];\\n        }\\n\\n        buildTrie(child, s, i+1);\\n    }\\n\\n    void p (vector<vector<char>>& b, int i, int j, trieNode* node, set<string>& ans, string& str) {\\n        int n = b.size(), m = b[0].size();\\n        str += node->ch;\\n\\n        b[i][j] = \\'?\\';\\n\\n        if (node->isEnd) ans.insert(str);\\n\\n        for (vector<int> a : change) {\\n            int nx = i+a[0], ny = j+a[1];\\n            if (nx >= 0 && nx < n && ny >= 0 && ny < m && b[nx][ny] != \\'?\\') {\\n                if (node->child[b[nx][ny]-\\'a\\'] != NULL)  p (b, nx, ny, node->child[b[nx][ny]-\\'a\\'], ans, str);\\n            }\\n        }\\n\\n        b[i][j] = node->ch;\\n        str.pop_back();\\n    }\\n\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        // time complexity -> words.length * words[i].length = 3*(10^5)\\n        trieNode* root = new trieNode();\\n        root->ch = \\'$\\';\\n        for (string& w : words) {\\n            buildTrie(root, w, 0);\\n        }\\n\\n        set<string> ans;\\n        int n = board.size(), m = board[0].size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                char ch = board[i][j];\\n                if (root->child[ch-\\'a\\'] != NULL) {\\n                    string str = \"\";\\n                    p(board, i, j, root->child[ch-\\'a\\'], ans, str);\\n                }\\n            }\\n        }\\n\\n        vector<string> res;\\n\\n        for (string s : ans) {\\n            res.push_back(s);\\n        }\\n\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "[@Ar_2000](/Ar_2000) I implemented in the similar way you did in java that gave me TLE when I implemented in the way I told you that accepted my solution. If you want I can give you my java based solution so that you can compare where you are going wrong."
                    },
                    {
                        "username": "Ar_2000",
                        "content": "[@nikhil97agra](/nikhil97agra) but it still gives tle. and it should be. Adding and poping in and from a string in O(1) operation only"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "I\\'m not sure but I think variable str you used to append character at each and every call that is causing you TLE.  Instead try this : instead isEnd variable in your class make it a string variable with initial value as null and when you are constructing your trie whenever some word ends just assign that variable to that word so what will happen is when you do recursion call to search for the word and you come at that trie node whose string variable is not null that means your word exist in the list in this way that extra overhead of appending and removing character from str variable will not be there."
                    }
                ]
            },
            {
                "id": 1702647,
                "content": [
                    {
                        "username": "ramadanizm",
                        "content": "What is the wrong with my solution ? why some test cases do not pass\\n```\\nclass TrieNode{\\n    Map<Character , TrieNode> children;\\n    boolean endOfWord;\\n\\n   public TrieNode(){ // no input  :) \\n        children = new HashMap<>();\\n        endOfWord = false;\\n   }\\n\\n    public void addWord(String word) {\\n        TrieNode curr = this;\\n        for(char c : word.toCharArray() ){\\n            if (curr.children.get(c) == null){\\n                curr.children.put(c , new TrieNode());\\n            }\\n            curr = curr.children.get(c);\\n        }\\n        curr.endOfWord = true;\\n    }\\n}\\n    \\nclass Solution {\\n    static final int[][] DIRECTIONS = new int [][]{{1,0} , {-1,0} , {0,1}, {0,-1}};\\n         public List<String> findWords(char[][] board, String[] words) {\\n            int rows = board.length ; int cols = board[0].length;\\n            TrieNode root = new TrieNode();\\n             for(String word : words){\\n                root.addWord(word);\\n             }\\n\\n             boolean [][] visit  = new boolean[rows][cols];\\n             for(boolean[] row: visit)\\n                Arrays.fill(row , false);\\n           \\n\\n             Set<String> result  = new HashSet<>();\\n             for (int r= 0 ; r < rows ; r++){\\n                 for(int c= 0 ; c < cols ; c++){\\n\\n                     dfs(board , r, c , visit , new StringBuilder()  , result, root );\\n                 }\\n             }\\n         /*\\n            System.out.print(result );\\n            List<String> list = new ArrayList<>();\\n            for(String word:words){\\n                if (result.contains(word)){\\n                  list.add(word);  \\n                } \\n                    \\n            }\\n            */\\n            \\n             return new ArrayList<>(result);\\n             \\n\\n}\\n\\nvoid dfs(char[][] board, int r, int c ,boolean [][] visit , StringBuilder path ,  Set<String>  result, TrieNode root   ){\\n\\nif (outOfBound(board  , r, c) || visit[r][c] || root.children.get(board[r][c])  == null){\\n    return ;\\n}\\n\\npath.append(board[r][c]);\\nvisit[r][c] = true;\\nroot = root.children.get(board[r][c]);\\nif (root.endOfWord){\\n    result.add(path.toString());\\n}\\n\\nfor(int[] dir:DIRECTIONS){\\n    dfs(board, r+ dir[0] , c+dir[1] , visit, path,result ,root );\\n}\\n\\nvisit[r][c] = false; // the c could be used in another path (backtracking )\\n\\n}\\n\\nprivate boolean outOfBound(char [][] board , int r , int c){\\n    if ( r < 0 || c < 0 || r >= board.length || c >= board[0].length){\\n        return true;\\n    }\\n    return false;\\n}\\n\\n}\\n```"
                    },
                    {
                        "username": "ababuji",
                        "content": "Language specific TLE  shouldn\\'t be happening. I see asymptotic time complexities being the same regardless of whether the solution is being implemented in Python or Java. \\n\\n"
                    },
                    {
                        "username": "heckervarun",
                        "content": "guys i\\'m getting TLE , can anyone give me some reason why ?, i used dfs on the matrix, any idea to reduce time complexity ?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@VaruN](/heckervarun) Trie, or you need to improve your dfs function if you dont want to use Trie-dic/set.\\nHope you will get new ideas for dfs algorithm, I would like to share my solution on Python3 for 2 direction searchs.\\nhttps://leetcode.com/problems/word-search-ii/solutions/2998236/dfs-no-trie-python-3-path-following-beats-96-12-95-0/"
                    },
                    {
                        "username": "pratikvijayakar31",
                        "content": "I am confused. For example 1, why do we output \"oath\" and \"eat\". Since \"t\" alphabet is common in both strings and hence I believe it cannot be used for both words. Can someone clarify the rule \"The same letter cell may not be used more than once in a word.\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Pratik Vijayakar](/pratikvijayakar31) \"not be used more than once in a word\", t may be presented once in _previous_ \"oath\", then you should not count it on _new_ word search, i.e. \"eat\"!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "Test case 22 is evil.\n\nEdit: managed to pass it by removing nodes from the prefix tree once I've already seen it and it doesnt have any children of its own."
                    },
                    {
                        "username": "pankajnegi010795",
                        "content": "Can anybody tell that why my following code showing TLE and same code in java accepted all test cases.\\n java code ref  https://leetcode.com/problems/word-search-ii/solutions/59780/java-15ms-easiest-solution-100-00/\\n\\nMy code\\n\\nclass Solution {\\n    struct Node\\n    {\\n        Node * next[26];\\n       string isend;\\n    };\\npublic:\\n    Node * newnode()\\n    {\\n        Node * node=new Node();\\n        for(int i=0;i<26;i++)\\n        node->next[i]=nullptr;\\n        node->isend=\"\";\\n        return node;\\n    }\\n    void createtrie(Node* head,string s1)\\n    {\\n        for(int i=0;i<s1.length();i++)\\n        {\\n            if(head->next[s1[i]-\\'a\\']==nullptr)\\n            head->next[s1[i]-\\'a\\']=newnode();\\n            head=head->next[s1[i]-\\'a\\'];\\n        }\\n        head->isend=s1;\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n      vector<string> res;\\n       Node * head=newnode();\\n       unordered_set<string> ve;\\n        for(int i=0;i<words.size();i++)\\n       {\\n           createtrie(head,words[i]);\\n       }\\n\\n        \\n            for(int l=0;l<board.size();l++)\\n            {\\n                for(int m=0;m<board[0].size();m++)\\n                {\\n                   \\n             vector<vector<int>> vis(board.size(),vector<int>(board[0].size(),0));\\n                checkfor(board,l,m,vis,ve,head);\\n   \\n                }\\n           \\n            }\\n            for(auto i=ve.begin();i!=ve.end();i++)\\n            {\\n                res.push_back(*i);\\n            }\\n        \\n        return res;\\n        \\n    }\\n   void checkfor(vector<vector<char>>& b,int i,int j,vector<vector<int>> vis,unordered_set<string>&ve,Node* head)\\n    {\\n        if(i>=b.size() or i<0 or j<0 or j>=b[0].size() )\\n            return ;\\n       if(vis[i][j]==true)\\n            return ;\\n\\n        if(head->next[b[i][j]-\\'a\\']==nullptr)\\n        return ;\\n              head=head->next[b[i][j]-\\'a\\'];\\n        if(head->isend.size()>0)\\n        {\\n            ve.insert(head->isend);\\n            head->isend=\"\";\\n        }\\n        vis[i][j]=true;\\n       checkfor(b,i+1,j,vis,ve,head) ;\\n       checkfor(b,i,j+1,vis,ve,head);\\n        checkfor(b,i-1,j,vis,ve,head) ;\\n        checkfor(b,i,j-1,vis,ve,head);\\n\\n\\n        vis[i][j]=false;\\n       return ;\\n    }\\n};\\n"
                    },
                    {
                        "username": "nickpavini",
                        "content": "Here is a DP solution I am working on that currently passes 55 of 64 cases. It fails on the test:\\n\\n`board =\\n[[\"a\",\"a\"]]\\nwords =\\n[\"aaa\"]\\nExpected = \\n[]`\\n\\nBasically we break words down and check if the left overs have been found and if this current letter is next to a location of the rest of the word.\\n\\nThe issue I have right now with that test case, is that after `aa` is found going 2 directions, the third `a` doesnt realize that we have overlap.\\n\\nAny ideas on a way to close off this solution?\\n\\n```\\ndef findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        if not board:\\n            return []\\n\\n        rtn = []\\n        memo = {}\\n        for word in words:\\n            self.dp(board, word, memo)\\n            if not (-1,-1) in memo[word]:\\n                rtn.append(word)        \\n        return rtn\\n\\n    def dp(self, board, word,  memo):\\n        if word in memo:\\n            return\\n\\n        leftOver = word[1:]\\n        if leftOver != \\'\\':\\n            self.dp(board, leftOver, memo)\\n            if (-1, -1) in memo[leftOver]:\\n                memo[word] = {(-1,-1): 1}\\n                return\\n\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == word[0]:\\n                    if leftOver == \\'\\' or (i,j+1) in memo[leftOver] or (i,j-1) in memo[leftOver] or (i+1,j) in memo[leftOver] or (i-1,j) in memo[leftOver]:\\n                        if word in memo:\\n                            memo[word][(i,j)] = 1\\n                        else:\\n                            memo[word] = {(i,j): 1}\\n                    \\n\\n        if not word in memo:\\n            memo[word] = {(-1,-1): 1}\\n```"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I dont really understand how a trie is faster than a set. I was able to get my python version running with a set of acceptable prefixes... once. Everytime after that I got TLE. But isnt a tree pretty much a hashed set anyhow? I thought set lookups were O(1). I dont understand how looking up a given prefix in the Trie, returning a small set of acceptable \"following\" letters, and comparing neighbors to the current cell to see if they fall in this set is any different than looking up the entire prefix so far + one of the neighbors in a big list of acceptable prefixes. Both involve at least one set check, and as a hashed structure, should take the same amount of time? Similarly, how does pruning help? It doesnt take less time to find inclusion in a hashed set if the set is smaller I thought? Look ups HASH the target and see if it exists, regardless of other hashed values: its the entire point of hashing, so look ups are O(1)"
                    },
                    {
                        "username": "palakons",
                        "content": "pruning helps, and prefix \"set\" would work f you could prune the prefix set... which is difficult"
                    },
                    {
                        "username": "drap5468",
                        "content": "The way pruning works for this problem is you *entirely* remove a word you already visited, including its prefixes. That way in future traversal you'll know to stop if the only valid route remaining leads to a used word.\n\nIf you never prune, that means you keep traversing routes that are no longer useful to you. Specifically in your code, the condition to continue down a path is whether the current sequence is in prefix_set. Since you never update prefix_set, you end up with a lot of very expensive false positives, going down paths that *used to be* relevant, but no longer are, since that word has been used up.\n\nI agree that your hashing method probably simulates a trie closely enough to work for this problem, so if you implement pruning I bet it will consistently finish running on time."
                    },
                    {
                        "username": "siseendri",
                        "content": " @ `your inline code...your inline code...` `your inline code...your inline code...` @"
                    },
                    {
                        "username": "Ar_2000",
                        "content": "can anyone help me why am I getting TLE for this solution -\\n\\n  class trieNode {\\n    public:\\n        char ch;\\n        vector<trieNode*> child;\\n        bool isEnd;\\n\\n        trieNode() {\\n            for (int i = 0; i < 26; i++) {\\n                child.push_back(NULL);\\n            }\\n\\n            isEnd = false;\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> change = {{0,1},{1,0},{0,-1},{-1,0}};\\n    void buildTrie (trieNode* root, string& s, int i) {\\n        if (i == s.size()) {\\n            root->isEnd = true;\\n            return;\\n        }\\n\\n        trieNode* child = new trieNode();\\n        if (root->child[s[i]-\\'a\\'] == NULL) {\\n            child->ch = s[i];\\n            root->child[s[i]-\\'a\\'] = child;\\n        } else {\\n            child = root->child[s[i]-\\'a\\'];\\n        }\\n\\n        buildTrie(child, s, i+1);\\n    }\\n\\n    void p (vector<vector<char>>& b, int i, int j, trieNode* node, set<string>& ans, string& str) {\\n        int n = b.size(), m = b[0].size();\\n        str += node->ch;\\n\\n        b[i][j] = \\'?\\';\\n\\n        if (node->isEnd) ans.insert(str);\\n\\n        for (vector<int> a : change) {\\n            int nx = i+a[0], ny = j+a[1];\\n            if (nx >= 0 && nx < n && ny >= 0 && ny < m && b[nx][ny] != \\'?\\') {\\n                if (node->child[b[nx][ny]-\\'a\\'] != NULL)  p (b, nx, ny, node->child[b[nx][ny]-\\'a\\'], ans, str);\\n            }\\n        }\\n\\n        b[i][j] = node->ch;\\n        str.pop_back();\\n    }\\n\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        // time complexity -> words.length * words[i].length = 3*(10^5)\\n        trieNode* root = new trieNode();\\n        root->ch = \\'$\\';\\n        for (string& w : words) {\\n            buildTrie(root, w, 0);\\n        }\\n\\n        set<string> ans;\\n        int n = board.size(), m = board[0].size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                char ch = board[i][j];\\n                if (root->child[ch-\\'a\\'] != NULL) {\\n                    string str = \"\";\\n                    p(board, i, j, root->child[ch-\\'a\\'], ans, str);\\n                }\\n            }\\n        }\\n\\n        vector<string> res;\\n\\n        for (string s : ans) {\\n            res.push_back(s);\\n        }\\n\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "[@Ar_2000](/Ar_2000) I implemented in the similar way you did in java that gave me TLE when I implemented in the way I told you that accepted my solution. If you want I can give you my java based solution so that you can compare where you are going wrong."
                    },
                    {
                        "username": "Ar_2000",
                        "content": "[@nikhil97agra](/nikhil97agra) but it still gives tle. and it should be. Adding and poping in and from a string in O(1) operation only"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "I\\'m not sure but I think variable str you used to append character at each and every call that is causing you TLE.  Instead try this : instead isEnd variable in your class make it a string variable with initial value as null and when you are constructing your trie whenever some word ends just assign that variable to that word so what will happen is when you do recursion call to search for the word and you come at that trie node whose string variable is not null that means your word exist in the list in this way that extra overhead of appending and removing character from str variable will not be there."
                    }
                ]
            },
            {
                "id": 1676756,
                "content": [
                    {
                        "username": "ramadanizm",
                        "content": "What is the wrong with my solution ? why some test cases do not pass\\n```\\nclass TrieNode{\\n    Map<Character , TrieNode> children;\\n    boolean endOfWord;\\n\\n   public TrieNode(){ // no input  :) \\n        children = new HashMap<>();\\n        endOfWord = false;\\n   }\\n\\n    public void addWord(String word) {\\n        TrieNode curr = this;\\n        for(char c : word.toCharArray() ){\\n            if (curr.children.get(c) == null){\\n                curr.children.put(c , new TrieNode());\\n            }\\n            curr = curr.children.get(c);\\n        }\\n        curr.endOfWord = true;\\n    }\\n}\\n    \\nclass Solution {\\n    static final int[][] DIRECTIONS = new int [][]{{1,0} , {-1,0} , {0,1}, {0,-1}};\\n         public List<String> findWords(char[][] board, String[] words) {\\n            int rows = board.length ; int cols = board[0].length;\\n            TrieNode root = new TrieNode();\\n             for(String word : words){\\n                root.addWord(word);\\n             }\\n\\n             boolean [][] visit  = new boolean[rows][cols];\\n             for(boolean[] row: visit)\\n                Arrays.fill(row , false);\\n           \\n\\n             Set<String> result  = new HashSet<>();\\n             for (int r= 0 ; r < rows ; r++){\\n                 for(int c= 0 ; c < cols ; c++){\\n\\n                     dfs(board , r, c , visit , new StringBuilder()  , result, root );\\n                 }\\n             }\\n         /*\\n            System.out.print(result );\\n            List<String> list = new ArrayList<>();\\n            for(String word:words){\\n                if (result.contains(word)){\\n                  list.add(word);  \\n                } \\n                    \\n            }\\n            */\\n            \\n             return new ArrayList<>(result);\\n             \\n\\n}\\n\\nvoid dfs(char[][] board, int r, int c ,boolean [][] visit , StringBuilder path ,  Set<String>  result, TrieNode root   ){\\n\\nif (outOfBound(board  , r, c) || visit[r][c] || root.children.get(board[r][c])  == null){\\n    return ;\\n}\\n\\npath.append(board[r][c]);\\nvisit[r][c] = true;\\nroot = root.children.get(board[r][c]);\\nif (root.endOfWord){\\n    result.add(path.toString());\\n}\\n\\nfor(int[] dir:DIRECTIONS){\\n    dfs(board, r+ dir[0] , c+dir[1] , visit, path,result ,root );\\n}\\n\\nvisit[r][c] = false; // the c could be used in another path (backtracking )\\n\\n}\\n\\nprivate boolean outOfBound(char [][] board , int r , int c){\\n    if ( r < 0 || c < 0 || r >= board.length || c >= board[0].length){\\n        return true;\\n    }\\n    return false;\\n}\\n\\n}\\n```"
                    },
                    {
                        "username": "ababuji",
                        "content": "Language specific TLE  shouldn\\'t be happening. I see asymptotic time complexities being the same regardless of whether the solution is being implemented in Python or Java. \\n\\n"
                    },
                    {
                        "username": "heckervarun",
                        "content": "guys i\\'m getting TLE , can anyone give me some reason why ?, i used dfs on the matrix, any idea to reduce time complexity ?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@VaruN](/heckervarun) Trie, or you need to improve your dfs function if you dont want to use Trie-dic/set.\\nHope you will get new ideas for dfs algorithm, I would like to share my solution on Python3 for 2 direction searchs.\\nhttps://leetcode.com/problems/word-search-ii/solutions/2998236/dfs-no-trie-python-3-path-following-beats-96-12-95-0/"
                    },
                    {
                        "username": "pratikvijayakar31",
                        "content": "I am confused. For example 1, why do we output \"oath\" and \"eat\". Since \"t\" alphabet is common in both strings and hence I believe it cannot be used for both words. Can someone clarify the rule \"The same letter cell may not be used more than once in a word.\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Pratik Vijayakar](/pratikvijayakar31) \"not be used more than once in a word\", t may be presented once in _previous_ \"oath\", then you should not count it on _new_ word search, i.e. \"eat\"!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "Test case 22 is evil.\n\nEdit: managed to pass it by removing nodes from the prefix tree once I've already seen it and it doesnt have any children of its own."
                    },
                    {
                        "username": "pankajnegi010795",
                        "content": "Can anybody tell that why my following code showing TLE and same code in java accepted all test cases.\\n java code ref  https://leetcode.com/problems/word-search-ii/solutions/59780/java-15ms-easiest-solution-100-00/\\n\\nMy code\\n\\nclass Solution {\\n    struct Node\\n    {\\n        Node * next[26];\\n       string isend;\\n    };\\npublic:\\n    Node * newnode()\\n    {\\n        Node * node=new Node();\\n        for(int i=0;i<26;i++)\\n        node->next[i]=nullptr;\\n        node->isend=\"\";\\n        return node;\\n    }\\n    void createtrie(Node* head,string s1)\\n    {\\n        for(int i=0;i<s1.length();i++)\\n        {\\n            if(head->next[s1[i]-\\'a\\']==nullptr)\\n            head->next[s1[i]-\\'a\\']=newnode();\\n            head=head->next[s1[i]-\\'a\\'];\\n        }\\n        head->isend=s1;\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n      vector<string> res;\\n       Node * head=newnode();\\n       unordered_set<string> ve;\\n        for(int i=0;i<words.size();i++)\\n       {\\n           createtrie(head,words[i]);\\n       }\\n\\n        \\n            for(int l=0;l<board.size();l++)\\n            {\\n                for(int m=0;m<board[0].size();m++)\\n                {\\n                   \\n             vector<vector<int>> vis(board.size(),vector<int>(board[0].size(),0));\\n                checkfor(board,l,m,vis,ve,head);\\n   \\n                }\\n           \\n            }\\n            for(auto i=ve.begin();i!=ve.end();i++)\\n            {\\n                res.push_back(*i);\\n            }\\n        \\n        return res;\\n        \\n    }\\n   void checkfor(vector<vector<char>>& b,int i,int j,vector<vector<int>> vis,unordered_set<string>&ve,Node* head)\\n    {\\n        if(i>=b.size() or i<0 or j<0 or j>=b[0].size() )\\n            return ;\\n       if(vis[i][j]==true)\\n            return ;\\n\\n        if(head->next[b[i][j]-\\'a\\']==nullptr)\\n        return ;\\n              head=head->next[b[i][j]-\\'a\\'];\\n        if(head->isend.size()>0)\\n        {\\n            ve.insert(head->isend);\\n            head->isend=\"\";\\n        }\\n        vis[i][j]=true;\\n       checkfor(b,i+1,j,vis,ve,head) ;\\n       checkfor(b,i,j+1,vis,ve,head);\\n        checkfor(b,i-1,j,vis,ve,head) ;\\n        checkfor(b,i,j-1,vis,ve,head);\\n\\n\\n        vis[i][j]=false;\\n       return ;\\n    }\\n};\\n"
                    },
                    {
                        "username": "nickpavini",
                        "content": "Here is a DP solution I am working on that currently passes 55 of 64 cases. It fails on the test:\\n\\n`board =\\n[[\"a\",\"a\"]]\\nwords =\\n[\"aaa\"]\\nExpected = \\n[]`\\n\\nBasically we break words down and check if the left overs have been found and if this current letter is next to a location of the rest of the word.\\n\\nThe issue I have right now with that test case, is that after `aa` is found going 2 directions, the third `a` doesnt realize that we have overlap.\\n\\nAny ideas on a way to close off this solution?\\n\\n```\\ndef findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        if not board:\\n            return []\\n\\n        rtn = []\\n        memo = {}\\n        for word in words:\\n            self.dp(board, word, memo)\\n            if not (-1,-1) in memo[word]:\\n                rtn.append(word)        \\n        return rtn\\n\\n    def dp(self, board, word,  memo):\\n        if word in memo:\\n            return\\n\\n        leftOver = word[1:]\\n        if leftOver != \\'\\':\\n            self.dp(board, leftOver, memo)\\n            if (-1, -1) in memo[leftOver]:\\n                memo[word] = {(-1,-1): 1}\\n                return\\n\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == word[0]:\\n                    if leftOver == \\'\\' or (i,j+1) in memo[leftOver] or (i,j-1) in memo[leftOver] or (i+1,j) in memo[leftOver] or (i-1,j) in memo[leftOver]:\\n                        if word in memo:\\n                            memo[word][(i,j)] = 1\\n                        else:\\n                            memo[word] = {(i,j): 1}\\n                    \\n\\n        if not word in memo:\\n            memo[word] = {(-1,-1): 1}\\n```"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I dont really understand how a trie is faster than a set. I was able to get my python version running with a set of acceptable prefixes... once. Everytime after that I got TLE. But isnt a tree pretty much a hashed set anyhow? I thought set lookups were O(1). I dont understand how looking up a given prefix in the Trie, returning a small set of acceptable \"following\" letters, and comparing neighbors to the current cell to see if they fall in this set is any different than looking up the entire prefix so far + one of the neighbors in a big list of acceptable prefixes. Both involve at least one set check, and as a hashed structure, should take the same amount of time? Similarly, how does pruning help? It doesnt take less time to find inclusion in a hashed set if the set is smaller I thought? Look ups HASH the target and see if it exists, regardless of other hashed values: its the entire point of hashing, so look ups are O(1)"
                    },
                    {
                        "username": "palakons",
                        "content": "pruning helps, and prefix \"set\" would work f you could prune the prefix set... which is difficult"
                    },
                    {
                        "username": "drap5468",
                        "content": "The way pruning works for this problem is you *entirely* remove a word you already visited, including its prefixes. That way in future traversal you'll know to stop if the only valid route remaining leads to a used word.\n\nIf you never prune, that means you keep traversing routes that are no longer useful to you. Specifically in your code, the condition to continue down a path is whether the current sequence is in prefix_set. Since you never update prefix_set, you end up with a lot of very expensive false positives, going down paths that *used to be* relevant, but no longer are, since that word has been used up.\n\nI agree that your hashing method probably simulates a trie closely enough to work for this problem, so if you implement pruning I bet it will consistently finish running on time."
                    },
                    {
                        "username": "siseendri",
                        "content": " @ `your inline code...your inline code...` `your inline code...your inline code...` @"
                    },
                    {
                        "username": "Ar_2000",
                        "content": "can anyone help me why am I getting TLE for this solution -\\n\\n  class trieNode {\\n    public:\\n        char ch;\\n        vector<trieNode*> child;\\n        bool isEnd;\\n\\n        trieNode() {\\n            for (int i = 0; i < 26; i++) {\\n                child.push_back(NULL);\\n            }\\n\\n            isEnd = false;\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> change = {{0,1},{1,0},{0,-1},{-1,0}};\\n    void buildTrie (trieNode* root, string& s, int i) {\\n        if (i == s.size()) {\\n            root->isEnd = true;\\n            return;\\n        }\\n\\n        trieNode* child = new trieNode();\\n        if (root->child[s[i]-\\'a\\'] == NULL) {\\n            child->ch = s[i];\\n            root->child[s[i]-\\'a\\'] = child;\\n        } else {\\n            child = root->child[s[i]-\\'a\\'];\\n        }\\n\\n        buildTrie(child, s, i+1);\\n    }\\n\\n    void p (vector<vector<char>>& b, int i, int j, trieNode* node, set<string>& ans, string& str) {\\n        int n = b.size(), m = b[0].size();\\n        str += node->ch;\\n\\n        b[i][j] = \\'?\\';\\n\\n        if (node->isEnd) ans.insert(str);\\n\\n        for (vector<int> a : change) {\\n            int nx = i+a[0], ny = j+a[1];\\n            if (nx >= 0 && nx < n && ny >= 0 && ny < m && b[nx][ny] != \\'?\\') {\\n                if (node->child[b[nx][ny]-\\'a\\'] != NULL)  p (b, nx, ny, node->child[b[nx][ny]-\\'a\\'], ans, str);\\n            }\\n        }\\n\\n        b[i][j] = node->ch;\\n        str.pop_back();\\n    }\\n\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        // time complexity -> words.length * words[i].length = 3*(10^5)\\n        trieNode* root = new trieNode();\\n        root->ch = \\'$\\';\\n        for (string& w : words) {\\n            buildTrie(root, w, 0);\\n        }\\n\\n        set<string> ans;\\n        int n = board.size(), m = board[0].size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                char ch = board[i][j];\\n                if (root->child[ch-\\'a\\'] != NULL) {\\n                    string str = \"\";\\n                    p(board, i, j, root->child[ch-\\'a\\'], ans, str);\\n                }\\n            }\\n        }\\n\\n        vector<string> res;\\n\\n        for (string s : ans) {\\n            res.push_back(s);\\n        }\\n\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "[@Ar_2000](/Ar_2000) I implemented in the similar way you did in java that gave me TLE when I implemented in the way I told you that accepted my solution. If you want I can give you my java based solution so that you can compare where you are going wrong."
                    },
                    {
                        "username": "Ar_2000",
                        "content": "[@nikhil97agra](/nikhil97agra) but it still gives tle. and it should be. Adding and poping in and from a string in O(1) operation only"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "I\\'m not sure but I think variable str you used to append character at each and every call that is causing you TLE.  Instead try this : instead isEnd variable in your class make it a string variable with initial value as null and when you are constructing your trie whenever some word ends just assign that variable to that word so what will happen is when you do recursion call to search for the word and you come at that trie node whose string variable is not null that means your word exist in the list in this way that extra overhead of appending and removing character from str variable will not be there."
                    }
                ]
            },
            {
                "id": 1672541,
                "content": [
                    {
                        "username": "ramadanizm",
                        "content": "What is the wrong with my solution ? why some test cases do not pass\\n```\\nclass TrieNode{\\n    Map<Character , TrieNode> children;\\n    boolean endOfWord;\\n\\n   public TrieNode(){ // no input  :) \\n        children = new HashMap<>();\\n        endOfWord = false;\\n   }\\n\\n    public void addWord(String word) {\\n        TrieNode curr = this;\\n        for(char c : word.toCharArray() ){\\n            if (curr.children.get(c) == null){\\n                curr.children.put(c , new TrieNode());\\n            }\\n            curr = curr.children.get(c);\\n        }\\n        curr.endOfWord = true;\\n    }\\n}\\n    \\nclass Solution {\\n    static final int[][] DIRECTIONS = new int [][]{{1,0} , {-1,0} , {0,1}, {0,-1}};\\n         public List<String> findWords(char[][] board, String[] words) {\\n            int rows = board.length ; int cols = board[0].length;\\n            TrieNode root = new TrieNode();\\n             for(String word : words){\\n                root.addWord(word);\\n             }\\n\\n             boolean [][] visit  = new boolean[rows][cols];\\n             for(boolean[] row: visit)\\n                Arrays.fill(row , false);\\n           \\n\\n             Set<String> result  = new HashSet<>();\\n             for (int r= 0 ; r < rows ; r++){\\n                 for(int c= 0 ; c < cols ; c++){\\n\\n                     dfs(board , r, c , visit , new StringBuilder()  , result, root );\\n                 }\\n             }\\n         /*\\n            System.out.print(result );\\n            List<String> list = new ArrayList<>();\\n            for(String word:words){\\n                if (result.contains(word)){\\n                  list.add(word);  \\n                } \\n                    \\n            }\\n            */\\n            \\n             return new ArrayList<>(result);\\n             \\n\\n}\\n\\nvoid dfs(char[][] board, int r, int c ,boolean [][] visit , StringBuilder path ,  Set<String>  result, TrieNode root   ){\\n\\nif (outOfBound(board  , r, c) || visit[r][c] || root.children.get(board[r][c])  == null){\\n    return ;\\n}\\n\\npath.append(board[r][c]);\\nvisit[r][c] = true;\\nroot = root.children.get(board[r][c]);\\nif (root.endOfWord){\\n    result.add(path.toString());\\n}\\n\\nfor(int[] dir:DIRECTIONS){\\n    dfs(board, r+ dir[0] , c+dir[1] , visit, path,result ,root );\\n}\\n\\nvisit[r][c] = false; // the c could be used in another path (backtracking )\\n\\n}\\n\\nprivate boolean outOfBound(char [][] board , int r , int c){\\n    if ( r < 0 || c < 0 || r >= board.length || c >= board[0].length){\\n        return true;\\n    }\\n    return false;\\n}\\n\\n}\\n```"
                    },
                    {
                        "username": "ababuji",
                        "content": "Language specific TLE  shouldn\\'t be happening. I see asymptotic time complexities being the same regardless of whether the solution is being implemented in Python or Java. \\n\\n"
                    },
                    {
                        "username": "heckervarun",
                        "content": "guys i\\'m getting TLE , can anyone give me some reason why ?, i used dfs on the matrix, any idea to reduce time complexity ?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@VaruN](/heckervarun) Trie, or you need to improve your dfs function if you dont want to use Trie-dic/set.\\nHope you will get new ideas for dfs algorithm, I would like to share my solution on Python3 for 2 direction searchs.\\nhttps://leetcode.com/problems/word-search-ii/solutions/2998236/dfs-no-trie-python-3-path-following-beats-96-12-95-0/"
                    },
                    {
                        "username": "pratikvijayakar31",
                        "content": "I am confused. For example 1, why do we output \"oath\" and \"eat\". Since \"t\" alphabet is common in both strings and hence I believe it cannot be used for both words. Can someone clarify the rule \"The same letter cell may not be used more than once in a word.\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Pratik Vijayakar](/pratikvijayakar31) \"not be used more than once in a word\", t may be presented once in _previous_ \"oath\", then you should not count it on _new_ word search, i.e. \"eat\"!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "Test case 22 is evil.\n\nEdit: managed to pass it by removing nodes from the prefix tree once I've already seen it and it doesnt have any children of its own."
                    },
                    {
                        "username": "pankajnegi010795",
                        "content": "Can anybody tell that why my following code showing TLE and same code in java accepted all test cases.\\n java code ref  https://leetcode.com/problems/word-search-ii/solutions/59780/java-15ms-easiest-solution-100-00/\\n\\nMy code\\n\\nclass Solution {\\n    struct Node\\n    {\\n        Node * next[26];\\n       string isend;\\n    };\\npublic:\\n    Node * newnode()\\n    {\\n        Node * node=new Node();\\n        for(int i=0;i<26;i++)\\n        node->next[i]=nullptr;\\n        node->isend=\"\";\\n        return node;\\n    }\\n    void createtrie(Node* head,string s1)\\n    {\\n        for(int i=0;i<s1.length();i++)\\n        {\\n            if(head->next[s1[i]-\\'a\\']==nullptr)\\n            head->next[s1[i]-\\'a\\']=newnode();\\n            head=head->next[s1[i]-\\'a\\'];\\n        }\\n        head->isend=s1;\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n      vector<string> res;\\n       Node * head=newnode();\\n       unordered_set<string> ve;\\n        for(int i=0;i<words.size();i++)\\n       {\\n           createtrie(head,words[i]);\\n       }\\n\\n        \\n            for(int l=0;l<board.size();l++)\\n            {\\n                for(int m=0;m<board[0].size();m++)\\n                {\\n                   \\n             vector<vector<int>> vis(board.size(),vector<int>(board[0].size(),0));\\n                checkfor(board,l,m,vis,ve,head);\\n   \\n                }\\n           \\n            }\\n            for(auto i=ve.begin();i!=ve.end();i++)\\n            {\\n                res.push_back(*i);\\n            }\\n        \\n        return res;\\n        \\n    }\\n   void checkfor(vector<vector<char>>& b,int i,int j,vector<vector<int>> vis,unordered_set<string>&ve,Node* head)\\n    {\\n        if(i>=b.size() or i<0 or j<0 or j>=b[0].size() )\\n            return ;\\n       if(vis[i][j]==true)\\n            return ;\\n\\n        if(head->next[b[i][j]-\\'a\\']==nullptr)\\n        return ;\\n              head=head->next[b[i][j]-\\'a\\'];\\n        if(head->isend.size()>0)\\n        {\\n            ve.insert(head->isend);\\n            head->isend=\"\";\\n        }\\n        vis[i][j]=true;\\n       checkfor(b,i+1,j,vis,ve,head) ;\\n       checkfor(b,i,j+1,vis,ve,head);\\n        checkfor(b,i-1,j,vis,ve,head) ;\\n        checkfor(b,i,j-1,vis,ve,head);\\n\\n\\n        vis[i][j]=false;\\n       return ;\\n    }\\n};\\n"
                    },
                    {
                        "username": "nickpavini",
                        "content": "Here is a DP solution I am working on that currently passes 55 of 64 cases. It fails on the test:\\n\\n`board =\\n[[\"a\",\"a\"]]\\nwords =\\n[\"aaa\"]\\nExpected = \\n[]`\\n\\nBasically we break words down and check if the left overs have been found and if this current letter is next to a location of the rest of the word.\\n\\nThe issue I have right now with that test case, is that after `aa` is found going 2 directions, the third `a` doesnt realize that we have overlap.\\n\\nAny ideas on a way to close off this solution?\\n\\n```\\ndef findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        if not board:\\n            return []\\n\\n        rtn = []\\n        memo = {}\\n        for word in words:\\n            self.dp(board, word, memo)\\n            if not (-1,-1) in memo[word]:\\n                rtn.append(word)        \\n        return rtn\\n\\n    def dp(self, board, word,  memo):\\n        if word in memo:\\n            return\\n\\n        leftOver = word[1:]\\n        if leftOver != \\'\\':\\n            self.dp(board, leftOver, memo)\\n            if (-1, -1) in memo[leftOver]:\\n                memo[word] = {(-1,-1): 1}\\n                return\\n\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == word[0]:\\n                    if leftOver == \\'\\' or (i,j+1) in memo[leftOver] or (i,j-1) in memo[leftOver] or (i+1,j) in memo[leftOver] or (i-1,j) in memo[leftOver]:\\n                        if word in memo:\\n                            memo[word][(i,j)] = 1\\n                        else:\\n                            memo[word] = {(i,j): 1}\\n                    \\n\\n        if not word in memo:\\n            memo[word] = {(-1,-1): 1}\\n```"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I dont really understand how a trie is faster than a set. I was able to get my python version running with a set of acceptable prefixes... once. Everytime after that I got TLE. But isnt a tree pretty much a hashed set anyhow? I thought set lookups were O(1). I dont understand how looking up a given prefix in the Trie, returning a small set of acceptable \"following\" letters, and comparing neighbors to the current cell to see if they fall in this set is any different than looking up the entire prefix so far + one of the neighbors in a big list of acceptable prefixes. Both involve at least one set check, and as a hashed structure, should take the same amount of time? Similarly, how does pruning help? It doesnt take less time to find inclusion in a hashed set if the set is smaller I thought? Look ups HASH the target and see if it exists, regardless of other hashed values: its the entire point of hashing, so look ups are O(1)"
                    },
                    {
                        "username": "palakons",
                        "content": "pruning helps, and prefix \"set\" would work f you could prune the prefix set... which is difficult"
                    },
                    {
                        "username": "drap5468",
                        "content": "The way pruning works for this problem is you *entirely* remove a word you already visited, including its prefixes. That way in future traversal you'll know to stop if the only valid route remaining leads to a used word.\n\nIf you never prune, that means you keep traversing routes that are no longer useful to you. Specifically in your code, the condition to continue down a path is whether the current sequence is in prefix_set. Since you never update prefix_set, you end up with a lot of very expensive false positives, going down paths that *used to be* relevant, but no longer are, since that word has been used up.\n\nI agree that your hashing method probably simulates a trie closely enough to work for this problem, so if you implement pruning I bet it will consistently finish running on time."
                    },
                    {
                        "username": "siseendri",
                        "content": " @ `your inline code...your inline code...` `your inline code...your inline code...` @"
                    },
                    {
                        "username": "Ar_2000",
                        "content": "can anyone help me why am I getting TLE for this solution -\\n\\n  class trieNode {\\n    public:\\n        char ch;\\n        vector<trieNode*> child;\\n        bool isEnd;\\n\\n        trieNode() {\\n            for (int i = 0; i < 26; i++) {\\n                child.push_back(NULL);\\n            }\\n\\n            isEnd = false;\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> change = {{0,1},{1,0},{0,-1},{-1,0}};\\n    void buildTrie (trieNode* root, string& s, int i) {\\n        if (i == s.size()) {\\n            root->isEnd = true;\\n            return;\\n        }\\n\\n        trieNode* child = new trieNode();\\n        if (root->child[s[i]-\\'a\\'] == NULL) {\\n            child->ch = s[i];\\n            root->child[s[i]-\\'a\\'] = child;\\n        } else {\\n            child = root->child[s[i]-\\'a\\'];\\n        }\\n\\n        buildTrie(child, s, i+1);\\n    }\\n\\n    void p (vector<vector<char>>& b, int i, int j, trieNode* node, set<string>& ans, string& str) {\\n        int n = b.size(), m = b[0].size();\\n        str += node->ch;\\n\\n        b[i][j] = \\'?\\';\\n\\n        if (node->isEnd) ans.insert(str);\\n\\n        for (vector<int> a : change) {\\n            int nx = i+a[0], ny = j+a[1];\\n            if (nx >= 0 && nx < n && ny >= 0 && ny < m && b[nx][ny] != \\'?\\') {\\n                if (node->child[b[nx][ny]-\\'a\\'] != NULL)  p (b, nx, ny, node->child[b[nx][ny]-\\'a\\'], ans, str);\\n            }\\n        }\\n\\n        b[i][j] = node->ch;\\n        str.pop_back();\\n    }\\n\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        // time complexity -> words.length * words[i].length = 3*(10^5)\\n        trieNode* root = new trieNode();\\n        root->ch = \\'$\\';\\n        for (string& w : words) {\\n            buildTrie(root, w, 0);\\n        }\\n\\n        set<string> ans;\\n        int n = board.size(), m = board[0].size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                char ch = board[i][j];\\n                if (root->child[ch-\\'a\\'] != NULL) {\\n                    string str = \"\";\\n                    p(board, i, j, root->child[ch-\\'a\\'], ans, str);\\n                }\\n            }\\n        }\\n\\n        vector<string> res;\\n\\n        for (string s : ans) {\\n            res.push_back(s);\\n        }\\n\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "[@Ar_2000](/Ar_2000) I implemented in the similar way you did in java that gave me TLE when I implemented in the way I told you that accepted my solution. If you want I can give you my java based solution so that you can compare where you are going wrong."
                    },
                    {
                        "username": "Ar_2000",
                        "content": "[@nikhil97agra](/nikhil97agra) but it still gives tle. and it should be. Adding and poping in and from a string in O(1) operation only"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "I\\'m not sure but I think variable str you used to append character at each and every call that is causing you TLE.  Instead try this : instead isEnd variable in your class make it a string variable with initial value as null and when you are constructing your trie whenever some word ends just assign that variable to that word so what will happen is when you do recursion call to search for the word and you come at that trie node whose string variable is not null that means your word exist in the list in this way that extra overhead of appending and removing character from str variable will not be there."
                    }
                ]
            },
            {
                "id": 1672404,
                "content": [
                    {
                        "username": "ramadanizm",
                        "content": "What is the wrong with my solution ? why some test cases do not pass\\n```\\nclass TrieNode{\\n    Map<Character , TrieNode> children;\\n    boolean endOfWord;\\n\\n   public TrieNode(){ // no input  :) \\n        children = new HashMap<>();\\n        endOfWord = false;\\n   }\\n\\n    public void addWord(String word) {\\n        TrieNode curr = this;\\n        for(char c : word.toCharArray() ){\\n            if (curr.children.get(c) == null){\\n                curr.children.put(c , new TrieNode());\\n            }\\n            curr = curr.children.get(c);\\n        }\\n        curr.endOfWord = true;\\n    }\\n}\\n    \\nclass Solution {\\n    static final int[][] DIRECTIONS = new int [][]{{1,0} , {-1,0} , {0,1}, {0,-1}};\\n         public List<String> findWords(char[][] board, String[] words) {\\n            int rows = board.length ; int cols = board[0].length;\\n            TrieNode root = new TrieNode();\\n             for(String word : words){\\n                root.addWord(word);\\n             }\\n\\n             boolean [][] visit  = new boolean[rows][cols];\\n             for(boolean[] row: visit)\\n                Arrays.fill(row , false);\\n           \\n\\n             Set<String> result  = new HashSet<>();\\n             for (int r= 0 ; r < rows ; r++){\\n                 for(int c= 0 ; c < cols ; c++){\\n\\n                     dfs(board , r, c , visit , new StringBuilder()  , result, root );\\n                 }\\n             }\\n         /*\\n            System.out.print(result );\\n            List<String> list = new ArrayList<>();\\n            for(String word:words){\\n                if (result.contains(word)){\\n                  list.add(word);  \\n                } \\n                    \\n            }\\n            */\\n            \\n             return new ArrayList<>(result);\\n             \\n\\n}\\n\\nvoid dfs(char[][] board, int r, int c ,boolean [][] visit , StringBuilder path ,  Set<String>  result, TrieNode root   ){\\n\\nif (outOfBound(board  , r, c) || visit[r][c] || root.children.get(board[r][c])  == null){\\n    return ;\\n}\\n\\npath.append(board[r][c]);\\nvisit[r][c] = true;\\nroot = root.children.get(board[r][c]);\\nif (root.endOfWord){\\n    result.add(path.toString());\\n}\\n\\nfor(int[] dir:DIRECTIONS){\\n    dfs(board, r+ dir[0] , c+dir[1] , visit, path,result ,root );\\n}\\n\\nvisit[r][c] = false; // the c could be used in another path (backtracking )\\n\\n}\\n\\nprivate boolean outOfBound(char [][] board , int r , int c){\\n    if ( r < 0 || c < 0 || r >= board.length || c >= board[0].length){\\n        return true;\\n    }\\n    return false;\\n}\\n\\n}\\n```"
                    },
                    {
                        "username": "ababuji",
                        "content": "Language specific TLE  shouldn\\'t be happening. I see asymptotic time complexities being the same regardless of whether the solution is being implemented in Python or Java. \\n\\n"
                    },
                    {
                        "username": "heckervarun",
                        "content": "guys i\\'m getting TLE , can anyone give me some reason why ?, i used dfs on the matrix, any idea to reduce time complexity ?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@VaruN](/heckervarun) Trie, or you need to improve your dfs function if you dont want to use Trie-dic/set.\\nHope you will get new ideas for dfs algorithm, I would like to share my solution on Python3 for 2 direction searchs.\\nhttps://leetcode.com/problems/word-search-ii/solutions/2998236/dfs-no-trie-python-3-path-following-beats-96-12-95-0/"
                    },
                    {
                        "username": "pratikvijayakar31",
                        "content": "I am confused. For example 1, why do we output \"oath\" and \"eat\". Since \"t\" alphabet is common in both strings and hence I believe it cannot be used for both words. Can someone clarify the rule \"The same letter cell may not be used more than once in a word.\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Pratik Vijayakar](/pratikvijayakar31) \"not be used more than once in a word\", t may be presented once in _previous_ \"oath\", then you should not count it on _new_ word search, i.e. \"eat\"!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "Test case 22 is evil.\n\nEdit: managed to pass it by removing nodes from the prefix tree once I've already seen it and it doesnt have any children of its own."
                    },
                    {
                        "username": "pankajnegi010795",
                        "content": "Can anybody tell that why my following code showing TLE and same code in java accepted all test cases.\\n java code ref  https://leetcode.com/problems/word-search-ii/solutions/59780/java-15ms-easiest-solution-100-00/\\n\\nMy code\\n\\nclass Solution {\\n    struct Node\\n    {\\n        Node * next[26];\\n       string isend;\\n    };\\npublic:\\n    Node * newnode()\\n    {\\n        Node * node=new Node();\\n        for(int i=0;i<26;i++)\\n        node->next[i]=nullptr;\\n        node->isend=\"\";\\n        return node;\\n    }\\n    void createtrie(Node* head,string s1)\\n    {\\n        for(int i=0;i<s1.length();i++)\\n        {\\n            if(head->next[s1[i]-\\'a\\']==nullptr)\\n            head->next[s1[i]-\\'a\\']=newnode();\\n            head=head->next[s1[i]-\\'a\\'];\\n        }\\n        head->isend=s1;\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n      vector<string> res;\\n       Node * head=newnode();\\n       unordered_set<string> ve;\\n        for(int i=0;i<words.size();i++)\\n       {\\n           createtrie(head,words[i]);\\n       }\\n\\n        \\n            for(int l=0;l<board.size();l++)\\n            {\\n                for(int m=0;m<board[0].size();m++)\\n                {\\n                   \\n             vector<vector<int>> vis(board.size(),vector<int>(board[0].size(),0));\\n                checkfor(board,l,m,vis,ve,head);\\n   \\n                }\\n           \\n            }\\n            for(auto i=ve.begin();i!=ve.end();i++)\\n            {\\n                res.push_back(*i);\\n            }\\n        \\n        return res;\\n        \\n    }\\n   void checkfor(vector<vector<char>>& b,int i,int j,vector<vector<int>> vis,unordered_set<string>&ve,Node* head)\\n    {\\n        if(i>=b.size() or i<0 or j<0 or j>=b[0].size() )\\n            return ;\\n       if(vis[i][j]==true)\\n            return ;\\n\\n        if(head->next[b[i][j]-\\'a\\']==nullptr)\\n        return ;\\n              head=head->next[b[i][j]-\\'a\\'];\\n        if(head->isend.size()>0)\\n        {\\n            ve.insert(head->isend);\\n            head->isend=\"\";\\n        }\\n        vis[i][j]=true;\\n       checkfor(b,i+1,j,vis,ve,head) ;\\n       checkfor(b,i,j+1,vis,ve,head);\\n        checkfor(b,i-1,j,vis,ve,head) ;\\n        checkfor(b,i,j-1,vis,ve,head);\\n\\n\\n        vis[i][j]=false;\\n       return ;\\n    }\\n};\\n"
                    },
                    {
                        "username": "nickpavini",
                        "content": "Here is a DP solution I am working on that currently passes 55 of 64 cases. It fails on the test:\\n\\n`board =\\n[[\"a\",\"a\"]]\\nwords =\\n[\"aaa\"]\\nExpected = \\n[]`\\n\\nBasically we break words down and check if the left overs have been found and if this current letter is next to a location of the rest of the word.\\n\\nThe issue I have right now with that test case, is that after `aa` is found going 2 directions, the third `a` doesnt realize that we have overlap.\\n\\nAny ideas on a way to close off this solution?\\n\\n```\\ndef findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        if not board:\\n            return []\\n\\n        rtn = []\\n        memo = {}\\n        for word in words:\\n            self.dp(board, word, memo)\\n            if not (-1,-1) in memo[word]:\\n                rtn.append(word)        \\n        return rtn\\n\\n    def dp(self, board, word,  memo):\\n        if word in memo:\\n            return\\n\\n        leftOver = word[1:]\\n        if leftOver != \\'\\':\\n            self.dp(board, leftOver, memo)\\n            if (-1, -1) in memo[leftOver]:\\n                memo[word] = {(-1,-1): 1}\\n                return\\n\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == word[0]:\\n                    if leftOver == \\'\\' or (i,j+1) in memo[leftOver] or (i,j-1) in memo[leftOver] or (i+1,j) in memo[leftOver] or (i-1,j) in memo[leftOver]:\\n                        if word in memo:\\n                            memo[word][(i,j)] = 1\\n                        else:\\n                            memo[word] = {(i,j): 1}\\n                    \\n\\n        if not word in memo:\\n            memo[word] = {(-1,-1): 1}\\n```"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I dont really understand how a trie is faster than a set. I was able to get my python version running with a set of acceptable prefixes... once. Everytime after that I got TLE. But isnt a tree pretty much a hashed set anyhow? I thought set lookups were O(1). I dont understand how looking up a given prefix in the Trie, returning a small set of acceptable \"following\" letters, and comparing neighbors to the current cell to see if they fall in this set is any different than looking up the entire prefix so far + one of the neighbors in a big list of acceptable prefixes. Both involve at least one set check, and as a hashed structure, should take the same amount of time? Similarly, how does pruning help? It doesnt take less time to find inclusion in a hashed set if the set is smaller I thought? Look ups HASH the target and see if it exists, regardless of other hashed values: its the entire point of hashing, so look ups are O(1)"
                    },
                    {
                        "username": "palakons",
                        "content": "pruning helps, and prefix \"set\" would work f you could prune the prefix set... which is difficult"
                    },
                    {
                        "username": "drap5468",
                        "content": "The way pruning works for this problem is you *entirely* remove a word you already visited, including its prefixes. That way in future traversal you'll know to stop if the only valid route remaining leads to a used word.\n\nIf you never prune, that means you keep traversing routes that are no longer useful to you. Specifically in your code, the condition to continue down a path is whether the current sequence is in prefix_set. Since you never update prefix_set, you end up with a lot of very expensive false positives, going down paths that *used to be* relevant, but no longer are, since that word has been used up.\n\nI agree that your hashing method probably simulates a trie closely enough to work for this problem, so if you implement pruning I bet it will consistently finish running on time."
                    },
                    {
                        "username": "siseendri",
                        "content": " @ `your inline code...your inline code...` `your inline code...your inline code...` @"
                    },
                    {
                        "username": "Ar_2000",
                        "content": "can anyone help me why am I getting TLE for this solution -\\n\\n  class trieNode {\\n    public:\\n        char ch;\\n        vector<trieNode*> child;\\n        bool isEnd;\\n\\n        trieNode() {\\n            for (int i = 0; i < 26; i++) {\\n                child.push_back(NULL);\\n            }\\n\\n            isEnd = false;\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> change = {{0,1},{1,0},{0,-1},{-1,0}};\\n    void buildTrie (trieNode* root, string& s, int i) {\\n        if (i == s.size()) {\\n            root->isEnd = true;\\n            return;\\n        }\\n\\n        trieNode* child = new trieNode();\\n        if (root->child[s[i]-\\'a\\'] == NULL) {\\n            child->ch = s[i];\\n            root->child[s[i]-\\'a\\'] = child;\\n        } else {\\n            child = root->child[s[i]-\\'a\\'];\\n        }\\n\\n        buildTrie(child, s, i+1);\\n    }\\n\\n    void p (vector<vector<char>>& b, int i, int j, trieNode* node, set<string>& ans, string& str) {\\n        int n = b.size(), m = b[0].size();\\n        str += node->ch;\\n\\n        b[i][j] = \\'?\\';\\n\\n        if (node->isEnd) ans.insert(str);\\n\\n        for (vector<int> a : change) {\\n            int nx = i+a[0], ny = j+a[1];\\n            if (nx >= 0 && nx < n && ny >= 0 && ny < m && b[nx][ny] != \\'?\\') {\\n                if (node->child[b[nx][ny]-\\'a\\'] != NULL)  p (b, nx, ny, node->child[b[nx][ny]-\\'a\\'], ans, str);\\n            }\\n        }\\n\\n        b[i][j] = node->ch;\\n        str.pop_back();\\n    }\\n\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        // time complexity -> words.length * words[i].length = 3*(10^5)\\n        trieNode* root = new trieNode();\\n        root->ch = \\'$\\';\\n        for (string& w : words) {\\n            buildTrie(root, w, 0);\\n        }\\n\\n        set<string> ans;\\n        int n = board.size(), m = board[0].size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                char ch = board[i][j];\\n                if (root->child[ch-\\'a\\'] != NULL) {\\n                    string str = \"\";\\n                    p(board, i, j, root->child[ch-\\'a\\'], ans, str);\\n                }\\n            }\\n        }\\n\\n        vector<string> res;\\n\\n        for (string s : ans) {\\n            res.push_back(s);\\n        }\\n\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "[@Ar_2000](/Ar_2000) I implemented in the similar way you did in java that gave me TLE when I implemented in the way I told you that accepted my solution. If you want I can give you my java based solution so that you can compare where you are going wrong."
                    },
                    {
                        "username": "Ar_2000",
                        "content": "[@nikhil97agra](/nikhil97agra) but it still gives tle. and it should be. Adding and poping in and from a string in O(1) operation only"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "I\\'m not sure but I think variable str you used to append character at each and every call that is causing you TLE.  Instead try this : instead isEnd variable in your class make it a string variable with initial value as null and when you are constructing your trie whenever some word ends just assign that variable to that word so what will happen is when you do recursion call to search for the word and you come at that trie node whose string variable is not null that means your word exist in the list in this way that extra overhead of appending and removing character from str variable will not be there."
                    }
                ]
            },
            {
                "id": 1672255,
                "content": [
                    {
                        "username": "ramadanizm",
                        "content": "What is the wrong with my solution ? why some test cases do not pass\\n```\\nclass TrieNode{\\n    Map<Character , TrieNode> children;\\n    boolean endOfWord;\\n\\n   public TrieNode(){ // no input  :) \\n        children = new HashMap<>();\\n        endOfWord = false;\\n   }\\n\\n    public void addWord(String word) {\\n        TrieNode curr = this;\\n        for(char c : word.toCharArray() ){\\n            if (curr.children.get(c) == null){\\n                curr.children.put(c , new TrieNode());\\n            }\\n            curr = curr.children.get(c);\\n        }\\n        curr.endOfWord = true;\\n    }\\n}\\n    \\nclass Solution {\\n    static final int[][] DIRECTIONS = new int [][]{{1,0} , {-1,0} , {0,1}, {0,-1}};\\n         public List<String> findWords(char[][] board, String[] words) {\\n            int rows = board.length ; int cols = board[0].length;\\n            TrieNode root = new TrieNode();\\n             for(String word : words){\\n                root.addWord(word);\\n             }\\n\\n             boolean [][] visit  = new boolean[rows][cols];\\n             for(boolean[] row: visit)\\n                Arrays.fill(row , false);\\n           \\n\\n             Set<String> result  = new HashSet<>();\\n             for (int r= 0 ; r < rows ; r++){\\n                 for(int c= 0 ; c < cols ; c++){\\n\\n                     dfs(board , r, c , visit , new StringBuilder()  , result, root );\\n                 }\\n             }\\n         /*\\n            System.out.print(result );\\n            List<String> list = new ArrayList<>();\\n            for(String word:words){\\n                if (result.contains(word)){\\n                  list.add(word);  \\n                } \\n                    \\n            }\\n            */\\n            \\n             return new ArrayList<>(result);\\n             \\n\\n}\\n\\nvoid dfs(char[][] board, int r, int c ,boolean [][] visit , StringBuilder path ,  Set<String>  result, TrieNode root   ){\\n\\nif (outOfBound(board  , r, c) || visit[r][c] || root.children.get(board[r][c])  == null){\\n    return ;\\n}\\n\\npath.append(board[r][c]);\\nvisit[r][c] = true;\\nroot = root.children.get(board[r][c]);\\nif (root.endOfWord){\\n    result.add(path.toString());\\n}\\n\\nfor(int[] dir:DIRECTIONS){\\n    dfs(board, r+ dir[0] , c+dir[1] , visit, path,result ,root );\\n}\\n\\nvisit[r][c] = false; // the c could be used in another path (backtracking )\\n\\n}\\n\\nprivate boolean outOfBound(char [][] board , int r , int c){\\n    if ( r < 0 || c < 0 || r >= board.length || c >= board[0].length){\\n        return true;\\n    }\\n    return false;\\n}\\n\\n}\\n```"
                    },
                    {
                        "username": "ababuji",
                        "content": "Language specific TLE  shouldn\\'t be happening. I see asymptotic time complexities being the same regardless of whether the solution is being implemented in Python or Java. \\n\\n"
                    },
                    {
                        "username": "heckervarun",
                        "content": "guys i\\'m getting TLE , can anyone give me some reason why ?, i used dfs on the matrix, any idea to reduce time complexity ?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@VaruN](/heckervarun) Trie, or you need to improve your dfs function if you dont want to use Trie-dic/set.\\nHope you will get new ideas for dfs algorithm, I would like to share my solution on Python3 for 2 direction searchs.\\nhttps://leetcode.com/problems/word-search-ii/solutions/2998236/dfs-no-trie-python-3-path-following-beats-96-12-95-0/"
                    },
                    {
                        "username": "pratikvijayakar31",
                        "content": "I am confused. For example 1, why do we output \"oath\" and \"eat\". Since \"t\" alphabet is common in both strings and hence I believe it cannot be used for both words. Can someone clarify the rule \"The same letter cell may not be used more than once in a word.\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Pratik Vijayakar](/pratikvijayakar31) \"not be used more than once in a word\", t may be presented once in _previous_ \"oath\", then you should not count it on _new_ word search, i.e. \"eat\"!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "Test case 22 is evil.\n\nEdit: managed to pass it by removing nodes from the prefix tree once I've already seen it and it doesnt have any children of its own."
                    },
                    {
                        "username": "pankajnegi010795",
                        "content": "Can anybody tell that why my following code showing TLE and same code in java accepted all test cases.\\n java code ref  https://leetcode.com/problems/word-search-ii/solutions/59780/java-15ms-easiest-solution-100-00/\\n\\nMy code\\n\\nclass Solution {\\n    struct Node\\n    {\\n        Node * next[26];\\n       string isend;\\n    };\\npublic:\\n    Node * newnode()\\n    {\\n        Node * node=new Node();\\n        for(int i=0;i<26;i++)\\n        node->next[i]=nullptr;\\n        node->isend=\"\";\\n        return node;\\n    }\\n    void createtrie(Node* head,string s1)\\n    {\\n        for(int i=0;i<s1.length();i++)\\n        {\\n            if(head->next[s1[i]-\\'a\\']==nullptr)\\n            head->next[s1[i]-\\'a\\']=newnode();\\n            head=head->next[s1[i]-\\'a\\'];\\n        }\\n        head->isend=s1;\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n      vector<string> res;\\n       Node * head=newnode();\\n       unordered_set<string> ve;\\n        for(int i=0;i<words.size();i++)\\n       {\\n           createtrie(head,words[i]);\\n       }\\n\\n        \\n            for(int l=0;l<board.size();l++)\\n            {\\n                for(int m=0;m<board[0].size();m++)\\n                {\\n                   \\n             vector<vector<int>> vis(board.size(),vector<int>(board[0].size(),0));\\n                checkfor(board,l,m,vis,ve,head);\\n   \\n                }\\n           \\n            }\\n            for(auto i=ve.begin();i!=ve.end();i++)\\n            {\\n                res.push_back(*i);\\n            }\\n        \\n        return res;\\n        \\n    }\\n   void checkfor(vector<vector<char>>& b,int i,int j,vector<vector<int>> vis,unordered_set<string>&ve,Node* head)\\n    {\\n        if(i>=b.size() or i<0 or j<0 or j>=b[0].size() )\\n            return ;\\n       if(vis[i][j]==true)\\n            return ;\\n\\n        if(head->next[b[i][j]-\\'a\\']==nullptr)\\n        return ;\\n              head=head->next[b[i][j]-\\'a\\'];\\n        if(head->isend.size()>0)\\n        {\\n            ve.insert(head->isend);\\n            head->isend=\"\";\\n        }\\n        vis[i][j]=true;\\n       checkfor(b,i+1,j,vis,ve,head) ;\\n       checkfor(b,i,j+1,vis,ve,head);\\n        checkfor(b,i-1,j,vis,ve,head) ;\\n        checkfor(b,i,j-1,vis,ve,head);\\n\\n\\n        vis[i][j]=false;\\n       return ;\\n    }\\n};\\n"
                    },
                    {
                        "username": "nickpavini",
                        "content": "Here is a DP solution I am working on that currently passes 55 of 64 cases. It fails on the test:\\n\\n`board =\\n[[\"a\",\"a\"]]\\nwords =\\n[\"aaa\"]\\nExpected = \\n[]`\\n\\nBasically we break words down and check if the left overs have been found and if this current letter is next to a location of the rest of the word.\\n\\nThe issue I have right now with that test case, is that after `aa` is found going 2 directions, the third `a` doesnt realize that we have overlap.\\n\\nAny ideas on a way to close off this solution?\\n\\n```\\ndef findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        if not board:\\n            return []\\n\\n        rtn = []\\n        memo = {}\\n        for word in words:\\n            self.dp(board, word, memo)\\n            if not (-1,-1) in memo[word]:\\n                rtn.append(word)        \\n        return rtn\\n\\n    def dp(self, board, word,  memo):\\n        if word in memo:\\n            return\\n\\n        leftOver = word[1:]\\n        if leftOver != \\'\\':\\n            self.dp(board, leftOver, memo)\\n            if (-1, -1) in memo[leftOver]:\\n                memo[word] = {(-1,-1): 1}\\n                return\\n\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == word[0]:\\n                    if leftOver == \\'\\' or (i,j+1) in memo[leftOver] or (i,j-1) in memo[leftOver] or (i+1,j) in memo[leftOver] or (i-1,j) in memo[leftOver]:\\n                        if word in memo:\\n                            memo[word][(i,j)] = 1\\n                        else:\\n                            memo[word] = {(i,j): 1}\\n                    \\n\\n        if not word in memo:\\n            memo[word] = {(-1,-1): 1}\\n```"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I dont really understand how a trie is faster than a set. I was able to get my python version running with a set of acceptable prefixes... once. Everytime after that I got TLE. But isnt a tree pretty much a hashed set anyhow? I thought set lookups were O(1). I dont understand how looking up a given prefix in the Trie, returning a small set of acceptable \"following\" letters, and comparing neighbors to the current cell to see if they fall in this set is any different than looking up the entire prefix so far + one of the neighbors in a big list of acceptable prefixes. Both involve at least one set check, and as a hashed structure, should take the same amount of time? Similarly, how does pruning help? It doesnt take less time to find inclusion in a hashed set if the set is smaller I thought? Look ups HASH the target and see if it exists, regardless of other hashed values: its the entire point of hashing, so look ups are O(1)"
                    },
                    {
                        "username": "palakons",
                        "content": "pruning helps, and prefix \"set\" would work f you could prune the prefix set... which is difficult"
                    },
                    {
                        "username": "drap5468",
                        "content": "The way pruning works for this problem is you *entirely* remove a word you already visited, including its prefixes. That way in future traversal you'll know to stop if the only valid route remaining leads to a used word.\n\nIf you never prune, that means you keep traversing routes that are no longer useful to you. Specifically in your code, the condition to continue down a path is whether the current sequence is in prefix_set. Since you never update prefix_set, you end up with a lot of very expensive false positives, going down paths that *used to be* relevant, but no longer are, since that word has been used up.\n\nI agree that your hashing method probably simulates a trie closely enough to work for this problem, so if you implement pruning I bet it will consistently finish running on time."
                    },
                    {
                        "username": "siseendri",
                        "content": " @ `your inline code...your inline code...` `your inline code...your inline code...` @"
                    },
                    {
                        "username": "Ar_2000",
                        "content": "can anyone help me why am I getting TLE for this solution -\\n\\n  class trieNode {\\n    public:\\n        char ch;\\n        vector<trieNode*> child;\\n        bool isEnd;\\n\\n        trieNode() {\\n            for (int i = 0; i < 26; i++) {\\n                child.push_back(NULL);\\n            }\\n\\n            isEnd = false;\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> change = {{0,1},{1,0},{0,-1},{-1,0}};\\n    void buildTrie (trieNode* root, string& s, int i) {\\n        if (i == s.size()) {\\n            root->isEnd = true;\\n            return;\\n        }\\n\\n        trieNode* child = new trieNode();\\n        if (root->child[s[i]-\\'a\\'] == NULL) {\\n            child->ch = s[i];\\n            root->child[s[i]-\\'a\\'] = child;\\n        } else {\\n            child = root->child[s[i]-\\'a\\'];\\n        }\\n\\n        buildTrie(child, s, i+1);\\n    }\\n\\n    void p (vector<vector<char>>& b, int i, int j, trieNode* node, set<string>& ans, string& str) {\\n        int n = b.size(), m = b[0].size();\\n        str += node->ch;\\n\\n        b[i][j] = \\'?\\';\\n\\n        if (node->isEnd) ans.insert(str);\\n\\n        for (vector<int> a : change) {\\n            int nx = i+a[0], ny = j+a[1];\\n            if (nx >= 0 && nx < n && ny >= 0 && ny < m && b[nx][ny] != \\'?\\') {\\n                if (node->child[b[nx][ny]-\\'a\\'] != NULL)  p (b, nx, ny, node->child[b[nx][ny]-\\'a\\'], ans, str);\\n            }\\n        }\\n\\n        b[i][j] = node->ch;\\n        str.pop_back();\\n    }\\n\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        // time complexity -> words.length * words[i].length = 3*(10^5)\\n        trieNode* root = new trieNode();\\n        root->ch = \\'$\\';\\n        for (string& w : words) {\\n            buildTrie(root, w, 0);\\n        }\\n\\n        set<string> ans;\\n        int n = board.size(), m = board[0].size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                char ch = board[i][j];\\n                if (root->child[ch-\\'a\\'] != NULL) {\\n                    string str = \"\";\\n                    p(board, i, j, root->child[ch-\\'a\\'], ans, str);\\n                }\\n            }\\n        }\\n\\n        vector<string> res;\\n\\n        for (string s : ans) {\\n            res.push_back(s);\\n        }\\n\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "[@Ar_2000](/Ar_2000) I implemented in the similar way you did in java that gave me TLE when I implemented in the way I told you that accepted my solution. If you want I can give you my java based solution so that you can compare where you are going wrong."
                    },
                    {
                        "username": "Ar_2000",
                        "content": "[@nikhil97agra](/nikhil97agra) but it still gives tle. and it should be. Adding and poping in and from a string in O(1) operation only"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "I\\'m not sure but I think variable str you used to append character at each and every call that is causing you TLE.  Instead try this : instead isEnd variable in your class make it a string variable with initial value as null and when you are constructing your trie whenever some word ends just assign that variable to that word so what will happen is when you do recursion call to search for the word and you come at that trie node whose string variable is not null that means your word exist in the list in this way that extra overhead of appending and removing character from str variable will not be there."
                    }
                ]
            }
        ]
    }
]