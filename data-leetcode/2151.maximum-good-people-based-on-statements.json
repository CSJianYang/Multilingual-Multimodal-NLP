[
    {
        "title": "Maximum Good People Based on Statements",
        "question_content": "There are two types of persons:\n\n\tThe good person: The person who always tells the truth.\n\tThe bad person: The person who might tell the truth and might lie.\n\nYou are given a 0-indexed 2D integer array statements of size n x n that represents the statements made by n people about each other. More specifically, statements[i][j] could be one of the following:\n\n\t0 which represents a statement made by person i that person j is a bad person.\n\t1 which represents a statement made by person i that person j is a good person.\n\t2 represents that no statement is made by person i about person j.\n\nAdditionally, no person ever makes a statement about themselves. Formally, we have that statements[i][i] = 2 for all 0 <= i < n.\nReturn the maximum number of people who can be good based on the statements made by the n people.\n&nbsp;\nExample 1:\n\nInput: statements = [[2,1,2],[1,2,2],[2,0,2]]\nOutput: 2\nExplanation: Each person makes a single statement.\n- Person 0 states that person 1 is good.\n- Person 1 states that person 0 is good.\n- Person 2 states that person 1 is bad.\nLet's take person 2 as the key.\n- Assuming that person 2 is a good person:\n    - Based on the statement made by person 2, person 1 is a bad person.\n    - Now we know for sure that person 1 is bad and person 2 is good.\n    - Based on the statement made by person 1, and since person 1 is bad, they could be:\n        - telling the truth. There will be a contradiction in this case and this assumption is invalid.\n        - lying. In this case, person 0 is also a bad person and lied in their statement.\n    - Following that person 2 is a good person, there will be only one good person in the group.\n- Assuming that person 2 is a bad person:\n    - Based on the statement made by person 2, and since person 2 is bad, they could be:\n        - telling the truth. Following this scenario, person 0 and 1 are both bad as explained before.\n            - Following that person 2 is bad but told the truth, there will be no good persons in the group.\n        - lying. In this case person 1 is a good person.\n            - Since person 1 is a good person, person 0 is also a good person.\n            - Following that person 2 is bad and lied, there will be two good persons in the group.\nWe can see that at most 2 persons are good in the best case, so we return 2.\nNote that there is more than one way to arrive at this conclusion.\n\nExample 2:\n\nInput: statements = [[2,0],[0,2]]\nOutput: 1\nExplanation: Each person makes a single statement.\n- Person 0 states that person 1 is bad.\n- Person 1 states that person 0 is bad.\nLet's take person 0 as the key.\n- Assuming that person 0 is a good person:\n    - Based on the statement made by person 0, person 1 is a bad person and was lying.\n    - Following that person 0 is a good person, there will be only one good person in the group.\n- Assuming that person 0 is a bad person:\n    - Based on the statement made by person 0, and since person 0 is bad, they could be:\n        - telling the truth. Following this scenario, person 0 and 1 are both bad.\n            - Following that person 0 is bad but told the truth, there will be no good persons in the group.\n        - lying. In this case person 1 is a good person.\n            - Following that person 0 is bad and lied, there will be only one good person in the group.\nWe can see that at most, one person is good in the best case, so we return 1.\nNote that there is more than one way to arrive at this conclusion.\n\n&nbsp;\nConstraints:\n\n\tn == statements.length == statements[i].length\n\t2 <= n <= 15\n\tstatements[i][j] is either 0, 1, or 2.\n\tstatements[i][i] == 2",
        "solutions": [
            {
                "id": 1711218,
                "title": "c-python-simple-solution-w-explanation-dfs-backtracking-and-bitmasking",
                "content": "We need to find maximum number of people who can be good in accordance with the given statements.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I (DFS + Backtrack)***\\n\\nA person can either be good or bad. \\nHowever, we cant be sure & assigning a person as good cant lead to contradictions in statements\\nWe explore both possibilities of a person being good or bad\\nFinally, we check if current configuration is valid or not\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int n, ans = 0;\\n    int maximumGood(vector<vector<int>>& S) {\\n        n = size(S);\\n        string cur = \"\"; cur.reserve(n);\\n        dfs(S, cur, 0, 0);\\n        return ans;\\n    }\\n    void dfs(vector<vector<int>>& S, string& cur, int i, int cnt) {\\n        if(i == n) {\\n\\t\\t\\t// if valid, update ans to store maximum good person found till now\\n            if(valid(S, cur)) ans = max(ans, cnt);\\n            return;\\n        }\\n        cur.append(1, \\'0\\');\\n        dfs(S, cur, i+1, cnt);        // assuming ith person is bad\\n        cur.back() = \\'1\\';\\n        dfs(S, cur, i+1, cnt + 1);    // assuming ith person is good\\n        cur.pop_back();        \\n    }\\n    bool valid(vector<vector<int>>& S, string& cur) {\\n        for(int i = 0; i < n; i++) \\n            if(cur[i] == \\'1\\') \\n                for(int j = 0; j < n; j++) \\n                    if(S[i][j] != 2 && S[i][j] != cur[j] - \\'0\\') return false;\\n        return true;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def maximumGood(self, S):\\n        n, ans = len(S), 0\\n        def valid(cur):\\n            for i in range(n):\\n                if cur[i]:\\n                    for j in range(n):\\n                        if S[i][j] != 2 and S[i][j] != cur[j]: return False\\n            return True;\\n        def dfs(cur, i, cnt):\\n            nonlocal ans\\n            if i == n:\\n                if valid(cur): ans = max(ans, cnt)\\n                return\\n            cur.append(0)\\n            dfs(cur, i+1, cnt)\\n            cur[-1] = 1\\n            dfs(cur, i+1, cnt+1)\\n            cur.pop()\\n        \\n        dfs([], 0, 0)\\n        return ans\\n        \\n```\\n\\n***Time Complexity :*** <code>O(N<sup>2</sup>*2<sup>N</sup>)</code>, where `N` is the number of people\\n***Space Complexity :*** `O(N)`\\n\\n\\n----\\n\\n\\u2714\\uFE0F ***Solution - II (Bitmasking)***\\n\\nThe same thing as above, but using bitmasking which should be more efficient than backtracking. We are basically exploring all possible configurations for given `n` people.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int maximumGood(vector<vector<int>>& S) {\\n        int n = size(S), ans = 0;\\n        auto valid = [&](int cur) {\\n            for(int i = 0; i < n; i++)\\n                if(cur & 1 << n-1-i)\\n                    for(int j = 0; j < n; j++)\\n                        if(S[i][j] != 2 && S[i][j] != bool(cur & 1 << n-1-j)) return false;\\n            return true;\\n        };\\n        for(int i = 0; i < 1 << n; i++)                            // bits in i denotes person configuration\\n            if(valid(i)) ans = max(ans, __builtin_popcount(i));    // update ans if valid config\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def maximumGood(self, S):\\n        n, ans = len(S), 0\\n        def valid(cur):\\n            for i in range(n):\\n                if cur & 1 << n-1-i:\\n                    for j in range(n):\\n                        if S[i][j] != 2 and S[i][j] != bool(cur & 1 << n-1-j): return False\\n            return True\\n        return max(bin(i).count(\\'1\\') if valid(i) else 0 for i in range(1 << n))\\n```\\n\\n***Time Complexity :*** <code>O(N<sup>2</sup>*2<sup>N</sup>)</code>, where `N` is the number of people\\n***Space Complexity :*** `O(1)`\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int n, ans = 0;\\n    int maximumGood(vector<vector<int>>& S) {\\n        n = size(S);\\n        string cur = \"\"; cur.reserve(n);\\n        dfs(S, cur, 0, 0);\\n        return ans;\\n    }\\n    void dfs(vector<vector<int>>& S, string& cur, int i, int cnt) {\\n        if(i == n) {\\n\\t\\t\\t// if valid, update ans to store maximum good person found till now\\n            if(valid(S, cur)) ans = max(ans, cnt);\\n            return;\\n        }\\n        cur.append(1, \\'0\\');\\n        dfs(S, cur, i+1, cnt);        // assuming ith person is bad\\n        cur.back() = \\'1\\';\\n        dfs(S, cur, i+1, cnt + 1);    // assuming ith person is good\\n        cur.pop_back();        \\n    }\\n    bool valid(vector<vector<int>>& S, string& cur) {\\n        for(int i = 0; i < n; i++) \\n            if(cur[i] == \\'1\\') \\n                for(int j = 0; j < n; j++) \\n                    if(S[i][j] != 2 && S[i][j] != cur[j] - \\'0\\') return false;\\n        return true;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def maximumGood(self, S):\\n        n, ans = len(S), 0\\n        def valid(cur):\\n            for i in range(n):\\n                if cur[i]:\\n                    for j in range(n):\\n                        if S[i][j] != 2 and S[i][j] != cur[j]: return False\\n            return True;\\n        def dfs(cur, i, cnt):\\n            nonlocal ans\\n            if i == n:\\n                if valid(cur): ans = max(ans, cnt)\\n                return\\n            cur.append(0)\\n            dfs(cur, i+1, cnt)\\n            cur[-1] = 1\\n            dfs(cur, i+1, cnt+1)\\n            cur.pop()\\n        \\n        dfs([], 0, 0)\\n        return ans\\n        \\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maximumGood(vector<vector<int>>& S) {\\n        int n = size(S), ans = 0;\\n        auto valid = [&](int cur) {\\n            for(int i = 0; i < n; i++)\\n                if(cur & 1 << n-1-i)\\n                    for(int j = 0; j < n; j++)\\n                        if(S[i][j] != 2 && S[i][j] != bool(cur & 1 << n-1-j)) return false;\\n            return true;\\n        };\\n        for(int i = 0; i < 1 << n; i++)                            // bits in i denotes person configuration\\n            if(valid(i)) ans = max(ans, __builtin_popcount(i));    // update ans if valid config\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def maximumGood(self, S):\\n        n, ans = len(S), 0\\n        def valid(cur):\\n            for i in range(n):\\n                if cur & 1 << n-1-i:\\n                    for j in range(n):\\n                        if S[i][j] != 2 and S[i][j] != bool(cur & 1 << n-1-j): return False\\n            return True\\n        return max(bin(i).count(\\'1\\') if valid(i) else 0 for i in range(1 << n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711216,
                "title": "python3-java-c-subsets-o-n-2-2-n",
                "content": "I recommend checking this problem first: https://leetcode.com/problems/subsets/solution/\\nLook for *Approach 3: Lexicographic (Binary Sorted) Subsets*\\n\\n* We are going to generate every possible permutation of good and bad people\\n* Then we check if this permutation satisfies the given constraints\\n\\nPermutation representation in binary:\\n\\n>111 : 0 -> good, 1 -> good, 2 -> good\\n110 : 0 -> good, 1 -> good, 2 -> bad\\n101 : 0 -> good, 1 -> bad, 2 -> good\\n011 : 0 -> bad, 1 -> good, 2 -> good\\n100 : 0 -> good, 1 -> bad, 2 -> bad\\n... and so on.\\n\\nWith 3 people we will have 8 permutations(2<sup>n</sup>)\\nWith 4 people we will have 16 permutations\\n\\n>For n = 3:\\nLower limit: 1 << n = 2<sup>n</sup> = 8 = 1000\\nUpper limit: 1 << (n + 1) - 1 = 2<sup>n+1</sup> - 1 = 16 - 1 = 15 = 1111\\nInteger.toBinaryString(8).substring(1): 000\\nInteger.toBinaryString(9).substring(1): 001\\n...\\nInteger.toBinaryString(15).substring(1): 111\\n\\nTo check if our permutation satisfies the constraints, we check if the statements of good people in our permutation are making any contradictions. If they are, this permutation will not hold and we can return false.\\n\\nIf our `permutation` satisfies the given constraints, count the number of ones in our `permutation`.\\nPermutation with maximum ones is the answer. \\n\\n<iframe src=\"https://leetcode.com/playground/aSJnx2F5/shared\" frameBorder=\"0\" width=\"700\" height=\"460\"></iframe>\\n\\n*Time Complexity*: O(n<sup>2</sup> * 2<sup>n</sup>)\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "I recommend checking this problem first: https://leetcode.com/problems/subsets/solution/\\nLook for *Approach 3: Lexicographic (Binary Sorted) Subsets*\\n\\n* We are going to generate every possible permutation of good and bad people\\n* Then we check if this permutation satisfies the given constraints\\n\\nPermutation representation in binary:\\n\\n>111 : 0 -> good, 1 -> good, 2 -> good\\n110 : 0 -> good, 1 -> good, 2 -> bad\\n101 : 0 -> good, 1 -> bad, 2 -> good\\n011 : 0 -> bad, 1 -> good, 2 -> good\\n100 : 0 -> good, 1 -> bad, 2 -> bad\\n... and so on.\\n\\nWith 3 people we will have 8 permutations(2<sup>n</sup>)\\nWith 4 people we will have 16 permutations\\n\\n>For n = 3:\\nLower limit: 1 << n = 2<sup>n</sup> = 8 = 1000\\nUpper limit: 1 << (n + 1) - 1 = 2<sup>n+1</sup> - 1 = 16 - 1 = 15 = 1111\\nInteger.toBinaryString(8).substring(1): 000\\nInteger.toBinaryString(9).substring(1): 001\\n...\\nInteger.toBinaryString(15).substring(1): 111\\n\\nTo check if our permutation satisfies the constraints, we check if the statements of good people in our permutation are making any contradictions. If they are, this permutation will not hold and we can return false.\\n\\nIf our `permutation` satisfies the given constraints, count the number of ones in our `permutation`.\\nPermutation with maximum ones is the answer. \\n\\n<iframe src=\"https://leetcode.com/playground/aSJnx2F5/shared\" frameBorder=\"0\" width=\"700\" height=\"460\"></iframe>\\n\\n*Time Complexity*: O(n<sup>2</sup> * 2<sup>n</sup>)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1711228,
                "title": "python-o-n-2-2-n-very-simple-solution-with-detailed-explanation",
                "content": "**1. Short answer:**\\nActually `n <= 15` is a very strong hint that we can try all combinations by brute force. So we can try every possible guess of the types of each person and check whether it\\'s valid or not.\\n\\nThe validation process is also very simple, since the **bad** person can tell the truth or lie whenever they want, which means his/her statements actually mean nothing, so we can **just ignore it!** We only need to take care of those **good** people and check if any statements made by them have any contradiction with our current guess. \\n\\nFinally, we choose the guess with maximum good people without any contradiction.\\n\\n```\\nclass Solution:\\n    def validation(self, guessedTypes, statements):\\n        N = len(statements)\\n        for i, type in enumerate(guessedTypes):\\n            # We only need to take care the statements of good person\\n            if type == 1:\\n                for j in range(N):\\n                    # This statement is contradicted with our current guess\\n                    if statements[i][j] != 2 and statements[i][j] != guessedTypes[j]:\\n                        return False\\n        return True\\n\\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        N = len(statements)\\n        ans = 0\\n        for i in range(1<<N):\\n            guessedTypes = [int(x) for x in bin(i)[2:].zfill(N)]\\n            if self.validation(guessedTypes, statements):\\n                ans = max(ans, sum(guessedTypes))\\n        return ans\\n\\n```\\n\\n**2. Explanation of the bit manipulation trick:**\\nFor example, if we only have 3 people (`N = 3`), one guess could be `[0, 1, 0]` which means person 1, 3 are bad, person 2 is good. All the possible guesses would be `[0, 0, 0], [0, 0, 1], [0, 1, 0], ... [1, 1, 1]`.\\n\\nHow can we generate these kinds of combinations easily?\\n\\nOf course we can construct a backtracking solution like [Subsets](https://leetcode.com/problems/subsets/), but there is a much easier and cleaner way to do it. We can take these states as binary code `000, 001, 010, 011, ... 111`, which means digital `0~7`. So we only need to iterate `i` from `0` to `2^N-1` (`2^N` could also be written as `1<<N`), and then transform each `i` from digital format to binary format and fill the leading zeros.\\n\\n```\\n1 (digital) => \"1\" (binary) => \"001\" (fill leading zeros)\\n2 => \"10\" => \"010\"\\n5 => \"101\"\\n```\\n\\nIn python, it can be written easily as `bin(i)[2:].zfill(N)`. And then we could further change it to a list of integers for convenience.\\n\\nActually, there is a more elegant way to do this\\n\\n```\\nfor i in range(1 << N, 1 << (N + 1)):\\n\\tprint(bin(i)[3:])\\n```\\n\\nThe above code will also give you all the combinations of binary code of a given size `N` with leading zeros. However, it\\'s a bit harder to understand.\\n\\n**3. Time complexity:**\\n1. `O(2 ^ N)` for trying all possible guesses\\n2. `O(N ^ 2)` for validating each guess\\nTotal: `O((N ^ 2) * (2 ^ N))`\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def validation(self, guessedTypes, statements):\\n        N = len(statements)\\n        for i, type in enumerate(guessedTypes):\\n            # We only need to take care the statements of good person\\n            if type == 1:\\n                for j in range(N):\\n                    # This statement is contradicted with our current guess\\n                    if statements[i][j] != 2 and statements[i][j] != guessedTypes[j]:\\n                        return False\\n        return True\\n\\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        N = len(statements)\\n        ans = 0\\n        for i in range(1<<N):\\n            guessedTypes = [int(x) for x in bin(i)[2:].zfill(N)]\\n            if self.validation(guessedTypes, statements):\\n                ans = max(ans, sum(guessedTypes))\\n        return ans\\n\\n```\n```\\n1 (digital) => \"1\" (binary) => \"001\" (fill leading zeros)\\n2 => \"10\" => \"010\"\\n5 => \"101\"\\n```\n```\\nfor i in range(1 << N, 1 << (N + 1)):\\n\\tprint(bin(i)[3:])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711219,
                "title": "c-bitmask-subset-traversal-o-2-n-n-2",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n\\n## Solution 1. Bitmask Subset Traversal\\n\\nEnumerate bitmask `m` from `1` to `2^N - 1`. If the `i`th bit of `m` is `1`/`0`, it means that person `i` is good/bad.\\n\\nWe can ignore bad persons\\' statements because they can be either true or false. But good persons\\' statements must be all correct.\\n\\nTo test if this bitmask `m` is valid, we go through all the good persons\\' statements and see if there is any contradiction.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-277/problems/maximum-good-people-based-on-statements/\\n// Author: github.com/lzl124631x\\n// Time: O(2^N * N^2)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int maximumGood(vector<vector<int>>& A) {\\n        int N = A.size(), ans = 0;\\n        auto valid = [&](int m) {\\n            for (int i = 0; i < N; ++i) {\\n                if (m >> i & 1) { // person i is good\\n                    for (int j = 0; j < N; ++j) { // test if there is any contradiction in the statements from person i\\n                        int good = m >> j & 1; // whether person j is good\\n                        if ((A[i][j] == 0 && good) || (A[i][j] == 1 && !good)) return false;\\n                    }\\n                }\\n            }\\n            return true;\\n        };\\n        for (int m = 1; m < (1 << N); ++m) {\\n            if (valid(m)) ans = max(ans, __builtin_popcount(m));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-277/problems/maximum-good-people-based-on-statements/\\n// Author: github.com/lzl124631x\\n// Time: O(2^N * N^2)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int maximumGood(vector<vector<int>>& A) {\\n        int N = A.size(), ans = 0;\\n        auto valid = [&](int m) {\\n            for (int i = 0; i < N; ++i) {\\n                if (m >> i & 1) { // person i is good\\n                    for (int j = 0; j < N; ++j) { // test if there is any contradiction in the statements from person i\\n                        int good = m >> j & 1; // whether person j is good\\n                        if ((A[i][j] == 0 && good) || (A[i][j] == 1 && !good)) return false;\\n                    }\\n                }\\n            }\\n            return true;\\n        };\\n        for (int m = 1; m < (1 << N); ++m) {\\n            if (valid(m)) ans = max(ans, __builtin_popcount(m));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712176,
                "title": "c-dfs-backtracking-added-comments-to-archit91-s-solution",
                "content": "**Note:** I have described the isValid() function with comments, and that is the main part for understanding this problem. \\nBasically we are trying to create a configuration in cur of good or bad people by trying out all ways, then we are checking what we made is in accordance with what these people said (what good people said) is true or not. This part is described further in isValid().\\n\\n**Why is it backtracking** - Backtracking means to try out all possible ways, hence I think backtracking is correct word to describe what we are doing.\\n\\n**Time and space complexity**\\n**T.C:** O(2^n * n^2) -\\n-> 2^n - Create all possible combinations of size n.\\n-> n^2 - Check validity of 2^n combinations each time by going through statements of all good persons (goodPersons == n persons in worst case leading to n^2).\\n\\n**S.C:** O(n) - Storing cur of size n.\\n\\n```\\nclass Solution {\\npublic:\\n    int result = 0;\\n    int n = 0;\\n    int maximumGood(vector<vector<int>>& statements) {\\n        n = statements.size();\\n        string cur = \"\";\\n        dfs(statements, cur, 0, 0);\\n        return result;\\n    }\\n    \\n    void dfs(vector<vector<int>>& statements, string& cur, int index, int goodPersonCount){\\n        if(index == n){\\n            //Check if cur is valid\\n            if(isValid(cur, statements)) result = max(goodPersonCount, result);\\n            return;\\n        }\\n        \\n        //Make current person a good person and call DFS\\n        cur.push_back(\\'1\\');\\n        dfs(statements, cur, index+1, goodPersonCount+1);\\n        \\n        //Backtrack: Make current person a bad person and call DFS\\n        cur.back() = \\'0\\';\\n        dfs(statements, cur, index+1, goodPersonCount);\\n        \\n        cur.pop_back();\\n    }\\n    \\n    bool isValid(string& cur, vector<vector<int>>& statements){\\n        //isValid() will check if the statement of goodPerson (i) about person (j) i.e. statement[i][j], is contradictory to what we have in cur[j]\\n        \\n        //If it is contradictory, then in terms of question i is lying, and is not a goodPerson, so this is not a valid count.\\n        \\n        //If s[i][j] == 2, i.e. person i said nothing about j, then we can skip it.\\n        for(int i=0; i<n; i++){\\n            if(cur[i] == \\'1\\'){ //We only care about what good people say\\n                //Now we check what they said is in accordance with what we have in cur\\n                for(int j=0; j<n; j++){\\n                    if(statements[i][j] != 2 && statements[i][j] != cur[j] - \\'0\\') return false;\\n                }\\n            }\\n        }\\n        \\n        //All statements made by good person is in accordance with cur, so we have a valid count of good people\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int result = 0;\\n    int n = 0;\\n    int maximumGood(vector<vector<int>>& statements) {\\n        n = statements.size();\\n        string cur = \"\";\\n        dfs(statements, cur, 0, 0);\\n        return result;\\n    }\\n    \\n    void dfs(vector<vector<int>>& statements, string& cur, int index, int goodPersonCount){\\n        if(index == n){\\n            //Check if cur is valid\\n            if(isValid(cur, statements)) result = max(goodPersonCount, result);\\n            return;\\n        }\\n        \\n        //Make current person a good person and call DFS\\n        cur.push_back(\\'1\\');\\n        dfs(statements, cur, index+1, goodPersonCount+1);\\n        \\n        //Backtrack: Make current person a bad person and call DFS\\n        cur.back() = \\'0\\';\\n        dfs(statements, cur, index+1, goodPersonCount);\\n        \\n        cur.pop_back();\\n    }\\n    \\n    bool isValid(string& cur, vector<vector<int>>& statements){\\n        //isValid() will check if the statement of goodPerson (i) about person (j) i.e. statement[i][j], is contradictory to what we have in cur[j]\\n        \\n        //If it is contradictory, then in terms of question i is lying, and is not a goodPerson, so this is not a valid count.\\n        \\n        //If s[i][j] == 2, i.e. person i said nothing about j, then we can skip it.\\n        for(int i=0; i<n; i++){\\n            if(cur[i] == \\'1\\'){ //We only care about what good people say\\n                //Now we check what they said is in accordance with what we have in cur\\n                for(int j=0; j<n; j++){\\n                    if(statements[i][j] != 2 && statements[i][j] != cur[j] - \\'0\\') return false;\\n                }\\n            }\\n        }\\n        \\n        //All statements made by good person is in accordance with cur, so we have a valid count of good people\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711348,
                "title": "java-bitmask-check-all-combinations-of-good-bad-people",
                "content": "There is only up to 15 people, so we can check all combinations (2^15) and verify them against the statements.\\nReject any combination that contradicts the statements of good people (bad may lie) and choose one with the max number of good people.\\n```\\nclass Solution {\\n    static int BAD= 0,  GOOD= 1, UNKNOWN= 2;\\n\\n    public int maximumGood(int[][] statements) {\\n        int n= statements.length;\\n        int max= 0, combos= 1<<n;\\n        int[] roles= new int[n];\\n\\t\\t// iterate through all combinations of good/bad people using bit masks\\n        for(int mask=1; mask<combos; mask++){\\n            int count= apply(roles, mask);\\n            if(possible(statements, roles))\\n                max= Math.max(max, count);\\n        }\\n        return max;\\n    }\\n    \\n\\t// convert bitmask to role array, count good people in this mask\\n\\t// (this part is optional, you can operate on bitmasks directly, but I like it this way to make the checking function\\'s code easy)\\n    int apply(int[] roles, int mask){\\n        int count= 0, n= roles.length;\\n        for(int i=0; i<n; i++){\\n            count+= roles[i]= mask & GOOD;\\n            mask >>= 1;\\n        }\\n        return count;\\n    }\\n\\n\\t// verify the n x n statement matrix against the current combination of roles\\n    boolean possible(int[][] statements, int[] roles){\\n        int n= statements.length;\\n        for(int i=0; i<n; i++){\\n            if(roles[i]==BAD) continue;\\n            // only check statements of good people\\n            for(int j=0; j<n; j++){\\n                if(statements[i][j]==UNKNOWN) continue;\\n\\t\\t\\t\\t// statement of a good person contradicts the assigned role in this combination\\n                if(statements[i][j]!=roles[j]) return false; \\n            }\\n        }\\n        return true;\\n    }    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    static int BAD= 0,  GOOD= 1, UNKNOWN= 2;\\n\\n    public int maximumGood(int[][] statements) {\\n        int n= statements.length;\\n        int max= 0, combos= 1<<n;\\n        int[] roles= new int[n];\\n\\t\\t// iterate through all combinations of good/bad people using bit masks\\n        for(int mask=1; mask<combos; mask++){\\n            int count= apply(roles, mask);\\n            if(possible(statements, roles))\\n                max= Math.max(max, count);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1711918,
                "title": "bitmasking-detailed-explanation",
                "content": "<br/>\\nWe need to check all configurations of good and bad people and find out which one has maximum good people\\n<br/> a person will be good, if and only if his statements don\\'t contradict\\n<br/> i.e. if in our configuration person i is assumed to be good, then if he says person j is good then j should be good in\\nour configuration and vise versa\\n\\n**Example:** \\n```\\nif there are 2 people\\nthen possible configurations are\\n00 - 0 bad 1 bad\\n01 - 0 bad 1 good\\n10 - 0 good 1 bad\\n11 - 0 good 1 good\\n```\\n\\nand for each of these configurations we will check if any statement contradicts or not\\n<br/> if a person is bad in our configuration, then his opinion doesn\\'t matter, so no need to check\\n<br/> if a person i is good, then if statements[i][j] = 1 then j should be 1 in our configuration and \\nif statements[i][j] = 0 then j should be 0 in our configuration\\n<br/> so if any of above two statements contradict then our configuration / assumption is invalid and we will have to check for other configurations (make other assumptions)\\n    \\nand we will take the configuration that has maximum number of good people\\n\\n<br/>\\n\\n<iframe src=\"https://leetcode.com/playground/kVuWTkep/shared\" frameBorder=\"0\" width=\"940\" height=\"600\"></iframe>\\n\\n<br/>",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nif there are 2 people\\nthen possible configurations are\\n00 - 0 bad 1 bad\\n01 - 0 bad 1 good\\n10 - 0 good 1 bad\\n11 - 0 good 1 good\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1711253,
                "title": "dfs-vs-brute-force",
                "content": "It is easy to misunderstand this question. A person *could* be good if, in the chain of all good people, no two people contradict each other.\\n\\n> I initially tried to just check all good people agains each other (brute-force), but was not successfull. More complicated DFS solution got accepted, and later I was able to find an error and make the brute-force solution work.\\n\\n#### Approach 1: Brute-Force\\nSame as above, we use `good` mask to check all combinations. Once you pick a set of \"good\" people, you check each person against each other in the set.\\n\\nThe tricky part is that \"good\" people (unless they have no answer) should not just tell \"good\" about each other, they also need to tell \"bad\" about all people who are not in the `good` set.\\n\\n**C++**\\n```cpp\\nint maximumGood(vector<vector<int>>& ss) {\\n    int n = ss.size(), all = (1 << n) - 1, res = 0;\\n    auto check = [&](int good) {\\n        for (int i = 0; i < n; ++i)\\n            if (good & (1 << i))\\n                for(int j = 0; j < n; ++j)\\n                    if (ss[i][j] != 2 && ss[i][j] != (good & (1 << j) ? 1 : 0))\\n                        return false;\\n        return true;\\n    };\\n    for (int good = 1; good <= all; ++good) {\\n        int cnt = bitset<16>(good).count();\\n        if (cnt > res && check(good))\\n            res = cnt;\\n    }\\n    return res;\\n}\\n```\\n**Complexity Analysis**\\n- Time: O(2 ^ n * n * n). \\n- Memory: O(1).\\n\\n#### Approach 2: DFS\\nThis is more complicated, and the benefit is that we can identify definitelly \"bad\" people upfront (by finding a controversy), and exclude them from the search.\\n\\nFor each person, we assume that this person is \"good\", and run DFS to find all \"bad\" people for that assumption. As we do DFS, we visit all allegedly \"good\" people. If the list of bad people intersect with the list of good people - this person cannot be good. \\n\\nAfter we collect this information, we try all combinations of people; for each combination we get the collective list of \\u201Cbad\\u201D people. If this list does not include anyone in our combination, this combination of good people is valid.\\n\\n**C++**\\n```cpp\\nint dfs(vector<vector<int>>& ss, int i, int &good) {\\n    int bad = 0;\\n    if ((good & (1 << i)) == 0) {\\n        good |= 1 << i;\\n        for (int j = 0; j < ss.size(); ++j) {\\n            if (ss[i][j] == 0)\\n                bad |= 1 << j;\\n            else if (ss[i][j] == 1)\\n                bad |= dfs(ss, j, good);\\n        }\\n    }\\n    return good & bad ? INT_MAX : bad;\\n}\\nint maximumGood(vector<vector<int>>& ss) {\\n    int n = ss.size(), all = (1 << n) - 1, res = 0, bad_masks[16] = {}, good_masks[16] = {}, bad_mask = 0;\\n    for (int i = 0; i < n; ++i) {\\n        int good = 0;\\n        bad_masks[i] = dfs(ss, i, good);\\n        good_masks[i] = good;\\n        if (bad_masks[i] == INT_MAX)\\n            bad_mask |= (1 << i);\\n    }\\n    for (int can_be_good = 1; can_be_good <= all; ++can_be_good) {\\n        if (can_be_good & bad_mask)\\n            continue;\\n        int bad = 0, good = 0;\\n        if (__builtin_popcount(can_be_good) > res) {\\n            for (int i = 0; i < n; ++i)\\n                if (can_be_good & (1 << i)) {\\n                    bad |= bad_masks[i];\\n                    good |= good_masks[i];\\n                }\\n            if ((good & bad) == 0)\\n                res = __builtin_popcount(good);\\n        }\\n    }\\n    return res;\\n}\\n```\\n**Complexity Analysis**\\n- Time: O(2 ^ n * n). \\n- Memory: O(n) for the recursion and to store masks.",
                "solutionTags": [],
                "code": "```cpp\\nint maximumGood(vector<vector<int>>& ss) {\\n    int n = ss.size(), all = (1 << n) - 1, res = 0;\\n    auto check = [&](int good) {\\n        for (int i = 0; i < n; ++i)\\n            if (good & (1 << i))\\n                for(int j = 0; j < n; ++j)\\n                    if (ss[i][j] != 2 && ss[i][j] != (good & (1 << j) ? 1 : 0))\\n                        return false;\\n        return true;\\n    };\\n    for (int good = 1; good <= all; ++good) {\\n        int cnt = bitset<16>(good).count();\\n        if (cnt > res && check(good))\\n            res = cnt;\\n    }\\n    return res;\\n}\\n```\n```cpp\\nint dfs(vector<vector<int>>& ss, int i, int &good) {\\n    int bad = 0;\\n    if ((good & (1 << i)) == 0) {\\n        good |= 1 << i;\\n        for (int j = 0; j < ss.size(); ++j) {\\n            if (ss[i][j] == 0)\\n                bad |= 1 << j;\\n            else if (ss[i][j] == 1)\\n                bad |= dfs(ss, j, good);\\n        }\\n    }\\n    return good & bad ? INT_MAX : bad;\\n}\\nint maximumGood(vector<vector<int>>& ss) {\\n    int n = ss.size(), all = (1 << n) - 1, res = 0, bad_masks[16] = {}, good_masks[16] = {}, bad_mask = 0;\\n    for (int i = 0; i < n; ++i) {\\n        int good = 0;\\n        bad_masks[i] = dfs(ss, i, good);\\n        good_masks[i] = good;\\n        if (bad_masks[i] == INT_MAX)\\n            bad_mask |= (1 << i);\\n    }\\n    for (int can_be_good = 1; can_be_good <= all; ++can_be_good) {\\n        if (can_be_good & bad_mask)\\n            continue;\\n        int bad = 0, good = 0;\\n        if (__builtin_popcount(can_be_good) > res) {\\n            for (int i = 0; i < n; ++i)\\n                if (can_be_good & (1 << i)) {\\n                    bad |= bad_masks[i];\\n                    good |= good_masks[i];\\n                }\\n            if ((good & bad) == 0)\\n                res = __builtin_popcount(good);\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1932580,
                "title": "using-backtracking-beats-90",
                "content": "```\\nclass Solution:\\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        good = set()\\n        def backTracking(i):\\n            if i == len(statements):\\n                return 0\\n            good.add(i) #Cosider i as good\\n            mxmGood = float(\\'-inf\\')\\n            found = 0\\n            for j in range(i):\\n                if (statements[i][j] == 1 and j not in good) or (statements[i][j] == 0 and j in good) or (j in good and statements[j][i] == 0):\\n                    found = 1\\n                    break\\n            if not found:\\n                mxmGood= max(mxmGood, 1 + backTracking(i+1))\\n            good.remove(i) #Consider i as bad\\n            found = 0\\n            for j in range(i):\\n                if (j in good and statements[j][i] == 1):\\n                    found = 1\\n                    break\\n            if not found:\\n                mxmGood= max(mxmGood, backTracking(i+1))\\n            return mxmGood\\n        return backTracking(0)\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        good = set()\\n        def backTracking(i):\\n            if i == len(statements):\\n                return 0\\n            good.add(i) #Cosider i as good\\n            mxmGood = float(\\'-inf\\')\\n            found = 0\\n            for j in range(i):\\n                if (statements[i][j] == 1 and j not in good) or (statements[i][j] == 0 and j in good) or (j in good and statements[j][i] == 0):\\n                    found = 1\\n                    break\\n            if not found:\\n                mxmGood= max(mxmGood, 1 + backTracking(i+1))\\n            good.remove(i) #Consider i as bad\\n            found = 0\\n            for j in range(i):\\n                if (j in good and statements[j][i] == 1):\\n                    found = 1\\n                    break\\n            if not found:\\n                mxmGood= max(mxmGood, backTracking(i+1))\\n            return mxmGood\\n        return backTracking(0)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1735349,
                "title": "exhaustive-search-with-bitmasking-o-2-n-n-2-with-explanation",
                "content": "```cpp\\nclass Solution {\\npublic:\\n\\tint maximumGood(vector<vector<int>>& statements) {\\n\\t\\tint n = statements.size();\\n\\t\\tint maxGoodPeople = 0;\\n\\t\\tint mask = (1 << n);\\n\\t\\tfor (int currMask = 1; currMask < mask; currMask++) {\\n\\t\\t\\tif (isAllGoodPeople(statements, currMask)) {\\n\\t\\t\\t\\tmaxGoodPeople = max(maxGoodPeople, __builtin_popcount(currMask));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn maxGoodPeople;\\n\\t}\\n\\n\\tbool isAllGoodPeople(vector<vector<int>>& statements, int currMask) {\\n\\t\\tfor (int i = 0; i < statements.size(); i++) {\\n\\t\\t\\tif (currMask & (1 << i)) { // check whether current person is good or not\\n\\t\\t\\t\\t// if it\\'s a good person check his credibility by checking\\n\\t\\t\\t\\t// whether everyone he says good is actually good and everyone he says bad\\n\\t\\t\\t\\t// are really bad person\\n\\t\\t\\t\\tfor (int j = 0; j < statements.size(); j++) {\\n\\t\\t\\t\\t\\tbool isGoodPerson = (currMask & (1 << j)) ? 1 : 0;\\n\\t\\t\\t\\t\\tif ((isGoodPerson && statements[i][j] == 0) || (!isGoodPerson && statements[i][j] == 1)) {\\n\\t\\t\\t\\t\\t\\t// isGoodPerson && statements[i][j] == 0 -> according to our mask j-th person is good\\n\\t\\t\\t\\t\\t\\t// but our i-th guy says he is not. So our assumption about i-th guy being good might be wrong.\\n\\t\\t\\t\\t\\t\\t// invlid mask\\n\\n\\t\\t\\t\\t\\t\\t// !isGoodPerson && statements[i][j] == 1 -> according to our mask j-th person is bad\\n\\t\\t\\t\\t\\t\\t// but our i-th guy says he is good. So our assumption about i-th guy being good might be wrong.\\n\\t\\t\\t\\t\\t\\t// invlid mask\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n\\tint maximumGood(vector<vector<int>>& statements) {\\n\\t\\tint n = statements.size();\\n\\t\\tint maxGoodPeople = 0;\\n\\t\\tint mask = (1 << n);\\n\\t\\tfor (int currMask = 1; currMask < mask; currMask++) {\\n\\t\\t\\tif (isAllGoodPeople(statements, currMask)) {\\n\\t\\t\\t\\tmaxGoodPeople = max(maxGoodPeople, __builtin_popcount(currMask));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn maxGoodPeople;\\n\\t}\\n\\n\\tbool isAllGoodPeople(vector<vector<int>>& statements, int currMask) {\\n\\t\\tfor (int i = 0; i < statements.size(); i++) {\\n\\t\\t\\tif (currMask & (1 << i)) { // check whether current person is good or not\\n\\t\\t\\t\\t// if it\\'s a good person check his credibility by checking\\n\\t\\t\\t\\t// whether everyone he says good is actually good and everyone he says bad\\n\\t\\t\\t\\t// are really bad person\\n\\t\\t\\t\\tfor (int j = 0; j < statements.size(); j++) {\\n\\t\\t\\t\\t\\tbool isGoodPerson = (currMask & (1 << j)) ? 1 : 0;\\n\\t\\t\\t\\t\\tif ((isGoodPerson && statements[i][j] == 0) || (!isGoodPerson && statements[i][j] == 1)) {\\n\\t\\t\\t\\t\\t\\t// isGoodPerson && statements[i][j] == 0 -> according to our mask j-th person is good\\n\\t\\t\\t\\t\\t\\t// but our i-th guy says he is not. So our assumption about i-th guy being good might be wrong.\\n\\t\\t\\t\\t\\t\\t// invlid mask\\n\\n\\t\\t\\t\\t\\t\\t// !isGoodPerson && statements[i][j] == 1 -> according to our mask j-th person is bad\\n\\t\\t\\t\\t\\t\\t// but our i-th guy says he is good. So our assumption about i-th guy being good might be wrong.\\n\\t\\t\\t\\t\\t\\t// invlid mask\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1717626,
                "title": "c-java-python-detailed-easy-to-understand-bitmask",
                "content": "# Algorithm\\nWe have a `statements` matrix of size n by n made up of elements 0,1,2 where \\n- `statements[i][j]=1` means `person i` thinks `person j` is good.\\n- `statements[i][j]=0` means `person i` thinks `person j` is bad.\\n- `statements[i][j]=2` means `person i` doesnt comment on `person j`.\\n\\nWe also have these conditions:\\n- Good person speaks truth always\\n- Bad person can say truth or lie\\n\\nWe want to assign either 1 (for good) and 0 (for bad) to all persons in `0,1,..n-1` such that the `statements` matrix is feasible.\\n\\n## Pseudocode\\nNow let us write our pseudocode to validate an assignment:\\n```\\nFOR i in 0,..,n-1\\n\\tFOR j in 0,..,n-1\\n\\t\\t\\tIF person i is good AND person j \\u2260  statement of person i on person j\\n\\t\\t\\t\\tRETURN False\\nRETURN True\\n```\\nWe simply need to run this for all possible assignments and if the assignment is valid we count the number of ones. At the end we return the maximum number of ones out of all valid assignments.\\n\\n## Bitmask\\nNow, to use bitmask, let us have some notation:\\nWe have `2^n` ways of doing the assignment (each person can be either good or bad). Let us denote an assignment as a variable caleld `number` which is in the range `[0,2^n-1]`.  If ith digit from left is 1 then in our assignment person i is assigned good and if ith digit from left is 0 then in our assignment person i is assigned bad.\\nFor example say n is 3. The we can have 0,1,2,3,4,5,6,7 as possible assignments.\\n0 in binary is `000` so means all bad\\n1 in binary is `001` so means (0,1) are bad and 2 is good\\n5 in binary is `101` so means (0,2) are good, 1 is bad\\nand so on.\\n\\nNow let us write some logic we are gonna use later:\\n#### How do we find if in our assignment ith person is assigned good or bad?\\nFor exampel say our assignment is 5 ie `101`. Then\\n- `5 & 4 > 0` means person 0 is assigned 1 ie good\\n- `5 & 2 == 0` means person 1 is assigned 0 ie bad\\n- `5 & 1 > 0` means person 2 is assigned  1 ie good\\n\\nBasically it is just a way of iterating over the binary representation of the number.\\n\\nNow that we have all the pieces let us write the code:\\n\\n<iframe src=\"https://leetcode.com/playground/8LL9m5Nw/shared\" frameBorder=\"0\" width=\"800\" height=\"500\"></iframe>\\n\\nTime complexity: O((n^2 )* (2^n))\\nSpace complexity: O(1)\\n\\nThis solution beats 80% of the solutions in terms of runtime and beats 95% of solutions in terms of memory. Please upvote if you found this helpful.",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nFOR i in 0,..,n-1\\n\\tFOR j in 0,..,n-1\\n\\t\\t\\tIF person i is good AND person j \\u2260  statement of person i on person j\\n\\t\\t\\t\\tRETURN False\\nRETURN True\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1711491,
                "title": "java-good-mask",
                "content": "```\\nclass Solution {\\n    public int maximumGood(int[][] sts) {\\n        // 1. generate bitmask\\n        int n = sts.length;\\n        int res = 0;\\n        \\n        for (int i = (int) Math.pow(2, n); i < (int) Math.pow(2, n + 1); i++) {\\n            String bitmask = Integer.toBinaryString(i).substring(1);\\n            boolean conflict = false;\\n            for (int j = 0; !conflict&&j < n; j++) {\\n                if (bitmask.charAt(j) == \\'1\\') {\\n                    // 2. check his statements to others so we know if there\\'s a conflict. \\n                    for(int k = 0; !conflict&&k< sts[j].length; k++) {\\n                        if (sts[j][k]!=2 && sts[j][k] != bitmask.charAt(k)-\\'0\\') {\\n                            // this indicates there\\'s a conflict, so this guy is not good as we assumed\\n                            conflict=true;\\n                        }\\n                    }\\n                }\\n            }\\n            if(!conflict) {\\n                int temp = 0;\\n                for(int x = 0; x< bitmask.length(); x++){\\n                    temp+=bitmask.charAt(x)-\\'0\\';\\n                }\\n                res = Math.max(temp, res);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumGood(int[][] sts) {\\n        // 1. generate bitmask\\n        int n = sts.length;\\n        int res = 0;\\n        \\n        for (int i = (int) Math.pow(2, n); i < (int) Math.pow(2, n + 1); i++) {\\n            String bitmask = Integer.toBinaryString(i).substring(1);\\n            boolean conflict = false;\\n            for (int j = 0; !conflict&&j < n; j++) {\\n                if (bitmask.charAt(j) == \\'1\\') {\\n                    // 2. check his statements to others so we know if there\\'s a conflict. \\n                    for(int k = 0; !conflict&&k< sts[j].length; k++) {\\n                        if (sts[j][k]!=2 && sts[j][k] != bitmask.charAt(k)-\\'0\\') {\\n                            // this indicates there\\'s a conflict, so this guy is not good as we assumed\\n                            conflict=true;\\n                        }\\n                    }\\n                }\\n            }\\n            if(!conflict) {\\n                int temp = 0;\\n                for(int x = 0; x< bitmask.length(); x++){\\n                    temp+=bitmask.charAt(x)-\\'0\\';\\n                }\\n                res = Math.max(temp, res);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711432,
                "title": "python-easy-solution-with-comments",
                "content": "Since `N` is small, there is about `2^N` cases because each person can be either good or bad.\\n\\nWe can search for all cases, and for each case we check if there is any contradictions.\\n\\nFor example, if person `A` is bad in current case, but some good guy states that `A` is good, it\\'s obvious that this is a contradiction. The case for `A` being good is similar.\\n\\nTime complexity: `O((2^N) * (N^2))`\\n\\n```python\\nclass Solution:\\n    def maximumGood(self, mat):\\n        n = len(mat)\\n        \\n        good_stated = [[] for _ in range(n)]\\n        bad_stated = [[] for _ in range(n)]\\n        \\n        # store all person i who says that j is good (or bad)\\n        for i in range(n):\\n            for j in range(n):\\n                if mat[i][j] == 0:\\n                    bad_stated[j].append(i)\\n                if mat[i][j] == 1:\\n                    good_stated[j].append(i)\\n        \\n        ans = 0\\n        \\n        # start check every cases\\n        mask = (1 << n) - 1\\n        while mask:\\n            cur = sum(1 for i in range(n) if (1 << i) & mask)\\n            for i in range(n):\\n                if (1 << i) & mask:\\n                    # if person i is good but some other good guy says i is bad -> contradiction\\n                    if any((1 << per) & mask for per in bad_stated[i]):\\n                        break\\n                else:\\n                    # if person i is bad but some other good guy says i is good -> contradiction\\n                    if any((1 << per) & mask for per in good_stated[i]):\\n                        break\\n            else:\\n                # no contradiction, update answer\\n                ans = max(ans, cur)\\n            mask -= 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maximumGood(self, mat):\\n        n = len(mat)\\n        \\n        good_stated = [[] for _ in range(n)]\\n        bad_stated = [[] for _ in range(n)]\\n        \\n        # store all person i who says that j is good (or bad)\\n        for i in range(n):\\n            for j in range(n):\\n                if mat[i][j] == 0:\\n                    bad_stated[j].append(i)\\n                if mat[i][j] == 1:\\n                    good_stated[j].append(i)\\n        \\n        ans = 0\\n        \\n        # start check every cases\\n        mask = (1 << n) - 1\\n        while mask:\\n            cur = sum(1 for i in range(n) if (1 << i) & mask)\\n            for i in range(n):\\n                if (1 << i) & mask:\\n                    # if person i is good but some other good guy says i is bad -> contradiction\\n                    if any((1 << per) & mask for per in bad_stated[i]):\\n                        break\\n                else:\\n                    # if person i is bad but some other good guy says i is good -> contradiction\\n                    if any((1 << per) & mask for per in good_stated[i]):\\n                        break\\n            else:\\n                # no contradiction, update answer\\n                ans = max(ans, cur)\\n            mask -= 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711369,
                "title": "c-bitmask-o-2-n-n-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int countBits(int mask) {\\n        int cnt = 0;\\n        while(mask) {\\n            cnt += mask & 1;\\n            mask >>= 1;\\n        }\\n        return cnt;\\n    }\\n    int isGood(int mask, int i) {\\n        return mask & (1 << i);\\n    }\\n    int maximumGood(vector<vector<int>>& statements) {\\n        int n = statements.size();\\n        int mask = 1 << n;\\n        int ans = 0;\\n        for(int s = mask - 1; s >= 0; --s) {\\n            int isValid = true;\\n            for(int i = 0; i < n; ++i) {\\n                for(int j = 0; j < n; ++j) {\\n                    if(isGood(s, i)) {\\n                        if((statements[i][j] == 0 && isGood(s, j)) || (statements[i][j] == 1 && !isGood(s, j))) {\\n                            isValid = false;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if(!isValid) break;\\n            }\\n            if(isValid) {\\n                ans = max(ans, countBits(s));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countBits(int mask) {\\n        int cnt = 0;\\n        while(mask) {\\n            cnt += mask & 1;\\n            mask >>= 1;\\n        }\\n        return cnt;\\n    }\\n    int isGood(int mask, int i) {\\n        return mask & (1 << i);\\n    }\\n    int maximumGood(vector<vector<int>>& statements) {\\n        int n = statements.size();\\n        int mask = 1 << n;\\n        int ans = 0;\\n        for(int s = mask - 1; s >= 0; --s) {\\n            int isValid = true;\\n            for(int i = 0; i < n; ++i) {\\n                for(int j = 0; j < n; ++j) {\\n                    if(isGood(s, i)) {\\n                        if((statements[i][j] == 0 && isGood(s, j)) || (statements[i][j] == 1 && !isGood(s, j))) {\\n                            isValid = false;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if(!isValid) break;\\n            }\\n            if(isValid) {\\n                ans = max(ans, countBits(s));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2715394,
                "title": "bitmasking-video-solution",
                "content": "For the full video, you can check out this [Youtube video]( https://youtu.be/v7sr-1Zbh6k) \\n\\nSince `n<=15` we can brute force our solution and generate all possibilities of good / bad people of our group.\\nThen for each of those arrangement we will verify if there are no contradictions. \\nIf there are no contradictions then we will count the `1` bit. \\nThat is the number of good people. \\n\\n```\\nclass Solution:        \\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        \\n        n = len(statements)\\n        res = 0\\n        \\n        def checkGood(person, mask):\\n            if (mask>>person) & 1:\\n                return True\\n            return False\\n        \\n        def validateStatement(mask):\\n            for i in range(n):\\n                if checkGood(i, mask):\\n                    for j in range(n):\\n                        statement = statements[i][j]\\n                        \\n                        if (statement==0 and checkGood(j, mask)) or (statement==1 and not checkGood(j, mask)):\\n                            return False\\n            return True\\n        \\n        for i in range(1,1<<n): \\n            if validateStatement(i):\\n                res = max(res, bin(i).count(\\'1\\'))\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:        \\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        \\n        n = len(statements)\\n        res = 0\\n        \\n        def checkGood(person, mask):\\n            if (mask>>person) & 1:\\n                return True\\n            return False\\n        \\n        def validateStatement(mask):\\n            for i in range(n):\\n                if checkGood(i, mask):\\n                    for j in range(n):\\n                        statement = statements[i][j]\\n                        \\n                        if (statement==0 and checkGood(j, mask)) or (statement==1 and not checkGood(j, mask)):\\n                            return False\\n            return True\\n        \\n        for i in range(1,1<<n): \\n            if validateStatement(i):\\n                res = max(res, bin(i).count(\\'1\\'))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1742091,
                "title": "c-bitmask",
                "content": "A brute force question where we just have to check every pattern.\\n\\nIn the check function if the cur which represents the current person reaches the end of the array we check whether the given pattern is valid or not.\\n \\nIf 1 then good else if 0 then a bad person.\\n\\nTo check the pattern we will go through our mask and consider only the good people the statements of which we can trust.\\nWe will then check the statements of all the good people we assumed.\\nIf the statement of the assumed good person does not match with statement vector given then we will return false.\\n\\n       person id =>  `3  2  1`\\nExample: mask => 1  0  1 ,this is a mask so the `1` at the right means the `0th` person in our statement vector. \\n\\nstatements vector :\\n[[2,0,1],  => 2 won\\'t be consider and the rest is proper according to mask\\n[0,1,1],  => in the mask, value is 0 so we won\\'t consider these statements\\n[0,2,1]]  => person 3 states that person 1 is bad but in our mask the value is 1 so contradictory statement so the mask should not be considered.\\n\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    \\n    int check(int cur,vector<vector<int>>&statements,int mask){\\n        if(cur==n){\\n            for(int i=0;i<n;i++){\\n                if((mask&(1<<i))){\\n                    for(int j=0;j<n;j++){\\n                        int val = (mask&(1<<j))?1:0;\\n                        if(statements[i][j]!=2 && statements[i][j]!=val){\\n                            return INT_MIN;\\n                        }\\n                    }\\n                }\\n            }\\n            return 0;\\n        }\\n        int a = check(cur+1,statements,mask);\\n        int b = 1+check(cur+1,statements,(mask|(1<<cur)));\\n        return max(a,b);\\n    }\\n    \\n    int maximumGood(vector<vector<int>>& statements) {\\n        n=statements.size();\\n        int res = check(0,statements,0);\\n        return res<0?0:res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    \\n    int check(int cur,vector<vector<int>>&statements,int mask){\\n        if(cur==n){\\n            for(int i=0;i<n;i++){\\n                if((mask&(1<<i))){\\n                    for(int j=0;j<n;j++){\\n                        int val = (mask&(1<<j))?1:0;\\n                        if(statements[i][j]!=2 && statements[i][j]!=val){\\n                            return INT_MIN;\\n                        }\\n                    }\\n                }\\n            }\\n            return 0;\\n        }\\n        int a = check(cur+1,statements,mask);\\n        int b = 1+check(cur+1,statements,(mask|(1<<cur)));\\n        return max(a,b);\\n    }\\n    \\n    int maximumGood(vector<vector<int>>& statements) {\\n        n=statements.size();\\n        int res = check(0,statements,0);\\n        return res<0?0:res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1722530,
                "title": "well-explained-java-solution-dfs-with-backtracking-beat-99-9",
                "content": "```\\nclass Solution {\\n    public int maximumGood(int[][] statements) {  \\n        int[] result = { 0 };      \\n        maximumGood(statements, new boolean[statements.length], 0, 0, result);\\n        return result[0];\\n    }\\n    \\n    /*\\n        This function uses backtracking to do the DFS. We are basically constructing all possible scenarios and verifying them.\\n\\n        statements (int[][]): This is the input statements.\\n        goodPeople (boolean[]): This array tells who are good and bad in the group.\\n        currentPerson (int): This is the current person that we are verifying.\\n        currentGoodPeople (int): This is the number of the good people identified so far.\\n        result (int[]): This array holds the result, the total number of good people.\\n    */\\n    private void maximumGood(int[][] statements, boolean[] goodPeople, int currentPerson, int currentGoodPeople, int[] result) {\\n        if (currentPerson == goodPeople.length) {\\n            result[0] = Math.max(result[0], currentGoodPeople);\\n            return;\\n        }\\n        \\n        // Now we are going to use backtracking to do DFS.\\n\\n        // Scenario 1: Assume the current person is good and verify it.\\n        goodPeople[currentPerson] = true;\\n        // Prune the tree if the sum of unverified people (goodPeople.length - currentPerson) and verifyied good people (currentGoodPeople) is less than the result.\\n        if (goodPeople.length - currentPerson + currentGoodPeople < result[0]) {\\n            return;\\n        }\\n        if (isValid(statements, goodPeople, currentPerson)) {\\n            maximumGood(statements, goodPeople, currentPerson + 1, currentGoodPeople + 1, result);\\n        }\\n\\n        // Scenario 2: Assume the current person is bad and verify it.\\n        goodPeople[currentPerson] = false;      \\n        // Prune the tree for the same reason mentioned earlier.  \\n        if (goodPeople.length - currentPerson - 1 + currentGoodPeople < result[0]) {\\n            return;\\n        }\\n        if (isValid(statements, goodPeople, currentPerson)) {\\n            maximumGood(statements, goodPeople, currentPerson + 1, currentGoodPeople, result);\\n        }\\n        \\n        return;\\n    }\\n    \\n    private boolean isValid(int[][] statements, boolean[] goodPeople, int currentPerson) {\\n        // To verify if the current assumption of good/bad people is correct, we need to do 2 things.\\n        // 1. We need to verify the statements from all processed good people. What they said about the current person should be correct.\\n        for (int i = 0; i < currentPerson; ++i) {\\n            if (goodPeople[i]) {\\n                if (goodPeople[currentPerson] && statements[i][currentPerson] == 0) {\\n                    return false;\\n                }\\n                if (!goodPeople[currentPerson] && statements[i][currentPerson] == 1) {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        // 2. We need to verify the statement from the current person if he is good. What he said about other people should be correct.\\n        if (goodPeople[currentPerson]) {\\n            for (int i = 0; i < currentPerson; ++i) {\\n                if (goodPeople[i] && statements[currentPerson][i] == 0) return false;\\n                if (!goodPeople[i] && statements[currentPerson][i] == 1) return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumGood(int[][] statements) {  \\n        int[] result = { 0 };      \\n        maximumGood(statements, new boolean[statements.length], 0, 0, result);\\n        return result[0];\\n    }\\n    \\n    /*\\n        This function uses backtracking to do the DFS. We are basically constructing all possible scenarios and verifying them.\\n\\n        statements (int[][]): This is the input statements.\\n        goodPeople (boolean[]): This array tells who are good and bad in the group.\\n        currentPerson (int): This is the current person that we are verifying.\\n        currentGoodPeople (int): This is the number of the good people identified so far.\\n        result (int[]): This array holds the result, the total number of good people.\\n    */\\n    private void maximumGood(int[][] statements, boolean[] goodPeople, int currentPerson, int currentGoodPeople, int[] result) {\\n        if (currentPerson == goodPeople.length) {\\n            result[0] = Math.max(result[0], currentGoodPeople);\\n            return;\\n        }\\n        \\n        // Now we are going to use backtracking to do DFS.\\n\\n        // Scenario 1: Assume the current person is good and verify it.\\n        goodPeople[currentPerson] = true;\\n        // Prune the tree if the sum of unverified people (goodPeople.length - currentPerson) and verifyied good people (currentGoodPeople) is less than the result.\\n        if (goodPeople.length - currentPerson + currentGoodPeople < result[0]) {\\n            return;\\n        }\\n        if (isValid(statements, goodPeople, currentPerson)) {\\n            maximumGood(statements, goodPeople, currentPerson + 1, currentGoodPeople + 1, result);\\n        }\\n\\n        // Scenario 2: Assume the current person is bad and verify it.\\n        goodPeople[currentPerson] = false;      \\n        // Prune the tree for the same reason mentioned earlier.  \\n        if (goodPeople.length - currentPerson - 1 + currentGoodPeople < result[0]) {\\n            return;\\n        }\\n        if (isValid(statements, goodPeople, currentPerson)) {\\n            maximumGood(statements, goodPeople, currentPerson + 1, currentGoodPeople, result);\\n        }\\n        \\n        return;\\n    }\\n    \\n    private boolean isValid(int[][] statements, boolean[] goodPeople, int currentPerson) {\\n        // To verify if the current assumption of good/bad people is correct, we need to do 2 things.\\n        // 1. We need to verify the statements from all processed good people. What they said about the current person should be correct.\\n        for (int i = 0; i < currentPerson; ++i) {\\n            if (goodPeople[i]) {\\n                if (goodPeople[currentPerson] && statements[i][currentPerson] == 0) {\\n                    return false;\\n                }\\n                if (!goodPeople[currentPerson] && statements[i][currentPerson] == 1) {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        // 2. We need to verify the statement from the current person if he is good. What he said about other people should be correct.\\n        if (goodPeople[currentPerson]) {\\n            for (int i = 0; i < currentPerson; ++i) {\\n                if (goodPeople[i] && statements[currentPerson][i] == 0) return false;\\n                if (!goodPeople[i] && statements[currentPerson][i] == 1) return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711376,
                "title": "who-so-ever-tested-this-problem-does-not-do-his-job-properly",
                "content": "If the intended solution is O(2^n*N^2) then this is plain embarrasing \\n\\nAC Code after 12 attempts of pointless optimizations and seeing the rank fall from 200 to 2000 :\\n```\\n#pragma GCC optimize(\"Ofast\")\\n#pragma GCC target(\"avx,avx2,fma\")\\ntypedef long long ll;\\n#define is(S, i) ((S >> i) & 1)\\n\\nclass Solution {\\npublic:\\n    \\n    int maximumGood(vector<vector<int>>& st) {\\n        int n=st.size();\\n        int lim= 1LL<<n;\\n        lim--;\\n        int ans=0;\\n        unordered_map<int,int>has;\\n        for(int mask=1;mask<=lim;mask++){\\n            if(has[mask])continue;\\n            int status[n];\\n            queue<int>q;\\n             int vis[n];\\n            ll sz=0;\\n            memset(vis,0,sizeof(vis));\\n            memset(status,0,sizeof(status));\\n            for(int j=0;j<n;j++){\\n                if(is(mask,j)){\\n                    status[j]=1;\\n                    q.push(j);\\n                    vis[j]=1;\\n                }\\n            }\\n           \\n            //vector<ll>g,b;\\n            bool f=1;\\n            \\n            while(!q.empty()){\\n                if(!f)break;\\n                int i=q.front();\\n                vis[i]=1;\\n                q.pop();\\n                    for(int j=0;j<n;j++){\\n                        \\n                        if(!f)break;\\n                        if(st[i][j]==1){\\n                            if(vis[j]==0){\\n                                vis[j]=1;\\n                                status[j]=1;\\n                                q.push(j);\\n                            }\\n                            else{\\n                                if(status[j]==0){\\n                                    f=0;\\n                                    break;\\n                                }\\n                            }\\n                        }\\n                        if(st[i][j]==0){\\n                            \\n                            if(vis[j]==0){\\n                                vis[j]=1;\\n                                status[j]=0;\\n                            }\\n                            else{\\n                                if(status[j]==1){\\n                                    f=0;\\n                                    break;\\n                                }\\n                            }\\n                            \\n                        }\\n                        //Check ends here\\n                         \\n                    }\\n                \\n            }\\n            if(f){\\n            int c=0;\\n                int val=0;\\n            for(int j=0;j<n;j++){\\n                if(status[j]==1 ){\\n                    c++;\\n                    val+=1<<j;\\n                }\\n            }\\n            if(f){\\n                ans=max(ans,c);\\n                has[val]=1;\\n            }\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\nTLE Code in hidden test cases at first attempt\\n```\\n#pragma GCC optimize(\"Ofast\")\\n#pragma GCC target(\"avx,avx2,fma\")\\ntypedef long long ll;\\n#define is(S, i) ((S >> i) & 1)\\n\\nclass Solution {\\npublic:\\n    \\n    int maximumGood(vector<vector<int>>& st) {\\n        int n=st.size();\\n        int lim= 1LL<<n;\\n        lim--;\\n        int ans=0;\\n        unordered_map<int,int>has;\\n        for(int mask=1;mask<=lim;mask++){\\n            if(has[mask])continue;\\n            vector<int>status(n);\\n            queue<int>q;\\n             vector<bool>vis(n);\\n            ll sz=0;\\n            for(int j=0;j<n;j++){\\n                if(is(mask,j)){\\n                    status[j]=1;\\n                    q.push(j);\\n                    vis[j]=1;\\n                }\\n            }\\n           \\n            //vector<ll>g,b;\\n            bool f=1;\\n            \\n            while(!q.empty()){\\n                if(!f)break;\\n                int i=q.front();\\n                vis[i]=1;\\n                q.pop();\\n                    for(int j=0;j<n;j++){\\n                        \\n                        if(!f)break;\\n                        if(st[i][j]==1){\\n                            if(vis[j]==0){\\n                                vis[j]=1;\\n                                status[j]=1;\\n                                q.push(j);\\n                            }\\n                            else{\\n                                if(status[j]==0){\\n                                    f=0;\\n                                    break;\\n                                }\\n                            }\\n                        }\\n                        if(st[i][j]==0){\\n                            \\n                            if(vis[j]==0){\\n                                vis[j]=1;\\n                                status[j]=0;\\n                            }\\n                            else{\\n                                if(status[j]==1){\\n                                    f=0;\\n                                    break;\\n                                }\\n                            }\\n                            \\n                        }\\n                        //Check ends here\\n                         \\n                    }\\n                \\n            }\\n            if(f){\\n            int c=0;\\n                int val=0;\\n            for(int j=0;j<n;j++){\\n                if(status[j]){\\n                    c++;\\n                    val+=1<<j;\\n                }\\n            }\\n            if(f){\\n                ans=max(ans,c);\\n                has[val]=1;\\n            }\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\nI am ranting here because both solutions have no difference and I had to suffer too much today without any fault of my own",
                "solutionTags": [],
                "code": "```\\n#pragma GCC optimize(\"Ofast\")\\n#pragma GCC target(\"avx,avx2,fma\")\\ntypedef long long ll;\\n#define is(S, i) ((S >> i) & 1)\\n\\nclass Solution {\\npublic:\\n    \\n    int maximumGood(vector<vector<int>>& st) {\\n        int n=st.size();\\n        int lim= 1LL<<n;\\n        lim--;\\n        int ans=0;\\n        unordered_map<int,int>has;\\n        for(int mask=1;mask<=lim;mask++){\\n            if(has[mask])continue;\\n            int status[n];\\n            queue<int>q;\\n             int vis[n];\\n            ll sz=0;\\n            memset(vis,0,sizeof(vis));\\n            memset(status,0,sizeof(status));\\n            for(int j=0;j<n;j++){\\n                if(is(mask,j)){\\n                    status[j]=1;\\n                    q.push(j);\\n                    vis[j]=1;\\n                }\\n            }\\n           \\n            //vector<ll>g,b;\\n            bool f=1;\\n            \\n            while(!q.empty()){\\n                if(!f)break;\\n                int i=q.front();\\n                vis[i]=1;\\n                q.pop();\\n                    for(int j=0;j<n;j++){\\n                        \\n                        if(!f)break;\\n                        if(st[i][j]==1){\\n                            if(vis[j]==0){\\n                                vis[j]=1;\\n                                status[j]=1;\\n                                q.push(j);\\n                            }\\n                            else{\\n                                if(status[j]==0){\\n                                    f=0;\\n                                    break;\\n                                }\\n                            }\\n                        }\\n                        if(st[i][j]==0){\\n                            \\n                            if(vis[j]==0){\\n                                vis[j]=1;\\n                                status[j]=0;\\n                            }\\n                            else{\\n                                if(status[j]==1){\\n                                    f=0;\\n                                    break;\\n                                }\\n                            }\\n                            \\n                        }\\n                        //Check ends here\\n                         \\n                    }\\n                \\n            }\\n            if(f){\\n            int c=0;\\n                int val=0;\\n            for(int j=0;j<n;j++){\\n                if(status[j]==1 ){\\n                    c++;\\n                    val+=1<<j;\\n                }\\n            }\\n            if(f){\\n                ans=max(ans,c);\\n                has[val]=1;\\n            }\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\n```\\n#pragma GCC optimize(\"Ofast\")\\n#pragma GCC target(\"avx,avx2,fma\")\\ntypedef long long ll;\\n#define is(S, i) ((S >> i) & 1)\\n\\nclass Solution {\\npublic:\\n    \\n    int maximumGood(vector<vector<int>>& st) {\\n        int n=st.size();\\n        int lim= 1LL<<n;\\n        lim--;\\n        int ans=0;\\n        unordered_map<int,int>has;\\n        for(int mask=1;mask<=lim;mask++){\\n            if(has[mask])continue;\\n            vector<int>status(n);\\n            queue<int>q;\\n             vector<bool>vis(n);\\n            ll sz=0;\\n            for(int j=0;j<n;j++){\\n                if(is(mask,j)){\\n                    status[j]=1;\\n                    q.push(j);\\n                    vis[j]=1;\\n                }\\n            }\\n           \\n            //vector<ll>g,b;\\n            bool f=1;\\n            \\n            while(!q.empty()){\\n                if(!f)break;\\n                int i=q.front();\\n                vis[i]=1;\\n                q.pop();\\n                    for(int j=0;j<n;j++){\\n                        \\n                        if(!f)break;\\n                        if(st[i][j]==1){\\n                            if(vis[j]==0){\\n                                vis[j]=1;\\n                                status[j]=1;\\n                                q.push(j);\\n                            }\\n                            else{\\n                                if(status[j]==0){\\n                                    f=0;\\n                                    break;\\n                                }\\n                            }\\n                        }\\n                        if(st[i][j]==0){\\n                            \\n                            if(vis[j]==0){\\n                                vis[j]=1;\\n                                status[j]=0;\\n                            }\\n                            else{\\n                                if(status[j]==1){\\n                                    f=0;\\n                                    break;\\n                                }\\n                            }\\n                            \\n                        }\\n                        //Check ends here\\n                         \\n                    }\\n                \\n            }\\n            if(f){\\n            int c=0;\\n                int val=0;\\n            for(int j=0;j<n;j++){\\n                if(status[j]){\\n                    c++;\\n                    val+=1<<j;\\n                }\\n            }\\n            if(f){\\n                ans=max(ans,c);\\n                has[val]=1;\\n            }\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711227,
                "title": "hypothesize-and-find-contradictions",
                "content": "This problem is pretty straightforward. Since there are only at most `n = 15` people in the group, we can just create all `2^n` possible lists of good people as hypotheses and check if there is a contadiction in each of the lists.\\n\\nThere are two possible contradictions. \\n1. a good person thinks someone is bad, but that person is actually in the good list.\\n2. a good person thinks someone is good but that person isn\\'t actually in the good list.\\n\\nNote that because bad people may lie *or* tell the truth, they aren\\'t useful at conveying information.\\n\\nHere is the code written in javascript:\\n\\n```js\\nvar maximumGood = function(statements) {\\n\\n    // Accepts a list of good people and returns if there is no contradiction\\n    function check(good) {\\n        for (const p of good) {\\n            for (let j = 0; j < statements.length; j++) {\\n                // if good person p thinks person j lied, but \\n                // person j is good, we have a contradiction\\n                if (statements[p][j] === 0) {\\n                    if (good.includes(j)) return false;\\n                }\\n                // if good person p thinks person j is good, but \\n                // person j is not good, we have a contradiction\\n                if (statements[p][j] === 1) {\\n                    if (!good.includes(j)) return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    // Tries every possible list of good people, and\\n    // and returns the length of the largest one.\\n    function getLargestValidList(i, good) {\\n        if (i >= statements.length) {\\n            return check(good) ? good.length : 0;\\n        }\\n\\t\\t\\n\\t\\t// check list including i\\n        good.push(i);\\n        let res = getLargestValidList(i + 1, good);\\n        good.pop();\\n\\t\\t\\n\\t\\t// check list not including i and return the larger of the two\\n        return Math.max(res, getLargestValidList(i + 1, good));\\n    }\\n    return getLargestValidList(0, []);\\n};\\n```\\n\\nThe time complexity of this implementation is `O(2^n * n^3)`. Good thing n is small!",
                "solutionTags": [],
                "code": "```js\\nvar maximumGood = function(statements) {\\n\\n    // Accepts a list of good people and returns if there is no contradiction\\n    function check(good) {\\n        for (const p of good) {\\n            for (let j = 0; j < statements.length; j++) {\\n                // if good person p thinks person j lied, but \\n                // person j is good, we have a contradiction\\n                if (statements[p][j] === 0) {\\n                    if (good.includes(j)) return false;\\n                }\\n                // if good person p thinks person j is good, but \\n                // person j is not good, we have a contradiction\\n                if (statements[p][j] === 1) {\\n                    if (!good.includes(j)) return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    // Tries every possible list of good people, and\\n    // and returns the length of the largest one.\\n    function getLargestValidList(i, good) {\\n        if (i >= statements.length) {\\n            return check(good) ? good.length : 0;\\n        }\\n\\t\\t\\n\\t\\t// check list including i\\n        good.push(i);\\n        let res = getLargestValidList(i + 1, good);\\n        good.pop();\\n\\t\\t\\n\\t\\t// check list not including i and return the larger of the two\\n        return Math.max(res, getLargestValidList(i + 1, good));\\n    }\\n    return getLargestValidList(0, []);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1712028,
                "title": "simple-recursive-approach",
                "content": "if you don\\'t want to use bit just use recursion to generate all possible combination of 1 and 0 of length n beacause bit also do the same thing but if you are confused then it\\'s good to go without bit.\\nif you have any queries then please comment below \\nthanks.\\n```\\ndef fun(n,ans,c): #this generate all the combination of 1 and 0 of lenght n.(simple recursion)\\n    if len(c)==n:\\n        ans.append(c)\\n        return\\n    p=c\\n    fun(n,ans,p+\"1\")\\n    fun(n,ans,c+\"0\")\\n\\nclass Solution:\\n    def maximumGood(self, st: List[List[int]]) -> int:\\n        n=len(st)\\n        ans=[]\\n        c=\"\"\\n        fun(n,ans,c)\\n        res=0\\n        for i in ans:\\n            g=i\\n            flag=True\\n            for j in range(n):\\n                if g[j]==\"1\": # this is because we don\\'t need to check for bad because he can lie also so we don\\'t care about bad one.\\n                    for k in range(n):\\n                        if st[j][k]!=2 and st[j][k]!=int(g[k]): \\n                            flag = False\\n                            break\\n                    if not flag:\\n                        break\\n            if flag:\\n                res = max(res,g.count(\"1\"))\\n        return res\\n\\t\\t\\n",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "if you don\\'t want to use bit just use recursion to generate all possible combination of 1 and 0 of length n beacause bit also do the same thing but if you are confused then it\\'s good to go without bit.\\nif you have any queries then please comment below \\nthanks.\\n```\\ndef fun(n,ans,c): #this generate all the combination of 1 and 0 of lenght n.(simple recursion)\\n    if len(c)==n:\\n        ans.append(c)\\n        return\\n    p=c\\n    fun(n,ans,p+\"1\")\\n    fun(n,ans,c+\"0\")\\n\\nclass Solution:\\n    def maximumGood(self, st: List[List[int]]) -> int:\\n        n=len(st)\\n        ans=[]\\n        c=\"\"\\n        fun(n,ans,c)\\n        res=0\\n        for i in ans:\\n            g=i\\n            flag=True\\n            for j in range(n):\\n                if g[j]==\"1\": # this is because we don\\'t need to check for bad because he can lie also so we don\\'t care about bad one.\\n                    for k in range(n):\\n                        if st[j][k]!=2 and st[j][k]!=int(g[k]): \\n                            flag = False\\n                            break\\n                    if not flag:\\n                        break\\n            if flag:\\n                res = max(res,g.count(\"1\"))\\n        return res\\n\\t\\t\\n",
                "codeTag": "Java"
            },
            {
                "id": 3677932,
                "title": "c-super-easy-clean-code-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int countMax(string& s, vector<vector<int>>& stats){\\n        int n = s.size();\\n        int cnt = 0;\\n        for(int i=0; i<n; i++){\\n            if(s[i] == \\'0\\') continue;\\n            cnt++;\\n            for(int j=0; j<n; j++){\\n                if(stats[i][j] == 1 && s[j] == \\'0\\') return 0;\\n                if(stats[i][j] == 0 && s[j] == \\'1\\') return 0;\\n            }\\n        }\\n        return cnt;\\n    }\\nprivate:\\n    int solver(int i, string s, vector<vector<int>>& stats){\\n        if(i == stats.size()){\\n            return countMax(s,stats);\\n        }\\n\\n        int good = solver(i+1,s+\\'1\\',stats);\\n        int bad = solver(i+1,s+\\'0\\',stats);\\n\\n        return max(good,bad);\\n    }\\npublic:\\n    int maximumGood(vector<vector<int>>& statements) {\\n        \\n        return solver(0,\"\",statements);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int countMax(string& s, vector<vector<int>>& stats){\\n        int n = s.size();\\n        int cnt = 0;\\n        for(int i=0; i<n; i++){\\n            if(s[i] == \\'0\\') continue;\\n            cnt++;\\n            for(int j=0; j<n; j++){\\n                if(stats[i][j] == 1 && s[j] == \\'0\\') return 0;\\n                if(stats[i][j] == 0 && s[j] == \\'1\\') return 0;\\n            }\\n        }\\n        return cnt;\\n    }\\nprivate:\\n    int solver(int i, string s, vector<vector<int>>& stats){\\n        if(i == stats.size()){\\n            return countMax(s,stats);\\n        }\\n\\n        int good = solver(i+1,s+\\'1\\',stats);\\n        int bad = solver(i+1,s+\\'0\\',stats);\\n\\n        return max(good,bad);\\n    }\\npublic:\\n    int maximumGood(vector<vector<int>>& statements) {\\n        \\n        return solver(0,\"\",statements);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018935,
                "title": "c-bit-manipulation-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(2^n * n^2)$$\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumGood(vector<vector<int>>& statements) {\\n        int ans=0;\\n        for(int i=1; i<(1<<statements.size()); i++){\\n            int chk=1;\\n            for(int j=0; j<statements.size(); j++){\\n                if(!(i&(1<<j))){\\n                    continue;\\n                }\\n                for(int k=0; k<statements.size(); k++){\\n                    if((i&(1<<k)) && statements[j][k]==0){\\n                        chk=-1; break;\\n                    }\\n                    else if(!(i&(1<<k)) && statements[j][k]==1){\\n                        chk=-1; break;\\n                    }\\n                }\\n                if(chk==-1){break;}\\n            }\\n            if(chk==1){\\n                int cnt=0;\\n                int n1=i;\\n                while(n1>0){\\n                    if(1&n1){cnt++;}\\n                    n1=n1>>1;\\n                }\\n                ans=max(ans, cnt);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGood(vector<vector<int>>& statements) {\\n        int ans=0;\\n        for(int i=1; i<(1<<statements.size()); i++){\\n            int chk=1;\\n            for(int j=0; j<statements.size(); j++){\\n                if(!(i&(1<<j))){\\n                    continue;\\n                }\\n                for(int k=0; k<statements.size(); k++){\\n                    if((i&(1<<k)) && statements[j][k]==0){\\n                        chk=-1; break;\\n                    }\\n                    else if(!(i&(1<<k)) && statements[j][k]==1){\\n                        chk=-1; break;\\n                    }\\n                }\\n                if(chk==-1){break;}\\n            }\\n            if(chk==1){\\n                int cnt=0;\\n                int n1=i;\\n                while(n1>0){\\n                    if(1&n1){cnt++;}\\n                    n1=n1>>1;\\n                }\\n                ans=max(ans, cnt);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772288,
                "title": "one-liner-for-fun-python",
                "content": "```\\nclass Solution:\\n    def maximumGood(self, s):\\n        return max(bin(b).count(\\'1\\') for b in range(1 << len(s)) # go through all combinations of good, bad\\n                   if all(all(g == (b >> i) & 1 for i, g in enumerate(s[w]) if g != 2) # check good\\'s statements match ours\\n                          for w in range(len(s)) if b & (1 << w))) # for each good \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumGood(self, s):\\n        return max(bin(b).count(\\'1\\') for b in range(1 << len(s)) # go through all combinations of good, bad\\n                   if all(all(g == (b >> i) & 1 for i, g in enumerate(s[w]) if g != 2) # check good\\'s statements match ours\\n                          for w in range(len(s)) if b & (1 << w))) # for each good \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730857,
                "title": "c-simple-recursive-approach-explanation",
                "content": "This post can be beneficial for someone who lacks confidence in solving recursive problems.\\n\\n**Brute force approach:**\\nGiven n people, each person can either be good or bad, so there are 2<sup>n</sup> combinations but each combination may not be valid. So, if we apply brute force and check if its valid or not and based on that calculate the maximum no of good people, the time complexity for should be O(2<sup>n</sup> * n<sup>2</sup>). For n = 15, the complexity is not too large and will work within the alloted time frame.\\nSo, we are good to go with brute force approach and do not need backtracking to prune the recursion tree (although that will be faster than this approach).\\n\\nLet\\'s look at the code.\\nIn the function definition, vector v is used to store whether the person i is good or bad. In case `i` is good, `v[i] = 1`, otherwise 0. A better approach could have been bitmasking, where we could have used a string of length n and stored character `1` at index `i` if person `i` is good.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> stm;\\n    int n;\\n\\tint rf(vector<int> v, int i){\\n\\t\\t\\tif(i>=n){\\n\\t\\t\\t\\t//check valid\\n\\t\\t\\t\\tint cnt = 0;\\n\\t\\t\\t\\tfor(int i=0; i<n; i++){\\n\\t\\t\\t\\t\\tif(v[i] == 1){\\n\\t\\t\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\t\\t\\tfor(int j=0; j<n; j++){\\n\\t\\t\\t\\t\\t\\t\\t// if not valid, return -1\\n\\t\\t\\t\\t\\t\\t\\tif(stm[i][j] == 1 && v[j] == 0) return -1;\\n\\t\\t\\t\\t\\t\\t\\tif(stm[i][j] == 0 && v[j] == 1) return -1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// if valid, return good people count\\n\\t\\t\\t\\treturn cnt;\\n\\t\\t\\t}\\n\\t\\t\\t// let person i be good\\n\\t\\t\\tv[i] = 1;\\n\\t\\t\\tint x = rf(v,i+1);\\n\\t\\t\\t\\n\\t\\t\\t// let person i be bad\\n\\t\\t\\tv[i] = 0;\\n\\t\\t\\tint y = rf(v, i+1);\\n\\t\\t\\t\\n\\t\\t\\treturn max({0,x,y});\\n\\t}\\n\\tint maximumGood(vector<vector<int>>& statements) {\\n        n = statements.size();\\n        stm = statements;\\n        vector<int> v(n);\\n        return rf(v,0);\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> stm;\\n    int n;\\n\\tint rf(vector<int> v, int i){\\n\\t\\t\\tif(i>=n){\\n\\t\\t\\t\\t//check valid\\n\\t\\t\\t\\tint cnt = 0;\\n\\t\\t\\t\\tfor(int i=0; i<n; i++){\\n\\t\\t\\t\\t\\tif(v[i] == 1){\\n\\t\\t\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\t\\t\\tfor(int j=0; j<n; j++){\\n\\t\\t\\t\\t\\t\\t\\t// if not valid, return -1\\n\\t\\t\\t\\t\\t\\t\\tif(stm[i][j] == 1 && v[j] == 0) return -1;\\n\\t\\t\\t\\t\\t\\t\\tif(stm[i][j] == 0 && v[j] == 1) return -1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// if valid, return good people count\\n\\t\\t\\t\\treturn cnt;\\n\\t\\t\\t}\\n\\t\\t\\t// let person i be good\\n\\t\\t\\tv[i] = 1;\\n\\t\\t\\tint x = rf(v,i+1);\\n\\t\\t\\t\\n\\t\\t\\t// let person i be bad\\n\\t\\t\\tv[i] = 0;\\n\\t\\t\\tint y = rf(v, i+1);\\n\\t\\t\\t\\n\\t\\t\\treturn max({0,x,y});\\n\\t}\\n\\tint maximumGood(vector<vector<int>>& statements) {\\n        n = statements.size();\\n        stm = statements;\\n        vector<int> v(n);\\n        return rf(v,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1717111,
                "title": "c-bitmask-with-comments-power-set",
                "content": "```\\nclass Solution {\\nprivate:\\n    bool isCorrect_Configuration(int c, vector<vector<int>>& arr, int n){\\n        for(int i=0; i<n; i++){\\n            if(c & (1<<i)){ //if ith person is a good person then only check his row\\n                for(int j=0; j<n; j++){\\n                    if(arr[i][j] != 2 && arr[i][j] != bool(c & (1<<j))){\\n                        return false; //if at any moment, the given configuration fails to distinguish between good person or bad person according to given statements(arr), just return false, coz this an invalid configuration.\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\npublic:\\n    int maximumGood(vector<vector<int>>& arr) {\\n        int n = arr.size();\\n        \\n        //Power set \\n        int maxi = 0;\\n        for(int c=0; c<(1<<n); c++){ //generate all configurations\\n            if(isCorrect_Configuration(c,arr,n)){ //if its a valid config, count the number of good persons in the mask\\n                maxi = max(maxi,__builtin_popcount(c)); //and return the maximum of them\\n            }\\n        }\\n        return maxi;\\n        \\n        //TC = O(N^2 * 2^N)\\n        //SC = O(1)\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool isCorrect_Configuration(int c, vector<vector<int>>& arr, int n){\\n        for(int i=0; i<n; i++){\\n            if(c & (1<<i)){ //if ith person is a good person then only check his row\\n                for(int j=0; j<n; j++){\\n                    if(arr[i][j] != 2 && arr[i][j] != bool(c & (1<<j))){\\n                        return false; //if at any moment, the given configuration fails to distinguish between good person or bad person according to given statements(arr), just return false, coz this an invalid configuration.\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\npublic:\\n    int maximumGood(vector<vector<int>>& arr) {\\n        int n = arr.size();\\n        \\n        //Power set \\n        int maxi = 0;\\n        for(int c=0; c<(1<<n); c++){ //generate all configurations\\n            if(isCorrect_Configuration(c,arr,n)){ //if its a valid config, count the number of good persons in the mask\\n                maxi = max(maxi,__builtin_popcount(c)); //and return the maximum of them\\n            }\\n        }\\n        return maxi;\\n        \\n        //TC = O(N^2 * 2^N)\\n        //SC = O(1)\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1714340,
                "title": "python3-check-all-candidates",
                "content": "\\n```\\nclass Solution:\\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        n = len(statements)\\n        ans = 0 \\n        for k in range(n, -1, -1): \\n            for good in combinations(list(range(n)), k): \\n                cand = True \\n                for i in good: \\n                    if cand: \\n                        for j in range(n): \\n                            if i != j and (statements[i][j] == 0 and j in good or statements[i][j] == 1 and j not in good): \\n                                cand = False \\n                                break \\n                if cand: return k\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        n = len(statements)\\n        ans = 0 \\n        for k in range(n, -1, -1): \\n            for good in combinations(list(range(n)), k): \\n                cand = True \\n                for i in good: \\n                    if cand: \\n                        for j in range(n): \\n                            if i != j and (statements[i][j] == 0 and j in good or statements[i][j] == 1 and j not in good): \\n                                cand = False \\n                                break \\n                if cand: return k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712322,
                "title": "c-o-2-n-n-2-power-set-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumGood(vector<vector<int>>& statements) {\\n        int n = statements.size();\\n        int ans = 0;\\n        // Checking for each permutation.\\n        // every number from 1 to 2^n -1 will represent a permutation.\\n        // Each permutation can be valid answer but we will choose the one which has\\n        // maximum number of true person, that is which number has maximum number of set_bits in it.\\n        for(int i=1;i<(1<<n);i++) {\\n            bool flag = true;\\n            // checking each bit of each number.\\n            // there will be n bits of each number.\\n            // if jth bit of ith number is true, that means that in our ith permutation jth person is good.\\n            // if jth bit of ith number is false, that means that in our ith permutation jth person is bad.\\n            for(int j=0;j<n;j++) {\\n                // if the jth bit of ith number is zero that means\\n                // the jth person is a bad person, and we don\\'t need to check for his \\n                // statements as he can be lying.\\n                if(!(i&(1<<j))) {\\n                    continue;\\n                }\\n                // jth bit of ith number is one that means \\n                // the jth person is a good person, therefore we will be checking further.\\n                for(int k=0;k<n;k++) {\\n                    // if jth person told that kth person is good, but kth bit in \\n                    // i is 0, i.e in our permuatation kth person is bad, then this permutation is wrong.\\n                    // as jth person is can\\'t lie, because jth person is a good person.\\n                    if(statements[j][k] == 1 && (!(i & (1<<k)))) {\\n                        flag = false;\\n                        break;\\n                    }\\n                    // if the jth person told that kth person is a bad, but kth bit in i is 1\\n                    // i.e. in our permuation kth person is good, then it will also be contradictory.\\n                    if(statements[j][k] == 0 && (i & (1<<k))) {\\n                        flag = false;\\n                        break;\\n                    }\\n                    // if our current permuation is invalid then break.\\n                    // and check for next permutation.\\n                    if(!flag) {\\n                        break;\\n                    }\\n                }\\n            }\\n            if(flag) {\\n                ans = max(ans,__builtin_popcount(i));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGood(vector<vector<int>>& statements) {\\n        int n = statements.size();\\n        int ans = 0;\\n        // Checking for each permutation.\\n        // every number from 1 to 2^n -1 will represent a permutation.\\n        // Each permutation can be valid answer but we will choose the one which has\\n        // maximum number of true person, that is which number has maximum number of set_bits in it.\\n        for(int i=1;i<(1<<n);i++) {\\n            bool flag = true;\\n            // checking each bit of each number.\\n            // there will be n bits of each number.\\n            // if jth bit of ith number is true, that means that in our ith permutation jth person is good.\\n            // if jth bit of ith number is false, that means that in our ith permutation jth person is bad.\\n            for(int j=0;j<n;j++) {\\n                // if the jth bit of ith number is zero that means\\n                // the jth person is a bad person, and we don\\'t need to check for his \\n                // statements as he can be lying.\\n                if(!(i&(1<<j))) {\\n                    continue;\\n                }\\n                // jth bit of ith number is one that means \\n                // the jth person is a good person, therefore we will be checking further.\\n                for(int k=0;k<n;k++) {\\n                    // if jth person told that kth person is good, but kth bit in \\n                    // i is 0, i.e in our permuatation kth person is bad, then this permutation is wrong.\\n                    // as jth person is can\\'t lie, because jth person is a good person.\\n                    if(statements[j][k] == 1 && (!(i & (1<<k)))) {\\n                        flag = false;\\n                        break;\\n                    }\\n                    // if the jth person told that kth person is a bad, but kth bit in i is 1\\n                    // i.e. in our permuation kth person is good, then it will also be contradictory.\\n                    if(statements[j][k] == 0 && (i & (1<<k))) {\\n                        flag = false;\\n                        break;\\n                    }\\n                    // if our current permuation is invalid then break.\\n                    // and check for next permutation.\\n                    if(!flag) {\\n                        break;\\n                    }\\n                }\\n            }\\n            if(flag) {\\n                ans = max(ans,__builtin_popcount(i));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711677,
                "title": "python-3-itertools-bitmask-explanation",
                "content": "### Explanation\\n- The idea is super simple: Test out possibilities and take the one has most `good` persons\\n\\t- There are at most `2^15 = 32768` possibilities\\n\\t- The `n*n` matrix `statements` will have at most `15 * 15 = 225` cells\\n\\t- Total will be `2 ^ 15 * 15 * 15 = 7372800 ~= 7 * 10^3 * 10^3`\\n\\t\\t- The general acceptance time complexity for LeetCode is around `10^6`\\n\\t\\t- With some optimization, we can make the time complexity of the idea much faster than `7 * 10^3 * 10^3`\\n### Approach \\\\#1. Use Python `itertools.product` to create mask\\n- Use `itertools.product` to make a list only contains `0` or `1` with a length of `n = len(statements)`\\n- Take this list and test it against the `statements` (i.e. `Proof by contradiction`)\\n\\t- Assuming the list is the correct `good` & `bad` identity for each person\\n\\t- If a `good` person\\'s statement on someone else is different from what the list says, then there is a **contradiction**\\n\\t- We will discard this list and continue to test the next one\\n- See below comments for more explanation\\n```python\\nclass Solution:\\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        ans, n = 0, len(statements)\\n        for person in itertools.product([0, 1], repeat=n): # use itertools to create a list only contains 0 or 1\\n            valid = True                                   # initially, we think the `person` list is valid\\n            for i in range(n):\\n                if not person[i]: continue                 # only `good` person\\'s statement can lead to a contradiction, we don\\'t care what `bad` person says\\n                for j in range(n):\\n                    if statements[i][j] == 2: continue     # ignore is no statement was made\\n                    if statements[i][j] != person[j]:      # if there is a contradiction, then valid = False\\n                        valid = False\\n                        break                              # optimization: break the loop when not valid\\n                if not valid:                              # optimization: break the loop when not valid\\n                    break        \\n            if valid: \\n                ans = max(ans, sum(person))                # count sum only when valid == True\\n        return ans\\n```\\n### Approach \\\\#2. Bitmask\\n- Below is a bitmask version of the above approach. I think for most starters, **Approach #1** is easier to understand. If you are not familiar with bitmask or bit operation, that\\'s totally fine. It takes time to build that mindset.\\n- See comments below for more explanation\\n```python\\nclass Solution:\\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        ans, n = 0, len(statements)\\n        for mask in range(1 << n):                           # 2**n possibilities\\n            valid = True\\n            for i in range(n):\\n                if not (mask >> i) & 1: continue             # check if the `i`th person is a `good` person\\n                for j in range(n):\\n                    if statements[i][j] == 2: continue\\n                    elif statements[i][j] != (mask >> j) & 1:# check if `i`th person\\'s statement about `j` matches what `mask` says\\n                        valid = False\\n                        break                                # optimization: break the loop when not valid\\n                if not valid: \\n                    break                                    # optimization: break the loop when not valid\\n            if valid: \\n                ans = max(ans, bin(mask).count(\\'1\\'))         # count `1` in mask, take the largest\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bitmask"
                ],
                "code": "```python\\nclass Solution:\\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        ans, n = 0, len(statements)\\n        for person in itertools.product([0, 1], repeat=n): # use itertools to create a list only contains 0 or 1\\n            valid = True                                   # initially, we think the `person` list is valid\\n            for i in range(n):\\n                if not person[i]: continue                 # only `good` person\\'s statement can lead to a contradiction, we don\\'t care what `bad` person says\\n                for j in range(n):\\n                    if statements[i][j] == 2: continue     # ignore is no statement was made\\n                    if statements[i][j] != person[j]:      # if there is a contradiction, then valid = False\\n                        valid = False\\n                        break                              # optimization: break the loop when not valid\\n                if not valid:                              # optimization: break the loop when not valid\\n                    break        \\n            if valid: \\n                ans = max(ans, sum(person))                # count sum only when valid == True\\n        return ans\\n```\n```python\\nclass Solution:\\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        ans, n = 0, len(statements)\\n        for mask in range(1 << n):                           # 2**n possibilities\\n            valid = True\\n            for i in range(n):\\n                if not (mask >> i) & 1: continue             # check if the `i`th person is a `good` person\\n                for j in range(n):\\n                    if statements[i][j] == 2: continue\\n                    elif statements[i][j] != (mask >> j) & 1:# check if `i`th person\\'s statement about `j` matches what `mask` says\\n                        valid = False\\n                        break                                # optimization: break the loop when not valid\\n                if not valid: \\n                    break                                    # optimization: break the loop when not valid\\n            if valid: \\n                ans = max(ans, bin(mask).count(\\'1\\'))         # count `1` in mask, take the largest\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711645,
                "title": "java-simple-solution-bit-masking",
                "content": "Enumerate bitmask X from 0 to 2^N. If the ith bit of X is:\\n* 1, it means that person i is good.\\n* 0, it means that person i is bad.\\n\\nWe can ignore bad persons\\' statements because they can be either true or false. But good persons\\' statements must be all correct.\\n\\nTo test if this bitmask X is valid, we go through all the good persons\\' statements and see if there is any contradiction.\\n\\n```\\nclass Solution {\\n    public int maximumGood(int[][] statements) {\\n        int n = statements.length;\\n        int res = 0;\\n        \\n        for(int i = 0; i < (1 << n); i++) {\\n            if(isValidGuess(statements, i)) {\\n                res = Math.max(res, countActiveBits(i));\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private boolean isValidGuess(int[][] statements, int guess) {\\n        int n = statements.length;\\n        \\n        for(int i = 0; i < n; i++) {\\n            // if i-th person is a good person\\n            if(isGuessedAsGood(guess, i, n)) {\\n                // Since i is a good person, all the statements by i would be true\\n                // So check if the statements given by i for other people\\n                // and the guess made by us for those people are the same\\n                // if not then the guess that we have made is not valid and return false\\n                for(int j = 0; j < n; j++) {\\n                    if(statements[i][j] != 2 &&\\n                       statements[i][j] != (isGuessedAsGood(guess, j, n) ? 1 : 0)) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private boolean isGuessedAsGood(int guess, int person, int total) {\\n        // a person is a good person if the (n - 1 - i)th bit is 1\\n        return (guess & (1 << (total - 1 - person))) > 0;\\n    }\\n    \\n    private int countActiveBits(int num) {\\n        int c = 0;\\n        \\n        while(num > 0) {\\n            if((num & 1) > 0)\\n                c++;\\n            \\n            num >>= 1;\\n        }\\n        \\n        return c;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumGood(int[][] statements) {\\n        int n = statements.length;\\n        int res = 0;\\n        \\n        for(int i = 0; i < (1 << n); i++) {\\n            if(isValidGuess(statements, i)) {\\n                res = Math.max(res, countActiveBits(i));\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private boolean isValidGuess(int[][] statements, int guess) {\\n        int n = statements.length;\\n        \\n        for(int i = 0; i < n; i++) {\\n            // if i-th person is a good person\\n            if(isGuessedAsGood(guess, i, n)) {\\n                // Since i is a good person, all the statements by i would be true\\n                // So check if the statements given by i for other people\\n                // and the guess made by us for those people are the same\\n                // if not then the guess that we have made is not valid and return false\\n                for(int j = 0; j < n; j++) {\\n                    if(statements[i][j] != 2 &&\\n                       statements[i][j] != (isGuessedAsGood(guess, j, n) ? 1 : 0)) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private boolean isGuessedAsGood(int guess, int person, int total) {\\n        // a person is a good person if the (n - 1 - i)th bit is 1\\n        return (guess & (1 << (total - 1 - person))) > 0;\\n    }\\n    \\n    private int countActiveBits(int num) {\\n        int c = 0;\\n        \\n        while(num > 0) {\\n            if((num & 1) > 0)\\n                c++;\\n            \\n            num >>= 1;\\n        }\\n        \\n        return c;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711555,
                "title": "c-recursive-approach",
                "content": "```\\nvoid rec(vector<vector<int>> & statements,int &ans,vector<int> &vec,int ind){\\n        int count=0;\\n        if(vec.size()!=0){\\n            for(int i=0;i<vec.size();i++){\\n                int j;\\n                for(j=0;j<statements[vec[i]].size();j++){\\n                    if(statements[vec[i]][j]==0)\\n                    if(binary_search(vec.begin(),vec.end(),j)){\\n                        return ;\\n                    }\\n                    if(statements[vec[i]][j]==1){\\n                        if(not binary_search(vec.begin(),vec.end(),j)){\\n                            break;\\n                        }\\n                    }\\n                }\\n                if(j==statements[0].size()) count++;\\n            }\\n            if(count==vec.size())\\n            ans=max(ans,(int)vec.size());\\n        }\\n        if(ind>=statements.size())return ;\\n        rec(statements,ans,vec,ind+1);\\n        vec.push_back(ind);\\n        rec(statements,ans,vec,ind+1);\\n        vec.pop_back();\\n    }\\n    int maximumGood(vector<vector<int>>& statements) {\\n        int ans=0;\\n        vector<int> vec;\\n        rec(statements,ans,vec,0);\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nvoid rec(vector<vector<int>> & statements,int &ans,vector<int> &vec,int ind){\\n        int count=0;\\n        if(vec.size()!=0){\\n            for(int i=0;i<vec.size();i++){\\n                int j;\\n                for(j=0;j<statements[vec[i]].size();j++){\\n                    if(statements[vec[i]][j]==0)\\n                    if(binary_search(vec.begin(),vec.end(),j)){\\n                        return ;\\n                    }\\n                    if(statements[vec[i]][j]==1){\\n                        if(not binary_search(vec.begin(),vec.end(),j)){\\n                            break;\\n                        }\\n                    }\\n                }\\n                if(j==statements[0].size()) count++;\\n            }\\n            if(count==vec.size())\\n            ans=max(ans,(int)vec.size());\\n        }\\n        if(ind>=statements.size())return ;\\n        rec(statements,ans,vec,ind+1);\\n        vec.push_back(ind);\\n        rec(statements,ans,vec,ind+1);\\n        vec.pop_back();\\n    }\\n    int maximumGood(vector<vector<int>>& statements) {\\n        int ans=0;\\n        vector<int> vec;\\n        rec(statements,ans,vec,0);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1711554,
                "title": "bit-masking-c-do-not-sleep-during-contest",
                "content": "I slept after solving 1st three problem and wake up with 1.2k submission on this shitty brute force problem xD.\\nP.S. Never fall asleep in morning contest.\\n```\\nclass Solution {\\npublic:\\n    int maximumGood(vector<vector<int>>& A) {\\n        int n = A.size(), ans = 0;\\n        for(int mask = 0; mask < (1 << n); mask++){\\n            // mask is our assumption : 101 means person 0, 2 are good and person 1 is bad.\\n            bool valid = true;\\n            for(int i = 0; i < n; i++){\\n                // if person at ith bit is good\\n                if(mask & (1 << i)){\\n                    for(int j = 0; j < n; j++){\\n                        // check for contradiction\\n                        if(A[i][j] != 2 && A[i][j] != bool(mask & (1 << j))){\\n                            valid = false;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n            if(valid) ans = max(ans, __builtin_popcount(mask));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGood(vector<vector<int>>& A) {\\n        int n = A.size(), ans = 0;\\n        for(int mask = 0; mask < (1 << n); mask++){\\n            // mask is our assumption : 101 means person 0, 2 are good and person 1 is bad.\\n            bool valid = true;\\n            for(int i = 0; i < n; i++){\\n                // if person at ith bit is good\\n                if(mask & (1 << i)){\\n                    for(int j = 0; j < n; j++){\\n                        // check for contradiction\\n                        if(A[i][j] != 2 && A[i][j] != bool(mask & (1 << j))){\\n                            valid = false;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n            if(valid) ans = max(ans, __builtin_popcount(mask));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711352,
                "title": "c-generate-all-possible-scenarios",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumGood(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int numSubSets = 1<<n;\\n        int ans = 0;\\n        for(int bitmask=1; bitmask<numSubSets; bitmask++)\\n        {\\n            vector<int> good(n,0),bad(n,0);\\n            int count = 0;\\n            for(int i=0; i<n; i++)\\n            {\\n                if((bitmask&(1<<i))!=0)\\n                {\\n                    count++;\\n                    good[i] = 1;\\n                    bad[i] = 0;\\n                }\\n                else\\n                {\\n                    good[i] = 0;\\n                    bad[i] = 1;\\n                }\\n                if(good[i]==1 && bad[i]==1) break;\\n            }\\n            bool flag = true;\\n            for(int i=0; i<n; i++)\\n            {\\n                for(int j=0; j<n; j++)\\n                {\\n                    if(i==j) continue;\\n                    if(good[i]==1)\\n                    {\\n                        if(grid[i][j]==0 && bad[j]==0)\\n                        {\\n                            flag = false;\\n                            break;\\n                        }\\n                        if(grid[i][j]==1 && good[j]==0)\\n                        {\\n                            flag = false;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n            if(flag==true)\\n                ans = max(ans,count);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int maximumGood(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int numSubSets = 1<<n;\\n        int ans = 0;\\n        for(int bitmask=1; bitmask<numSubSets; bitmask++)\\n        {\\n            vector<int> good(n,0),bad(n,0);\\n            int count = 0;\\n            for(int i=0; i<n; i++)\\n            {\\n                if((bitmask&(1<<i))!=0)\\n                {\\n                    count++;\\n                    good[i] = 1;\\n                    bad[i] = 0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1711222,
                "title": "simple-c-solution-o-2-n-n-2-proof-by-contradiction",
                "content": "**Approach :**\\n1. We go through all possible combinations of ```n``` and if any bit in ```n``` is set we assume that this person is bad and check if it setisfies the given conditions.\\n2.  We assume person i is good so he always speaks truth so there are 2 possible contradiction.\\n\\t\\t(i) Person i said that person j is bad but we assume person j is good so, here it contradict.\\n        (ii) Person i said that person j is good but we assume person j is bad so, here it contradict.\\n\\n```\\nclass Solution\\n{\\n    public:\\n    int n=0,ans=0;\\n    bool isPossible(vector<vector<int>>& arr,vector<bool>& people)\\n    {\\n        for (int i=0;i<n;i++)\\n        {\\n            for (int j=0;j<n;j++)\\n            {\\n                // We assume person i is good so he always speaks truth so there are 2 possible contradiction.\\n                \\n                //1. Person i said that person j is bad but we assume person j is good so, here it contradict.\\n                if (arr[i][j]==0 and people[i] and people[j])\\n                    return false;\\n                \\n                //2. Person i said that person j is good but we assume person j is bad so, here it contradict.\\n                else if (arr[i][j]==1 and people[i] and !people[j])\\n                    return false;\\n            }\\n        }\\n        // We return true if there is no contradiction\\n        return true;\\n    }\\n    int getGood(int i)\\n    {\\n        int temp=(__builtin_popcountll(i));\\n        return (n-temp);\\n    }\\n    int maximumGood(vector<vector<int>>& arr)\\n    {\\n        n=arr.size();\\n        // Get all possible combinations and if bit is set assume this person bad.\\n        for (int i=0;i<(1<<n);i++)\\n        {\\n            vector<bool> people(n,true);\\n            for (int j=0,temp=i;j<n && temp>0;j++)\\n            {\\n                if (temp&1)\\n                    people[j]=false;\\n                temp/=2;\\n            }\\n            if (isPossible(arr,people))\\n                ans=max(ans,getGood(i));\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Time Complexity : ```O((2^n)*(n*2))```**",
                "solutionTags": [],
                "code": "```n```\n```n```\n```\\nclass Solution\\n{\\n    public:\\n    int n=0,ans=0;\\n    bool isPossible(vector<vector<int>>& arr,vector<bool>& people)\\n    {\\n        for (int i=0;i<n;i++)\\n        {\\n            for (int j=0;j<n;j++)\\n            {\\n                // We assume person i is good so he always speaks truth so there are 2 possible contradiction.\\n                \\n                //1. Person i said that person j is bad but we assume person j is good so, here it contradict.\\n                if (arr[i][j]==0 and people[i] and people[j])\\n                    return false;\\n                \\n                //2. Person i said that person j is good but we assume person j is bad so, here it contradict.\\n                else if (arr[i][j]==1 and people[i] and !people[j])\\n                    return false;\\n            }\\n        }\\n        // We return true if there is no contradiction\\n        return true;\\n    }\\n    int getGood(int i)\\n    {\\n        int temp=(__builtin_popcountll(i));\\n        return (n-temp);\\n    }\\n    int maximumGood(vector<vector<int>>& arr)\\n    {\\n        n=arr.size();\\n        // Get all possible combinations and if bit is set assume this person bad.\\n        for (int i=0;i<(1<<n);i++)\\n        {\\n            vector<bool> people(n,true);\\n            for (int j=0,temp=i;j<n && temp>0;j++)\\n            {\\n                if (temp&1)\\n                    people[j]=false;\\n                temp/=2;\\n            }\\n            if (isPossible(arr,people))\\n                ans=max(ans,getGood(i));\\n        }\\n        return ans;\\n    }\\n};\\n```\n```O((2^n)*(n*2))```",
                "codeTag": "Java"
            },
            {
                "id": 3036371,
                "title": "easiest-soln-goldman-sachs-well-explained",
                "content": "## If you found my answer helpful, please consider giving it an upvote\\uD83D\\uDE0A\\n**ReviseWithArsh #6Companies30Days Challenge 2023\\nChallenge Company 2 : Goldman Sachs\\nQ15. Maximum Good People Based on Statements**\\n\\n![15.jpg](https://assets.leetcode.com/users/images/7974e00e-afb6-45be-b1c4-8d4d7902b480_1673453967.692707.jpeg)\\n\\n\\n### Complexity\\n- The **time complexity** of this code is O(2^N * N^2) where N is the number of people. The space complexity is O(N).\\nThe time complexity of the code is determined by the number of recursive calls that are made. In the worst case, the function will be called for each possible combination of good and bad people, which is 2^N. In each recursive call, the isValid function is called, which takes O(N) time as it needs to check the consistency of each person\\'s statement with the current configuration. Therefore, the total time complexity is O(2^N * N^2).\\n\\n- The **space complexity** is determined by the amount of memory used by the function. The function uses a boolean array goodPeople of length N to store the current configuration of good and bad people, and an integer array maxGoodPeople of length 1 to store the maximum number of good people found so far. Therefore, the space complexity is O(N)\\nIt should be noted that this algorithm is very slow for large inputs. There are other methods such as backtracking to solve this problem which have a much better time complexity O(N*2^(N/2))\\n\\n### Code\\n```\\nclass Solution {\\n    public int maximumGood(int[][] statements) {  \\n        // Declare variable to store the max number of good people\\n        int[] maxGoodPeople = { 0 };      \\n        // Recursive function to find the maximum number of good people\\n        maximumGood(statements, new boolean[statements.length], 0, 0, maxGoodPeople);\\n        return maxGoodPeople[0];\\n    }\\n    \\n    private void maximumGood(int[][] statements, boolean[] goodPeople, int currentPerson, int currentGoodPeople, int[] maxGoodPeople) {\\n        // Base case: if all people have been checked\\n        if (currentPerson == goodPeople.length) {\\n            // Update maxGoodPeople if necessary\\n            maxGoodPeople[0] = Math.max(maxGoodPeople[0], currentGoodPeople);\\n            return;\\n        }\\n        \\n        // Set current person as good\\n        goodPeople[currentPerson] = true;\\n        // If remaining people cannot beat the current max, return\\n        if (goodPeople.length - currentPerson + currentGoodPeople < maxGoodPeople[0]) {\\n            return;\\n        }\\n        // If current configuration is valid, move forward\\n        if (isValid(statements, goodPeople, currentPerson)) {\\n            maximumGood(statements, goodPeople, currentPerson + 1, currentGoodPeople + 1, maxGoodPeople);\\n        }\\n\\n        // Set current person as bad\\n        goodPeople[currentPerson] = false; \\n        // If remaining people cannot beat the current max, return\\n        if (goodPeople.length - currentPerson - 1 + currentGoodPeople < maxGoodPeople[0]) {\\n            return;\\n        }\\n        // If current configuration is valid, move forward\\n        if (isValid(statements, goodPeople, currentPerson)) {\\n            maximumGood(statements, goodPeople, currentPerson + 1, currentGoodPeople, maxGoodPeople);\\n        }\\n        \\n        return;\\n    }\\n    \\n    // Function to check if the current configuration is valid\\n    private boolean isValid(int[][] statements, boolean[] goodPeople, int currentPerson) {\\n        // Check if all previous people\\'s statements are consistent with current configuration\\n        for (int i = 0; i < currentPerson; ++i) {\\n            if (goodPeople[i]) {\\n                if (goodPeople[currentPerson] && statements[i][currentPerson] == 0) {\\n                    return false;\\n                }\\n                if (!goodPeople[currentPerson] && statements[i][currentPerson] == 1) {\\n                    return false;\\n                }\\n            }\\n        }\\n        // Check if current person\\'s statements are consistent with current configuration\\n        if (goodPeople[currentPerson]) {\\n            for (int i = 0; i < currentPerson; ++i) {\\n                if (goodPeople[i] && statements[currentPerson][i] == 0) return false;\\n                if (!goodPeople[i] && statements[currentPerson][i] == 1) return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n```\\nThis code is a solution to a problem where given a 2D array of statements, where each statement is a binary value (0 or 1) representing whether a person is good (1) or bad (0), the task is to find the maximum number of good people. The code does this by using a recursive function called maximumGood that explores different configurations of good and bad people and checks the validity of each configuration using the isValid function.\\n- maximumGood function: It is a recursive function that takes four parameters, first is the 2D array of statements, second is a boolean array indicating whether a person is good or bad, third is an integer indicating the current person being checked, and fourth is an integer array that stores the maximum number of good people found so far.\\n- The function explores different configurations of good and bad people by setting the current person being checked as good or bad, and recursively calling itself with the next person and updated number of good people.\\n- isValid function: It is used to check if a given configuration of good and bad people is consistent with the statements in the input 2D array. It returns false if any person\\'s statement is not consistent with their good/bad status in the current configuration, and true otherwise.\\n- The code makes use of memoization by adding an early return when the remaining people cannot beat the current max, to improve performance.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumGood(int[][] statements) {  \\n        // Declare variable to store the max number of good people\\n        int[] maxGoodPeople = { 0 };      \\n        // Recursive function to find the maximum number of good people\\n        maximumGood(statements, new boolean[statements.length], 0, 0, maxGoodPeople);\\n        return maxGoodPeople[0];\\n    }\\n    \\n    private void maximumGood(int[][] statements, boolean[] goodPeople, int currentPerson, int currentGoodPeople, int[] maxGoodPeople) {\\n        // Base case: if all people have been checked\\n        if (currentPerson == goodPeople.length) {\\n            // Update maxGoodPeople if necessary\\n            maxGoodPeople[0] = Math.max(maxGoodPeople[0], currentGoodPeople);\\n            return;\\n        }\\n        \\n        // Set current person as good\\n        goodPeople[currentPerson] = true;\\n        // If remaining people cannot beat the current max, return\\n        if (goodPeople.length - currentPerson + currentGoodPeople < maxGoodPeople[0]) {\\n            return;\\n        }\\n        // If current configuration is valid, move forward\\n        if (isValid(statements, goodPeople, currentPerson)) {\\n            maximumGood(statements, goodPeople, currentPerson + 1, currentGoodPeople + 1, maxGoodPeople);\\n        }\\n\\n        // Set current person as bad\\n        goodPeople[currentPerson] = false; \\n        // If remaining people cannot beat the current max, return\\n        if (goodPeople.length - currentPerson - 1 + currentGoodPeople < maxGoodPeople[0]) {\\n            return;\\n        }\\n        // If current configuration is valid, move forward\\n        if (isValid(statements, goodPeople, currentPerson)) {\\n            maximumGood(statements, goodPeople, currentPerson + 1, currentGoodPeople, maxGoodPeople);\\n        }\\n        \\n        return;\\n    }\\n    \\n    // Function to check if the current configuration is valid\\n    private boolean isValid(int[][] statements, boolean[] goodPeople, int currentPerson) {\\n        // Check if all previous people\\'s statements are consistent with current configuration\\n        for (int i = 0; i < currentPerson; ++i) {\\n            if (goodPeople[i]) {\\n                if (goodPeople[currentPerson] && statements[i][currentPerson] == 0) {\\n                    return false;\\n                }\\n                if (!goodPeople[currentPerson] && statements[i][currentPerson] == 1) {\\n                    return false;\\n                }\\n            }\\n        }\\n        // Check if current person\\'s statements are consistent with current configuration\\n        if (goodPeople[currentPerson]) {\\n            for (int i = 0; i < currentPerson; ++i) {\\n                if (goodPeople[i] && statements[currentPerson][i] == 0) return false;\\n                if (!goodPeople[i] && statements[currentPerson][i] == 1) return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1765526,
                "title": "bitmasking-c-o-n-2-2-n",
                "content": "```\\nclass Solution {\\npublic:\\n   // bool isvalid\\n    int isvalid(int key,vector<vector<int>>&statements,int n){\\n        vector<int>gb(n,0);\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            if(key & (1<<i))\\n                gb[i]++,count++;\\n            \\n        }\\n        for(int i=0;i<n;i++){\\n            if(gb[i]==1){\\n                for(int j=0;j<n;j++){\\n                    if((statements[i][j]==1 && gb[j]==0) ||(statements[i][j]==0 && gb[j]==1))return 0;\\n                }\\n            }\\n        }\\n        \\n        \\n        return count;\\n        \\n        \\n    }\\n    int maximumGood(vector<vector<int>>& statements) {\\n        int n=statements.size();\\n    \\n        int ans=0;\\n        for(int i=0;i<(1<<n);i++){\\n            ans=max(ans,isvalid(i,statements,n));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n   // bool isvalid\\n    int isvalid(int key,vector<vector<int>>&statements,int n){\\n        vector<int>gb(n,0);\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            if(key & (1<<i))\\n                gb[i]++,count++;\\n            \\n        }\\n        for(int i=0;i<n;i++){\\n            if(gb[i]==1){\\n                for(int j=0;j<n;j++){\\n                    if((statements[i][j]==1 && gb[j]==0) ||(statements[i][j]==0 && gb[j]==1))return 0;\\n                }\\n            }\\n        }\\n        \\n        \\n        return count;\\n        \\n        \\n    }\\n    int maximumGood(vector<vector<int>>& statements) {\\n        int n=statements.size();\\n    \\n        int ans=0;\\n        for(int i=0;i<(1<<n);i++){\\n            ans=max(ans,isvalid(i,statements,n));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1726746,
                "title": "backtracking-explanation",
                "content": "Idea with the backtracking solution is to iterate over all candidates, and check for contradictions.\\n\\nFor each candidate we can assume they are either good or bad.\\n\\nIf they are good:\\n* if they make a statement about any previously seen candidate that statement must be true (i.e. that the candidate is good/bad)\\n* no previously seen good candidate states the current is bad\\n\\nIf they are bad:\\n* if a previously seen good candidate states they are good, then that previous candidate cannot be good\\n\\nWe check for these conditions and prune branches when contradictions are found.\\n\\n```\\nclass Solution:\\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        n = len(statements)\\n        self.ans = 0\\n\\t\\t# good candidate set for O(1) lookup\\n        good = set()\\n        \\n        def backtracking(idx, count):\\n            if idx == n:\\n\\t\\t\\t\\t# found a potential solution\\n                self.ans = max(self.ans, count)\\n                return\\n            \\n            # assume idx is good\\n            good.add(idx)\\n            for i in range(idx):\\n\\t\\t\\t\\t# check for any contradictions with previous assumptions\\n                if (statements[idx][i] == 1 and i not in good) or (statements[idx][i] == 0 and i in good) or (i in good and statements[i][idx] == 0):\\n                    break\\n            else:\\n\\t\\t\\t\\t# if no contradiction found then we can assume idx is good and continue search\\n                backtracking(idx + 1, count + 1)\\n            good.remove(idx)\\n            \\n            # assume idx is bad\\n            for i in range(idx):\\n\\t\\t\\t\\t# check for any contradictions with previous candidates thought to be good\\n                if (i in good and statements[i][idx] == 1):\\n\\t\\t\\t\\t\\t# contradiction so prune current branch\\n                    return\\n            backtracking(idx + 1, count)\\n    \\n        backtracking(0, 0)\\n        return self.ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        n = len(statements)\\n        self.ans = 0\\n\\t\\t# good candidate set for O(1) lookup\\n        good = set()\\n        \\n        def backtracking(idx, count):\\n            if idx == n:\\n\\t\\t\\t\\t# found a potential solution\\n                self.ans = max(self.ans, count)\\n                return\\n            \\n            # assume idx is good\\n            good.add(idx)\\n            for i in range(idx):\\n\\t\\t\\t\\t# check for any contradictions with previous assumptions\\n                if (statements[idx][i] == 1 and i not in good) or (statements[idx][i] == 0 and i in good) or (i in good and statements[i][idx] == 0):\\n                    break\\n            else:\\n\\t\\t\\t\\t# if no contradiction found then we can assume idx is good and continue search\\n                backtracking(idx + 1, count + 1)\\n            good.remove(idx)\\n            \\n            # assume idx is bad\\n            for i in range(idx):\\n\\t\\t\\t\\t# check for any contradictions with previous candidates thought to be good\\n                if (i in good and statements[i][idx] == 1):\\n\\t\\t\\t\\t\\t# contradiction so prune current branch\\n                    return\\n            backtracking(idx + 1, count)\\n    \\n        backtracking(0, 0)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713297,
                "title": "python-dfs-straightforward-easy-thinking-explained",
                "content": "### General Idea\\n\\nLet `persons` be an array of `0`s and `1`s, where `persons[i]` indicates the assumption we made towards person `i` (`0` - bad, `1` - good).\\n\\nWe first create a function `hasContradiction()` which determines if there is a contradiction exists in the `statements` array, if we assume the trustability to be `persons`. By observation, we can see that\\n\\n> there exists a contradiction if and only if an assumed good person states another assumed good person to be bad\\n\\nNext we want to create all the combinations of `persons`, we can achieve this by using DFS. Starting from an empty array, each step we recursivly append either a good or bad into our accumulative array, representing in one branch we assume the current person to be good, and in the other we assume it to be bad (visually, the process will be like growing a binary tree). We stop when the length of the array reaches `N` which is the total number of persons.\\n\\nThen if we iterate through all these possible combinations, and count the number of good person in them if the combination does not have a contradiction, by finding the maximal among them we will obtain our final answer.\\n\\n### Code\\n\\n```\\nclass Solution:\\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        BAD, GOOD, NO_STATEMENT = 0, 1, 2\\n        N = len(statements)\\n        \\n        def hasContradiction(persons):\\n            for i in range(N):\\n                for j in range(N):\\n                    if statements[i][j] == NO_STATEMENT:\\n                        continue\\n                    if persons[i] == GOOD:\\n                        if statements[i][j] != persons[j]:\\n                            return True\\n            return False\\n        \\n        ans = 0\\n        def dfs(persons):\\n            nonlocal ans\\n            if len(persons) == N:\\n                if not hasContradiction(persons):\\n                    ans = max(ans, persons.count(GOOD))\\n            else:\\n                dfs(persons+[GOOD])\\n                dfs(persons+[BAD])\\n                \\n        dfs([])\\n        return ans\\n```\\n\\n### Complexity Analysis\\n- Time complexity: `O(2^N * N^2)`\\n\\n\\tSince there are a total of `2^N` possible combinations of `persons`, and in each of these combinations we are performing `O(N^2)` operation to exam if there is a contradiction, the time complexity is `O(2^N * N^2)`\\n- Space complexity: `O(N)`\\n\\n\\tSInce we are using DFS to find all the possible combinations of the `persons` array, at each time we are storing a complete `0` to `N` array in the memory stack, this takes `O(N)` space\\n\\t\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        BAD, GOOD, NO_STATEMENT = 0, 1, 2\\n        N = len(statements)\\n        \\n        def hasContradiction(persons):\\n            for i in range(N):\\n                for j in range(N):\\n                    if statements[i][j] == NO_STATEMENT:\\n                        continue\\n                    if persons[i] == GOOD:\\n                        if statements[i][j] != persons[j]:\\n                            return True\\n            return False\\n        \\n        ans = 0\\n        def dfs(persons):\\n            nonlocal ans\\n            if len(persons) == N:\\n                if not hasContradiction(persons):\\n                    ans = max(ans, persons.count(GOOD))\\n            else:\\n                dfs(persons+[GOOD])\\n                dfs(persons+[BAD])\\n                \\n        dfs([])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713267,
                "title": "python3-fast-recursive-dp-n-2-n",
                "content": "we should iterate the matrix and for each person check 2 possibilities, \\nwhether he might be telling the truth or he might be a lier. in both cases we should dig deeper and count the maximum number of good people.\\nIn case he is telling the truth, we must consider all his judgements as valid and add them to already **good** and **bad** people we collected.\\nIn case the person is a lier we should not consider his judgements and we should only add him to the **bad** list.\\n```\\nclass Solution:\\n    def maximumGood(self, statements):\\n        def dp(idx: int, good: List[int], bad: List[int]):\\n            if idx == len(statements):\\n                return len(good)\\n            a, b = 0, 0\\n            if idx not in bad and all(i not in bad if s == 1 else i not in good for i, s in enumerate(statements[idx]) if\\n                   i != idx and s != 2):\\n                a = dp(\\n                    idx + 1,\\n                    list(set([idx] + good + [i for i, s in enumerate(statements[idx]) if s == 1])),\\n                    list(set(bad + [i for i, s in enumerate(statements[idx]) if s == 0])),\\n                )\\n            if idx not in good:\\n                b = dp(\\n                    idx + 1,\\n                    good,\\n                    list(set(bad + [idx]))\\n                )\\n            return max(a, b)\\n\\n        return dp(0, [], [])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumGood(self, statements):\\n        def dp(idx: int, good: List[int], bad: List[int]):\\n            if idx == len(statements):\\n                return len(good)\\n            a, b = 0, 0\\n            if idx not in bad and all(i not in bad if s == 1 else i not in good for i, s in enumerate(statements[idx]) if\\n                   i != idx and s != 2):\\n                a = dp(\\n                    idx + 1,\\n                    list(set([idx] + good + [i for i, s in enumerate(statements[idx]) if s == 1])),\\n                    list(set(bad + [i for i, s in enumerate(statements[idx]) if s == 0])),\\n                )\\n            if idx not in good:\\n                b = dp(\\n                    idx + 1,\\n                    good,\\n                    list(set(bad + [idx]))\\n                )\\n            return max(a, b)\\n\\n        return dp(0, [], [])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712314,
                "title": "clean-and-concise-solution-with-explaination",
                "content": "**Solution [AC]  DFS**\\n\\nAny person \\' i \\' can either  be a good person or a bad person.\\nHere the Approch is.\\nTrying every possible combination of all persons (by making them good or bad) and if it satisfys all given statements then, we will update our ans if, our combination has more no. of good persons than previous answer.\\n\\n```\\nclass Solution {\\n    private int maxGoodPersons = 0;\\n    public int maximumGood(int[][] s) {\\n        solve(0, 0, new int[s.length], s);\\n        return maxGoodPersons;\\n    }\\n    \\n    private void solve(int currPerson, int goods, int[] isGoodPerson, int[][] s) {\\n        \\n        if(currPerson == isGoodPerson.length) {\\n            if(isValid(isGoodPerson, s)) maxGoodPersons = Math.max(maxGoodPersons, goods);\\n            return;\\n        }\\n        //Set currPerson as good person\\n        isGoodPerson[currPerson] = 1;\\n        solve(currPerson+1, goods+1, isGoodPerson, s);\\n        \\n        //Set currPerson as bad person\\n        isGoodPerson[currPerson] = 0;\\n        solve(currPerson+1, goods, isGoodPerson, s);  \\n    }\\n    \\n    private boolean isValid(int[] isGoodPerson, int[][] s) {\\n        \\n        // If our combination does\\'nt satisfy given statements then return false.\\n         for(int i = 0; i < isGoodPerson.length; i++) {\\n            // If i\\'th person is bad then no need to check if his statements are satisfying or not because his stat\\'s. might me right might be wrong.\\n            if(isGoodPerson[i] == 0) continue; \\n             \\n            // If i\\'s statemtn saying that j is good (or bad) and if it does\\'nt match with our combination then our combination is not valid.\\n            for(int j = 0; j < isGoodPerson.length; j++) if(s[i][j] != 2 && s[i][j] != isGoodPerson[j]) return false;\\n         }\\n        \\n        return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    private int maxGoodPersons = 0;\\n    public int maximumGood(int[][] s) {\\n        solve(0, 0, new int[s.length], s);\\n        return maxGoodPersons;\\n    }\\n    \\n    private void solve(int currPerson, int goods, int[] isGoodPerson, int[][] s) {\\n        \\n        if(currPerson == isGoodPerson.length) {\\n            if(isValid(isGoodPerson, s)) maxGoodPersons = Math.max(maxGoodPersons, goods);\\n            return;\\n        }\\n        //Set currPerson as good person\\n        isGoodPerson[currPerson] = 1;\\n        solve(currPerson+1, goods+1, isGoodPerson, s);\\n        \\n        //Set currPerson as bad person\\n        isGoodPerson[currPerson] = 0;\\n        solve(currPerson+1, goods, isGoodPerson, s);  \\n    }\\n    \\n    private boolean isValid(int[] isGoodPerson, int[][] s) {\\n        \\n        // If our combination does\\'nt satisfy given statements then return false.\\n         for(int i = 0; i < isGoodPerson.length; i++) {\\n            // If i\\'th person is bad then no need to check if his statements are satisfying or not because his stat\\'s. might me right might be wrong.\\n            if(isGoodPerson[i] == 0) continue; \\n             \\n            // If i\\'s statemtn saying that j is good (or bad) and if it does\\'nt match with our combination then our combination is not valid.\\n            for(int j = 0; j < isGoodPerson.length; j++) if(s[i][j] != 2 && s[i][j] != isGoodPerson[j]) return false;\\n         }\\n        \\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712143,
                "title": "python-one-line-q4",
                "content": "```python\\nclass Solution:maximumGood=lambda _,S:max(sum(C) for C in product(range(2),repeat=len(S)) if all(C[i]==0 or 2==S[i][j] or S[i][j]==C[j] for i,j in product(range(len(S)),repeat=2)))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:maximumGood=lambda _,S:max(sum(C) for C in product(range(2),repeat=len(S)) if all(C[i]==0 or 2==S[i][j] or S[i][j]==C[j] for i,j in product(range(len(S)),repeat=2)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712106,
                "title": "dfs-java-in-40-lines",
                "content": "```\\npublic int maximumGood(int[][] statements) {\\n\\tint[] known = new int[statements.length];\\n\\tArrays.fill(known, 2);\\n\\treturn max(statements, known, 0);\\n}\\nprivate int max(int[][] statements, int[] known, int position) {\\n\\tif(position == statements.length) return (int) Arrays.stream(known).filter(a -> a == 1).count();\\n\\tswitch(known[position]) {\\n\\t\\tcase 0:\\n\\t\\t\\treturn assumeBad(statements, known, position);\\n\\t\\tcase 1:\\n\\t\\t\\treturn assumeGood(statements, known, position);\\n\\t\\tdefault:\\n\\t\\t\\treturn Math.max(assumeBad(statements, known, position), assumeGood(statements, known, position));\\n\\t}\\n}\\nprivate int assumeBad(int[][] statements, int[] known, int position) {\\n\\tint[] updatedKnown = known.clone();\\n\\tupdatedKnown[position] = 0;\\n\\treturn max(statements, updatedKnown, position + 1);\\n}    \\nprivate int assumeGood(int[][] statements, int[] known, int position) {\\n\\tint[] updatedKnown = known.clone();\\n\\tboolean conflictDetected = false;\\n\\tupdatedKnown[position] = 1;\\n\\tfor(int i = 0; i<statements[position].length; i++) {\\n\\t\\tint answer = statements[position][i];\\n\\t\\tif(answer == 2) continue;\\n\\t\\tif(known[i] != 2 && answer != known[i]) { \\n\\t\\t\\tconflictDetected = true;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tupdatedKnown[i] = answer;            \\n\\t}\\n\\treturn conflictDetected ? 0 : max(statements, updatedKnown, position + 1);\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int maximumGood(int[][] statements) {\\n\\tint[] known = new int[statements.length];\\n\\tArrays.fill(known, 2);\\n\\treturn max(statements, known, 0);\\n}\\nprivate int max(int[][] statements, int[] known, int position) {\\n\\tif(position == statements.length) return (int) Arrays.stream(known).filter(a -> a == 1).count();\\n\\tswitch(known[position]) {\\n\\t\\tcase 0:\\n\\t\\t\\treturn assumeBad(statements, known, position);\\n\\t\\tcase 1:\\n\\t\\t\\treturn assumeGood(statements, known, position);\\n\\t\\tdefault:\\n\\t\\t\\treturn Math.max(assumeBad(statements, known, position), assumeGood(statements, known, position));\\n\\t}\\n}\\nprivate int assumeBad(int[][] statements, int[] known, int position) {\\n\\tint[] updatedKnown = known.clone();\\n\\tupdatedKnown[position] = 0;\\n\\treturn max(statements, updatedKnown, position + 1);\\n}    \\nprivate int assumeGood(int[][] statements, int[] known, int position) {\\n\\tint[] updatedKnown = known.clone();\\n\\tboolean conflictDetected = false;\\n\\tupdatedKnown[position] = 1;\\n\\tfor(int i = 0; i<statements[position].length; i++) {\\n\\t\\tint answer = statements[position][i];\\n\\t\\tif(answer == 2) continue;\\n\\t\\tif(known[i] != 2 && answer != known[i]) { \\n\\t\\t\\tconflictDetected = true;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tupdatedKnown[i] = answer;            \\n\\t}\\n\\treturn conflictDetected ? 0 : max(statements, updatedKnown, position + 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1711979,
                "title": "python-backtracking-solution",
                "content": "set_g_or_b -> use backtracking method to find all possible combination of good and bad person. Configuration is valid if it doesn\\'t lead to any contradiction. \\n\\nin set_g_or_b, call find_bad to find bad people given the existing condition\\nfind_bad-> use the conditon that x is bad or good to find all bad person:\\n\\t1. Once x is set to be bad, anyone says x is good is bad\\n\\t2. Once x is set to be good, anyone says x is bad is bad\\n\\t3. use visted_bad and visited_good to save found bad/good person, a person can only in one set\\n\\n\\n```\\nclass Solution:\\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        pointed_good_by = collections.defaultdict(set)\\n        pointed_bad_by = collections.defaultdict(set)\\n        \\n        for i in range(len(statements)):\\n            for k in range(len(statements[i])):\\n                if statements[i][k] == 1:\\n                    pointed_good_by[k].add(i)\\n                if statements[i][k] == 0:\\n                    pointed_bad_by[k].add(i)\\n    \\n\\n        def find_bad(i):\\n            if i in self.visited_good:\\n                return False\\n            if i in self.visited_bad:\\n                return True\\n            self.visited_bad.add(i)\\n            for k in pointed_good_by[i]:\\n                if not find_bad(k):\\n                    return False\\n            return True\\n \\n        self.res = 0\\n        \\n        def set_g_or_b(i, f):\\n            if f == True:\\n                self.visited_good.add(i)\\n                for k in pointed_bad_by[i]:\\n                    if not find_bad(k):\\n                        return\\n            else:\\n                if not find_bad(i):\\n                    return\\n\\n            if i == len(statements) -1:\\n                self.res = max(self.res, len(statements) - len(self.visited_bad))\\n                return\\n                \\n            tp_good = copy.deepcopy(self.visited_good)\\n            tp_bad = copy.deepcopy(self.visited_bad)\\n            if i + 1 not in self.visited_bad:\\n                set_g_or_b(i + 1, True)\\n            self.visited_good = copy.deepcopy(tp_good)\\n            self.visited_bad = copy.deepcopy(tp_bad)\\n            if i + 1 not in self.visited_good:\\n                set_g_or_b(i + 1, False)\\n\\n        \\n        self.visited_bad = set()\\n        self.visited_good = set()\\n        set_g_or_b(0, True)\\n        self.visited_bad = set()\\n        self.visited_good = set()\\n        set_g_or_b(0, False)\\n \\n        return self.res\\n\\t```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        pointed_good_by = collections.defaultdict(set)\\n        pointed_bad_by = collections.defaultdict(set)\\n        \\n        for i in range(len(statements)):\\n            for k in range(len(statements[i])):\\n                if statements[i][k] == 1:\\n                    pointed_good_by[k].add(i)\\n                if statements[i][k] == 0:\\n                    pointed_bad_by[k].add(i)\\n    \\n\\n        def find_bad(i):\\n            if i in self.visited_good:\\n                return False\\n            if i in self.visited_bad:\\n                return True\\n            self.visited_bad.add(i)\\n            for k in pointed_good_by[i]:\\n                if not find_bad(k):\\n                    return False\\n            return True\\n \\n        self.res = 0\\n        \\n        def set_g_or_b(i, f):\\n            if f == True:\\n                self.visited_good.add(i)\\n                for k in pointed_bad_by[i]:\\n                    if not find_bad(k):\\n                        return\\n            else:\\n                if not find_bad(i):\\n                    return\\n\\n            if i == len(statements) -1:\\n                self.res = max(self.res, len(statements) - len(self.visited_bad))\\n                return\\n                \\n            tp_good = copy.deepcopy(self.visited_good)\\n            tp_bad = copy.deepcopy(self.visited_bad)\\n            if i + 1 not in self.visited_bad:\\n                set_g_or_b(i + 1, True)\\n            self.visited_good = copy.deepcopy(tp_good)\\n            self.visited_bad = copy.deepcopy(tp_bad)\\n            if i + 1 not in self.visited_good:\\n                set_g_or_b(i + 1, False)\\n\\n        \\n        self.visited_bad = set()\\n        self.visited_good = set()\\n        set_g_or_b(0, True)\\n        self.visited_bad = set()\\n        self.visited_good = set()\\n        set_g_or_b(0, False)\\n \\n        return self.res\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1711831,
                "title": "simple-c-solution-bitmask-detailed-explanation",
                "content": "\\n**Approach:**\\nlet n=3\\nwe know that, a person can be good or bad --> there are two options only\\n```\\np1  p2   p2\\n2   2   2   ----> 2*2*2= 2^3 combinations\\n```\\n000   ---> bad bad bad\\n001\\n010\\n011\\n100\\n101\\n110\\n111\\n\\nwe will only care about only good persons and ignore bad persons\\nbcoz good persons will always tells truth.\\n\\nWe assume person i is good so he always speaks \\ntruth so there are 2 possible contradictions :\\n(i) Person i said that person j is good but we assume person j is bad so, here it contradict.\\n\\n(ii) Person i said that person j is bad but we assume person j is good so, here it contradict.\\n\\n\\nif everything is okay (no contradiction)\\nthen  just count the no. of good peoples in this combination\\nSimilarly do for all combinations and return max of them.\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumGood(vector<vector<int>>& a) {\\n        int ans = 0;\\n        int n = a.size();\\n        for (int mask = 0; mask < (1 << n); mask++)\\n        {\\n            bool can = true;\\n            for (int i = 0; i < n; i++)\\n            {\\n                if (!(mask & (1 << i))) continue;  // if bad\\n                for (int j = 0; j < n; j++)\\n                {\\n                    if (a[i][j] == 1)\\n                    {  if (!(mask & (1 << j))) can = false; }\\n\\t\\t\\t\\t\\t\\n                    if (a[i][j] == 0)\\n                    {  if ((mask & (1 << j)))   can = false; }\\n                }\\n            }\\n            if (can)  \\n            {\\n                int  curr = __builtin_popcount(mask);\\n                ans= max(ans, curr);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\np1  p2   p2\\n2   2   2   ----> 2*2*2= 2^3 combinations\\n```\n```\\nclass Solution {\\npublic:\\n    int maximumGood(vector<vector<int>>& a) {\\n        int ans = 0;\\n        int n = a.size();\\n        for (int mask = 0; mask < (1 << n); mask++)\\n        {\\n            bool can = true;\\n            for (int i = 0; i < n; i++)\\n            {\\n                if (!(mask & (1 << i))) continue;  // if bad\\n                for (int j = 0; j < n; j++)\\n                {\\n                    if (a[i][j] == 1)\\n                    {  if (!(mask & (1 << j))) can = false; }\\n\\t\\t\\t\\t\\t\\n                    if (a[i][j] == 0)\\n                    {  if ((mask & (1 << j)))   can = false; }\\n                }\\n            }\\n            if (can)  \\n            {\\n                int  curr = __builtin_popcount(mask);\\n                ans= max(ans, curr);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711823,
                "title": "javascript-bitmask-116ms",
                "content": "```\\nconst bitCount = (n) => { n = n - ((n >> 1) & 0x55555555); n = (n & 0x33333333) + ((n >> 2) & 0x33333333); return ((n + (n >> 4) & 0xF0F0F0F) * 0x1010101) >> 24; };\\n\\nconst maximumGood = (g) => {\\n    let n = g.length, res = Number.MIN_SAFE_INTEGER;\\n    outer:\\n    for(let i = 0; i < 1 << n; i++) {\\n        for (let j = 0; j < n; j++) {\\n            for (let k = 0; k < n; k++) {\\n                if (g[j][k] == 2) continue;\\n                if (i & (1 << j)) {\\n                    if (i & (1 << k)) {\\n                       if (g[j][k] == 0) continue outer;\\n                    } else {\\n                        if (g[j][k] == 1) continue outer;\\n                    }\\n                }\\n            }\\n        }\\n        res = Math.max(res, bitCount(i));\\n    }\\n    return res;\\n};\\n```\\nmodified version\\n```\\nconst maximumGood = (g) => {\\n    let n = g.length, res = Number.MIN_SAFE_INTEGER;\\n    for (let i = 0; i < 1 << n; i++) {\\n        let ok = true, cnt = 0;\\n        for (let j = 0; j < n; j++) {\\n            if (i & (1 << j)) {\\n                cnt++;\\n                for (let k = 0; k < n; k++) {\\n                    if (g[j][k] == 2) continue;\\n                    if (i & (1 << k)) {\\n                        if (g[j][k] == 0) ok = false;\\n                    } else {\\n                        if (g[j][k] == 1) ok = false;\\n                    }\\n                    // if (!ok) break;   // add will speed up, not add is also correct\\n                }\\n            }\\n            // if (!ok) break;\\n        }\\n        if (ok) res = Math.max(res, cnt);\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bitmask"
                ],
                "code": "```\\nconst bitCount = (n) => { n = n - ((n >> 1) & 0x55555555); n = (n & 0x33333333) + ((n >> 2) & 0x33333333); return ((n + (n >> 4) & 0xF0F0F0F) * 0x1010101) >> 24; };\\n\\nconst maximumGood = (g) => {\\n    let n = g.length, res = Number.MIN_SAFE_INTEGER;\\n    outer:\\n    for(let i = 0; i < 1 << n; i++) {\\n        for (let j = 0; j < n; j++) {\\n            for (let k = 0; k < n; k++) {\\n                if (g[j][k] == 2) continue;\\n                if (i & (1 << j)) {\\n                    if (i & (1 << k)) {\\n                       if (g[j][k] == 0) continue outer;\\n                    } else {\\n                        if (g[j][k] == 1) continue outer;\\n                    }\\n                }\\n            }\\n        }\\n        res = Math.max(res, bitCount(i));\\n    }\\n    return res;\\n};\\n```\n```\\nconst maximumGood = (g) => {\\n    let n = g.length, res = Number.MIN_SAFE_INTEGER;\\n    for (let i = 0; i < 1 << n; i++) {\\n        let ok = true, cnt = 0;\\n        for (let j = 0; j < n; j++) {\\n            if (i & (1 << j)) {\\n                cnt++;\\n                for (let k = 0; k < n; k++) {\\n                    if (g[j][k] == 2) continue;\\n                    if (i & (1 << k)) {\\n                        if (g[j][k] == 0) ok = false;\\n                    } else {\\n                        if (g[j][k] == 1) ok = false;\\n                    }\\n                    // if (!ok) break;   // add will speed up, not add is also correct\\n                }\\n            }\\n            // if (!ok) break;\\n        }\\n        if (ok) res = Math.max(res, cnt);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1711775,
                "title": "go-bitmask",
                "content": "```\\nfunc max(a int, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc maximumGood(statements [][]int) int {\\n    n := len(statements)\\n    res := 0\\n    for i := 0; i < (1 << n); i++ {\\n        cnt := 0\\n        good := make([]bool, n)\\n        for j := 0; j < n; j++ {\\n            if (i & (1 << j)) != 0 {\\n                cnt++\\n                good[j] = true\\n            }\\n        }\\n        check := true\\n        for j := 0; j < n; j++ {\\n            if good[j] {\\n                for k := 0; k < n; k++ {\\n                    if statements[j][k] == 0 {\\n                        if good[k] {\\n                            check = false\\n                        }\\n                    }\\n                    if statements[j][k] == 1 {\\n                        if !good[k] {\\n                            check = false\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if check {\\n            res = max(res, cnt)\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc max(a int, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc maximumGood(statements [][]int) int {\\n    n := len(statements)\\n    res := 0\\n    for i := 0; i < (1 << n); i++ {\\n        cnt := 0\\n        good := make([]bool, n)\\n        for j := 0; j < n; j++ {\\n            if (i & (1 << j)) != 0 {\\n                cnt++\\n                good[j] = true\\n            }\\n        }\\n        check := true\\n        for j := 0; j < n; j++ {\\n            if good[j] {\\n                for k := 0; k < n; k++ {\\n                    if statements[j][k] == 0 {\\n                        if good[k] {\\n                            check = false\\n                        }\\n                    }\\n                    if statements[j][k] == 1 {\\n                        if !good[k] {\\n                            check = false\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if check {\\n            res = max(res, cnt)\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1711671,
                "title": "java-bitmask-solution",
                "content": "Intuition - \\nn <= 15 from the constraints, which means all combinations gives us time complexity of O(2^15) ~= O(4\\\\*10^4). And travesing through the statements array for every combiantion is another 15\\\\*15 ~= 200. Time Complexity  O(10^6). Therefore a bruteforce solution works.\\nTo iterate through all the combinations we can use a bitmask and check for the combination if it is a valid combination. \\n```\\nclass Solution {\\n    // efficient way to calculate set bits in an integer\\n    private int calculateOnes(int n){\\n        int count = 0;\\n        while (n>0) {\\n            n &= (n - 1);\\n            count++;\\n        }\\n        return count;\\n    }\\n    private boolean isPossible(int[][] statements, int mask){\\n        int n = statements.length;\\n        for(int i=0;i<n;i++){\\n            //mask 0 for ith person means he may be lying\\n            // so we do not consider his statement\\n            if(((mask>>i) & 1) !=1) continue;\\n            for(int j=0;j<n;j++){\\n                //if he is saying jth person is bad but mask says he is good - contradiction\\n                if(statements[i][j]==0){\\n                    if(((mask>>j) & 1 )==1) return false;\\n                }\\n                //contradiction here as well so this combination is not valid \\n                else if(statements[i][j]==1){\\n                    if(((mask>>j) & 1)==0) return false;\\n                }\\n            }\\n        }\\n        // there is no contradiction between statements and our mask\\n        return true;\\n    }\\n    public int maximumGood(int[][] statements) {\\n        int n = statements.length;\\n        int max = 0;\\n        for(int i=0;i<(1<<n);i++){\\n            if(isPossible(statements, i)){\\n                max = Math.max(max, calculateOnes(i));\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    // efficient way to calculate set bits in an integer\\n    private int calculateOnes(int n){\\n        int count = 0;\\n        while (n>0) {\\n            n &= (n - 1);\\n            count++;\\n        }\\n        return count;\\n    }\\n    private boolean isPossible(int[][] statements, int mask){\\n        int n = statements.length;\\n        for(int i=0;i<n;i++){\\n            //mask 0 for ith person means he may be lying\\n            // so we do not consider his statement\\n            if(((mask>>i) & 1) !=1) continue;\\n            for(int j=0;j<n;j++){\\n                //if he is saying jth person is bad but mask says he is good - contradiction\\n                if(statements[i][j]==0){\\n                    if(((mask>>j) & 1 )==1) return false;\\n                }\\n                //contradiction here as well so this combination is not valid \\n                else if(statements[i][j]==1){\\n                    if(((mask>>j) & 1)==0) return false;\\n                }\\n            }\\n        }\\n        // there is no contradiction between statements and our mask\\n        return true;\\n    }\\n    public int maximumGood(int[][] statements) {\\n        int n = statements.length;\\n        int max = 0;\\n        for(int i=0;i<(1<<n);i++){\\n            if(isPossible(statements, i)){\\n                max = Math.max(max, calculateOnes(i));\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711570,
                "title": "simple-python-backtrack-solution",
                "content": "Enumerate all possibilities and check if the statements said by a good person are correct. (no contradition happens)\\n```python\\nclass Solution:\\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n      def valid(cur):\\n        for i in range(len(statements)):\\n          for j in range(len(statements)):\\n            if cur[i] == 1 and (statements[i][j] != 2 and statements[i][j] != cur[j]):\\n              return False\\n        return True\\n            \\n      def backtrack(cur, i):\\n        if i == len(statements):\\n          if valid(cur):\\n            nonlocal res\\n            res = max(res, sum(cur))\\n          return\\n\\n        for j in [0, 1]:\\n          cur.append(j)\\n          backtrack(cur, i+1)\\n          cur.pop()\\n\\n      res = 0\\n      backtrack([], 0)\\n      return res\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n      def valid(cur):\\n        for i in range(len(statements)):\\n          for j in range(len(statements)):\\n            if cur[i] == 1 and (statements[i][j] != 2 and statements[i][j] != cur[j]):\\n              return False\\n        return True\\n            \\n      def backtrack(cur, i):\\n        if i == len(statements):\\n          if valid(cur):\\n            nonlocal res\\n            res = max(res, sum(cur))\\n          return\\n\\n        for j in [0, 1]:\\n          cur.append(j)\\n          backtrack(cur, i+1)\\n          cur.pop()\\n\\n      res = 0\\n      backtrack([], 0)\\n      return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711435,
                "title": "python-solution-with-explanation",
                "content": "We can solve the problem in 2 steps:\\n1. Select those who maybe be good by a scanning: for those who I say is good, none of them says I\\'m bad.\\n2. Evaluate if the set of \"may be good\" is valid.\\n\\t2.1. If yes, return the size of this set.\\n\\t2.2. If no, we remove any of the member from the set and repeat the evaluation.\\n\\nHowever, some sets of \"may be good\" may appear many times, so we need to mask this set and avoid evluating it again.\\n\\nBelow is an implementation in Python3:\\n```python\\nclass Solution:\\n    def is_valid(self, good_set: Set[int], statements: List[List[int]]) -> bool:\\n        for idx in good_set:\\n            for i in range(len(statements[idx])):\\n                # decribed as bad but in the good set\\n                if statements[idx][i] == 0 and i in good_set:\\n                    return False\\n                # decribed as good but in the bad set\\n                if statements[idx][i] == 1 and i not in good_set:\\n                    return False\\n                \\n        return True\\n    \\n    def set_to_mask(self, good_set: Set[int], n: int) -> str:\\n        ret = [\"0\"] * n\\n        for i in good_set:\\n            ret[i] = \"1\"\\n            \\n        return \"\".join(ret)\\n    \\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        \"\"\"\\n        every person can be:\\n        1. good.\\n        2. bad but telling the truth.\\n        3. bad but lying.\\n        \\n        minimize certainly bad to maximize probably good.\\n        1. the network contains good people are always valid.\\n        2. Bruteforce, try to remove any one see if it makes the network valid.\\n        \\n        As a good person:\\n        1. When I say someone is bad, his statement doesn\\'t affect me.\\n        2. When I say someone is good, he must also say I\\'m good or no comment, otherwise contradiction.\\n        \"\"\"\\n        n = len(statements)\\n        \\n        # select those who can be good\\n        can_be_good_set = set()\\n        for i, statement in enumerate(statements):\\n            can_be_good = True\\n            for j, comment in enumerate(statement):\\n                # i says j is good but j says i is bad\\n                if comment == 1 and statements[j][i] == 0:\\n                    can_be_good = False\\n                if not can_be_good:\\n                    False\\n            if can_be_good:\\n                can_be_good_set.add(i)\\n                    \\n        # if the combination of those who can be good is not valid\\n        # we try remove one of them\\n        Q = [can_be_good_set]\\n        seen = {self.set_to_mask(can_be_good_set, n)}\\n        while len(Q) > 0: \\n            can_be_good_set = Q.pop(0)\\n            if self.is_valid(can_be_good_set, statements):\\n                return len(can_be_good_set)\\n            else:\\n                for can_be_good in can_be_good_set:\\n                    _can_be_good_set = can_be_good_set - {can_be_good}\\n                    mask = self.set_to_mask(_can_be_good_set, n)\\n                    if mask not in seen:\\n                        Q.append(_can_be_good_set)\\n                        seen.add(mask)\\n\\n        return 0\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def is_valid(self, good_set: Set[int], statements: List[List[int]]) -> bool:\\n        for idx in good_set:\\n            for i in range(len(statements[idx])):\\n                # decribed as bad but in the good set\\n                if statements[idx][i] == 0 and i in good_set:\\n                    return False\\n                # decribed as good but in the bad set\\n                if statements[idx][i] == 1 and i not in good_set:\\n                    return False\\n                \\n        return True\\n    \\n    def set_to_mask(self, good_set: Set[int], n: int) -> str:\\n        ret = [\"0\"] * n\\n        for i in good_set:\\n            ret[i] = \"1\"\\n            \\n        return \"\".join(ret)\\n    \\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        \"\"\"\\n        every person can be:\\n        1. good.\\n        2. bad but telling the truth.\\n        3. bad but lying.\\n        \\n        minimize certainly bad to maximize probably good.\\n        1. the network contains good people are always valid.\\n        2. Bruteforce, try to remove any one see if it makes the network valid.\\n        \\n        As a good person:\\n        1. When I say someone is bad, his statement doesn\\'t affect me.\\n        2. When I say someone is good, he must also say I\\'m good or no comment, otherwise contradiction.\\n        \"\"\"\\n        n = len(statements)\\n        \\n        # select those who can be good\\n        can_be_good_set = set()\\n        for i, statement in enumerate(statements):\\n            can_be_good = True\\n            for j, comment in enumerate(statement):\\n                # i says j is good but j says i is bad\\n                if comment == 1 and statements[j][i] == 0:\\n                    can_be_good = False\\n                if not can_be_good:\\n                    False\\n            if can_be_good:\\n                can_be_good_set.add(i)\\n                    \\n        # if the combination of those who can be good is not valid\\n        # we try remove one of them\\n        Q = [can_be_good_set]\\n        seen = {self.set_to_mask(can_be_good_set, n)}\\n        while len(Q) > 0: \\n            can_be_good_set = Q.pop(0)\\n            if self.is_valid(can_be_good_set, statements):\\n                return len(can_be_good_set)\\n            else:\\n                for can_be_good in can_be_good_set:\\n                    _can_be_good_set = can_be_good_set - {can_be_good}\\n                    mask = self.set_to_mask(_can_be_good_set, n)\\n                    if mask not in seen:\\n                        Q.append(_can_be_good_set)\\n                        seen.add(mask)\\n\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711353,
                "title": "java-backtrack",
                "content": "```\\nclass Solution {\\n    int max=0;\\n    public int maximumGood(int[][] statements) {\\n        int n=statements.length;\\n        int[] arr=new int[n]; //0 bad, 1 good, 2 no statement\\n        Arrays.fill(arr, 2);\\n        dfs(0,arr,statements,n);\\n        return max;\\n    }\\n    private void dfs(int index, int[] arr, int[][] statements, int n){\\n        if (index>=n){\\n            int res=0;\\n            for (int i=0; i<n; i++){\\n                if (arr[i]==1){\\n                    res++;\\n                }\\n            }\\n            max=Math.max(max,res);\\n            return;\\n        }\\n            \\n        int[] temp=arr.clone();\\n        if (temp[index]==0){ // statement doesn\\'t care\\n            dfs(index+1, temp, statements,n);\\n            return;\\n        } else if (temp[index]==1){\\n            int[] st=statements[index];\\n            for (int i=0; i<n; i++){\\n                if ((st[i]==0 && temp[i]==1) || (st[i]==1 && temp[i]==0)){\\n                    return;\\n                }\\n                if (st[i]!=2) temp[i]=st[i];\\n            }\\n            dfs(index+1, temp, statements,n);\\n            return;\\n        } else {\\n            temp[index]=0;\\n            dfs(index+1, temp, statements, n);\\n            temp[index]=1;\\n            int[] st1=statements[index];\\n            for (int i=0; i<n; i++){\\n                if ((st1[i]==0 && temp[i]==1) || (st1[i]==1 && temp[i]==0)){\\n                    return;\\n                }\\n                if (st1[i]!=2) temp[i]=st1[i];\\n            }\\n            dfs(index+1, temp, statements, n);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int max=0;\\n    public int maximumGood(int[][] statements) {\\n        int n=statements.length;\\n        int[] arr=new int[n]; //0 bad, 1 good, 2 no statement\\n        Arrays.fill(arr, 2);\\n        dfs(0,arr,statements,n);\\n        return max;\\n    }\\n    private void dfs(int index, int[] arr, int[][] statements, int n){\\n        if (index>=n){\\n            int res=0;\\n            for (int i=0; i<n; i++){\\n                if (arr[i]==1){\\n                    res++;\\n                }\\n            }\\n            max=Math.max(max,res);\\n            return;\\n        }\\n            \\n        int[] temp=arr.clone();\\n        if (temp[index]==0){ // statement doesn\\'t care\\n            dfs(index+1, temp, statements,n);\\n            return;\\n        } else if (temp[index]==1){\\n            int[] st=statements[index];\\n            for (int i=0; i<n; i++){\\n                if ((st[i]==0 && temp[i]==1) || (st[i]==1 && temp[i]==0)){\\n                    return;\\n                }\\n                if (st[i]!=2) temp[i]=st[i];\\n            }\\n            dfs(index+1, temp, statements,n);\\n            return;\\n        } else {\\n            temp[index]=0;\\n            dfs(index+1, temp, statements, n);\\n            temp[index]=1;\\n            int[] st1=statements[index];\\n            for (int i=0; i<n; i++){\\n                if ((st1[i]==0 && temp[i]==1) || (st1[i]==1 && temp[i]==0)){\\n                    return;\\n                }\\n                if (st1[i]!=2) temp[i]=st1[i];\\n            }\\n            dfs(index+1, temp, statements, n);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711341,
                "title": "java-my-dfs-bitmask-o-n-2-n-solution-with-tree-pruning-beat-100-1ms",
                "content": "Share my O(n * 2 ^ n) time and O(1) space solution. Prunning the tree, optimizing space compleixity using bitmask.\\n\\n```\\nclass Solution {\\n    private int maxResult = 0;\\n\\n    public int maximumGood(int[][] statements) {\\n        // Given 2 <= n <= 15, the states of all people can be stored in a bitmask (32 digits) \\n        int bitmask = 0;\\n        checkStateFrom(bitmask, 0, 0, statements);\\n        return maxResult;\\n    }\\n    \\n    private void checkStateFrom(int bitmask, int curr, int goodCount, int[][] statements) {\\n        int n = statements.length;\\n        \\n        if (curr == statements.length) {\\n            maxResult = Math.max(goodCount, maxResult);\\n            return;\\n        }\\n        \\n        // pruning useless branches\\n        if (goodCount + n - curr <= maxResult) {\\n            return;\\n        }\\n        \\n        boolean canBeGood = true;\\n        boolean canBeBad = true;\\n\\t\\t// for each previous person, check if there\\'s any contradictory statements\\n        for (int i = 0; i < curr; i++) {\\n            int iStatement = (bitmask >> i) % 2;\\n            if (iStatement == 1 && statements[i][curr] == 0 /* Violates i\\'s statement */\\n               || statements[curr][i] != 2 && statements[curr][i] != iStatement) { /* Wrong statement about i */\\n                canBeGood = false;\\n            }\\n            if (iStatement == 1 && statements[i][curr] == 1) { /* Violates i\\'s statement */\\n                canBeBad = false;\\n            }\\n            if (!canBeGood && !canBeBad) {\\n                return;\\n            }\\n        }\\n        if (canBeGood) {\\n            checkStateFrom(bitmask + (1 << curr), curr + 1, goodCount + 1, statements);\\n        }      \\n        if (canBeBad) {\\n            checkStateFrom(bitmask, curr + 1, goodCount, statements);\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    private int maxResult = 0;\\n\\n    public int maximumGood(int[][] statements) {\\n        // Given 2 <= n <= 15, the states of all people can be stored in a bitmask (32 digits) \\n        int bitmask = 0;\\n        checkStateFrom(bitmask, 0, 0, statements);\\n        return maxResult;\\n    }\\n    \\n    private void checkStateFrom(int bitmask, int curr, int goodCount, int[][] statements) {\\n        int n = statements.length;\\n        \\n        if (curr == statements.length) {\\n            maxResult = Math.max(goodCount, maxResult);\\n            return;\\n        }\\n        \\n        // pruning useless branches\\n        if (goodCount + n - curr <= maxResult) {\\n            return;\\n        }\\n        \\n        boolean canBeGood = true;\\n        boolean canBeBad = true;\\n\\t\\t// for each previous person, check if there\\'s any contradictory statements\\n        for (int i = 0; i < curr; i++) {\\n            int iStatement = (bitmask >> i) % 2;\\n            if (iStatement == 1 && statements[i][curr] == 0 /* Violates i\\'s statement */\\n               || statements[curr][i] != 2 && statements[curr][i] != iStatement) { /* Wrong statement about i */\\n                canBeGood = false;\\n            }\\n            if (iStatement == 1 && statements[i][curr] == 1) { /* Violates i\\'s statement */\\n                canBeBad = false;\\n            }\\n            if (!canBeGood && !canBeBad) {\\n                return;\\n            }\\n        }\\n        if (canBeGood) {\\n            checkStateFrom(bitmask + (1 << curr), curr + 1, goodCount + 1, statements);\\n        }      \\n        if (canBeBad) {\\n            checkStateFrom(bitmask, curr + 1, goodCount, statements);\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711335,
                "title": "c-2151-maximum-good-people-based-on-statements",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maximumGood(vector<vector<int>>& statements) {\\n        int ans = 0, n = statements.size(); \\n        for (int m = (1<<n)-1; m >= 0; --m) {\\n            bool cand = true; \\n            for (int i = 0; i < n; ++i) \\n                if ((m & (1<<i)) && cand) \\n                    for (int j = 0; j < n; ++j) \\n                        if ((statements[i][j]==1 && !(m & 1<<j)) || (statements[i][j]==0 && (m & 1<<j))) {\\n                            cand = false; \\n                            break; \\n                        }\\n            if (cand) ans = max(ans, __builtin_popcount(m)); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGood(vector<vector<int>>& statements) {\\n        int ans = 0, n = statements.size(); \\n        for (int m = (1<<n)-1; m >= 0; --m) {\\n            bool cand = true; \\n            for (int i = 0; i < n; ++i) \\n                if ((m & (1<<i)) && cand) \\n                    for (int j = 0; j < n; ++j) \\n                        if ((statements[i][j]==1 && !(m & 1<<j)) || (statements[i][j]==0 && (m & 1<<j))) {\\n                            cand = false; \\n                            break; \\n                        }\\n            if (cand) ans = max(ans, __builtin_popcount(m)); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711299,
                "title": "c-check-the-combination-easy-to-understand-bitmask",
                "content": "* Generate all combinations using bitmask where the mask tells that who all are speaking truth (1->truth, 0->lying). \\n* Now you just need to check that all the people who we assumed are speaking truth, their statements should not contradict. i.e. if 3rd person says 1 and 2 and bad people and in our mask if 1 and 2 are not bad(not 0), then this configuration is invalid.\\n* You just need to check this for all.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> DP[16][16];\\n    void findBitCombinations(int k){\\n\\t    string str = \"\";\\n\\t    for (int len = 0; len <= k; len++){\\n\\t\\t    DP[len][0].push_back(str);\\n\\t\\t    str = str + \"0\";\\n\\t    }\\n\\t    for (int len = 1; len <= k; len++)\\n\\t    {\\n\\t\\t    for (int n = 1; n <= len; n++)\\n\\t\\t    {\\n\\t\\t\\t    for (string str : DP[len - 1][n])\\n\\t\\t\\t\\t    DP[len][n].push_back(\"0\" + str);\\n\\t\\t\\t    for (string str : DP[len - 1][n - 1])\\n\\t\\t\\t\\t    DP[len][n].push_back(\"1\" + str);\\n\\t\\t    }\\n\\t    }\\n\\t\\n    }\\n    \\n    bool ok(string str, vector<vector<int>>& stm){\\n        //010--> 0,1,2\\n        int n=str.size();\\n        for(int i=0;i<n;i++){\\n            if(str[i]==\\'1\\'){\\n                for(int j=0;j<n;j++){\\n                    if(stm[i][j]!=2 and stm[i][j]!=(str[j]-\\'0\\'))\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    int maximumGood(vector<vector<int>>& stm) {\\n        int k=stm.size();\\n        int ans=0;\\n        findBitCombinations(k);\\n        for (int n = k; n >=1; n--){\\n\\t\\t    for (string str : DP[k][n]){\\n                if(ok(str, stm)){\\n                    return n;\\n                }\\n            }\\n\\t    }   \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> DP[16][16];\\n    void findBitCombinations(int k){\\n\\t    string str = \"\";\\n\\t    for (int len = 0; len <= k; len++){\\n\\t\\t    DP[len][0].push_back(str);\\n\\t\\t    str = str + \"0\";\\n\\t    }\\n\\t    for (int len = 1; len <= k; len++)\\n\\t    {\\n\\t\\t    for (int n = 1; n <= len; n++)\\n\\t\\t    {\\n\\t\\t\\t    for (string str : DP[len - 1][n])\\n\\t\\t\\t\\t    DP[len][n].push_back(\"0\" + str);\\n\\t\\t\\t    for (string str : DP[len - 1][n - 1])\\n\\t\\t\\t\\t    DP[len][n].push_back(\"1\" + str);\\n\\t\\t    }\\n\\t    }\\n\\t\\n    }\\n    \\n    bool ok(string str, vector<vector<int>>& stm){\\n        //010--> 0,1,2\\n        int n=str.size();\\n        for(int i=0;i<n;i++){\\n            if(str[i]==\\'1\\'){\\n                for(int j=0;j<n;j++){\\n                    if(stm[i][j]!=2 and stm[i][j]!=(str[j]-\\'0\\'))\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    int maximumGood(vector<vector<int>>& stm) {\\n        int k=stm.size();\\n        int ans=0;\\n        findBitCombinations(k);\\n        for (int n = k; n >=1; n--){\\n\\t\\t    for (string str : DP[k][n]){\\n                if(ok(str, stm)){\\n                    return n;\\n                }\\n            }\\n\\t    }   \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711282,
                "title": "python-simple-bitmask",
                "content": "Emureate all the possible good people and check if the enumerate is correct.\\n\\nAn enumeration is correct if good people\\'s statement are true. \\n```\\nclass Solution:\\n    def maximumGood(self, A: List[List[int]]) -> int:\\n        \\n        ans = 0\\n        for i in range(1 << len(A))[::-1]:\\n            \\n            # enumerate the ppl who told the truth\\n            good = []\\n            for j in range(len(A)):\\n                if i & (1 << j):\\n                    good.append(j)\\n            \\n            # check conflict \\n            count = self.get_count(A, good)\\n            \\n            ans = max(ans, count)\\n        \\n        return ans\\n    \\n    def get_count(self, graph, good):\\n        \\n        for g in good:\\n            for nei, st in enumerate(graph[g]):\\n                if st == 2:\\n                    continue\\n                elif st == 1:\\n                    # nei should be good\\n                    if nei not in good:\\n                        return 0\\n                elif st == 0:\\n                    # nei should not be in good\\n                    if nei in good:\\n                        return 0\\n        return len(good)\\n```",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def maximumGood(self, A: List[List[int]]) -> int:\\n        \\n        ans = 0\\n        for i in range(1 << len(A))[::-1]:\\n            \\n            # enumerate the ppl who told the truth\\n            good = []\\n            for j in range(len(A)):\\n                if i & (1 << j):\\n                    good.append(j)\\n            \\n            # check conflict \\n            count = self.get_count(A, good)\\n            \\n            ans = max(ans, count)\\n        \\n        return ans\\n    \\n    def get_count(self, graph, good):\\n        \\n        for g in good:\\n            for nei, st in enumerate(graph[g]):\\n                if st == 2:\\n                    continue\\n                elif st == 1:\\n                    # nei should be good\\n                    if nei not in good:\\n                        return 0\\n                elif st == 0:\\n                    # nei should not be in good\\n                    if nei in good:\\n                        return 0\\n        return len(good)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711233,
                "title": "c-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumGood(vector<vector<int>>& ss) {\\n        int n = ss.size(), res = 0;\\n \\n        for (int i = 1; i < (1 << n); i++) {\\n            bool valid = true;\\n            for (int j = 0; valid && j < n; j++) {\\n                if ((1 << j) & i) {\\n                    for (int k = 0; k < n; k++) {\\n                        if (ss[j][k] == 1 && ((1 << k) & ~i) ||\\n                            !ss[j][k] && ((1 << k) & i))\\n                            valid = false;\\n                    }\\n                }\\n            }\\n            \\n            if (valid) {\\n                res = max(res, __builtin_popcount(i));\\n            } \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGood(vector<vector<int>>& ss) {\\n        int n = ss.size(), res = 0;\\n \\n        for (int i = 1; i < (1 << n); i++) {\\n            bool valid = true;\\n            for (int j = 0; valid && j < n; j++) {\\n                if ((1 << j) & i) {\\n                    for (int k = 0; k < n; k++) {\\n                        if (ss[j][k] == 1 && ((1 << k) & ~i) ||\\n                            !ss[j][k] && ((1 << k) & i))\\n                            valid = false;\\n                    }\\n                }\\n            }\\n            \\n            if (valid) {\\n                res = max(res, __builtin_popcount(i));\\n            } \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075289,
                "title": "typescript-javascript-beats-100-memory-and-time-bitmask",
                "content": "![Capture.JPG](https://assets.leetcode.com/users/images/ec310cb4-4f96-49cf-9fb7-0a11b0f3e1d6_1695363889.9201026.jpeg)\\n```TypeScript []\\nfunction maximumGood(statements: number[][]): number {\\n    const n: number = statements.length\\n    let res: number = Number.MIN_SAFE_INTEGER\\n    outer:\\n    for(let i = 0; i < 1 << n; i++){\\n        for(let j = 0; j < n; j++){\\n            for(let k = 0; k < n; k++){\\n                if(statements[j][k] === 2) continue\\n                if(i & (1 << j)){\\n                    if(i & (1 << k)){\\n                        if(statements[j][k] === 0) continue outer\\n                    }\\n                    else{\\n                        if(statements[j][k] === 1) continue outer\\n                    }\\n                }\\n            }\\n        }\\n        res = Math.max(res, bitCount(i))\\n    }\\n    return res\\n}\\n\\nconst bitCount = (n: number) => {\\n    n = n - ((n >> 1) & 0x55555555)\\n    n = (n & 0x33333333) + ((n >> 2) & 0x33333333)\\n    return ((n + (n >> 4) & 0xF0F0F0F) * 0x1010101) >> 24\\n}\\n```\\n```JavaScript []\\nfunction maximumGood(statements) {\\n    const n = statements.length\\n    let res = Number.MIN_SAFE_INTEGER\\n    outer:\\n    for(let i = 0; i < 1 << n; i++){\\n        for(let j = 0; j < n; j++){\\n            for(let k = 0; k < n; k++){\\n                if(statements[j][k] === 2) continue\\n                if(i & (1 << j)){\\n                    if(i & (1 << k)){\\n                        if(statements[j][k] === 0) continue outer\\n                    }\\n                    else{\\n                        if(statements[j][k] === 1) continue outer\\n                    }\\n                }\\n            }\\n        }\\n        res = Math.max(res, bitCount(i))\\n    }\\n    return res\\n}\\n\\nconst bitCount = (n) => {\\n    n = n - ((n >> 1) & 0x55555555)\\n    n = (n & 0x33333333) + ((n >> 2) & 0x33333333)\\n    return ((n + (n >> 4) & 0xF0F0F0F) * 0x1010101) >> 24\\n}\\n```\\n\\n\\n\\n# Code\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Bitmask"
                ],
                "code": "```TypeScript []\\nfunction maximumGood(statements: number[][]): number {\\n    const n: number = statements.length\\n    let res: number = Number.MIN_SAFE_INTEGER\\n    outer:\\n    for(let i = 0; i < 1 << n; i++){\\n        for(let j = 0; j < n; j++){\\n            for(let k = 0; k < n; k++){\\n                if(statements[j][k] === 2) continue\\n                if(i & (1 << j)){\\n                    if(i & (1 << k)){\\n                        if(statements[j][k] === 0) continue outer\\n                    }\\n                    else{\\n                        if(statements[j][k] === 1) continue outer\\n                    }\\n                }\\n            }\\n        }\\n        res = Math.max(res, bitCount(i))\\n    }\\n    return res\\n}\\n\\nconst bitCount = (n: number) => {\\n    n = n - ((n >> 1) & 0x55555555)\\n    n = (n & 0x33333333) + ((n >> 2) & 0x33333333)\\n    return ((n + (n >> 4) & 0xF0F0F0F) * 0x1010101) >> 24\\n}\\n```\n```JavaScript []\\nfunction maximumGood(statements) {\\n    const n = statements.length\\n    let res = Number.MIN_SAFE_INTEGER\\n    outer:\\n    for(let i = 0; i < 1 << n; i++){\\n        for(let j = 0; j < n; j++){\\n            for(let k = 0; k < n; k++){\\n                if(statements[j][k] === 2) continue\\n                if(i & (1 << j)){\\n                    if(i & (1 << k)){\\n                        if(statements[j][k] === 0) continue outer\\n                    }\\n                    else{\\n                        if(statements[j][k] === 1) continue outer\\n                    }\\n                }\\n            }\\n        }\\n        res = Math.max(res, bitCount(i))\\n    }\\n    return res\\n}\\n\\nconst bitCount = (n) => {\\n    n = n - ((n >> 1) & 0x55555555)\\n    n = (n & 0x33333333) + ((n >> 2) & 0x33333333)\\n    return ((n + (n >> 4) & 0xF0F0F0F) * 0x1010101) >> 24\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4021962,
                "title": "c-easy-and-optimal-solution-using-bitmask",
                "content": "# Intuition\\nDue to the light constraints we can try with every combination of good people.\\n\\n# Approach\\nFor checking whether a combination is valid or not, we need to check the statement of the good people is correct.\\nIf their is no contradiction in statements of good people, we can count the good people in that combination and take the maximum with our result.\\n\\n# Complexity\\n- Time complexity: O(2^N * N^2)\\n\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int mask, vector<vector<int>>& v)\\n    {\\n        int n = v.size();\\n        for(int i = 0; i < n; i++)\\n        {\\n            // Assuming ith person is good\\n            if(mask >> i & 1)\\n            {\\n                // then all his statements shoud be true\\n                for(int j = 0; j < n; j++)\\n                {\\n                    bool good = mask >> j & 1;\\n                    if(v[i][j] == 2) continue;\\n                    // if his statement contradicts\\n                    if(v[i][j] ^ good)\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    int maximumGood(vector<vector<int>>& v) {\\n        int n = v.size();\\n        int mask = (1 << n) - 1;\\n        int res = 0;\\n        // trying all possible combinations of good people\\n        while(mask >= 0)\\n        {\\n            if(isPossible(mask, v))\\n                res = max(res, __builtin_popcount(mask));\\n            mask--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int mask, vector<vector<int>>& v)\\n    {\\n        int n = v.size();\\n        for(int i = 0; i < n; i++)\\n        {\\n            // Assuming ith person is good\\n            if(mask >> i & 1)\\n            {\\n                // then all his statements shoud be true\\n                for(int j = 0; j < n; j++)\\n                {\\n                    bool good = mask >> j & 1;\\n                    if(v[i][j] == 2) continue;\\n                    // if his statement contradicts\\n                    if(v[i][j] ^ good)\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    int maximumGood(vector<vector<int>>& v) {\\n        int n = v.size();\\n        int mask = (1 << n) - 1;\\n        int res = 0;\\n        // trying all possible combinations of good people\\n        while(mask >= 0)\\n        {\\n            if(isPossible(mask, v))\\n                res = max(res, __builtin_popcount(mask));\\n            mask--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651808,
                "title": "golang",
                "content": "# Code\\n```\\nfunc maximumGood(statements [][]int) int {\\n    n := len(statements)\\n    maxCount := 0\\n    for i := 0; i < (1 << n); i++ {\\n        if isValid(i, statements) && numOnes(i) > maxCount {\\n            maxCount = numOnes(i)\\n        }\\n    }\\n    return maxCount\\n}\\n\\nfunc isValid(mask int, statements [][]int) bool {\\n    n := len(statements)\\n    for i := 0; i < n; i++{\\n        if ((1<<i) & mask) == (1<<i) {\\n            for j := 0; j < n; j++ {\\n                if statements[i][j] != 2 && (statements[i][j]<<j) != (mask & (1<<j)) {\\n                    return false\\n                }\\n            }\\n        } \\n    }\\n    return true\\n}\\n\\nfunc numOnes(i int) int {\\n    count := 0\\n    for i > 0 {\\n        count += i & 1\\n        i >>= 1\\n    }\\n    return count\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maximumGood(statements [][]int) int {\\n    n := len(statements)\\n    maxCount := 0\\n    for i := 0; i < (1 << n); i++ {\\n        if isValid(i, statements) && numOnes(i) > maxCount {\\n            maxCount = numOnes(i)\\n        }\\n    }\\n    return maxCount\\n}\\n\\nfunc isValid(mask int, statements [][]int) bool {\\n    n := len(statements)\\n    for i := 0; i < n; i++{\\n        if ((1<<i) & mask) == (1<<i) {\\n            for j := 0; j < n; j++ {\\n                if statements[i][j] != 2 && (statements[i][j]<<j) != (mask & (1<<j)) {\\n                    return false\\n                }\\n            }\\n        } \\n    }\\n    return true\\n}\\n\\nfunc numOnes(i int) int {\\n    count := 0\\n    for i > 0 {\\n        count += i & 1\\n        i >>= 1\\n    }\\n    return count\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3555837,
                "title": "rust-incrementally-build-possible-truth-states",
                "content": "# Intuition\\nSuppose that we were told the good/bad status of the people [0, 1, ...i-1] and we are then considering person i to determine if they\\'re good or bad.\\n\\nFirst then we can do is ask all of our known-good people about i.\\n\\nIf some of our trusted memebers say \"i is good\" and some of them say \"i is bad\", then we\\'re in a contradiction, because i can\\'t be good and bad at the same time. That means this can\\'t be a possible arrangement, and we throw out this case entirely.\\n\\nIf at least some of our trusted members say \"i is bad\" and none of them say \"i is good\", then i must be bad. So we can extend our known good/bad status with the fact that i is bad.\\n\\nIf some of our trusted members say \"i is good\", we then need to check what i has to say. If i disagrees with our current good/bad status (saying a known good j is actually bad, or a known bad j is actually good) then we\\'re in a contradiction, and throw out the test case. Otherwise, if all known good js agree i is good, and i agrees with our current good/bad state, we can extend out good/bad status with the fact that i is definitely good.\\n\\nIf none of our trusted members make any definite statements on i (including if we have no members at all so far), then it\\'s possible i is a liar. So we have to consider that.\\n\\ni might also be good, but only if they agree with our current state. If they do, then we have to consider both possibilities. If they don\\'t.\\n\\nTaken together, this means that a known-good list of [0..i-1] will either be thrown out as a contradiction, will be extended with a single fact about i, or will be split into two new cases where i is good and i is bad.\\n\\nThis gives us a way to pathfind from no known good/bads, up until we have all n good/bad states defined. \\n\\n# Complexity\\n- Time complexity: O(n^2) average case, O(2^n) in the worst case. Adding each new i requires doing an O(n) scan across the previous truth statements, so it\\'s at least O(n^2). And if our grid is entirely 2s (i.e no one makes any statements) we end up considering the entire power set of the set of n people.\\n\\n- Space complexity: O(n * 2^n), we have to hold an O(n) vector of booleans for up to O(2^n) possible truth states.\\n\\n# Code\\n```\\nuse std::collections::VecDeque;\\nimpl Solution {\\n    pub fn maximum_good(statements: Vec<Vec<i32>>) -> i32 {\\n        let n = statements.len();\\n\\n        let mut queue = VecDeque::<Vec<bool>>::new();\\n        queue.push_back(Vec::new());\\n        \\n        let mut best = 0;\\n        while let Some(mut known) = queue.pop_front() {\\n            let i = known.len();\\n            if i == n {\\n                best = best.max(known.into_iter().filter(|&good| good).count());\\n                continue;\\n            }\\n\\n            let i_called_bad = known\\n            .iter()\\n            .enumerate()\\n            .any(|(j, &j_good)| j_good && statements[j][i] == 0);\\n\\n            let i_called_good = known\\n            .iter()\\n            .enumerate()\\n            .any(|(j, &j_good)| j_good && statements[j][i] == 1);\\n\\n            if i_called_bad && i_called_good {\\n                // Contradiction: previous \"goods\" are in conflict about i\\n                // This arrangement is impossible\\n                continue;\\n            } \\n            \\n            if i_called_bad {\\n                // Previous goods agree i is untrustworthy\\n                // We don\\'t care what i says\\n                known.push(false);\\n                queue.push_back(known);\\n                continue;\\n            }\\n\\n            // Check consistency against known good js\\n            let i_agrees_with_known = known\\n            .iter()\\n            .enumerate()\\n            .all(|(j, &j_good)| {\\n                (j_good && statements[i][j] != 0)\\n                || (!j_good && statements[i][j] != 1)\\n            });\\n\\n            if i_called_good && !i_agrees_with_known {\\n                // Contradiction: i is in conflict with existing goods\\n                continue;\\n            }\\n\\n            if i_called_good {\\n                // Existing goods like i\\n                // i likes all existing goods\\n                // i must be good\\n                known.push(true);\\n                queue.push_back(known);\\n                continue;\\n            }\\n\\n            // No previous good j has made a statement on i\\n            if i_agrees_with_known {\\n                // Possible i tells the truth\\n                let mut case_i_good = known.clone();\\n                case_i_good.push(true);\\n                queue.push_back(case_i_good);\\n            }\\n\\n            // Possible that i is a liar\\n            let mut case_i_lies = known;\\n            case_i_lies.push(false);\\n            queue.push_back(case_i_lies);\\n        }\\n\\n        best as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::VecDeque;\\nimpl Solution {\\n    pub fn maximum_good(statements: Vec<Vec<i32>>) -> i32 {\\n        let n = statements.len();\\n\\n        let mut queue = VecDeque::<Vec<bool>>::new();\\n        queue.push_back(Vec::new());\\n        \\n        let mut best = 0;\\n        while let Some(mut known) = queue.pop_front() {\\n            let i = known.len();\\n            if i == n {\\n                best = best.max(known.into_iter().filter(|&good| good).count());\\n                continue;\\n            }\\n\\n            let i_called_bad = known\\n            .iter()\\n            .enumerate()\\n            .any(|(j, &j_good)| j_good && statements[j][i] == 0);\\n\\n            let i_called_good = known\\n            .iter()\\n            .enumerate()\\n            .any(|(j, &j_good)| j_good && statements[j][i] == 1);\\n\\n            if i_called_bad && i_called_good {\\n                // Contradiction: previous \"goods\" are in conflict about i\\n                // This arrangement is impossible\\n                continue;\\n            } \\n            \\n            if i_called_bad {\\n                // Previous goods agree i is untrustworthy\\n                // We don\\'t care what i says\\n                known.push(false);\\n                queue.push_back(known);\\n                continue;\\n            }\\n\\n            // Check consistency against known good js\\n            let i_agrees_with_known = known\\n            .iter()\\n            .enumerate()\\n            .all(|(j, &j_good)| {\\n                (j_good && statements[i][j] != 0)\\n                || (!j_good && statements[i][j] != 1)\\n            });\\n\\n            if i_called_good && !i_agrees_with_known {\\n                // Contradiction: i is in conflict with existing goods\\n                continue;\\n            }\\n\\n            if i_called_good {\\n                // Existing goods like i\\n                // i likes all existing goods\\n                // i must be good\\n                known.push(true);\\n                queue.push_back(known);\\n                continue;\\n            }\\n\\n            // No previous good j has made a statement on i\\n            if i_agrees_with_known {\\n                // Possible i tells the truth\\n                let mut case_i_good = known.clone();\\n                case_i_good.push(true);\\n                queue.push_back(case_i_good);\\n            }\\n\\n            // Possible that i is a liar\\n            let mut case_i_lies = known;\\n            case_i_lies.push(false);\\n            queue.push_back(case_i_lies);\\n        }\\n\\n        best as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3549326,
                "title": "simple-bit-masking-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool valid(int m,vector<vector<int>>&statement){\\n        int N=statement.size();\\n        for(int i=0;i<N;i++){\\n            if(m>>i & 1){\\n                for(int j=0;j<N;j++){\\n                    int good=m>>j & 1;\\n                    if((statement[i][j]==0 && good) ||(statement[i][j]==1 && !good))return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    int maximumGood(vector<vector<int>>& statement) {\\n        int n=statement.size();\\n        int ans=0;\\n        for(int i=0;i< (1<<n);i++){\\n            if(valid(i,statement)){\\n                ans=max(ans,__builtin_popcount(i));\\n            }\\n\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool valid(int m,vector<vector<int>>&statement){\\n        int N=statement.size();\\n        for(int i=0;i<N;i++){\\n            if(m>>i & 1){\\n                for(int j=0;j<N;j++){\\n                    int good=m>>j & 1;\\n                    if((statement[i][j]==0 && good) ||(statement[i][j]==1 && !good))return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    int maximumGood(vector<vector<int>>& statement) {\\n        int n=statement.size();\\n        int ans=0;\\n        for(int i=0;i< (1<<n);i++){\\n            if(valid(i,statement)){\\n                ans=max(ans,__builtin_popcount(i));\\n            }\\n\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385375,
                "title": "bitmask-iteration-python",
                "content": "\\n# Code\\n```\\nfrom typing import List\\n\\n\\nclass Solution:\\n\\tdef maximumGood(self, statements: List[List[int]]) -> int:\\n\\t\\tn = len(statements)\\n\\n\\t\\tdef correct(mask):\\n\\t\\t\\tfor p in range(n):\\n\\t\\t\\t\\tfor q in range(n):\\n\\t\\t\\t\\t\\tif not (\\n\\t\\t\\t\\t\\t\\t\\tstatements[p][q] == 2 or\\n\\t\\t\\t\\t\\t\\t\\t(mask >> p & 1) == 0 or\\n\\t\\t\\t\\t\\t\\t\\t(mask >> q & 1) == statements[p][q]):\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\treturn True\\n\\n\\t\\tans = 0\\n\\t\\tfor mask in range(1 << n):\\n\\t\\t\\tif correct(mask):\\n\\t\\t\\t\\tans = max(ans, mask.bit_count())\\n\\t\\treturn ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom typing import List\\n\\n\\nclass Solution:\\n\\tdef maximumGood(self, statements: List[List[int]]) -> int:\\n\\t\\tn = len(statements)\\n\\n\\t\\tdef correct(mask):\\n\\t\\t\\tfor p in range(n):\\n\\t\\t\\t\\tfor q in range(n):\\n\\t\\t\\t\\t\\tif not (\\n\\t\\t\\t\\t\\t\\t\\tstatements[p][q] == 2 or\\n\\t\\t\\t\\t\\t\\t\\t(mask >> p & 1) == 0 or\\n\\t\\t\\t\\t\\t\\t\\t(mask >> q & 1) == statements[p][q]):\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\treturn True\\n\\n\\t\\tans = 0\\n\\t\\tfor mask in range(1 << n):\\n\\t\\t\\tif correct(mask):\\n\\t\\t\\t\\tans = max(ans, mask.bit_count())\\n\\t\\treturn ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254878,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn maximum_good(statements: Vec<Vec<i32>>) -> i32 {\\n        let mut ans = 0;\\n        for i in 1..(1 << statements.len()) {\\n            let mut chk = 1;\\n            for j in 0..statements.len() {\\n                if i & (1 << j) == 0 {\\n                    continue;\\n                }\\n                for k in 0..statements.len() {\\n                    if ((i & (1 << k) != 0) && statements[j][k] == 0) || ((i & (1 << k) == 0) && statements[j][k] == 1)\\n                    {\\n                        chk = -1;\\n                        break;\\n                    }\\n                }\\n                if chk == -1 {\\n                    break;\\n                }\\n            }\\n            if chk == 1 {\\n                let mut cnt = 0;\\n                let mut n1 = i;\\n                while n1 > 0 {\\n                    if 1 & n1 != 0 {\\n                        cnt += 1;\\n                    }\\n                    n1 >>= 1;\\n                }\\n                ans = ans.max(cnt);\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn maximum_good(statements: Vec<Vec<i32>>) -> i32 {\\n        let mut ans = 0;\\n        for i in 1..(1 << statements.len()) {\\n            let mut chk = 1;\\n            for j in 0..statements.len() {\\n                if i & (1 << j) == 0 {\\n                    continue;\\n                }\\n                for k in 0..statements.len() {\\n                    if ((i & (1 << k) != 0) && statements[j][k] == 0) || ((i & (1 << k) == 0) && statements[j][k] == 1)\\n                    {\\n                        chk = -1;\\n                        break;\\n                    }\\n                }\\n                if chk == -1 {\\n                    break;\\n                }\\n            }\\n            if chk == 1 {\\n                let mut cnt = 0;\\n                let mut n1 = i;\\n                while n1 > 0 {\\n                    if 1 & n1 != 0 {\\n                        cnt += 1;\\n                    }\\n                    n1 >>= 1;\\n                }\\n                ans = ans.max(cnt);\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3241723,
                "title": "easy-logical-brute-force",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    // global var that keeps track of max good people possible\\n    int maxGood;\\n\\n    int maximumGood(vector<vector<int>> &statements)\\n    {\\n        maxGood = 0;\\n\\n        // vector that we treat everytime as truth\\n        vector<int> people(statements.size(), 2);\\n\\n        helper(0, people, statements);\\n        return maxGood;\\n    }\\n\\n    void helper(int person, vector<int> people, vector<vector<int>> &statements)\\n    {\\n        // base case, count number of good people\\n        if (person >= people.size())\\n        {\\n            int count = 0;\\n            for (int i : people)\\n                if (i == 1)\\n                    count++;\\n\\n            // replace with maxGood if greater\\n            maxGood = max(maxGood, count);\\n            return;\\n        }\\n\\n        // if person has already been established as bad, don\\'t listen to him\\n        if (people[person] == 0)\\n        {\\n            // call recursively on next person\\n            helper(person + 1, people, statements);\\n            return;\\n        }\\n\\n        // if person has not been established as being bad or good\\n        else if (people[person] == 2)\\n        {\\n            // try them as bad person\\n            people[person] = 0;\\n\\n            // perform recursion\\n            helper(person + 1, people, statements);\\n        }\\n\\n        // otherwise, if he is already established as good person, or if not established, try him as good person\\n        people[person] = 1;\\n\\n        // go to his statement\\n        for (int i = 0; i < people.size(); i++)\\n        {\\n            // establish who he says is good as good\\n            if (statements[person][i] == 1)\\n            {\\n                // check for contradiction (if he says someone is good and we have already established them as bad)\\n                if (people[i] == 0)\\n                    return;\\n\\n                // make them good\\n                people[i] = 1;\\n            }\\n\\n            // else if he says they are bad, make them bad\\n            else if (statements[person][i] == 0)\\n            {\\n                // check for contradiction (if he says someone is bad and we have already established them as good)\\n                if (people[i] == 1)\\n                    return;\\n                people[i] = 0;\\n            }\\n        }\\n\\n        // perform same on next person using our truth vector\\n        helper(person + 1, people, statements);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    // global var that keeps track of max good people possible\\n    int maxGood;\\n\\n    int maximumGood(vector<vector<int>> &statements)\\n    {\\n        maxGood = 0;\\n\\n        // vector that we treat everytime as truth\\n        vector<int> people(statements.size(), 2);\\n\\n        helper(0, people, statements);\\n        return maxGood;\\n    }\\n\\n    void helper(int person, vector<int> people, vector<vector<int>> &statements)\\n    {\\n        // base case, count number of good people\\n        if (person >= people.size())\\n        {\\n            int count = 0;\\n            for (int i : people)\\n                if (i == 1)\\n                    count++;\\n\\n            // replace with maxGood if greater\\n            maxGood = max(maxGood, count);\\n            return;\\n        }\\n\\n        // if person has already been established as bad, don\\'t listen to him\\n        if (people[person] == 0)\\n        {\\n            // call recursively on next person\\n            helper(person + 1, people, statements);\\n            return;\\n        }\\n\\n        // if person has not been established as being bad or good\\n        else if (people[person] == 2)\\n        {\\n            // try them as bad person\\n            people[person] = 0;\\n\\n            // perform recursion\\n            helper(person + 1, people, statements);\\n        }\\n\\n        // otherwise, if he is already established as good person, or if not established, try him as good person\\n        people[person] = 1;\\n\\n        // go to his statement\\n        for (int i = 0; i < people.size(); i++)\\n        {\\n            // establish who he says is good as good\\n            if (statements[person][i] == 1)\\n            {\\n                // check for contradiction (if he says someone is good and we have already established them as bad)\\n                if (people[i] == 0)\\n                    return;\\n\\n                // make them good\\n                people[i] = 1;\\n            }\\n\\n            // else if he says they are bad, make them bad\\n            else if (statements[person][i] == 0)\\n            {\\n                // check for contradiction (if he says someone is bad and we have already established them as good)\\n                if (people[i] == 1)\\n                    return;\\n                people[i] = 0;\\n            }\\n        }\\n\\n        // perform same on next person using our truth vector\\n        helper(person + 1, people, statements);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194169,
                "title": "python-o-2-n-n-2-easy-to-read-backtracking",
                "content": "Generate all permutations of Good/Bad combinations (2^N possibilites). Loop through given statements (N^2) and see if: given our current states, if there is a contradiction. The only contradictions occur when a good person says a bad person is good or when a good person says a bad person is good. If either of those occur, we can break out of the loop early. Also keeping tracking of a count parameter for how many good people there are. \\n```\\ndef maximumGood(self, statements):\\n        \"\"\"\\n        :type statements: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        def dfs(index,curstate,count):\\n            if index == len(curstate):\\n                for i in range (len(statements)):\\n                    for j in range (len(statements)):\\n                        if statements[i][j] == 0 and curstate[i] == \\'G\\' and curstate[j] == \\'G\\':\\n                            return 0\\n                        if statements[i][j] == 1 and curstate[i] == \\'G\\' and curstate[j] == \\'B\\':\\n                            return 0\\n                return count\\n            a = dfs(index+1,curstate[:index]+[\\'B\\']+curstate[index+1:], count-1)\\n            b = dfs(index+1,curstate,count)\\n            return max(a,b)\\n        curstate = [\\'G\\']*len(statements)\\n        return dfs(0,curstate,len(statements))\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\ndef maximumGood(self, statements):\\n        \"\"\"\\n        :type statements: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        def dfs(index,curstate,count):\\n            if index == len(curstate):\\n                for i in range (len(statements)):\\n                    for j in range (len(statements)):\\n                        if statements[i][j] == 0 and curstate[i] == \\'G\\' and curstate[j] == \\'G\\':\\n                            return 0\\n                        if statements[i][j] == 1 and curstate[i] == \\'G\\' and curstate[j] == \\'B\\':\\n                            return 0\\n                return count\\n            a = dfs(index+1,curstate[:index]+[\\'B\\']+curstate[index+1:], count-1)\\n            b = dfs(index+1,curstate,count)\\n            return max(a,b)\\n        curstate = [\\'G\\']*len(statements)\\n        return dfs(0,curstate,len(statements))\\n\\t\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 3060790,
                "title": "easiest-bitmask-dp-solution-well-commented-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int res = 0;\\n    int n = 0;\\n    // check if ith bit is set or not\\n    int isGood(int mask, int i) {\\n        return mask & (1 << i);\\n    }\\n\\n    bool isValid(int s, vector<vector<int>> &statements){\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j < n; ++j) {\\n                    // if ith person is true\\n                    if(isGood(s, i)) {\\n                        /* Mask is invlaid in either of these \\n                            two case according to person \\'i\\':-\\n                        1. if jth person is bad but has been considered \\n                           good in mask\\n                        2. if jth person is good but has been \\n                           considered bad\\n                        */\\n                        if((statements[i][j] == 0 && isGood(s, j)) || (statements[i][j] == 1 && !isGood(s, j))) {\\n                            return false;\\n                        }\\n                    }\\n                }\\n        }\\n        return true;\\n    }\\n\\n    void dfs(vector<vector<int> > &statements, int &mask, int i, int goodPersonCount){\\n        if(i == n){\\n            int cpy = mask; \\n            // mask is valid if statements said all good persons true\\n            if(isValid(cpy, statements)){\\n                res = max(res, goodPersonCount);\\n            }\\n            return;\\n        }\\n        // considerig ith person to be good\\n        mask |= (1<<i);\\n        \\n        dfs(statements, mask, i+1, goodPersonCount + 1);\\n\\n        // not considering him to be good\\n        mask ^= (1<<i);\\n        dfs(statements, mask, i+1, goodPersonCount);\\n    }\\n\\n    int maximumGood(vector<vector<int>>& statements) {\\n        n = statements.size();\\n        int mask = 0;\\n        dfs(statements, mask, 0 , 0);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int res = 0;\\n    int n = 0;\\n    // check if ith bit is set or not\\n    int isGood(int mask, int i) {\\n        return mask & (1 << i);\\n    }\\n\\n    bool isValid(int s, vector<vector<int>> &statements){\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j < n; ++j) {\\n                    // if ith person is true\\n                    if(isGood(s, i)) {\\n                        /* Mask is invlaid in either of these \\n                            two case according to person \\'i\\':-\\n                        1. if jth person is bad but has been considered \\n                           good in mask\\n                        2. if jth person is good but has been \\n                           considered bad\\n                        */\\n                        if((statements[i][j] == 0 && isGood(s, j)) || (statements[i][j] == 1 && !isGood(s, j))) {\\n                            return false;\\n                        }\\n                    }\\n                }\\n        }\\n        return true;\\n    }\\n\\n    void dfs(vector<vector<int> > &statements, int &mask, int i, int goodPersonCount){\\n        if(i == n){\\n            int cpy = mask; \\n            // mask is valid if statements said all good persons true\\n            if(isValid(cpy, statements)){\\n                res = max(res, goodPersonCount);\\n            }\\n            return;\\n        }\\n        // considerig ith person to be good\\n        mask |= (1<<i);\\n        \\n        dfs(statements, mask, i+1, goodPersonCount + 1);\\n\\n        // not considering him to be good\\n        mask ^= (1<<i);\\n        dfs(statements, mask, i+1, goodPersonCount);\\n    }\\n\\n    int maximumGood(vector<vector<int>>& statements) {\\n        n = statements.size();\\n        int mask = 0;\\n        dfs(statements, mask, 0 , 0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040822,
                "title": "bit-manipulation-o-2-n-n-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumGood(vector<vector<int>>& statements) {\\n        int n = statements.size();\\n\\n        auto isValid = [&](int m){\\n            for(int i=0;i<n;i++){\\n                if(m>>i & 1){\\n                    for(int j=0;j<n;j++){\\n                        bool good = (m>>j & 1);\\n                        if((good and statements[i][j]==0) || (!good and statements[i][j]==1)){\\n                            return false;\\n                        }\\n                    }\\n                }\\n            }\\n            return true;\\n        };\\n\\n        int ans = 0;\\n        for(int i=1;i<(1<<n);i++){\\n            if(isValid(i)) ans = max(ans,__builtin_popcount(i));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGood(vector<vector<int>>& statements) {\\n        int n = statements.size();\\n\\n        auto isValid = [&](int m){\\n            for(int i=0;i<n;i++){\\n                if(m>>i & 1){\\n                    for(int j=0;j<n;j++){\\n                        bool good = (m>>j & 1);\\n                        if((good and statements[i][j]==0) || (!good and statements[i][j]==1)){\\n                            return false;\\n                        }\\n                    }\\n                }\\n            }\\n            return true;\\n        };\\n\\n        int ans = 0;\\n        for(int i=1;i<(1<<n);i++){\\n            if(isValid(i)) ans = max(ans,__builtin_popcount(i));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3036890,
                "title": "java-without-bitmasking-bruteforce-backtracking",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1 . Generate all possible combinations of people being good and bad using recursion/backtracking\\n2 . Check each combination for validity, if valid update max\\n\\n\\n# Code\\n```\\nclass Solution {\\n    static int max;\\n    public int maximumGood(int[][] statements){\\n        int n = statements.length;\\n        max=0;\\n        generateAll(statements,new int[n],0,0);\\n        return max;\\n    }\\n\\n    private static void generateAll(int[][] statements,int arr[],int idx,int count){\\n        if(idx==arr.length){\\n            boolean res = check(statements,arr);\\n            if(res) max=Math.max(max,count);\\n            return;\\n        }\\n        generateAll(statements,arr,idx+1,count);\\n        arr[idx]=1;\\n        generateAll(statements,arr,idx+1,count+1);\\n        arr[idx]=0;\\n    }\\n\\n    static boolean check(int stat[][],int arr[]){\\n        for(int i=0;i<stat.length;i++){\\n            if(arr[i]==0) continue;\\n            for(int j=0;j<stat.length;j++){\\n                if(stat[i][j]==2) continue;\\n                if((stat[i][j]==1 && arr[j]==0) || (stat[i][j]==0 && arr[j]==1)){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    static int max;\\n    public int maximumGood(int[][] statements){\\n        int n = statements.length;\\n        max=0;\\n        generateAll(statements,new int[n],0,0);\\n        return max;\\n    }\\n\\n    private static void generateAll(int[][] statements,int arr[],int idx,int count){\\n        if(idx==arr.length){\\n            boolean res = check(statements,arr);\\n            if(res) max=Math.max(max,count);\\n            return;\\n        }\\n        generateAll(statements,arr,idx+1,count);\\n        arr[idx]=1;\\n        generateAll(statements,arr,idx+1,count+1);\\n        arr[idx]=0;\\n    }\\n\\n    static boolean check(int stat[][],int arr[]){\\n        for(int i=0;i<stat.length;i++){\\n            if(arr[i]==0) continue;\\n            for(int j=0;j<stat.length;j++){\\n                if(stat[i][j]==2) continue;\\n                if((stat[i][j]==1 && arr[j]==0) || (stat[i][j]==0 && arr[j]==1)){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034702,
                "title": "all-possible-combination-and-check-c",
                "content": "# Intuition\\nhere n<15 so if we generate all possible combination of 0 and 1 it will 2^15 which is less than 1e8,so we can generate all possible combination and when we reach to end we just need keep in mind \\n- if v[i]==1 when there should not be any contradicton between dp[j][i] and our final list.\\n\\n\\n# Complexity\\n- Time complexity:\\n- $$O(n*n*2^n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int maximumGood(vector<vector<int>>& statements) \\n    {\\n        vector<int>temp(statements.size(),0);\\n        f(statements,temp,0);\\n        return ans;\\n    }\\n    void f(vector<vector<int>>&statements,vector<int>&temp,int i)\\n    {\\n        if (i==statements.size())\\n        {\\n            ans=max(ans,check(statements,temp));\\n            return;\\n        }\\n        //bad\\n        temp[i]=0;\\n        f(statements,temp,i+1);\\n        //good\\n        temp[i]=1;\\n        f(statements,temp,i+1);\\n    }\\n    int check(vector<vector<int>>&statements,vector<int>&curr)\\n    {\\n        int count=0;\\n        for(int i=0;i<curr.size();i++)\\n        {\\n            if (curr[i]==1)\\n            {\\n                for(int j=0;j<curr.size();j++)\\n                {\\n                    if (statements[i][j]!=2 && curr[j]!=statements[i][j])\\n                    {\\n                        return 0;\\n                    }\\n                }\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int maximumGood(vector<vector<int>>& statements) \\n    {\\n        vector<int>temp(statements.size(),0);\\n        f(statements,temp,0);\\n        return ans;\\n    }\\n    void f(vector<vector<int>>&statements,vector<int>&temp,int i)\\n    {\\n        if (i==statements.size())\\n        {\\n            ans=max(ans,check(statements,temp));\\n            return;\\n        }\\n        //bad\\n        temp[i]=0;\\n        f(statements,temp,i+1);\\n        //good\\n        temp[i]=1;\\n        f(statements,temp,i+1);\\n    }\\n    int check(vector<vector<int>>&statements,vector<int>&curr)\\n    {\\n        int count=0;\\n        for(int i=0;i<curr.size();i++)\\n        {\\n            if (curr[i]==1)\\n            {\\n                for(int j=0;j<curr.size();j++)\\n                {\\n                    if (statements[i][j]!=2 && curr[j]!=statements[i][j])\\n                    {\\n                        return 0;\\n                    }\\n                }\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2970894,
                "title": "c-easy-backtracking-bitmask-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int res = 0;\\n    int n = 0;\\n\\n    int isGood(int mask, int i) {\\n        return mask & (1 << i);\\n    }\\n\\n    bool isValid(int s, vector<vector<int>> &statements){\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j < n; ++j) {\\n                    if(isGood(s, i)) {\\n                        if((statements[i][j] == 0 && isGood(s, j)) || (statements[i][j] == 1 && !isGood(s, j))) {\\n                            return false;\\n                        }\\n                    }\\n                }\\n        }\\n        return true;\\n    }\\n\\n    void dfs(vector<vector<int> > &statements, int &mask, int i, int goodPersonCount){\\n        if(i == n){\\n            int cpy = mask; \\n            if(isValid(cpy, statements)){\\n                // cout<<cpy<<\" \"<<goodPersonCount<<endl;\\n                res = max(res, goodPersonCount);\\n            }\\n            return;\\n        }\\n\\n        mask |= (1<<i);\\n        \\n        dfs(statements, mask, i+1, goodPersonCount + 1);\\n\\n        mask ^= (1<<i);\\n        dfs(statements, mask, i+1, goodPersonCount);\\n    }\\n\\n    int maximumGood(vector<vector<int>>& statements) {\\n        n = statements.size();\\n        int mask = 0;\\n        dfs(statements, mask, 0 , 0);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int res = 0;\\n    int n = 0;\\n\\n    int isGood(int mask, int i) {\\n        return mask & (1 << i);\\n    }\\n\\n    bool isValid(int s, vector<vector<int>> &statements){\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j < n; ++j) {\\n                    if(isGood(s, i)) {\\n                        if((statements[i][j] == 0 && isGood(s, j)) || (statements[i][j] == 1 && !isGood(s, j))) {\\n                            return false;\\n                        }\\n                    }\\n                }\\n        }\\n        return true;\\n    }\\n\\n    void dfs(vector<vector<int> > &statements, int &mask, int i, int goodPersonCount){\\n        if(i == n){\\n            int cpy = mask; \\n            if(isValid(cpy, statements)){\\n                // cout<<cpy<<\" \"<<goodPersonCount<<endl;\\n                res = max(res, goodPersonCount);\\n            }\\n            return;\\n        }\\n\\n        mask |= (1<<i);\\n        \\n        dfs(statements, mask, i+1, goodPersonCount + 1);\\n\\n        mask ^= (1<<i);\\n        dfs(statements, mask, i+1, goodPersonCount);\\n    }\\n\\n    int maximumGood(vector<vector<int>>& statements) {\\n        n = statements.size();\\n        int mask = 0;\\n        dfs(statements, mask, 0 , 0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2812381,
                "title": "python-solution-bitmasking-with-comments",
                "content": "```\\nclass Solution:\\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        \"\"\"\\n        0  \\u3000-> i says j is bad\\n        1    -> i says j is good\\n        \\n        Method: since N is small, we generate all possibilities using a bit mask (bit wise operations)\\n        ie. the possible good/bad combo array for n = 2 is \\n        0 0 \\n        0 1 \\n        1 0 \\n        1 1 \\n        \\n        This is equal to 1 << 2, and we use bit masking (&) to get value of specific bit. \\n        \\n        Then we check for inconsistencies\\n        \"\"\"\\n        N = len(statements)\\n        maxGood = 0\\n        \\n        def checkConsistency(maskVal) -> bool:\\n            # get good people in this iteration\\n            good = [] # index is person number, val is good/bad\\n            for p in range(N):\\n                if (1 << p & maskVal > 0): \\n                    good.append(True)\\n                else:\\n                    good.append(False)\\n            \\n            for r in range(N):\\n                for c in range(N):\\n                    # if person is bad, then don\\'t consider them\\n                    if not good[r]:\\n                        continue\\n                    \\n                    # good person makes false claims \\n                    if (statements[r][c] == 0 and\\n                        good[c]):\\n                        return False\\n                    if (statements[r][c] == 1 and \\n                       not good[c]):\\n                        return False\\n            return True\\n        \\n        # we start from 1 since all 0 is base case\\n        for i in range(1, 1 << N): \\n            # if set of combo is valid, we get count of good people\\n            if checkConsistency(i):\\n                count = 0\\n                for j in range(N):\\n                    # jth person is good\\n                    if (1 << j & i > 0): \\n                        count += 1\\n                    maxGood = max(maxGood, count)\\n        return maxGood\\n\\t",
                "solutionTags": [
                    "Python",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        \"\"\"\\n        0  \\u3000-> i says j is bad\\n        1    -> i says j is good\\n        \\n        Method: since N is small, we generate all possibilities using a bit mask (bit wise operations)\\n        ie. the possible good/bad combo array for n = 2 is \\n        0 0 \\n        0 1 \\n        1 0 \\n        1 1 \\n        \\n        This is equal to 1 << 2, and we use bit masking (&) to get value of specific bit. \\n        \\n        Then we check for inconsistencies\\n        \"\"\"\\n        N = len(statements)\\n        maxGood = 0\\n        \\n        def checkConsistency(maskVal) -> bool:\\n            # get good people in this iteration\\n            good = [] # index is person number, val is good/bad\\n            for p in range(N):\\n                if (1 << p & maskVal > 0): \\n                    good.append(True)\\n                else:\\n                    good.append(False)\\n            \\n            for r in range(N):\\n                for c in range(N):\\n                    # if person is bad, then don\\'t consider them\\n                    if not good[r]:\\n                        continue\\n                    \\n                    # good person makes false claims \\n                    if (statements[r][c] == 0 and\\n                        good[c]):\\n                        return False\\n                    if (statements[r][c] == 1 and \\n                       not good[c]):\\n                        return False\\n            return True\\n        \\n        # we start from 1 since all 0 is base case\\n        for i in range(1, 1 << N): \\n            # if set of combo is valid, we get count of good people\\n            if checkConsistency(i):\\n                count = 0\\n                for j in range(N):\\n                    # jth person is good\\n                    if (1 << j & i > 0): \\n                        count += 1\\n                    maxGood = max(maxGood, count)\\n        return maxGood\\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 2736528,
                "title": "binary-search-to-prune-faster-python",
                "content": "n <= 15, so brute force is possible. But I thought you could use binary search on the size of goodPeople to make things faster. \\n\\nCan someone please disprove/prove this method?\\nI have doubts about my contradicts function\\n```\\ndef maximumGood(self, statements: List[List[int]]) -> int:\\n    n = len(statements)\\n\\n    def contradicts(goodPeople):\\n        goodPeople = set(goodPeople)\\n        couldBeGood = set(goodPeople)\\n\\n        for i in goodPeople:\\n            for j in range(n):\\n                if statements[i][j] == 0 and j in goodPeople:\\n                    return True\\n                if statements[i][j] == 1 and j not in goodPeople:\\n                    couldBeGood.add(j)\\n        \\n        for i in couldBeGood:\\n            for j in range(n):\\n                if statements[i][j] == 0 and j in couldBeGood:\\n                    return True\\n                if statements[i][j] == 1 and j not in couldBeGood:\\n                    return True\\n        \\n        M = len(couldBeGood)\\n        return False\\n    \\n    def isValid(size):\\n        for goodPeople in combinations(range(n), size):\\n            if not contradicts(goodPeople):\\n                return True\\n        \\n        return False \\n    \\n    L = 0; R = n\\n    while L < R:\\n        M = (L+R+1)//2\\n        if not isValid(M):\\n            R = M-1\\n        else:\\n            L = M\\n    \\n    return L\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\ndef maximumGood(self, statements: List[List[int]]) -> int:\\n    n = len(statements)\\n\\n    def contradicts(goodPeople):\\n        goodPeople = set(goodPeople)\\n        couldBeGood = set(goodPeople)\\n\\n        for i in goodPeople:\\n            for j in range(n):\\n                if statements[i][j] == 0 and j in goodPeople:\\n                    return True\\n                if statements[i][j] == 1 and j not in goodPeople:\\n                    couldBeGood.add(j)\\n        \\n        for i in couldBeGood:\\n            for j in range(n):\\n                if statements[i][j] == 0 and j in couldBeGood:\\n                    return True\\n                if statements[i][j] == 1 and j not in couldBeGood:\\n                    return True\\n        \\n        M = len(couldBeGood)\\n        return False\\n    \\n    def isValid(size):\\n        for goodPeople in combinations(range(n), size):\\n            if not contradicts(goodPeople):\\n                return True\\n        \\n        return False \\n    \\n    L = 0; R = n\\n    while L < R:\\n        M = (L+R+1)//2\\n        if not isValid(M):\\n            R = M-1\\n        else:\\n            L = M\\n    \\n    return L\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2706944,
                "title": "python3-checking-all-combinations-one-by-one-against-all-statements-for-consistency",
                "content": "class Solution:\\n\\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        n=len(statements)\\n        maxCount=0\\n        combos=1<<n\\n        \\n        \\n        for i in range(1,combos):\\n            role=[0]*n\\n            count=0\\n            for j in range(n):\\n                role[j]=i&1\\n                count+=role[j]\\n                i=i>>1\\n            flag = True\\n            for j in range(n):\\n                if role[j]==0:\\n                    continue\\n                for k in range(n):\\n                    if statements[j][k]==2:\\n                        continue\\n                    if statements[j][k]!=role[k]:\\n                        flag = False\\n                        break\\n                if not flag:\\n                    break\\n            if flag:\\n                maxCount = max(maxCount,count)\\n            \\n        return maxCount",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        n=len(statements)\\n        maxCount=0\\n        combos=1<<n\\n        \\n        \\n        for i in range(1,combos):\\n            role=[0]*n\\n            count=0\\n            for j in range(n):\\n                role[j]=i&1\\n                count+=role[j]\\n                i=i>>1\\n            flag = True\\n            for j in range(n):\\n                if role[j]==0:\\n                    continue\\n                for k in range(n):\\n                    if statements[j][k]==2:\\n                        continue\\n                    if statements[j][k]!=role[k]:\\n                        flag = False\\n                        break\\n                if not flag:\\n                    break\\n            if flag:\\n                maxCount = max(maxCount,count)\\n            \\n        return maxCount",
                "codeTag": "Java"
            },
            {
                "id": 2704053,
                "title": "c-simple-dfs-backtracking-with-explanation-and-code-comments",
                "content": "Use Backtracking to find all possible combinations, then verify if this combination is correct. \\n```\\nclass Solution {\\nprivate: \\n    int max_count = 0;\\n    int n;\\npublic:\\n    // use dfs to find all possible combinations since n <= 15; \\n    int maximumGood(vector<vector<int>>& statements) {\\n        n = statements.size(); // make is global to save typing\\n        vector<int> curr; // this is the current people prediction\\n        dfs(statements, curr, 0);\\n        return max_count;\\n    }\\n \\n    void dfs(vector<vector<int>>& statements, vector<int>& curr, int count){\\n        if(curr.size() == n){\\n            // we have predications for all people\\n            if(isValid(curr, statements)){\\n                max_count = max(max_count, count);\\n            }\\n            return;\\n        }\\n        // people i is bad\\n        curr.push_back(0);\\n        dfs(statements, curr, count);\\n        curr.pop_back();\\n        // people i is good\\n        curr.push_back(1);\\n        dfs(statements, curr, count + 1);\\n        curr.pop_back();\\n    }\\n    // go for all statements and check if it satisfies our prediction\\n    bool isValid(vector<int>& curr, vector<vector<int>>& statements){\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                if(i == j) continue;\\n                // if I predict i is correct, then everything he says should be correct\\n                if(curr[i] == 1){\\n                    if(statements[i][j] != 2 && statements[i][j] != curr[j]) return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate: \\n    int max_count = 0;\\n    int n;\\npublic:\\n    // use dfs to find all possible combinations since n <= 15; \\n    int maximumGood(vector<vector<int>>& statements) {\\n        n = statements.size(); // make is global to save typing\\n        vector<int> curr; // this is the current people prediction\\n        dfs(statements, curr, 0);\\n        return max_count;\\n    }\\n \\n    void dfs(vector<vector<int>>& statements, vector<int>& curr, int count){\\n        if(curr.size() == n){\\n            // we have predications for all people\\n            if(isValid(curr, statements)){\\n                max_count = max(max_count, count);\\n            }\\n            return;\\n        }\\n        // people i is bad\\n        curr.push_back(0);\\n        dfs(statements, curr, count);\\n        curr.pop_back();\\n        // people i is good\\n        curr.push_back(1);\\n        dfs(statements, curr, count + 1);\\n        curr.pop_back();\\n    }\\n    // go for all statements and check if it satisfies our prediction\\n    bool isValid(vector<int>& curr, vector<vector<int>>& statements){\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                if(i == j) continue;\\n                // if I predict i is correct, then everything he says should be correct\\n                if(curr[i] == 1){\\n                    if(statements[i][j] != 2 && statements[i][j] != curr[j]) return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2662251,
                "title": "c-fast-simple-pruned-brute-dfs",
                "content": "Link to the submission stats:\\nhttps://leetcode.com/submissions/detail/815464891/\\n\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int ans=0;\\n    vector<int> f,g,b;\\n    \\n    void solve(int k,vector<vector<int>> &ar,int val){\\n        if(k==n){\\n            ans=max(ans,val);\\n            return;\\n        }\\n        bool ok=1;\\n        for(int i=0;i<n;i++){\\n            if(ar[k][i]==2){continue;}\\n            if(ar[k][i]==1){\\n                if(i<k && !f[i]){ok=0;}\\n                if(b[i]){ok=0;}\\n            }\\n            if(ar[k][i]==0){\\n                if(g[i] || f[i]){ok=0;}\\n            }\\n        }\\n        if(g[k] && !ok){return;}\\n        if(ok && !b[k]){\\n            for(int i=0;i<n;i++){\\n                if(ar[k][i]==2){continue;}\\n                if(ar[k][i]==1){g[i]++;}\\n                else{b[i]++;}\\n            }\\n            f[k]++;\\n            solve(k+1,ar,val+1);\\n            f[k]--;\\n            for(int i=0;i<n;i++){\\n                if(ar[k][i]==2){continue;}\\n                if(ar[k][i]==1){g[i]--;}\\n                else{b[i]--;}\\n            }\\n        }\\n        if(!g[k]){solve(k+1,ar,val);}\\n    } \\n    \\n    int maximumGood(vector<vector<int>>& ar) {\\n        n=ar.size();\\n        f.resize(n);\\n        fill(f.begin(),f.end(),0);\\n        g=f;b=f;\\n        solve(0,ar,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int ans=0;\\n    vector<int> f,g,b;\\n    \\n    void solve(int k,vector<vector<int>> &ar,int val){\\n        if(k==n){\\n            ans=max(ans,val);\\n            return;\\n        }\\n        bool ok=1;\\n        for(int i=0;i<n;i++){\\n            if(ar[k][i]==2){continue;}\\n            if(ar[k][i]==1){\\n                if(i<k && !f[i]){ok=0;}\\n                if(b[i]){ok=0;}\\n            }\\n            if(ar[k][i]==0){\\n                if(g[i] || f[i]){ok=0;}\\n            }\\n        }\\n        if(g[k] && !ok){return;}\\n        if(ok && !b[k]){\\n            for(int i=0;i<n;i++){\\n                if(ar[k][i]==2){continue;}\\n                if(ar[k][i]==1){g[i]++;}\\n                else{b[i]++;}\\n            }\\n            f[k]++;\\n            solve(k+1,ar,val+1);\\n            f[k]--;\\n            for(int i=0;i<n;i++){\\n                if(ar[k][i]==2){continue;}\\n                if(ar[k][i]==1){g[i]--;}\\n                else{b[i]--;}\\n            }\\n        }\\n        if(!g[k]){solve(k+1,ar,val);}\\n    } \\n    \\n    int maximumGood(vector<vector<int>>& ar) {\\n        n=ar.size();\\n        f.resize(n);\\n        fill(f.begin(),f.end(),0);\\n        g=f;b=f;\\n        solve(0,ar,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2615023,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def maximumGood(self, x: List[List[int]]) -> int:\\n        \\n        n=len(x)\\n        y=[2 for i in range(n)]\\n        ans=0\\n        for i in range(2**n):\\n            flag=True\\n            for j in range(n):\\n                if (i>>j)&1:\\n                    y[j]=1\\n                else:\\n                    y[j]=0\\n            for j in range(n):\\n                if (i>>j)&1:\\n                    for k in range(n):\\n                        if x[j][k]==2:continue\\n                        if x[j][k]!=y[k]:\\n                            flag=False\\n                            break\\n                    if not flag:break\\n            if flag:\\n                ans=max(ans,sum(y))\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumGood(self, x: List[List[int]]) -> int:\\n        \\n        n=len(x)\\n        y=[2 for i in range(n)]\\n        ans=0\\n        for i in range(2**n):\\n            flag=True\\n            for j in range(n):\\n                if (i>>j)&1:\\n                    y[j]=1\\n                else:\\n                    y[j]=0\\n            for j in range(n):\\n                if (i>>j)&1:\\n                    for k in range(n):\\n                        if x[j][k]==2:continue\\n                        if x[j][k]!=y[k]:\\n                            flag=False\\n                            break\\n                    if not flag:break\\n            if flag:\\n                ans=max(ans,sum(y))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2600249,
                "title": "c-o-n-2-2-n-bitmask-with-slight-pruning",
                "content": "formed an `adjList` for small pruning (to make sure the complexity does not go to `n^2` for every mask, like when there are no opinions about anybody).\\n```\\nclass Solution {\\n    \\n    bool isValid(int &mask, vector<vector<pair<int,int>>>&adj){\\n        int n=adj.size();\\n        for(int i=0; i<n; i++){\\n            if(mask&(1<<i)) continue; //bad person\\n            for(auto &[j, thought] : adj[i]){\\n                if(thought==0){\\n                    if(!(mask&(1<<j))) \\n                        return false;\\n                }\\n                else if(thought==1){\\n                    if(mask&(1<<j))\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    int unsetBits(int& mask, int &n){\\n        int ans=0;\\n        for(int i=0; i<n; i++)\\n            if(!(mask&(1<<i)))\\n                ans++;\\n        return ans;\\n    }\\npublic:\\n    int maximumGood(vector<vector<int>>& a) {\\n        int n=a.size();\\n        int maxMask = 1<<n;\\n        int ans=0;\\n        vector<vector<pair<int,int>>>adj(n);\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(a[i][j]!=2)\\n                    adj[i].push_back({j, a[i][j]});\\n            }\\n        }\\n        for(int mask=0; mask<maxMask; mask++){\\n            if(isValid(mask, adj))\\n                ans=max(ans, unsetBits(mask, n));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    \\n    bool isValid(int &mask, vector<vector<pair<int,int>>>&adj){\\n        int n=adj.size();\\n        for(int i=0; i<n; i++){\\n            if(mask&(1<<i)) continue; //bad person\\n            for(auto &[j, thought] : adj[i]){\\n                if(thought==0){\\n                    if(!(mask&(1<<j))) \\n                        return false;\\n                }\\n                else if(thought==1){\\n                    if(mask&(1<<j))\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    int unsetBits(int& mask, int &n){\\n        int ans=0;\\n        for(int i=0; i<n; i++)\\n            if(!(mask&(1<<i)))\\n                ans++;\\n        return ans;\\n    }\\npublic:\\n    int maximumGood(vector<vector<int>>& a) {\\n        int n=a.size();\\n        int maxMask = 1<<n;\\n        int ans=0;\\n        vector<vector<pair<int,int>>>adj(n);\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(a[i][j]!=2)\\n                    adj[i].push_back({j, a[i][j]});\\n            }\\n        }\\n        for(int mask=0; mask<maxMask; mask++){\\n            if(isValid(mask, adj))\\n                ans=max(ans, unsetBits(mask, n));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2576887,
                "title": "c-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int  fun(int i,vector<vector<int>>&s,vector<int>&v)\\n    {\\n        if(i==s.size())\\n        {\\n            for(int j=0;j<s.size();j++)\\n            {  \\n                if(v[j]==1)\\n                {\\n                  for(int k=0;k<s.size();k++)\\n                  {\\n                     if(s[k][j]==0 && v[k]==1)\\n                         return -100000;        \\n                  }\\n                }\\n                else\\n                {\\n                    for(int k=0;k<s.size();k++)\\n                  {\\n                      if(s[k][j]==1 && v[k]==1)\\n                         return -100000;\\n                  } \\n                    \\n                }\\n            }\\n            return 0;\\n        }\\n        \\n       v.push_back(1);\\n     int take= 1+ fun(i+1,s,v);\\n        v.pop_back();\\n        \\n        v.push_back(0);\\n      int nottake= fun(i+1,s,v);\\n        v.pop_back();\\n        \\n     return max(take , nottake);\\n        \\n    }\\n    int maximumGood(vector<vector<int>>& statements) {\\n        \\n        vector<int>v;\\n       return  fun(0,statements,v);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int  fun(int i,vector<vector<int>>&s,vector<int>&v)\\n    {\\n        if(i==s.size())\\n        {\\n            for(int j=0;j<s.size();j++)\\n            {  \\n                if(v[j]==1)\\n                {\\n                  for(int k=0;k<s.size();k++)\\n                  {\\n                     if(s[k][j]==0 && v[k]==1)\\n                         return -100000;        \\n                  }\\n                }\\n                else\\n                {\\n                    for(int k=0;k<s.size();k++)\\n                  {\\n                      if(s[k][j]==1 && v[k]==1)\\n                         return -100000;\\n                  } \\n                    \\n                }\\n            }\\n            return 0;\\n        }\\n        \\n       v.push_back(1);\\n     int take= 1+ fun(i+1,s,v);\\n        v.pop_back();\\n        \\n        v.push_back(0);\\n      int nottake= fun(i+1,s,v);\\n        v.pop_back();\\n        \\n     return max(take , nottake);\\n        \\n    }\\n    int maximumGood(vector<vector<int>>& statements) {\\n        \\n        vector<int>v;\\n       return  fun(0,statements,v);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2538076,
                "title": "simple-short-clean-code",
                "content": "```\\nclass Solution {\\n    typedef long long ll;\\npublic:\\n    int maximumGood(vector<vector<int>>& v) {\\n        ll n = v.size(), ans = 0;\\n        for (ll bm = 0;bm < (1 << n);++bm) { // all possible combinations\\n            bool take = true;\\n            for (ll i = 0;i < n;++i) {\\n                if (!((bm >> i) & 1)) { // ith person is a liar, why listen to him/her?\\n                    continue;\\n                }\\n                for (ll j = 0;j < n;++j) {\\n                    if (v[i][j] != 2 && v[i][j] != ((bm >> j) & 1)) { // ith person\\'s statement about the jth person is contradictory\\n                        take = false;\\n                        break;\\n                    }\\n                }\\n                if (!take) {\\n                    break;\\n                }\\n            }\\n            if (take) {\\n                ans = max(ans, ll(__builtin_popcount(bm))); // num of set bits\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Iterator",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    typedef long long ll;\\npublic:\\n    int maximumGood(vector<vector<int>>& v) {\\n        ll n = v.size(), ans = 0;\\n        for (ll bm = 0;bm < (1 << n);++bm) { // all possible combinations\\n            bool take = true;\\n            for (ll i = 0;i < n;++i) {\\n                if (!((bm >> i) & 1)) { // ith person is a liar, why listen to him/her?\\n                    continue;\\n                }\\n                for (ll j = 0;j < n;++j) {\\n                    if (v[i][j] != 2 && v[i][j] != ((bm >> j) & 1)) { // ith person\\'s statement about the jth person is contradictory\\n                        take = false;\\n                        break;\\n                    }\\n                }\\n                if (!take) {\\n                    break;\\n                }\\n            }\\n            if (take) {\\n                ans = max(ans, ll(__builtin_popcount(bm))); // num of set bits\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2523645,
                "title": "c-easy-bit-mask-brute-force-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int check(vector<vector<int>>& st,int arragment,int n){\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            if((arragment & (1<<i))!=0){// true person in arragement\\n                count++;//increasing set bits or number of person telling truth \\n                for(int j=0;j<n;j++){\\n                    int mask=1<<j; \\n                    //if arragement says person is true and statemtn says no then return 0 || \\n                    //if arragement says person is false/lier and statment says person is true then also reutrn 0\\n                  if(((arragment & mask)!=0 && st[i][j]==0) || ((arragment & mask)==0 && st[i][j]==1))\\n                      return 0;\\n                    \\n                }\\n\\n            }\\n        }\\n\\t\\t//if all arragemnt is true according to statments in the matrix, the the answer is the number of \\n\\t\\t//set bits, in other words number of one\\'s are the number of persons telling the truth\\n        return count;\\n    }\\n    \\n    int maximumGood(vector<vector<int>>& st) {\\n        int n=st.size();\\n        int ans=0;\\n        for(int arragment=0;arragment<(1<<n);arragment++){\\n            ans=max(ans,check(st,arragment,n));\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int check(vector<vector<int>>& st,int arragment,int n){\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            if((arragment & (1<<i))!=0){// true person in arragement\\n                count++;//increasing set bits or number of person telling truth \\n                for(int j=0;j<n;j++){\\n                    int mask=1<<j; \\n                    //if arragement says person is true and statemtn says no then return 0 || \\n                    //if arragement says person is false/lier and statment says person is true then also reutrn 0\\n                  if(((arragment & mask)!=0 && st[i][j]==0) || ((arragment & mask)==0 && st[i][j]==1))\\n                      return 0;\\n                    \\n                }\\n\\n            }\\n        }\\n\\t\\t//if all arragemnt is true according to statments in the matrix, the the answer is the number of \\n\\t\\t//set bits, in other words number of one\\'s are the number of persons telling the truth\\n        return count;\\n    }\\n    \\n    int maximumGood(vector<vector<int>>& st) {\\n        int n=st.size();\\n        int ans=0;\\n        for(int arragment=0;arragment<(1<<n);arragment++){\\n            ans=max(ans,check(st,arragment,n));\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2516953,
                "title": "simple-bitmask-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumGood(vector<vector<int>>& st) {\\n        \\n        int n=st.size();\\n        int ans=0;\\n        \\n        for(int i=1;i<(1<<n);i++)\\n        { int flag=1;\\n            \\n            for(int j=0;j<n;j++)\\n            {\\n                if( i & (1<<j) )\\n                {\\n                    for(int k=0;k<n;k++)\\n                    {\\n                        if( i&(1<<k)  && st[j][k]==0){\\n                            flag=0;break;\\n                        }\\n                        if( !(i&(1<<k))  && st[j][k]==1){\\n                            flag=0;break;\\n                        }\\n                        \\n                    }\\n                    \\n                }\\n                \\n                if(!flag) break;\\n            }\\n            \\n            if(flag)\\n            {\\n                ans=max(ans,__builtin_popcount(i));\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGood(vector<vector<int>>& st) {\\n        \\n        int n=st.size();\\n        int ans=0;\\n        \\n        for(int i=1;i<(1<<n);i++)\\n        { int flag=1;\\n            \\n            for(int j=0;j<n;j++)\\n            {\\n                if( i & (1<<j) )\\n                {\\n                    for(int k=0;k<n;k++)\\n                    {\\n                        if( i&(1<<k)  && st[j][k]==0){\\n                            flag=0;break;\\n                        }\\n                        if( !(i&(1<<k))  && st[j][k]==1){\\n                            flag=0;break;\\n                        }\\n                        \\n                    }\\n                    \\n                }\\n                \\n                if(!flag) break;\\n            }\\n            \\n            if(flag)\\n            {\\n                ans=max(ans,__builtin_popcount(i));\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2516762,
                "title": "c-bitmasking-simple-solution-with-explanation",
                "content": "### Solution using bitmask enumeration\\n\\nTime Complexity: `O(2^N * N^2)`\\nSpace Complexity: `O(1)`\\n\\n```\\n/***\\n* Time Complexity: O(2^N * N^2)\\n* Space Complexity: O(1)\\n*/\\n\\nclass Solution {\\nprivate:\\n    bool validate(int submask , vector<vector<int>>& arr , int N){\\n        for(int i = 0;i<N;i++){\\n            if(!(submask & (1<<i))) continue; // We want the opinion of good people only.\\n            \\n            for(int j = 0;j<N;j++){\\n                //If they have no opinion for the jth person we skip\\n                if(arr[i][j] == 2) continue;\\n                \\n                //If i claims j is evil but we have assumed j is good. Then there is contradiction. So it is wrong\\n                if(arr[i][j] == 0 and (submask & (1<<j)))\\n                        return false;\\n\\n                //If i claims j is good but we have assumed j is evil. Then there is contradiction. So it is wrong\\n                if(arr[i][j] == 1 and !(submask & (1<<j))) \\n                       return false;    \\n            }\\n        }\\n        \\n        //There is no contradiction. \\n        return true;\\n        \\n    }\\npublic:\\n    int maximumGood(vector<vector<int>>& statements) {\\n        const int N = statements.size();\\n        //It generates a number 111...11 (N bits)\\n        //Here 1 = Good person\\n        // And 0=  Bad person\\n        const int mask = (1<<N) - 1;\\n        \\n        int ans = 0;\\n        \\n        //We will try every combination of the bits\\n        for(int submask = mask;submask;submask = (submask-1)&mask){\\n            if(validate(submask,statements,N)){\\n                //This function calculates the number of set bits\\n                ans = max(__builtin_popcount(submask),ans);\\n               \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\n/***\\n* Time Complexity: O(2^N * N^2)\\n* Space Complexity: O(1)\\n*/\\n\\nclass Solution {\\nprivate:\\n    bool validate(int submask , vector<vector<int>>& arr , int N){\\n        for(int i = 0;i<N;i++){\\n            if(!(submask & (1<<i))) continue; // We want the opinion of good people only.\\n            \\n            for(int j = 0;j<N;j++){\\n                //If they have no opinion for the jth person we skip\\n                if(arr[i][j] == 2) continue;\\n                \\n                //If i claims j is evil but we have assumed j is good. Then there is contradiction. So it is wrong\\n                if(arr[i][j] == 0 and (submask & (1<<j)))\\n                        return false;\\n\\n                //If i claims j is good but we have assumed j is evil. Then there is contradiction. So it is wrong\\n                if(arr[i][j] == 1 and !(submask & (1<<j))) \\n                       return false;    \\n            }\\n        }\\n        \\n        //There is no contradiction. \\n        return true;\\n        \\n    }\\npublic:\\n    int maximumGood(vector<vector<int>>& statements) {\\n        const int N = statements.size();\\n        //It generates a number 111...11 (N bits)\\n        //Here 1 = Good person\\n        // And 0=  Bad person\\n        const int mask = (1<<N) - 1;\\n        \\n        int ans = 0;\\n        \\n        //We will try every combination of the bits\\n        for(int submask = mask;submask;submask = (submask-1)&mask){\\n            if(validate(submask,statements,N)){\\n                //This function calculates the number of set bits\\n                ans = max(__builtin_popcount(submask),ans);\\n               \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2399298,
                "title": "java-o-n-2-n-better-than-n-2-2-n",
                "content": "We can ignore the bad people because they can either lie or don\\'t lie, there is nothing of value we can learn from them.\\nSo we can bruteforce this by assiging a subset of people with the good status, and check for contradiction.\\n\\nHere I am using bitmask where `0b001` means the 1st person is good, and the 2nd and 3rd people are bad.\\nI am also preprocessing the statements data such that we can do O(1) lookup for each person.\\n`state[i][j]` represents the statements made by person `i` and `j=0 -> bad, j=1 -> good, j=2 -> no opnion`, with the value inside being the people mask much like the above.\\n\\n`good & bad` checks for the contradiction - a person can\\'t be both bad and good at the same time. This AND operation must return 0.\\n\\n### Java\\n```Java\\n// Time O(n * 2^n)\\n// Space O(n)\\nclass Solution {\\n    public int maximumGood(int[][] statements) {\\n        int n = statements.length, ans = 0;\\n        int[][] state = new int[n][3];\\n        for (int i = 0; i < n; i++){\\n            for (int j = 0; j < n; j++){ // preprocess the mask\\n                state[i][statements[i][j]]|=1<<j;\\n            }\\n        }\\n        for (int i = 1 ; i < 1<<n; i++){\\n            int good = i, bad = (1<<n)-1-i;\\n            for (int j = 0; j < n; j++){\\n                if ((i&1<<j)>0){\\n                    bad |=state[j][0];\\n                    good|=state[j][1];\\n                }\\n            }\\n            if ((bad & good)==0){ // check for contradiction\\n                ans = Math.max(ans, Integer.bitCount(i));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n#### Optimization\\nWe don\\'t have to check for the contradiction at the end of the loop, we can check it within the inner loop.\\nThis improves the runtime by about 4 times.\\n```Java\\nclass Solution {\\n    public int maximumGood(int[][] statements) {\\n        int n = statements.length, ans = 0;\\n        int[][] state = new int[n][3];\\n        for (int i = 0; i < n; i++){\\n            for (int j = 0; j < n; j++){\\n                state[i][statements[i][j]]|=1<<j;\\n            }\\n        }\\n        for (int i = 1 ; i < 1<<n; i++){\\n            int good = i, bad = (1<<n)-1-i;\\n            boolean ok = true;\\n            for (int j = 0; j < n && ok; j++){\\n                if ((i&1<<j)>0){\\n                    ok &= (bad | state[j][0]) == bad;\\n                    ok &= (good| state[j][1]) == good;\\n                }\\n            }\\n            if (ok){\\n                ans = Math.max(ans, Integer.bitCount(i));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```Java\\n// Time O(n * 2^n)\\n// Space O(n)\\nclass Solution {\\n    public int maximumGood(int[][] statements) {\\n        int n = statements.length, ans = 0;\\n        int[][] state = new int[n][3];\\n        for (int i = 0; i < n; i++){\\n            for (int j = 0; j < n; j++){ // preprocess the mask\\n                state[i][statements[i][j]]|=1<<j;\\n            }\\n        }\\n        for (int i = 1 ; i < 1<<n; i++){\\n            int good = i, bad = (1<<n)-1-i;\\n            for (int j = 0; j < n; j++){\\n                if ((i&1<<j)>0){\\n                    bad |=state[j][0];\\n                    good|=state[j][1];\\n                }\\n            }\\n            if ((bad & good)==0){ // check for contradiction\\n                ans = Math.max(ans, Integer.bitCount(i));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```Java\\nclass Solution {\\n    public int maximumGood(int[][] statements) {\\n        int n = statements.length, ans = 0;\\n        int[][] state = new int[n][3];\\n        for (int i = 0; i < n; i++){\\n            for (int j = 0; j < n; j++){\\n                state[i][statements[i][j]]|=1<<j;\\n            }\\n        }\\n        for (int i = 1 ; i < 1<<n; i++){\\n            int good = i, bad = (1<<n)-1-i;\\n            boolean ok = true;\\n            for (int j = 0; j < n && ok; j++){\\n                if ((i&1<<j)>0){\\n                    ok &= (bad | state[j][0]) == bad;\\n                    ok &= (good| state[j][1]) == good;\\n                }\\n            }\\n            if (ok){\\n                ans = Math.max(ans, Integer.bitCount(i));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2346545,
                "title": "python-6-liners-easy-approach",
                "content": "Try all combinations of good people.\\nFor each people in the combination `A`, if a good person is told by him not in `A` or there\\'s a person in `A` is bad as he stated then then this combination is invalid (for the facts that all the good person must be in `A` and no bad person is in `A` while we assumning that each in `A` is good person which always tell the truth)\\nWe can simplify this using bit mask as `statements[i][j] ^ 1 != j not in A` for every `i` in `A`.\\n\\n```python\\ndef maximumGood(self, statements: List[List[int]]) -> int:\\n      res, n = 0, len(statements) \\n      for i in range(1,1<<n):\\n        pool = {j for j in range(n) if (i>>j)&1}\\n        if all(statements[j][i] ^ 1 != (i in pool) for j in pool for i in range(n) ):\\n          res = max(res, len(pool))\\n      return res\\n```",
                "solutionTags": [],
                "code": "```python\\ndef maximumGood(self, statements: List[List[int]]) -> int:\\n      res, n = 0, len(statements) \\n      for i in range(1,1<<n):\\n        pool = {j for j in range(n) if (i>>j)&1}\\n        if all(statements[j][i] ^ 1 != (i in pool) for j in pool for i in range(n) ):\\n          res = max(res, len(pool))\\n      return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2342466,
                "title": "python-backtrack-solution",
                "content": "```\\ndef maximumGood(self, sts: List[List[int]]) -> int:\\n\\tn = len(sts)\\n\\tself.ans = 0\\n\\n\\tdef valid(s):\\n\\t\\tfor i in range(n):\\n\\t\\t\\tif s[i]==\\'0\\':\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tfor j in range(n):\\n\\t\\t\\t\\tif sts[i][j]!=2 and sts[i][j]!=int(s[j]):\\n\\t\\t\\t\\t\\treturn False\\n\\t\\treturn True\\n\\n\\tdef btrack(s):\\n\\t\\tif len(s)==n:\\n\\t\\t\\tif valid(s):\\n\\t\\t\\t\\tself.ans = max(self.ans, s.count(\\'1\\'))\\n\\t\\t\\treturn\\n\\t\\telse:\\n\\t\\t\\tbtrack(s+\\'1\\')            \\n\\t\\t\\tbtrack(s+\\'0\\')\\n\\n\\tbtrack(\\'\\')\\n\\n\\treturn self.ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef maximumGood(self, sts: List[List[int]]) -> int:\\n\\tn = len(sts)\\n\\tself.ans = 0\\n\\n\\tdef valid(s):\\n\\t\\tfor i in range(n):\\n\\t\\t\\tif s[i]==\\'0\\':\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tfor j in range(n):\\n\\t\\t\\t\\tif sts[i][j]!=2 and sts[i][j]!=int(s[j]):\\n\\t\\t\\t\\t\\treturn False\\n\\t\\treturn True\\n\\n\\tdef btrack(s):\\n\\t\\tif len(s)==n:\\n\\t\\t\\tif valid(s):\\n\\t\\t\\t\\tself.ans = max(self.ans, s.count(\\'1\\'))\\n\\t\\t\\treturn\\n\\t\\telse:\\n\\t\\t\\tbtrack(s+\\'1\\')            \\n\\t\\t\\tbtrack(s+\\'0\\')\\n\\n\\tbtrack(\\'\\')\\n\\n\\treturn self.ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2300126,
                "title": "c-solution-by-brute-force-and-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumGood(vector<vector<int>>& statements) {\\n        \\n        int n = statements.size();\\n        queue<pair<int, string>> units; units.push({0, string(n, \\'*\\')});\\n        int p = 0;\\n        while(p < n){\\n            int round_size = units.size();\\n            for (int i = 0; i < round_size; i++){\\n                auto unit = units.front();    units.pop();\\n                unit.second[p] = \\'0\\';\\n                units.push(unit);\\n                unit.second[p] = \\'1\\';\\n                units.push({unit.first + 1, unit.second});\\n                unit.second[p] = \\'*\\';\\n            }\\n            p++;\\n        }\\n        int max_person = 0;\\n        // printf(\"units.size=%d\\\\n\", units.size());\\n        vector<vector<string>> perms(n + 1);\\n        while(!units.empty()){\\n            auto unit = units.front(); units.pop();\\n            perms[unit.first].push_back(unit.second);\\n        }\\n        for (int p = n; p >= 1; p--){\\n            for (string state: perms[p]){\\n                bool match = true;\\n                for (int i = 0; i < n; i++){\\n                    for (int j = 0; j < n; j++){\\n                        // check whether unit.first[i] and unit.first[j] matches statement[i][j]\\n                        if (!match_with_statements(statements, i, j, state)){\\n                            match = false;\\n                            i = n;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if (match){\\n                    return p;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n    bool match_with_statements(vector<vector<int>>& statements, int i, int j, string& unit){\\n        \\n        if (statements[i][j] == 2){\\n            return true;\\n        }\\n        \\n        if (unit[i] == \\'1\\' && unit[j] == \\'1\\'){\\n            if (statements[i][j] == 1){\\n                return true;\\n            }\\n            return false;\\n        }\\n        else if (unit[i] == \\'1\\' && unit[j] == \\'0\\'){\\n            if (statements[i][j] == 0){\\n                return true;\\n            }\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGood(vector<vector<int>>& statements) {\\n        \\n        int n = statements.size();\\n        queue<pair<int, string>> units; units.push({0, string(n, \\'*\\')});\\n        int p = 0;\\n        while(p < n){\\n            int round_size = units.size();\\n            for (int i = 0; i < round_size; i++){\\n                auto unit = units.front();    units.pop();\\n                unit.second[p] = \\'0\\';\\n                units.push(unit);\\n                unit.second[p] = \\'1\\';\\n                units.push({unit.first + 1, unit.second});\\n                unit.second[p] = \\'*\\';\\n            }\\n            p++;\\n        }\\n        int max_person = 0;\\n        // printf(\"units.size=%d\\\\n\", units.size());\\n        vector<vector<string>> perms(n + 1);\\n        while(!units.empty()){\\n            auto unit = units.front(); units.pop();\\n            perms[unit.first].push_back(unit.second);\\n        }\\n        for (int p = n; p >= 1; p--){\\n            for (string state: perms[p]){\\n                bool match = true;\\n                for (int i = 0; i < n; i++){\\n                    for (int j = 0; j < n; j++){\\n                        // check whether unit.first[i] and unit.first[j] matches statement[i][j]\\n                        if (!match_with_statements(statements, i, j, state)){\\n                            match = false;\\n                            i = n;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if (match){\\n                    return p;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n    bool match_with_statements(vector<vector<int>>& statements, int i, int j, string& unit){\\n        \\n        if (statements[i][j] == 2){\\n            return true;\\n        }\\n        \\n        if (unit[i] == \\'1\\' && unit[j] == \\'1\\'){\\n            if (statements[i][j] == 1){\\n                return true;\\n            }\\n            return false;\\n        }\\n        else if (unit[i] == \\'1\\' && unit[j] == \\'0\\'){\\n            if (statements[i][j] == 0){\\n                return true;\\n            }\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2286330,
                "title": "fast-concise-python-bitmask-time-n-2-2-n-memory-2-n",
                "content": "N is small enough to exhaust. For larger N, you could square root the memory by pre-computing a separate list for each half of the elements, then exhaustively try all pairs. Here is the short and sweet code for the simple exhaust.\\n\\n```\\nclass Solution:\\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        S=statements\\n        n=len(S)\\n        pop=(1<<n)*[0]\\n        f0=(1<<n)*[0]\\n        f1=(1<<n)*[0]\\n        for i in range(n):\\n            k=1<<i\\n            pop[k]=1\\n            x0=f0[k]=sum(1<<j for j in range(n) if S[i][j]==0) # people who are Forced to be bad if person i is truthful\\n            x1=f1[k]=sum(1<<j for j in range(n) if S[i][j]==1) # people who are Forced to be good if person i is truthful\\n            for j in range(1,k):\\n                k+=1\\n                pop[k]=pop[j]+1\\n                f0[k]=f0[j]|x0\\n                f1[k]=f1[j]|x1\\n        return max(pop[i] for i in range(1<<n) if i&f0[i]==0 and i|f1[i]==i)\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        S=statements\\n        n=len(S)\\n        pop=(1<<n)*[0]\\n        f0=(1<<n)*[0]\\n        f1=(1<<n)*[0]\\n        for i in range(n):\\n            k=1<<i\\n            pop[k]=1\\n            x0=f0[k]=sum(1<<j for j in range(n) if S[i][j]==0) # people who are Forced to be bad if person i is truthful\\n            x1=f1[k]=sum(1<<j for j in range(n) if S[i][j]==1) # people who are Forced to be good if person i is truthful\\n            for j in range(1,k):\\n                k+=1\\n                pop[k]=pop[j]+1\\n                f0[k]=f0[j]|x0\\n                f1[k]=f1[j]|x1\\n        return max(pop[i] for i in range(1<<n) if i&f0[i]==0 and i|f1[i]==i)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2191539,
                "title": "c-solution-bit-manipulation",
                "content": "```\\nclass Solution {\\nprivate:\\n    bool checkValid(int mask,vector<vector<int>>&statements){\\n        int copy=mask;\\n        while(mask){\\n            //allows me to turn the rightmost bit off, meaning I only have to \\n            //traverse through the 1s in the bitmask rather than all the bits\\n            //of the bitmask\\n            int pos=log2(mask&(-mask));\\n            mask-=mask&(-mask);\\n            //pos is a good person, therefore all his statements should be \\n            //consistent\\n            for(int i=0;i<statements[pos].size();i++){\\n                if(statements[pos][i]==2){\\n                    continue;\\n                } else {\\n                    //his statement on j is not consistent, therefore this \\n                    //assignment is not valid\\n                    if(statements[pos][i]!=((copy>>i)&1)){\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\npublic:\\n    int maximumGood(vector<vector<int>>& statements) {\\n        int n=statements.size(),ans=0;\\n        //checking every possible assignment of good people\\n        for(int mask=0;mask<(1<<n);mask++){\\n            if(checkValid(mask,statements)){\\n                ans=max(ans,__builtin_popcount(mask));\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "class Solution {\\nprivate:\\n    bool checkValid(int mask,vector<vector<int>>&statements){\\n        int copy=mask;\\n        while(mask){\\n            //allows me to turn the rightmost bit off, meaning I only have to \\n            //traverse through the 1s in the bitmask rather than all the bits\\n            //of the bitmask\\n            int pos=log2(mask&(-mask));\\n            mask-=mask&(-mask);\\n            //pos is a good person, therefore all his statements should be \\n            //consistent\\n            for(int i=0;i<statements[pos].size();i++){\\n                if(statements[pos][i]==2){\\n                    continue;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2152016,
                "title": "c-bit-manipulation-clean-and-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkValid(int index, int mask, vector<vector<int>>& statements) {\\n        if (index == statements.size())\\n            return true;\\n        if (mask & (1 << index)) {\\n            for (int k = 0; k < statements.size(); k++) {\\n                if (statements[index][k] == 2)\\n                    continue;\\n                if (statements[index][k] ^ (bool)(mask & (1 << k)))\\n                    return false;\\n            }\\n        }\\n        return checkValid(index + 1, mask, statements);\\n    }\\n    int maximumGood(vector<vector<int>>& statements) {\\n        int n = statements.size(), result = 0;\\n        for (int mask = 0; mask < (1 << n); mask++) {\\n            if (checkValid(0, mask, statements))\\n                result = max(result, __builtin_popcount(mask));\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValid(int index, int mask, vector<vector<int>>& statements) {\\n        if (index == statements.size())\\n            return true;\\n        if (mask & (1 << index)) {\\n            for (int k = 0; k < statements.size(); k++) {\\n                if (statements[index][k] == 2)\\n                    continue;\\n                if (statements[index][k] ^ (bool)(mask & (1 << k)))\\n                    return false;\\n            }\\n        }\\n        return checkValid(index + 1, mask, statements);\\n    }\\n    int maximumGood(vector<vector<int>>& statements) {\\n        int n = statements.size(), result = 0;\\n        for (int mask = 0; mask < (1 << n); mask++) {\\n            if (checkValid(0, mask, statements))\\n                result = max(result, __builtin_popcount(mask));\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2147944,
                "title": "full-video-explanation-link-provided",
                "content": "Please watch this video to fully understand the problem. \\n\\nhttps://www.youtube.com/watch?v=_fQQjh7lMBI\\n",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "Please watch this video to fully understand the problem. \\n\\nhttps://www.youtube.com/watch?v=_fQQjh7lMBI\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2136392,
                "title": "c-brute-force",
                "content": "```\\n    int maximumGood(vector<vector<int>>& statements) {\\n        int n = statements.size(), res = 0, numTotalPoss= pow(2, n);\\n     \\n        for(int i = 0; i < numTotalPoss; i++){\\n            bitset<16> b(i);\\n            string possibleOption = b.to_string().substr(16-n);\\n            bool flag = true;\\n            \\n            for(int j = 0; j <n  ; j++){\\n              \\n                if(possibleOption[j] == \\'0\\') continue;\\n                \\n                else{\\n                    for(int k = 0; k< n; k++){\\n                        int statement = statements[j][k];\\n                        if(statement == 2) continue;\\n                        if(possibleOption[k] -\\'0\\' != statement) {\\n                            flag = false;\\n                            break;\\n                        }\\n                    }\\n                    if(!flag) break;\\n                    \\n                }\\n            }\\n            \\n            if(flag) res = max(res, (int) b.count());\\n        }\\n        \\n        return res;\\n        \\n    }",
                "solutionTags": [],
                "code": "```\\n    int maximumGood(vector<vector<int>>& statements) {\\n        int n = statements.size(), res = 0, numTotalPoss= pow(2, n);\\n     \\n        for(int i = 0; i < numTotalPoss; i++){\\n            bitset<16> b(i);\\n            string possibleOption = b.to_string().substr(16-n);\\n            bool flag = true;\\n            \\n            for(int j = 0; j <n  ; j++){\\n              \\n                if(possibleOption[j] == \\'0\\') continue;\\n                \\n                else{\\n                    for(int k = 0; k< n; k++){\\n                        int statement = statements[j][k];\\n                        if(statement == 2) continue;\\n                        if(possibleOption[k] -\\'0\\' != statement) {\\n                            flag = false;\\n                            break;\\n                        }\\n                    }\\n                    if(!flag) break;\\n                    \\n                }\\n            }\\n            \\n            if(flag) res = max(res, (int) b.count());\\n        }\\n        \\n        return res;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2112851,
                "title": "c-bit-manipulation",
                "content": "```\\nclass Solution {\\nprivate:\\n    bool possible(vector<vector<int>>& grid, int num) {\\n        int n = grid.size();\\n        for(int i = 0; i < n; i++) {\\n            if((1 << i) & num) {\\n                for(int j = 0; j < n; j++) {\\n                    if(i == j) continue;\\n                    if(((1 << j) & num) && grid[i][j] == 0) \\n                        return false;\\n                    else if(!((1 << j) & num) && grid[i][j] == 1)\\n                        return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\npublic:\\n    int maximumGood(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int N = 1 << n;\\n        \\n        int ans = 0;\\n        for(int i = 1; i < N; i++) {\\n            if(possible(grid, i))\\n                ans = max(ans, __builtin_popcount(i));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool possible(vector<vector<int>>& grid, int num) {\\n        int n = grid.size();\\n        for(int i = 0; i < n; i++) {\\n            if((1 << i) & num) {\\n                for(int j = 0; j < n; j++) {\\n                    if(i == j) continue;\\n                    if(((1 << j) & num) && grid[i][j] == 0) \\n                        return false;\\n                    else if(!((1 << j) & num) && grid[i][j] == 1)\\n                        return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\npublic:\\n    int maximumGood(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int N = 1 << n;\\n        \\n        int ans = 0;\\n        for(int i = 1; i < N; i++) {\\n            if(possible(grid, i))\\n                ans = max(ans, __builtin_popcount(i));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2095117,
                "title": "swift-clean-solution-with-bitmasking",
                "content": "```\\nclass Solution {\\n    func maximumGood(_ statements: [[Int]]) -> Int {\\n        let n = statements.count\\n        var ans = 0\\n        let maxMask = 1 << n\\n\\n        func getBit(_ num: Int, _ index: Int) -> Int {\\n            return ((num & (1 << index)) >> index) & 1\\n        }\\n\\n        // 0 is bad, 1 is good\\n        func check(_ curMask: Int) -> Bool {\\n            for i in 0..<n {\\n                let iStatus = getBit(curMask, i)\\n                \\n                // if person i is bad, ignore\\n                if iStatus == 0 { continue }\\n                \\n                // here: i is good, i tells the truth\\n                for j in 0..<n {\\n                    if statements[i][j] == 2 { continue }\\n                    let jStatus = getBit(curMask, j)\\n                    if statements[i][j] != jStatus { return false }\\n                }\\n            }\\n            return true\\n        }\\n\\n        for mask in 0..<maxMask {\\n            let bitCount = mask.nonzeroBitCount\\n            if bitCount > ans, check(mask){\\n                ans = bitCount\\n            }\\n        }\\n\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    func maximumGood(_ statements: [[Int]]) -> Int {\\n        let n = statements.count\\n        var ans = 0\\n        let maxMask = 1 << n\\n\\n        func getBit(_ num: Int, _ index: Int) -> Int {\\n            return ((num & (1 << index)) >> index) & 1\\n        }\\n\\n        // 0 is bad, 1 is good\\n        func check(_ curMask: Int) -> Bool {\\n            for i in 0..<n {\\n                let iStatus = getBit(curMask, i)\\n                \\n                // if person i is bad, ignore\\n                if iStatus == 0 { continue }\\n                \\n                // here: i is good, i tells the truth\\n                for j in 0..<n {\\n                    if statements[i][j] == 2 { continue }\\n                    let jStatus = getBit(curMask, j)\\n                    if statements[i][j] != jStatus { return false }\\n                }\\n            }\\n            return true\\n        }\\n\\n        for mask in 0..<maxMask {\\n            let bitCount = mask.nonzeroBitCount\\n            if bitCount > ans, check(mask){\\n                ans = bitCount\\n            }\\n        }\\n\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2078929,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    int max_num = 0;\\n    \\n    public int maximumGood(int[][] statements) {\\n        dfs(statements, new boolean[statements.length], 0, 0);\\n        return max_num;\\n    }\\n    \\n    private boolean isValid(int[][] statements, boolean[] good, int k) {\\n        for (int i = 0; i <= k; i++) {\\n            for (int j = 0; j <= k; j++) {\\n                \\n                if (statements[i][j] == 1 && !good[j] && good[i]) return false;   \\n                \\n                if (statements[i][j] == 0 && good[j] && good[i]) return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private void dfs(int[][] statements, boolean[] good, int i, int count) {\\n        if (i == good.length) {\\n            max_num = Math.max(count, max_num);\\n            return;\\n        }\\n        // try person i is good person\\n        if (isValid(statements, good, i)) {\\n            dfs(statements, good, i + 1, count);\\n        }\\n        good[i] = true;\\n        if (isValid(statements, good, i)) {\\n            dfs(statements, good, i + 1, count + 1);\\n        }\\n        good[i] = false;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int max_num = 0;\\n    \\n    public int maximumGood(int[][] statements) {\\n        dfs(statements, new boolean[statements.length], 0, 0);\\n        return max_num;\\n    }\\n    \\n    private boolean isValid(int[][] statements, boolean[] good, int k) {\\n        for (int i = 0; i <= k; i++) {\\n            for (int j = 0; j <= k; j++) {\\n                \\n                if (statements[i][j] == 1 && !good[j] && good[i]) return false;   \\n                \\n                if (statements[i][j] == 0 && good[j] && good[i]) return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private void dfs(int[][] statements, boolean[] good, int i, int count) {\\n        if (i == good.length) {\\n            max_num = Math.max(count, max_num);\\n            return;\\n        }\\n        // try person i is good person\\n        if (isValid(statements, good, i)) {\\n            dfs(statements, good, i + 1, count);\\n        }\\n        good[i] = true;\\n        if (isValid(statements, good, i)) {\\n            dfs(statements, good, i + 1, count + 1);\\n        }\\n        good[i] = false;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2064391,
                "title": "easy-understanding-python-mask-approach",
                "content": "```\\n        n = len(statements)\\n        max_count = 0\\n\\n        for p in range(2**n): # each p is a possible combination of good/bad person\\n            \\n            for a in range(n):\\n                if p >> a & 1: # only good person\\'s statement is deterministic\\n                    \\n                    for b in range(n):\\n                        if statements[a][b] != 2 and statements[a][b] != p >> b & 1: # invalid p\\n                            break\\n                    else:\\n                        continue\\n                        \\n                    break\\n            else:\\n                max_count = max(max_count, bin(p).count(\"1\"))\\n                \\n        return max_count\\n```",
                "solutionTags": [],
                "code": "```\\n        n = len(statements)\\n        max_count = 0\\n\\n        for p in range(2**n): # each p is a possible combination of good/bad person\\n            \\n            for a in range(n):\\n                if p >> a & 1: # only good person\\'s statement is deterministic\\n                    \\n                    for b in range(n):\\n                        if statements[a][b] != 2 and statements[a][b] != p >> b & 1: # invalid p\\n                            break\\n                    else:\\n                        continue\\n                        \\n                    break\\n            else:\\n                max_count = max(max_count, bin(p).count(\"1\"))\\n                \\n        return max_count\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1981645,
                "title": "bitmask-for-every-possible-combination",
                "content": "```cpp\\nint maximumGood(vector<vector<int>>& statements) {\\n\\tint n = statements.size();\\n\\tint b = 1 << n;\\n\\tint r = 0;\\n\\t\\n\\t// k is a bitset of size n, \\n\\t// every person is presented by a bit, 1 means the person is presumed good, 0 otherwise.\\n\\t// for every possible combination, \\n\\tfor (int k = 0; k < b; ++k)\\n\\t{\\n\\t\\tbool stillGood = true;\\n\\t\\tint c = 0;\\n\\t\\t\\n\\t\\t// for every person i, \\n\\t\\tfor(int i = 0; i < n && stillGood; ++i)\\n\\t\\t{\\n\\t\\t\\t// if the person i is not presumed good, skip.\\n\\t\\t\\tif (((k >> i) & 1) == 0)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\n\\t\\t\\t//in combination k, i is presume good, \\n\\t\\t\\t// count good i.\\n\\t\\t\\t++ c;\\n\\n\\t\\t\\t// check the statement of i to j, and the presume state of j.\\n\\t\\t\\tfor (int j = 0; j < n && stillGood; ++j)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (statements[i][j] == 2)\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\tstillGood = statements[i][j] == ((k >> j) & 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\tif (stillGood)\\n\\t\\t\\tr = max(r, c);;\\n\\t}\\n\\t\\n\\treturn r;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```cpp\\nint maximumGood(vector<vector<int>>& statements) {\\n\\tint n = statements.size();\\n\\tint b = 1 << n;\\n\\tint r = 0;\\n\\t\\n\\t// k is a bitset of size n, \\n\\t// every person is presented by a bit, 1 means the person is presumed good, 0 otherwise.\\n\\t// for every possible combination, \\n\\tfor (int k = 0; k < b; ++k)\\n\\t{\\n\\t\\tbool stillGood = true;\\n\\t\\tint c = 0;\\n\\t\\t\\n\\t\\t// for every person i, \\n\\t\\tfor(int i = 0; i < n && stillGood; ++i)\\n\\t\\t{\\n\\t\\t\\t// if the person i is not presumed good, skip.\\n\\t\\t\\tif (((k >> i) & 1) == 0)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\n\\t\\t\\t//in combination k, i is presume good, \\n\\t\\t\\t// count good i.\\n\\t\\t\\t++ c;\\n\\n\\t\\t\\t// check the statement of i to j, and the presume state of j.\\n\\t\\t\\tfor (int j = 0; j < n && stillGood; ++j)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (statements[i][j] == 2)\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\tstillGood = statements[i][j] == ((k >> j) & 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\tif (stillGood)\\n\\t\\t\\tr = max(r, c);;\\n\\t}\\n\\t\\n\\treturn r;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1916728,
                "title": "c-bit-manipulation-dfs",
                "content": "```\\n\\nclass Solution {\\npublic:\\n\\n    bool isValid(int bitMask, vector<vector<int>> &s) {\\n        int n = s[0].size();\\n\\n        for (int i = 0; i < n; i++) {\\n            \\n            int amIGood = bitMask & (1 << i);\\n            for (int j = 0; j < s[0].size(); j++) {\\n                if (amIGood) {\\n                    // means i will always speak the truth\\n                    if (s[i][j] == 1) {\\n                        if (!(bitMask & (1 << j))) return false;\\n                    } else if (s[i][j] == 0) {\\n                        if ((bitMask & (1 << j))) return false;\\n                    }\\n                }\\n            }\\n        }\\n\\n\\n        return true;\\n    }\\n\\n    void generateSubsetsAndCheck(int i, int bitMask, int &n, vector<vector<int>> &s, int &ans) {\\n        \\n        if (i == n - 1) {\\n            if (isValid(bitMask , s)) {\\n                ans = max(ans, __builtin_popcount(bitMask));\\n                \\n            }\\n            return;\\n        }\\n\\n        generateSubsetsAndCheck(i + 1, bitMask & (~(1 << (i + 1))), n, s, ans);\\n        generateSubsetsAndCheck(i + 1, bitMask | (1 << (i + 1)), n, s, ans);\\n\\n    }\\n    \\n    int maximumGood(vector<vector<int>>& statements) {\\n        int n = statements[0].size();\\n        int ans1 = 0, ans2 = 0;\\n        int bitMask1 = 0;\\n        int bitMask2 = 1;\\n        generateSubsetsAndCheck(0, bitMask1, n, statements, ans1);\\n        generateSubsetsAndCheck(0, bitMask2, n, statements, ans2);\\n\\n        return max(ans1, ans2);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n    bool isValid(int bitMask, vector<vector<int>> &s) {\\n        int n = s[0].size();\\n\\n        for (int i = 0; i < n; i++) {\\n            \\n            int amIGood = bitMask & (1 << i);\\n            for (int j = 0; j < s[0].size(); j++) {\\n                if (amIGood) {\\n                    // means i will always speak the truth\\n                    if (s[i][j] == 1) {\\n                        if (!(bitMask & (1 << j))) return false;\\n                    } else if (s[i][j] == 0) {\\n                        if ((bitMask & (1 << j))) return false;\\n                    }\\n                }\\n            }\\n        }\\n\\n\\n        return true;\\n    }\\n\\n    void generateSubsetsAndCheck(int i, int bitMask, int &n, vector<vector<int>> &s, int &ans) {\\n        \\n        if (i == n - 1) {\\n            if (isValid(bitMask , s)) {\\n                ans = max(ans, __builtin_popcount(bitMask));\\n                \\n            }\\n            return;\\n        }\\n\\n        generateSubsetsAndCheck(i + 1, bitMask & (~(1 << (i + 1))), n, s, ans);\\n        generateSubsetsAndCheck(i + 1, bitMask | (1 << (i + 1)), n, s, ans);\\n\\n    }\\n    \\n    int maximumGood(vector<vector<int>>& statements) {\\n        int n = statements[0].size();\\n        int ans1 = 0, ans2 = 0;\\n        int bitMask1 = 0;\\n        int bitMask2 = 1;\\n        generateSubsetsAndCheck(0, bitMask1, n, statements, ans1);\\n        generateSubsetsAndCheck(0, bitMask2, n, statements, ans2);\\n\\n        return max(ans1, ans2);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1914370,
                "title": "python-solution-need-to-recall-before-interviewing",
                "content": "```\\nclass Solution:\\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        def helper(statements, guess_type_list):\\n            N = len(statements)\\n            for i, guess_type in enumerate(guess_type_list):\\n                if guess_type == 0:\\n                    continue\\n                for j in range(N):\\n                    if statements[i][j] != 2 and statements[i][j] != guess_type_list[j]:\\n                        return False\\n            return True\\n        N = len(statements)\\n        res = 0\\n        for guess in range(1<<N):\\n            guess_type_list = [int(i) for i in bin(guess)[2:].zfill(N)]\\n            if helper(statements, guess_type_list):\\n                res = max(res, sum(guess_type_list))\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        def helper(statements, guess_type_list):\\n            N = len(statements)\\n            for i, guess_type in enumerate(guess_type_list):\\n                if guess_type == 0:\\n                    continue\\n                for j in range(N):\\n                    if statements[i][j] != 2 and statements[i][j] != guess_type_list[j]:\\n                        return False\\n            return True\\n        N = len(statements)\\n        res = 0\\n        for guess in range(1<<N):\\n            guess_type_list = [int(i) for i in bin(guess)[2:].zfill(N)]\\n            if helper(statements, guess_type_list):\\n                res = max(res, sum(guess_type_list))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1842063,
                "title": "python-backtracking-bit-manipulation-explained",
                "content": "We keep track of the good and bad people using bit manipulation. `good_people = 010011` would mean we know (or are assuming) that people 0, 1, and 4 are good.\\n\\nWe have a function\\n```\\n        @lru_cache(None)\\n        def Good(good_people: int, bad_people: int) -> int:\\n```\\nthat gives us the maximum possible number of good people we can have given `statements`, and assuming `good_people` are good and `bad_people` are bad. We will recursively call this function as we learn more about the good and bad people. If a combination of `good_people` and `bad_people` is not compatible, this function returns `-1`. We will also keep previous values stored to reduce processing time (otherwise this solution TLE\\'s).\\n\\nFirst we will update `good_people` and `bad_people` given `statements` as much as possible, being careful **not** to have someone be *good* and *bad* at the **same time**. We won\\'t bother checking the **known** bad people statements, since they are unreliable:\\n```\\n            prev_good, new_good = 0, good_people\\n\\t\\t\\t# if in the previous iteration we discovered at least one more new\\n\\t\\t\\t# good person from the good people statements, we go at it again \\n            while new_good ^ prev_good:\\n\\t\\t\\t    # we will only check the statements of the new good people found\\n\\t\\t\\t\\t# on the previous iteration\\n                to_check = new_good ^ prev_good\\n                prev_good = new_good\\n                for i in range(n):\\n                    if to_check & 1 << i:\\n                        for x in range(n):\\n\\t\\t\\t\\t\\t\\t\\t# we turn on the bit in new_good corresponding to person x\\n\\t\\t\\t\\t\\t\\t\\t# if a good person says they are good\\n                            if statements[i][x] == 1:\\n                                new_good |= 1 << x\\n\\t\\t\\t\\t\\t\\t\\t# we turn on the bit in bad_people corresponding to person x\\n\\t\\t\\t\\t\\t\\t\\t# if a good person says they are bad\\n                            elif statements[i][x] == 0:\\n                                bad_people |= 1 << x\\n\\t\\t\\t\\t\\t\\t\\t# we cannot have someone be good and bad at the same time\\n                            if new_good & bad_people:\\n                                return -1\\n            good_people = new_good\\n```\\nOnce we have updated `good_people` and `bad_people` as much as possible with the good people statements, we will ask `Good` the maximum number of good people we could have by assuming, one at a time, that the people we are unsure of are good (here `goodness` returns the Hamming weight of `good_people`, that is, the number of good people it represents):\\n```\\n            curr_max  = goodnes(good_people)\\n\\t\\t\\t# we will only check people that we don\\'t know yet if they are good or bad\\n            to_check = ~(good_people | bad_people) & 2 ** n - 1\\n            for i in range(n):\\n                if to_check & 1 << i:\\n\\t\\t\\t\\t\\t# what if i was also good?\\n                    good_aux = Good(good_people | 1 << i, bad_people)\\n                    if good_aux != -1:\\n                        curr_max = max(curr_max, good_aux)\\n            return curr_max\\n```\\nThe answer is then `Good(0,0)`. \\n&#8718;\\n\\nWhole solution:\\n```\\nclass Solution:\\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        \\n        def goodnes(good_people):\\n            return bin(good_people)[2:].count(\\'1\\')\\n        \\n        n = len(statements)\\n        @lru_cache(None)\\n        def Good(good_people: int, bad_people: int) -> int:\\n            prev_good, new_good = 0, good_people\\n            while new_good ^ prev_good:\\n                to_check = new_good ^ prev_good\\n                prev_good = new_good\\n                for i in range(n):\\n                    if to_check & 1 << i:\\n                        for x in range(n):\\n                            if statements[i][x] == 1:\\n                                new_good |= 1 << x\\n                            elif statements[i][x] == 0:\\n                                bad_people |= 1 << x\\n                            if new_good & bad_people:\\n                                return -1\\n            \\n            good_people = new_good\\n            curr_max  = goodnes(good_people)\\n            \\n            to_check = ~(good_people | bad_people) & 2 ** n - 1\\n            for i in range(n):\\n                if to_check & 1 << i:\\n                    good_aux = Good(good_people | 1 << i, bad_people)\\n                    if good_aux != -1:\\n                        curr_max = max(curr_max, good_aux)\\n\\n            return curr_max\\n\\n        return Good(0,0)\\n```\\n*This was my first successful atempt at this problem. I will probably come back and improve whatever I can as I try different approaches and read other\\'s solutions.* Any comments are greatly appreciated. Thanks for reading through my solution!",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\n        @lru_cache(None)\\n        def Good(good_people: int, bad_people: int) -> int:\\n```\n```\\n            prev_good, new_good = 0, good_people\\n\\t\\t\\t# if in the previous iteration we discovered at least one more new\\n\\t\\t\\t# good person from the good people statements, we go at it again \\n            while new_good ^ prev_good:\\n\\t\\t\\t    # we will only check the statements of the new good people found\\n\\t\\t\\t\\t# on the previous iteration\\n                to_check = new_good ^ prev_good\\n                prev_good = new_good\\n                for i in range(n):\\n                    if to_check & 1 << i:\\n                        for x in range(n):\\n\\t\\t\\t\\t\\t\\t\\t# we turn on the bit in new_good corresponding to person x\\n\\t\\t\\t\\t\\t\\t\\t# if a good person says they are good\\n                            if statements[i][x] == 1:\\n                                new_good |= 1 << x\\n\\t\\t\\t\\t\\t\\t\\t# we turn on the bit in bad_people corresponding to person x\\n\\t\\t\\t\\t\\t\\t\\t# if a good person says they are bad\\n                            elif statements[i][x] == 0:\\n                                bad_people |= 1 << x\\n\\t\\t\\t\\t\\t\\t\\t# we cannot have someone be good and bad at the same time\\n                            if new_good & bad_people:\\n                                return -1\\n            good_people = new_good\\n```\n```\\n            curr_max  = goodnes(good_people)\\n\\t\\t\\t# we will only check people that we don\\'t know yet if they are good or bad\\n            to_check = ~(good_people | bad_people) & 2 ** n - 1\\n            for i in range(n):\\n                if to_check & 1 << i:\\n\\t\\t\\t\\t\\t# what if i was also good?\\n                    good_aux = Good(good_people | 1 << i, bad_people)\\n                    if good_aux != -1:\\n                        curr_max = max(curr_max, good_aux)\\n            return curr_max\\n```\n```\\nclass Solution:\\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        \\n        def goodnes(good_people):\\n            return bin(good_people)[2:].count(\\'1\\')\\n        \\n        n = len(statements)\\n        @lru_cache(None)\\n        def Good(good_people: int, bad_people: int) -> int:\\n            prev_good, new_good = 0, good_people\\n            while new_good ^ prev_good:\\n                to_check = new_good ^ prev_good\\n                prev_good = new_good\\n                for i in range(n):\\n                    if to_check & 1 << i:\\n                        for x in range(n):\\n                            if statements[i][x] == 1:\\n                                new_good |= 1 << x\\n                            elif statements[i][x] == 0:\\n                                bad_people |= 1 << x\\n                            if new_good & bad_people:\\n                                return -1\\n            \\n            good_people = new_good\\n            curr_max  = goodnes(good_people)\\n            \\n            to_check = ~(good_people | bad_people) & 2 ** n - 1\\n            for i in range(n):\\n                if to_check & 1 << i:\\n                    good_aux = Good(good_people | 1 << i, bad_people)\\n                    if good_aux != -1:\\n                        curr_max = max(curr_max, good_aux)\\n\\n            return curr_max\\n\\n        return Good(0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1837822,
                "title": "java-o-n-2-n-2-n-solution",
                "content": "```\\nclass Solution {\\n    private int max = 0;\\n    public int maximumGood(int[][] statements) {\\n        int n = statements.length;\\n        List<Integer>[] neigh = new List[n];\\n        for(int i = 0; i < n; i++) {\\n            neigh[i] = new ArrayList<>();\\n            for(int j = 0; j < n; j++) {\\n                if(statements[i][j] != 2) {\\n                    neigh[i].add(j);\\n                }\\n            }\\n        }\\n        dfs(0, neigh, 0, 0, statements);\\n        return max;\\n    }\\n    \\n    private void dfs(int curPerson, List<Integer>[] neigh, int goodGroup, int badGroup, int[][] statements) {\\n        if(curPerson == statements.length) {\\n            max = Math.max(Integer.bitCount(goodGroup), max);\\n            return;\\n        }\\n        int d = 1 << curPerson;\\n        //is bad guy\\n        if((d & badGroup) != 0) {\\n            dfs(curPerson + 1, neigh, goodGroup, badGroup, statements);\\n            return;\\n        }\\n        int max = 0;\\n        //not bad and not good, not sure => so we try bad guy on current person\\n        if((d & goodGroup) == 0) {\\n            dfs(curPerson + 1, neigh, goodGroup, badGroup | d, statements);\\n        }\\n        //try good guy on current person => verify his word, if he is not conflicting with other good person \\n        if(!valid(curPerson, neigh[curPerson], goodGroup, badGroup, statements)) {\\n            return;\\n        }\\n        for(int p: neigh[curPerson]) {\\n            if(statements[curPerson][p] == 1) {\\n                goodGroup |= (1 << p);\\n            } else if(statements[curPerson][p] == 0) {\\n                badGroup |= (1 << p);\\n            }\\n        }\\n        dfs(curPerson + 1, neigh, goodGroup | d, badGroup, statements);\\n    }\\n    \\n    private boolean valid(int curPerson, List<Integer> relatedPeople, int goodGroup, int badGroup, int[][] statements) {\\n        for(int p: relatedPeople) {\\n            if(statements[curPerson][p] == 1 && ((1 << p) & goodGroup) == 0 && ((1 << p) & badGroup) != 0) {\\n                return false;\\n            } \\n            if(statements[curPerson][p] == 0 && ((1 << p) & goodGroup) != 0 && ((1 << p) & badGroup) == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n//     public int maximumGood(int[][] statements) {\\n//         int n = statements.length;\\n//         int len = 1 << n;\\n//         int ans = 0;\\n//         for(int v = 1; v < len; v++) {\\n//             if(isValid(statements, v, n)) {\\n//                 ans = Math.max(Integer.bitCount(v), ans);\\n//             }\\n//         }\\n//         return ans;\\n//     }\\n    \\n//     private boolean isValid(int[][] stat, int v, int n) {\\n//         for(int i = 0; i < n; i++) {\\n//             if((v & (1 << i)) == 0) {\\n//                 continue;\\n//             }\\n//             for(int j = 0; j < n; j++) {\\n//                 if(stat[i][j] == 1 && (v & (1 << j)) == 0) {\\n//                     return false;\\n//                 } else if(stat[i][j] == 0 && (v & (1 << j)) != 0) {\\n//                     return false;\\n//                 }\\n//             }\\n//         }\\n//         return true;\\n//     }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    private int max = 0;\\n    public int maximumGood(int[][] statements) {\\n        int n = statements.length;\\n        List<Integer>[] neigh = new List[n];\\n        for(int i = 0; i < n; i++) {\\n            neigh[i] = new ArrayList<>();\\n            for(int j = 0; j < n; j++) {\\n                if(statements[i][j] != 2) {\\n                    neigh[i].add(j);\\n                }\\n            }\\n        }\\n        dfs(0, neigh, 0, 0, statements);\\n        return max;\\n    }\\n    \\n    private void dfs(int curPerson, List<Integer>[] neigh, int goodGroup, int badGroup, int[][] statements) {\\n        if(curPerson == statements.length) {\\n            max = Math.max(Integer.bitCount(goodGroup), max);\\n            return;\\n        }\\n        int d = 1 << curPerson;\\n        //is bad guy\\n        if((d & badGroup) != 0) {\\n            dfs(curPerson + 1, neigh, goodGroup, badGroup, statements);\\n            return;\\n        }\\n        int max = 0;\\n        //not bad and not good, not sure => so we try bad guy on current person\\n        if((d & goodGroup) == 0) {\\n            dfs(curPerson + 1, neigh, goodGroup, badGroup | d, statements);\\n        }\\n        //try good guy on current person => verify his word, if he is not conflicting with other good person \\n        if(!valid(curPerson, neigh[curPerson], goodGroup, badGroup, statements)) {\\n            return;\\n        }\\n        for(int p: neigh[curPerson]) {\\n            if(statements[curPerson][p] == 1) {\\n                goodGroup |= (1 << p);\\n            } else if(statements[curPerson][p] == 0) {\\n                badGroup |= (1 << p);\\n            }\\n        }\\n        dfs(curPerson + 1, neigh, goodGroup | d, badGroup, statements);\\n    }\\n    \\n    private boolean valid(int curPerson, List<Integer> relatedPeople, int goodGroup, int badGroup, int[][] statements) {\\n        for(int p: relatedPeople) {\\n            if(statements[curPerson][p] == 1 && ((1 << p) & goodGroup) == 0 && ((1 << p) & badGroup) != 0) {\\n                return false;\\n            } \\n            if(statements[curPerson][p] == 0 && ((1 << p) & goodGroup) != 0 && ((1 << p) & badGroup) == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n//     public int maximumGood(int[][] statements) {\\n//         int n = statements.length;\\n//         int len = 1 << n;\\n//         int ans = 0;\\n//         for(int v = 1; v < len; v++) {\\n//             if(isValid(statements, v, n)) {\\n//                 ans = Math.max(Integer.bitCount(v), ans);\\n//             }\\n//         }\\n//         return ans;\\n//     }\\n    \\n//     private boolean isValid(int[][] stat, int v, int n) {\\n//         for(int i = 0; i < n; i++) {\\n//             if((v & (1 << i)) == 0) {\\n//                 continue;\\n//             }\\n//             for(int j = 0; j < n; j++) {\\n//                 if(stat[i][j] == 1 && (v & (1 << j)) == 0) {\\n//                     return false;\\n//                 } else if(stat[i][j] == 0 && (v & (1 << j)) != 0) {\\n//                     return false;\\n//                 }\\n//             }\\n//         }\\n//         return true;\\n//     }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1835139,
                "title": "c-brute-force",
                "content": "Since the problem is restricted to 15 people max, you can simply search the whole space of 2^15 possibilities and match the statements.\\n\\n```\\npublic class Solution\\n{\\n\\tprivate int CountSetBits(int num)\\n\\t{\\n\\t\\tint count = 0;\\n\\t\\twhile (num > 0)\\n\\t\\t{\\n\\t\\t\\tnum = num & (num - 1);\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn count;\\n\\t}\\n\\t\\n\\tprivate bool MatchStatement(int bits, int[][] statements)\\n\\t{\\n\\t\\tfor (int i = 0; i < statements.Length; i++)\\n\\t\\t{\\n\\t\\t\\tint mask = 1 << i;\\n\\t\\t\\tif ((bits & mask) == 0) continue;\\n\\t\\t\\tfor (int j = 0; j < statements.Length; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (statements[i][j] == 2) continue;\\n\\t\\t\\t\\tmask = 1 << j;\\n\\t\\t\\t\\tif (statements[i][j] == 0 && (bits & mask) != 0 || statements[i][j] == 1 && (bits & mask) == 0)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\n\\tpublic int MaximumGood(int[][] statements)\\n\\t{\\n\\t\\tint size = statements.Length;\\n\\t\\t\\n\\t\\tDictionary<int, List<int>> map = new Dictionary<int, List<int>>();\\n\\t\\tfor (int i = 0; i < (1 << size); i++)\\n\\t\\t{\\n\\t\\t\\tint count = CountSetBits(i);\\n\\t\\t\\tif (!map.ContainsKey(count))\\n\\t\\t\\t{\\n\\t\\t\\t\\tmap.Add(count, new List<int>());\\n\\t\\t\\t}\\n\\t\\t\\tmap[count].Add(i);\\n\\t\\t}\\n\\t\\t\\n\\t\\tforeach (var key in map.Keys.OrderByDescending(k => k))\\n\\t\\t{\\n\\t\\t\\tforeach (var bits in map[key])\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (MatchStatement(bits, statements))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn key;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn 0;\\n\\t}\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n\\tprivate int CountSetBits(int num)\\n\\t{\\n\\t\\tint count = 0;\\n\\t\\twhile (num > 0)\\n\\t\\t{\\n\\t\\t\\tnum = num & (num - 1);\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn count;\\n\\t}\\n\\t\\n\\tprivate bool MatchStatement(int bits, int[][] statements)\\n\\t{\\n\\t\\tfor (int i = 0; i < statements.Length; i++)\\n\\t\\t{\\n\\t\\t\\tint mask = 1 << i;\\n\\t\\t\\tif ((bits & mask) == 0) continue;\\n\\t\\t\\tfor (int j = 0; j < statements.Length; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (statements[i][j] == 2) continue;\\n\\t\\t\\t\\tmask = 1 << j;\\n\\t\\t\\t\\tif (statements[i][j] == 0 && (bits & mask) != 0 || statements[i][j] == 1 && (bits & mask) == 0)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\n\\tpublic int MaximumGood(int[][] statements)\\n\\t{\\n\\t\\tint size = statements.Length;\\n\\t\\t\\n\\t\\tDictionary<int, List<int>> map = new Dictionary<int, List<int>>();\\n\\t\\tfor (int i = 0; i < (1 << size); i++)\\n\\t\\t{\\n\\t\\t\\tint count = CountSetBits(i);\\n\\t\\t\\tif (!map.ContainsKey(count))\\n\\t\\t\\t{\\n\\t\\t\\t\\tmap.Add(count, new List<int>());\\n\\t\\t\\t}\\n\\t\\t\\tmap[count].Add(i);\\n\\t\\t}\\n\\t\\t\\n\\t\\tforeach (var key in map.Keys.OrderByDescending(k => k))\\n\\t\\t{\\n\\t\\t\\tforeach (var bits in map[key])\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (MatchStatement(bits, statements))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn key;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn 0;\\n\\t}\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1817114,
                "title": "python-dp-beats-99-95",
                "content": "```\\nclass Solution:\\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        N = len(statements)\\n        Max = 0\\n        @lru_cache(None)\\n        def dp(i,good,tag):\\n            nonlocal Max\\n            Tag = list(tag)\\n            if i>=N:\\n                Max = max(Max,good)\\n                return True\\n            if Tag[0] == 0 or Tag[0] == 2:\\n                conflict = 0\\n                for j in range(i+1,N):\\n                    if statements[j][i] == 1:\\n                        if Tag[j-i] == 1:\\n                            conflict = 1\\n                            break\\n                        Tag[j-i] = 0\\n                if not conflict:\\n                    dp(i+1,good,tuple(Tag[1:]))\\n                if Tag[0] == 0:\\n                    return True\\n            \\n            Tag = list(tag)\\n            conflict = 0\\n            for j in range(i+1,N):\\n                if (statements[i][j] == 0 and Tag[j-i] == 1) or (statements[i][j] == 1 and Tag[j-i] == 0) or (statements[i][j] == 1 and statements[j][i] == 0) :\\n                    conflict = 1\\n                    break\\n            if not conflict:\\n                for j in range(i+1,N):\\n                    if statements[i][j] < 2:\\n                        Tag[j-i] = statements[i][j]\\n                    if statements[j][i] == 0:\\n                        Tag[j-i] = 0\\n                dp(i+1,good+1,tuple(Tag[1:]))\\n        \\n        tag = [2]*N\\n        tag = tuple(tag)\\n        dp(0,0,tag)\\n        return Max\\n\\t\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        N = len(statements)\\n        Max = 0\\n        @lru_cache(None)\\n        def dp(i,good,tag):\\n            nonlocal Max\\n            Tag = list(tag)\\n            if i>=N:\\n                Max = max(Max,good)\\n                return True\\n            if Tag[0] == 0 or Tag[0] == 2:\\n                conflict = 0\\n                for j in range(i+1,N):\\n                    if statements[j][i] == 1:\\n                        if Tag[j-i] == 1:\\n                            conflict = 1\\n                            break\\n                        Tag[j-i] = 0\\n                if not conflict:\\n                    dp(i+1,good,tuple(Tag[1:]))\\n                if Tag[0] == 0:\\n                    return True\\n            \\n            Tag = list(tag)\\n            conflict = 0\\n            for j in range(i+1,N):\\n                if (statements[i][j] == 0 and Tag[j-i] == 1) or (statements[i][j] == 1 and Tag[j-i] == 0) or (statements[i][j] == 1 and statements[j][i] == 0) :\\n                    conflict = 1\\n                    break\\n            if not conflict:\\n                for j in range(i+1,N):\\n                    if statements[i][j] < 2:\\n                        Tag[j-i] = statements[i][j]\\n                    if statements[j][i] == 0:\\n                        Tag[j-i] = 0\\n                dp(i+1,good+1,tuple(Tag[1:]))\\n        \\n        tag = [2]*N\\n        tag = tuple(tag)\\n        dp(0,0,tag)\\n        return Max\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 1791056,
                "title": "gg-bois-ii",
                "content": "gg bois II good going",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1791055,
                "title": "gg-bois",
                "content": "gg bois good going",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1768345,
                "title": "rust-backtracking",
                "content": "```\\nimpl Solution {\\n    pub fn maximum_good(statements: Vec<Vec<i32>>) -> i32 {\\n        let mut res = 0;\\n        let mut assumptions = vec![];\\n\\n        Solution::dfs(&statements, &mut assumptions, 0, 0, &mut res);\\n\\n        res\\n    }\\n\\n    fn dfs(\\n        statements: &Vec<Vec<i32>>,\\n        assumptions: &mut Vec<i32>,\\n        index: usize,\\n        count: i32,\\n        res: &mut i32,\\n    ) {\\n        // End of tree\\n        if index == statements.len() {\\n            if Solution::is_valid(statements, assumptions) {\\n                *res = std::cmp::max(*res, count);\\n            }\\n            return \\n        }\\n\\n        // Assuming good\\n        assumptions.push(1);\\n        Solution::dfs(statements, assumptions, index + 1, count + 1, res);\\n        assumptions.pop();\\n\\n        // Assuming bad\\n        assumptions.push(0);\\n        Solution::dfs(statements, assumptions, index + 1, count, res);\\n        assumptions.pop();\\n    }\\n\\n    fn is_valid(statements: &Vec<Vec<i32>>, assumptions: &Vec<i32>) -> bool {\\n        for i in 0..assumptions.len() {\\n            if assumptions[i] == 1 {\\n                for j in 0..assumptions.len() {\\n                    if statements[i][j] != 2 && statements[i][j] != assumptions[j] {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n\\n        true\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn maximum_good(statements: Vec<Vec<i32>>) -> i32 {\\n        let mut res = 0;\\n        let mut assumptions = vec![];\\n\\n        Solution::dfs(&statements, &mut assumptions, 0, 0, &mut res);\\n\\n        res\\n    }\\n\\n    fn dfs(\\n        statements: &Vec<Vec<i32>>,\\n        assumptions: &mut Vec<i32>,\\n        index: usize,\\n        count: i32,\\n        res: &mut i32,\\n    ) {\\n        // End of tree\\n        if index == statements.len() {\\n            if Solution::is_valid(statements, assumptions) {\\n                *res = std::cmp::max(*res, count);\\n            }\\n            return \\n        }\\n\\n        // Assuming good\\n        assumptions.push(1);\\n        Solution::dfs(statements, assumptions, index + 1, count + 1, res);\\n        assumptions.pop();\\n\\n        // Assuming bad\\n        assumptions.push(0);\\n        Solution::dfs(statements, assumptions, index + 1, count, res);\\n        assumptions.pop();\\n    }\\n\\n    fn is_valid(statements: &Vec<Vec<i32>>, assumptions: &Vec<i32>) -> bool {\\n        for i in 0..assumptions.len() {\\n            if assumptions[i] == 1 {\\n                for j in 0..assumptions.len() {\\n                    if statements[i][j] != 2 && statements[i][j] != assumptions[j] {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n\\n        true\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1739292,
                "title": "2151-maximum-good-people-based-on-statements",
                "content": "class Solution {\\n    public int maximumGood(int[][] statements) {\\n        return DFS(0,new int[statements.length],statements);\\n    }\\n    private int DFS(int idx,int[] pos,int[][] statements){\\n        if(idx==pos.length){\\n            if(check(pos,statements)){\\n                int count=0;\\n                for(int i:pos){\\n                    count+=i;\\n                }\\n                return count;\\n            }\\n            else{\\n                return 0;\\n            }\\n        }\\n        \\n        int tans1=DFS(idx+1,pos,statements);\\n        pos[idx]=1;\\n        int tans2=DFS(idx+1,pos,statements);\\n        pos[idx]=0;\\n        \\n        return Math.max(tans1,tans2);\\n    }\\n    private boolean check(int[] pos,int[][] statements){\\n        for(int i=0;i<pos.length;i++){\\n            \\n            if(pos[i]==0) continue;\\n            \\n            for(int j=0;j<pos.length;j++){\\n                if(statements[i][j]==2) continue;\\n                if(statements[i][j]!=pos[j]){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maximumGood(int[][] statements) {\\n        return DFS(0,new int[statements.length],statements);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1728142,
                "title": "c-backtrack-with-bitmask-fast-and-easy-solution-with-comments",
                "content": "use one bitmap and one bitmask per person\\nbitmap, bad[i][j] = 1 if person i said person j is bad\\nbitmask, said[i][j] = 1 if person i said something about person j\\n\\n(bad1 ^ bad2) & said1 & said2 ==  0 means that there is no conflict between two statements\\n\\n```\\nint maximumGood(vector<vector<int>>& A) {\\n        int N = A.size();\\n        vector<int> bad( N ), said( N, (1<<N)-1 );\\n        for( int i = 0; i < N; ++i ) {\\n            for( int j = 0; j < N; ++j ) {\\n                if( A[i][j] == 0 ) {\\n\\t\\t\\t\\t    // person i said person j is bad\\n                    bad[i] |= ( 1 << j );\\n                } else if( A[i][j] == 2 ) {\\n\\t\\t\\t\\t    // person i did not say anything about person j\\n                    said[i] &= ~( 1 << j );\\n                }\\n            }\\n        }\\n        int rv = 0;\\n        function<void(int,int,int,int)> backtrack = [&]( int currBad, int currSaid, int cnt, int idx ) {\\n            if( idx == N ) {\\n                rv = max( rv, cnt );\\n                return;\\n            }\\n\\t\\t\\t// if it is ok to guess person, idx, is good.\\n            if( ((currBad ^ bad[idx]) & currSaid & (said[idx] | (1<<idx))) == 0 ) {\\n                backtrack( currBad | bad[idx], currSaid | (said[idx] | (1<<idx)), cnt + 1, idx + 1 );\\n            }\\n\\t\\t\\t// if it is ok to guess person, idx, is bad.\\n            if ( ((currBad ^ (1<<idx)) & currSaid & (1<<idx)) == 0 ) {\\n                backtrack( currBad | (1<<idx), currSaid | (1<<idx), cnt, idx + 1 );\\n            }\\n        };\\n        backtrack( 0, 0, 0, 0 );\\n        return rv;\\n    }\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nint maximumGood(vector<vector<int>>& A) {\\n        int N = A.size();\\n        vector<int> bad( N ), said( N, (1<<N)-1 );\\n        for( int i = 0; i < N; ++i ) {\\n            for( int j = 0; j < N; ++j ) {\\n                if( A[i][j] == 0 ) {\\n\\t\\t\\t\\t    // person i said person j is bad\\n                    bad[i] |= ( 1 << j );\\n                } else if( A[i][j] == 2 ) {\\n\\t\\t\\t\\t    // person i did not say anything about person j\\n                    said[i] &= ~( 1 << j );\\n                }\\n            }\\n        }\\n        int rv = 0;\\n        function<void(int,int,int,int)> backtrack = [&]( int currBad, int currSaid, int cnt, int idx ) {\\n            if( idx == N ) {\\n                rv = max( rv, cnt );\\n                return;\\n            }\\n\\t\\t\\t// if it is ok to guess person, idx, is good.\\n            if( ((currBad ^ bad[idx]) & currSaid & (said[idx] | (1<<idx))) == 0 ) {\\n                backtrack( currBad | bad[idx], currSaid | (said[idx] | (1<<idx)), cnt + 1, idx + 1 );\\n            }\\n\\t\\t\\t// if it is ok to guess person, idx, is bad.\\n            if ( ((currBad ^ (1<<idx)) & currSaid & (1<<idx)) == 0 ) {\\n                backtrack( currBad | (1<<idx), currSaid | (1<<idx), cnt, idx + 1 );\\n            }\\n        };\\n        backtrack( 0, 0, 0, 0 );\\n        return rv;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1726175,
                "title": "python-bit-manipulation-detailed-explanation",
                "content": "Since n is very small (15), try all possible combination and check if the current combination does not contradict with the statements. Store the max good people if the current combination is valid.\\n\\n```\\nclass Solution:\\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        n = len(statements)\\n        # total possibilties\\n        total_comb = 2 ** n\\n        ans = 0\\n        \\n        # calculate total  set bit (i.e, no of good people)\\n        def set_bit(x):\\n            c = 0\\n            while x > 0:\\n                if x & 1:\\n                    c += 1\\n                x = x >> 1\\n            return c\\n        \\n        # find jth bit value\\n        def jth_bit(x,j):\\n            return x & (1<<j) > 0\\n        \\n        # check if the current combination is valid or not\\n        def is_valid(x):\\n            for i in range(n):\\n                for j in range(n):\\n                    if statements[i][j] == 2:\\n                        continue\\n                    ii = jth_bit(x, i) # i\\'th is good or bad\\n                    jj = jth_bit(x, j) # j\\'th is good or bad\\n                    \\n                    # only condradict when ii is a good person and statement made by him about j \\n                    # does not match with current combination\\n                    if jj != statements[i][j] and ii: \\n                        return False\\n            return True\\n                        \\n        # iterate all possible combination       \\n        for i in range(total_comb-1, -1, -1):\\n            if is_valid(i):\\n                curr = set_bit(i)\\n                ans = max(ans, curr)\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        n = len(statements)\\n        # total possibilties\\n        total_comb = 2 ** n\\n        ans = 0\\n        \\n        # calculate total  set bit (i.e, no of good people)\\n        def set_bit(x):\\n            c = 0\\n            while x > 0:\\n                if x & 1:\\n                    c += 1\\n                x = x >> 1\\n            return c\\n        \\n        # find jth bit value\\n        def jth_bit(x,j):\\n            return x & (1<<j) > 0\\n        \\n        # check if the current combination is valid or not\\n        def is_valid(x):\\n            for i in range(n):\\n                for j in range(n):\\n                    if statements[i][j] == 2:\\n                        continue\\n                    ii = jth_bit(x, i) # i\\'th is good or bad\\n                    jj = jth_bit(x, j) # j\\'th is good or bad\\n                    \\n                    # only condradict when ii is a good person and statement made by him about j \\n                    # does not match with current combination\\n                    if jj != statements[i][j] and ii: \\n                        return False\\n            return True\\n                        \\n        # iterate all possible combination       \\n        for i in range(total_comb-1, -1, -1):\\n            if is_valid(i):\\n                curr = set_bit(i)\\n                ans = max(ans, curr)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1724794,
                "title": "documented-depth-first-search-until-contradiction-typescript",
                "content": "```\\nenum GBU {\\n  Good = 1,\\n  Bad = 0,\\n  Unknown = 2,\\n}\\n\\n// Calculate the new status for each individual assuming a particular individual is good and\\n// all their statements are taken into account. Returns undefined if there is a logical\\n// contradiction. For example, if we assume person i is good and they said person j is bad but\\n// and we already know person j is good, that is a contradiction.\\nconst ifGood = (statements: GBU[][], status: GBU[], i: number): GBU[] | undefined => {\\n  if (status[i] === GBU.Bad) return undefined;\\n  const result = status.slice(); // Copy current status so we can return an unmutated copy.\\n  result[i] = GBU.Good;\\n  for (let j = 0; j < statements.length; j++) {\\n    const s = statements[i][j];\\n    if ((s === GBU.Good && status[j] === GBU.Bad) || (s === GBU.Bad && status[j] === GBU.Good)) {\\n      return undefined;\\n    } else if (s !== GBU.Unknown) {\\n      result[j] = s;\\n    }\\n  }\\n  return result;\\n};\\n\\n// Calculate the new status for each individual assuming a particular individual is bad.\\nconst ifBad = (statements: GBU[][], status: GBU[], i: number): GBU[] | undefined => {\\n  if (status[i] === GBU.Good) return undefined;\\n  const result = status.slice();\\n  result[i] = GBU.Bad;\\n  return result;\\n};\\n\\n// Utility function that maps a possibly undefined value to another value.\\nconst mapOption = <A, B>(a: A | undefined, f: (a: A) => B) => (a === undefined ? undefined : f(a));\\n\\n// Recursively calculates the maximum number of good people. Iterates through the statements\\n// each person makes, in order. Once we get to person i, the maximum is the max of person\\n// i being good or person i being bad. Each path is followed until a logical contradication\\n// occurs, which short-circuits that path of the calculation and returns 0.\\nconst maxGood = (statements: GBU[][], status: GBU[], i: number): number => {\\n  if (i === statements.length)\\n    return status.reduce((total, x) => (x === GBU.Good ? total + 1 : total), 0);\\n  return Math.max(\\n    mapOption(ifGood(statements, status, i), (x) => maxGood(statements, x, i + 1)) ?? 0,\\n    mapOption(ifBad(statements, status, i), (x) => maxGood(statements, x, i + 1)) ?? 0\\n  );\\n};\\n\\n// Start with person 0 and assume every person\\'s status is Unknown.\\nconst maximumGood = (statements: GBU[][]): number =>\\n  maxGood(statements, new Array(statements.length).fill(GBU.Unknown), 0);\\n```",
                "solutionTags": [],
                "code": "```\\nenum GBU {\\n  Good = 1,\\n  Bad = 0,\\n  Unknown = 2,\\n}\\n\\n// Calculate the new status for each individual assuming a particular individual is good and\\n// all their statements are taken into account. Returns undefined if there is a logical\\n// contradiction. For example, if we assume person i is good and they said person j is bad but\\n// and we already know person j is good, that is a contradiction.\\nconst ifGood = (statements: GBU[][], status: GBU[], i: number): GBU[] | undefined => {\\n  if (status[i] === GBU.Bad) return undefined;\\n  const result = status.slice(); // Copy current status so we can return an unmutated copy.\\n  result[i] = GBU.Good;\\n  for (let j = 0; j < statements.length; j++) {\\n    const s = statements[i][j];\\n    if ((s === GBU.Good && status[j] === GBU.Bad) || (s === GBU.Bad && status[j] === GBU.Good)) {\\n      return undefined;\\n    } else if (s !== GBU.Unknown) {\\n      result[j] = s;\\n    }\\n  }\\n  return result;\\n};\\n\\n// Calculate the new status for each individual assuming a particular individual is bad.\\nconst ifBad = (statements: GBU[][], status: GBU[], i: number): GBU[] | undefined => {\\n  if (status[i] === GBU.Good) return undefined;\\n  const result = status.slice();\\n  result[i] = GBU.Bad;\\n  return result;\\n};\\n\\n// Utility function that maps a possibly undefined value to another value.\\nconst mapOption = <A, B>(a: A | undefined, f: (a: A) => B) => (a === undefined ? undefined : f(a));\\n\\n// Recursively calculates the maximum number of good people. Iterates through the statements\\n// each person makes, in order. Once we get to person i, the maximum is the max of person\\n// i being good or person i being bad. Each path is followed until a logical contradication\\n// occurs, which short-circuits that path of the calculation and returns 0.\\nconst maxGood = (statements: GBU[][], status: GBU[], i: number): number => {\\n  if (i === statements.length)\\n    return status.reduce((total, x) => (x === GBU.Good ? total + 1 : total), 0);\\n  return Math.max(\\n    mapOption(ifGood(statements, status, i), (x) => maxGood(statements, x, i + 1)) ?? 0,\\n    mapOption(ifBad(statements, status, i), (x) => maxGood(statements, x, i + 1)) ?? 0\\n  );\\n};\\n\\n// Start with person 0 and assume every person\\'s status is Unknown.\\nconst maximumGood = (statements: GBU[][]): number =>\\n  maxGood(statements, new Array(statements.length).fill(GBU.Unknown), 0);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1721209,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumGood(vector<vector<int>>& sta) {\\n        int n = sta.size();\\n        int sol = 0;\\n        for(int mask = 0; mask < (1 << n); mask++) {\\n            \\n            bool isPossible = true;\\n            for(int i = 0; i < n; i++) {\\n                for(int j = 0; j < n; j++) {\\n                    if(mask & (1 << i)) {\\n                        if(mask & (1 << j)) {\\n                            if(sta[i][j] == 2) continue;\\n                            if(sta[i][j] == 0) {\\n                                isPossible = false;\\n                                i = n;\\n                                break;\\n                            }\\n                        }\\n                        else {\\n                            if(sta[i][j] == 2) continue;\\n                            if(sta[i][j] == 1) {\\n                                isPossible = false;\\n                                i = n;\\n                                break;\\n                            }\\n                        }\\n                    }\\n                   \\n                }\\n            }\\n            if(isPossible) {\\n                sol = max(sol, __builtin_popcount(mask));\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGood(vector<vector<int>>& sta) {\\n        int n = sta.size();\\n        int sol = 0;\\n        for(int mask = 0; mask < (1 << n); mask++) {\\n            \\n            bool isPossible = true;\\n            for(int i = 0; i < n; i++) {\\n                for(int j = 0; j < n; j++) {\\n                    if(mask & (1 << i)) {\\n                        if(mask & (1 << j)) {\\n                            if(sta[i][j] == 2) continue;\\n                            if(sta[i][j] == 0) {\\n                                isPossible = false;\\n                                i = n;\\n                                break;\\n                            }\\n                        }\\n                        else {\\n                            if(sta[i][j] == 2) continue;\\n                            if(sta[i][j] == 1) {\\n                                isPossible = false;\\n                                i = n;\\n                                break;\\n                            }\\n                        }\\n                    }\\n                   \\n                }\\n            }\\n            if(isPossible) {\\n                sol = max(sol, __builtin_popcount(mask));\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1719849,
                "title": "python-easy-to-understand-dfs",
                "content": "The idea is simple. Everyone can be either good or bad. We track the cases in dfs and stop when we encounter contradiction, e.g. no valid labels in the corresponding sublist in res.\\n\\n\\n```\\nclass Solution(object):\\n    def maximumGood(self, statements):\\n        \"\"\"\\n        :type statements: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        n = len(statements)\\n        def dfs(i, indicator, res = [[\"b\", \"g\"] for _ in range(n)]):\\n            # print(i, indicator, res)\\n            \\n            if i >= n:\\n                return sum([1 for r in res if \"g\" in r ])\\n\\n            if res[i] == [] or indicator not in res[i]:\\n                return 0\\n            \\n            res[i] = [indicator]\\n            if indicator == \"g\":\\n                for j in range(n):\\n                    if statements[i][j] == 1:\\n                        res[j] = list(set(res[j]) & set([\"g\"]))\\n                    elif statements[i][j] == 0:\\n                        res[j] = list(set(res[j]) & set([\"b\"]))\\n                    if res[j] == []:\\n                        # print(0, indicator, res, res[j])\\n                        return 0\\n                        \\n                for j in range(n):\\n                    if statements[j][i] == 0:\\n                        res[j] = list(set(res[j]) & set([\"b\"]))\\n                    if res[j] == []:\\n                        # print(0, indicator, res, res[j])                        \\n                        return 0\\n                if i+1 < n and res[i+1] != []:\\n                    # print(res)\\n                    return max(dfs(i+1, ind, list(res)) for ind in res[i+1])\\n                elif i+1 >= n:\\n                    return dfs(i+1, \"\", res)\\n                else:\\n                    # print(0, indicator, res, res[j])                    \\n                    return 0\\n                \\n            elif indicator == \"b\":\\n                for j in range(n):\\n                    if statements[j][i] == 1:\\n                        res[j] = list(set(res[j]) & set([\"b\"]))\\n                    if res[j] == []:\\n                        return 0 \\n            \\n                if i+1 < n and res[i+1] != []:\\n                    # print(res)\\n                    return max(dfs(i+1, ind, list(res)) for ind in res[i+1])\\n                elif i+1 >= n:\\n                    return dfs(i+1, \"\", res)\\n                else:\\n                    return 0\\n            else:\\n                return -9999\\n                \\n                \\n        return max([dfs(0, indicator, res = [[\"b\", \"g\"] for _ in range(n)]) for indicator in cands])\\n                    \\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def maximumGood(self, statements):\\n        \"\"\"\\n        :type statements: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        n = len(statements)\\n        def dfs(i, indicator, res = [[\"b\", \"g\"] for _ in range(n)]):\\n            # print(i, indicator, res)\\n            \\n            if i >= n:\\n                return sum([1 for r in res if \"g\" in r ])\\n\\n            if res[i] == [] or indicator not in res[i]:\\n                return 0\\n            \\n            res[i] = [indicator]\\n            if indicator == \"g\":\\n                for j in range(n):\\n                    if statements[i][j] == 1:\\n                        res[j] = list(set(res[j]) & set([\"g\"]))\\n                    elif statements[i][j] == 0:\\n                        res[j] = list(set(res[j]) & set([\"b\"]))\\n                    if res[j] == []:\\n                        # print(0, indicator, res, res[j])\\n                        return 0\\n                        \\n                for j in range(n):\\n                    if statements[j][i] == 0:\\n                        res[j] = list(set(res[j]) & set([\"b\"]))\\n                    if res[j] == []:\\n                        # print(0, indicator, res, res[j])                        \\n                        return 0\\n                if i+1 < n and res[i+1] != []:\\n                    # print(res)\\n                    return max(dfs(i+1, ind, list(res)) for ind in res[i+1])\\n                elif i+1 >= n:\\n                    return dfs(i+1, \"\", res)\\n                else:\\n                    # print(0, indicator, res, res[j])                    \\n                    return 0\\n                \\n            elif indicator == \"b\":\\n                for j in range(n):\\n                    if statements[j][i] == 1:\\n                        res[j] = list(set(res[j]) & set([\"b\"]))\\n                    if res[j] == []:\\n                        return 0 \\n            \\n                if i+1 < n and res[i+1] != []:\\n                    # print(res)\\n                    return max(dfs(i+1, ind, list(res)) for ind in res[i+1])\\n                elif i+1 >= n:\\n                    return dfs(i+1, \"\", res)\\n                else:\\n                    return 0\\n            else:\\n                return -9999\\n                \\n                \\n        return max([dfs(0, indicator, res = [[\"b\", \"g\"] for _ in range(n)]) for indicator in cands])\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1719837,
                "title": "python-backtracking-beat-95",
                "content": "```\\nclass Solution:\\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        n = len(statements)\\n        self.is_good = [None] * n # Store good status\\n        self.ret_val = 0\\n        \\n        def backtrack(ind):\\n            if ind == n:\\n                self.ret_val = max(self.ret_val, sum(self.is_good))\\n                return\\n            \\n            prev = self.is_good.copy()\\n            \\n            # Handling good person\\n            if (self.is_good[ind] is None) or (self.is_good[ind] == 1):\\n                self.is_good[ind] = 1\\n                contradict = False\\n                \\n                for i in range(0, n):\\n                    if statements[ind][i] != 2 and self.is_good[i] is not None and statements[ind][i] != self.is_good[i]:\\n                        contradict = True\\n                        break\\n                    if statements[ind][i] != 2:\\n                        self.is_good[i] = statements[ind][i]    \\n                        \\n                if contradict is False:\\n                    backtrack(ind+1)\\n                    \\n                self.is_good = prev.copy()\\n            \\n            # Handling bad person\\n            if (self.is_good[ind] is None) or (self.is_good[ind] == 0):\\n                self.is_good[ind] = 0\\n                \\n                backtrack(ind+1)\\n                \\n                self.is_good = prev.copy()\\n                \\n        backtrack(0)\\n         \\n        return self.ret_val\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        n = len(statements)\\n        self.is_good = [None] * n # Store good status\\n        self.ret_val = 0\\n        \\n        def backtrack(ind):\\n            if ind == n:\\n                self.ret_val = max(self.ret_val, sum(self.is_good))\\n                return\\n            \\n            prev = self.is_good.copy()\\n            \\n            # Handling good person\\n            if (self.is_good[ind] is None) or (self.is_good[ind] == 1):\\n                self.is_good[ind] = 1\\n                contradict = False\\n                \\n                for i in range(0, n):\\n                    if statements[ind][i] != 2 and self.is_good[i] is not None and statements[ind][i] != self.is_good[i]:\\n                        contradict = True\\n                        break\\n                    if statements[ind][i] != 2:\\n                        self.is_good[i] = statements[ind][i]    \\n                        \\n                if contradict is False:\\n                    backtrack(ind+1)\\n                    \\n                self.is_good = prev.copy()\\n            \\n            # Handling bad person\\n            if (self.is_good[ind] is None) or (self.is_good[ind] == 0):\\n                self.is_good[ind] = 0\\n                \\n                backtrack(ind+1)\\n                \\n                self.is_good = prev.copy()\\n                \\n        backtrack(0)\\n         \\n        return self.ret_val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1718400,
                "title": "runtime-331-ms-faster-than-49-71-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    string generate(int num,int n)\\n    {\\n        string temp=\"\";\\n        while(num)\\n        {\\n            int a=num%2;\\n            temp += (a+\\'0\\');\\n            num = num >> 1;\\n        }\\n        while(temp.length()!=n)\\n        {\\n            temp += \"0\";\\n        }\\n        reverse(temp.begin(),temp.end());\\n        return temp;\\n    }\\n    int maximumGood(vector<vector<int>>& statements) {\\n        int n=statements.size();\\n        int max1=0;\\n        for(int p=0;p<pow(2,n);p++)\\n        {\\n            string s = generate(p,n);\\n            bool flag=true;\\n            for(int i=0;i<s.length();i++)\\n            {\\n                if(s[i]==\\'0\\') continue;\\n                for(int j=0;j<n;j++)\\n                {\\n                    int z = statements[i][j];\\n                    if(z == 2)continue;\\n                    if(s[j]==\\'0\\' and z == 1 || s[j]==\\'1\\' and z==0)\\n                    {\\n                        flag=false;\\n                        break;\\n                    }\\n                }\\n                if(flag==false)break;\\n            }\\n            if(flag)\\n            {\\n                int count=0;\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(s[j]==\\'1\\')\\n                    {\\n                        count++;\\n                    }\\n                }\\n                max1 = max(max1,count);\\n            }\\n            \\n        }\\n        return max1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string generate(int num,int n)\\n    {\\n        string temp=\"\";\\n        while(num)\\n        {\\n            int a=num%2;\\n            temp += (a+\\'0\\');\\n            num = num >> 1;\\n        }\\n        while(temp.length()!=n)\\n        {\\n            temp += \"0\";\\n        }\\n        reverse(temp.begin(),temp.end());\\n        return temp;\\n    }\\n    int maximumGood(vector<vector<int>>& statements) {\\n        int n=statements.size();\\n        int max1=0;\\n        for(int p=0;p<pow(2,n);p++)\\n        {\\n            string s = generate(p,n);\\n            bool flag=true;\\n            for(int i=0;i<s.length();i++)\\n            {\\n                if(s[i]==\\'0\\') continue;\\n                for(int j=0;j<n;j++)\\n                {\\n                    int z = statements[i][j];\\n                    if(z == 2)continue;\\n                    if(s[j]==\\'0\\' and z == 1 || s[j]==\\'1\\' and z==0)\\n                    {\\n                        flag=false;\\n                        break;\\n                    }\\n                }\\n                if(flag==false)break;\\n            }\\n            if(flag)\\n            {\\n                int count=0;\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(s[j]==\\'1\\')\\n                    {\\n                        count++;\\n                    }\\n                }\\n                max1 = max(max1,count);\\n            }\\n            \\n        }\\n        return max1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1717452,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\n    bool isGood(int n, int index){\\n        return (n>>index)&1;\\n    }\\npublic:\\n    int maximumGood(vector<vector<int>>& statements) {\\n        int n=statements.size();\\n        int ans=0;\\n        int comb = pow(2, n);\\n        \\n        for(int i=0; i<comb; i++){\\n            bool isValid = true;\\n            int counter=0;\\n            for(int person=0; person<n; person++){\\n                if(!isGood(i, person))\\n                    continue;\\n                counter++;\\n                for(int j=0; j<n; j++){\\n                    if((!isGood(i, j) && statements[person][j]==1) || (isGood(i, j) && statements[person][j]==0)){\\n                        isValid=false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(isValid)\\n                ans = max(ans, counter);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    bool isGood(int n, int index){\\n        return (n>>index)&1;\\n    }\\npublic:\\n    int maximumGood(vector<vector<int>>& statements) {\\n        int n=statements.size();\\n        int ans=0;\\n        int comb = pow(2, n);\\n        \\n        for(int i=0; i<comb; i++){\\n            bool isValid = true;\\n            int counter=0;\\n            for(int person=0; person<n; person++){\\n                if(!isGood(i, person))\\n                    continue;\\n                counter++;\\n                for(int j=0; j<n; j++){\\n                    if((!isGood(i, j) && statements[person][j]==1) || (isGood(i, j) && statements[person][j]==0)){\\n                        isValid=false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(isValid)\\n                ans = max(ans, counter);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1717051,
                "title": "scala-functional-solution-using-bitsets",
                "content": "```\\n  def maximumGood(statements: Array[Array[Int]]): Int = {\\n    val n = statements.length\\n\\n    def statementsHoldForPerson(bitset: Int, i: Int) =\\n      (0 until n).forall(j => statements(i)(j) == 2 || statements(i)(j) == (bitset >> j & 1))\\n\\n    def statementsHoldForAll(bitset: Int): Boolean =\\n      (0 until n)\\n        .filter(i => (bitset >> i & 1) == 1)\\n        .forall(i => statementsHoldForPerson(bitset, i))\\n\\n    @annotation.tailrec\\n    def countOneBits(bitset: Int, bits: Int): Int =\\n      if (bitset == 0) bits\\n      else countOneBits(bitset >> 1, bits + (bitset & 1))\\n\\n    (0 until 1 << n).collect {\\n      case bitset if statementsHoldForAll(bitset) =>\\n        countOneBits(bitset, 0)\\n    }.max\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n  def maximumGood(statements: Array[Array[Int]]): Int = {\\n    val n = statements.length\\n\\n    def statementsHoldForPerson(bitset: Int, i: Int) =\\n      (0 until n).forall(j => statements(i)(j) == 2 || statements(i)(j) == (bitset >> j & 1))\\n\\n    def statementsHoldForAll(bitset: Int): Boolean =\\n      (0 until n)\\n        .filter(i => (bitset >> i & 1) == 1)\\n        .forall(i => statementsHoldForPerson(bitset, i))\\n\\n    @annotation.tailrec\\n    def countOneBits(bitset: Int, bits: Int): Int =\\n      if (bitset == 0) bits\\n      else countOneBits(bitset >> 1, bits + (bitset & 1))\\n\\n    (0 until 1 << n).collect {\\n      case bitset if statementsHoldForAll(bitset) =>\\n        countOneBits(bitset, 0)\\n    }.max\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1717017,
                "title": "c-with-time-of-o-2-n-n-and-space-of-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumGood(vector<vector<int>>& statements) {\\n        vector<int> goods(statements.size(), 0);\\n        vector<int> bads(statements.size(), 0);\\n        for (int idx = 0; idx < statements.size(); ++idx) {\\n            queue<int> q;\\n            q.push(idx);\\n            \\n            int &good = goods[idx];\\n            good = 1 << idx;\\n            \\n            while (!q.empty()) {\\n                int i = q.front();\\n                q.pop();\\n                \\n                for (int j = 0; j < statements.size(); ++j) {\\n                    if (statements[i][j] == 1 and (good & (1 << j)) == 0) {\\n                        q.push(j);\\n                        good |= 1 << j;\\n                    }\\n                }\\n            }\\n            \\n            int &bad = bads[idx];\\n            for (int i = 0; i < statements.size(); ++i) {\\n                if (statements[idx][i] == 0)\\n                    bad |= 1 << i;\\n            }\\n        }\\n        int ans = 0;\\n        for (int k = 1; k < (1 << statements.size()); ++k) {\\n            if (__builtin_popcount(k) <= ans) {\\n                continue;\\n            }\\n            \\n            int believe = 0;\\n            for (int i = 0; i < statements.size(); ++i) {\\n                if (k & (1 << i)) {\\n                    believe |= goods[i];\\n                }\\n            }\\n            int liar = 0;\\n            for (int i = 0; i < statements.size(); ++i) {\\n                if (believe & (1 << i)) {\\n                    liar |= bads[i];\\n                }\\n            }\\n            if ((believe & liar) == 0) {\\n                ans = __builtin_popcount(believe);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGood(vector<vector<int>>& statements) {\\n        vector<int> goods(statements.size(), 0);\\n        vector<int> bads(statements.size(), 0);\\n        for (int idx = 0; idx < statements.size(); ++idx) {\\n            queue<int> q;\\n            q.push(idx);\\n            \\n            int &good = goods[idx];\\n            good = 1 << idx;\\n            \\n            while (!q.empty()) {\\n                int i = q.front();\\n                q.pop();\\n                \\n                for (int j = 0; j < statements.size(); ++j) {\\n                    if (statements[i][j] == 1 and (good & (1 << j)) == 0) {\\n                        q.push(j);\\n                        good |= 1 << j;\\n                    }\\n                }\\n            }\\n            \\n            int &bad = bads[idx];\\n            for (int i = 0; i < statements.size(); ++i) {\\n                if (statements[idx][i] == 0)\\n                    bad |= 1 << i;\\n            }\\n        }\\n        int ans = 0;\\n        for (int k = 1; k < (1 << statements.size()); ++k) {\\n            if (__builtin_popcount(k) <= ans) {\\n                continue;\\n            }\\n            \\n            int believe = 0;\\n            for (int i = 0; i < statements.size(); ++i) {\\n                if (k & (1 << i)) {\\n                    believe |= goods[i];\\n                }\\n            }\\n            int liar = 0;\\n            for (int i = 0; i < statements.size(); ++i) {\\n                if (believe & (1 << i)) {\\n                    liar |= bads[i];\\n                }\\n            }\\n            if ((believe & liar) == 0) {\\n                ans = __builtin_popcount(believe);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1716722,
                "title": "c-using-bit",
                "content": "```\\n int check(vector<vector<int>>& statements,vector<int>&arr)\\n    {\\n        int cnt=0;\\n        for(int i=0;i<statements.size();i++)\\n        {\\n            if(arr[i]==1)\\n            {\\n                for(int j=0;j<statements.size();j++)\\n                {\\n                    if(arr[j] == 0 && statements[i][j]==1)\\n                        return -1;\\n                    if(arr[j]==1 && statements[i][j]==0)\\n                        return -1;\\n                }\\n            }\\n        }\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(arr[i]==1)\\n                cnt++;\\n        }\\n        return cnt;\\n        \\n    }\\n    int maximumGood(vector<vector<int>>& statements) {\\n        \\n        int n=statements.size();\\n        int ans=0;\\n        int t=pow(2,n);\\n        \\n        for(int i=0;i<t;i++)\\n        {\\n            int x=i;\\n            vector<int>arr(n,0);\\n            int s=0;\\n            while(x>0)\\n            {\\n                if(x&1)\\n                {\\n                    arr[s]=1;\\n                }\\n                s++;\\n                x=x>>1;\\n            }\\n            int cnt = check(statements,arr);\\n            if(cnt>ans)\\n                ans=cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\n int check(vector<vector<int>>& statements,vector<int>&arr)\\n    {\\n        int cnt=0;\\n        for(int i=0;i<statements.size();i++)\\n        {\\n            if(arr[i]==1)\\n            {\\n                for(int j=0;j<statements.size();j++)\\n                {\\n                    if(arr[j] == 0 && statements[i][j]==1)\\n                        return -1;\\n                    if(arr[j]==1 && statements[i][j]==0)\\n                        return -1;\\n                }\\n            }\\n        }\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(arr[i]==1)\\n                cnt++;\\n        }\\n        return cnt;\\n        \\n    }\\n    int maximumGood(vector<vector<int>>& statements) {\\n        \\n        int n=statements.size();\\n        int ans=0;\\n        int t=pow(2,n);\\n        \\n        for(int i=0;i<t;i++)\\n        {\\n            int x=i;\\n            vector<int>arr(n,0);\\n            int s=0;\\n            while(x>0)\\n            {\\n                if(x&1)\\n                {\\n                    arr[s]=1;\\n                }\\n                s++;\\n                x=x>>1;\\n            }\\n            int cnt = check(statements,arr);\\n            if(cnt>ans)\\n                ans=cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1716059,
                "title": "simple-solution-c",
                "content": "**Approach :**\\n=>create an array of the same size of the number of people.\\n=>create every combination of the array  \\n        \\n          1) arr[i]=1  indicates person (i) is a good person.\\n          similarly\\n          2) arr[i]=0  indicates person (i) is a bad person.\\n          \\n=>  we have to check whether that will satisfy conditions given in the question \\n      find the number of good persons in that array. then return the maximum value.\\n***solve function :***\\n  => check only the statements made by a good person \\n  => return value if and only if conditions are satisfied.\\n  => else return 0.\\n \\n```\\nclass Solution {\\npublic:\\n    \\n    int solve( int * arr, vector<vector<int>>& A,int size)\\n    {\\n        int ans=0; \\n        for(int i=0;i<size;i++)\\n        {\\n            if(arr[i]==1) // check only the statements made by good person \\n            {\\n                ans++; // number of good persons\\n                for(int j=0;j<size;j++)\\n                {\\n                   if(A[i][j]==1)\\n                   {\\n                       if(arr[j]!=1)return 0; //do not match the reality. \\n                       \\n                   }\\n                    else if(A[i][j]==0)\\n                    {\\n                       if(arr[j]!=0)return 0; //do not match the reality \\n                    }\\n                }\\n            }\\n        }\\n        return ans; //every condition satisfied so return ans\\n    }\\n    int maximumGood(vector<vector<int>>& A) {\\n        int size = A.size(); // number of people ;\\n        \\n        int * arr = new int[size]; // create an array as same size of number of people\\n        \\n        \\n        for(int i=0;i<size;i++)arr[i]=0; // initialise every element of array into zero\\n        \\n       int n= 1<< size; \\n        \\n        int m = INT_MIN;\\n        \\n        /* create every combination of array and check !!!!!!!!!!\\n         => arr[i]=1  indicates person (i) is a good person\\n         similarly\\n         => arr[i]=0  indicates person (i) is a bad person\\n         */\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            int aq= i;\\n            \\n            int j= size-1;\\n            \\n            while(aq>0)\\n            {\\n               arr[j]= aq%2;\\n                \\n                aq= aq/2;\\n                \\n                j--;\\n            }\\n            // created an array of particular combinations and we have to check whether that will satisfy conditions given in the question \\n            // find the number of good persons in that array. If the array satisfies the conditions given in the question then check whether that is the maximum value.\\n            \\n            m = max(m,solve(arr,A,size)); // max value \\n            \\n            for(int i=0;i<size;i++)arr[i]=0; // initialise every element into 0 to create next combination.!!!!!!\\n        }\\n        return m; //return maximum value\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve( int * arr, vector<vector<int>>& A,int size)\\n    {\\n        int ans=0; \\n        for(int i=0;i<size;i++)\\n        {\\n            if(arr[i]==1) // check only the statements made by good person \\n            {\\n                ans++; // number of good persons\\n                for(int j=0;j<size;j++)\\n                {\\n                   if(A[i][j]==1)\\n                   {\\n                       if(arr[j]!=1)return 0; //do not match the reality. \\n                       \\n                   }\\n                    else if(A[i][j]==0)\\n                    {\\n                       if(arr[j]!=0)return 0; //do not match the reality \\n                    }\\n                }\\n            }\\n        }\\n        return ans; //every condition satisfied so return ans\\n    }\\n    int maximumGood(vector<vector<int>>& A) {\\n        int size = A.size(); // number of people ;\\n        \\n        int * arr = new int[size]; // create an array as same size of number of people\\n        \\n        \\n        for(int i=0;i<size;i++)arr[i]=0; // initialise every element of array into zero\\n        \\n       int n= 1<< size; \\n        \\n        int m = INT_MIN;\\n        \\n        /* create every combination of array and check !!!!!!!!!!\\n         => arr[i]=1  indicates person (i) is a good person\\n         similarly\\n         => arr[i]=0  indicates person (i) is a bad person\\n         */\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            int aq= i;\\n            \\n            int j= size-1;\\n            \\n            while(aq>0)\\n            {\\n               arr[j]= aq%2;\\n                \\n                aq= aq/2;\\n                \\n                j--;\\n            }\\n            // created an array of particular combinations and we have to check whether that will satisfy conditions given in the question \\n            // find the number of good persons in that array. If the array satisfies the conditions given in the question then check whether that is the maximum value.\\n            \\n            m = max(m,solve(arr,A,size)); // max value \\n            \\n            for(int i=0;i<size;i++)arr[i]=0; // initialise every element into 0 to create next combination.!!!!!!\\n        }\\n        return m; //return maximum value\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1715898,
                "title": "python-bitmask-time-2-n-n-300ms",
                "content": "```\\nclass Solution:\\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        n = len(statements)\\n        bit = [1<<i for i in range(n)]\\n        \\n        # use two int to record possible good or bad person combination\\n        possible = {(0,0)} # good / bad\\n        for j in range(n):\\n            possible_tmp = set()\\n            \\n            # record which person say good/bad \\n            say_good = 0\\n            say_bad = 0\\n            for i in range(n):\\n                if statements[i][j]==0:\\n                    say_bad |= bit[i]\\n                elif statements[i][j]==1:\\n                    say_good |= bit[i]\\n            \\n            # now check every case im possible\\n            for g,b in possible:\\n                \\n                #case1:\\n                #if j is good\\n                g1 = g | bit[j]\\n                b1 = b | say_bad\\n                if not (g1 & b1): # one person can not be good and bad at the same time \\n                    possible_tmp.add((g1,b1))\\n               \\n                # case2:\\n                # if j is bad\\n                g2 = g \\n                b2 = b | say_good | bit[j]\\n                if not (g2 & b2):\\n                    possible_tmp.add((g2,b2))\\n                \\n            possible = possible_tmp\\n        \\n        # finally, fine the case with minimum bad person\\n        ans = 0\\n        for g,b in possible:\\n            b_count = 0\\n            while b:\\n                b_count+=b%2\\n                b//=2\\n            g_count = n-b_count\\n            ans = max(g_count,ans)\\n\\n        return ans\\n    \\n        # time complexity:  O( N* (N+2^N)) = O( N*2^N)\\n        # space complexity: O(2^N)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        n = len(statements)\\n        bit = [1<<i for i in range(n)]\\n        \\n        # use two int to record possible good or bad person combination\\n        possible = {(0,0)} # good / bad\\n        for j in range(n):\\n            possible_tmp = set()\\n            \\n            # record which person say good/bad \\n            say_good = 0\\n            say_bad = 0\\n            for i in range(n):\\n                if statements[i][j]==0:\\n                    say_bad |= bit[i]\\n                elif statements[i][j]==1:\\n                    say_good |= bit[i]\\n            \\n            # now check every case im possible\\n            for g,b in possible:\\n                \\n                #case1:\\n                #if j is good\\n                g1 = g | bit[j]\\n                b1 = b | say_bad\\n                if not (g1 & b1): # one person can not be good and bad at the same time \\n                    possible_tmp.add((g1,b1))\\n               \\n                # case2:\\n                # if j is bad\\n                g2 = g \\n                b2 = b | say_good | bit[j]\\n                if not (g2 & b2):\\n                    possible_tmp.add((g2,b2))\\n                \\n            possible = possible_tmp\\n        \\n        # finally, fine the case with minimum bad person\\n        ans = 0\\n        for g,b in possible:\\n            b_count = 0\\n            while b:\\n                b_count+=b%2\\n                b//=2\\n            g_count = n-b_count\\n            ans = max(g_count,ans)\\n\\n        return ans\\n    \\n        # time complexity:  O( N* (N+2^N)) = O( N*2^N)\\n        # space complexity: O(2^N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1715664,
                "title": "check-all-combination-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int totset(int mask){\\n        int ans=0;\\n        for(int i=0;i<15;i++)if(mask&(1<<i))ans++;\\n        return ans;\\n    }\\n    \\n    bool check(int mask,vector<vector<int>>& st){\\n        int n=st.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                int ith=((mask&(1<<i))>0);\\n                int jth=((mask&(1<<j))>0);\\n                if(st[i][j]==0 and ith==1 and jth==1)return false;\\n                if(st[i][j]==1 and ith==1 and jth==0)return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int maximumGood(vector<vector<int>>& st) {\\n        int n=st.size();\\n        int mask=(1<<n)-1;\\n        int ans=0;\\n        for(int i=mask;i>=0;i--){\\n            if(check(i,st))ans=max(ans,totset(i));\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int totset(int mask){\\n        int ans=0;\\n        for(int i=0;i<15;i++)if(mask&(1<<i))ans++;\\n        return ans;\\n    }\\n    \\n    bool check(int mask,vector<vector<int>>& st){\\n        int n=st.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                int ith=((mask&(1<<i))>0);\\n                int jth=((mask&(1<<j))>0);\\n                if(st[i][j]==0 and ith==1 and jth==1)return false;\\n                if(st[i][j]==1 and ith==1 and jth==0)return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int maximumGood(vector<vector<int>>& st) {\\n        int n=st.size();\\n        int mask=(1<<n)-1;\\n        int ans=0;\\n        for(int i=mask;i>=0;i--){\\n            if(check(i,st))ans=max(ans,totset(i));\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1715279,
                "title": "c-linq-three-lines-11-lines-o-2-n-n-time-o-n-space",
                "content": "```\\npublic class Solution \\n{\\n    public int MaximumGood(int[][] statements)\\n    {\\n        int[] haveOpinion = (from array in statements\\n                             select Enumerable.Range(0, array.Length).Sum(i => array[i] != 2 ? 1 << i : 0)).ToArray();\\n        \\n        int[] good = (from array in statements\\n                      select Enumerable.Range(0, array.Length).Sum(i => array[i] == 1 ? 1 << i : 0)).ToArray();\\n        \\n        return Enumerable\\n            .Range(0, 1 << statements.Length)\\n            .Where(mask => Enumerable\\n                        .Range(0, statements.Length)\\n                        .Where(i => (mask & (1 << i)) > 0)\\n                        .All(i => good[i] == (mask & haveOpinion[i])))\\n            .Max(mask => Convert.ToString(mask, 2).Count(\\'1\\'.Equals));\\n    }\\n}\\n```\\n\\nMore readable solution: [C# - Short solution (13 lines), O(2^N * N^2) time, O(n) space](https://leetcode.com/problems/maximum-good-people-based-on-statements/discuss/1711541/C-Short-solution-(13-lines)-O(2N-*-N2)-time-O(n)-space)",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int MaximumGood(int[][] statements)\\n    {\\n        int[] haveOpinion = (from array in statements\\n                             select Enumerable.Range(0, array.Length).Sum(i => array[i] != 2 ? 1 << i : 0)).ToArray();\\n        \\n        int[] good = (from array in statements\\n                      select Enumerable.Range(0, array.Length).Sum(i => array[i] == 1 ? 1 << i : 0)).ToArray();\\n        \\n        return Enumerable\\n            .Range(0, 1 << statements.Length)\\n            .Where(mask => Enumerable\\n                        .Range(0, statements.Length)\\n                        .Where(i => (mask & (1 << i)) > 0)\\n                        .All(i => good[i] == (mask & haveOpinion[i])))\\n            .Max(mask => Convert.ToString(mask, 2).Count(\\'1\\'.Equals));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1715143,
                "title": "simple-c-sol-using-bitmask",
                "content": "int maximumGood(vector<vector<int>>& statements) {\\n        int n=statements.size();\\n        int ans=0;\\n        for(int i=1;i<(1<<n);i++){\\n            bool flag=true;\\n            for(int j=0;j<n;j++){\\n                if(!(i&(1<<j))){\\n                    continue;\\n                }\\n                else{\\n                    for(int k=0;k<n;k++){\\n                        if((i&(1<<k)) && statements[j][k]==0){\\n                            flag=false;\\n                            break;\\n                        }\\n                        else if(!(i&(1<<k)) && statements[j][k]==1){\\n                            flag=false;\\n                            break;\\n                        }\\n                    }\\n                    if(flag==false){\\n                        break;\\n                    }\\n                }\\n            }\\n            if(flag){\\n                ans=max(ans,__builtin_popcount(i));\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "int maximumGood(vector<vector<int>>& statements) {\\n        int n=statements.size();\\n        int ans=0;\\n        for(int i=1;i<(1<<n);i++){\\n            bool flag=true;\\n            for(int j=0;j<n;j++){\\n                if(!(i&(1<<j))){\\n                    continue;\\n                }\\n                else{\\n                    for(int k=0;k<n;k++){\\n                        if((i&(1<<k)) && statements[j][k]==0){\\n                            flag=false;\\n                            break;\\n                        }\\n                        else if(!(i&(1<<k)) && statements[j][k]==1){\\n                            flag=false;\\n                            break;\\n                        }\\n                    }\\n                    if(flag==false){\\n                        break;\\n                    }\\n                }\\n            }\\n            if(flag){\\n                ans=max(ans,__builtin_popcount(i));\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1715110,
                "title": "java-solution-brute-force-short-solution",
                "content": "```\\nclass Solution {\\n    public int maximumGood(int[][] s) {\\n        int max = 0;\\n        _xxx:\\n        for (int i = (1 << s.length) - 1; i >= 0; i--) { // i is the mask of good ppl\\n            for (int j = 0; j < s.length; j++)  \\n                if (((1 << j) & i) > 0)  // j is good ppl\\n                    for (int k = 0; k < s.length; k++) // good ppl\\'s statement\\n                        if (s[j][k] == 0 && (i & (1 << k)) > 0 || s[j][k] == 1 && (i & (1 << k)) == 0) continue _xxx; // gool ppl tell truth\\n            max = Math.max(max, Integer.bitCount(i)); // if use grey code, then greed instead of brute force\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maximumGood(int[][] s) {\\n        int max = 0;\\n        _xxx:\\n        for (int i = (1 << s.length) - 1; i >= 0; i--) { // i is the mask of good ppl\\n            for (int j = 0; j < s.length; j++)  \\n                if (((1 << j) & i) > 0)  // j is good ppl\\n                    for (int k = 0; k < s.length; k++) // good ppl\\'s statement\\n                        if (s[j][k] == 0 && (i & (1 << k)) > 0 || s[j][k] == 1 && (i & (1 << k)) == 0) continue _xxx; // gool ppl tell truth\\n            max = Math.max(max, Integer.bitCount(i)); // if use grey code, then greed instead of brute force\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1714039,
                "title": "c-easy-to-understand-simple-efficient-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int helper(int mask,vector<int> &roles)\\n    {\\n        int count=0;\\n        int n=roles.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mask&1)\\n            {\\n                roles[i]=1;\\n                count++;\\n            }\\n            else\\n            roles[i]=0;\\n            mask>>=1;\\n        }\\n        return count;\\n    }\\n    bool valid(vector<int> &roles,vector<vector<int> > &statements)\\n    {\\n        int n=roles.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(roles[i]==0)\\n            continue;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(statements[i][j]==2)\\n                continue;\\n                if(statements[i][j]!=roles[j])\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int maximumGood(vector<vector<int>>& statements) {\\n        int n=statements[0].size();\\n        int combinations=1<<n;\\n        vector<int> roles(n);\\n        int ans=0;\\n        for(int i=1;i<=combinations;i++)\\n        {\\n            int currentGood=helper(i,roles);\\n            if(valid(roles,statements))\\n            {\\n                ans=max(ans,currentGood);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(int mask,vector<int> &roles)\\n    {\\n        int count=0;\\n        int n=roles.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mask&1)\\n            {\\n                roles[i]=1;\\n                count++;\\n            }\\n            else\\n            roles[i]=0;\\n            mask>>=1;\\n        }\\n        return count;\\n    }\\n    bool valid(vector<int> &roles,vector<vector<int> > &statements)\\n    {\\n        int n=roles.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(roles[i]==0)\\n            continue;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(statements[i][j]==2)\\n                continue;\\n                if(statements[i][j]!=roles[j])\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int maximumGood(vector<vector<int>>& statements) {\\n        int n=statements[0].size();\\n        int combinations=1<<n;\\n        vector<int> roles(n);\\n        int ans=0;\\n        for(int i=1;i<=combinations;i++)\\n        {\\n            int currentGood=helper(i,roles);\\n            if(valid(roles,statements))\\n            {\\n                ans=max(ans,currentGood);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713962,
                "title": "python-173ms-100-in-both-memory-and-time-dfs-bitmasks-for-good-bad-folks-separately",
                "content": "**ideas**\\nFirst, change ```statements[i][i]``` to 1 for each i. if we think ```i``` is a good folk, then ```i``` should trust himself as well.\\n\\nNext, we convert the statements to bitmasks for good / bad folks separately. All 2\\'s are ignored.\\n\\nLet ```n = len(statements)```. ```DFS(i, good, bad)``` equals to the maximum number of good floks, where we haven\\'t made decisions for folks from ```i ,..., n-1``` and ```good``` is the the bitmask for all the good folks we found. ```good & bad``` should be ```0```. \\n\\n*induction step:*\\n1. if the guy ```i``` we\\'re checking is already in bad folk mask, we ignore what this guy said.\\n2. if the guy  ```i``` we\\'re checking is already in good folk mask, we include the guy\\'s judgement in the good / bad mask. But after including the new masks, ```good & bad``` has to be ```0``` to for logical consistency.  \\n3. if  ```i``` is not in the bad folk mask nor good folk mask, we can try out boths cases above. Note that if we think ```i``` is bad and is not going to trust what he said, we have to include this guy in the bad folk mask.\\n\\n**codes**\\n\\n```\\nclass Solution:\\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        \\n        n = len(statements)\\n        for i in range(n):\\n            statements[i][i] = 1\\n        good_masks = []\\n        bad_masks = []\\n        \\n        for statement in statements:\\n            good_mask = 0\\n            bad_mask = 0\\n            mask = 1\\n            for flag in statement:\\n                if flag == 0:\\n                    bad_mask += mask\\n                elif flag == 1:\\n                    good_mask += mask\\n                mask <<= 1\\n            good_masks.append(good_mask)\\n            bad_masks.append(bad_mask)\\n        \\n        def DFS(i, good, bad):\\n            if i == n:\\n                return 0       \\n            mask = (1 << i)\\n            if mask & bad == mask:\\n                return DFS(i+1, good, bad)\\n            elif mask & good == mask:\\n                good |= good_masks[i]\\n                bad |= bad_masks[i]\\n                if good & bad == 0:\\n                    return DFS(i+1, good, bad)+1\\n                else:\\n                    return -n\\n            else:\\n                res = DFS(i+1, good, bad|mask)\\n                good |= good_masks[i]\\n                bad |= bad_masks[i]           \\n                if good & bad == 0:\\n                    return max(res, DFS(i+1, good, bad)+1)\\n                else:\\n                    return res\\n        \\n        return DFS(0, 0, 0)",
                "solutionTags": [],
                "code": "```statements[i][i]```\n```i```\n```i```\n```n = len(statements)```\n```DFS(i, good, bad)```\n```i ,..., n-1```\n```good```\n```good & bad```\n```0```\n```i```\n```i```\n```good & bad```\n```0```\n```i```\n```i```",
                "codeTag": "Unknown"
            },
            {
                "id": 1713868,
                "title": "python-3-100-time",
                "content": "![image](https://assets.leetcode.com/users/images/9791523f-e448-4332-bb93-f42f0a0f6584_1642964451.5870588.png)\\n\\nThe most important constraint of this problem is 2 < n < 15. Because there will be maximum 15 persons, which makes the scale small enough for us to try all combinations of good/bad on each person - each combination can be represented using a n-bit mask. \\n\\nNext, to validate a combination, we only need to verify that each good person\\'s statements have no conflict with the mask.\\n\\nTo accelerate, we reversely sort the masks by their 1-counts and traverse them from max to min, such that we can return once the first valid combination encountered.\\n\\nTime complexity O(N^2 * 2^N)\\nSpace complexity O(2^N)\\n\\n```\\nclass Solution:\\n    # generate bit masks with their counts of 1\\n    masks = [[] for _ in range(1 << 15)]\\n    for i in range(1 << 15):\\n        masks[i] = [i, bin(i).count(\\'1\\')]\\n    memo = {}\\n    \\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        def validate(bm):\\n            for i in range(N):\\n                if bm & 1 << i: # only validate good persons\\' statements\\n                    for j in range(N):\\n                        if (statements[i][j] == 1 and not bm & 1 << j) or\\\\\\n                            (not statements[i][j] and bm & 1 << j):\\n                            return False\\n            return True\\n        \\n        N = len(statements)\\n        B = 2 ** N - 1 # N persons, 2 ** N combinations including 0, 2 ** N - 1 non-zero ones\\n        if N in Solution.memo:\\n            bms = Solution.memo[N]\\n        else:\\n            # reversely sort the bitmasks by their 1-counts\\n            bms = sorted(Solution.masks[:B+1], key = lambda x: x[1], reverse = True)\\n            Solution.memo[N] = bms\\n        \\n        for i in range(B):\\n            if validate(bms[i][0]):\\n                # early return once a valid combination found\\n                return bms[i][1]\\n        return 0\\n```\\n",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    # generate bit masks with their counts of 1\\n    masks = [[] for _ in range(1 << 15)]\\n    for i in range(1 << 15):\\n        masks[i] = [i, bin(i).count(\\'1\\')]\\n    memo = {}\\n    \\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        def validate(bm):\\n            for i in range(N):\\n                if bm & 1 << i: # only validate good persons\\' statements\\n                    for j in range(N):\\n                        if (statements[i][j] == 1 and not bm & 1 << j) or\\\\\\n                            (not statements[i][j] and bm & 1 << j):\\n                            return False\\n            return True\\n        \\n        N = len(statements)\\n        B = 2 ** N - 1 # N persons, 2 ** N combinations including 0, 2 ** N - 1 non-zero ones\\n        if N in Solution.memo:\\n            bms = Solution.memo[N]\\n        else:\\n            # reversely sort the bitmasks by their 1-counts\\n            bms = sorted(Solution.masks[:B+1], key = lambda x: x[1], reverse = True)\\n            Solution.memo[N] = bms\\n        \\n        for i in range(B):\\n            if validate(bms[i][0]):\\n                # early return once a valid combination found\\n                return bms[i][1]\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713845,
                "title": "dfs-in-swift",
                "content": "This solution prunes branches that contain conflicts as early as possible, so it is a bit faster than my first try at dfs.\\n\\n```\\nclass Solution {\\n    func maximumGood(_ statements: [[Int]]) -> Int {\\n        let n = statements.count\\n        \\n        var state = Array(repeating: 2, count: n)\\n        \\n        func dfs(_ i: Int, _ count: Int) -> Int {\\n            var newCount = -1\\n            \\n            //check the liar option\\n            state[i] = 0\\n            if i == n - 1 {\\n                if isLegal(i) {\\n                    newCount = max(newCount, count)\\n                }\\n            } else {\\n                if isLegal(i) {\\n                    newCount = max(newCount, dfs(i+1, count))\\n                }\\n            }\\n            \\n            //check the truth teller option \\n            state[i] = 1\\n            if i == n - 1 {\\n                if isLegal(i) && isValid(i) {\\n                    newCount = max(newCount, count+1)\\n                }\\n            } else {\\n                if isLegal(i) && isValid(i) {\\n                    newCount = max(newCount, dfs(i+1, count+1))\\n                }\\n            }\\n            \\n            //reset the state\\n            state[i] = 2\\n            \\n            return newCount\\n            \\n        }\\n        \\n        func isValid(_ i: Int) -> Bool {\\n            for j in 0..<i {\\n                if state[j] == 1 && statements[i][j] == 0 || state[j] == 0 && statements[i][j] == 1 {\\n                    return false\\n                }\\n            }\\n            return true\\n        }\\n        \\n        func isLegal(_ j: Int) -> Bool {\\n            for i in 0..<j {\\n                if state[i] == 1 {\\n                    if state[j] == 1 && statements[i][j] == 0 || state[j] == 0 && statements[i][j] == 1 {\\n                        return false\\n                    }\\n                }\\n            }\\n            return true\\n        }\\n        \\n        return dfs(0,0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    func maximumGood(_ statements: [[Int]]) -> Int {\\n        let n = statements.count\\n        \\n        var state = Array(repeating: 2, count: n)\\n        \\n        func dfs(_ i: Int, _ count: Int) -> Int {\\n            var newCount = -1\\n            \\n            //check the liar option\\n            state[i] = 0\\n            if i == n - 1 {\\n                if isLegal(i) {\\n                    newCount = max(newCount, count)\\n                }\\n            } else {\\n                if isLegal(i) {\\n                    newCount = max(newCount, dfs(i+1, count))\\n                }\\n            }\\n            \\n            //check the truth teller option \\n            state[i] = 1\\n            if i == n - 1 {\\n                if isLegal(i) && isValid(i) {\\n                    newCount = max(newCount, count+1)\\n                }\\n            } else {\\n                if isLegal(i) && isValid(i) {\\n                    newCount = max(newCount, dfs(i+1, count+1))\\n                }\\n            }\\n            \\n            //reset the state\\n            state[i] = 2\\n            \\n            return newCount\\n            \\n        }\\n        \\n        func isValid(_ i: Int) -> Bool {\\n            for j in 0..<i {\\n                if state[j] == 1 && statements[i][j] == 0 || state[j] == 0 && statements[i][j] == 1 {\\n                    return false\\n                }\\n            }\\n            return true\\n        }\\n        \\n        func isLegal(_ j: Int) -> Bool {\\n            for i in 0..<j {\\n                if state[i] == 1 {\\n                    if state[j] == 1 && statements[i][j] == 0 || state[j] == 0 && statements[i][j] == 1 {\\n                        return false\\n                    }\\n                }\\n            }\\n            return true\\n        }\\n        \\n        return dfs(0,0)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713827,
                "title": "python-o-n-2-n-bitmask-pre-processing-and-bit-manipulation-beats-100",
                "content": "Preprocess the statements and use bitmasking to track each person\\'s statements.\\nFor each good person `a`:\\n* check if the person\\'s statements about good people are correct: `mask & good[a] == good[a]`,\\n* check if the person\\'s statements about bad people are correct: `mask & bad[a] ^ bad[a] == bad[a]`\\n\\nThe above check is O(1) time complexity, comparing to O(N)\\n\\n```\\nclass Solution:\\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        res, n, good, bad = 0, len(statements), defaultdict(int), defaultdict(int) \\n        for i in range(n): \\n            for j in range(n):\\n                if statements[i][j] == 1:\\n                    good[i] = good[i] | (1 << j)    \\n                elif statements[i][j] == 0:\\n                    bad[i] = bad[i] | (1 << j) \\n        for mask in range(1 << n):  \\n            good_count = 0\\n            for a in range(n):\\n                if (1 << a) & mask:\\n                    good_count += 1\\n                    if not(mask & good[a] == good[a] and mask & bad[a] ^ bad[a] == bad[a]): \\n                        break\\n            else: \\n                res = max(res, good_count)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        res, n, good, bad = 0, len(statements), defaultdict(int), defaultdict(int) \\n        for i in range(n): \\n            for j in range(n):\\n                if statements[i][j] == 1:\\n                    good[i] = good[i] | (1 << j)    \\n                elif statements[i][j] == 0:\\n                    bad[i] = bad[i] | (1 << j) \\n        for mask in range(1 << n):  \\n            good_count = 0\\n            for a in range(n):\\n                if (1 << a) & mask:\\n                    good_count += 1\\n                    if not(mask & good[a] == good[a] and mask & bad[a] ^ bad[a] == bad[a]): \\n                        break\\n            else: \\n                res = max(res, good_count)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713439,
                "title": "16ms-c-solution",
                "content": "```\\nint isGood;\\nint isBad;\\nint res;\\nvector<vector<int>> statements;\\nint n;\\n\\nclass Snapshot {\\n    private:\\n    int isGoodSnapshot;\\n    int isBadSnapshot;\\n    \\n    public:\\n    Snapshot() {\\n        isGoodSnapshot = isGood;\\n        isBadSnapshot = isBad;\\n    }\\n    \\n    void recover() {\\n        isGood = isGoodSnapshot;\\n        isBad = isBadSnapshot;\\n    }\\n};\\n\\nint ones(int n) {\\n    int res = 0;\\n    while(n > 0) {\\n        res += 1;\\n        n -= n & -n;\\n    }\\n    return res;\\n}\\n\\nclass Solution {\\npublic:\\n    bool updateNeighbor(int pos) {\\n        for(int neighbor = 0; neighbor < n; ++neighbor) {\\n            if(statements[pos][neighbor] == 0) {\\n                if(isGood & (1 << neighbor)) {\\n                    return false;\\n                } else {\\n                    isBad |= 1 << neighbor;\\n                }\\n            } else if(statements[pos][neighbor] == 1) {\\n                if(isBad & (1 << neighbor)) {\\n                    return false;\\n                } else {\\n                    isGood |= 1 << neighbor;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    void dfs(int pos) {\\n        if(pos == n) {\\n            res = max(res, ones(isGood));\\n        } else {\\n            if(isGood & (1 << pos)) {\\n                Snapshot snapshot;\\n                if(updateNeighbor(pos)) {\\n                    dfs(pos + 1);\\n                }\\n                snapshot.recover();\\n            } else if(isBad & (1 << pos)) {\\n                dfs(pos + 1);\\n            } else {\\n                isGood |= 1 << pos;\\n                Snapshot snapshot;\\n                if(updateNeighbor(pos)) {\\n                    dfs(pos + 1);\\n                }\\n                snapshot.recover();\\n                isGood &= ~(1 << pos);\\n                \\n                isBad |= 1 << pos;\\n                dfs(pos + 1);\\n                isBad &= ~(1 << pos);\\n            }\\n        }\\n    }\\n    \\n    int maximumGood(vector<vector<int>>& _statements) {\\n        isGood = 0;\\n        isBad = 0;\\n\\n        res = 0;\\n        swap(_statements, statements);\\n        n = statements.size();\\n        \\n        dfs(0);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint isGood;\\nint isBad;\\nint res;\\nvector<vector<int>> statements;\\nint n;\\n\\nclass Snapshot {\\n    private:\\n    int isGoodSnapshot;\\n    int isBadSnapshot;\\n    \\n    public:\\n    Snapshot() {\\n        isGoodSnapshot = isGood;\\n        isBadSnapshot = isBad;\\n    }\\n    \\n    void recover() {\\n        isGood = isGoodSnapshot;\\n        isBad = isBadSnapshot;\\n    }\\n};\\n\\nint ones(int n) {\\n    int res = 0;\\n    while(n > 0) {\\n        res += 1;\\n        n -= n & -n;\\n    }\\n    return res;\\n}\\n\\nclass Solution {\\npublic:\\n    bool updateNeighbor(int pos) {\\n        for(int neighbor = 0; neighbor < n; ++neighbor) {\\n            if(statements[pos][neighbor] == 0) {\\n                if(isGood & (1 << neighbor)) {\\n                    return false;\\n                } else {\\n                    isBad |= 1 << neighbor;\\n                }\\n            } else if(statements[pos][neighbor] == 1) {\\n                if(isBad & (1 << neighbor)) {\\n                    return false;\\n                } else {\\n                    isGood |= 1 << neighbor;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    void dfs(int pos) {\\n        if(pos == n) {\\n            res = max(res, ones(isGood));\\n        } else {\\n            if(isGood & (1 << pos)) {\\n                Snapshot snapshot;\\n                if(updateNeighbor(pos)) {\\n                    dfs(pos + 1);\\n                }\\n                snapshot.recover();\\n            } else if(isBad & (1 << pos)) {\\n                dfs(pos + 1);\\n            } else {\\n                isGood |= 1 << pos;\\n                Snapshot snapshot;\\n                if(updateNeighbor(pos)) {\\n                    dfs(pos + 1);\\n                }\\n                snapshot.recover();\\n                isGood &= ~(1 << pos);\\n                \\n                isBad |= 1 << pos;\\n                dfs(pos + 1);\\n                isBad &= ~(1 << pos);\\n            }\\n        }\\n    }\\n    \\n    int maximumGood(vector<vector<int>>& _statements) {\\n        isGood = 0;\\n        isBad = 0;\\n\\n        res = 0;\\n        swap(_statements, statements);\\n        n = statements.size();\\n        \\n        dfs(0);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712784,
                "title": "java-solution-using-bitmasking",
                "content": "# **Disclaimer: If you don\\'t know how to represent subset using bitwise then don\\'t look into solution , you only be frustrated **\\n\\n\\nI considered all the possible assumption and then tried to validate these assumption from statement table.\\nE.g,  [[2,1,2],[1,2,2],[2,0,2]]\\nhere n is 3\\nthen there will be 2^3 possibility\\n0 0 0\\n0 0 1\\n0 1 0\\n0 1 1\\n1 0 0\\n1 0 1\\n1 1 0\\n1 1 1\\n\\nHerer 1 1 1 means --> I\\'m assuming all these three guy are good now let\\'s validate this from statement matrix\\n\\n0th guy is good\\n\\t\\tconsider 0th row and check what 0 is saying about all other person, if the statement of 0 is not equal to our assumption we will reject our assumption and if our assumption is right we will calculate number of good guy we considered in our assumption and that will be answer.\\n\\t\\tSimilarly , we can dry run it for 1st and 2nd\\n1st guy is good\\n2nd guy is good\\n\\n\\n\\n\\n```\\nclass Solution {\\n    public int maximumGood(int[][] stat) {\\n        int n=stat.length;\\n        int Nofbit=1<<n;\\n        int ans=0;\\n        boolean is=false;\\n        for(int i=0;i<Nofbit;i++){\\n            is=true;\\n           int count=0;\\n            for(int j=0;j<n;j++){\\n                if(((i>>j) &1)==1){\\n                    for(int k=0;k<n;k++){\\n                       if(stat[j][k]!=2 &&  stat[j][k]!=((i>>k)&1)){\\n                           is=false;\\n                           break;\\n                       } \\n                    }\\n                   count++;\\n                }\\n            }\\n               if(is){\\n                         ans=Math.max(ans,count);\\n                     }    \\n        }\\n        return ans;\\n    }\\n}\\n```\\n*Time Complexity :O(2^N* N^2 );\\n**Happie Coding !**\\n",
                "solutionTags": [
                    "Java",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumGood(int[][] stat) {\\n        int n=stat.length;\\n        int Nofbit=1<<n;\\n        int ans=0;\\n        boolean is=false;\\n        for(int i=0;i<Nofbit;i++){\\n            is=true;\\n           int count=0;\\n            for(int j=0;j<n;j++){\\n                if(((i>>j) &1)==1){\\n                    for(int k=0;k<n;k++){\\n                       if(stat[j][k]!=2 &&  stat[j][k]!=((i>>k)&1)){\\n                           is=false;\\n                           break;\\n                       } \\n                    }\\n                   count++;\\n                }\\n            }\\n               if(is){\\n                         ans=Math.max(ans,count);\\n                     }    \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712708,
                "title": "cpp-solution",
                "content": "\\'\\'\\'\\nint maximumGood(vector<vector<int>>& statements) {\\n        int n = statements.size();\\n        int tot = 1<<n;\\n        int ans = 0;\\n        //Let mask all the posible cases.\\n        for(int mask=0; mask<tot; mask++){\\n            int tek = 1;\\n            int count = 0;\\n            for(int i=0;i<n;i++){\\n                if(1 & mask>>i){\\n                    count ++;\\n                    for(int j=0;j<n;j++){\\n                        if(statements[i][j] == 1 && !(1 & mask>>j)){\\n                             tek = 0;\\n                             break;\\n                        }\\n                        else if(statements[i][j] == 0 && (1 & mask>>j)){\\n                             tek = 0;\\n                             break;\\n                        }\\n                    }\\n                }\\n                if(tek == 0)\\n                    break;\\n            }\\n            if(tek == 1)\\n                ans = max(ans, count);\\n        }\\n        return ans;\\n    }\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "\\'\\'\\'\\nint maximumGood(vector<vector<int>>& statements) {\\n        int n = statements.size();\\n        int tot = 1<<n;\\n        int ans = 0;\\n        //Let mask all the posible cases.\\n        for(int mask=0; mask<tot; mask++){\\n            int tek = 1;\\n            int count = 0;\\n            for(int i=0;i<n;i++){\\n                if(1 & mask>>i){\\n                    count ++;\\n                    for(int j=0;j<n;j++){\\n                        if(statements[i][j] == 1 && !(1 & mask>>j)){\\n                             tek = 0;\\n                             break;\\n                        }\\n                        else if(statements[i][j] == 0 && (1 & mask>>j)){\\n                             tek = 0;\\n                             break;\\n                        }\\n                    }\\n                }\\n                if(tek == 0)\\n                    break;\\n            }\\n            if(tek == 1)\\n                ans = max(ans, count);\\n        }\\n        return ans;\\n    }\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1712682,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    using vvi = vector<vector<int>>;\\n    int countGoodPeople(int mask){\\n        int count = 0;\\n        while(mask){\\n            count += mask & 1;\\n            mask = mask >>1;\\n        }\\n        return count;\\n    }\\n    // verify if \\'person\\' is saying truth\\n    bool verified(int person,vvi& statements, int mask ){\\n        for(int i = 0; i<statements[person].size(); i++){\\n            int st = statements[person][i];\\n            if(st == 2) continue;\\n            else if(st == 0 && !(mask & (1<<i))) continue;\\n            else if(st == 1 && (mask & (1<<i))) continue;\\n            else return false;\\n        }\\n        return true;\\n    }\\n    // check if \\'mask\\' is not contradictory\\n    bool isValid(vvi& statements, int mask){\\n        for(int i = 0; i<statements.size(); i++){\\n            if(mask & (1<<i)){\\n                if(!verified(i,statements,mask)){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    int maximumGood(vvi& statements) {\\n        int mask = 0;\\n        int goodPeople = 0;\\n        int n = statements.size();\\n        while(mask < (1<<n)){\\n            if(isValid(statements,mask)){\\n                int x = countGoodPeople(mask);\\n                goodPeople = max(goodPeople, x);\\n            }\\n            mask += 1;\\n        }\\n        return goodPeople;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using vvi = vector<vector<int>>;\\n    int countGoodPeople(int mask){\\n        int count = 0;\\n        while(mask){\\n            count += mask & 1;\\n            mask = mask >>1;\\n        }\\n        return count;\\n    }\\n    // verify if \\'person\\' is saying truth\\n    bool verified(int person,vvi& statements, int mask ){\\n        for(int i = 0; i<statements[person].size(); i++){\\n            int st = statements[person][i];\\n            if(st == 2) continue;\\n            else if(st == 0 && !(mask & (1<<i))) continue;\\n            else if(st == 1 && (mask & (1<<i))) continue;\\n            else return false;\\n        }\\n        return true;\\n    }\\n    // check if \\'mask\\' is not contradictory\\n    bool isValid(vvi& statements, int mask){\\n        for(int i = 0; i<statements.size(); i++){\\n            if(mask & (1<<i)){\\n                if(!verified(i,statements,mask)){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    int maximumGood(vvi& statements) {\\n        int mask = 0;\\n        int goodPeople = 0;\\n        int n = statements.size();\\n        while(mask < (1<<n)){\\n            if(isValid(statements,mask)){\\n                int x = countGoodPeople(mask);\\n                goodPeople = max(goodPeople, x);\\n            }\\n            mask += 1;\\n        }\\n        return goodPeople;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712604,
                "title": "c-bitmask-bfs-30-fast-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumGood(vector<vector<int>>& statements) {\\n        int n = statements.size();\\n        int ans = 0;\\n        for(int i = 0; i< pow(2,n);i++)\\n        {\\n            int good = 0;\\n            queue<int> q;\\n            int bitmask = i;\\n            int j = 0;\\n            vector<int> gd(n, 0);\\n            while(bitmask!=0)\\n            {\\n                if(bitmask&1 == 1)\\n                {\\n                    q.push(j);\\n                    gd[j] = 1;\\n                }\\n                bitmask>>=1;\\n                j++;\\n            }\\n            \\n            // count the number of 1s in our bitmask or people who we assumed to be good...\\n            good = q.size();\\n            \\n            \\n            // bfs on assumed \\'good\\' people to check if their statements contradict!!\\n            while(q.size())\\n            {\\n                int k = q.front();\\n                q.pop();\\n                j = 0;\\n                int contradiction = 0;\\n                for(int x: statements[k])\\n                {\\n                    // checking for contradiction....\\n                    // if a good person says someone is good but he is not assumed to good\\n                    // or\\n                    // if he is called bad but we assumed him to be good...\\n                    if((x == 1 && gd[j]!=1) || (x == 0 && gd[j]==1))\\n                    {\\n                        contradiction = 1;\\n                        break;\\n                    }   \\n                    j++;\\n                }\\n                // if contradiction, we will avoid this result... so assigning -INF to good\\n                if(contradiction)\\n                {\\n                    good = -1e9;\\n                    break;\\n                }\\n            }\\n            ans = max(good, ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGood(vector<vector<int>>& statements) {\\n        int n = statements.size();\\n        int ans = 0;\\n        for(int i = 0; i< pow(2,n);i++)\\n        {\\n            int good = 0;\\n            queue<int> q;\\n            int bitmask = i;\\n            int j = 0;\\n            vector<int> gd(n, 0);\\n            while(bitmask!=0)\\n            {\\n                if(bitmask&1 == 1)\\n                {\\n                    q.push(j);\\n                    gd[j] = 1;\\n                }\\n                bitmask>>=1;\\n                j++;\\n            }\\n            \\n            // count the number of 1s in our bitmask or people who we assumed to be good...\\n            good = q.size();\\n            \\n            \\n            // bfs on assumed \\'good\\' people to check if their statements contradict!!\\n            while(q.size())\\n            {\\n                int k = q.front();\\n                q.pop();\\n                j = 0;\\n                int contradiction = 0;\\n                for(int x: statements[k])\\n                {\\n                    // checking for contradiction....\\n                    // if a good person says someone is good but he is not assumed to good\\n                    // or\\n                    // if he is called bad but we assumed him to be good...\\n                    if((x == 1 && gd[j]!=1) || (x == 0 && gd[j]==1))\\n                    {\\n                        contradiction = 1;\\n                        break;\\n                    }   \\n                    j++;\\n                }\\n                // if contradiction, we will avoid this result... so assigning -INF to good\\n                if(contradiction)\\n                {\\n                    good = -1e9;\\n                    break;\\n                }\\n            }\\n            ans = max(good, ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712544,
                "title": "c-bitmask",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumGood(vector<vector<int>>& statements) {\\n        int N = int(statements.size());\\n        int mx = 0;\\n        for (int i = 0; i <= (1 << N) - 1; i++) {            \\n            bool valid = true;\\n            for (int j = 0; j < N && valid; j++) {\\n                for (int k = 0; k < N && valid; k++) {\\n                    if (i & (1 << j)) {\\n                        if (statements[j][k] == 0 && (i & (1 << k)))\\n                            valid = false;\\n                        if (statements[j][k] == 1 && !(i & (1 << k)))\\n                            valid = false;\\n                    }\\n                }\\n            }\\n            if (valid)\\n                mx = max(mx, __builtin_popcount(i));\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGood(vector<vector<int>>& statements) {\\n        int N = int(statements.size());\\n        int mx = 0;\\n        for (int i = 0; i <= (1 << N) - 1; i++) {            \\n            bool valid = true;\\n            for (int j = 0; j < N && valid; j++) {\\n                for (int k = 0; k < N && valid; k++) {\\n                    if (i & (1 << j)) {\\n                        if (statements[j][k] == 0 && (i & (1 << k)))\\n                            valid = false;\\n                        if (statements[j][k] == 1 && !(i & (1 << k)))\\n                            valid = false;\\n                    }\\n                }\\n            }\\n            if (valid)\\n                mx = max(mx, __builtin_popcount(i));\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712538,
                "title": "o-n-3-solution-faster-than-100-python-submissions",
                "content": "1. Maintain res_list which contain list of good and bad sets e.g. res_list = [[{1,2}, {3}], [{1},{3}]]\\n\\n2. 1. For each row (person) (i),  check whether he is good or bad by validating all his statements.\\n\\t* Take all the person which are good according to him.\\n\\t* For all those, check if there is any contradiction.\\n\\t* return valid or not valid, set of good person, set of bad person\\n\\n2. if not valid => check in each good_set of the res_list if i is present, if yes, remove that combinatoin else add i to bad_set\\n3. if valid => for each of good_set, bad_set in res_list , if there is contradiction with curr_bad_set and curr_good_set resp, append this combination to res_list. If there is no contradiction, then merge curr_good_set with good_set and curr_bad_set with bad_set  \\n4. Final result will be one of the good_set having max length\\n\\nCheck following code\\n```\\nclass Solution:\\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        s = statements\\n        n = len(s)\\n        \\n        def is_valid(p):\\n            tg = set()\\n            tb = set()\\n            tgl = list()\\n            seen = set()\\n            seen.add(p)\\n            tg.add(p)\\n            for i, e in enumerate(s[p]):\\n                if e == 1:\\n                    tg.add(i)\\n                    tgl.append(i)\\n                    seen.add(i)\\n                elif e == 0:\\n                    tb.add(i)\\n            for gp in tgl:\\n                for i, e in enumerate(s[gp]):\\n                    if (e == 1 and i in tb) or (e == 0 and i in tg):\\n                        return False, set(), set()\\n                    elif e == 1:\\n                        if i not in seen:\\n                            tg.add(i)\\n                            tgl.append(i)\\n                            seen.add(i)\\n                    elif e == 0:\\n                        tb.add(i)\\n            return True, tg, tb\\n        \\n        res_list = list()\\n        \\n        for i in range(n):\\n            flag, tg, tb = is_valid(i)\\n            # print(i, flag)\\n            if not flag:\\n                for k in range(len(res_list)):\\n                    if k >= len(res_list):\\n                        break\\n                    good_set, bad_set = res_list[k]\\n                    if i in good_set:\\n                        res_list.pop(k)\\n                    else:\\n                        bad_set.add(i)\\n                    \\n            else:\\n                if not res_list:\\n                    res_list.append([tg,tb])\\n                    continue\\n                for good_set, bad_set in res_list:\\n                    if good_set.intersection(tb) or bad_set.intersection(tg):\\n                        res_list.append([tg, tb])\\n                        \\n                    else:\\n                        for e in tg:\\n                            good_set.add(e)\\n                        for b in tb:\\n                            bad_set.add(b)\\n                    \\n        res = 0\\n        for gs, bs in res_list:\\n            res = max(res, len(gs))\\n        return res\\n\\n                \\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        s = statements\\n        n = len(s)\\n        \\n        def is_valid(p):\\n            tg = set()\\n            tb = set()\\n            tgl = list()\\n            seen = set()\\n            seen.add(p)\\n            tg.add(p)\\n            for i, e in enumerate(s[p]):\\n                if e == 1:\\n                    tg.add(i)\\n                    tgl.append(i)\\n                    seen.add(i)\\n                elif e == 0:\\n                    tb.add(i)\\n            for gp in tgl:\\n                for i, e in enumerate(s[gp]):\\n                    if (e == 1 and i in tb) or (e == 0 and i in tg):\\n                        return False, set(), set()\\n                    elif e == 1:\\n                        if i not in seen:\\n                            tg.add(i)\\n                            tgl.append(i)\\n                            seen.add(i)\\n                    elif e == 0:\\n                        tb.add(i)\\n            return True, tg, tb\\n        \\n        res_list = list()\\n        \\n        for i in range(n):\\n            flag, tg, tb = is_valid(i)\\n            # print(i, flag)\\n            if not flag:\\n                for k in range(len(res_list)):\\n                    if k >= len(res_list):\\n                        break\\n                    good_set, bad_set = res_list[k]\\n                    if i in good_set:\\n                        res_list.pop(k)\\n                    else:\\n                        bad_set.add(i)\\n                    \\n            else:\\n                if not res_list:\\n                    res_list.append([tg,tb])\\n                    continue\\n                for good_set, bad_set in res_list:\\n                    if good_set.intersection(tb) or bad_set.intersection(tg):\\n                        res_list.append([tg, tb])\\n                        \\n                    else:\\n                        for e in tg:\\n                            good_set.add(e)\\n                        for b in tb:\\n                            bad_set.add(b)\\n                    \\n        res = 0\\n        for gs, bs in res_list:\\n            res = max(res, len(gs))\\n        return res\\n\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712487,
                "title": "c-simple-solution-w-explanation-bitmasking",
                "content": "#### /// if you like please upvoke****\\nclass Solution {\\npublic:\\n    int maximumGood(vector<vector<int>>& s)\\n    {\\n        int n  = s.size();\\n            \\n        int ans  = 0;\\n            ///consider all possiblities with bitmasks..\\n         for(int i = 1;i<(1<<n);i++)\\n         {\\n                 int flag  = true;\\n                 \\n                 for(int j = 0;j<n;j++)\\n                 {\\n\\t\\t\\t\\t // here the sequence means value of i that is 101 if 5, 100011 if 35 etc\\n        /// here if the sequence says that that the jth person is bad then no need to do anything as their is no voilation..\\n\\t\\t\\n                     if(!(i&(1<<j)))\\n                     continue;\\n//here we considered that the jth person speaks truth in the given sequence then check if it agree with the sequence                     \\n                    for(int k = 0;k<n;k++)\\n                    {\\n///if for any person k in which the sequence say that k person speaks truth but j person says that k person speaks false so this is contradiction with the sequence...\\n\\n                        if((i&(1<<k))&&s[j][k]==0)\\n                        flag  = false;\\n\\t\\t\\t\\t\\t\\t\\n//if for any person k in which the sequence say that k person says false but since j says that k speaks truth so this is also contradiction with the sequence...     \\n\\n                        if(!(i&(1<<k))&&s[j][k]==1)\\n                        flag  = false;           \\n                            \\n                    }\\n                         \\n                         if(flag==0)\\n                         break;\\n                              \\n                 }\\n                \\n                 if(flag==1)\\n                 {\\n                      int g  = __builtin_popcount(i);\\n                      ans  = max(ans,g);\\n                 }\\n         }\\n            return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "class Solution {\\npublic:\\n    int maximumGood(vector<vector<int>>& s)\\n    {\\n        int n  = s.size();\\n            \\n        int ans  = 0;\\n            ///consider all possiblities with bitmasks..\\n         for(int i = 1;i<(1<<n);i++)\\n         {\\n                 int flag  = true;\\n                 \\n                 for(int j = 0;j<n;j++)\\n                 {\\n\\t\\t\\t\\t // here the sequence means value of i that is 101 if 5, 100011 if 35 etc\\n        /// here if the sequence says that that the jth person is bad then no need to do anything as their is no voilation..\\n\\t\\t\\n                     if(!(i&(1<<j)))\\n                     continue;\\n//here we considered that the jth person speaks truth in the given sequence then check if it agree with the sequence                     \\n                    for(int k = 0;k<n;k++)\\n                    {\\n///if for any person k in which the sequence say that k person speaks truth but j person says that k person speaks false so this is contradiction with the sequence...\\n\\n                        if((i&(1<<k))&&s[j][k]==0)\\n                        flag  = false;\\n\\t\\t\\t\\t\\t\\t\\n//if for any person k in which the sequence say that k person says false but since j says that k speaks truth so this is also contradiction with the sequence...     \\n\\n                        if(!(i&(1<<k))&&s[j][k]==1)\\n                        flag  = false;           \\n                            \\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1712370,
                "title": "python-bitmask-o-2-n-n-2",
                "content": "```\\nclass Solution:\\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        n=len(statements)\\n        ans=0\\n        def check(mask):\\n            for i in range(n):\\n                if mask & (1<<i)!=0: good.add(i)\\n            for i in range(n):\\n                if i in good:\\n                    for j in range(n):\\n                        if statements[i][j]==0 and j in good: return False\\n                        if statements[i][j]==1 and j not in good: return False\\n            return True\\n        for i in range(1,1<<n):\\n            good=set()\\n            if check(i):\\n                ans=max(ans,len(good))\\n        return ans\\n                \\n                        \\n```",
                "solutionTags": [
                    "Python",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        n=len(statements)\\n        ans=0\\n        def check(mask):\\n            for i in range(n):\\n                if mask & (1<<i)!=0: good.add(i)\\n            for i in range(n):\\n                if i in good:\\n                    for j in range(n):\\n                        if statements[i][j]==0 and j in good: return False\\n                        if statements[i][j]==1 and j not in good: return False\\n            return True\\n        for i in range(1,1<<n):\\n            good=set()\\n            if check(i):\\n                ans=max(ans,len(good))\\n        return ans\\n                \\n                        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712365,
                "title": "java-bitmask-brute-force-o-2-n",
                "content": "2 <= n <= 15 indicates brute-force ennumeration with bitMask may be the correct way to solve this problem. By default, we treat 1 as good and 0 as bad.\\n\\nEnnumerate all of the possible states and check if each of them is valid or not.\\nif it is valid, then count of the \"good bits\" and find the max value.\\n\\nTo verify if it is valid or not, we basically look for the contradication. \\nSimply convert the state a person array to make the check easier.\\nNote we only check good person and all \"valid statement\" (statements[i][j] != 2) as :\\n1. bad people can tell truth or lie, we cannot judge directly if it is a contradiction or not.\\n2. statements[i][j] == 2 doesn\\'t mean anything, and we can\\'t make judgment out of that.\\n\\n```\\nclass Solution {\\n    // time = O(2^n), space = O(n)\\n    public int maximumGood(int[][] statements) {\\n        int n = statements.length, res = 0;\\n        for (int state = 0; state < (1 << n); state++) {\\n            if (isValid(statements, state)) {\\n                res = Math.max(res, Integer.bitCount(state));\\n            }\\n        }\\n        return res;\\n    }\\n\\n    private boolean isValid(int[][] statements, int state) {\\n        int n = statements.length;\\n        int[] persons = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            if (((state >> i) & 1) == 1) persons[i] = 1;\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            if (persons[i] == 0) continue;\\n            for (int j = 0; j < n; j++) {\\n                if (statements[i][j] == 2) continue;\\n                if (statements[i][j] != persons[j]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    // time = O(2^n), space = O(n)\\n    public int maximumGood(int[][] statements) {\\n        int n = statements.length, res = 0;\\n        for (int state = 0; state < (1 << n); state++) {\\n            if (isValid(statements, state)) {\\n                res = Math.max(res, Integer.bitCount(state));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1712307,
                "title": "c-bitmask-preprocessing-o-n-2-n-faster-than-100",
                "content": "We can check whether a good/bad configuration is valid in linear time by translating the statements into bitmasks, too.\\n\\nThis makes all tests run in <30 ms.\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumGood(vector<vector<int>>& statements) {\\n        // We can just iterate through all\\n        int n = statements.size();\\n        // Do some preprocessing\\n        vector<int> masks, answers;\\n        for (const auto& statement : statements) {\\n            int mask = 0, answer = 0;\\n            for (auto it = statement.cbegin(); it != statement.cend(); ++it) {\\n                mask <<= 1;\\n                answer <<= 1;\\n                if (*it == 2)\\n                    continue;\\n                mask ^= 1;\\n                answer ^= *it;\\n            }\\n            masks.push_back(mask);\\n            answers.push_back(answer);\\n        }\\n        \\n        int res = 0;\\n        for (int key = 0; key < (1 << n); ++key) {\\n            int good = 0;\\n            bool is_valid = true;\\n            \\n            for (int i = n - 1; i >= 0; --i) {\\n                if ((key >> i) & 1) {\\n                    ++good;\\n                    if ((key & masks[n - 1 - i]) != answers[n - 1 - i]) {\\n                        is_valid = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if (!is_valid)\\n                continue;\\n            \\n            res = max(res, good);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGood(vector<vector<int>>& statements) {\\n        // We can just iterate through all\\n        int n = statements.size();\\n        // Do some preprocessing\\n        vector<int> masks, answers;\\n        for (const auto& statement : statements) {\\n            int mask = 0, answer = 0;\\n            for (auto it = statement.cbegin(); it != statement.cend(); ++it) {\\n                mask <<= 1;\\n                answer <<= 1;\\n                if (*it == 2)\\n                    continue;\\n                mask ^= 1;\\n                answer ^= *it;\\n            }\\n            masks.push_back(mask);\\n            answers.push_back(answer);\\n        }\\n        \\n        int res = 0;\\n        for (int key = 0; key < (1 << n); ++key) {\\n            int good = 0;\\n            bool is_valid = true;\\n            \\n            for (int i = n - 1; i >= 0; --i) {\\n                if ((key >> i) & 1) {\\n                    ++good;\\n                    if ((key & masks[n - 1 - i]) != answers[n - 1 - i]) {\\n                        is_valid = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if (!is_valid)\\n                continue;\\n            \\n            res = max(res, good);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712284,
                "title": "simple-straightforward-c-solution",
                "content": "class Solution {\\npublic:\\n    int maximumGood(vector<vector<int>>& statements) {\\n        int n = statements.size();\\n        vector<bool> state(n, false);\\n        return maxGoodRecursive(state, 0, statements);\\n    }\\n    \\n    int maxGoodRecursive(vector<bool>& state, int idx, const vector<vector<int>>& statements)\\n    {\\n        int n = statements.size();\\n        if (idx == statements.size())\\n        {\\n            if (isValid(state, statements))\\n                return count(state.begin(), state.end(), true);\\n            else\\n                return 0;\\n        }\\n        \\n        int maxNum = 0;\\n        state[idx] = true;\\n        maxNum = max(maxNum, maxGoodRecursive(state, idx + 1, statements));\\n        state[idx] = false;\\n        maxNum = max(maxNum, maxGoodRecursive(state, idx + 1, statements));\\n        return maxNum;\\n    }\\n    \\n    bool isValid(const vector<bool>& state, const vector<vector<int>>& statements)\\n    {\\n        int n = state.size();\\n        for (int i = 0; i < n; ++i)\\n        {\\n            bool result = true;\\n            if (state[i])\\n            {\\n                for (int j = 0; j < n; ++j)\\n                {\\n                    result = result && (statements[i][j] == 2 || statements[i][j] == (int)state[j]);\\n                    if (result == false)\\n                        return false;\\n                }\\n            }\\n            /*else\\n            {\\n                for (int j = 0; j < n; ++j)\\n                    result = result && (statements[i][j] == 2 || statements[i][j] == (int)state[j]);\\n                \\n                if (result)\\n                    return false;\\n            }*/\\n        }\\n        return true;\\n    }\\n   \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maximumGood(vector<vector<int>>& statements) {\\n        int n = statements.size();\\n        vector<bool> state(n, false);\\n        return maxGoodRecursive(state, 0, statements);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1712211,
                "title": "bitmasking",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumGood(vector<vector<int>>& s) {\\n        \\n       int n = s.size();\\n       \\n//  0 0\\n//  1 1\\n//  0 1\\n//  1 0\\n        \\n//       try all combinations : Left-> multiply by 2 , right shift / by 2\\n        int ans = 0;\\n        bool ok =false;\\n        for(int mask = 0 ; mask< 1<<n ; mask++){     //2^n-1 combination of subset \\n        \\n            ok = true;\\n            \\n            for(int i=0;i<n;i++){      //check ith bit \\n                \\n                if(!( mask>>i & 1  )){   //ith is good whatever hw will say is always correct, so we will check further and if he is not good then we have considered for now he is good and continued further\\n                    \\n                    continue;\\n                }\\n                \\n                for(int j=0;j<n;j++){      //now we check jth person if he doestnt make opinion for ith person we will simply continue\\n                    if(i==j || s[i][j]==2){\\n                        continue;\\n                    }\\n//     otherwise we will check the opinions with s[i][j] if they dont match our subset is invalid                \\n                    if( (mask>>j &1) != s[i][j] ){\\n                        ok = false;\\n                    }\\n                }\\n                \\n            }\\n//             if we get valid subset we will check for makimum 1 \\n            if(!ok){\\n                continue;\\n            }\\n            \\n            ans = max(ans , __builtin_popcount(mask));     \\n        }\\n        return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGood(vector<vector<int>>& s) {\\n        \\n       int n = s.size();\\n       \\n//  0 0\\n//  1 1\\n//  0 1\\n//  1 0\\n        \\n//       try all combinations : Left-> multiply by 2 , right shift / by 2\\n        int ans = 0;\\n        bool ok =false;\\n        for(int mask = 0 ; mask< 1<<n ; mask++){     //2^n-1 combination of subset \\n        \\n            ok = true;\\n            \\n            for(int i=0;i<n;i++){      //check ith bit \\n                \\n                if(!( mask>>i & 1  )){   //ith is good whatever hw will say is always correct, so we will check further and if he is not good then we have considered for now he is good and continued further\\n                    \\n                    continue;\\n                }\\n                \\n                for(int j=0;j<n;j++){      //now we check jth person if he doestnt make opinion for ith person we will simply continue\\n                    if(i==j || s[i][j]==2){\\n                        continue;\\n                    }\\n//     otherwise we will check the opinions with s[i][j] if they dont match our subset is invalid                \\n                    if( (mask>>j &1) != s[i][j] ){\\n                        ok = false;\\n                    }\\n                }\\n                \\n            }\\n//             if we get valid subset we will check for makimum 1 \\n            if(!ok){\\n                continue;\\n            }\\n            \\n            ans = max(ans , __builtin_popcount(mask));     \\n        }\\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712110,
                "title": "get-all-combinations-and-check-no-bit-mask-easy-to-understand",
                "content": "# Approach:\\n1. Find out all the possible combinations of Goods and Bads for n-people. O(2^n)\\n2. As Bad People can lie or contradict themselves, we only check the statements of \"Good\" People and check if they contradict. \\n3. **Rephrasing Point 2:** If I have a combination of Good and Bad where ALL the opinions of Good People do not contradict, then I don\\'t care whatever Bad People say as we can consider it a lie.\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n   vector<vector<char>> combinations;\\n    //Just get all the possible combination of Good and Bad\\n    int getCombinations(int n, vector<char>& choice, vector<char>& temp)\\n    {\\n         if(temp.size()==n)\\n         {\\n             combinations.push_back(temp);\\n             return 1;\\n         }\\n         if(temp.size()>n)\\n         {\\n             return 0;\\n         }\\n         int ans=0;\\n        \\n         for(auto e: choice)\\n         {\\n             temp.push_back(e);\\n             ans+= getCombinations(n, choice, temp);\\n             temp.pop_back();\\n         }\\n        return ans;\\n    }\\n    \\n    //Check for Contradictions \\n    //If a Good Person (i) says (j) is \"bad\" but he is \"good\" in my combination\\n    //OR if a Good Person(i) says (j) is \"good\" but he is \"bad\" in my combination\\n    bool check(vector<vector<char>>& combinations, int idx, vector<vector<int>>& grid)\\n    {\\n        int n = grid.size(); \\n        //{G, G, G}  //combinations[idx][row]\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(combinations[idx][i]==\\'B\\')\\n            {\\n                continue;\\n            }\\n            for(int j=0;j<n;j++)\\n            {\\n                //from row to col\\n                if(combinations[idx][i]==\\'G\\')\\n                {                    \\n                    if((grid[i][j]==0 && combinations[idx][j]==\\'G\\') || (grid[i][j]==1 && combinations[idx][j]==\\'B\\'))  \\n                    {\\n                        return false;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return true;\\n        \\n    }    \\n    \\n    int maximumGood(vector<vector<int>>& statements) {\\n        \\n        int n = statements.size();\\n        vector<char> choice = {\\'G\\', \\'B\\'};\\n        \\n        vector<char> temp;\\n        int total = getCombinations(n, choice, temp); //getting the combinations\\n        \\n        int ans = 0;\\n        for(int i=0;i<total;i++)\\n        {\\n            if(check(combinations, i, statements))\\n            {\\n                int temp = 0;\\n                \\n               for(auto e: combinations[i])\\n               {\\n                  \\n                   if(e==\\'G\\') //Check for Good Person in the valid combination[i]\\n                   {\\n                        temp++;       \\n                   }\\n               }\\n                ans= max(ans, temp);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   vector<vector<char>> combinations;\\n    //Just get all the possible combination of Good and Bad\\n    int getCombinations(int n, vector<char>& choice, vector<char>& temp)\\n    {\\n         if(temp.size()==n)\\n         {\\n             combinations.push_back(temp);\\n             return 1;\\n         }\\n         if(temp.size()>n)\\n         {\\n             return 0;\\n         }\\n         int ans=0;\\n        \\n         for(auto e: choice)\\n         {\\n             temp.push_back(e);\\n             ans+= getCombinations(n, choice, temp);\\n             temp.pop_back();\\n         }\\n        return ans;\\n    }\\n    \\n    //Check for Contradictions \\n    //If a Good Person (i) says (j) is \"bad\" but he is \"good\" in my combination\\n    //OR if a Good Person(i) says (j) is \"good\" but he is \"bad\" in my combination\\n    bool check(vector<vector<char>>& combinations, int idx, vector<vector<int>>& grid)\\n    {\\n        int n = grid.size(); \\n        //{G, G, G}  //combinations[idx][row]\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(combinations[idx][i]==\\'B\\')\\n            {\\n                continue;\\n            }\\n            for(int j=0;j<n;j++)\\n            {\\n                //from row to col\\n                if(combinations[idx][i]==\\'G\\')\\n                {                    \\n                    if((grid[i][j]==0 && combinations[idx][j]==\\'G\\') || (grid[i][j]==1 && combinations[idx][j]==\\'B\\'))  \\n                    {\\n                        return false;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return true;\\n        \\n    }    \\n    \\n    int maximumGood(vector<vector<int>>& statements) {\\n        \\n        int n = statements.size();\\n        vector<char> choice = {\\'G\\', \\'B\\'};\\n        \\n        vector<char> temp;\\n        int total = getCombinations(n, choice, temp); //getting the combinations\\n        \\n        int ans = 0;\\n        for(int i=0;i<total;i++)\\n        {\\n            if(check(combinations, i, statements))\\n            {\\n                int temp = 0;\\n                \\n               for(auto e: combinations[i])\\n               {\\n                  \\n                   if(e==\\'G\\') //Check for Good Person in the valid combination[i]\\n                   {\\n                        temp++;       \\n                   }\\n               }\\n                ans= max(ans, temp);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712051,
                "title": "another-brute-force-python-solution",
                "content": "```\\nclass Solution:\\n    def maximumGood(self, s: List[List[int]]) -> int:\\n        \"\"\"\\n        brute force: try if all N people are good, if not, try N-1 etc.\\n        \"\"\"\\n        N = len(s)\\n        \\n        gooddict = defaultdict(set)\\n        baddict = defaultdict(set)\\n        \\n        for r in range(N):\\n            for c in range(N):\\n                if s[r][c]==1: \\n                    gooddict[r].add(c)\\n                elif s[r][c] == 0:\\n                    baddict[r].add(c)\\n     \\n        def valid(good):\\n            bad = set(x for x in range(N) if x not in good)\\n            for g in good:\\n                for gg in gooddict[g]:\\n                    if gg not in good:\\n                        return False\\n                for gb in baddict[g]:\\n                    if gb not in bad:\\n                        return False\\n            return True\\n        \\n        for t in range(len(s),0,-1):\\n            choices = set(itertools.combinations(range(N), t))\\n            for c in choices:\\n                if valid(c):\\n                    return t\\n                \\n        return 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumGood(self, s: List[List[int]]) -> int:\\n        \"\"\"\\n        brute force: try if all N people are good, if not, try N-1 etc.\\n        \"\"\"\\n        N = len(s)\\n        \\n        gooddict = defaultdict(set)\\n        baddict = defaultdict(set)\\n        \\n        for r in range(N):\\n            for c in range(N):\\n                if s[r][c]==1: \\n                    gooddict[r].add(c)\\n                elif s[r][c] == 0:\\n                    baddict[r].add(c)\\n     \\n        def valid(good):\\n            bad = set(x for x in range(N) if x not in good)\\n            for g in good:\\n                for gg in gooddict[g]:\\n                    if gg not in good:\\n                        return False\\n                for gb in baddict[g]:\\n                    if gb not in bad:\\n                        return False\\n            return True\\n        \\n        for t in range(len(s),0,-1):\\n            choices = set(itertools.combinations(range(N), t))\\n            for c in choices:\\n                if valid(c):\\n                    return t\\n                \\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712001,
                "title": "java-solution-using-bit-mask",
                "content": "Intuition:  \\n1. Use brute force.\\n2. Find all subset of good and bad people using bitmask.\\n3. We only care about good people and they always tell truth and we just need to validate their statements given in the table in problem statement.\\n4. If we are able to find a valid scenario, just record all these result and take maximum of them.\\n```\\nclass Solution {\\n    public int maximumGood(int[][] statements) {\\n        int n = statements.length;\\n        int res = 0;\\n        for(int i = 1; i<(1 <<n); i++){\\n            if(valid(i, statements)){\\n                res = Math.max(res, getSetBits(i));\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private boolean valid(int i, int[][] statements){   \\n        int n = statements.length;\\n        for(int bit = 0; bit < n; bit++){\\n            if((i & (1 << bit)) > 0){\\n                int statementTo = 0;\\n                for(int statement : statements[bit]){\\n                    if(statement!= 2 && statement != ((i & (1 << statementTo) ) > 0 ? 1 : 0)){\\n                        return false;\\n                    }\\n                    statementTo++;\\n                }\\n            }\\n        }       \\n          return true;\\n    }\\n    private int getSetBits(int n){\\n        int count = 0;\\n        while(n > 0){\\n            n = n & (n-1);\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```\\nTime Complexity : `O(2^n *  n^2) `",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maximumGood(int[][] statements) {\\n        int n = statements.length;\\n        int res = 0;\\n        for(int i = 1; i<(1 <<n); i++){\\n            if(valid(i, statements)){\\n                res = Math.max(res, getSetBits(i));\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private boolean valid(int i, int[][] statements){   \\n        int n = statements.length;\\n        for(int bit = 0; bit < n; bit++){\\n            if((i & (1 << bit)) > 0){\\n                int statementTo = 0;\\n                for(int statement : statements[bit]){\\n                    if(statement!= 2 && statement != ((i & (1 << statementTo) ) > 0 ? 1 : 0)){\\n                        return false;\\n                    }\\n                    statementTo++;\\n                }\\n            }\\n        }       \\n          return true;\\n    }\\n    private int getSetBits(int n){\\n        int count = 0;\\n        while(n > 0){\\n            n = n & (n-1);\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711925,
                "title": "generate-all-possible-combinations-and-iterate-each-one-brute-force",
                "content": "The complexity is `O(2^n * n^2)`.\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumGood(vector<vector<int>>& statements) {\\n        int n = statements.size();\\n        vector<int> subsets = getSubsets(n);\\n        int ans = 0;\\n        for (int subset : subsets) {\\n            if (valid(statements, subset)) {\\n                ans = max(ans, getOnes(subset));\\n            }\\n        }\\n        return ans;\\n    }\\n\\nprivate:\\n    bool valid(vector<vector<int>>& statements, int subset) {\\n        int n = statements.size();\\n        for (int i = 0; i < n; ++i) {\\n            if (subset & (1 << i)) {\\n                for (int j = 0; j < n; ++j) {\\n                    if (statements[i][j] == 0 && (subset & (1 << j))) {\\n                        return false;\\n                    }\\n                    if (statements[i][j] == 1 && ((subset & (1 << j)) == 0)) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    int getOnes(int n) {\\n        int ans = 0;\\n        while (n) {\\n            ++ans;\\n            n &= (n - 1);\\n        }\\n        return ans;\\n    }\\n    vector<int> getSubsets(int n) {\\n        vector<int> ans;\\n        for (int i = 0; i < (1 << n); ++i) {\\n            ans.emplace_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGood(vector<vector<int>>& statements) {\\n        int n = statements.size();\\n        vector<int> subsets = getSubsets(n);\\n        int ans = 0;\\n        for (int subset : subsets) {\\n            if (valid(statements, subset)) {\\n                ans = max(ans, getOnes(subset));\\n            }\\n        }\\n        return ans;\\n    }\\n\\nprivate:\\n    bool valid(vector<vector<int>>& statements, int subset) {\\n        int n = statements.size();\\n        for (int i = 0; i < n; ++i) {\\n            if (subset & (1 << i)) {\\n                for (int j = 0; j < n; ++j) {\\n                    if (statements[i][j] == 0 && (subset & (1 << j))) {\\n                        return false;\\n                    }\\n                    if (statements[i][j] == 1 && ((subset & (1 << j)) == 0)) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    int getOnes(int n) {\\n        int ans = 0;\\n        while (n) {\\n            ++ans;\\n            n &= (n - 1);\\n        }\\n        return ans;\\n    }\\n    vector<int> getSubsets(int n) {\\n        vector<int> ans;\\n        for (int i = 0; i < (1 << n); ++i) {\\n            ans.emplace_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711852,
                "title": "c-simple-bit-mask-bruteforce-faster-than-93",
                "content": "```\\n\\t\\tint n= statements.size();\\n        int ans=0;\\n         for(int i=0 ;i<(1<<n);i++) // (1<<n) generates bitmask of all possible combination of people\\n         {\\n             bool p= true;\\n             for(int j=0;j<n;j++) // Validating the assumed bitmask with the given statements\\n             {\\n                 if(((i>>j)&1)) // check if person is good, then only validate its statements\\n                 {\\n                     for(int k=0;k<n;k++)\\n                     {\\n                       if(!(statements[j][k]==2||statements[j][k]==((i>>k)&1))) // check if statements matches with the assumed bitmask combination\\n                       {\\n                           p= false;\\n                           break; \\n                       }\\n                     }\\n                     if(!p) break;\\n                 }\\n             }\\n             if(p) // if all statements match with assumed bitmask , then  update ans to maximum number of good people \\n             ans= max(ans,__builtin_popcount(i));  // \" __builtin_popcount (i)\" returns the count of 1 in bits representation of \"i\"\\n         }\\n        return ans;\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\t\\tint n= statements.size();\\n        int ans=0;\\n         for(int i=0 ;i<(1<<n);i++) // (1<<n) generates bitmask of all possible combination of people\\n         {\\n             bool p= true;\\n             for(int j=0;j<n;j++) // Validating the assumed bitmask with the given statements\\n             {\\n                 if(((i>>j)&1)) // check if person is good, then only validate its statements\\n                 {\\n                     for(int k=0;k<n;k++)\\n                     {\\n                       if(!(statements[j][k]==2||statements[j][k]==((i>>k)&1))) // check if statements matches with the assumed bitmask combination\\n                       {\\n                           p= false;\\n                           break; \\n                       }\\n                     }\\n                     if(!p) break;\\n                 }\\n             }\\n             if(p) // if all statements match with assumed bitmask , then  update ans to maximum number of good people \\n             ans= max(ans,__builtin_popcount(i));  // \" __builtin_popcount (i)\" returns the count of 1 in bits representation of \"i\"\\n         }\\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1711832,
                "title": "java-check-all-combinations-brute-force",
                "content": "```\\nclass Solution {\\n    public int maximumGood(int[][] statements) {\\n        int n = statements.length;\\n        int answer = 0;\\n        \\n        // generate all possible combinations and check if there are any statements which contradict\\n        for(int bitmask = 0; bitmask < (1 << n); bitmask++) {\\n            if(isValid(bitmask, statements)) {\\n                answer = Math.max(answer, Integer.bitCount(bitmask));\\n            }\\n        }\\n        \\n        return answer;\\n        \\n    }\\n    \\n    private boolean isValid(int bitmask, int[][] statements) {\\n        for(int i = 0; i < statements.length; i++) {\\n            if(isBitSet(bitmask, i)) {\\n                int[] statement = statements[i];\\n                for(int j = 0; j < statement.length; j++) {\\n                    if((statement[j] == 0 && isBitSet(bitmask, j)) || (statement[j] == 1 && !isBitSet(bitmask, j))) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private boolean isBitSet(int bitmask, int i) {\\n        return ((1 << i) & bitmask) != 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumGood(int[][] statements) {\\n        int n = statements.length;\\n        int answer = 0;\\n        \\n        // generate all possible combinations and check if there are any statements which contradict\\n        for(int bitmask = 0; bitmask < (1 << n); bitmask++) {\\n            if(isValid(bitmask, statements)) {\\n                answer = Math.max(answer, Integer.bitCount(bitmask));\\n            }\\n        }\\n        \\n        return answer;\\n        \\n    }\\n    \\n    private boolean isValid(int bitmask, int[][] statements) {\\n        for(int i = 0; i < statements.length; i++) {\\n            if(isBitSet(bitmask, i)) {\\n                int[] statement = statements[i];\\n                for(int j = 0; j < statement.length; j++) {\\n                    if((statement[j] == 0 && isBitSet(bitmask, j)) || (statement[j] == 1 && !isBitSet(bitmask, j))) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private boolean isBitSet(int bitmask, int i) {\\n        return ((1 << i) & bitmask) != 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711817,
                "title": "c-o-2-n-n-2-solution-using-bit-mask-with-brief-explanation",
                "content": "Idea:\\n1. Use a bit mask \"i\" to represent every state (eg. each person may be good or bad).\\n2. If a person \"j\" is good, then all his/her \"statements[j][k]\" must be consistent to the bit mask state \"i\".\\n-> eg. if statements[j][k] is 0, then i & (1<<k) must not be set\\n-> eg. if statements[j][k] is 1, then i & (1<<k) must be set\\n```\\nint maximumGood(vector<vector<int>>& statements) \\n{\\n\\tint result=0,n=statements.size(),p=1<<n;\\n\\tfor(int i=0;i<p;i++) // every bit mask state (eg. 0 ~ 2^n-1)\\n\\t{\\n\\t\\tbool flag=true;\\n\\t\\tfor(int j=0;j<n;j++)\\n\\t\\t{\\n\\t\\t\\tif(i & (1<<j)) // if person j is considered good, check whether he/she is really good\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int k=0;k<n;k++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(statements[j][k]==2) continue; // ignore empty statements\\n\\t\\t\\t\\t\\tif((statements[j][k]==0) != ((i&(1<<k))==0)) // whether j\\'s statement is inconsistent\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tflag=false; // invalid state\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(!flag) break;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(flag) // valid state\\n\\t\\t{\\n\\t\\t\\tint current=0,c=i;\\n\\t\\t\\twhile(c) current+=c&1,c>>=1; // count number of good person\\n\\t\\t\\tresult=max(result,current);\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint maximumGood(vector<vector<int>>& statements) \\n{\\n\\tint result=0,n=statements.size(),p=1<<n;\\n\\tfor(int i=0;i<p;i++) // every bit mask state (eg. 0 ~ 2^n-1)\\n\\t{\\n\\t\\tbool flag=true;\\n\\t\\tfor(int j=0;j<n;j++)\\n\\t\\t{\\n\\t\\t\\tif(i & (1<<j)) // if person j is considered good, check whether he/she is really good\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int k=0;k<n;k++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(statements[j][k]==2) continue; // ignore empty statements\\n\\t\\t\\t\\t\\tif((statements[j][k]==0) != ((i&(1<<k))==0)) // whether j\\'s statement is inconsistent\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tflag=false; // invalid state\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(!flag) break;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(flag) // valid state\\n\\t\\t{\\n\\t\\t\\tint current=0,c=i;\\n\\t\\t\\twhile(c) current+=c&1,c>>=1; // count number of good person\\n\\t\\t\\tresult=max(result,current);\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1711782,
                "title": "pure-bitmask-with-detailed-explanations-and-similar-questions",
                "content": "similar paradigm can be applied to the power set related problems.\\nsee Leetcode 90\\nhttps://leetcode.com/problems/subsets-ii/\\n```\\n\\'\\'\\'\\nIdea: brute force, each person can be good or bad, so the total condition is 2^N\\nif assume a person is good, then find if there are contridicts between the preset condition (bitmask) and the statements\\nis assume a person is bad, no need to check as the claims are not trustworth\\n\\nshould use a bitmask to filter out all conditions\\n\\'\\'\\'\\n\\nclass Solution:\\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        # n cases\\n        length = len(statements)\\n\\t\\tn = 1 << length\\n        \\n        def helper(bitmask: int) -> bool:\\n            nonlocal length\\n            for i in range(length):\\n                # test if the person j is good based on the bitmask condition\\n                if not bitmask & (1 << i):\\n                    continue\\n                for j in range(length):\\n                    # j is bad according to the statements, but is good according to the bitmask condition\\n                    if (statements[i][j] == 0 and bitmask & (1 << j)):\\n                        return False\\n                    # j is good according to the statements, but is bad according to the bitmask condition\\n                    elif (statements[i][j] == 1 and not bitmask & (1 << j)):\\n                        return False\\n            return True\\n        \\n        result = 0\\n        for bitmask in range(n):\\n            # in the bitmask, assume digit 1 represents good\\n            if helper(bitmask):\\n                result = max(result, bin(bitmask)[2:].count(\\'1\\'))\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bitmask"
                ],
                "code": "```\\n\\'\\'\\'\\nIdea: brute force, each person can be good or bad, so the total condition is 2^N\\nif assume a person is good, then find if there are contridicts between the preset condition (bitmask) and the statements\\nis assume a person is bad, no need to check as the claims are not trustworth\\n\\nshould use a bitmask to filter out all conditions\\n\\'\\'\\'\\n\\nclass Solution:\\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        # n cases\\n        length = len(statements)\\n\\t\\tn = 1 << length\\n        \\n        def helper(bitmask: int) -> bool:\\n            nonlocal length\\n            for i in range(length):\\n                # test if the person j is good based on the bitmask condition\\n                if not bitmask & (1 << i):\\n                    continue\\n                for j in range(length):\\n                    # j is bad according to the statements, but is good according to the bitmask condition\\n                    if (statements[i][j] == 0 and bitmask & (1 << j)):\\n                        return False\\n                    # j is good according to the statements, but is bad according to the bitmask condition\\n                    elif (statements[i][j] == 1 and not bitmask & (1 << j)):\\n                        return False\\n            return True\\n        \\n        result = 0\\n        for bitmask in range(n):\\n            # in the bitmask, assume digit 1 represents good\\n            if helper(bitmask):\\n                result = max(result, bin(bitmask)[2:].count(\\'1\\'))\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711772,
                "title": "can-someone-explain-the-following-test-case",
                "content": "[[2,1,0],[2,2,1],[0,2,2]]\\n\\nThis test case \"expects\" 2 possible good people for an answer but that\\'s impossible:\\n- person 0 can never tell the truth because that would imply that person 1 is good, but persons 0 and 1 disagree on person 2.\\n- person 0 is lying (therefore bad), thus person 1 is also bad, leaving us with at most 1 good person.\\n\\nWhat gives?\\n\\n",
                "solutionTags": [],
                "code": "[[2,1,0],[2,2,1],[0,2,2]]\\n\\nThis test case \"expects\" 2 possible good people for an answer but that\\'s impossible:\\n- person 0 can never tell the truth because that would imply that person 1 is good, but persons 0 and 1 disagree on person 2.\\n- person 0 is lying (therefore bad), thus person 1 is also bad, leaving us with at most 1 good person.\\n\\nWhat gives?\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1711696,
                "title": "python-dfs",
                "content": "\\tclass Solution(object):\\n\\t\\tdef maximumGood(self, statements):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type statements: List[List[int]]\\n\\t\\t\\t:rtype: int\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tn = len(statements)        \\n\\t\\t\\tlists = []\\n\\t\\t\\tres = 0\\n\\t\\t\\tself.generate(n, lists, [])\\n\\t\\t\\tfor sequence in lists:\\n\\t\\t\\t\\tif sum(sequence) <= res: continue\\n\\t\\t\\t\\tif self.check(sequence, statements):\\n\\t\\t\\t\\t\\tres = max(res, sum(sequence))\\n\\t\\t\\treturn res\\n\\n\\t\\tdef generate(self, length, res, temp):\\n\\t\\t\\tif length == 0:\\n\\t\\t\\t\\tres.append(temp)\\n\\t\\t\\t\\treturn res\\n\\t\\t\\tself.generate(length - 1, res, temp + [0])\\n\\t\\t\\tself.generate(length - 1, res, temp + [1])\\n\\n\\t\\tdef check(self, sequence, statements):\\n\\t\\t\\tn = len(statements)\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tfor j in range(n):\\n\\t\\t\\t\\t\\tif sequence[i] == 1 and statements[i][j] != 2:\\n\\t\\t\\t\\t\\t\\tif statements[i][j] != sequence[j]:\\n\\t\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\treturn True",
                "solutionTags": [],
                "code": "\\tclass Solution(object):\\n\\t\\tdef maximumGood(self, statements):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type statements: List[List[int]]\\n\\t\\t\\t:rtype: int\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tn = len(statements)        \\n\\t\\t\\tlists = []\\n\\t\\t\\tres = 0\\n\\t\\t\\tself.generate(n, lists, [])\\n\\t\\t\\tfor sequence in lists:\\n\\t\\t\\t\\tif sum(sequence) <= res: continue\\n\\t\\t\\t\\tif self.check(sequence, statements):\\n\\t\\t\\t\\t\\tres = max(res, sum(sequence))\\n\\t\\t\\treturn res\\n\\n\\t\\tdef generate(self, length, res, temp):\\n\\t\\t\\tif length == 0:\\n\\t\\t\\t\\tres.append(temp)\\n\\t\\t\\t\\treturn res\\n\\t\\t\\tself.generate(length - 1, res, temp + [0])\\n\\t\\t\\tself.generate(length - 1, res, temp + [1])\\n\\n\\t\\tdef check(self, sequence, statements):\\n\\t\\t\\tn = len(statements)\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tfor j in range(n):\\n\\t\\t\\t\\t\\tif sequence[i] == 1 and statements[i][j] != 2:\\n\\t\\t\\t\\t\\t\\tif statements[i][j] != sequence[j]:\\n\\t\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\treturn True",
                "codeTag": "Java"
            },
            {
                "id": 1711680,
                "title": "java-bitmask-o-2-n-n-n",
                "content": "```java\\nclass Solution {\\n    public int maximumGood(int[][] statements) {\\n        int n = statements.length;\\n        int res = 0;\\n        int statusCount = (1 << n) - 1;\\n        boolean jump = false;\\n        for (int i = 0; i <= statusCount; ++i) {\\n            jump = false;\\n            for (int j = 0; j < n; ++j) {\\n                for (int k = 0; k < n; ++k) {\\n                    if (j == k) continue;\\n                    boolean jIsGood = (i & (1 << j)) != 0;\\n                    int statement = statements[j][k];\\n                    if (jIsGood) {\\n                        // If j is good person and he lies, we found a contradiction, then try another possibility.\\n                        if ((statement == 0 && (i & (1 << k)) != 0) || (statement == 1 && (i & (1 << k)) == 0)) {\\n                            jump = true;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if (jump) break;\\n            }\\n            if (jump) continue;\\n            res = Math.max(res, goodCount(i));\\n        }\\n        return res;\\n    }\\n    \\n    private int low_bit(int x) {\\n        return x & (-x);\\n    }\\n    private int goodCount(int x) {\\n        int count = 0;\\n        while (x != 0) {\\n            x -= low_bit(x);\\n            ++ count;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bitmask"
                ],
                "code": "```java\\nclass Solution {\\n    public int maximumGood(int[][] statements) {\\n        int n = statements.length;\\n        int res = 0;\\n        int statusCount = (1 << n) - 1;\\n        boolean jump = false;\\n        for (int i = 0; i <= statusCount; ++i) {\\n            jump = false;\\n            for (int j = 0; j < n; ++j) {\\n                for (int k = 0; k < n; ++k) {\\n                    if (j == k) continue;\\n                    boolean jIsGood = (i & (1 << j)) != 0;\\n                    int statement = statements[j][k];\\n                    if (jIsGood) {\\n                        // If j is good person and he lies, we found a contradiction, then try another possibility.\\n                        if ((statement == 0 && (i & (1 << k)) != 0) || (statement == 1 && (i & (1 << k)) == 0)) {\\n                            jump = true;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if (jump) break;\\n            }\\n            if (jump) continue;\\n            res = Math.max(res, goodCount(i));\\n        }\\n        return res;\\n    }\\n    \\n    private int low_bit(int x) {\\n        return x & (-x);\\n    }\\n    private int goodCount(int x) {\\n        int count = 0;\\n        while (x != 0) {\\n            x -= low_bit(x);\\n            ++ count;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1967681,
                "content": [
                    {
                        "username": "chandramani_ramachandran",
                        "content": "- Assuming that person 2 is a good person:\n    - Based on the statement made by person 2, person 1 is a bad person.\n    - Now we know for sure that person 1 is bad and person 2 is good.\n    - Based on the statement made by person 1, and since person 1 is bad, they could be:\n        - telling the truth. [*[There will be a contradiction in this case and this assumption is invalid.]*]\n        - lying. In this case, person 0 is also a bad person and lied in their statement.\n\nWhy will there be a contradiction in that case? We are given only that bad persons sometimes lie and sometimes tell the truth, so even if person 1 is bad, why does it follow that it is a contradiction that he is telling the truth? Perhaps the question should be reworded: 'a bad person always tells at least one lie'??"
                    },
                    {
                        "username": "Finesse",
                        "content": "Much easier than I expected. The example explanations demonstrate a backtracking approach which works very good for the problem."
                    }
                ]
            },
            {
                "id": 1785170,
                "content": [
                    {
                        "username": "chandramani_ramachandran",
                        "content": "- Assuming that person 2 is a good person:\n    - Based on the statement made by person 2, person 1 is a bad person.\n    - Now we know for sure that person 1 is bad and person 2 is good.\n    - Based on the statement made by person 1, and since person 1 is bad, they could be:\n        - telling the truth. [*[There will be a contradiction in this case and this assumption is invalid.]*]\n        - lying. In this case, person 0 is also a bad person and lied in their statement.\n\nWhy will there be a contradiction in that case? We are given only that bad persons sometimes lie and sometimes tell the truth, so even if person 1 is bad, why does it follow that it is a contradiction that he is telling the truth? Perhaps the question should be reworded: 'a bad person always tells at least one lie'??"
                    },
                    {
                        "username": "Finesse",
                        "content": "Much easier than I expected. The example explanations demonstrate a backtracking approach which works very good for the problem."
                    }
                ]
            }
        ]
    }
]