[
    {
        "title": "Longest Valid Parentheses",
        "question_content": "Given a string containing just the characters '(' and ')', return the length of the longest valid (well-formed) parentheses substring.\n&nbsp;\nExample 1:\n\nInput: s = \"(()\"\nOutput: 2\nExplanation: The longest valid parentheses substring is \"()\".\n\nExample 2:\n\nInput: s = \")()())\"\nOutput: 4\nExplanation: The longest valid parentheses substring is \"()()\".\n\nExample 3:\n\nInput: s = \"\"\nOutput: 0\n\n&nbsp;\nConstraints:\n\n\t0 <= s.length <= 3 * 104\n\ts[i] is '(', or ')'.",
        "solutions": [
            {
                "id": 14126,
                "title": "my-o-n-solution-using-a-stack",
                "content": "    class Solution {\\n    public:\\n        int longestValidParentheses(string s) {\\n            int n = s.length(), longest = 0;\\n            stack<int> st;\\n            for (int i = 0; i < n; i++) {\\n                if (s[i] == '(') st.push(i);\\n                else {\\n                    if (!st.empty()) {\\n                        if (s[st.top()] == '(') st.pop();\\n                        else st.push(i);\\n                    }\\n                    else st.push(i);\\n                }\\n            }\\n            if (st.empty()) longest = n;\\n            else {\\n                int a = n, b = 0;\\n                while (!st.empty()) {\\n                    b = st.top(); st.pop();\\n                    longest = max(longest, a-b-1);\\n                    a = b;\\n                }\\n                longest = max(longest, a);\\n            }\\n            return longest;\\n        }\\n    };\\n\\nThe workflow of the solution is as below.\\n\\n 1. Scan the string from beginning to end.  \\n 2. If current character is '(',\\n    push its index to the stack. If current character is ')' and the\\n    character at the index of the top of stack is '(', we just find a\\n    matching pair so pop from the stack. Otherwise, we push the index of\\n    ')' to the stack.\\n 3. After the scan is done, the stack will only\\n    contain the indices of characters which cannot be matched. Then\\n    let's use the opposite side -  substring between adjacent indices\\n    should be valid parentheses. \\n 4. If the stack is empty, the whole input\\n    string is valid. Otherwise, we can scan the stack to get longest\\n    valid substring as described in step 3.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int longestValidParentheses(string s) {\\n            int n = s.length(), longest = 0;\\n            stack<int> st;\\n            for (int i = 0; i < n; i++) {\\n                if (s[i] == '(') st.push(i);\\n                else {\\n                    if (!st.empty()) {\\n                        if (s[st.top()] == '(') st.pop();\\n                        else st.push(i);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 14133,
                "title": "my-dp-o-n-solution-without-using-stack",
                "content": "My solution uses DP. The main idea is as follows: I construct a array <b>longest[]</b>, for any longest[i], it stores the longest length of valid parentheses which is end at i.\\n<br>And the DP idea is :\\n<br> If s[i] is '(', set longest[i] to 0,because any string end with '(' cannot be a valid one.\\n<br>Else if s[i] is ')'\\n<br>\\xa0\\xa0\\xa0\\xa0 If s[i-1] is '(', longest[i] = longest[i-2] + 2\\n<br>\\xa0\\xa0\\xa0\\xa0 Else if s[i-1] is ')' **and s[i-longest[i-1]-1] == '('**, longest[i] = longest[i-1] + 2 + longest[i-longest[i-1]-2]\\n<br> For example, input \"()(())\", at i = 5, longest array is [0,2,0,0,2,0], longest[5] = longest[4] + 2 + longest[1] = 6.\\n<br>\\n \\n\\n       int longestValidParentheses(string s) {\\n                if(s.length() <= 1) return 0;\\n                int curMax = 0;\\n                vector<int> longest(s.size(),0);\\n                for(int i=1; i < s.length(); i++){\\n                    if(s[i] == ')'){\\n                        if(s[i-1] == '('){\\n                            longest[i] = (i-2) >= 0 ? (longest[i-2] + 2) : 2;\\n                            curMax = max(longest[i],curMax);\\n                        }\\n                        else{ // if s[i-1] == ')', combine the previous length.\\n                            if(i-longest[i-1]-1 >= 0 && s[i-longest[i-1]-1] == '('){\\n                                longest[i] = longest[i-1] + 2 + ((i-longest[i-1]-2 >= 0)?longest[i-longest[i-1]-2]:0);\\n                                curMax = max(longest[i],curMax);\\n                            }\\n                        }\\n                    }\\n                    //else if s[i] == '(', skip it, because longest[i] must be 0\\n                }\\n                return curMax;\\n            }\\n\\nUpdated: thanks to **Philip0116**, I have a more concise solution(though this is not as readable as the above one, but concise):\\n\\n    int longestValidParentheses(string s) {\\n            if(s.length() <= 1) return 0;\\n            int curMax = 0;\\n            vector<int> longest(s.size(),0);\\n            for(int i=1; i < s.length(); i++){\\n                if(s[i] == ')' && i-longest[i-1]-1 >= 0 && s[i-longest[i-1]-1] == '('){\\n                        longest[i] = longest[i-1] + 2 + ((i-longest[i-1]-2 >= 0)?longest[i-longest[i-1]-2]:0);\\n                        curMax = max(longest[i],curMax);\\n                }\\n            }\\n            return curMax;\\n        }",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "My solution uses DP. The main idea is as follows: I construct a array <b>longest[]</b>, for any longest[i], it stores the longest length of valid parentheses which is end at i.\\n<br>And the DP idea is :\\n<br> If s[i] is '(', set longest[i] to 0,because any string end with '(' cannot be a valid one.\\n<br>Else if s[i] is ')'\\n<br>\\xa0\\xa0\\xa0\\xa0 If s[i-1] is '(', longest[i] = longest[i-2] + 2\\n<br>\\xa0\\xa0\\xa0\\xa0 Else if s[i-1] is ')' **and s[i-longest[i-1]-1] == '('**, longest[i] = longest[i-1] + 2 + longest[i-longest[i-1]-2]\\n<br> For example, input \"()(())\", at i = 5, longest array is [0,2,0,0,2,0], longest[5] = longest[4] + 2 + longest[1] = 6.\\n<br>\\n \\n\\n       int longestValidParentheses(string s) {\\n                if(s.length() <= 1) return 0;\\n                int curMax = 0;\\n                vector<int> longest(s.size(),0);\\n                for(int i=1; i < s.length(); i++){\\n                    if(s[i] == ')'){\\n                        if(s[i-1] == '('){\\n                            longest[i] = (i-2) >= 0 ? (longest[i-2] + 2) : 2;\\n                            curMax = max(longest[i],curMax);\\n                        }\\n                        else{ // if s[i-1] == ')', combine the previous length.\\n                            if(i-longest[i-1]-1 >= 0 && s[i-longest[i-1]-1] == '('){\\n                                longest[i] = longest[i-1] + 2 + ((i-longest[i-1]-2 >= 0)?longest[i-longest[i-1]-2]:0);\\n                                curMax = max(longest[i],curMax);\\n                            }\\n                        }\\n                    }\\n                    //else if s[i] == '(', skip it, because longest[i] must be 0\\n                }\\n                return curMax;\\n            }\\n\\nUpdated: thanks to **Philip0116**, I have a more concise solution(though this is not as readable as the above one, but concise):\\n\\n    int longestValidParentheses(string s) {\\n            if(s.length() <= 1) return 0;\\n            int curMax = 0;\\n            vector<int> longest(s.size(),0);\\n            for(int i=1; i < s.length(); i++){\\n                if(s[i] == ')' && i-longest[i-1]-1 >= 0 && s[i-longest[i-1]-1] == '('){\\n                        longest[i] = longest[i-1] + 2 + ((i-longest[i-1]-2 >= 0)?longest[i-longest[i-1]-2]:0);\\n                        curMax = max(longest[i],curMax);\\n                }\\n            }\\n            return curMax;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 14147,
                "title": "my-simple-8ms-c-code",
                "content": "    class Solution {\\n    public:\\n        int longestValidParentheses(string s) {\\n            stack<int> stk;\\n            stk.push(-1);\\n            int maxL=0;\\n            for(int i=0;i<s.size();i++)\\n            {\\n                int t=stk.top();\\n                if(t!=-1&&s[i]==')'&&s[t]=='(')\\n                {\\n                    stk.pop();\\n                    maxL=max(maxL,i-stk.top());\\n                }\\n                else\\n                    stk.push(i);\\n            }\\n            return maxL;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int longestValidParentheses(string s) {\\n            stack<int> stk;\\n            stk.push(-1);\\n            int maxL=0;\\n            for(int i=0;i<s.size();i++)\\n            {\\n                int t=stk.top();\\n                if(t!=-1&&s[i]==')'&&s[t]=='(')\\n                {\\n                    stk.pop();\\n                    maxL=max(maxL,i-stk.top());\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 14167,
                "title": "simple-java-solution-o-n-time-one-stack",
                "content": "```\\npublic class Solution {\\n    public int longestValidParentheses(String s) {\\n        Stack<Integer> stack = new Stack<Integer>();\\n        int max=0;\\n        int left = -1;\\n        for(int j=0;j<s.length();j++){\\n            if(s.charAt(j)=='(') stack.push(j);            \\n            else {\\n                if (stack.isEmpty()) left=j;\\n                else{\\n                    stack.pop();\\n                    if(stack.isEmpty()) max=Math.max(max,j-left);\\n                    else max=Math.max(max,j-stack.peek());\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public int longestValidParentheses(String s) {\\n        Stack<Integer> stack = new Stack<Integer>();\\n        int max=0;\\n        int left = -1;\\n        for(int j=0;j<s.length();j++){\\n            if(s.charAt(j)=='(') stack.push(j);            \\n            else {\\n                if (stack.isEmpty()) left=j;\\n                else{\\n                    stack.pop();\\n                    if(stack.isEmpty()) max=Math.max(max,j-left);\\n                    else max=Math.max(max,j-stack.peek());\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1139990,
                "title": "longest-valid-parentheses-short-easy-w-explanation-using-stack",
                "content": "***Solution (Simulating with stack) :***\\n\\nWe can use a stack to find the longest valid parentheses. \\n\\nWe will start by pushing `-1` into the stack at first. This will denote index preceding to **potential start of valid parentheses**. It will be more clear later. Now will start iterating over `s` and we will have two cases -\\n1. **`s[i] == \\'(\\'`** - In this case, we will push the index into the stack (just as we do in valid parentheses check).\\n2. **`s[i] == \\')\\'`** - In this case, we will pop the index from the stack (again just as in parentheses check). Now, after popping, we need to do some simple checks which are main steps of this problem. Again, there will be following scenarios that may occur -\\n    * **stack is not empty** - If stack is not empty, then this **may be our longest valid parentheses**. We update the `MAX_len` as `max(MAX_len, current index - stack.top())`. Do notice, that our bottom of stack will always hold index preceding to a potential valid parentheses.\\n\\t* **stack becomes empty** - This will only happen when we have an extra \\')\\' bracket. There may have been valid parentheses previously which have been updated and stored in `MAX_len`. But, since we now have an extra closing bracket any further extensions of previous valid parentheses is not possible. So, push the current index into stack, again which will denote that bottom of stack will hold the index preceding to a **potential** valid parentheses.\\n\\n```\\nExample - \\'()())()\\'\\nInitial stack(from bottom to top) :  [ -1 ] , MAX = 0\\n\\n1. i = 0          |   s[i] = \\'(\\'        =>     case-1: push current index into stack\\nstack : [-1, 0]   |   MAX = 0\\n\\n2. i = 1          |   s[i] = \\')\\'        =>     case-2.1: pop. After pop, stack is not empty so update MAX.\\nstack : [-1]      |   MAX = max(0, 1 - (-1)) = 2.\\n\\n\\'NOTE : Since the index starts from 0, having index preceding to the start of valid parentheses will give us actual length of the valid parentheses,\\ninstead of us having to add 1 to it everytime.\\'\\n\\n3. i = 2          |   s[i] = \\'(\\'        =>     case-1: push current index into stack\\nstack : [-1, 1]   |   MAX = 2.\\n\\n4. i = 3          |   s[i] = \\')\\'        =>     case-2.1: pop. After pop, stack is not empty so update MAX.\\nstack : [-1]      |   MAX = max(2, 3 - (-1)) = 4.\\n\\n5. i = 4          |   s[i] = \\')\\'        =>     case-2.2: pop. After pop, stack is empty, so push current index into stack.\\nThis denotes any valid parentheses from now will start from next index and previous valid parentheses cant be extended further.\\nstack : [4]       |   MAX = 4.\\n\\n6. i = 5          |   s[i] = \\'(\\'        =>     case-1: push current index into stack\\nstack : [4, 5]    |   MAX = 4.\\n\\n7. i = 6          |   s[i] = \\')\\'        =>     case-2.2: pop. After pop, stack is empty, so push current index into stack.\\nstack : [4]       |   MAX = max(4, 6 - 4) = 4.\\n```\\n\\nThe small simulation above might have given you the idea of how this process works. Watch the LC solution showing a gif which will give you better idea. Below is them implementation of the same -\\n\\n\\n```\\nint longestValidParentheses(string s) {\\n\\tint MAX = 0;  // denotes length of maximum valid parentheses\\n\\tstack<int> stk;\\n\\tstk.push(-1); // bottom of stack will always hold index preceding to potential start of valid parentheses\\n\\tfor(int i = 0; i < size(s); i++)\\n\\t\\tif(s[i] == \\'(\\') stk.push(i);            \\n\\t\\telse{                \\n\\t\\t\\tstk.pop();\\n\\t\\t\\tif(stk.empty()) stk.push(i);\\n\\t\\t\\telse MAX = max(MAX, i - stk.top());\\n\\t\\t}        \\n\\treturn MAX;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N)`**, for iterating over the string s.\\n***Space Complexity :*** **`O(N)`**, for maintaining the stack.\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nExample - \\'()())()\\'\\nInitial stack(from bottom to top) :  [ -1 ] , MAX = 0\\n\\n1. i = 0          |   s[i] = \\'(\\'        =>     case-1: push current index into stack\\nstack : [-1, 0]   |   MAX = 0\\n\\n2. i = 1          |   s[i] = \\')\\'        =>     case-2.1: pop. After pop, stack is not empty so update MAX.\\nstack : [-1]      |   MAX = max(0, 1 - (-1)) = 2.\\n\\n\\'NOTE : Since the index starts from 0, having index preceding to the start of valid parentheses will give us actual length of the valid parentheses,\\ninstead of us having to add 1 to it everytime.\\'\\n\\n3. i = 2          |   s[i] = \\'(\\'        =>     case-1: push current index into stack\\nstack : [-1, 1]   |   MAX = 2.\\n\\n4. i = 3          |   s[i] = \\')\\'        =>     case-2.1: pop. After pop, stack is not empty so update MAX.\\nstack : [-1]      |   MAX = max(2, 3 - (-1)) = 4.\\n\\n5. i = 4          |   s[i] = \\')\\'        =>     case-2.2: pop. After pop, stack is empty, so push current index into stack.\\nThis denotes any valid parentheses from now will start from next index and previous valid parentheses cant be extended further.\\nstack : [4]       |   MAX = 4.\\n\\n6. i = 5          |   s[i] = \\'(\\'        =>     case-1: push current index into stack\\nstack : [4, 5]    |   MAX = 4.\\n\\n7. i = 6          |   s[i] = \\')\\'        =>     case-2.2: pop. After pop, stack is empty, so push current index into stack.\\nstack : [4]       |   MAX = max(4, 6 - 4) = 4.\\n```\n```\\nint longestValidParentheses(string s) {\\n\\tint MAX = 0;  // denotes length of maximum valid parentheses\\n\\tstack<int> stk;\\n\\tstk.push(-1); // bottom of stack will always hold index preceding to potential start of valid parentheses\\n\\tfor(int i = 0; i < size(s); i++)\\n\\t\\tif(s[i] == \\'(\\') stk.push(i);            \\n\\t\\telse{                \\n\\t\\t\\tstk.pop();\\n\\t\\t\\tif(stk.empty()) stk.push(i);\\n\\t\\t\\telse MAX = max(MAX, i - stk.top());\\n\\t\\t}        \\n\\treturn MAX;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 14278,
                "title": "two-java-solutions-with-explanation-stack-dp-short-easy-to-understand",
                "content": "// **Stack solution  10ms**  \\nThe idea is simple, we only update the result (max) when we find a \"pair\".  \\nIf we find a pair. We throw this pair away and see how big the gap is between current and previous invalid.  \\nEX: \"( )( )\"  \\nstack: -1, 0,  \\nwhen we get to index 1 \")\", the peek is \"(\" so we pop it out and see what's before \"(\".  \\nIn this example it's -1. So the gap is \"current_index\" - (-1) = 2.  \\n\\nThe idea **only update the result (max) when we find a \"pair\"** and **push -1 to stack first** covered all edge cases.  \\n\\n    public class Solution {\\n        public int longestValidParentheses(String s) {\\n            LinkedList<Integer> stack = new LinkedList<>();\\n            int result = 0;\\n            stack.push(-1);\\n            for (int i = 0; i < s.length(); i++) {\\n                if (s.charAt(i) == ')' && stack.size() > 1 && s.charAt(stack.peek()) == '(') {\\n                    stack.pop();\\n                    result = Math.max(result, i - stack.peek());\\n                } else {\\n                    stack.push(i);\\n                }\\n            }\\n            return result;\\n        }\\n    }\\n\\n\\n\\n**//DP solution  4ms**  \\nThe idea is go through the string and use DP to store the longest valid parentheses at that point.  \\ntake example \"()(())\"  \\ni :    [0,1,2,3,4,5]  \\ns :   [( ,) ,( ,( ,) ,) ]  \\nDP:[0,2,0,0,2,6]  \\n\\n1, We count all the \\u2018(\\u2018.  \\n2, If we find a \\u2018)\\u2019 and \\u2018(\\u2018 counter is not 0, we have at least a valid result size of 2. \\u201c()\"  \\n3, Check the the one before (i - 1). If DP[i - 1] is not 0 means we have something like this \\u201c(())\\u201d . This will have DP \\u201c0024\"  \\n4, We might have something before \"(())\\u201d. Take \"()(())\\u201d example, Check the i = 1 because this might be a consecutive valid string.  \\n\\n    public class Solution {\\n        public int longestValidParentheses(String s) {\\n            int[] dp = new int[s.length()];\\n            int result = 0;\\n            int leftCount = 0;\\n            for (int i = 0; i < s.length(); i++) {\\n                if (s.charAt(i) == '(') {\\n                    leftCount++;\\n                } else if (leftCount > 0){\\n                    dp[i] = dp[i - 1] + 2;\\n                    dp[i] += (i - dp[i]) >= 0 ? dp[i - dp[i]] : 0;\\n                    result = Math.max(result, dp[i]);\\n                    leftCount--;\\n                }\\n            }\\n            return result;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "class Solution {\\n        public int longestValidParentheses(String s) {\\n            LinkedList<Integer> stack = new LinkedList<>();\\n            int result = 0;\\n            stack.push(-1);\\n            for (int i = 0; i < s.length(); i++) {\\n                if (s.charAt(i) == ')' && stack.size() > 1 && s.charAt(stack.peek()) == '(') {\\n                    stack.pop();\\n                    result = Math.max(result, i - stack.peek());\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 14312,
                "title": "my-ten-lines-python-solution",
                "content": "   let dp[i] is the number of longest valid  Parentheses ended with the i - 1 position of s, then we have the following relationship:\\ndp[i + 1] = dp[p] + i - p + 1 where p is the position of '(' which can matches current ')' in the stack.\\n\\n      def longestValidParentheses(self, s):\\n        dp, stack = [0]*(len(s) + 1), []\\n        for i in range(len(s)):\\n            if s[i] == '(':\\n                stack.append(i)\\n            else:\\n                if stack:\\n                    p = stack.pop()\\n                    dp[i + 1] = dp[p] + i - p + 1\\n        return max(dp)",
                "solutionTags": [],
                "code": "   let dp[i] is the number of longest valid  Parentheses ended with the i - 1 position of s, then we have the following relationship:\\ndp[i + 1] = dp[p] + i - p + 1 where p is the position of '(' which can matches current ')' in the stack.\\n\\n      def longestValidParentheses(self, s):\\n        dp, stack = [0]*(len(s) + 1), []\\n        for i in range(len(s)):\\n            if s[i] == '(':\\n                stack.append(i)\\n            else:\\n                if stack:\\n                    p = stack.pop()\\n                    dp[i + 1] = dp[p] + i - p + 1\\n        return max(dp)",
                "codeTag": "Python3"
            },
            {
                "id": 345045,
                "title": "c-easy-to-understand",
                "content": "Rather than working with complex valid parenthesis strings, we just mark all of the occurences where an open parenthesis matches a close parenthesis. The idea is to then concatenate all of these individual valid parentheses to identify the longest valid streak of parentheses.\\n\\nFirst, we iterate through the string, keeping track of the indices of open parentheses in a stack. Every time we hit a close parenthesis, we know that the last open and the current close are both valid, so we mark both of these as being valid by overwriting them in the original string with `*`.\\n\\nOnce we have all of the valid individual parentheses marked, we iterate through the string once more and identify the longest sequence of `*`, which is our answer.\\n```cpp\\nint longestValidParentheses(string s) {\\n\\tstack<int> opens;\\n\\tfor(int i = 0; i < s.size(); i++) {\\n\\t\\tif(s[i] == \\'(\\') opens.push(i);\\n\\t\\telse if(opens.size()) {\\n\\t\\t\\ts[opens.top()] = s[i] = \\'*\\';\\n\\t\\t\\topens.pop();\\n\\t\\t}\\n\\t}\\n\\n\\tint curr = 0, res = 0;\\n\\tfor(int i = 0; i <= s.size(); i++) {\\n\\t\\tif(s[i] == \\'*\\') curr++;\\n\\t\\telse {\\n\\t\\t\\tres = max(res, curr);\\n\\t\\t\\tcurr = 0;\\n\\t\\t}\\n\\t}\\n\\n\\treturn max(curr, res);\\n}\\n```\\n\\n---\\n\\n**Alternate Solution:**\\n\\nTo reduce memory usage, we can take another approach. Scan the string from left to right, replacing any invalid parentheses with `*`. Then repeat the process, scanning from right to left. The string we\\'re left with should have \"pockets\" of valid parentheses strings separated by `*`. We simply have to iterate through the string and count the longest stretch of parentheses.\\n```\\nint longestValidParentheses(string s, int res = 0) {\\n\\tfor (int i = 0, n = 0; i < s.size(); ++i)\\n\\t\\tif (s[i] == \\'(\\') ++n;\\n\\t\\telse if (!n--) s[i] = \\'*\\', n = 0;\\n\\tfor (int i = s.size() - 1, n = 0; i >= 0; --i) \\n\\t\\tif (s[i] == \\')\\') ++n;\\n\\t\\telse if (s[i] == \\'*\\') n = 0;\\n\\t\\telse if (!n--) s[i] = \\'*\\', n = 0;\\n\\tfor (int i = 0, cur = 0; i < s.size(); ++i)\\n\\t\\tif (s[i] != \\'*\\') res = max(res, ++cur);\\n\\t\\telse cur = 0;\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nint longestValidParentheses(string s) {\\n\\tstack<int> opens;\\n\\tfor(int i = 0; i < s.size(); i++) {\\n\\t\\tif(s[i] == \\'(\\') opens.push(i);\\n\\t\\telse if(opens.size()) {\\n\\t\\t\\ts[opens.top()] = s[i] = \\'*\\';\\n\\t\\t\\topens.pop();\\n\\t\\t}\\n\\t}\\n\\n\\tint curr = 0, res = 0;\\n\\tfor(int i = 0; i <= s.size(); i++) {\\n\\t\\tif(s[i] == \\'*\\') curr++;\\n\\t\\telse {\\n\\t\\t\\tres = max(res, curr);\\n\\t\\t\\tcurr = 0;\\n\\t\\t}\\n\\t}\\n\\n\\treturn max(curr, res);\\n}\\n```\n```\\nint longestValidParentheses(string s, int res = 0) {\\n\\tfor (int i = 0, n = 0; i < s.size(); ++i)\\n\\t\\tif (s[i] == \\'(\\') ++n;\\n\\t\\telse if (!n--) s[i] = \\'*\\', n = 0;\\n\\tfor (int i = s.size() - 1, n = 0; i >= 0; --i) \\n\\t\\tif (s[i] == \\')\\') ++n;\\n\\t\\telse if (s[i] == \\'*\\') n = 0;\\n\\t\\telse if (!n--) s[i] = \\'*\\', n = 0;\\n\\tfor (int i = 0, cur = 0; i < s.size(); ++i)\\n\\t\\tif (s[i] != \\'*\\') res = max(res, ++cur);\\n\\t\\telse cur = 0;\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 243913,
                "title": "7ms-100-o-n-time-o-1-space-without-stack-or-array",
                "content": "- This solution is inspired by maximum sum of subsequence.\\n\\t- Let\\'s recall the O(n) solution for that problem: we give up when the current sum < 0, set the sum = 0 and restart counting from the next number; and we records the maximum all the time.\\n\\t- In this problem, I use sum to indicate whether the expression is balanced:\\n\\t\\t- +1 to represent \\'(\\' and -1 for \\')\\'; if sum == 0, then the substring is balanced;\\n\\t\\t- sum < 0 means the expression is unbalanced, where I give up the current length and start again.\\n\\t- However, when we scan from left side, we can only find the expression unbalanced when \\')\\' appears too often, and \\'(\\' should also be checked for balance, so we should scan again from right side.\\n\\t- Total time complexity is O(n) as we scanned 2 times, and space complexity is O(1) as we don\\'t record things in an array or stack:)\\n```java\\n\\tpublic int longestValidParenthesesOnline(String s) {\\n        if (s == null) return -1;\\n        if (s.length() == 0) return 0;\\n        char[] str = s.toCharArray();\\n        int sum = 0, res = 0, len = 0, n = s.length();\\n\\t\\t// Scan the string from left side, plus 1 for \\'(\\' and minus 1 for \\')\\'.\\n        for (int i = 0; i < n; i++) {\\n            if (str[i] == \\'(\\') sum++;\\n            else sum--;\\n            if (sum < 0) {\\n                sum = 0;\\n                len = 0;\\n            } else {\\n                len++;\\n                if (sum == 0) res = Math.max(res, len);\\n            }\\n        }\\n\\t\\t// Scan again from right side, plus 1 for \\')\\' and minus 1 for \\'(\\'.\\n        sum = 0;\\n        len = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (str[i] == \\')\\') sum++;\\n            else sum--;\\n            if (sum < 0) {\\n                sum = 0;\\n                len = 0;\\n            } else {\\n                len++;\\n                if (sum == 0) res = Math.max(res, len);\\n            }\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "- This solution is inspired by maximum sum of subsequence.\\n\\t- Let\\'s recall the O(n) solution for that problem: we give up when the current sum < 0, set the sum = 0 and restart counting from the next number; and we records the maximum all the time.\\n\\t- In this problem, I use sum to indicate whether the expression is balanced:\\n\\t\\t- +1 to represent \\'(\\' and -1 for \\')\\'; if sum == 0, then the substring is balanced;\\n\\t\\t- sum < 0 means the expression is unbalanced, where I give up the current length and start again.\\n\\t- However, when we scan from left side, we can only find the expression unbalanced when \\')\\' appears too often, and \\'(\\' should also be checked for balance, so we should scan again from right side.\\n\\t- Total time complexity is O(n) as we scanned 2 times, and space complexity is O(1) as we don\\'t record things in an array or stack:)\\n```java\\n\\tpublic int longestValidParenthesesOnline(String s) {\\n        if (s == null) return -1;\\n        if (s.length() == 0) return 0;\\n        char[] str = s.toCharArray();\\n        int sum = 0, res = 0, len = 0, n = s.length();\\n\\t\\t// Scan the string from left side, plus 1 for \\'(\\' and minus 1 for \\')\\'.\\n        for (int i = 0; i < n; i++) {\\n            if (str[i] == \\'(\\') sum++;\\n            else sum--;\\n            if (sum < 0) {\\n                sum = 0;\\n                len = 0;\\n            } else {\\n                len++;\\n                if (sum == 0) res = Math.max(res, len);\\n            }\\n        }\\n\\t\\t// Scan again from right side, plus 1 for \\')\\' and minus 1 for \\'(\\'.\\n        sum = 0;\\n        len = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (str[i] == \\')\\') sum++;\\n            else sum--;\\n            if (sum < 0) {\\n                sum = 0;\\n                len = 0;\\n            } else {\\n                len++;\\n                if (sum == 0) res = Math.max(res, len);\\n            }\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1139982,
                "title": "python-short-dp-explained",
                "content": "This is quite difficult problem, which can be solved with dymamic programming. As usual let us define `dp[i]` the length of the longest valid substring ending at `i`-th index. We can have several cases now:\\n1. If `i == -1`, it means we reached empty string, return `0`, answer for empty string. Also if `s[i] = (`, answer is also `0`, because no valid parantheses can end with `(`\\n2. Now, we have case, when `s[i] = )`. Let us look at the previous element. If it is equal to `(`, then we have `()` as two last elements and we can return `dp(i-2) + 2`.\\n3. Now consider the case, when `s[i-1] = )`, it means, that we have the following situation: `...))`. If we want to find the longest valid parentheses for `i`, first we need to deal with `i-1`. Define `P = i - dp(i-1) - 1`. Then we have the following situation:\\n\\n`...((.....))`\\n\\n`...P.......i`\\n\\nHere on the top is the structure of string and in the bottom are indexes. String from `P + 1` to `i - 1` indexes including is the longest valid parentheses endind with `i-1` place. What we can say about place `P`. If we have `)` element on this place, then we need to return `0`: in this case we have patten `...)(...))...` and we **know** that answer for `dp(P)` is equal to `0`: if it is not, what we considered was not the longest answer for `i-1`. And if answer for `dp(P)` is zero, than answer for `dp(i)` is zero as well.\\nIn the case, when we have `...((.....))`, answer is `dp(i-1) + dp(P-1) + 2`. \\n\\n#### Complexity\\nTime complexity is `O(n)`, space complexity as well.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def longestValidParentheses(self, s):\\n        @lru_cache(None)\\n        def dp(i):\\n            if i == -1 or s[i] == \"(\": return 0\\n            if i >= 1 and s[i-1:i+1] == \"()\": return dp(i-2) + 2\\n            P = i - dp(i-1) - 1\\n            if P >= 0 and s[P] == \"(\":\\n                return dp(i-1) + dp(P-1) + 2\\n            return 0\\n            \\n        return max(dp(i) for i in range(len(s))) if s else 0\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def longestValidParentheses(self, s):\\n        @lru_cache(None)\\n        def dp(i):\\n            if i == -1 or s[i] == \"(\": return 0\\n            if i >= 1 and s[i-1:i+1] == \"()\": return dp(i-2) + 2\\n            P = i - dp(i-1) - 1\\n            if P >= 0 and s[P] == \"(\":\\n                return dp(i-1) + dp(P-1) + 2\\n            return 0\\n            \\n        return max(dp(i) for i in range(len(s))) if s else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 123926,
                "title": "best-python-solution-beats-100",
                "content": "```\\nclass Solution:\\n    def longestValidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        stack = [0]\\n        longest = 0\\n        \\n        for c in s:\\n            if c == \"(\":\\n                stack.append(0)\\n            else:\\n                if len(stack) > 1:\\n                    val = stack.pop()\\n                    stack[-1] += val + 2\\n                    longest = max(longest, stack[-1])\\n                else:\\n                    stack = [0]\\n\\n        return longest\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestValidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        stack = [0]\\n        longest = 0\\n        \\n        for c in s:\\n            if c == \"(\":\\n                stack.append(0)\\n            else:\\n                if len(stack) > 1:\\n                    val = stack.pop()\\n                    stack[-1] += val + 2\\n                    longest = max(longest, stack[-1])\\n                else:\\n                    stack = [0]\\n\\n        return longest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2068235,
                "title": "python-easy-2-approaches-space-o-n-and-o-1",
                "content": "The time complexity for both the approaches is `O(len(s)`.\\n\\n 1. ##### **Space - O(len(s))**\\n\\nThis approach solves the problem in similar way as https://leetcode.com/problems/valid-parentheses/ using `Stack`. The stack is used to track indices of `(`. So whenever we hit a `)`, we pop the pair from stack and update the length of valid substring.\\n\\n```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        max_length = 0\\n        stck=[-1] # initialize with a start index\\n        for i in range(len(s)):\\n            if s[i] == \\'(\\':\\n                stck.append(i)\\n            else:\\n                stck.pop()\\n                if not stck: # if popped -1, add a new start index\\n                    stck.append(i)\\n                else:\\n                    max_length=max(max_length, i-stck[-1]) # update the length of the valid substring\\n        return max_length\\n```\\n\\n2. ##### **Space - O(1)**\\nThe valid parantheses problem can also be solved using a counter variable. Below implementation modifies this approach a bit and uses two counters:`left` and `right` for `(` and `)` respectively. \\n\\nThe pseudo code for this approach:\\n1. Increment `left` on hitting `(`.\\n2. Increment `right` on hitting `)`.\\n3. If `left=right`, then calculate the current substring length and update the `max_length`\\n4. If `right>left`, then it means it\\'s an invalid substring. So reset both `left` and `right` to `0`.\\n\\nPerform the above algorithm once on original `s` and then on the reversed `s`.\\n\\n```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        max_length = 0\\n                \\n        l,r=0,0        \\n        # traverse the string from left to right\\n        for i in range(len(s)):\\n            if s[i] == \\'(\\':\\n                l+=1\\n            else:\\n                r+=1                        \\n            if l == r:# valid balanced parantheses substring \\n                max_length=max(max_length, l*2)\\n            elif r>l: # invalid case as \\')\\' is more\\n                l=r=0\\n        \\n        l,r=0,0        \\n        # traverse the string from right to left\\n        for i in range(len(s)-1,-1,-1):\\n            if s[i] == \\'(\\':\\n                l+=1\\n            else:\\n                r+=1            \\n            if l == r:# valid balanced parantheses substring \\n                max_length=max(max_length, l*2)\\n            elif l>r: # invalid case as \\'(\\' is more\\n                l=r=0\\n        return max_length\\n```\\n\\n---\\n\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        max_length = 0\\n        stck=[-1] # initialize with a start index\\n        for i in range(len(s)):\\n            if s[i] == \\'(\\':\\n                stck.append(i)\\n            else:\\n                stck.pop()\\n                if not stck: # if popped -1, add a new start index\\n                    stck.append(i)\\n                else:\\n                    max_length=max(max_length, i-stck[-1]) # update the length of the valid substring\\n        return max_length\\n```\n```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        max_length = 0\\n                \\n        l,r=0,0        \\n        # traverse the string from left to right\\n        for i in range(len(s)):\\n            if s[i] == \\'(\\':\\n                l+=1\\n            else:\\n                r+=1                        \\n            if l == r:# valid balanced parantheses substring \\n                max_length=max(max_length, l*2)\\n            elif r>l: # invalid case as \\')\\' is more\\n                l=r=0\\n        \\n        l,r=0,0        \\n        # traverse the string from right to left\\n        for i in range(len(s)-1,-1,-1):\\n            if s[i] == \\'(\\':\\n                l+=1\\n            else:\\n                r+=1            \\n            if l == r:# valid balanced parantheses substring \\n                max_length=max(max_length, l*2)\\n            elif l>r: # invalid case as \\'(\\' is more\\n                l=r=0\\n        return max_length\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14355,
                "title": "my-solution-using-one-stack-in-one-pass",
                "content": "Since any valid parentheses sequence starts from a '(' and ends at ')', we can calculate new length when we meet a ')'. The key is to use a stack to store all the indices and the start position is always the one on top of the stack. See the code below for details.\\n\\n\\n     // Using a stack. One pass\\n        int longestValidParentheses(string s) {\\n            vector<int> stack;\\n            int maxLen = 0;\\n            for (int i = 0; i < s.size(); ++i)\\n            {\\n                if (s[i] == '(')\\n                    stack.push_back(i);\\n                else {\\n                    if (!stack.empty() && s[stack.back()] == '(') {\\n                        stack.pop_back();\\n                        int lastPos = -1;\\n                        if (!stack.empty())\\n                            lastPos = stack.back();\\n                        int curLen = i - lastPos;\\n                        maxLen = (maxLen < curLen) ? curLen : maxLen;\\n                    } else\\n                        stack.push_back(i);\\n                }\\n            }\\n            return maxLen;\\n        }",
                "solutionTags": [
                    "Stack"
                ],
                "code": "Since any valid parentheses sequence starts from a '(' and ends at ')', we can calculate new length when we meet a ')'. The key is to use a stack to store all the indices and the start position is always the one on top of the stack. See the code below for details.\\n\\n\\n     // Using a stack. One pass\\n        int longestValidParentheses(string s) {\\n            vector<int> stack;\\n            int maxLen = 0;\\n            for (int i = 0; i < s.size(); ++i)\\n            {\\n                if (s[i] == '(')\\n                    stack.push_back(i);\\n                else {\\n                    if (!stack.empty() && s[stack.back()] == '(') {\\n                        stack.pop_back();\\n                        int lastPos = -1;\\n                        if (!stack.empty())\\n                            lastPos = stack.back();\\n                        int curLen = i - lastPos;\\n                        maxLen = (maxLen < curLen) ? curLen : maxLen;\\n                    } else\\n                        stack.push_back(i);\\n                }\\n            }\\n            return maxLen;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3401956,
                "title": "100-detailed-explaination-with-pictures-o-n-in-c-java-python-stack",
                "content": "# Approach\\n- Here the approach is nothing but we are using a stack and when we encounter an opening brace then we push the index of it into the stack and whenever we touch a closing brace then we see the top of the stack if it\\'s size is one then it means the closing braces have dominated the opening brace. We then edit the top value of the stack to the index of the closing brace.\\n>- This method is clearly depicted in the picture as shown below.\\n\\n![pic1.png](https://assets.leetcode.com/users/images/28c7fe2b-0003-4027-9d8f-94b1abadf7c4_1681156598.7949007.png)\\n\\n>- here answer is given as the line `ans = max(ans , index - stk.top())` only when the size of stack is not 1 and there is a closing brace encountered.\\n\\n---\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int>stk;\\n        stk.push(-1);\\n        int ans = 0;\\n        for(int i = 0 ; i < s.size();  i++)\\n        {\\n            if(s[i] == \\'(\\')\\n                stk.push(i);\\n            else\\n            {\\n                if(stk.size() == 1)\\n                    stk.top() = i;\\n                else\\n                {\\n                    stk.pop();\\n                    ans = max(ans , i - stk.top());\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n    int leftCount = 0;\\n    int rightCount = 0;\\n    int maxLength = 0;\\n    \\n    for (int i = 0; i < s.length(); i++) {\\n        if (s.charAt(i) == \\'(\\') {\\n            leftCount++;\\n        } else {\\n            rightCount++;\\n        }\\n        \\n        if (leftCount == rightCount) {\\n            maxLength = Math.max(maxLength, 2 * rightCount);\\n        } else if (rightCount > leftCount) {\\n            leftCount = rightCount = 0;\\n        }\\n    }\\n    \\n    leftCount = rightCount = 0;\\n    \\n    for (int i = s.length() - 1; i >= 0; i--) {\\n        if (s.charAt(i) == \\'(\\') {\\n            leftCount++;\\n        } else {\\n            rightCount++;\\n        }\\n        \\n        if (leftCount == rightCount) {\\n            maxLength = Math.max(maxLength, 2 * leftCount);\\n        } else if (leftCount > rightCount) {\\n            leftCount = rightCount = 0;\\n        }\\n    }\\n    \\n    return maxLength;\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        stack=[]\\n        l=[\\'0\\']*len(s)\\n        for ind,i in enumerate(s):\\n            if i==\\'(\\':\\n                stack.append(ind)\\n            else:\\n                if stack:\\n                    l[stack.pop()]=\\'1\\'\\n                    l[ind]=\\'1\\'\\n        return max(len(i) for i in \\'\\'.join(l).split(\\'0\\'))\\n```\\n\\n---\\n\\n\\n\\n# Complexity\\n>- Time complexity:Here the complexity would be $$O(n)$$ as we are using only a single loop with a stack only so this runs in a linear complexity.\\n\\n>- Space complexity:Here the space complexity would be $O(n)$ as we are using just a stack that too store the elements in the worst case it goes to that complexity.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n\\n\\n**IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.**\\n\\n![UPVOTE.jpg](https://assets.leetcode.com/users/images/d53e3e8f-f0ff-4dbb-bf1f-f44e71c7e735_1681156831.395462.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int>stk;\\n        stk.push(-1);\\n        int ans = 0;\\n        for(int i = 0 ; i < s.size();  i++)\\n        {\\n            if(s[i] == \\'(\\')\\n                stk.push(i);\\n            else\\n            {\\n                if(stk.size() == 1)\\n                    stk.top() = i;\\n                else\\n                {\\n                    stk.pop();\\n                    ans = max(ans , i - stk.top());\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n    int leftCount = 0;\\n    int rightCount = 0;\\n    int maxLength = 0;\\n    \\n    for (int i = 0; i < s.length(); i++) {\\n        if (s.charAt(i) == \\'(\\') {\\n            leftCount++;\\n        } else {\\n            rightCount++;\\n        }\\n        \\n        if (leftCount == rightCount) {\\n            maxLength = Math.max(maxLength, 2 * rightCount);\\n        } else if (rightCount > leftCount) {\\n            leftCount = rightCount = 0;\\n        }\\n    }\\n    \\n    leftCount = rightCount = 0;\\n    \\n    for (int i = s.length() - 1; i >= 0; i--) {\\n        if (s.charAt(i) == \\'(\\') {\\n            leftCount++;\\n        } else {\\n            rightCount++;\\n        }\\n        \\n        if (leftCount == rightCount) {\\n            maxLength = Math.max(maxLength, 2 * leftCount);\\n        } else if (leftCount > rightCount) {\\n            leftCount = rightCount = 0;\\n        }\\n    }\\n    \\n    return maxLength;\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        stack=[]\\n        l=[\\'0\\']*len(s)\\n        for ind,i in enumerate(s):\\n            if i==\\'(\\':\\n                stack.append(ind)\\n            else:\\n                if stack:\\n                    l[stack.pop()]=\\'1\\'\\n                    l[ind]=\\'1\\'\\n        return max(len(i) for i in \\'\\'.join(l).split(\\'0\\'))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14256,
                "title": "my-easy-o-n-java-solution-with-explanation",
                "content": "    public class Solution {\\n        public int longestValidParentheses(String s) {\\n            int res=0;\\n            int tep=0;\\n            Stack<Integer> s1=new Stack<>();\\n            int data[]=new int[s.length()];\\n            for(int i=0;i<s.length();i++){\\n                char c=s.charAt(i);\\n                if(c=='(') s1.push(i);\\n                else{\\n                    if(!s1.empty()){\\n                        data[i]=1;\\n                        data[s1.pop()]=1;\\n                    }\\n                }\\n            }\\n            for(int i:data){\\n                if(i==1) tep++;\\n                else {res=Math.max(tep,res);tep=0;}\\n            }\\n            return Math.max(tep,res);\\n        }\\n    }\\n\\nImaging we are coloring the original string, each substring that has valid parentheses is colored with '1' and other characters are colored by '0'.\\nFor example \"( ) ( ( ) \"would become \"11011\". Thus, the problem has converted to finding the longest subsequence that all elements are '1', which could be easily solved.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int longestValidParentheses(String s) {\\n            int res=0;\\n            int tep=0;\\n            Stack<Integer> s1=new Stack<>();\\n            int data[]=new int[s.length()];\\n            for(int i=0;i<s.length();i++){\\n                char c=s.charAt(i);\\n                if(c=='(') s1.push(i);\\n                else{\\n                    if(!s1.empty()){\\n                        data[i]=1;\\n                        data[s1.pop()]=1;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 14140,
                "title": "constant-space-o-n-time-with-forward-and-backward-pass",
                "content": "When right parentheses are more than left parentheses in the forward pass, we can discard previous parentheses. In the backward pass, when left parentheses are more than right parentheses, we can discard previous parentheses. \\n\\n\\n    int longestValidParentheses(string s) {\\n        int longest = 0;\\n        int extra=0;\\n        int length=0;\\n        for(int i=0; i<s.size(); i++) {\\n            if(s[i] == '(') {\\n                extra++;\\n                length++;\\n            }\\n            else {\\n                if(extra>0) {\\n                    extra--;\\n                    length++;\\n                    if(extra == 0)\\n                        longest = max(longest, length);\\n                }\\n                else {\\n                    extra = 0;\\n                    length=0;\\n                }\\n            }\\n        }\\n        length = 0;\\n        extra=0;\\n        for(int i=s.size()-1; i>=0; i--) {\\n            if(s[i] == ')') {\\n                extra++;\\n                length++;\\n            }\\n            else {\\n                if(extra>0){\\n                    extra--;\\n                    length++;\\n                    if(extra == 0)\\n                        longest = max(longest, length);\\n                    \\n                }\\n                else {\\n                    extra = 0;\\n                    length=0;\\n                }\\n            }\\n        }\\n        return longest;\\n    }",
                "solutionTags": [],
                "code": "When right parentheses are more than left parentheses in the forward pass, we can discard previous parentheses. In the backward pass, when left parentheses are more than right parentheses, we can discard previous parentheses. \\n\\n\\n    int longestValidParentheses(string s) {\\n        int longest = 0;\\n        int extra=0;\\n        int length=0;\\n        for(int i=0; i<s.size(); i++) {\\n            if(s[i] == '(') {\\n                extra++;\\n                length++;\\n            }\\n            else {\\n                if(extra>0) {\\n                    extra--;\\n                    length++;\\n                    if(extra == 0)\\n                        longest = max(longest, length);\\n                }\\n                else {\\n                    extra = 0;\\n                    length=0;\\n                }\\n            }\\n        }\\n        length = 0;\\n        extra=0;\\n        for(int i=s.size()-1; i>=0; i--) {\\n            if(s[i] == ')') {\\n                extra++;\\n                length++;\\n            }\\n            else {\\n                if(extra>0){\\n                    extra--;\\n                    length++;\\n                    if(extra == 0)\\n                        longest = max(longest, length);\\n                    \\n                }\\n                else {\\n                    extra = 0;\\n                    length=0;\\n                }\\n            }\\n        }\\n        return longest;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 14141,
                "title": "pure-1d-dp-without-using-stack-python-with-detailed-explanation",
                "content": "    class Solution(object):\\n        def longestValidParentheses(self, s):\\n            \"\"\"\\n            :type s: str\\n            :rtype: int\\n            \"\"\"\\n            # use 1D DP\\n            # dp[i] records the longestValidParenthese EXACTLY ENDING at s[i]\\n            dp = [0 for x in xrange(len(s))]\\n            max_to_now = 0\\n            for i in xrange(1,len(s)):\\n                if s[i] == ')':\\n                    # case 1: ()()\\n                    if s[i-1] == '(':\\n                        # add nearest parentheses pairs + 2\\n                        dp[i] = dp[i-2] + 2\\n                    # case 2: (()) \\n                    # i-dp[i-1]-1 is the index of last \"(\" not paired until this \")\"\\n                    elif i-dp[i-1]-1 >= 0 and s[i-dp[i-1]-1] == '(':\\n                        if dp[i-1] > 0: # content within current matching pair is valid \\n                        # add nearest parentheses pairs + 2 + parentheses before last \"(\"\\n                            dp[i] = dp[i-1] + 2 + dp[i-dp[i-1]-2]\\n                        else:\\n                        # otherwise is 0\\n                            dp[i] = 0\\n                    max_to_now = max(max_to_now, dp[i])\\n            return max_to_now",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "    class Solution(object):\\n        def longestValidParentheses(self, s):\\n            \"\"\"\\n            :type s: str\\n            :rtype: int\\n            \"\"\"\\n            # use 1D DP\\n            # dp[i] records the longestValidParenthese EXACTLY ENDING at s[i]\\n            dp = [0 for x in xrange(len(s))]\\n            max_to_now = 0\\n            for i in xrange(1,len(s)):\\n                if s[i] == ')':\\n                    # case 1: ()()\\n                    if s[i-1] == '(':\\n                        # add nearest parentheses pairs + 2\\n                        dp[i] = dp[i-2] + 2\\n                    # case 2: (()) \\n                    # i-dp[i-1]-1 is the index of last \"(\" not paired until this \")\"\\n                    elif i-dp[i-1]-1 >= 0 and s[i-dp[i-1]-1] == '(':\\n                        if dp[i-1] > 0: # content within current matching pair is valid \\n                        # add nearest parentheses pairs + 2 + parentheses before last \"(\"\\n                            dp[i] = dp[i-1] + 2 + dp[i-dp[i-1]-2]\\n                        else:\\n                        # otherwise is 0\\n                            dp[i] = 0\\n                    max_to_now = max(max_to_now, dp[i])\\n            return max_to_now",
                "codeTag": "Java"
            },
            {
                "id": 14284,
                "title": "8-line-python-solution-stack-80ms",
                "content": "To make sure the stack is not empty, first put in a tuple `(-1, ')')` as it will never be poped out and `-1` can be used to calculate `result`.\\n\\n    def longestValidParentheses(self, s):\\n        stack, result = [(-1, ')')], 0\\n        for i, paren in enumerate(s):\\n            if paren == ')' and stack[-1][1] == '(':\\n                stack.pop()\\n                result = max(result, i - stack[-1][0])\\n            else:\\n                stack += (i, paren),\\n        return result",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "To make sure the stack is not empty, first put in a tuple `(-1, ')')` as it will never be poped out and `-1` can be used to calculate `result`.\\n\\n    def longestValidParentheses(self, s):\\n        stack, result = [(-1, ')')], 0\\n        for i, paren in enumerate(s):\\n            if paren == ')' and stack[-1][1] == '(':\\n                stack.pop()\\n                result = max(result, i - stack[-1][0])\\n            else:\\n                stack += (i, paren),\\n        return result",
                "codeTag": "Python3"
            },
            {
                "id": 1349298,
                "title": "accepted-solution-for-swift",
                "content": "```swift\\nclass Solution {\\n    func longestValidParentheses(_ s: String) -> Int {\\n        guard !s.isEmpty else { return 0 }\\n        var val = 0, stack = [-1]\\n        for (i, ch) in s.enumerated() {\\n            guard ch != \"(\" else { stack.append(i); continue }\\n            guard stack.count > 1 else { stack[0] = i; continue }\\n            stack.removeLast()\\n            val = max(val, i - stack.last!)\\n        }\\n        return val\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<p><details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<p><pre>\\nResult: Executed 3 tests, with 0 failures (0 unexpected) in 0.010 (0.012) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // The longest valid parentheses substring is \"()\".\\n    func test0() {\\n        let res = solution.longestValidParentheses(\"(()\")\\n        XCTAssertEqual(res, 2)\\n    }\\n    \\n    // The longest valid parentheses substring is \"()()\".\\n    func test1() {\\n        let res = solution.longestValidParentheses(\")()())\")\\n        XCTAssertEqual(res, 4)\\n    }\\n    \\n    func test2() {\\n        let res = solution.longestValidParentheses(\"\")\\n        XCTAssertEqual(res, 0)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details></p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func longestValidParentheses(_ s: String) -> Int {\\n        guard !s.isEmpty else { return 0 }\\n        var val = 0, stack = [-1]\\n        for (i, ch) in s.enumerated() {\\n            guard ch != \"(\" else { stack.append(i); continue }\\n            guard stack.count > 1 else { stack[0] = i; continue }\\n            stack.removeLast()\\n            val = max(val, i - stack.last!)\\n        }\\n        return val\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // The longest valid parentheses substring is \"()\".\\n    func test0() {\\n        let res = solution.longestValidParentheses(\"(()\")\\n        XCTAssertEqual(res, 2)\\n    }\\n    \\n    // The longest valid parentheses substring is \"()()\".\\n    func test1() {\\n        let res = solution.longestValidParentheses(\")()())\")\\n        XCTAssertEqual(res, 4)\\n    }\\n    \\n    func test2() {\\n        let res = solution.longestValidParentheses(\"\")\\n        XCTAssertEqual(res, 0)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 864061,
                "title": "c-o-n-time-and-o-1-space-0ms-runtime-beats-100-explained",
                "content": "### Intuition\\n\\nBefore explaining the solution, I will write how I came up with the solution.\\n\\nThe main point to notice in this problem is that the moment we get an invalid parenthesis, the subarray can\\'t start from beyond this point.\\nNot clear ? Let\\'s understand with an example.\\n\\nConsider this simple string.\\n```()()))()(())```, at index 4 the subarray starting from index 0 becomes invalid, it is clear the longest valid parenthesis won\\'t start from [0, 3] and end after 4.\\n\\nThis striked me that I can use a sliding window to solve this problem.\\n\\n### How to solve ?\\n\\nConsider a window with left end shown by **i** and right end shown by **j**.\\nInitially **i = 0 and j = 0**\\nLet us consider another variable k which will help us to determine when subarray becomes invalid.\\n\\nNow, we start moving j keeping i as fixed. \\n\\nIncrement k when we encounter ```(``` and decrement when we encounter ```)```.\\n\\nWhenever k becomes zero we will update our answer with max(ans,  j - i + 1)\\nIt is clear when k becomes negative the subarray will become invalid, so we will move the left end i.e **i** to the new position.\\n\\n**Question**\\nWhy are we updating the answer when k is 0 and not when k > 0.\\n**Answer**\\nWe know for sure, whenever we get k as 0 the subarray is valid and length will be j - i + 1.\\nBut when k > 0 the subarray is still valid, but the length will be less than j - i + 1.\\nBut ofcourse we are missing some values, since the length which is less j - i + 1 can be a better answer.\\n\\nConsider this string ```(()```. Here, we will never get k = 0 and hence we can\\'t update our answer.\\n\\n**How to resolve this?**\\nWe have to repeat the above process but this time starting i = n - 1 and j = n - 1. Now, keep moving j to the left side and do the same as above. Here k will increase when we encounter ```)``` and decrease when we encounter ```(```.\\n\\n### Cpp Code\\n\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int n = s.length(), i = 0, ans = 0, k = 0;\\n        for(int j = 0; j < n; j++) {\\n            if(s[j] == \\'(\\')  k++;\\n            else if(s[j] == \\')\\') {\\n                k--;\\n                if(k == 0)\\n                    ans = max(ans, j - i + 1);\\n            }\\n            if(k < 0) {\\n                k = 0;\\n                i = j + 1;\\n            }\\n        }\\n        k = 0, i = n - 1;\\n        for(int j = n - 1; j >= 0; j--) {\\n            if(s[j] == \\')\\') {\\n                k++;\\n            }\\n            else if(s[j] == \\'(\\') {\\n                k--;\\n                if(k == 0)\\n                    ans = max(ans, i - j + 1);\\n            }\\n            if(k < 0) {\\n                k = 0;\\n                i = j - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Please upvote if this post is helpful to you :)**",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```()()))()(())```\n```(```\n```)```\n```(()```\n```)```\n```(```\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int n = s.length(), i = 0, ans = 0, k = 0;\\n        for(int j = 0; j < n; j++) {\\n            if(s[j] == \\'(\\')  k++;\\n            else if(s[j] == \\')\\') {\\n                k--;\\n                if(k == 0)\\n                    ans = max(ans, j - i + 1);\\n            }\\n            if(k < 0) {\\n                k = 0;\\n                i = j + 1;\\n            }\\n        }\\n        k = 0, i = n - 1;\\n        for(int j = n - 1; j >= 0; j--) {\\n            if(s[j] == \\')\\') {\\n                k++;\\n            }\\n            else if(s[j] == \\'(\\') {\\n                k--;\\n                if(k == 0)\\n                    ans = max(ans, i - j + 1);\\n            }\\n            if(k < 0) {\\n                k = 0;\\n                i = j - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2069416,
                "title": "c-easy-simple-stack-solution-o-n-daily-leetcoding-challenge-may-day-24",
                "content": "**Please Upvote If It Helps**\\n\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        // created a stack for storing the open parenthesis \\n        stack<int> st;\\n        st.push(-1);            // initially push -1 to the stack because if there is ) then we can not pop our stack if it is empty\\n        \\n        int ans = 0;\\n        \\n        // iterate over the given string\\n        for(int i=0;i<s.length();i++)\\n        {\\n            // if it is open parenthesis then push that index to the stack\\n            if(s[i] == \\'(\\')\\n                st.push(i);\\n            \\n            // if it is close then pop the stack \\n            // and check it is empty or not if it is empty then push current value to it because if there is another ) then we can not pop our stack if it is empty\\n            // if it is not empty then find the length between the (current index i and stack top index) and store the max value in ans\\n            else\\n            {\\n                st.pop();\\n                \\n                if(st.empty())\\n                    st.push(i);\\n                else\\n                    ans = max(ans,i-st.top());\\n            }\\n        }\\n        \\n        // returning the answer\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        // created a stack for storing the open parenthesis \\n        stack<int> st;\\n        st.push(-1);            // initially push -1 to the stack because if there is ) then we can not pop our stack if it is empty\\n        \\n        int ans = 0;\\n        \\n        // iterate over the given string\\n        for(int i=0;i<s.length();i++)\\n        {\\n            // if it is open parenthesis then push that index to the stack\\n            if(s[i] == \\'(\\')\\n                st.push(i);\\n            \\n            // if it is close then pop the stack \\n            // and check it is empty or not if it is empty then push current value to it because if there is another ) then we can not pop our stack if it is empty\\n            // if it is not empty then find the length between the (current index i and stack top index) and store the max value in ans\\n            else\\n            {\\n                st.pop();\\n                \\n                if(st.empty())\\n                    st.push(i);\\n                else\\n                    ans = max(ans,i-st.top());\\n            }\\n        }\\n        \\n        // returning the answer\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140005,
                "title": "longest-valid-parentheses-js-python-java-c-easy-stack-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nOne of the key things to realize about valid parentheses strings is that they\\'re entirely self-satisfied, meaning that while you can have one substring that is entirely inside another, you can\\'t have two substrings that only partially overlap.\\n\\nThis means that we can use a **greedy O(N) time complexity** solution to this problem without the need for any kind of backtracking. In fact, we should be able to use a very standard stack-based valid parentheses string algorithm with just three very minor modifications.\\n\\nIn a stadard valid parentheses string algorithm, we iterate through the string (**S**) and push the index (**i**) of any **\\'(\\'** to our **stack**. Whenever we find a **\\')\\'**, we match it with the last entry on the **stack** and pop said entry off. We know the string is not valid if we find a **\\')\\'** while there are no **\\'(\\'** indexes in the **stack** with which to match it, and also if we have leftover **\\'(\\'** in the **stack** when we reach the end of **S**.\\n\\nFor this problem, we will need to add in a step that updates our answer (**ans**) when we close a parentheses pair. Since we stored the index of the **\\'(\\'** in our stack, we can easily find the difference between the **\\')\\'** at **i** and the last entry in the **stack**, which should be the length of the valid substring which was just closed.\\n\\nBut here we run into a problem, because consecutive valid substrings can be grouped into a larger valid substring (ie, **\\'()()\\' = 4**). So instead of counting from the *last* **stack** entry, we should actually count from the *second to last* entry, to include any other valid closed substrings since the most recent **\\'(\\'** that will still remain after we pop the just-matched last **stack** entry off.\\n\\nThis, of course, brings us to the second and third changes. Since we\\'re checking the second to last **stack** entry, what happens in the case of **\\'()()\\'** when you close the second valid substring yet there\\'s only the one **stack** entry left at the time?\\n\\nTo avoid this issue, we can just wrap the entire string in another imaginary set of parentheses by starting with **stack = [-1]**, indicating that there\\'s an imaginary **\\'(\\'** just before the beginning of the string at **i = 0**.\\n\\nThe other issue is that we will want to continue even if the string up to **i** becomes invalid due to a **\\')\\'** appearing when the **stack** is \"empty\", or in this case has only our imaginary index left. In that case, we can just effectively restart our **stack** by updating our imaginary **\\'(\\'** index (**stack[0] = i**) and continue on.\\n\\nThen, once we reach the end of **S**, we can just **return ans**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThere are only minor differences in the code for all four languages.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **76ms / 39.9MB** (beats 99% / 78%).\\n```javascript\\nvar longestValidParentheses = function(S) {\\n    let stack = [-1], ans = 0\\n    for (let i = 0; i < S.length; i++)\\n        if (S[i] === \\'(\\') stack.push(i)\\n        else if (stack.length === 1) stack[0] = i\\n        else stack.pop(), ans = Math.max(ans, i - stack[stack.length-1])\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **40ms / 14.6MB** (beats 88% / 71%).\\n```python\\nclass Solution:\\n    def longestValidParentheses(self, S: str) -> int:\\n        stack, ans = [-1], 0\\n        for i in range(len(S)):\\n            if S[i] == \\'(\\': stack.append(i)\\n            elif len(stack) == 1: stack[0] = i\\n            else:\\n                stack.pop()\\n                ans = max(ans, i - stack[-1])\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **2ms / 38.7MB** (beats 69% / 94%).\\n```java\\nclass Solution {\\n    public int longestValidParentheses(String S) {\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(-1);\\n        int ans = 0;\\n        for (int i = 0; i < S.length(); i++)\\n            if (S.charAt(i) == \\'(\\') stack.push(i);\\n            else {\\n                stack.pop();\\n                if (stack.isEmpty()) stack.push(i);\\n                else ans = Math.max(ans, i - stack.peek());\\n            }\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 7.1MB** (beats 100% / 71%).\\n```c++\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string S) {\\n        vector<int> stack = {-1};\\n        int ans = 0;\\n        for (int i = 0; i < S.size(); i++)\\n            if (S[i] == \\'(\\') stack.push_back(i);\\n            else if (stack.size() == 1) stack[0] = i;\\n            else {\\n                stack.pop_back();\\n                ans = max(ans, i - stack.back());\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar longestValidParentheses = function(S) {\\n    let stack = [-1], ans = 0\\n    for (let i = 0; i < S.length; i++)\\n        if (S[i] === \\'(\\') stack.push(i)\\n        else if (stack.length === 1) stack[0] = i\\n        else stack.pop(), ans = Math.max(ans, i - stack[stack.length-1])\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def longestValidParentheses(self, S: str) -> int:\\n        stack, ans = [-1], 0\\n        for i in range(len(S)):\\n            if S[i] == \\'(\\': stack.append(i)\\n            elif len(stack) == 1: stack[0] = i\\n            else:\\n                stack.pop()\\n                ans = max(ans, i - stack[-1])\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int longestValidParentheses(String S) {\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(-1);\\n        int ans = 0;\\n        for (int i = 0; i < S.length(); i++)\\n            if (S.charAt(i) == \\'(\\') stack.push(i);\\n            else {\\n                stack.pop();\\n                if (stack.isEmpty()) stack.push(i);\\n                else ans = Math.max(ans, i - stack.peek());\\n            }\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string S) {\\n        vector<int> stack = {-1};\\n        int ans = 0;\\n        for (int i = 0; i < S.size(); i++)\\n            if (S[i] == \\'(\\') stack.push_back(i);\\n            else if (stack.size() == 1) stack[0] = i;\\n            else {\\n                stack.pop_back();\\n                ans = max(ans, i - stack.back());\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1139974,
                "title": "python-c-go-o-n-by-stack-w-comment",
                "content": "O(n) by stack\\n\\n---\\n\\n**Implementation** by stack in Python\\n\\n```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n\\n        # stack, used to record index of parenthesis\\n        # initialized to -1 as dummy head for valid parentheses length computation\\n        stack = [-1]\\n        \\n        max_length = 0\\n        \\n\\t\\t# linear scan each index and character in input string s\\n        for cur_idx, char in enumerate(s):\\n            \\n            if char == \\'(\\':\\n                \\n                # push when current char is (\\n                stack.append( cur_idx )\\n                \\n            else:\\n                \\n                # pop when current char is )\\n                stack.pop()\\n                \\n                if not stack:\\n                    \\n                    # stack is empty, push current index into stack\\n                    stack.append( cur_idx )\\n                else:\\n                    # stack is non-empty, update maximal valid parentheses length\\n                    max_length = max(max_length, cur_idx - stack[-1])\\n                \\n        return max_length\\n```\\n\\n---\\n\\n**Implementation** by stack in C++\\n\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        \\n        // Initialized a stack with -1 on the bottom\\n        std::stack<int> _stack = std::stack<int>( {-1} );\\n        \\n        int maxSize = 0;\\n        \\n        // scan each character\\n        for( int i = 0 ; i < s.length() ;  i++ ){\\n            \\n            char ch = s[i];\\n            \\n            if( ch == \\'(\\' ){\\n                \\n                // current charachter is left bracket\\n                _stack.push( i );\\n                \\n            }else{\\n                \\n                // right charachter is left bracket\\n                _stack.pop();\\n                \\n                if( _stack.empty() ){\\n                    \\n                    // handle for corner case when ) comes before (\\n                    _stack.push( i );\\n                    \\n                }else{\\n                    // update max length if we have paired bracket\\n                    maxSize = max( maxSize, i - _stack.top() );    \\n                }\\n            }\\n        }\\n        \\n        return maxSize;\\n        \\n    }\\n};\\n```\\n\\n---\\n\\n**Implementation** by stack in Go\\n\\n```\\n// Support function max\\nfunc Max(a, b int)int{\\n    \\n    if a > b{\\n        return a\\n    }\\n    \\n    return b\\n}\\n\\n\\nfunc longestValidParentheses(s string) int {\\n    \\n    // stack, used to record index of parenthesis\\n    // initialized to -1 as dummy head for valid parenthesis length computation\\n    stack := []int{-1}\\n    \\n    maxLength := 0\\n    \\n    // linear scan each index and character in input string s\\n    for curIdx, char := range s{\\n        \\n        if char == \\'(\\'{\\n            \\n            // push when current char is (\\n            stack = append( stack, curIdx)\\n            \\n        }else{\\n            \\n            // pop when current char is )\\n            stack = stack[:len(stack)-1]\\n            \\n            if len(stack)==0{\\n                \\n                // stack is empty, push current index into stack\\n                stack = append( stack, curIdx)\\n            }else{\\n                \\n                // stack is non-empty, update maximal valud parentheses length\\n                \\n                maxLength = Max( maxLength, curIdx - stack[ len(stack)-1 ] )\\n            }\\n            \\n        }\\n        \\n    }\\n    \\n    return maxLength\\n    \\n}\\n\\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #20 Valid Parentheses](https://leetcode.com/problems/valid-parentheses/)",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "Go",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n\\n        # stack, used to record index of parenthesis\\n        # initialized to -1 as dummy head for valid parentheses length computation\\n        stack = [-1]\\n        \\n        max_length = 0\\n        \\n\\t\\t# linear scan each index and character in input string s\\n        for cur_idx, char in enumerate(s):\\n            \\n            if char == \\'(\\':\\n                \\n                # push when current char is (\\n                stack.append( cur_idx )\\n                \\n            else:\\n                \\n                # pop when current char is )\\n                stack.pop()\\n                \\n                if not stack:\\n                    \\n                    # stack is empty, push current index into stack\\n                    stack.append( cur_idx )\\n                else:\\n                    # stack is non-empty, update maximal valid parentheses length\\n                    max_length = max(max_length, cur_idx - stack[-1])\\n                \\n        return max_length\\n```\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        \\n        // Initialized a stack with -1 on the bottom\\n        std::stack<int> _stack = std::stack<int>( {-1} );\\n        \\n        int maxSize = 0;\\n        \\n        // scan each character\\n        for( int i = 0 ; i < s.length() ;  i++ ){\\n            \\n            char ch = s[i];\\n            \\n            if( ch == \\'(\\' ){\\n                \\n                // current charachter is left bracket\\n                _stack.push( i );\\n                \\n            }else{\\n                \\n                // right charachter is left bracket\\n                _stack.pop();\\n                \\n                if( _stack.empty() ){\\n                    \\n                    // handle for corner case when ) comes before (\\n                    _stack.push( i );\\n                    \\n                }else{\\n                    // update max length if we have paired bracket\\n                    maxSize = max( maxSize, i - _stack.top() );    \\n                }\\n            }\\n        }\\n        \\n        return maxSize;\\n        \\n    }\\n};\\n```\n```\\n// Support function max\\nfunc Max(a, b int)int{\\n    \\n    if a > b{\\n        return a\\n    }\\n    \\n    return b\\n}\\n\\n\\nfunc longestValidParentheses(s string) int {\\n    \\n    // stack, used to record index of parenthesis\\n    // initialized to -1 as dummy head for valid parenthesis length computation\\n    stack := []int{-1}\\n    \\n    maxLength := 0\\n    \\n    // linear scan each index and character in input string s\\n    for curIdx, char := range s{\\n        \\n        if char == \\'(\\'{\\n            \\n            // push when current char is (\\n            stack = append( stack, curIdx)\\n            \\n        }else{\\n            \\n            // pop when current char is )\\n            stack = stack[:len(stack)-1]\\n            \\n            if len(stack)==0{\\n                \\n                // stack is empty, push current index into stack\\n                stack = append( stack, curIdx)\\n            }else{\\n                \\n                // stack is non-empty, update maximal valud parentheses length\\n                \\n                maxLength = Max( maxLength, curIdx - stack[ len(stack)-1 ] )\\n            }\\n            \\n        }\\n        \\n    }\\n    \\n    return maxLength\\n    \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140004,
                "title": "js-python-java-c-easy-stack-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nOne of the key things to realize about valid parentheses strings is that they\\'re entirely self-satisfied, meaning that while you can have one substring that is entirely inside another, you can\\'t have two substrings that only partially overlap.\\n\\nThis means that we can use a **greedy O(N) time complexity** solution to this problem without the need for any kind of backtracking. In fact, we should be able to use a very standard stack-based valid parentheses string algorithm with just three very minor modifications.\\n\\nIn a stadard valid parentheses string algorithm, we iterate through the string (**S**) and push the index (**i**) of any **\\'(\\'** to our **stack**. Whenever we find a **\\')\\'**, we match it with the last entry on the **stack** and pop said entry off. We know the string is not valid if we find a **\\')\\'** while there are no **\\'(\\'** indexes in the **stack** with which to match it, and also if we have leftover **\\'(\\'** in the **stack** when we reach the end of **S**.\\n\\nFor this problem, we will need to add in a step that updates our answer (**ans**) when we close a parentheses pair. Since we stored the index of the **\\'(\\'** in our stack, we can easily find the difference between the **\\')\\'** at **i** and the last entry in the **stack**, which should be the length of the valid substring which was just closed.\\n\\nBut here we run into a problem, because consecutive valid substrings can be grouped into a larger valid substring (ie, **\\'()()\\' = 4**). So instead of counting from the *last* **stack** entry, we should actually count from the *second to last* entry, to include any other valid closed substrings since the most recent **\\'(\\'** that will still remain after we pop the just-matched last **stack** entry off.\\n\\nThis, of course, brings us to the second and third changes. Since we\\'re checking the second to last **stack** entry, what happens in the case of **\\'()()\\'** when you close the second valid substring yet there\\'s only the one **stack** entry left at the time?\\n\\nTo avoid this issue, we can just wrap the entire string in another imaginary set of parentheses by starting with **stack = [-1]**, indicating that there\\'s an imaginary **\\'(\\'** just before the beginning of the string at **i = 0**.\\n\\nThe other issue is that we will want to continue even if the string up to **i** becomes invalid due to a **\\')\\'** appearing when the **stack** is \"empty\", or in this case has only our imaginary index left. In that case, we can just effectively restart our **stack** by updating our imaginary **\\'(\\'** index (**stack[0] = i**) and continue on.\\n\\nThen, once we reach the end of **S**, we can just **return ans**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThere are only minor differences in the code for all four languages.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **76ms / 39.9MB** (beats 99% / 78%).\\n```javascript\\nvar longestValidParentheses = function(S) {\\n    let stack = [-1], ans = 0\\n    for (let i = 0; i < S.length; i++)\\n        if (S[i] === \\'(\\') stack.push(i)\\n        else if (stack.length === 1) stack[0] = i\\n        else stack.pop(), ans = Math.max(ans, i - stack[stack.length-1])\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **40ms / 14.6MB** (beats 88% / 71%).\\n```python\\nclass Solution:\\n    def longestValidParentheses(self, S: str) -> int:\\n        stack, ans = [-1], 0\\n        for i in range(len(S)):\\n            if S[i] == \\'(\\': stack.append(i)\\n            elif len(stack) == 1: stack[0] = i\\n            else:\\n                stack.pop()\\n                ans = max(ans, i - stack[-1])\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **2ms / 38.7MB** (beats 69% / 94%).\\n```java\\nclass Solution {\\n    public int longestValidParentheses(String S) {\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(-1);\\n        int ans = 0;\\n        for (int i = 0; i < S.length(); i++)\\n            if (S.charAt(i) == \\'(\\') stack.push(i);\\n            else {\\n                stack.pop();\\n                if (stack.isEmpty()) stack.push(i);\\n                else ans = Math.max(ans, i - stack.peek());\\n            }\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 7.1MB** (beats 100% / 71%).\\n```c++\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string S) {\\n        vector<int> stack = {-1};\\n        int ans = 0;\\n        for (int i = 0; i < S.size(); i++)\\n            if (S[i] == \\'(\\') stack.push_back(i);\\n            else if (stack.size() == 1) stack[0] = i;\\n            else {\\n                stack.pop_back();\\n                ans = max(ans, i - stack.back());\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar longestValidParentheses = function(S) {\\n    let stack = [-1], ans = 0\\n    for (let i = 0; i < S.length; i++)\\n        if (S[i] === \\'(\\') stack.push(i)\\n        else if (stack.length === 1) stack[0] = i\\n        else stack.pop(), ans = Math.max(ans, i - stack[stack.length-1])\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def longestValidParentheses(self, S: str) -> int:\\n        stack, ans = [-1], 0\\n        for i in range(len(S)):\\n            if S[i] == \\'(\\': stack.append(i)\\n            elif len(stack) == 1: stack[0] = i\\n            else:\\n                stack.pop()\\n                ans = max(ans, i - stack[-1])\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int longestValidParentheses(String S) {\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(-1);\\n        int ans = 0;\\n        for (int i = 0; i < S.length(); i++)\\n            if (S.charAt(i) == \\'(\\') stack.push(i);\\n            else {\\n                stack.pop();\\n                if (stack.isEmpty()) stack.push(i);\\n                else ans = Math.max(ans, i - stack.peek());\\n            }\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string S) {\\n        vector<int> stack = {-1};\\n        int ans = 0;\\n        for (int i = 0; i < S.size(); i++)\\n            if (S[i] == \\'(\\') stack.push_back(i);\\n            else if (stack.size() == 1) stack[0] = i;\\n            else {\\n                stack.pop_back();\\n                ans = max(ans, i - stack.back());\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1027331,
                "title": "java-from-top-down-w-memo-to-bottom-up-dp-beats-100",
                "content": "Since the tag of this problem is `Dynamic Programming`, here I shared a top down approach, similar to solution 2 but for me it\\'s easier to understand. \\n\\nWe define the subproblem as `dp(idx) := length of the longest valid parentheses which use s[idx] as end.`\\n\\nWe only compute when `s[idx] == \\')\\'` since `\\'(\\'` can\\'t be the end of a valid parentheses.\\n\\nThe recurrence relationship is:\\n1. when `s[idx - 1] == \\'(\\'`:\\n\\t `\\'(\\'` and `\\')\\'` at idx - 1 and idx respectively already form a valid `()`, since we want to form the longest substring, we want to check if the substring end with `s[idx - 2]` is also valid, if valid, we need to add the length of it (`dp(idx - 2)`).\\n\\t `dp(idx) = 2 + dp(idx - 2)`\\n2. when `s[idx - 1] == \\')\\'`:\\n\\t\\tfirst we need to check if substring end at `idx - 1` is valid, if not. then we can\\'t use `idx` as end neither. if valid, we want to make sure that `)` at `idx` has a `\\'(\\'` to match it, without this `\\'(\\'`, substring end at `idx` can\\'t be valid as well. So what\\'s the position should such `\\'(\\'` located? Its position is at `idx - dp(idx - 1) - 1`, e.g. `....(  (())  )`, previous valid parentheses length is 4, so the `\\'(\\'` matching `\\')\\'` at idx is at `idx - 4 - 1`, where `4 = dp(idx - 1)`. as in case 1, we want to check if the substring can be longer, so we check the previous index which is left to the `\\'(\\'` that match `\\')\\'` at idx. Its index is `idx - dp(idx - 1) - 2`.\\n\\t\\t`if dp(idx - 1) > 0 && s[idx - dp(idx - 1) - 1] == \\'(\\':        dp(idx) = 2 + dp(idx - 1) + dp(idx - dp(idx - 1) - 2)`\\n\\nBase case is trivial, `dp(idx) = 0 if idx <= 0`\\n\\n```\\nclass Solution {\\n    int[] memo;\\n    \\n    public int longestValidParentheses(String s) {\\n        int n = s.length();\\n        int ans = 0;\\n        memo = new int[n];\\n        Arrays.fill(memo, -1);\\n        for (int i = 0; i < n; i++) {\\n            ans = Math.max(ans, dp(s, i));\\n        }\\n        return ans;\\n    }\\n    \\n    private int dp(String s, int idx) {\\n        if (idx <= 0) return 0; // Base case\\n        if (memo[idx] != -1) return memo[idx];\\n\\t\\t\\n        int ans = 0;\\n        if (s.charAt(idx) == \\')\\') {\\n            if (idx > 0 && s.charAt(idx - 1) == \\'(\\') {\\n                ans += 2; // \\'(\\' \\')\\' at idx-1 and idx\\n                ans += dp(s, idx - 2); // previous valid length\\n            } else if (idx > 0 && s.charAt(idx - 1) == \\')\\') {\\n                int prevLen = dp(s, idx - 1); // idx-1 has valid parentheses?\\n                if (prevLen > 0 && idx - prevLen - 1 >= 0 && s.charAt(idx- prevLen - 1) == \\'(\\') {\\n                    ans += 2; // \\'(\\' pair with \\')\\' at idx\\n                    ans += prevLen; // length use s[idx -1] as end\\n                    ans += dp(s, idx - prevLen - 2); // more previous length\\n                }\\n            }\\n        }\\n        memo[idx] = ans;\\n        return ans;\\n    }\\n}\\n```\\n\\nIf you understand this top-down approach, you can easily convert it to bottom-up dp to avoid recursive calls.\\n```\\n    public int longestValidParentheses(String s) {\\n        int n = s.length();\\n        int[] dp = new int[n];\\n        int ans = 0;\\n        \\n        for (int i = 1; i < n; i++) {\\n            if (s.charAt(i) == \\')\\') {\\n                if (s.charAt(i - 1) == \\'(\\') {\\n                    dp[i] = 2 + (i - 2 >= 0 ? dp[i - 2] : 0);\\n                } else {\\n                    int prevLen = dp[i - 1];\\n                    if (prevLen > 0 && i - prevLen - 1 >= 0 && s.charAt(i - prevLen - 1) == \\'(\\') {\\n                        dp[i] = 2 + prevLen + (i - prevLen - 2 >= 0 ? dp[i - prevLen - 2] : 0);\\n                    }\\n                }\\n            }\\n            ans = Math.max(ans, dp[i]);\\n        }\\n\\n        return ans;\\n    }\\n```\\n\\nTime Complexity: `O(n)`\\nSpace: `O(n)`",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int[] memo;\\n    \\n    public int longestValidParentheses(String s) {\\n        int n = s.length();\\n        int ans = 0;\\n        memo = new int[n];\\n        Arrays.fill(memo, -1);\\n        for (int i = 0; i < n; i++) {\\n            ans = Math.max(ans, dp(s, i));\\n        }\\n        return ans;\\n    }\\n    \\n    private int dp(String s, int idx) {\\n        if (idx <= 0) return 0; // Base case\\n        if (memo[idx] != -1) return memo[idx];\\n\\t\\t\\n        int ans = 0;\\n        if (s.charAt(idx) == \\')\\') {\\n            if (idx > 0 && s.charAt(idx - 1) == \\'(\\') {\\n                ans += 2; // \\'(\\' \\')\\' at idx-1 and idx\\n                ans += dp(s, idx - 2); // previous valid length\\n            } else if (idx > 0 && s.charAt(idx - 1) == \\')\\') {\\n                int prevLen = dp(s, idx - 1); // idx-1 has valid parentheses?\\n                if (prevLen > 0 && idx - prevLen - 1 >= 0 && s.charAt(idx- prevLen - 1) == \\'(\\') {\\n                    ans += 2; // \\'(\\' pair with \\')\\' at idx\\n                    ans += prevLen; // length use s[idx -1] as end\\n                    ans += dp(s, idx - prevLen - 2); // more previous length\\n                }\\n            }\\n        }\\n        memo[idx] = ans;\\n        return ans;\\n    }\\n}\\n```\n```\\n    public int longestValidParentheses(String s) {\\n        int n = s.length();\\n        int[] dp = new int[n];\\n        int ans = 0;\\n        \\n        for (int i = 1; i < n; i++) {\\n            if (s.charAt(i) == \\')\\') {\\n                if (s.charAt(i - 1) == \\'(\\') {\\n                    dp[i] = 2 + (i - 2 >= 0 ? dp[i - 2] : 0);\\n                } else {\\n                    int prevLen = dp[i - 1];\\n                    if (prevLen > 0 && i - prevLen - 1 >= 0 && s.charAt(i - prevLen - 1) == \\'(\\') {\\n                        dp[i] = 2 + prevLen + (i - prevLen - 2 >= 0 ? dp[i - prevLen - 2] : 0);\\n                    }\\n                }\\n            }\\n            ans = Math.max(ans, dp[i]);\\n        }\\n\\n        return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14131,
                "title": "explaining-solution-using-stack",
                "content": "I have seen a lot of good answers but it is not immediately clear how they are achieving the result. I am going to make an attempt to explain my solution using a stack. Every time we encounter '(' we push the index onto the stack and when we encounter ')' we pop the stack and use the current index minus the index at the top of the stack to be the current_length. we check against the max found so far and update if needed. Here is the code\\n\\n \\n\\n    public static int longestValidParentheses(String s) {\\n    \\n    \\n            Stack<Integer> bracketStack = new Stack<Integer>();\\n            int max_len=0;\\n            int current_len=0;\\n            int last = -1;\\n            for (int i = 0; i < s.length(); i++) {\\n                if (s.charAt(i) == '(') {\\n                    \\n                        bracketStack.push(i);\\n                }\\n                else{\\n    \\n                    if(!bracketStack.isEmpty())\\n                    {\\n                        bracketStack.pop();\\n    \\n                    if(!bracketStack.isEmpty())\\n                        current_len = i-bracketStack.peek();\\n                    else\\n                        current_len=i-last;\\n                    max_len = Math.max(max_len,current_len);\\n                    }\\n                    else{\\n                        \\n                        last = i;\\n                    }\\n                }\\n    \\n            }\\n    \\n    \\n            return max_len;\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "I have seen a lot of good answers but it is not immediately clear how they are achieving the result. I am going to make an attempt to explain my solution using a stack. Every time we encounter '(' we push the index onto the stack and when we encounter ')' we pop the stack and use the current index minus the index at the top of the stack to be the current_length. we check against the max found so far and update if needed. Here is the code\\n\\n \\n\\n    public static int longestValidParentheses(String s) {\\n    \\n    \\n            Stack<Integer> bracketStack = new Stack<Integer>();\\n            int max_len=0;\\n            int current_len=0;\\n            int last = -1;\\n            for (int i = 0; i < s.length(); i++) {\\n                if (s.charAt(i) == '(') {\\n                    \\n                        bracketStack.push(i);\\n                }\\n                else{\\n    \\n                    if(!bracketStack.isEmpty())\\n                    {\\n                        bracketStack.pop();\\n    \\n                    if(!bracketStack.isEmpty())\\n                        current_len = i-bracketStack.peek();\\n                    else\\n                        current_len=i-last;\\n                    max_len = Math.max(max_len,current_len);\\n                    }\\n                    else{\\n                        \\n                        last = i;\\n                    }\\n                }\\n    \\n            }\\n    \\n    \\n            return max_len;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 14146,
                "title": "simple-java-solution",
                "content": "![enter image description here][1]\\n\\n\\n  [1]: http://s11.postimg.org/9i4ju3imr/IMG_20150202_130621.jpg\\n\\n\\n    public int longestValidParentheses(String s) {\\n        char[] S = s.toCharArray();\\n        int[] V = new int[S.length];\\n        int open = 0;\\n        int max = 0;\\n        for (int i=0; i<S.length; i++) {\\n        \\tif (S[i] == '(') open++;\\n        \\tif (S[i] == ')' && open > 0) {\\n        \\t\\tV[i] = 2 + V[i-1] + (i-2-V[i-1] > 0 ? V[i-2-V[i-1]] : 0);\\n        \\t\\topen--;\\n        \\t}\\n        \\tif (V[i] > max) max = V[i];\\n        }\\n        return max;\\n    }",
                "solutionTags": [],
                "code": "![enter image description here][1]\\n\\n\\n  [1]: http://s11.postimg.org/9i4ju3imr/IMG_20150202_130621.jpg\\n\\n\\n    public int longestValidParentheses(String s) {\\n        char[] S = s.toCharArray();\\n        int[] V = new int[S.length];\\n        int open = 0;\\n        int max = 0;\\n        for (int i=0; i<S.length; i++) {\\n        \\tif (S[i] == '(') open++;\\n        \\tif (S[i] == ')' && open > 0) {\\n        \\t\\tV[i] = 2 + V[i-1] + (i-2-V[i-1] > 0 ? V[i-2-V[i-1]] : 0);\\n        \\t\\topen--;\\n        \\t}\\n        \\tif (V[i] > max) max = V[i];\\n        }\\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1139991,
                "title": "short-easy-w-explanation-o-n-solution-with-stack",
                "content": "***Solution (Simulating with stack) :***\\n\\nWe can use a stack to find the longest valid parentheses. \\n\\nWe will start by pushing `-1` into the stack at first. This will denote index preceding to **potential start of valid parentheses**. It will be more clear later. Now will start iterating over `s` and we will have two cases -\\n1. **`s[i] == \\'(\\'`** - In this case, we will push the index into the stack (just as we do in valid parentheses check).\\n2. **`s[i] == \\')\\'`** - In this case, we will pop the index from the stack (again just as in parentheses check). Now, after popping, we need to do some simple checks which are main steps of this problem. Again, there will be following scenarios that may occur -\\n    * **stack is not empty** - If stack is not empty, then this **may be our longest valid parentheses**. We update the `MAX_len` as `max(MAX_len, current index - stack.top())`. Do notice, that our bottom of stack will always hold index preceding to a potential valid parentheses.\\n\\t* **stack becomes empty** - This will only happen when we have an extra \\')\\' bracket. There may have been valid parentheses previously which have been updated and stored in `MAX_len`. But, since we now have an extra closing bracket any further extensions of previous valid parentheses is not possible. So, push the current index into stack, again which will denote that bottom of stack will hold the index preceding to a **potential** valid parentheses.\\n\\n```\\nExample - \\'()())()\\'\\nInitial stack(from bottom to top) :  [ -1 ] , MAX = 0\\n\\n1. i = 0          |   s[i] = \\'(\\'        =>     case-1: push current index into stack\\nstack : [-1, 0]   |   MAX = 0\\n\\n2. i = 1          |   s[i] = \\')\\'        =>     case-2.1: pop. After pop, stack is not empty so update MAX.\\nstack : [-1]      |   MAX = max(0, 1 - (-1)) = 2.\\n\\n\\'NOTE : Since the index starts from 0, having index preceding to the start of valid parentheses will give us actual length of the valid parentheses,\\ninstead of us having to add 1 to it everytime.\\'\\n\\n3. i = 2          |   s[i] = \\'(\\'        =>     case-1: push current index into stack\\nstack : [-1, 1]   |   MAX = 2.\\n\\n4. i = 3          |   s[i] = \\')\\'        =>     case-2.1: pop. After pop, stack is not empty so update MAX.\\nstack : [-1]      |   MAX = max(2, 3 - (-1)) = 4.\\n\\n5. i = 4          |   s[i] = \\')\\'        =>     case-2.2: pop. After pop, stack is empty, so push current index into stack.\\nThis denotes any valid parentheses from now will start from next index and previous valid parentheses cant be extended further.\\nstack : [4]       |   MAX = 4.\\n\\n6. i = 5          |   s[i] = \\'(\\'        =>     case-1: push current index into stack\\nstack : [4, 5]    |   MAX = 4.\\n\\n7. i = 6          |   s[i] = \\')\\'        =>     case-2.2: pop. After pop, stack is empty, so push current index into stack.\\nstack : [4]       |   MAX = max(4, 6 - 4) = 4.\\n```\\n\\nThe small simulation above might have given you the idea of how this process works. Watch the LC solution showing a gif which will give you better idea. Below is them implementation of the same -\\n\\n\\n```\\nint longestValidParentheses(string s) {\\n\\tint MAX = 0;  // denotes length of maximum valid parentheses\\n\\tstack<int> stk;\\n\\tstk.push(-1); // bottom of stack will always hold index preceding to potential start of valid parentheses\\n\\tfor(int i = 0; i < size(s); i++)\\n\\t\\tif(s[i] == \\'(\\') stk.push(i);            \\n\\t\\telse{                \\n\\t\\t\\tstk.pop();\\n\\t\\t\\tif(stk.empty()) stk.push(i);\\n\\t\\t\\telse MAX = max(MAX, i - stk.top());\\n\\t\\t}        \\n\\treturn MAX;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N)`**, for iterating over the string s.\\n***Space Complexity :*** **`O(N)`**, for maintaining the stack.\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nExample - \\'()())()\\'\\nInitial stack(from bottom to top) :  [ -1 ] , MAX = 0\\n\\n1. i = 0          |   s[i] = \\'(\\'        =>     case-1: push current index into stack\\nstack : [-1, 0]   |   MAX = 0\\n\\n2. i = 1          |   s[i] = \\')\\'        =>     case-2.1: pop. After pop, stack is not empty so update MAX.\\nstack : [-1]      |   MAX = max(0, 1 - (-1)) = 2.\\n\\n\\'NOTE : Since the index starts from 0, having index preceding to the start of valid parentheses will give us actual length of the valid parentheses,\\ninstead of us having to add 1 to it everytime.\\'\\n\\n3. i = 2          |   s[i] = \\'(\\'        =>     case-1: push current index into stack\\nstack : [-1, 1]   |   MAX = 2.\\n\\n4. i = 3          |   s[i] = \\')\\'        =>     case-2.1: pop. After pop, stack is not empty so update MAX.\\nstack : [-1]      |   MAX = max(2, 3 - (-1)) = 4.\\n\\n5. i = 4          |   s[i] = \\')\\'        =>     case-2.2: pop. After pop, stack is empty, so push current index into stack.\\nThis denotes any valid parentheses from now will start from next index and previous valid parentheses cant be extended further.\\nstack : [4]       |   MAX = 4.\\n\\n6. i = 5          |   s[i] = \\'(\\'        =>     case-1: push current index into stack\\nstack : [4, 5]    |   MAX = 4.\\n\\n7. i = 6          |   s[i] = \\')\\'        =>     case-2.2: pop. After pop, stack is empty, so push current index into stack.\\nstack : [4]       |   MAX = max(4, 6 - 4) = 4.\\n```\n```\\nint longestValidParentheses(string s) {\\n\\tint MAX = 0;  // denotes length of maximum valid parentheses\\n\\tstack<int> stk;\\n\\tstk.push(-1); // bottom of stack will always hold index preceding to potential start of valid parentheses\\n\\tfor(int i = 0; i < size(s); i++)\\n\\t\\tif(s[i] == \\'(\\') stk.push(i);            \\n\\t\\telse{                \\n\\t\\t\\tstk.pop();\\n\\t\\t\\tif(stk.empty()) stk.push(i);\\n\\t\\t\\telse MAX = max(MAX, i - stk.top());\\n\\t\\t}        \\n\\treturn MAX;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1139905,
                "title": "longest-valid-parentheses-simple-code-easy-to-understand-explained",
                "content": "There are different approaches to solve this problem.\\n**Approach -1: Using Stacks** -\\nThe main idea is pretty straight forward, **we only update the result (res) when we find a valid paranthesis.**\\n-> If we find a valid pair. We pop this pair and check gap between the current and previous invalid and update the res.\\n```\\nFor example: s= \"())(())\", stack= [-1 ], res =0, here the answer must be 4, the longest valid paranthesis is from index 3 to 6. So, lets dry run this example.\\n    ->index 0 :  s[i] == \\'(\\'   push into stack,  //stack=[-1,0], res=0\\n    ->index 1 :  s[i] == \\')\\'   we pop it out and see what\\'s before \"(\". In this example it\\'s -1. So the gap is \"current_index - (-1) = 2\"  // res = 2, stack = [-1]\\n    ->index 2 :  s[i] == \\')\\'   we pop -1 the stack, here stack is empty, i.e, it is not a valid pair, so we push current index into stack      //res=2, stack = [2]\\n    ->index-3 :  s[i] == \\'(\\'  we push into stack. // res =2, stack = [2,3]\\n    ->index-4 :  s[i] == \\'(\\'  we push into stack. //res =2, stack = [2,3,4]\\n    ->index-5 :  s[i] == \\')\\'  we pop the stack, update the res, gap = \"current index - 3 = 2\"     //res =2, stack = [2,3]\\n    ->index-6 :  s[i] == \\')\\'  we pop the stack, update the res, gap = \"current index - 2 =4\"   //res = max(res,4 ) = 4, stack = [2]\\n```\\nHere we intially pushed \\'-1\\' to stack to cover all edge cases.\\nHope this example helps in understanding the logic. Go through the code for better idea.\\n\\n```\\nint longestValidParentheses(string s) {\\n        stack<int>st;\\n        st.push(-1);\\n        int res =0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\')  st.push(i);\\n            else{\\n                st.pop();\\n                if(st.empty()) st.push(i);\\n                else res = max(res,i-st.top());\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n\\n**Approach-2: Dynamic programming**:\\nThe main idea is for every index of our DP array, dp[i], it stores the longest length of valid parentheses which is end at i, and the logic is :\\n```\\n\\n-> If s[i] is \\'(\\',  dp[i] = 0,because any string end with \\'(\\' cannot be a valid paranthesis.\\n-> else if s[i] is \\')\\', we have two conditions,\\n  \\t\\t -> s[i-1] is \\'(\\', dp[i] = dp[i-2] + 2\\n         -> s[i-1] is \\')\\' and s[i-dp[i-1]-1] == \\'(\\', dp[i] = dp[i-1] + 2 + dp[i-dp[i-1]-2]\\n```\\nBasically, we are finding the longest valid paranthesis ending at `index i`.\\n\\n```\\nint longestValidParentheses(string s) {\\n        if(s.length() <= 1) return 0;\\n        int res = 0;\\n        vector<int> dp(s.length(),0);\\n        for(int i=1; i<s.length(); i++){\\n            if(s[i] == \\')\\' && i-dp[i-1]-1 >= 0 && s[i-dp[i-1]-1] == \\'(\\'){\\n                if(i-dp[i-1]-2 >=0) \\n                    dp[i] = dp[i-1] + 2 + dp[i-dp[i-1]-2];\\n                else \\n                    dp[i] = dp[i-1] + 2;\\n                res = max(dp[i],res);\\n            }\\n        }\\n        return res;\\n    }\\n```\\n**Do Upvote if you like the explanation and find it helpful!!!**\\n\\nAny other ways to solve this problems ?? Thoughts?? Comment down below !!\\n\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nFor example: s= \"())(())\", stack= [-1 ], res =0, here the answer must be 4, the longest valid paranthesis is from index 3 to 6. So, lets dry run this example.\\n    ->index 0 :  s[i] == \\'(\\'   push into stack,  //stack=[-1,0], res=0\\n    ->index 1 :  s[i] == \\')\\'   we pop it out and see what\\'s before \"(\". In this example it\\'s -1. So the gap is \"current_index - (-1) = 2\"  // res = 2, stack = [-1]\\n    ->index 2 :  s[i] == \\')\\'   we pop -1 the stack, here stack is empty, i.e, it is not a valid pair, so we push current index into stack      //res=2, stack = [2]\\n    ->index-3 :  s[i] == \\'(\\'  we push into stack. // res =2, stack = [2,3]\\n    ->index-4 :  s[i] == \\'(\\'  we push into stack. //res =2, stack = [2,3,4]\\n    ->index-5 :  s[i] == \\')\\'  we pop the stack, update the res, gap = \"current index - 3 = 2\"     //res =2, stack = [2,3]\\n    ->index-6 :  s[i] == \\')\\'  we pop the stack, update the res, gap = \"current index - 2 =4\"   //res = max(res,4 ) = 4, stack = [2]\\n```\n```\\nint longestValidParentheses(string s) {\\n        stack<int>st;\\n        st.push(-1);\\n        int res =0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\')  st.push(i);\\n            else{\\n                st.pop();\\n                if(st.empty()) st.push(i);\\n                else res = max(res,i-st.top());\\n            }\\n        }\\n        return res;\\n    }\\n```\n```\\n\\n-> If s[i] is \\'(\\',  dp[i] = 0,because any string end with \\'(\\' cannot be a valid paranthesis.\\n-> else if s[i] is \\')\\', we have two conditions,\\n  \\t\\t -> s[i-1] is \\'(\\', dp[i] = dp[i-2] + 2\\n         -> s[i-1] is \\')\\' and s[i-dp[i-1]-1] == \\'(\\', dp[i] = dp[i-1] + 2 + dp[i-dp[i-1]-2]\\n```\n```\\nint longestValidParentheses(string s) {\\n        if(s.length() <= 1) return 0;\\n        int res = 0;\\n        vector<int> dp(s.length(),0);\\n        for(int i=1; i<s.length(); i++){\\n            if(s[i] == \\')\\' && i-dp[i-1]-1 >= 0 && s[i-dp[i-1]-1] == \\'(\\'){\\n                if(i-dp[i-1]-2 >=0) \\n                    dp[i] = dp[i-1] + 2 + dp[i-dp[i-1]-2];\\n                else \\n                    dp[i] = dp[i-1] + 2;\\n                res = max(dp[i],res);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 14296,
                "title": "my-o-n-time-c-solutions-stack-based-and-dp-based",
                "content": " - DP based solution, O(N) time O(N) space\\n\\nWe can do DP: dp[i] saves the longest valid parentheses that ends at (i-1). To calculate the longest valid parentheses that ends at i (i.e. calculate dp[i+1]), we only need to consider the following cases\\n1) case 1: s[i] = '(', then no valid parentheses that ends at i, so dp[i+1]=0 (i.e. do nothing)\\n2) case 2  s[i]= ')' , then we have to check if this ')' can find a matched '(' just before the longest parentheses ending at i-1 (i.e. check if s[i-dp[i]-1] = '('); \\nif yes, then s[i] extends the longest parentheses ending at i-1 to [i-dp[i]-1, i] and it now connects to the longest parentheses ending at i-dp[i]-2, so the DP update equation becomes dp[i+1] =dp[i]+2+dp[i-dp[i]-1]  \\nif no, then no valid parentheses ending at i, so dp[i+1] =0 (do nothing)\\n\\n    class Solution {\\n    public:\\n        int longestValidParentheses(string s) {\\n            int len = s.size(), i, res=0, left;\\n            vector<int> dp(len+1,0);\\n            \\n            for(i=1;i<len;++i)\\n            {\\n                if(s[i]==')')\\n                {\\n                    left = i-dp[i]-1;\\n                    if(left>=0 && s[left]=='(') dp[i+1] = dp[i]+2+dp[left];\\n                    res = max(res, dp[i+1]);\\n                }\\n            }\\n            return res;\\n            \\n        }\\n    };\\n\\n 2)  Stack based solution, O(N) time and O(N) space\\nScan s from left to right and use a stack to save all the unmatched '(' or ')' indices. If s[i] ='(', then push i to the stack; if s[i] =')', check if it can match the last unmatched char (i.e. check if s[stk.top()]='('), if so, remove tthe top entry and update res if the current parentheses [stk.top(), i] is longer than res.\\n\\n    class Solution {\\n    public:\\n        int longestValidParentheses(string s) {\\n            int len = s.size(), maxL=0, i;\\n            stack<int> stk;\\n            stk.push(-1);\\n            for(i=0; i<len;++i)\\n            {\\n                if(s[i]==')' && stk.top()>=0 && s[stk.top()]=='(')\\n                { // if s[i] is ')' and matches the last unmatched  char  \\n                    stk.pop(); // remove the last unmatched char\\n                    maxL = max(maxL, i-stk.top()); // update res\\n                }\\n                else stk.push(i);\\n            }\\n            return maxL;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int longestValidParentheses(string s) {\\n            int len = s.size(), i, res=0, left;\\n            vector<int> dp(len+1,0);\\n            \\n            for(i=1;i<len;++i)\\n            {\\n                if(s[i]==')')\\n                {\\n                    left = i-dp[i]-1;\\n                    if(left>=0 && s[left]=='(') dp[i+1] = dp[i]+2+dp[left];\\n                    res = max(res, dp[i+1]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1038932,
                "title": "c-10-lines-easy-stack-solution-o-n-tc-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int>stck;\\n        stck.push(-1);\\n        int res=0;\\n        \\n        for(int i=0;i<s.size();i++){\\n            \\n            if(s[i]==\\'(\\') stck.push(i);\\n            \\n            else{\\n                if(!stck.empty())stck.pop();\\n                \\n                if(!stck.empty()){\\n                    res=max(res,i-stck.top());\\n                }\\n                else stck.push(i);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int>stck;\\n        stck.push(-1);\\n        int res=0;\\n        \\n        for(int i=0;i<s.size();i++){\\n            \\n            if(s[i]==\\'(\\') stck.push(i);\\n            \\n            else{\\n                if(!stck.empty())stck.pop();\\n                \\n                if(!stck.empty()){\\n                    res=max(res,i-stck.top());\\n                }\\n                else stck.push(i);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14377,
                "title": "o-n-dp-solution-in-c",
                "content": "      \\n       int longestValidParentheses(string s) {\\n            int cnt = 0; // count of \"(\"\\n            vector<int> dp(s.size()+1, 0);\\n            \\n            for (size_t i = 1; i <= s.size(); i++) {\\n                if (s[i-1] == '(') {\\n                    cnt++;\\n                } else {\\n                    if (cnt > 0) {  // there exists an unclosed \"(\" to match \")\"\\n                        cnt--;\\n                        dp[i] = 2;\\n                        if (s[i-2] == ')')  // add the length of previous closed \")\" neighbor\\n                            dp[i] += dp[i-1];                        \\n                        dp[i] += dp[i-dp[i]]; // add the length of previous valid parentheses\\n                    }\\n                }\\n            }\\n            \\n            return *max_element(dp.begin(), dp.end());\\n        }",
                "solutionTags": [
                    "C++"
                ],
                "code": "      \\n       int longestValidParentheses(string s) {\\n            int cnt = 0; // count of \"(\"\\n            vector<int> dp(s.size()+1, 0);\\n            \\n            for (size_t i = 1; i <= s.size(); i++) {\\n                if (s[i-1] == '(') {\\n                    cnt++;\\n                } else {\\n                    if (cnt > 0) {  // there exists an unclosed \"(\" to match \")\"\\n                        cnt--;\\n                        dp[i] = 2;\\n                        if (s[i-2] == ')')  // add the length of previous closed \")\" neighbor\\n                            dp[i] += dp[i-1];                        \\n                        dp[i] += dp[i-dp[i]]; // add the length of previous valid parentheses\\n                    }\\n                }\\n            }\\n            \\n            return *max_element(dp.begin(), dp.end());\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 14271,
                "title": "java-o-n-very-easy-to-understand",
                "content": "    public int longestValidParentheses(String s) {\\n        int max=0,start=0;\\n        Stack<Integer> stack=new Stack();\\n        int[] a=new int[s.length()];\\n        char[] c=s.toCharArray();\\n        for(int i=0;i<c.length;i++){\\n            if(c[i]=='(') stack.push(i);\\n            else if(!stack.empty()){\\n                start=stack.pop();\\n                a[i]=i-start+1;\\n                if(start>1) a[i]+=a[start-1];\\n                max=Math.max(max,a[i]);\\n            }\\n        }\\n        return max;\\n    }",
                "solutionTags": [],
                "code": "    public int longestValidParentheses(String s) {\\n        int max=0,start=0;\\n        Stack<Integer> stack=new Stack();\\n        int[] a=new int[s.length()];\\n        char[] c=s.toCharArray();\\n        for(int i=0;i<c.length;i++){\\n            if(c[i]=='(') stack.push(i);\\n            else if(!stack.empty()){\\n                start=stack.pop();\\n                a[i]=i-start+1;\\n                if(start>1) a[i]+=a[start-1];\\n                max=Math.max(max,a[i]);\\n            }\\n        }\\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 14298,
                "title": "java-stack-solution-o-n",
                "content": "    public class Solution {\\n    public int longestValidParentheses(String s) {\\n        if(s == null || s.length() <= 1){\\n            return 0;\\n        }\\n        int start = -1;\\n        int res = 0;\\n        LinkedList<Integer> stack = new LinkedList<Integer>();\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i) == '('){\\n                stack.push(i);\\n            }else{\\n                if(!stack.isEmpty()){\\n                    stack.pop();\\n                    if(!stack.isEmpty()){\\n                        res = Math.max(res,i-stack.peek());\\n                    }else{\\n                        res = Math.max(res,i-start);\\n                    }\\n                }else{\\n                    start = i;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int longestValidParentheses(String s) {\\n        if(s == null || s.length() <= 1){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2068304,
                "title": "c-using-left-and-right-parentheses-count",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int left=0,right=0,maxlen=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\')\\n                left++;\\n            if(s[i]==\\')\\')\\n                right++;\\n            if(left==right)\\n                maxlen=max(maxlen,2*left);\\n\\t\\t//when we traverse from left to right ,if right becomes more than left then we enter into invalid state\\n            else if(right>=left){\\n                left=0;\\n                right=0;\\n            }\\n        }\\n        left=0,right=0;\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(s[i]==\\'(\\')\\n                left++;\\n            if(s[i]==\\')\\')\\n                right++;\\n            if(left==right)\\n                maxlen=max(maxlen,2*right);\\n\\t\\t//when we traverse from right to left ,if left becomes more than right we enter into inavild state\\n            else if(left>=right){\\n                left=0;\\n                right=0;\\n            }\\n        }\\n        return maxlen;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int left=0,right=0,maxlen=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\')\\n                left++;\\n            if(s[i]==\\')\\')\\n                right++;\\n            if(left==right)\\n                maxlen=max(maxlen,2*left);\\n\\t\\t//when we traverse from left to right ,if right becomes more than left then we enter into invalid state\\n            else if(right>=left){\\n                left=0;\\n                right=0;\\n            }\\n        }\\n        left=0,right=0;\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(s[i]==\\'(\\')\\n                left++;\\n            if(s[i]==\\')\\')\\n                right++;\\n            if(left==right)\\n                maxlen=max(maxlen,2*right);\\n\\t\\t//when we traverse from right to left ,if left becomes more than right we enter into inavild state\\n            else if(left>=right){\\n                left=0;\\n                right=0;\\n            }\\n        }\\n        return maxlen;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2690340,
                "title": "python-c-java-beginner-level-simple-short-solution-easytounderstand",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q32. Longest Valid Parentheses***\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        l,stack=0,[-1]\\n        for i in range(len(s)):\\n            if s[i]==\\'(\\':\\n                stack.append(i)\\n            else:\\n                stack.pop()\\n                if not stack:\\n                    stack.append(i)\\n                else:\\n                    l=max(l,i-stack[-1])\\n        return l;\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\n\\u2705 **Java Code** :\\n```\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n        Stack<Integer> stack = new Stack();\\n        stack.push(-1);\\n        int maxLen = 0;\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            if(s.charAt(i) == \\'(\\')\\n                stack.push(i);\\n            else if(s.charAt(i) == \\')\\')\\n            {    \\n                stack.pop();\\n                if(stack.empty())\\n                    stack.push(i);\\n                else\\n                    maxLen = Math.max(maxLen, i - stack.peek());     \\n            }\\n        }\\n        return maxLen;\\n    }\\n}\\n```\\n\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n    int n = s.length(),len =0,maxlen =0;\\n    stack<int> st;\\n    st.push(-1);\\n    for(int i =0;i<n;i++)\\n    {\\n        if(s[i] == \\'(\\')\\n            st.push(i);\\n        if(s[i] == \\')\\')\\n        {\\n            st.pop();\\n            if(st.empty())\\n                st.push(i);\\n            len = i - st.top();\\n            maxlen = max(maxlen,len);\\n        }\\n    }\\n    return maxlen;\\n    }\\n};\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        l,stack=0,[-1]\\n        for i in range(len(s)):\\n            if s[i]==\\'(\\':\\n                stack.append(i)\\n            else:\\n                stack.pop()\\n                if not stack:\\n                    stack.append(i)\\n                else:\\n                    l=max(l,i-stack[-1])\\n        return l;\\n```\n```\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n        Stack<Integer> stack = new Stack();\\n        stack.push(-1);\\n        int maxLen = 0;\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            if(s.charAt(i) == \\'(\\')\\n                stack.push(i);\\n            else if(s.charAt(i) == \\')\\')\\n            {    \\n                stack.pop();\\n                if(stack.empty())\\n                    stack.push(i);\\n                else\\n                    maxLen = Math.max(maxLen, i - stack.peek());     \\n            }\\n        }\\n        return maxLen;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n    int n = s.length(),len =0,maxlen =0;\\n    stack<int> st;\\n    st.push(-1);\\n    for(int i =0;i<n;i++)\\n    {\\n        if(s[i] == \\'(\\')\\n            st.push(i);\\n        if(s[i] == \\')\\')\\n        {\\n            st.pop();\\n            if(st.empty())\\n                st.push(i);\\n            len = i - st.top();\\n            maxlen = max(maxlen,len);\\n        }\\n    }\\n    return maxlen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2069052,
                "title": "c-0-ms-two-pointer-very-easy",
                "content": "*Left*   : keeps track of  (\\n*Right* : keeps track of )\\n\\nFor First Pass if *Right>Left* happens then they are re-initialized to zero as  \\')\\' can\\'t come before \\'(\\'\\nSimilary,For Second Pass *Left>Right* happens then they are re-initialized to zero as \\'(\\' should come before \\')\\'\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s)\\n    {\\n        \\n        int n=s.size();\\n        int ans=0;\\n        int left=0,right=0;\\n        for(int i=0;i<n;i++)\\n        {\\n           if(s[i]==\\')\\')\\n           {\\n               right++;\\n           }\\n           else if(s[i]==\\'(\\')\\n            {\\n                left++;\\n            }\\n            if(left==right)\\n            {\\n                ans=max(left+right,ans);\\n            }\\n            else if(right>left)\\n            {\\n                left=right=0;\\n            }\\n        }\\n        \\n        left=right=0;\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n           if(s[i]==\\'(\\')\\n           {\\n               left++;\\n           }\\n            else if(s[i]==\\')\\')\\n            {\\n                right++;\\n            }\\n            if(left==right)\\n            {\\n                ans=max(left+right,ans);\\n            }\\n            else if(left>right)\\n            {\\n                left=right=0;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s)\\n    {\\n        \\n        int n=s.size();\\n        int ans=0;\\n        int left=0,right=0;\\n        for(int i=0;i<n;i++)\\n        {\\n           if(s[i]==\\')\\')\\n           {\\n               right++;\\n           }\\n           else if(s[i]==\\'(\\')\\n            {\\n                left++;\\n            }\\n            if(left==right)\\n            {\\n                ans=max(left+right,ans);\\n            }\\n            else if(right>left)\\n            {\\n                left=right=0;\\n            }\\n        }\\n        \\n        left=right=0;\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n           if(s[i]==\\'(\\')\\n           {\\n               left++;\\n           }\\n            else if(s[i]==\\')\\')\\n            {\\n                right++;\\n            }\\n            if(left==right)\\n            {\\n                ans=max(left+right,ans);\\n            }\\n            else if(left>right)\\n            {\\n                left=right=0;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902507,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func longestValidParentheses(_ s: String) -> Int {\\n\\t\\tvar string = Array(s)\\n\\n\\n\\t\\tfunc reverse(_ string: [Character]) -> [Character] {\\n\\t\\t\\tvar res: [Character] = []\\n\\t\\t\\tfor c in string.reversed() { res.append(c == \"(\" ? \")\" : \"(\") }\\n\\t\\t\\treturn res\\n\\t\\t}\\n\\t\\t\\n\\n\\t\\tfunc _max(_ string: [Character]) -> Int {\\n\\t\\t\\tvar max = 0\\n\\t\\t\\tvar tmp = 0\\n\\t\\t\\tvar lastContinuousIndex = 0\\n\\t\\t\\tvar stack: [Character] = []\\n\\n\\t\\t\\tfor (i, c) in string.enumerated() {\\n\\t\\t\\t\\tif c == \"(\" {\\n\\t\\t\\t\\t\\tif stack.count == 0 { lastContinuousIndex = i }\\n\\t\\t\\t\\t\\tstack.append(c)\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tlet index = stack.count - 1\\n\\t\\t\\t\\t\\tif index >= 0 && stack[index] == \"(\" {\\n\\t\\t\\t\\t\\t\\tstack.remove(at: index)\\n\\t\\t\\t\\t\\t\\ttmp += 2\\n\\t\\t\\t\\t\\t\\tmax = tmp > max ? tmp : max  \\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tstack.removeAll()\\n\\t\\t\\t\\t\\t\\ttmp = 0\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (stack.count == 0) {\\n\\t\\t\\t\\treturn max\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tlet a = _max(Array(string[0..<lastContinuousIndex]))\\n\\t\\t\\t\\tlet b =  _max(reverse(Array(string[lastContinuousIndex..<string.count])))\\n\\t\\t\\t\\treturn a > b ? a : b\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn _max(string)\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func longestValidParentheses(_ s: String) -> Int {\\n\\t\\tvar string = Array(s)\\n\\n\\n\\t\\tfunc reverse(_ string: [Character]) -> [Character] {\\n\\t\\t\\tvar res: [Character] = []\\n\\t\\t\\tfor c in string.reversed() { res.append(c == \"(\" ? \")\" : \"(\") }\\n\\t\\t\\treturn res\\n\\t\\t}\\n\\t\\t\\n\\n\\t\\tfunc _max(_ string: [Character]) -> Int {\\n\\t\\t\\tvar max = 0\\n\\t\\t\\tvar tmp = 0\\n\\t\\t\\tvar lastContinuousIndex = 0\\n\\t\\t\\tvar stack: [Character] = []\\n\\n\\t\\t\\tfor (i, c) in string.enumerated() {\\n\\t\\t\\t\\tif c == \"(\" {\\n\\t\\t\\t\\t\\tif stack.count == 0 { lastContinuousIndex = i }\\n\\t\\t\\t\\t\\tstack.append(c)\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tlet index = stack.count - 1\\n\\t\\t\\t\\t\\tif index >= 0 && stack[index] == \"(\" {\\n\\t\\t\\t\\t\\t\\tstack.remove(at: index)\\n\\t\\t\\t\\t\\t\\ttmp += 2\\n\\t\\t\\t\\t\\t\\tmax = tmp > max ? tmp : max  \\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tstack.removeAll()\\n\\t\\t\\t\\t\\t\\ttmp = 0\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (stack.count == 0) {\\n\\t\\t\\t\\treturn max\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tlet a = _max(Array(string[0..<lastContinuousIndex]))\\n\\t\\t\\t\\tlet b =  _max(reverse(Array(string[lastContinuousIndex..<string.count])))\\n\\t\\t\\t\\treturn a > b ? a : b\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn _max(string)\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 176332,
                "title": "python-dp-stack-very-easy-to-understand-beats-99-52",
                "content": "Simply iterate through the string.\\nIf `s[i] == \"(\"` simply store the position in the stack, and `dp[i] = 0` (because it does not signify the end of any valid parentheses. The position in stack will be used to check if the string made is completed or not later.\\nNow, if `s[i] == \")\"` see if the length of stack > 0, if it is not, `dp[i] = 0` because no valid parentheses end there. if length > 0, then pop the top of the stack, that is the position of the `\"(\"` that completes the current `\")\"`. \\nNow, just check if there was any valid parentheses ending just before that position. Because, if there was, this should be added to our length of the valid parentheses.\\neg:\\n`()(())`\\n`dp = [0, 2, 0, 0, 2, 6]`\\nHere, for the last `)` at position 5, it gets completed by the `(` at position 2, now check position 1, if there is a valid parentheses ending there, add its length to the current length.\\n\\nThe code is below:\\n\\n```\\n def longestValidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        if not s:\\n            return 0\\n        \\n        stack = []\\n        dp = [0]*len(s)\\n        \\n        for i in range(len(s)):\\n            if s[i] == \"(\":\\n                stack.append(i)\\n                dp[i] = 0\\n            else: #we have a closing brace\\n                if len(stack) == 0:\\n                    dp[i] = 0\\n                else:\\n                    pos = stack.pop()\\n                    dp[i] = dp[pos-1]+i-pos+1\\n        return max(dp)\\n```\\n",
                "solutionTags": [],
                "code": "```\\n def longestValidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        if not s:\\n            return 0\\n        \\n        stack = []\\n        dp = [0]*len(s)\\n        \\n        for i in range(len(s)):\\n            if s[i] == \"(\":\\n                stack.append(i)\\n                dp[i] = 0\\n            else: #we have a closing brace\\n                if len(stack) == 0:\\n                    dp[i] = 0\\n                else:\\n                    pos = stack.pop()\\n                    dp[i] = dp[pos-1]+i-pos+1\\n        return max(dp)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3998060,
                "title": "c-using-stack",
                "content": "# Approach\\nIn My solution, trash indicates breakpoint or we can say that when we encounter \\')\\' but we don\\'t have any \\'(\\' in stack to fulfil it , we can say next longer parentheses will start after this index and we need to keep track it since we are not inserting this into stack, \\nand for rest if stack is not empty we can easily say (index-st.top());\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N) due to stack.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int n = s.length();\\n        \\n        stack<int>st;\\n        int trash = 0;\\n        int ans = 0;\\n        for(int i=1; i<=n; i++){\\n            if(s[i-1]==\\'(\\'){\\n                st.push(i);\\n            }\\n            else{\\n                if(st.empty()){\\n                    trash= i;\\n                    continue;\\n                }\\n                else{\\n                    st.pop();\\n                }\\n                if(st.empty()){\\n                    ans= max(ans, (int)(i-trash));\\n                }\\n                else{\\n                    ans= max(ans, (int)(i-st.top()));\\n                } \\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int n = s.length();\\n        \\n        stack<int>st;\\n        int trash = 0;\\n        int ans = 0;\\n        for(int i=1; i<=n; i++){\\n            if(s[i-1]==\\'(\\'){\\n                st.push(i);\\n            }\\n            else{\\n                if(st.empty()){\\n                    trash= i;\\n                    continue;\\n                }\\n                else{\\n                    st.pop();\\n                }\\n                if(st.empty()){\\n                    ans= max(ans, (int)(i-trash));\\n                }\\n                else{\\n                    ans= max(ans, (int)(i-st.top()));\\n                } \\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2950489,
                "title": "simple-java-solution-with-o-n",
                "content": "\\n```\\nclass Solution {\\n    // TC : O(n)\\n    // SC : O(n)\\n    public int longestValidParentheses(String s) {\\n        if(s==null || s.length()<2){\\n            return 0;\\n        }\\n\\n        Stack<Integer> st =new Stack<>();\\n\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i) == \\'(\\'){\\n                st.push(i);\\n            } else{\\n\\n                // current closing bracket\\n\\n                if(!st.empty() && s.charAt(st.peek()) == \\'(\\'){\\n                    // balanced case\\n                    st.pop();\\n                } else {\\n                    // unbalanced case\\n                    st.push(i);\\n                }\\n            }\\n        }\\n     \\n        int maxLen = 0;\\n        int endTerminal = s.length();\\n\\n        while(!st.empty()){\\n            int startTerminal  = st.pop();\\n            maxLen = Math.max(maxLen, endTerminal - startTerminal -1);\\n            endTerminal = startTerminal;\\n        }\\n\\n        return Math.max(endTerminal, maxLen);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // TC : O(n)\\n    // SC : O(n)\\n    public int longestValidParentheses(String s) {\\n        if(s==null || s.length()<2){\\n            return 0;\\n        }\\n\\n        Stack<Integer> st =new Stack<>();\\n\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i) == \\'(\\'){\\n                st.push(i);\\n            } else{\\n\\n                // current closing bracket\\n\\n                if(!st.empty() && s.charAt(st.peek()) == \\'(\\'){\\n                    // balanced case\\n                    st.pop();\\n                } else {\\n                    // unbalanced case\\n                    st.push(i);\\n                }\\n            }\\n        }\\n     \\n        int maxLen = 0;\\n        int endTerminal = s.length();\\n\\n        while(!st.empty()){\\n            int startTerminal  = st.pop();\\n            maxLen = Math.max(maxLen, endTerminal - startTerminal -1);\\n            endTerminal = startTerminal;\\n        }\\n\\n        return Math.max(endTerminal, maxLen);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14227,
                "title": "why-people-give-conclusion-that-this-cannot-be-done-with-o-1-space-my-ac-solution-o-n-run-time-o-1-space",
                "content": "    public class Solution {\\n        public int longestValidParentheses(String s) {\\n          return ltr(s, 0, s.length());\\n        }\\n    \\n        public int ltr(String s, int start, int end) {\\n          int left = start;\\n          int openLeft = 0;\\n          int max = 0;\\n          for(int i = start; i < end; i++) {\\n            if(s.charAt(i) == '(')\\n              openLeft++;\\n            else\\n              openLeft--;\\n            if(openLeft < 0) {\\n              int length = i - left;\\n              if(length > max)\\n                max = length;\\n              left = i + 1;\\n              openLeft = 0;\\n            }\\n          }\\n          if(openLeft == 0) {\\n            int length = end - left;\\n            if(length > max)\\n              max = length;\\n          } {\\n            int length = rtl(s, left, end);\\n            if(length > max)\\n              max = length;\\n          }\\n          return max;\\n        }\\n\\n        public int rtl(String s, int start, int end) {\\n          int right = end;\\n          int openRight = 0;\\n          int max = 0;\\n          for(int i = end - 1; i >= start; i--) {\\n            if(s.charAt(i) == ')')\\n              openRight++;\\n            else\\n              openRight--;\\n            if(openRight < 0) {\\n              int length = right - (i + 1);\\n              if(length > max)\\n                max = length;\\n              right = i;\\n              openRight = 0;\\n            }\\n          }\\n          if(openRight == 0) {\\n            int length = right - start;\\n            if(length > max)\\n              max = length;\\n          }\\n          return max;\\n        }\\n      }\\n\\nI am pretty sure the code can be shorten to maybe half of the current size...... but why bother...\\nThe idea is very simple, 2 iteration at most. First time from left to right, second time from right to left.\\n\\nThe second iteration is only needed if the first iteration has ends with unclosed left bracket.",
                "solutionTags": [],
                "code": "class Solution {\\n        public int longestValidParentheses(String s) {\\n          return ltr(s, 0, s.length());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 14357,
                "title": "o-n-one-pass-solution-without-stacks",
                "content": "Basically it is a two pass solution, but I can combine them in one loop.\\n\\nFirst, scan from left to right while checking the balance. Second, scan from right to left in the same way. So no stack is needed.\\n\\n    class Solution {\\n    public:\\n        int longestValidParentheses(string s) {\\n            int result = 0;\\n            {\\n                int left = 0;\\n                int right = 0;\\n                for (int i = 0; i < s.length(); i++) {\\n                    switch (s[i]) {\\n                    case '(': left++; break;\\n                    case ')': right++; break;\\n                    default: left = right = 0; continue;\\n                    }\\n                    if (left == right && left + right > result) result = left + right;\\n                    if (right > left) left = right = 0;\\n                }\\n            }\\n            {\\n                int left = 0;\\n                int right = 0;\\n                for (int i = s.length(); i > 0; i--) {\\n                    switch (s[i-1]) {\\n                    case '(': left++; break;\\n                    case ')': right++; break;\\n                    default: left = right = 0; continue;\\n                    }\\n                    if (left == right && left + right > result) result = left + right;\\n                    if (left > right) left = right = 0;\\n                }\\n            }\\n            return result;\\n        }\\n    };\\n\\nCombination:\\n\\n    class Solution {\\n    public:\\n        int longestValidParentheses(string s) {\\n            int result = 0;\\n            int ll = 0, lr = 0, li = 0;  // left paren sum, right paren sum, left index\\n            int rl = 0, rr = 0, ri = s.length();  // left paren sum, right paren sum, right index\\n            while (li < s.length() && ri > 0) {\\n                switch (s[li]) {\\n                case '(': ll++; break;\\n                case ')': lr++; break;\\n                default: ll = lr = 0;\\n                }\\n                switch (s[ri-1]) {\\n                case '(': rl++; break;\\n                case ')': rr++; break;\\n                default: rl = rr = 0;\\n                }\\n                if (ll == lr && ll + lr > result) result = ll + lr;\\n                if (rl == rr && rl + rr > result) result = rl + rr;\\n                if (ll < lr) ll = lr = 0;\\n                if (rl > rr) rl = rr = 0;\\n                li++; ri--;\\n            }\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int longestValidParentheses(string s) {\\n            int result = 0;\\n            {\\n                int left = 0;\\n                int right = 0;\\n                for (int i = 0; i < s.length(); i++) {\\n                    switch (s[i]) {\\n                    case '(': left++; break;\\n                    case ')': right++; break;\\n                    default: left = right = 0; continue;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1149315,
                "title": "java-two-pointer-100-faster-constant-space",
                "content": "```\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n        int open=0;\\n        int close=0;\\n        int maxLen=0;\\n        \\n        for(int i=0;i<s.length();i++){\\n            char c=s.charAt(i);\\n            \\n            if(c==\\'(\\') open++;\\n            else close++;\\n            \\n            if(open==close){\\n                maxLen=Math.max(maxLen,open+close);\\n            }\\n            else if(close>open){\\n                open=close=0;\\n            }\\n        }\\n        \\n        open=close=0;\\n        \\n        for(int i=s.length()-1;i>=0;i--){\\n            char c=s.charAt(i);\\n            \\n            if(c==\\'(\\') open++;\\n            else close++;\\n            \\n            if(open==close){\\n                maxLen=Math.max(maxLen,open+close);\\n            }\\n            else if(close<open){\\n                open=close=0;\\n            }\\n        }\\n        return maxLen;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n        int open=0;\\n        int close=0;\\n        int maxLen=0;\\n        \\n        for(int i=0;i<s.length();i++){\\n            char c=s.charAt(i);\\n            \\n            if(c==\\'(\\') open++;\\n            else close++;\\n            \\n            if(open==close){\\n                maxLen=Math.max(maxLen,open+close);\\n            }\\n            else if(close>open){\\n                open=close=0;\\n            }\\n        }\\n        \\n        open=close=0;\\n        \\n        for(int i=s.length()-1;i>=0;i--){\\n            char c=s.charAt(i);\\n            \\n            if(c==\\'(\\') open++;\\n            else close++;\\n            \\n            if(open==close){\\n                maxLen=Math.max(maxLen,open+close);\\n            }\\n            else if(close<open){\\n                open=close=0;\\n            }\\n        }\\n        return maxLen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1050101,
                "title": "python-using-stacks-o-n-beats-97",
                "content": "Simple stack implementation in Python.\\n\\n```\\ndef longestValidParentheses(self, s: str) -> int:\\n        stack = [0,] # Initial value to handle \"()\"\\n        max_parenthesis = 0\\n        for bracket in s:\\n            if bracket == \\'(\\':\\n                stack.append(0)\\n            else:\\n                if len(stack) > 1:\\n                    val = stack.pop()\\n                    stack[-1] += val + 2  # Add 2 when a \")\" matches \"(\"\\n                    max_parenthesis = max(max_parenthesis, stack[-1]) # Keep track of longest valid sequence\\n                else:\\n                    stack = [0]\\n\\n        return max_parenthesis\\n\\t",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "Simple stack implementation in Python.\\n\\n```\\ndef longestValidParentheses(self, s: str) -> int:\\n        stack = [0,] # Initial value to handle \"()\"\\n        max_parenthesis = 0\\n        for bracket in s:\\n            if bracket == \\'(\\':\\n                stack.append(0)\\n            else:\\n                if len(stack) > 1:\\n                    val = stack.pop()\\n                    stack[-1] += val + 2  # Add 2 when a \")\" matches \"(\"\\n                    max_parenthesis = max(max_parenthesis, stack[-1]) # Keep track of longest valid sequence\\n                else:\\n                    stack = [0]\\n\\n        return max_parenthesis\\n\\t",
                "codeTag": "Python3"
            },
            {
                "id": 752095,
                "title": "c-easy-solution-with-stack-and-dynamic-programming-with-explanation",
                "content": "We can solve this problem using stack. We will push -1 into the stack, so that whenever the stack becomes empty then we are sure that it is not valid at that point. So, whenever we have \\')\\' then we pop the element from the stack and if it is empty then the string ending at that index is not valid and we need to push the index so to find next valid parenthesis length. Let\\'s do a dry run of the below code by using the string \"()(()\".\\n\\nFirst, we push -1 so initially stack element is -1.\\nAt i=0, we have s[i]=\\'(\\' , we push the index 0.\\nAt i=1, we have s[i]=\\')\\', we pop the element from the stack so the current valid length till index 1 becomes (i-stack.top()) i.e. (1-(-1))=2.\\nAt i=2, we have s[i]=\\')\\' , we pop the element from the stack and note that stack now becomes empty so any new valid string would start after this index only. Thus, we push the index i=2 in the stack.\\n\\nAt i=3, we have s[i]=\\'(\\', we push the index 3 in the stack.\\nAt i=4, we have s[i]=\\')\\', we pop the element and since the stack is still not empty, we find the length valid till this index as (4-2)=2.\\n\\nThus, the longest valid parenthesis length is 2 for this example.\\nThe time complexity of this approach is O(n) and space complexity is also O(n).\\n\\nPlease let me know me in the comment section if you need further clarification on how this approach works.\\n\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> p;\\n        int maxlength=0;\\n        p.push(-1);\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                p.push(i);\\n            }\\n            else{\\n                p.pop();\\n                if(p.empty())\\n                    p.push(i);\\n                else\\n                    maxlength=max(maxlength,i-p.top());\\n            }\\n        }\\n        return maxlength;\\n    }\\n};\\n```\\n\\nWe can also use dynamic programming to solve this problem. We can find the length of valid parenthesis till each index.  For any string ending with \\'(\\' the length would be zero since valid parenthesis cannot end with \\'(\\'. \\n\\nIf the string ends with \\')\\', then there will be two cases :\\n\\n1. If the previous character is \\'(\\' then the length of valid parenthesis ending at this index would be dp[i-2] + 2.\\n2.  We need to check if the character at (i-dp[i-1]-1) =\\'(\\' if it is the length of valid parenthesis ending at this point is dp[i-1] + (i>=2 ? dp[i-dp[i-1]-2] :0) +2.\\n\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n       int maxlength=0;\\n       vector<int> dp(s.length(),0);\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(s[i]==\\')\\')\\n            {\\n                if(s[i]==\\'(\\')\\n                    dp[i]=(i>=2 ? dp[i-2] : 0)+2;\\n                else if(i-dp[i-1]-1>=0 && s[i-dp[i-1]-1]==\\'(\\')\\n                    dp[i]=dp[i-1]+((i-dp[i-1])>=2 ? dp[i-dp[i-1]-2] :0)+2;\\n            }\\n            maxlength=max(maxlength,dp[i]);\\n        }\\n        return maxlength;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> p;\\n        int maxlength=0;\\n        p.push(-1);\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                p.push(i);\\n            }\\n            else{\\n                p.pop();\\n                if(p.empty())\\n                    p.push(i);\\n                else\\n                    maxlength=max(maxlength,i-p.top());\\n            }\\n        }\\n        return maxlength;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n       int maxlength=0;\\n       vector<int> dp(s.length(),0);\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(s[i]==\\')\\')\\n            {\\n                if(s[i]==\\'(\\')\\n                    dp[i]=(i>=2 ? dp[i-2] : 0)+2;\\n                else if(i-dp[i-1]-1>=0 && s[i-dp[i-1]-1]==\\'(\\')\\n                    dp[i]=dp[i-1]+((i-dp[i-1])>=2 ? dp[i-dp[i-1]-2] :0)+2;\\n            }\\n            maxlength=max(maxlength,dp[i]);\\n        }\\n        return maxlength;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 309306,
                "title": "recursive-c-solution-with-memoization-o-n",
                "content": "/*\\nT : O(n)\\nS : O(n)\\nIdea : try to break in smaller sub problem .\\ncase 1: string ends at \"()\"\\nlongestParenEnding(0, i) = longestParenEnding(0, i - 2) + 2\\n\\ncase 2: string ends with \"))\" for example \"()(())\"\\nlongestParenEnding(0, i) = \\n\\ncase 3: string ends with \"(\"\\nlongestParenEnding(0, i) = 0\\n*/\\n```\\nclass Solution {\\n    int lonParen(int i, string & s, vector<int> & memo){\\n        if(i <= 0){\\n            return 0;\\n        }\\n        \\n        if(memo[i] != -1){\\n            return memo[i];\\n        }\\n        \\n        if(s[i] == \\'(\\'){\\n            memo[i] = 0;\\n        }\\n        else if(s[i] == \\')\\' && s[i - 1] == \\'(\\'){\\n            memo[i] = lonParen(i - 2, s, memo) + 2;\\n        }\\n        else if(s[i] == \\')\\' && s[i - 1] == \\')\\'){\\n            int len = lonParen(i - 1, s, memo);\\n            if(i - 1 - len >= 0 && s[i - 1 - len] == \\'(\\'){\\n                memo[i] = len + 2 + lonParen(i - len - 2, s, memo);\\n            }\\n            else{\\n                memo[i] = 0;\\n            }\\n        }\\n        return memo[i];\\n    }\\npublic:\\n    int longestValidParentheses(string s) {\\n        \\n        int n = s.size(), maxLen = 0;\\n        vector<int> memo(n, -1);\\n        for(int i = 0; i < n; i++){\\n            maxLen = max(maxLen, lonParen(i, s, memo));\\n        }\\n        return maxLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int lonParen(int i, string & s, vector<int> & memo){\\n        if(i <= 0){\\n            return 0;\\n        }\\n        \\n        if(memo[i] != -1){\\n            return memo[i];\\n        }\\n        \\n        if(s[i] == \\'(\\'){\\n            memo[i] = 0;\\n        }\\n        else if(s[i] == \\')\\' && s[i - 1] == \\'(\\'){\\n            memo[i] = lonParen(i - 2, s, memo) + 2;\\n        }\\n        else if(s[i] == \\')\\' && s[i - 1] == \\')\\'){\\n            int len = lonParen(i - 1, s, memo);\\n            if(i - 1 - len >= 0 && s[i - 1 - len] == \\'(\\'){\\n                memo[i] = len + 2 + lonParen(i - len - 2, s, memo);\\n            }\\n            else{\\n                memo[i] = 0;\\n            }\\n        }\\n        return memo[i];\\n    }\\npublic:\\n    int longestValidParentheses(string s) {\\n        \\n        int n = s.size(), maxLen = 0;\\n        vector<int> memo(n, -1);\\n        for(int i = 0; i < n; i++){\\n            maxLen = max(maxLen, lonParen(i, s, memo));\\n        }\\n        return maxLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14303,
                "title": "o-1-space-python-solution-no-stack",
                "content": "scan s from left to right and then from right to left. The variable names are quite self-explaining. \\n\\n    def longestValidParentheses(self, s):\\n        return max(self.helper(s,'('), self.helper(s[::-1],')'))\\n    \\n    def helper(self, s, left):\\n        ans = 0\\n        maxendinghere = 0\\n        count = 0\\n        for c in s:\\n            if c == left:    #when scan s from left to right, left is '(', otherwise is ')'\\n                count += 1\\n                maxendinghere += 1\\n            else: \\n                count -= 1\\n                if count <0:\\n                    maxendinghere = 0\\n                    count = 0\\n                else:\\n                    maxendinghere += 1\\n                    if count == 0:\\n                        ans = max(ans, maxendinghere)\\n        return ans",
                "solutionTags": [],
                "code": "scan s from left to right and then from right to left. The variable names are quite self-explaining. \\n\\n    def longestValidParentheses(self, s):\\n        return max(self.helper(s,'('), self.helper(s[::-1],')'))\\n    \\n    def helper(self, s, left):\\n        ans = 0\\n        maxendinghere = 0\\n        count = 0\\n        for c in s:\\n            if c == left:    #when scan s from left to right, left is '(', otherwise is ')'\\n                count += 1\\n                maxendinghere += 1\\n            else: \\n                count -= 1\\n                if count <0:\\n                    maxendinghere = 0\\n                    count = 0\\n                else:\\n                    maxendinghere += 1\\n                    if count == 0:\\n                        ans = max(ans, maxendinghere)\\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 14137,
                "title": "68-ms-fast-python-solution-beat-97-only-put-starting-index-in-stack-detailed-explaination",
                "content": "    class Solution(object):\\n        def longestValidParentheses(self, s):\\n            \"\"\"\\n            :type s: str\\n            :rtype: int\\n            \"\"\"\\n            result=0\\n            stk=[]\\n            lst=-1\\n            for i in xrange(len(s)):\\n                if s[i]=='(':\\n                    if lst!=-1:\\n                        stk.append(lst)\\n                        lst=-1\\n                    else:\\n                        stk.append(i)\\n                else:\\n                    if stk:\\n                        stt=stk.pop()\\n                        if i-stt+1>result:\\n                            result=i-stt+1\\n                        lst=stt\\n                    else:\\n                        lst=-1\\n            return result\\n\\nstk store the index of '('. <br>\\nwe intereate through the string. <br>\\nresult is the length of the longest unbroken bracket chain at that position, we update it when we iterate through the string. We initiate it to 0.<br>\\nlst is -1 or the starting index of the unbroken bracket chain we just extended with a matching ')', its initial value is -1, if we iterate to a '(' or a umatchable ')', we set lst to -1. So we are using lst for two purposes.<br>\\nEvery time we see a '(',  we push a index to the stack. if the lst is not -1 (means last time we just got a matching ')' and extended the current unbroken bracket chain and we set lst to the starting index of that chain), we push lst into the stack. If lst is -1, it means we are on index 0 or last character is not a match ')'. We push the index i into the stack. We set lst to -1 in either case.<br>\\nEvery time we see a ')' and the stack is not empty ( means it's a matching ')' ),we pop the stack. we calculate the length of the chain and update the result and set the lst to the popped index. If the stack is empty, it means that's a unmatchable ')', and we set lst to -1.<br>\\nA lot of times, we pop a index and push it right back like when we iterate to index 2 of string \"()()\"\\nIn the end of the interation we will have the length of the longest chain in the result variable\\n\\nLet me know if the explaination doesn't make sense or hard to understand. I will try my best to revise it.",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def longestValidParentheses(self, s):\\n            \"\"\"\\n            :type s: str\\n            :rtype: int\\n            \"\"\"\\n            result=0\\n            stk=[]\\n            lst=-1\\n            for i in xrange(len(s)):\\n                if s[i]=='(':\\n                    if lst!=-1:\\n                        stk.append(lst)\\n                        lst=-1\\n                    else:\\n                        stk.append(i)\\n                else:\\n                    if stk:\\n                        stt=stk.pop()\\n                        if i-stt+1>result:\\n                            result=i-stt+1\\n                        lst=stt\\n                    else:\\n                        lst=-1\\n            return result\\n\\nstk store the index of '('. <br>\\nwe intereate through the string. <br>\\nresult is the length of the longest unbroken bracket chain at that position, we update it when we iterate through the string. We initiate it to 0.<br>\\nlst is -1 or the starting index of the unbroken bracket chain we just extended with a matching ')', its initial value is -1, if we iterate to a '(' or a umatchable ')', we set lst to -1. So we are using lst for two purposes.<br>\\nEvery time we see a '(',  we push a index to the stack. if the lst is not -1 (means last time we just got a matching ')' and extended the current unbroken bracket chain and we set lst to the starting index of that chain), we push lst into the stack. If lst is -1, it means we are on index 0 or last character is not a match ')'. We push the index i into the stack. We set lst to -1 in either case.<br>\\nEvery time we see a ')' and the stack is not empty ( means it's a matching ')' ),we pop the stack. we calculate the length of the chain and update the result and set the lst to the popped index. If the stack is empty, it means that's a unmatchable ')', and we set lst to -1.<br>\\nA lot of times, we pop a index and push it right back like when we iterate to index 2 of string \"()()\"\\nIn the end of the interation we will have the length of the longest chain in the result variable\\n\\nLet me know if the explaination doesn't make sense or hard to understand. I will try my best to revise it.",
                "codeTag": "Java"
            },
            {
                "id": 2068590,
                "title": "c-short-and-simple-solution",
                "content": "Easy stack based problem.<br>\\nComplexities :\\n* **Time :** `O(n)`\\n* **Space :** `O(n)`\\n\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        \\n\\t    int maxVal = 0;\\n\\n    \\tstack<int> st;\\n\\t    st.push(-1);\\n\\n    \\tfor(int i = 0; i < s.size(); i++)\\n\\t    \\tif(s[i] == \\'(\\')\\n                st.push(i);\\n\\n    \\t\\telse {       \\n\\t    \\t\\tst.pop();\\n\\n\\t\\t    \\tif(st.empty())\\n                    st.push(i);\\n    \\t\\t\\telse\\n                    maxVal = max(maxVal, i - st.top());\\n    \\t\\t}        \\n        \\n\\t    return maxVal;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        \\n\\t    int maxVal = 0;\\n\\n    \\tstack<int> st;\\n\\t    st.push(-1);\\n\\n    \\tfor(int i = 0; i < s.size(); i++)\\n\\t    \\tif(s[i] == \\'(\\')\\n                st.push(i);\\n\\n    \\t\\telse {       \\n\\t    \\t\\tst.pop();\\n\\n\\t\\t    \\tif(st.empty())\\n                    st.push(i);\\n    \\t\\t\\telse\\n                    maxVal = max(maxVal, i - st.top());\\n    \\t\\t}        \\n        \\n\\t    return maxVal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1899279,
                "title": "python-3-o-n-solution",
                "content": "Algorithm Explanation:\\n1. check for the base case and if valid string make stack and add dummy value (reason explained in step )\\n2. loop through the string using enumerate as we will use both character and index of the character to count the longest valid parentheses\\n3. we will append open bracker index in stack and pop the last element when closed parentheses encountered\\n4.  if we encounter closed parentheses as our first value than we will have dummy value to remove from stack\\n5.  after removing last element from the stack check if stack is empty if it is than append index of current character\\n6.  if not than we will calculate current length which will be current index - last value of stack\\n7.  for max length we will do max of current lengh and assigned max lenght\\n```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n\\t\\t# base case check\\n        if not s:\\n            return 0\\n        stack = [-1] # \\n        max_len = 0\\n        for i, ch in enumerate(s):\\n            if ch == \\'(\\':\\n                stack.append(i)\\n            else:\\n                stack.pop()\\n                if not stack:\\n                    stack.append(i)\\n                else:\\n                    curr_len = i - stack[len(stack)-1]\\n                    max_len = max(curr_len, max_len)\\n        return max_len\\n```\\n\\nPlease upvote this solution if you find it helpful.\\nany suggestions or imporvement are more than welcome.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n\\t\\t# base case check\\n        if not s:\\n            return 0\\n        stack = [-1] # \\n        max_len = 0\\n        for i, ch in enumerate(s):\\n            if ch == \\'(\\':\\n                stack.append(i)\\n            else:\\n                stack.pop()\\n                if not stack:\\n                    stack.append(i)\\n                else:\\n                    curr_len = i - stack[len(stack)-1]\\n                    max_len = max(curr_len, max_len)\\n        return max_len\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1379451,
                "title": "easy-stack-based-approach-in-c",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        stack<int>stk;\\n        int ans=0;\\n        stk.push(-1);\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                stk.push(i);\\n            }\\n            else\\n            {\\n                stk.pop();\\n                if(!stk.empty())\\n                {\\n                    ans=max(ans,i-stk.top());\\n                }\\n                else\\n                {\\n                    stk.push(i);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        stack<int>stk;\\n        int ans=0;\\n        stk.push(-1);\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                stk.push(i);\\n            }\\n            else\\n            {\\n                stk.pop();\\n                if(!stk.empty())\\n                {\\n                    ans=max(ans,i-stk.top());\\n                }\\n                else\\n                {\\n                    stk.push(i);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1144587,
                "title": "java-simple-and-easy-to-understand-solution-using-stack-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n```\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n        Stack<Integer> stack = new Stack();\\n        stack.push(-1);\\n        \\n        int maxLen = 0;\\n        \\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == \\'(\\'){ //opening bracket\\n                \\n                stack.push(i);\\n            }else if(s.charAt(i) == \\')\\'){ //closing bracket\\n                \\n                stack.pop();\\n                if(stack.empty()){\\n                    //reset\\n                    stack.push(i);\\n                }else{\\n                    //update maxLen\\n                    maxLen = Math.max(maxLen, i - stack.peek());\\n                }\\n                    \\n            }\\n        }\\n        \\n        return maxLen;\\n    }\\n\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n        Stack<Integer> stack = new Stack();\\n        stack.push(-1);\\n        \\n        int maxLen = 0;\\n        \\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == \\'(\\'){ //opening bracket\\n                \\n                stack.push(i);\\n            }else if(s.charAt(i) == \\')\\'){ //closing bracket\\n                \\n                stack.pop();\\n                if(stack.empty()){\\n                    //reset\\n                    stack.push(i);\\n                }else{\\n                    //update maxLen\\n                    maxLen = Math.max(maxLen, i - stack.peek());\\n                }\\n                    \\n            }\\n        }\\n        \\n        return maxLen;\\n    }\\n\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14173,
                "title": "javascript-solution-o-n-with-comments",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar longestValidParentheses = function(s) {\\n    if (!s || !s.length) { return 0; }\\n\\n    /* We will store the position of every invalid parenthesis.\\n       Once we have that, the solution is simply the longest\\n       subarray between two invalid parentheses */\\n    const invalids = new Set();\\n\\n    /* We stack the opening parentheses as we find them,\\n       and pop them we we meet the corresponding closing\\n       parenthesis. Note that a closing ) always matches the\\n       latest opening ( one, hence the choice of a stack */\\n    const stack = [];\\n\\n    for (let i=0; i<s.length; i++) {\\n        if (s[i] === '(') {\\n            stack.push(i);\\n        } else {\\n            // If we are closing an opening parenthesis, pop it out\\n            if (stack.length) {\\n                stack.pop();\\n            } else {\\n                /* Otherwise there is nothing to close,\\n                   hence this parenthesis is invalid */\\n                invalids.add(i);\\n            }\\n        }\\n    }\\n\\n    /* Any remaining opening parenthesis that has not been closed is\\n       automatically invalid */\\n    while (stack.length) {\\n        invalids.add(stack.pop());\\n    }\\n    \\n    // Here we just count how many valid in between every invalid\\n    let max = 0, count = 0;\\n    for (let i=0; i<=s.length; i++) {\\n        if (i < s.length && !invalids.has(i)) {\\n            count++;\\n        } else {\\n            max = Math.max(max, count);\\n            count = 0;\\n        }\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar longestValidParentheses = function(s) {\\n    if (!s || !s.length) { return 0; }\\n\\n    /* We will store the position of every invalid parenthesis.\\n       Once we have that, the solution is simply the longest\\n       subarray between two invalid parentheses */\\n    const invalids = new Set();\\n\\n    /* We stack the opening parentheses as we find them,\\n       and pop them we we meet the corresponding closing\\n       parenthesis. Note that a closing ) always matches the\\n       latest opening ( one, hence the choice of a stack */\\n    const stack = [];\\n\\n    for (let i=0; i<s.length; i++) {\\n        if (s[i] === '(') {\\n            stack.push(i);\\n        } else {\\n            // If we are closing an opening parenthesis, pop it out\\n            if (stack.length) {\\n                stack.pop();\\n            } else {\\n                /* Otherwise there is nothing to close,\\n                   hence this parenthesis is invalid */\\n                invalids.add(i);\\n            }\\n        }\\n    }\\n\\n    /* Any remaining opening parenthesis that has not been closed is\\n       automatically invalid */\\n    while (stack.length) {\\n        invalids.add(stack.pop());\\n    }\\n    \\n    // Here we just count how many valid in between every invalid\\n    let max = 0, count = 0;\\n    for (let i=0; i<=s.length; i++) {\\n        if (i < s.length && !invalids.has(i)) {\\n            count++;\\n        } else {\\n            max = Math.max(max, count);\\n            count = 0;\\n        }\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 14354,
                "title": "my-simple-java-solution",
                "content": "    public int longestValidParentheses(String s) {\\n        Stack<Integer> st = new Stack<Integer>();\\n        int maxLen = 0;\\n        int curLen = 0;\\n        for(int i = 0; i < s.length();i++) {\\n            if(s.charAt(i) == '(') {\\n                st.push(curLen);\\n                curLen = 0;\\n            } else if (s.charAt(i) == ')') {\\n                if(st.isEmpty()) {\\n                    curLen = 0;\\n                } else {\\n                    curLen = curLen + st.pop() + 2;\\n                    if(curLen > maxLen) maxLen = curLen;\\n                }\\n            }\\n        }\\n        return maxLen;\\n    }",
                "solutionTags": [],
                "code": "    public int longestValidParentheses(String s) {\\n        Stack<Integer> st = new Stack<Integer>();\\n        int maxLen = 0;\\n        int curLen = 0;\\n        for(int i = 0; i < s.length();i++) {\\n            if(s.charAt(i) == '(') {\\n                st.push(curLen);\\n                curLen = 0;\\n            } else if (s.charAt(i) == ')') {\\n                if(st.isEmpty()) {\\n                    curLen = 0;\\n                } else {\\n                    curLen = curLen + st.pop() + 2;\\n                    if(curLen > maxLen) maxLen = curLen;\\n                }\\n            }\\n        }\\n        return maxLen;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 14395,
                "title": "within-10-lines-in-python-to-solve-it",
                "content": "      def longestValidParentheses(self, s):\\n        \"\"\" as the \")\" will not effect the final result, which acts as a dummy  element to\\n            make the all the  original elements of s equivalently, \\n            otherwise the first element needs to be dealt with separately. \\n        \"\"\" \\n        s = \")\" + s  \\n        stack, ans = [], 0\\n        for index in xrange(len(s)):\\n          element = s[index]\\n          if element == \")\" and stack and stack[-1][1] == \"(\":\\n            stack.pop()\\n            ans = max(ans, index - stack[-1][0])\\n          else:\\n            stack.append((index, element))\\n        return ans",
                "solutionTags": [
                    "Python"
                ],
                "code": "      def longestValidParentheses(self, s):\\n        \"\"\" as the \")\" will not effect the final result, which acts as a dummy  element to\\n            make the all the  original elements of s equivalently, \\n            otherwise the first element needs to be dealt with separately. \\n        \"\"\" \\n        s = \")\" + s  \\n        stack, ans = [], 0\\n        for index in xrange(len(s)):\\n          element = s[index]\\n          if element == \")\" and stack and stack[-1][1] == \"(\":\\n            stack.pop()\\n            ans = max(ans, index - stack[-1][0])\\n          else:\\n            stack.append((index, element))\\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 14405,
                "title": "an-easy-understanding-way-to-solve-it",
                "content": "but maybe with more timewaste.haha\\n\\n    class LVP{\\n    \\n    \\tpublic:\\n    \\tint lvp( string s ){\\n    \\t\\tint len = s.size();\\n    \\t\\tif( !len )\\t\\t\\t// if string is empty, return 0 instantly.\\n    \\t\\t\\treturn 0;\\n    \\t\\tfor( int i = 0;i < len;i++ )\\t\\n    \\t\\t\\tif( s[i] == ')' )\\t\\n    \\t\\t\\t\\tfor( int j = i - 1;j >= 0;j-- )\\t\\t// for every ')\\u2019\\uff0cfind the first match '(' before it\\n    \\t\\t\\t\\t\\tif( s[j] == '(' )\\t{\\t\\t\\t// and mark the two with a special flag,like '0'\\n    \\t\\t\\t\\t\\t\\ts[i] = '0';\\n    \\t\\t\\t\\t\\t\\ts[j] = '0';\\n    \\t\\t\\t\\t\\t\\tbreak;\\n    \\t\\t\\t\\t\\t}\\n    \\t\\tint max = 0,temp = 0;\\t\\t\\t\\t\\t\\t\\n    \\t\\tfor( int i = 0;i < len;i++ )\\t{\\t\\t\\t// the problem changed to find the longest '0' in the string\\n    \\t\\t\\tif( s[i] == '0' )\\n    \\t\\t\\t\\ttemp++;\\n    \\t\\t\\telse\\t{\\n    \\t\\t\\t\\tmax = temp > max ? temp : max;\\n    \\t\\t\\t\\ttemp = 0;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tmax = temp > max ? temp : max;\\t\\t\\t\\t// longest '0'sequence may still stored in temp\\n    \\t\\treturn max;\\n    \\t}\\n    };",
                "solutionTags": [],
                "code": "but maybe with more timewaste.haha\\n\\n    class LVP{\\n    \\n    \\tpublic:\\n    \\tint lvp( string s ){\\n    \\t\\tint len = s.size();\\n    \\t\\tif( !len )\\t\\t\\t// if string is empty, return 0 instantly.\\n    \\t\\t\\treturn 0;\\n    \\t\\tfor( int i = 0;i < len;i++ )\\t\\n    \\t\\t\\tif( s[i] == ')' )\\t\\n    \\t\\t\\t\\tfor( int j = i - 1;j >= 0;j-- )\\t\\t// for every ')\\u2019\\uff0cfind the first match '(' before it\\n    \\t\\t\\t\\t\\tif( s[j] == '(' )\\t{\\t\\t\\t// and mark the two with a special flag,like '0'\\n    \\t\\t\\t\\t\\t\\ts[i] = '0';\\n    \\t\\t\\t\\t\\t\\ts[j] = '0';\\n    \\t\\t\\t\\t\\t\\tbreak;\\n    \\t\\t\\t\\t\\t}\\n    \\t\\tint max = 0,temp = 0;\\t\\t\\t\\t\\t\\t\\n    \\t\\tfor( int i = 0;i < len;i++ )\\t{\\t\\t\\t// the problem changed to find the longest '0' in the string\\n    \\t\\t\\tif( s[i] == '0' )\\n    \\t\\t\\t\\ttemp++;\\n    \\t\\t\\telse\\t{\\n    \\t\\t\\t\\tmax = temp > max ? temp : max;\\n    \\t\\t\\t\\ttemp = 0;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tmax = temp > max ? temp : max;\\t\\t\\t\\t// longest '0'sequence may still stored in temp\\n    \\t\\treturn max;\\n    \\t}\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 625799,
                "title": "memorized-dfs-top-down-dp",
                "content": "I did not see a top down approach, so I created one. \\ndp[i] = longest valid parentheses ending at index `i`.\\n\\nStarting from the end of the string `s`, either current position is `(` when it means computation is done for the string ending at index `i`; \\nor a more complex case where the current char is `)` when recursion needs to continue to find out `dp[i - 1]`. \\n```\\nif s[i] == \\'(\\':\\n    dp[i] = 0\\nelif s[i] == \\')\\':\\n\\tif  i - dp[i - 1] - 1 >= 0 and s[i - dp[i - 1] - 1] == \\'(\\':\\n\\t\\t\\tdp[i] = dp[ i - dp[i - 1] - 2] + 2 + dp[i - 1]\\n\\telse:\\n\\t\\t\\tdp[i] = 0\\n```\\n\\nWe need to do the above for all index within string `s` because we have defined the `dp[i]` to mean such valid string to end in every index. \\nAfter that we want to collect the longest of such valid parentheses. \\n\\nHence the final code for this top down approach:\\n```\\nimport functools\\nclass Solution:\\n    def __init__(self):\\n        self.max = 0\\n        \\n    def longestValidParentheses(self, s: str) -> int:\\n        \\n        @functools.lru_cache(maxsize = None)\\n        def dp(s, i):\\n            if i < 0:\\n                return 0\\n\\n            if s[i] == \\'(\\':\\n                return 0\\n\\n            ans = 0\\n            length = dp(s, i - 1)\\n            if i - length - 1 >= 0 and s[i - length - 1] == \\'(\\':\\n                ans = length + 2 + dp(s, i - length - 1 - 1)\\n\\n            self.max = max(self.max, ans)\\n            return ans\\n\\n        for i in range(len(s)):\\n            dp(s, i)\\n            \\n        return self.max\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nif s[i] == \\'(\\':\\n    dp[i] = 0\\nelif s[i] == \\')\\':\\n\\tif  i - dp[i - 1] - 1 >= 0 and s[i - dp[i - 1] - 1] == \\'(\\':\\n\\t\\t\\tdp[i] = dp[ i - dp[i - 1] - 2] + 2 + dp[i - 1]\\n\\telse:\\n\\t\\t\\tdp[i] = 0\\n```\n```\\nimport functools\\nclass Solution:\\n    def __init__(self):\\n        self.max = 0\\n        \\n    def longestValidParentheses(self, s: str) -> int:\\n        \\n        @functools.lru_cache(maxsize = None)\\n        def dp(s, i):\\n            if i < 0:\\n                return 0\\n\\n            if s[i] == \\'(\\':\\n                return 0\\n\\n            ans = 0\\n            length = dp(s, i - 1)\\n            if i - length - 1 >= 0 and s[i - length - 1] == \\'(\\':\\n                ans = length + 2 + dp(s, i - length - 1 - 1)\\n\\n            self.max = max(self.max, ans)\\n            return ans\\n\\n        for i in range(len(s)):\\n            dp(s, i)\\n            \\n        return self.max\\n```",
                "codeTag": "Java"
            },
            {
                "id": 593019,
                "title": "store-current-longest-valid-string-on-stack-add-to-it-when-popped-python",
                "content": "A couple of the highest voted solutions are similar, but this was the easist way for me to understand it. Whenever we see a new open paren, we push the current longest streak to the stack. Whenever we see a close paren, we pop the top value if possible, and add the value (which was the previous longest streak up to that point) to the current one (because they are now contiguous) and add 2 to count for the matching open and close parens. If there is no matching open paren for a close paren, reset the current count. Observe:\\n\\n```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        stack, curr_longest, max_longest = [], 0, 0\\n        for c in s:\\n            if c == \\'(\\':\\n                stack.append(curr_longest)\\n                curr_longest = 0\\n            elif c == \\')\\':\\n                if stack:\\n                    curr_longest += stack.pop() + 2\\n                    max_longest = max(max_longest, curr_longest)\\n                else:\\n                    curr_longest = 0\\n        return max_longest\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        stack, curr_longest, max_longest = [], 0, 0\\n        for c in s:\\n            if c == \\'(\\':\\n                stack.append(curr_longest)\\n                curr_longest = 0\\n            elif c == \\')\\':\\n                if stack:\\n                    curr_longest += stack.pop() + 2\\n                    max_longest = max(max_longest, curr_longest)\\n                else:\\n                    curr_longest = 0\\n        return max_longest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 555969,
                "title": "js-no-magic-approach-2-beats-99-2-approaches-to-choose-from-feedback-is-welcome",
                "content": "\\n1.Sliding window \\n-time O(N)\\n-space O(N)\\n```\\n\\nvar longestValidParentheses = function(s) {\\n    let longest = 0\\n    let stack=[-1]\\n    \\n    for(let i=0;i<s.length;i++){\\n      let char = s[i]\\n      \\n      if(char === \\'(\\'){\\n        stack.push(i)\\n        continue\\n      }\\n      \\n      stack.pop()\\n      if(!stack.length) stack.push(i)\\n      else longest = Math.max((i - stack[stack.length-1]),longest)\\n    }\\n  \\n    return longest\\n};\\n```\\n\\n2. Using left to right pass then right to left pass\\n-time O(N)\\n-space O(1)\\n\\n```\\n\\nfunction longestValidParentheses(s){\\n  let longest = 0,leftCount = 0, rightCount = 0\\n  \\n  //left to right pass\\n  for(let i=0; i < s.length;i++){\\n    \\n    if(s[i] === \\'(\\')leftCount++\\n    else rightCount++\\n    \\n    if(leftCount === rightCount){\\n      longest = Math.max(longest,leftCount+rightCount)\\n    }else if(leftCount <rightCount){\\n      leftCount=0\\n      rightCount=0\\n    }\\n  }\\n  \\n  //right to left pass\\n  leftCount = 0, rightCount = 0\\n  for(let i=s.length-1; i >= 0;i--){\\n\\n    if(s[i] === \\'(\\')leftCount++\\n    else rightCount++\\n\\n    if(leftCount === rightCount){\\n      longest = Math.max(longest,leftCount+rightCount)\\n    }else if(leftCount >rightCount){\\n      leftCount=0\\n      rightCount=0\\n    }\\n  }\\n  return longest\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar longestValidParentheses = function(s) {\\n    let longest = 0\\n    let stack=[-1]\\n    \\n    for(let i=0;i<s.length;i++){\\n      let char = s[i]\\n      \\n      if(char === \\'(\\'){\\n        stack.push(i)\\n        continue\\n      }\\n      \\n      stack.pop()\\n      if(!stack.length) stack.push(i)\\n      else longest = Math.max((i - stack[stack.length-1]),longest)\\n    }\\n  \\n    return longest\\n};\\n```\n```\\n\\nfunction longestValidParentheses(s){\\n  let longest = 0,leftCount = 0, rightCount = 0\\n  \\n  //left to right pass\\n  for(let i=0; i < s.length;i++){\\n    \\n    if(s[i] === \\'(\\')leftCount++\\n    else rightCount++\\n    \\n    if(leftCount === rightCount){\\n      longest = Math.max(longest,leftCount+rightCount)\\n    }else if(leftCount <rightCount){\\n      leftCount=0\\n      rightCount=0\\n    }\\n  }\\n  \\n  //right to left pass\\n  leftCount = 0, rightCount = 0\\n  for(let i=s.length-1; i >= 0;i--){\\n\\n    if(s[i] === \\'(\\')leftCount++\\n    else rightCount++\\n\\n    if(leftCount === rightCount){\\n      longest = Math.max(longest,leftCount+rightCount)\\n    }else if(leftCount >rightCount){\\n      leftCount=0\\n      rightCount=0\\n    }\\n  }\\n  return longest\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 400214,
                "title": "easy-python-solution-no-dynamic-programming",
                "content": "\\tclass Solution(object):\\n\\t\\tdef longestValidParentheses(self, s):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type s: str\\n\\t\\t\\t:rtype: int\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tm = l = r = 0\\n\\t\\t\\tfor e in s:\\n\\t\\t\\t\\tif e==\\'(\\':\\n\\t\\t\\t\\t\\tl+=1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tr+=1\\n\\t\\t\\t\\tif l==r:\\n\\t\\t\\t\\t\\tm = max(m,r+l)\\n\\t\\t\\t\\telif r>l:\\n\\t\\t\\t\\t\\tl=r=0\\n\\t\\t\\tl=r=0\\n\\t\\t\\tfor e in s[::-1]:\\n\\t\\t\\t\\tif e==\\')\\':\\n\\t\\t\\t\\t\\tr+=1\\n\\t\\t\\t\\telse: \\n\\t\\t\\t\\t\\tl+=1\\n\\t\\t\\t\\tif l==r: \\n\\t\\t\\t\\t\\tm=max(m,r+l)\\n\\t\\t\\t\\telif l>r:\\n\\t\\t\\t\\t\\tl=r=0\\n\\t\\t\\treturn m\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution(object):\\n\\t\\tdef longestValidParentheses(self, s):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type s: str\\n\\t\\t\\t:rtype: int\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tm = l = r = 0\\n\\t\\t\\tfor e in s:\\n\\t\\t\\t\\tif e==\\'(\\':\\n\\t\\t\\t\\t\\tl+=1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tr+=1\\n\\t\\t\\t\\tif l==r:\\n\\t\\t\\t\\t\\tm = max(m,r+l)\\n\\t\\t\\t\\telif r>l:\\n\\t\\t\\t\\t\\tl=r=0\\n\\t\\t\\tl=r=0\\n\\t\\t\\tfor e in s[::-1]:\\n\\t\\t\\t\\tif e==\\')\\':\\n\\t\\t\\t\\t\\tr+=1\\n\\t\\t\\t\\telse: \\n\\t\\t\\t\\t\\tl+=1\\n\\t\\t\\t\\tif l==r: \\n\\t\\t\\t\\t\\tm=max(m,r+l)\\n\\t\\t\\t\\telif l>r:\\n\\t\\t\\t\\t\\tl=r=0\\n\\t\\t\\treturn m\\n",
                "codeTag": "Java"
            },
            {
                "id": 14258,
                "title": "very-easy-to-understand-5-ms-o-n-solution-without-stack-or-dp",
                "content": "for input example:\\n\\n\"()()))((()(())(()))((())(()()()()()()(((((())))))())()())()(())(())())))))(())()((((((((()()(())))))())())))()(((()())()))(((()()(((((\"\\n\\nI scan the string forward and backward change the string to:\\n\\n()()##((()(())(()))((())(()()()()()()(((((())))))())()())()(())(())())####(())()((((((((()()(())))))())())))()(((()())()))###()()#####\\n\\nthe invalid ( or ) are removed.\\n\\nThen you count the longest valid substring length.\\n\\n\\n    public class Solution {\\n        public int longestValidParentheses(String s) {\\n            char[] c = s.toCharArray();\\n            int len = c.length, t = 0, ans = 0;\\n            for (int i = 0, y = 0; i < len; i++)\\n                if (c[i] == '(')\\n                    y++;\\n                else if (c[i] == ')' && --y < 0) {\\n                    y = 0;\\n                    c[i] = '#';\\n                }\\n                \\n            for (int i = len - 1, y = 0; i >= 0; i--) {\\n                if (c[i] == ')')\\n                    y++;\\n                else if (c[i] == '(' && --y < 0) {\\n                    y = 0;\\n                    c[i] = '#';\\n                }\\n                \\n                t = (c[i] == '#') ? 0 : t + 1;\\n                ans = Math.max(ans, t);\\n            }\\n            System.out.println(new String(c));\\n            \\n            return ans;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int longestValidParentheses(String s) {\\n            char[] c = s.toCharArray();\\n            int len = c.length, t = 0, ans = 0;\\n            for (int i = 0, y = 0; i < len; i++)\\n                if (c[i] == '(')\\n                    y++;\\n                else if (c[i] == ')' && --y < 0) {\\n                    y = 0;\\n                    c[i] = '#';\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 14269,
                "title": "an-intuitive-4ms-solution-a-dp-solution-0ms-and-an-optimized-clean-dp-solution-0ms-in-c",
                "content": "A direct solution is to traverse the string and record the index of '(' until its corresponding ')' in a stack in which process we can get the longest for different sections of valid parentheses and then using a variable max to record the current longest valid parentheses we handled so far; till the end, we return the max - the longest valid parentheses in the string. \\n\\n - Time Cost O(n) \\n - Space Cost O(n)\\n\\n----------\\n    //AC - 4ms;\\n    int longestValidParentheses(char* s)\\n    {\\n        int len = strlen(s);\\n        int *stack = (int*)malloc(sizeof(int)*len);\\n        int top = -1;\\n        stack[++top] = -1;\\n        int max = 0;\\n        for(int i = 0; i < len; i++)\\n        {\\n            int t = stack[top];\\n            if(t!=-1 && s[i]==')' && s[t]=='(')\\n            {\\n                if(i-stack[--top] > max)\\n                    max = i-stack[top];\\n            }\\n            else\\n                stack[++top] = i;\\n        }\\n        return max;\\n    }\\n    \\nUsing DP is quite simpler and easy to understand, here we can use an array maxs[] to store the longest till the current position of the string - the index of maxs[] is the same as that of the string. \\n\\n - When the current character is '(' then maxs[current]=0, quite intuitive; \\n - when the current character is ')' we need to consider the previous state maxs[current-1] and s[current-1]: \\n - at this time if s[current-1]=='(' we need further check the maxs[current-2] to get the longest valid parentheses; \\n - if s[current-1]==')' then we need to check s[i-maxs[current-1]-1] and maxs[i-maxs[current-1]-2] to get the longest for maxs[current].\\n\\nConfused? check an example here: \"()(())\" if we reached the last ')', then the maxs[current-1]=2 and obviously this is not the longest for maxs[current] and to get the longest we need to check the third character which is the last character not covered by maxs[current-1] -- s[current-maxs[current-1]-1] is the character and then the maxs[current-maxs[current-1]-2] which is the first parentheses in this example.\\n\\n - Time Cost O(n)\\n - Space Cost O(n)\\n\\n----------\\n    //AC - 0ms - DP solution;\\n    int longestValidParentheses2(char* s)\\n    {\\n        int len = strlen(s);\\n        if(len < 2) return 0;\\n        int max = 0;\\n        int *maxs = (int*)malloc(sizeof(int)*len); //record the max viable length ending with the current;\\n        memset(maxs, 0, sizeof(int)*len);\\n        for(int i = 1; i < len; i++)\\n        {\\n            if(s[i] == ')')\\n            {\\n                if(s[i-1] == '(')\\n                        maxs[i] = 2+ (i>1? maxs[i-2] : 0);\\n                else if(i-maxs[i-1] > 0 && s[i-maxs[i-1]-1] == '(')\\n                        maxs[i] = maxs[i-1] + (i-maxs[i-1]>1? maxs[i-maxs[i-1]-2]:0) + 2; \\n                if(maxs[i] > max)\\n                    max = maxs[i];\\n            }\\n        }\\n        return max;\\n    }\\n    \\n\\n \\nIn fact, just as we have analyzed in the DP solution, we can merge the two conditions s[current-1]==')' and s[current-1]=='(' altogether when s[current]==')', because if s[current-1]=='(' then maxs[current-1] will be zero which will force the second condition to be the same with the first, so we are just repeating ourselves! Here is the further optimized DP solution removing the redundancy, which is much terse and clean!\\n\\n - Time Cost O(n)\\n - Space Cost O(n)\\n\\n----------\\n\\n    //AC - 0ms;\\n    int longestValidParentheses(char* s)\\n    {\\n        int len = strlen(s);\\n        int max = 0;\\n        int *maxs = (int*)malloc(sizeof(int)*len); //record the max viable length ending with the current;\\n        memset(maxs, 0, sizeof(int)*len);\\n        for(int i = 1; i < len; i++)\\n            if(s[i] == ')')\\n            {\\n                int t = i-maxs[i-1];\\n                if(t>0 && s[t-1] == '(') maxs[i] = maxs[i-1] + (t>1? maxs[t-2]:0) + 2; \\n                if(maxs[i] > max) max = maxs[i];\\n            }\\n        return max;\\n    }",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "A direct solution is to traverse the string and record the index of '(' until its corresponding ')' in a stack in which process we can get the longest for different sections of valid parentheses and then using a variable max to record the current longest valid parentheses we handled so far; till the end, we return the max - the longest valid parentheses in the string. \\n\\n - Time Cost O(n) \\n - Space Cost O(n)\\n\\n----------\\n    //AC - 4ms;\\n    int longestValidParentheses(char* s)\\n    {\\n        int len = strlen(s);\\n        int *stack = (int*)malloc(sizeof(int)*len);\\n        int top = -1;\\n        stack[++top] = -1;\\n        int max = 0;\\n        for(int i = 0; i < len; i++)\\n        {\\n            int t = stack[top];\\n            if(t!=-1 && s[i]==')' && s[t]=='(')\\n            {\\n                if(i-stack[--top] > max)\\n                    max = i-stack[top];\\n            }\\n            else\\n                stack[++top] = i;\\n        }\\n        return max;\\n    }\\n    \\nUsing DP is quite simpler and easy to understand, here we can use an array maxs[] to store the longest till the current position of the string - the index of maxs[] is the same as that of the string. \\n\\n - When the current character is '(' then maxs[current]=0, quite intuitive; \\n - when the current character is ')' we need to consider the previous state maxs[current-1] and s[current-1]: \\n - at this time if s[current-1]=='(' we need further check the maxs[current-2] to get the longest valid parentheses; \\n - if s[current-1]==')' then we need to check s[i-maxs[current-1]-1] and maxs[i-maxs[current-1]-2] to get the longest for maxs[current].\\n\\nConfused? check an example here: \"()(())\" if we reached the last ')', then the maxs[current-1]=2 and obviously this is not the longest for maxs[current] and to get the longest we need to check the third character which is the last character not covered by maxs[current-1] -- s[current-maxs[current-1]-1] is the character and then the maxs[current-maxs[current-1]-2] which is the first parentheses in this example.\\n\\n - Time Cost O(n)\\n - Space Cost O(n)\\n\\n----------\\n    //AC - 0ms - DP solution;\\n    int longestValidParentheses2(char* s)\\n    {\\n        int len = strlen(s);\\n        if(len < 2) return 0;\\n        int max = 0;\\n        int *maxs = (int*)malloc(sizeof(int)*len); //record the max viable length ending with the current;\\n        memset(maxs, 0, sizeof(int)*len);\\n        for(int i = 1; i < len; i++)\\n        {\\n            if(s[i] == ')')\\n            {\\n                if(s[i-1] == '(')\\n                        maxs[i] = 2+ (i>1? maxs[i-2] : 0);\\n                else if(i-maxs[i-1] > 0 && s[i-maxs[i-1]-1] == '(')\\n                        maxs[i] = maxs[i-1] + (i-maxs[i-1]>1? maxs[i-maxs[i-1]-2]:0) + 2; \\n                if(maxs[i] > max)\\n                    max = maxs[i];\\n            }\\n        }\\n        return max;\\n    }\\n    \\n\\n \\nIn fact, just as we have analyzed in the DP solution, we can merge the two conditions s[current-1]==')' and s[current-1]=='(' altogether when s[current]==')', because if s[current-1]=='(' then maxs[current-1] will be zero which will force the second condition to be the same with the first, so we are just repeating ourselves! Here is the further optimized DP solution removing the redundancy, which is much terse and clean!\\n\\n - Time Cost O(n)\\n - Space Cost O(n)\\n\\n----------\\n\\n    //AC - 0ms;\\n    int longestValidParentheses(char* s)\\n    {\\n        int len = strlen(s);\\n        int max = 0;\\n        int *maxs = (int*)malloc(sizeof(int)*len); //record the max viable length ending with the current;\\n        memset(maxs, 0, sizeof(int)*len);\\n        for(int i = 1; i < len; i++)\\n            if(s[i] == ')')\\n            {\\n                int t = i-maxs[i-1];\\n                if(t>0 && s[t-1] == '(') maxs[i] = maxs[i-1] + (t>1? maxs[t-2]:0) + 2; \\n                if(maxs[i] > max) max = maxs[i];\\n            }\\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3538668,
                "title": "two-approaches-using-stack-and-without-space",
                "content": "# Using Stack:\\n```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        stack=[]\\n        stack.append(-1)\\n        ans=0\\n        for i in range(len(s)):\\n            if s[i]==\\'(\\':\\n                stack.append(i)\\n            else:\\n                stack.pop()\\n                if len(stack)==0:\\n                    stack.append(i)\\n                ans=max(ans,i-stack[-1])\\n        return ans\\n```\\n# without Space complexity:\\n```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        open,close,ans=0,0,0\\n        for i in s:\\n            if i==\"(\":\\n                open+=1\\n            else:\\n                close+=1\\n            if close==open:\\n                ans=max(ans,close+open)\\n            elif close>open:\\n                open=close=0\\n        open=close=0\\n        for i in range(len(s)-1,-1,-1):\\n            if \"(\"==s[i]:\\n                open+=1\\n            else:\\n                close+=1\\n            if close==open:\\n                ans=max(ans,close+open)\\n            elif open>close:\\n                open=close=0\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        stack=[]\\n        stack.append(-1)\\n        ans=0\\n        for i in range(len(s)):\\n            if s[i]==\\'(\\':\\n                stack.append(i)\\n            else:\\n                stack.pop()\\n                if len(stack)==0:\\n                    stack.append(i)\\n                ans=max(ans,i-stack[-1])\\n        return ans\\n```\n```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        open,close,ans=0,0,0\\n        for i in s:\\n            if i==\"(\":\\n                open+=1\\n            else:\\n                close+=1\\n            if close==open:\\n                ans=max(ans,close+open)\\n            elif close>open:\\n                open=close=0\\n        open=close=0\\n        for i in range(len(s)-1,-1,-1):\\n            if \"(\"==s[i]:\\n                open+=1\\n            else:\\n                close+=1\\n            if close==open:\\n                ans=max(ans,close+open)\\n            elif open>close:\\n                open=close=0\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3197466,
                "title": "c-c-python-both-dp-and-stack-solution-beats-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n# If you find this helpful,Please Upvote \\n```\\npublic class Solution {\\n    public int LongestValidParentheses(string s) {\\n        Stack<int> index =new Stack<int>();\\n            for(int i=0;i < s.Length;i++){\\n                if (s[i] == \\'(\\'){\\n                    index.Push(i);\\n                }\\n                else{\\n                    if(index.Any() && s[index.Peek()] == \\'(\\'){\\n                        index.Pop();\\n                    }\\n                    else{\\n                        index.Push(i);\\n                    }\\n                }\\n            }\\n            if(!index.Any()){\\n                return s.Length;\\n            }\\n            int length = s.Length, unwanted = 0;\\n            int result = 0;\\n            while(index.Any()){\\n                unwanted = index.Peek();\\n                index.Pop();\\n                result = Math.Max(result,length - unwanted - 1);\\n                length = unwanted;\\n            }\\n            result = Math.Max(result,length);\\n            return result;\\n    }\\n}\\n```\\n# Python Solution  \\n\\n    def ValidParantheses(s):\\n        length=len(s)\\n        dp=[0]*length\\n        count=0\\n        maxLen=0\\n        pos=0\\n        for par in s:\\n            if par == \\'(\\':\\n                count += 1\\n            elif par == \\')\\':\\n                if count>0:\\n                    count-=1\\n                    #immediate parentheses like ()()\\n                    dp[pos]=dp[pos-1]+2\\n                    #outer parentheses (out of nested parentheses or non immmediate valid parentheses)\\n                    if dp[pos] <= pos:\\n                        dp[pos] = dp[pos]+dp[pos-dp[pos]]\\n                \\n            maxLen=max(maxLen,dp[pos])\\n            pos += 1\\n        return maxLen\\n\\n# Upvote \\uD83E\\uDD1E",
                "solutionTags": [
                    "Python",
                    "C#",
                    "String",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\npublic class Solution {\\n    public int LongestValidParentheses(string s) {\\n        Stack<int> index =new Stack<int>();\\n            for(int i=0;i < s.Length;i++){\\n                if (s[i] == \\'(\\'){\\n                    index.Push(i);\\n                }\\n                else{\\n                    if(index.Any() && s[index.Peek()] == \\'(\\'){\\n                        index.Pop();\\n                    }\\n                    else{\\n                        index.Push(i);\\n                    }\\n                }\\n            }\\n            if(!index.Any()){\\n                return s.Length;\\n            }\\n            int length = s.Length, unwanted = 0;\\n            int result = 0;\\n            while(index.Any()){\\n                unwanted = index.Peek();\\n                index.Pop();\\n                result = Math.Max(result,length - unwanted - 1);\\n                length = unwanted;\\n            }\\n            result = Math.Max(result,length);\\n            return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3008088,
                "title": "simplest-shortest-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string str) {\\n        stack<int> s;\\n        s.push(-1);\\n        int ans = 0, n = str.size();\\n        for(int i=0; i<n; i++) {\\n            if(s.top() != -1 && str[s.top()] == \\'(\\' && str[i] == \\')\\') s.pop(), ans = max(ans, i - s.top());\\n            else s.push(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string str) {\\n        stack<int> s;\\n        s.push(-1);\\n        int ans = 0, n = str.size();\\n        for(int i=0; i<n; i++) {\\n            if(s.top() != -1 && str[s.top()] == \\'(\\' && str[i] == \\')\\') s.pop(), ans = max(ans, i - s.top());\\n            else s.push(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2449097,
                "title": "c-easy-and-simplest-code-without-dp",
                "content": "\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint longestValidParentheses(string s) \\n\\t\\t{\\n\\t\\t\\tstack<int>st;\\n\\t\\t\\tst.push(-1);\\n\\t\\t\\tint maxcount=0;\\n\\t\\t\\tfor(int i=0;i<s.length();i++)\\n\\t\\t\\t{\\n\\t\\t\\t   char ch=s[i];\\n\\t\\t\\t\\tif(ch==\\'(\\')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t st.push(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{ \\n\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t\\tif(st.empty())st.push(i);\\n\\t\\t\\t\\t   else\\n\\t\\t\\t\\t   {\\n\\t\\t\\t\\t\\t\\tmaxcount =   max(maxcount,i-st.top());\\n\\t\\t\\t\\t   }\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn maxcount;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint longestValidParentheses(string s) \\n\\t\\t{\\n\\t\\t\\tstack<int>st;\\n\\t\\t\\tst.push(-1);\\n\\t\\t\\tint maxcount=0;\\n\\t\\t\\tfor(int i=0;i<s.length();i++)\\n\\t\\t\\t{\\n\\t\\t\\t   char ch=s[i];\\n\\t\\t\\t\\tif(ch==\\'(\\')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t st.push(i);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2420673,
                "title": "c-solution-little-tricky-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int n=s.length();\\n        vector<int>dp(n+1,0);\\n        stack<int>st;\\n        int ans=0;\\n        int temp=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n                st.push(i);\\n            else\\n            {\\n                if(!st.empty())\\n                {\\n                    int k=st.top();\\n                    st.pop();\\n                    dp[k]=(i-k+1);\\n                }\\n            }\\n        }\\n        int i=0;\\n        while(i<n)\\n        {\\n            if(dp[i]==0)\\n            {\\n                temp=0;\\n                i++;\\n            }\\n            else\\n            {\\n                temp+=dp[i];\\n                i+=dp[i];\\n            }\\n            ans=max(ans,temp);\\n        }\\n        ans=max(ans,temp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int n=s.length();\\n        vector<int>dp(n+1,0);\\n        stack<int>st;\\n        int ans=0;\\n        int temp=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n                st.push(i);\\n            else\\n            {\\n                if(!st.empty())\\n                {\\n                    int k=st.top();\\n                    st.pop();\\n                    dp[k]=(i-k+1);\\n                }\\n            }\\n        }\\n        int i=0;\\n        while(i<n)\\n        {\\n            if(dp[i]==0)\\n            {\\n                temp=0;\\n                i++;\\n            }\\n            else\\n            {\\n                temp+=dp[i];\\n                i+=dp[i];\\n            }\\n            ans=max(ans,temp);\\n        }\\n        ans=max(ans,temp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2070522,
                "title": "left-and-right-traversal-o-n-time-complexity-o-1-space-complexity-easy-0ms",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int left=0,right=0,ansLeft=0,ansRight=0;\\n        \\n        // for left traversal \\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\')\\n                left++;\\n            if(s[i]==\\')\\')\\n                right++;\\n            if(right>left) // if count of closing brackets becomes greater than opening bracket\\n            {\\n                right=0;\\n                left=0;\\n            }\\n            else if(right==left)\\n              ansLeft=max(ansLeft,left+right);\\n        }\\n        left=0;\\n        right=0;\\n        // for right traversal\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(s[i]==\\'(\\')\\n                left++;\\n            if(s[i]==\\')\\')\\n                right++;\\n            if(left>right) // if count of opening brackets becomes greater than closing bracket\\n            {   \\n                left=0;\\n                right=0;\\n                }\\n            else if(left==right)\\n              ansRight=max(ansRight,left+right);\\n        }\\n        return max(ansLeft,ansRight);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int left=0,right=0,ansLeft=0,ansRight=0;\\n        \\n        // for left traversal \\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\')\\n                left++;\\n            if(s[i]==\\')\\')\\n                right++;\\n            if(right>left) // if count of closing brackets becomes greater than opening bracket\\n            {\\n                right=0;\\n                left=0;\\n            }\\n            else if(right==left)\\n              ansLeft=max(ansLeft,left+right);\\n        }\\n        left=0;\\n        right=0;\\n        // for right traversal\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(s[i]==\\'(\\')\\n                left++;\\n            if(s[i]==\\')\\')\\n                right++;\\n            if(left>right) // if count of opening brackets becomes greater than closing bracket\\n            {   \\n                left=0;\\n                right=0;\\n                }\\n            else if(left==right)\\n              ansRight=max(ansRight,left+right);\\n        }\\n        return max(ansLeft,ansRight);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2069564,
                "title": "c-2-approach-easy-and-simple",
                "content": "**Please Upvote If It Helps**\\n\\n**Approach : 1 (Using Two Pointer)**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n       int open=0, close=0;\\n        int maxl = 0;\\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(s[i] == \\'(\\')\\n                open++;\\n            else\\n                close++;\\n            if(close==open)\\n                maxl = max(maxl, 2*close);\\n            else if(close>=open)\\n                open=0, close=0;\\n            \\n        }\\n        \\n        open = 0, close = 0;\\n        for(int i = s.size()-1; i>=0; i--)\\n        {\\n            if(s[i]==\\'(\\')\\n                open++;\\n            else\\n                close++;\\n            if(close==open)\\n                maxl = max(maxl, 2*open);\\n            else if(open>=close)\\n                open = 0, close = 0;\\n        }\\n        return maxl;\\n    }\\n};\\n```\\n\\n\\n\\n**Approach : 2 (Using Stack)**\\n\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> stk;\\n        stk.push(-1);\\n        int maxLength = 0;\\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(s[i] == \\'(\\')\\n            {\\n                stk.push(i);\\n            }\\n            else\\n            {\\n                stk.pop();\\n                \\n                if(stk.empty())\\n                {\\n                    stk.push(i);\\n                }\\n                else\\n                {\\n                    maxLength = max(maxLength, i-stk.top());\\n                }\\n            }\\n        }\\n        return maxLength;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n       int open=0, close=0;\\n        int maxl = 0;\\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(s[i] == \\'(\\')\\n                open++;\\n            else\\n                close++;\\n            if(close==open)\\n                maxl = max(maxl, 2*close);\\n            else if(close>=open)\\n                open=0, close=0;\\n            \\n        }\\n        \\n        open = 0, close = 0;\\n        for(int i = s.size()-1; i>=0; i--)\\n        {\\n            if(s[i]==\\'(\\')\\n                open++;\\n            else\\n                close++;\\n            if(close==open)\\n                maxl = max(maxl, 2*open);\\n            else if(open>=close)\\n                open = 0, close = 0;\\n        }\\n        return maxl;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> stk;\\n        stk.push(-1);\\n        int maxLength = 0;\\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(s[i] == \\'(\\')\\n            {\\n                stk.push(i);\\n            }\\n            else\\n            {\\n                stk.pop();\\n                \\n                if(stk.empty())\\n                {\\n                    stk.push(i);\\n                }\\n                else\\n                {\\n                    maxLength = max(maxLength, i-stk.top());\\n                }\\n            }\\n        }\\n        return maxLength;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1141234,
                "title": "javascript-o-1-space-o-n-time-intuitive-solution",
                "content": "Time: `O(N)`\\nSpace: `O(1)`\\n```javascript\\nvar longestValidParentheses = function(s) {\\n    let open = 0, close = 0, maxLen = 0;\\n\\n    for(let c of s) {\\n        if(c === \\'(\\') open++;\\n        else close++;\\n        if(open === close) maxLen = Math.max(maxLen, close*2);\\n        else if(close > open) open = close = 0;\\n    }\\n\\n    open = close = 0;\\n    \\n    for(let i = s.length-1; i >= 0; i--) {\\n        if(s[i] === \\')\\') close++;\\n        else open++;\\n        if(open === close) maxLen = Math.max(maxLen, open*2);\\n        else if(open > close) open = close = 0;\\n    }\\n    return maxLen;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar longestValidParentheses = function(s) {\\n    let open = 0, close = 0, maxLen = 0;\\n\\n    for(let c of s) {\\n        if(c === \\'(\\') open++;\\n        else close++;\\n        if(open === close) maxLen = Math.max(maxLen, close*2);\\n        else if(close > open) open = close = 0;\\n    }\\n\\n    open = close = 0;\\n    \\n    for(let i = s.length-1; i >= 0; i--) {\\n        if(s[i] === \\')\\') close++;\\n        else open++;\\n        if(open === close) maxLen = Math.max(maxLen, open*2);\\n        else if(open > close) open = close = 0;\\n    }\\n    return maxLen;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 833908,
                "title": "simple-easy-java-solution-o-n-with-comments",
                "content": "```\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n        // create an array to mark valid parenthesis.\\n        int[] arr = new int[s.length()];\\n        \\n        // use a stack to store location of opening brackets.\\n        Stack<Integer> stack = new Stack<>();\\n        for(int k=0; k<s.length(); k++) {\\n            // if opening bracket is found, push its location onto the stack.\\n            if (s.charAt(k) == \\'(\\') {\\n                stack.add(k);\\n            }\\n            // if closing bracket is found and stack is not empty, that means the \\n            // the current closing bracket is a pair of the opening bracket at location\\n            // available at stack.peek().\\n            // mark both location as valid in the array.\\n            else if (s.charAt(k) == \\')\\') {\\n                if (!stack.isEmpty()) {\\n                    int top = stack.pop();\\n                    arr[top] = 1;\\n                    arr[k] = 1;\\n                }\\n            }\\n        }\\n        // find maximum of continuous valid locations in the array.\\n        int max = 0;\\n        int curr = 0;\\n        for(int k=0; k<arr.length; k++) {\\n            if(arr[k] == 1) {\\n                curr++;\\n            }\\n            else {\\n                max = Math.max(curr, max);\\n                curr = 0;\\n            }\\n        }\\n        return Math.max(curr, max);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n    public int longestValidParentheses(String s) {\\n        // create an array to mark valid parenthesis.\\n        int[] arr = new int[s.length()];\\n        \\n        // use a stack to store location of opening brackets.\\n        Stack<Integer> stack = new Stack<>();\\n        for(int k=0; k<s.length(); k++) {\\n            // if opening bracket is found, push its location onto the stack.\\n            if (s.charAt(k) == \\'(\\') {\\n                stack.add(k);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4043194,
                "title": "easy-to-understand-dp-solution-o-n-5-lines",
                "content": "# Intuition\\nThe problem asks for the length of the longest valid parentheses substring in a given string. To solve this problem, we can use dynamic programming. The idea is to maintain a dynamic programming array `dp`, where `dp[i]` represents the length of the longest valid parentheses substring ending at index `i` of the input string. We can initialize `dp` with zeros and then iterate through the string to update `dp` as we find valid parentheses substrings.\\n\\n# Approach\\n1. Initialize a dynamic programming array `dp` of size `s.size() + 1` and initialize all elements to 0.\\n2. Initialize a variable `ans` to 0, which will store the maximum length of valid parentheses substring found so far.\\n3. Iterate through the characters of the input string `s` from left to right, starting from the second character (index 1).\\n   - If the current character is \\')\\':\\n     - Check if there is a valid opening parenthesis \\'(\\' that can be matched with the current closing parenthesis \\')\\'.\\n     - To do this, check if the character before the current closing parenthesis (at index `i`) is an opening parenthesis \\'(\\', and if the character just before the opening parenthesis (at index `i - dp[i] - 1`) is also an opening parenthesis \\'(\\'.\\n     - If the conditions are met, update `dp[i + 1]` as follows:\\n       - `dp[i + 1] = dp[i] + 2 + dp[i - dp[i] - 1]`\\n       - Here, `dp[i]` represents the length of valid parentheses substring ending at the previous character, and `dp[i - dp[i] - 1]` represents the length of valid parentheses substring just before the opening parenthesis that matches with the current closing parenthesis.\\n   - Update `ans` with the maximum value between the current `ans` and `dp[i + 1]`.\\n4. After iterating through the entire string, `ans` will contain the length of the longest valid parentheses substring in the input string.\\n5. Return `ans` as the result.\\n\\n# Complexity\\n- Time complexity: O(n), where n is the length of the input string `s`. We iterate through the string once, and for each character, we perform constant time operations.\\n- Space complexity: O(n), as we use a dynamic programming array `dp` of the same length as the input string.\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        vector<int> dp(s.size() + 1, 0);\\n        int ans = 0;\\n        for (int i = 1; i < s.size(); i++) {\\n            if (s[i] == \\')\\' && (i - dp[i] - 1) >= 0 && s[i - dp[i] - 1] == \\'(\\')\\n                dp[i + 1] = dp[i] + 2 + dp[i - dp[i] - 1];\\n            ans = max(ans, dp[i + 1]);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        vector<int> dp(s.size() + 1, 0);\\n        int ans = 0;\\n        for (int i = 1; i < s.size(); i++) {\\n            if (s[i] == \\')\\' && (i - dp[i] - 1) >= 0 && s[i - dp[i] - 1] == \\'(\\')\\n                dp[i + 1] = dp[i] + 2 + dp[i - dp[i] - 1];\\n            ans = max(ans, dp[i + 1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3926422,
                "title": "commented-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> stk;     // Create a stack to keep track of indices\\n        stk.push(-1);       // Initialize the stack with -1 as a base index\\n        int ans = 0;        // Initialize the answer variable to store the maximum length\\n\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] == \\'(\\')\\n                stk.push(i);  // Push the index of an opening parenthesis onto the stack\\n            else {\\n                if(stk.size() == 1)\\n                    stk.top() = i;  // If stack contains only the base index, update it to the current index\\n                else {\\n                    stk.pop();       // Pop the top index from the stack\\n                    ans = max(ans, i - stk.top());  // Calculate the current valid length and update the answer\\n                }\\n            }\\n        }\\n        return ans;   // Return the maximum valid length\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> stk;     // Create a stack to keep track of indices\\n        stk.push(-1);       // Initialize the stack with -1 as a base index\\n        int ans = 0;        // Initialize the answer variable to store the maximum length\\n\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] == \\'(\\')\\n                stk.push(i);  // Push the index of an opening parenthesis onto the stack\\n            else {\\n                if(stk.size() == 1)\\n                    stk.top() = i;  // If stack contains only the base index, update it to the current index\\n                else {\\n                    stk.pop();       // Pop the top index from the stack\\n                    ans = max(ans, i - stk.top());  // Calculate the current valid length and update the answer\\n                }\\n            }\\n        }\\n        return ans;   // Return the maximum valid length\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768052,
                "title": "beats-100-easy-with-proper-commented-explanation-c",
                "content": "# Please Upvote!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The stack will store indices of the characters in the string. For every \\')\\' encountered, we check if the stack is not empty and the character at the top of the stack is \\'(\\', if so, it means that a pair of well-formed parentheses is formed.\\n\\n- The length of the longest valid parentheses can be updated by the current index minus the index at the new top of the stack (if the stack is not empty). If the stack is empty, we just push the current index into the stack.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> st;\\n        st.push(-1); // push -1 as initial index to start from\\n        int maxLength = 0;\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            // if current character is \\'(\\', push its index\\n            if(s[i] == \\'(\\') {\\n                st.push(i);\\n            }\\n            else { \\n                // if current character is \\')\\', pop the top\\n                if(!st.empty())\\n                    st.pop();\\n                // if stack is not empty, update the maxLength \\n                // by the difference of current index and index at the top of the stack\\n                if(!st.empty()) {\\n                    maxLength = max(maxLength, i - st.top());\\n                }\\n                else {\\n                    // if stack is empty, push the current index\\n                    st.push(i);\\n                }\\n            }\\n        }\\n        \\n        return maxLength;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> st;\\n        st.push(-1); // push -1 as initial index to start from\\n        int maxLength = 0;\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            // if current character is \\'(\\', push its index\\n            if(s[i] == \\'(\\') {\\n                st.push(i);\\n            }\\n            else { \\n                // if current character is \\')\\', pop the top\\n                if(!st.empty())\\n                    st.pop();\\n                // if stack is not empty, update the maxLength \\n                // by the difference of current index and index at the top of the stack\\n                if(!st.empty()) {\\n                    maxLength = max(maxLength, i - st.top());\\n                }\\n                else {\\n                    // if stack is empty, push the current index\\n                    st.push(i);\\n                }\\n            }\\n        }\\n        \\n        return maxLength;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610328,
                "title": "stack-based-approach-using-single-loop-java",
                "content": "# Intuition\\nUsed an Stack to find the longest valid parenthesis\\n\\n# Approach\\nStack based approach using single while loop.\\n\\n# Complexity\\n- Time complexity:\\nTime complexity is O(n);\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n    Stack<Integer> st=new Stack<>();\\n    int ans=0;\\n    st.push(-1);\\n    for(int i=0;i<s.length();i++){\\n        if(s.charAt(i)==\\'(\\')\\n            st.push(i);\\n        else{\\n            if(!st.isEmpty())\\n            st.pop();\\n            if(!st.isEmpty())\\n            ans=Math.max(i-st.peek(),ans);\\n            else\\n            st.push(i);\\n        }\\n    }\\n    return ans;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n    Stack<Integer> st=new Stack<>();\\n    int ans=0;\\n    st.push(-1);\\n    for(int i=0;i<s.length();i++){\\n        if(s.charAt(i)==\\'(\\')\\n            st.push(i);\\n        else{\\n            if(!st.isEmpty())\\n            st.pop();\\n            if(!st.isEmpty())\\n            ans=Math.max(i-st.peek(),ans);\\n            else\\n            st.push(i);\\n        }\\n    }\\n    return ans;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350181,
                "title": "100-faster-with-comments-c-stack-short-sweet-easy-to-understand",
                "content": "````\\n//IN THIS PROBLEM I FIND LONGEST LONGEST VALID PRENTHESIS SUBSTRING\\nclass Solution\\n{\\npublic:\\n    int longestValidParentheses(string s)\\n    {\\n        vector<int> v;\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            if (s[i] == \\'(\\')\\n            {\\n                v.push_back(i);\\n            }\\n            else\\n            {\\n                if (v.size() > 0 && s[v.back()] == \\'(\\')\\n                {\\n                    v.pop_back();\\n                }\\n                else\\n                {\\n                    v.push_back(i);\\n                }\\n            }\\n        }\\n        if (v.size() == 0)//ARRAY WE STORE INDICES WHERE OUR SUBSTRINGS WILL BE INCOREECT & EXTRA OPENING BRACKET\\'S INDICES\\n            return s.length();\\n        int ans = 0, a = 0, b = s.length();\\n        while (v.size() > 0)\\n        {\\n            a = v.back();\\n            v.pop_back();\\n            ans = max(ans, b - a - 1);\\n            b = a;\\n        }\\n        ans = max(ans,b);\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Stack"
                ],
                "code": "````\\n//IN THIS PROBLEM I FIND LONGEST LONGEST VALID PRENTHESIS SUBSTRING\\nclass Solution\\n{\\npublic:\\n    int longestValidParentheses(string s)\\n    {\\n        vector<int> v;\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            if (s[i] == \\'(\\')\\n            {\\n                v.push_back(i);\\n            }\\n            else\\n            {\\n                if (v.size() > 0 && s[v.back()] == \\'(\\')\\n                {\\n                    v.pop_back();\\n                }\\n                else\\n                {\\n                    v.push_back(i);\\n                }\\n            }\\n        }\\n        if (v.size() == 0)//ARRAY WE STORE INDICES WHERE OUR SUBSTRINGS WILL BE INCOREECT & EXTRA OPENING BRACKET\\'S INDICES\\n            return s.length();\\n        int ans = 0, a = 0, b = s.length();\\n        while (v.size() > 0)\\n        {\\n            a = v.back();\\n            v.pop_back();\\n            ans = max(ans, b - a - 1);\\n            b = a;\\n        }\\n        ans = max(ans,b);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2881527,
                "title": "c-o-n-easy-to-understand-with-in-depth-explanation-and-examples",
                "content": "#### Table of Contents\\n\\n- [TL;DR](#tldr)\\n  - [Code](#code)\\n  - [Complexity](#complexity)\\n- [In Depth Analysis](#in-depth-analysis)\\n  - [Intuition](#intuition)\\n  - [Approach](#approach)\\n  - [Example](#example)\\n\\n# TL;DR\\n\\nAll we want to do is scan the string from start to finish and use a stack to figure out if the index we are still looking at is a valid parenthesis\\n\\nIn other words, we want to push the indices of the opening brackets and if you encounter a closing bracket, then we calculate how long was this valid parenthesis (assuming that the stack is not empty) and update the ans if it is longer than the current best\\n\\n## Code\\n\\n```c++\\n#define OPEN_BRACKET \\'(\\'\\n\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        const int n = s.size();\\n        int ans = 0;\\n        stack<int> brackets;\\n        brackets.push(-1);\\n        for (int i = 0; i < n; i++) {\\n            if (s[i] == OPEN_BRACKET)\\n                brackets.push(i);\\n            else {\\n                brackets.pop();\\n                if (brackets.empty())\\n                    brackets.push(i);\\n                else\\n                    ans = max(ans, i - brackets.top());\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n## Complexity\\n\\n**Time Complexity:** $$O(N)$$\\n**Space Complexity:** $$O(N)$$\\n\\n**PLEASE UPVOTE IF YOU FIND MY POST HELPFUL!! \\uD83E\\uDD7A\\uD83D\\uDE01**\\n\\n---\\n\\n# In Depth Analysis\\n\\n## Intuition\\n\\nThis is a modified version of the valid parenthesis problem\\n\\nWe initially push `-1` onto the stack because it is to indicate the last location of a valid parenthesis. At first, the last valid parenthesis finished at index `-1`. Then, every time we encounter an opening bracket, we want to push that onto the stack too. \\n\\nIf it isn\\'t an opening bracket (aka closing bracket), we want to pop off the stack. If the stack is not empty, that means we have encountered a valid parenthesis and the stack\\'s current top is the position before the start of the valid string. Therefore, taking the difference between the current index and the stack\\'s top will yield the length of the valid string and we update the answer if it is longer than the current best.\\n\\nIf the stack is empty, that means that we have no idea where the next valid parenthesis set is (since we always compare it to the stack\\'s top element). Therefore, we just push the current index onto the stack to indicate the location of the last valid parenthesis.\\n\\n## Approach \\n\\nWe initialize push `-1` onto a stack and we iterate through all the characters in `s`. If the current character is a open bracket, push the index onto the stack. Otherwise, we pop off of the top. If the stack then becomes empty, we push the current index onto the stack. Otherwise, we update the answer to be the difference between the current index and the current stack top\\'s value\\n\\n## Example\\n\\nLets use the second example, where `s = \")()())\"`\\n\\nFirst, we push `-1` onto the stack since that the last valid location so far\\n\\n* i = 0\\nStack = [-1] <-- TOP\\nAns = 0\\n\\n`s[0] = \\')\\'`, so we pop off of the stack. Since it is empty now, we push `i = 0` onto the stack\\n\\n* i = 1\\nStack = [0] <-- TOP\\nAns = 0\\n\\n`s[1] = \\'(\\'`, so we push `i = 1` onto the stack\\n\\n* i = 2\\nStack = [0,1] <-- TOP\\nAns = 0\\n\\n`s[2] = \\')\\'`, so we pop off of the stack (`1`). Then, we update ans to be the max between itself and `i - stack.top() = 2 - 0 = 2`\\n\\n* i = 3\\nStack = [0] <-- TOP\\nAns = 2\\n\\n`s[3] = \\'(\\'`, so push `i = 3` onto the stack\\n\\n* i = 4\\nStack = [0,3] <-- TOP\\nAns = 2\\n\\n`s[4] = \\')\\'`, so we pop off of the stack (`3`). Then, we update ans to be the max between itself and `i - stack.top() = 4 - 0 = 4`\\n\\n* i = 5\\nStack = [0] <-- TOP\\nAns = 4\\n\\n`s[5] = \\')\\'`, so we pop off of the stack (`0`). Since the stack is empty now, then we push `i = 5` onto the stack\\n\\n* Aftermath\\n\\nWe return 4, which is the correct answer\\n\\n**PLEASE UPVOTE IF YOU FIND MY POST HELPFUL!! \\uD83E\\uDD7A\\uD83D\\uDE01**",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```c++\\n#define OPEN_BRACKET \\'(\\'\\n\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        const int n = s.size();\\n        int ans = 0;\\n        stack<int> brackets;\\n        brackets.push(-1);\\n        for (int i = 0; i < n; i++) {\\n            if (s[i] == OPEN_BRACKET)\\n                brackets.push(i);\\n            else {\\n                brackets.pop();\\n                if (brackets.empty())\\n                    brackets.push(i);\\n                else\\n                    ans = max(ans, i - brackets.top());\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832087,
                "title": "o-n-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> st;\\n        int n=s.size();\\n        for(int i=0;i<n;i++){\\n            if(st.empty()) st.push(i);\\n            else{\\n                if(s[i]==\\'(\\') st.push(i);\\n                else{\\n                    if(s[st.top()]==\\'(\\') st.pop();\\n                    else st.push(i);\\n                }\\n            }\\n        }\\n        int ans;\\n        if(!st.empty())\\n         ans=n-1 - st.top();\\n        else ans=n;\\n        while(!st.empty()){\\n            int a=st.top();\\n            st.pop();\\n            if(!st.empty())\\n            ans=max(ans,a-st.top() -1);\\n            else ans=max(ans,a-0);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> st;\\n        int n=s.size();\\n        for(int i=0;i<n;i++){\\n            if(st.empty()) st.push(i);\\n            else{\\n                if(s[i]==\\'(\\') st.push(i);\\n                else{\\n                    if(s[st.top()]==\\'(\\') st.pop();\\n                    else st.push(i);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2675471,
                "title": "simple-c-solution-100-faster",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int open=0, close=0;\\n        int maxLen=0;\\n\\t\\t\\n\\t\\t//traversing from left\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\'){\\n                open++;\\n            }\\n            else{\\n                close++;\\n            }\\n\\t\\t\\t//valid pair of paranthesis if number of opening and closing brackets are equal\\n            if(open==close){   \\n                int len=open+close;\\n                maxLen=max(maxLen,len);\\n            }\\n\\t\\t\\telse if(close>open){      //from left if closing brackets is greater than openin brackets\\n                close=0;\\n                open=0;\\n            }\\n        }\\n        \\n        open=0,close=0;\\n        \\n\\t\\t//traversing from right\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(s[i]==\\'(\\'){\\n                open++;\\n            }\\n            else{\\n                close++;\\n            }\\n\\t\\t\\t//valid pair of paranthesis if number of opening and closing brackets are equal\\n            if(open==close){\\n                int len=open+close;\\n                maxLen=max(maxLen,len);\\n            }\\n            else if(close<open){     //from right if opening brackets is greater than closing brackets\\n                close=0;\\n                open=0;\\n            }            \\n        }\\n        return maxLen;\\n    }\\n};\\n//please upvote if found helpful\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int open=0, close=0;\\n        int maxLen=0;\\n\\t\\t\\n\\t\\t//traversing from left\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\'){\\n                open++;\\n            }\\n            else{\\n                close++;\\n            }\\n\\t\\t\\t//valid pair of paranthesis if number of opening and closing brackets are equal\\n            if(open==close){   \\n                int len=open+close;\\n                maxLen=max(maxLen,len);\\n            }\\n\\t\\t\\telse if(close>open){      //from left if closing brackets is greater than openin brackets\\n                close=0;\\n                open=0;\\n            }\\n        }\\n        \\n        open=0,close=0;\\n        \\n\\t\\t//traversing from right\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(s[i]==\\'(\\'){\\n                open++;\\n            }\\n            else{\\n                close++;\\n            }\\n\\t\\t\\t//valid pair of paranthesis if number of opening and closing brackets are equal\\n            if(open==close){\\n                int len=open+close;\\n                maxLen=max(maxLen,len);\\n            }\\n            else if(close<open){     //from right if opening brackets is greater than closing brackets\\n                close=0;\\n                open=0;\\n            }            \\n        }\\n        return maxLen;\\n    }\\n};\\n//please upvote if found helpful\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2339817,
                "title": "java-0-ms-simple-explanation-with-tc-sc-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n        Stack<Integer> st = new Stack<Integer>();\\n        \\n        //We push -1 so that if the whole str is ans then we will get ans by \\'i - st.peek()\\' e.g: \\'(())\\' = 3 - (-1) = 3 + 1 = 4\\n        st.push(-1);\\n        int result = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            \\n            //If it\\'s an opening bracket then push in the stack\\n            if(s.charAt(i) == \\'(\\') {\\n                st.push(i);\\n            } else {\\n                \\n                st.pop();\\n                if(st.isEmpty()) {\\n                    //If the stack is empty, push the current index as a base for the next valid substring.\\n                   st.push(i); \\n                } else {\\n                    //If the stack is not empty, then find the length of current valid substring by taking the difference between the current index and top of the stack.\\n                    result = Math.max(result, i - st.peek());\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n//Time Complexity : O(n) where n is the length of string\\n//Space Complexity : O(n) due to stack\\n//Please upvote the solution if you like it.\\n```\\nAlso check out my GitHub repository (https://github.com/Ovaishk/DSA-Problems-for-Placement) for solution to other important DSA Problems !!!",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n        Stack<Integer> st = new Stack<Integer>();\\n        \\n        //We push -1 so that if the whole str is ans then we will get ans by \\'i - st.peek()\\' e.g: \\'(())\\' = 3 - (-1) = 3 + 1 = 4\\n        st.push(-1);\\n        int result = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            \\n            //If it\\'s an opening bracket then push in the stack\\n            if(s.charAt(i) == \\'(\\') {\\n                st.push(i);\\n            } else {\\n                \\n                st.pop();\\n                if(st.isEmpty()) {\\n                    //If the stack is empty, push the current index as a base for the next valid substring.\\n                   st.push(i); \\n                } else {\\n                    //If the stack is not empty, then find the length of current valid substring by taking the difference between the current index and top of the stack.\\n                    result = Math.max(result, i - st.peek());\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n//Time Complexity : O(n) where n is the length of string\\n//Space Complexity : O(n) due to stack\\n//Please upvote the solution if you like it.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2070202,
                "title": "js-ts-dynamic-programming-solution-explained",
                "content": "<h2>Dynamic programming with tabulation.</h2>\\n\\n1. <a href=\"#algo\">Algorithm</a>\\n2. <a href=\"#javascript-solution\">JavaScript solution</a>\\n3. <a href=\"#typescript-solution\">TypeScript solution</a>\\n\\n<h3>Intro</h3>\\n\\nLet\\'s say we have a string: \\' ( ) ( ( ) ( ) ) \\'.\\nThe resulting array we got using this approach looks like this (**only the last row** actually):\\n\\n<table>\\n\\t<tr>\\n\\t\\t<td><b>i</b></td>\\n\\t\\t<td>0</td>\\n\\t\\t<td>1</td>\\n\\t\\t<td>2</td>\\n\\t\\t<td>3</td>\\n\\t\\t<td>4</td>\\n\\t\\t<td>5</td>\\n\\t\\t<td>6</td>\\n\\t\\t<td>7</td>\\n\\t\\t<td> - an index</td>\\n\\t</tr>\\n\\t<tr>\\n\\t\\t<td><b>s</b></td>\\n\\t\\t<td>(</td>\\n\\t\\t<td>)</td>\\n\\t\\t<td>(</td>\\n\\t\\t<td>(</td>\\n\\t\\t<td>)</td>\\n\\t\\t<td>(</td>\\n\\t\\t<td>)</td>\\n\\t\\t<td>)</td>\\n\\t\\t<td> - a given string</td>\\n\\t</tr>\\n\\t<tr>\\n\\t\\t<td><b>dp</b></td>\\n\\t\\t<td>0</td>\\n\\t\\t<td>2</td>\\n\\t\\t<td>0</td>\\n\\t\\t<td>0</td>\\n\\t\\t<td>2</td>\\n\\t\\t<td>0</td>\\n\\t\\t<td>4</td>\\n\\t\\t<td>8</td>\\n\\t\\t<td> - a dynamic programming tabulation</td>\\n\\t</tr>\\n</table>\\n\\nThe numbers in **dp** indicate the length of the valid parentheses substring ending at the corresponding index.\\nThe largest number of the **dp** will indicate *the length of the longest parentheses substring*.\\n\\n<h3 id=\"algo\">Algorithm</h3>\\n\\n1. Initialise the **dp** array with zeros. The length of the array equals to the length of the string (e.g. length = 8).\\n\\n<table>\\n\\t<tr>\\n\\t\\t<td><b>dp</b></td>\\n\\t\\t<td>0</td>\\n\\t\\t<td>0</td>\\n\\t\\t<td>0</td>\\n\\t\\t<td>0</td>\\n\\t\\t<td>0</td>\\n\\t\\t<td>0</td>\\n\\t\\t<td>0</td>\\n\\t\\t<td>0</td>\\n\\t</tr>\\n</table>\\n\\n2. We will be checking two adjacent charachters of  the given string (**s[ i - 1 ]** and **s[ i ]**, for i = 1, 2, ... , length-1).\\n<table>\\n\\t<tr>\\n\\t\\t<td><b>i</b></td>\\n\\t\\t<td><b>[ 0 ]</b></td>\\n\\t\\t<td><b>[ 1 ]</b></td>\\n\\t\\t<td>2</td>\\n\\t\\t<td>...</td>\\n\\t\\t<td rowspan=\"2\"> => </td>\\n\\t\\t<td><b>i</b></td>\\n\\t\\t<td>0</td>\\n\\t\\t<td><b>[ 1 ]</b></td>\\n\\t\\t<td><b>[ 2 ]</b></td>\\n\\t\\t<td>...</td>\\n\\t\\t<td rowspan=\"2\"> => </td>\\n\\t\\t<td><b>i</b></td>\\n\\t\\t<td>...</td>\\n\\t\\t<td><b>[ 2 ]</b></td>\\n\\t\\t<td><b>[ 3 ]</b></td>\\n\\t\\t<td>...</td>\\n\\t</tr>\\n\\t<tr>\\n\\t\\t<td><b>s</b></td>\\n\\t\\t<td><b>[ ( ]</b></td>\\n\\t\\t<td><b>[ ) ]</b></td>\\n\\t\\t<td>(</td>\\n\\t\\t<td>...</td>\\n\\t\\t<td><b>s</b></td>\\n\\t\\t<td>(</td>\\n\\t\\t<td><b>[ ) ]</b></td>\\n\\t\\t<td><b>[ ( ]</b></td>\\n\\t\\t<td>...</td>\\n\\t\\t<td><b>s</b></td>\\n\\t\\t<td>...</td>\\n\\t\\t<td><b>[ ( ]</b></td>\\n\\t\\t<td><b>[ ( ]</b></td>\\n\\t\\t<td>...</td>\\n\\t</tr>\\n</table>\\n\\n* We will take into consideration only **two conditions**:\\n\\t*a.*  s[ i - 1 ] == \\' **(** \\' && s[ i ] == \\' **)** \\';\\n\\t*b.* s[ i - 1 ] == \\' **)** \\' && s[ i ] == \\' **)** \\'.\\n\\n3. *Condition a.* means that we have found a valid substring \\' **( )** \\' of parentheses of length 2. So we can put the length = 2 of that substring in the **dp** at index i: **dp[ i ] = 2**\\n\\n<table>\\n\\t<tr>\\n\\t\\t<td><b>i</b></td>\\n\\t\\t<td><b>0</b></td>\\n\\t\\t<td><b>1</b></td>\\n\\t</tr>\\n\\t<tr>\\n\\t\\t<td><b>s</b></td>\\n\\t\\t<td><b>(</b></td>\\n\\t\\t<td><b>)</b></td>\\n\\t</tr>\\n\\t<tr>\\n\\t\\t<td><b>dp</b></td>\\n\\t\\t<td>0</td>\\n\\t\\t<td>2</td>\\n\\t</tr>\\n</table>\\n\\n* But it could be a subsequent valid substring (e.g. **i = 5 to 6** - this valid substing is a part of the bigger valid substring **i = 3 to 6**). So we also have to check the value in **dp[ i - 2 ]**, and the resulting equation for *condition a.* will be **dp[ i ] = 2 + dp[ i - 2]**.\\n\\nFor **i = 4** and next **i = 6** (i = 5 does not fall under *condition a.*)\\n<table>\\n\\t<tr>\\n\\t\\t<td><b>i</b></td>\\n\\t\\t<td>...</td>\\n\\t\\t<td>2</td>\\n\\t\\t<td><b>3</b></td>\\n\\t\\t<td><b>4</b></td>\\n\\t\\t<td rowspan=\"3\"> => </td>\\n\\t\\t<td><b>i</b></td>\\n\\t\\t<td>...</td>\\n\\t\\t<td>4</td>\\n\\t\\t<td><b>5</b></td>\\n\\t\\t<td><b>6</b></td>\\n\\t</tr>\\n\\t<tr>\\n\\t\\t<td><b>s</b></td>\\n\\t\\t<td>...</td>\\n\\t\\t<td>(</td>\\n\\t\\t<td><b>(</b></td>\\n\\t\\t<td><b>)</b></td>\\n\\t\\t<td><b>s</b></td>\\n\\t\\t<td>...</td>\\n\\t\\t<td>)</td>\\n\\t\\t<td><b>(</b></td>\\n\\t\\t<td><b>)</b></td>\\n\\t</tr>\\n\\t<tr>\\n\\t\\t<td><b>dp</b></td>\\n\\t\\t<td>...</td>\\n\\t\\t<td><b>[ 0 ]</b></td>\\n\\t\\t<td>0</td>\\n\\t\\t<td>0 + 2 = 2</td>\\n\\t\\t<td><b>dp</b></td>\\n\\t\\t<td>...</td>\\n\\t\\t<td><b>[ 2 ]</b></td>\\n\\t\\t<td>0</td>\\n\\t\\t<td>2 + 2 = 4</td>\\n\\t</tr>\\n</table>\\n\\n4. *Condition b.* s[ i - 1 ] == \\' **)** \\' && s[ i ] == \\' **)** \\' means that **s[ i ]** could be a closing parentheses of the pattern \\' **(** ( ... ) **)** \\'.\\nIn this case we already checked **s[ i - 1 ]** at the previous step and it could be a part of the previous valid or invalid substring, let\\'s call it **sub<sub>i-1</sub>**. Also we have already put some value in **dp[ i - 1 ]**. Thus, only **s[ i ]** needs further investigation.\\n* We have to check if the character before **sub<sub>i-1</sub>** equals \\' **(** \\'. To do that we subtract the value of **dp[ i - 1 ]** (the length of **sub<sub>i-1</sub>**) plus 1, from **i** to get the resulting equation **s[ i - (dp[ i - 1 ] + 1) ]**.\\n* In this example, for **i = 7** we have to check the character at **i = 2**: s[ 7 - (4 + 1) ] => s[ 2 ] == \\' **(** \\', if ```true``` we will put in **dp[ i ] = 2 + dp [ i - 1] + dp[ i - (dp[ i - 1] + 2) ]**. The last term dp[ i - (dp[ i - 1] + 2) ] appears because we also have to check if there a valid substring just before the considering substring.\\nThat is why in the considering example we get **8** at **dp[ 7 ]**: **2** (when we found the opening parentheses at i = 2) + **4** (the length of the **sub<sub>i-1</sub>** as it is valid) + **2** (the substring at i = 1 is also valid) = **8**.\\n\\n<h3 id=\"javascript-solution\">JavaScript</h3>\\n\\n```\\nfunction longestValidParentheses(s) {\\n\\t// maxLength variable is used to monitor the maximum length of the valid substring\\n\\t// every time we fall in condition a. or b.\\n\\t// by using it we don\\'t need to find the maximum value in the resulting dp array\\n    let maxLength = 0;\\n    let dp = new Array(s.length).fill(0);\\n    \\n    for (let i = 1; i < s.length; i++) {\\n        if (s[i - 1] === \\'(\\' && s[i] === \\')\\') { // - condition a.\\n            dp[i] = 2 + (dp[i - 2] || 0); // - dp[i-2] can return undefined, if so we will add zero instead\\n            maxLength = Math.max(maxLength, dp[i]);\\n        }\\n        if (\\n            s[i - 1] === \\')\\' &&\\n            s[i] === \\')\\' &&\\n            s[i - dp[i - 1] - 1] === \\'(\\' // - condition b.\\n        ) {\\n            dp[i] = 2 + dp[i - 1] + (dp[i - dp[i - 1] - 2] || 0);\\n            maxLength = Math.max(maxLength, dp[i]);\\n        }\\n    }\\n    return maxLength;\\n};\\n```\\n\\n<h3 id=\"typescript-solution\">TypeScript</h3>\\n\\n```\\nfunction longestValidParentheses(s: string): number {\\n\\t// maxLength variable is used to monitor the maximum length of the valid substring\\n\\t// every time we fall in condition a. or b.\\n\\t// by using it we don\\'t need to find the maximum value in the resulting dp array\\n    let maxLength: number = 0;\\n    let dp: number[] = new Array(s.length).fill(0);\\n    \\n    for (let i = 1; i < s.length; i++) {\\n        if (s[i - 1] === \\'(\\' && s[i] === \\')\\') { // - condition a.\\n            dp[i] = 2 + (dp[i - 2] || 0); // - dp[i-2] can return undefined, if so we will add zero instead\\n            maxLength = Math.max(maxLength, dp[i]);\\n        }\\n        if (\\n            s[i - 1] === \\')\\' &&\\n            s[i] === \\')\\' &&\\n            s[i - dp[i - 1] - 1] === \\'(\\' // - condition b.\\n        ) {\\n            dp[i] = 2 + dp[i - 1] + (dp[i - dp[i - 1] - 2] || 0);\\n            maxLength = Math.max(maxLength, dp[i]);\\n        }\\n    }\\n    return maxLength;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Dynamic Programming"
                ],
                "code": "```true```\n```\\nfunction longestValidParentheses(s) {\\n\\t// maxLength variable is used to monitor the maximum length of the valid substring\\n\\t// every time we fall in condition a. or b.\\n\\t// by using it we don\\'t need to find the maximum value in the resulting dp array\\n    let maxLength = 0;\\n    let dp = new Array(s.length).fill(0);\\n    \\n    for (let i = 1; i < s.length; i++) {\\n        if (s[i - 1] === \\'(\\' && s[i] === \\')\\') { // - condition a.\\n            dp[i] = 2 + (dp[i - 2] || 0); // - dp[i-2] can return undefined, if so we will add zero instead\\n            maxLength = Math.max(maxLength, dp[i]);\\n        }\\n        if (\\n            s[i - 1] === \\')\\' &&\\n            s[i] === \\')\\' &&\\n            s[i - dp[i - 1] - 1] === \\'(\\' // - condition b.\\n        ) {\\n            dp[i] = 2 + dp[i - 1] + (dp[i - dp[i - 1] - 2] || 0);\\n            maxLength = Math.max(maxLength, dp[i]);\\n        }\\n    }\\n    return maxLength;\\n};\\n```\n```\\nfunction longestValidParentheses(s: string): number {\\n\\t// maxLength variable is used to monitor the maximum length of the valid substring\\n\\t// every time we fall in condition a. or b.\\n\\t// by using it we don\\'t need to find the maximum value in the resulting dp array\\n    let maxLength: number = 0;\\n    let dp: number[] = new Array(s.length).fill(0);\\n    \\n    for (let i = 1; i < s.length; i++) {\\n        if (s[i - 1] === \\'(\\' && s[i] === \\')\\') { // - condition a.\\n            dp[i] = 2 + (dp[i - 2] || 0); // - dp[i-2] can return undefined, if so we will add zero instead\\n            maxLength = Math.max(maxLength, dp[i]);\\n        }\\n        if (\\n            s[i - 1] === \\')\\' &&\\n            s[i] === \\')\\' &&\\n            s[i - dp[i - 1] - 1] === \\'(\\' // - condition b.\\n        ) {\\n            dp[i] = 2 + dp[i - 1] + (dp[i - dp[i - 1] - 2] || 0);\\n            maxLength = Math.max(maxLength, dp[i]);\\n        }\\n    }\\n    return maxLength;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2068207,
                "title": "java-fastest-solution-tc-100-sc-99-3-solution",
                "content": "```\\npublic class Solution {\\n    public int longestValidParentheses(String s) {\\n        int left = 0, right = 0, maxlength = 0;\\n        \\n        for (int i = 0; i < s.length(); i++) \\n        {\\n            if (s.charAt(i) == \\'(\\') left++;\\n            else right++;\\n            \\n            if (left == right) {\\n                maxlength = Math.max(maxlength, 2 * right);\\n            } else if (right >= left) {\\n                left = right = 0;\\n            }\\n        }\\n        \\n        left = right = 0;\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            \\n            if (s.charAt(i) == \\'(\\') left++;\\n            else right++;\\n            \\n            if (left == right) {\\n                maxlength = Math.max(maxlength, 2 * left);\\n            } else if (left >= right) {\\n                left = right = 0;\\n            }\\n        }\\n        \\n        return maxlength;\\n    }\\n}\\n```\\n\\n**Using Stack**\\n\\n```\\npublic class Solution {\\n    public int longestValidParentheses(String s) {\\n        Stack <Integer> stack = new Stack<>();\\n        int result = 0;\\n        stack.push(-1);\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\')\\' && stack.size() > 1 && s.charAt(stack.peek()) == \\'(\\') {\\n                stack.pop();\\n                result = Math.max(result, i - stack.peek());\\n            } else {\\n                stack.push(i);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\n**Using DP**\\n```\\npublic class Solution {\\n    public int longestValidParentheses(String s) {\\n        int[] dp = new int[s.length()];\\n        int result = 0;\\n        int leftCount = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'(\\') {\\n                leftCount++;\\n            } else if (leftCount > 0){\\n                dp[i] = dp[i - 1] + 2;\\n                dp[i] += (i - dp[i]) >= 0 ? dp[i - dp[i]] : 0;\\n                result = Math.max(result, dp[i]);\\n                leftCount--;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\npublic class Solution {\\n    public int longestValidParentheses(String s) {\\n        int left = 0, right = 0, maxlength = 0;\\n        \\n        for (int i = 0; i < s.length(); i++) \\n        {\\n            if (s.charAt(i) == \\'(\\') left++;\\n            else right++;\\n            \\n            if (left == right) {\\n                maxlength = Math.max(maxlength, 2 * right);\\n            } else if (right >= left) {\\n                left = right = 0;\\n            }\\n        }\\n        \\n        left = right = 0;\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            \\n            if (s.charAt(i) == \\'(\\') left++;\\n            else right++;\\n            \\n            if (left == right) {\\n                maxlength = Math.max(maxlength, 2 * left);\\n            } else if (left >= right) {\\n                left = right = 0;\\n            }\\n        }\\n        \\n        return maxlength;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int longestValidParentheses(String s) {\\n        Stack <Integer> stack = new Stack<>();\\n        int result = 0;\\n        stack.push(-1);\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\')\\' && stack.size() > 1 && s.charAt(stack.peek()) == \\'(\\') {\\n                stack.pop();\\n                result = Math.max(result, i - stack.peek());\\n            } else {\\n                stack.push(i);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int longestValidParentheses(String s) {\\n        int[] dp = new int[s.length()];\\n        int result = 0;\\n        int leftCount = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'(\\') {\\n                leftCount++;\\n            } else if (leftCount > 0){\\n                dp[i] = dp[i - 1] + 2;\\n                dp[i] += (i - dp[i]) >= 0 ? dp[i - dp[i]] : 0;\\n                result = Math.max(result, dp[i]);\\n                leftCount--;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1914266,
                "title": "simple-java-solution-o-n-time-one-stack",
                "content": "\\n```\\npublic int longestValidParentheses(String s) {\\n        if(s.length() == 0) return 0; //If given String is Empty, then return 0\\n        \\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(-1); //push value -1 to stack\\n        \\n        int requiredLength = 0;\\n        \\n        for(int i =0;i<s.length();i++){\\n            char c = s.charAt(i);\\n            \\n            if(c == \\'(\\'){\\n                stack.push(i);\\n            }else{\\n                stack.pop();\\n                if(stack.isEmpty()){\\n                    stack.push(i);\\n                }else{\\n                   requiredLength = Math.max(requiredLength, i - stack.peek());\\n                }\\n            }\\n        }\\n        \\n        return requiredLength;\\n    }\\n```\\nIf you like this solution, please do upvote it",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\npublic int longestValidParentheses(String s) {\\n        if(s.length() == 0) return 0; //If given String is Empty, then return 0\\n        \\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(-1); //push value -1 to stack\\n        \\n        int requiredLength = 0;\\n        \\n        for(int i =0;i<s.length();i++){\\n            char c = s.charAt(i);\\n            \\n            if(c == \\'(\\'){\\n                stack.push(i);\\n            }else{\\n                stack.pop();\\n                if(stack.isEmpty()){\\n                    stack.push(i);\\n                }else{\\n                   requiredLength = Math.max(requiredLength, i - stack.peek());\\n                }\\n            }\\n        }\\n        \\n        return requiredLength;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1646136,
                "title": "java-stack-soln-easy-to-understand-code",
                "content": "\\'\\'\\'\\n  public int longestValidParentheses(String s) {\\n      \\n          Stack<Integer> st =new Stack<>();\\n          st.push(-1);\\n          int max=0;\\n          char a[]=s.toCharArray();\\n          \\n          for(int i=0;i<s.length();i++)\\n            {\\n                 if(a[i]==\\'(\\')st.push(i);\\n                 else{\\n                     st.pop();\\n                     \\n                     if(st.empty()) st.push(i);\\n                     else max=Math.max(max,i-st.peek());\\n                     }\\n            }\\n          return max;   \\n    }\\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "\\'\\'\\'\\n  public int longestValidParentheses(String s) {\\n      \\n          Stack<Integer> st =new Stack<>();\\n          st.push(-1);\\n          int max=0;\\n          char a[]=s.toCharArray();\\n          \\n          for(int i=0;i<s.length();i++)\\n            {\\n                 if(a[i]==\\'(\\')st.push(i);\\n                 else{\\n                     st.pop();\\n                     \\n                     if(st.empty()) st.push(i);\\n                     else max=Math.max(max,i-st.peek());\\n                     }\\n            }\\n          return max;   \\n    }\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1523930,
                "title": "javascript-easy-stack-with-comments",
                "content": "```\\nvar longestValidParentheses = function(s) {\\n    if(s.length === 0) return 0;\\n    \\n    let stack = [-1];\\n    let max = 0;\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        //push into stack if opening paran\\n        if(s[i] === \\'(\\') {\\n            stack.push(i);\\n        } else {\\n            // pop out if it\\'s an closing paran\\n            stack.pop();\\n            \\n            // if we don\\'t hav anything in stack, push this new index\\n            if(stack.length === 0) {\\n                stack.push(i);\\n            } else {\\n                // i - stack[stack.length - 1] is length of longest substr\\n                max = Math.max(max, i - stack[stack.length - 1]);\\n            }\\n        }\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\nvar longestValidParentheses = function(s) {\\n    if(s.length === 0) return 0;\\n    \\n    let stack = [-1];\\n    let max = 0;\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        //push into stack if opening paran\\n        if(s[i] === \\'(\\') {\\n            stack.push(i);\\n        } else {\\n            // pop out if it\\'s an closing paran\\n            stack.pop();\\n            \\n            // if we don\\'t hav anything in stack, push this new index\\n            if(stack.length === 0) {\\n                stack.push(i);\\n            } else {\\n                // i - stack[stack.length - 1] is length of longest substr\\n                max = Math.max(max, i - stack[stack.length - 1]);\\n            }\\n        }\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1428156,
                "title": "time-complexity-o-n-space-complexity-o-1-clear-with-explaination",
                "content": "**time complexity:o(n)\\nspace complexity:o(1)**\\nAn opening bracket increase the opens\\nBracket increase the counter of the end brackets,\\nAt each stage I compare if the masses are equal,\\n If so then the sequence so far is correct - So I compare the length of the sequence with the maximum.\\nAt each stage I also check if the brackets are larger than the openers -\\nI mean an incorrect sequence so we initialize the amount of openers and closers by 0\\nFor the first time I went from beginning to end\\nAnd in a second from the end to the beginning\\nEnjoy...\\n\\n```\\n```\\n```\\n\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int start = 0, end = 0, max = 0, i = 0;\\n\\n        for (; i < s.length(); i++)\\n        {\\n            s[i] == \\')\\' ? end++ : start++;\\n\\n            if (end == start)\\n            {\\n                if(max<2 * start)\\n                     max = 2 * start;\\n            }\\n            else if (end > start)\\n                end = start = 0;\\n        }\\n        \\n        start = 0, end = 0;\\n        \\n        for (i = s.length()-1 ; i >= 0 ; i--)\\n        {\\n            s[i] == \\'(\\' ? end++ : start++;\\n            \\n            if (end == start)\\n            {\\n                if(max < 2 * start)\\n                     max = 2 * start;\\n            }\\n            else if (end > start)\\n                end = start = 0;\\n        }\\n         return max;\\n    }        \\n};\\n \\n```\\n```\\n```\\n",
                "solutionTags": [],
                "code": "```\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int start = 0, end = 0, max = 0, i = 0;\\n\\n        for (; i < s.length(); i++)\\n        {\\n            s[i] == \\')\\' ? end++ : start++;\\n\\n            if (end == start)\\n            {\\n                if(max<2 * start)\\n                     max = 2 * start;\\n            }\\n            else if (end > start)\\n                end = start = 0;\\n        }\\n        \\n        start = 0, end = 0;\\n        \\n        for (i = s.length()-1 ; i >= 0 ; i--)\\n        {\\n            s[i] == \\'(\\' ? end++ : start++;\\n            \\n            if (end == start)\\n            {\\n                if(max < 2 * start)\\n                     max = 2 * start;\\n            }\\n            else if (end > start)\\n                end = start = 0;\\n        }\\n         return max;\\n    }        \\n};\\n \\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1294217,
                "title": "python3-o-n-runtime-o-1-space-self-explananatory-beginner-friendly",
                "content": "```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        open_=0\\n        close=0\\n        ans1=0\\n        for i in s:\\n            if i==\\'(\\':\\n                open_+=1\\n            else:\\n                close+=1\\n            if open_==close:\\n                ans1=max(close*2,ans1)\\n            elif close>open_:\\n                open_=close=0\\n        ans2=0\\n        open_=close=0\\n        for i in range(len(s)-1,-1,-1):\\n            if s[i]==\\'(\\':\\n                open_+=1\\n            else:\\n                close+=1\\n            if open_==close:\\n                ans2=max(ans2,2*open_)\\n            elif open_>close:\\n                open_=close=0\\n        return max(ans1,ans2)\\n```\\n\\n\\n**Please Upvote if you find it helpful !!!  ... :)**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        open_=0\\n        close=0\\n        ans1=0\\n        for i in s:\\n            if i==\\'(\\':\\n                open_+=1\\n            else:\\n                close+=1\\n            if open_==close:\\n                ans1=max(close*2,ans1)\\n            elif close>open_:\\n                open_=close=0\\n        ans2=0\\n        open_=close=0\\n        for i in range(len(s)-1,-1,-1):\\n            if s[i]==\\'(\\':\\n                open_+=1\\n            else:\\n                close+=1\\n            if open_==close:\\n                ans2=max(ans2,2*open_)\\n            elif open_>close:\\n                open_=close=0\\n        return max(ans1,ans2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1294166,
                "title": "c-solution",
                "content": "Method 1\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int close=0,open=0,max_len=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'){\\n                open++;\\n            }\\n            else{\\n                close++;\\n            }\\n            if(close==open){\\n                max_len=max(max_len,2*open);\\n            }\\n            else if(close>open){\\n                open=0;\\n                close=0;\\n            }\\n        }\\n        close=0;\\n        open=0;\\n         for(int i=s.length()-1;i>=0;i--){\\n            if(s[i]==\\'(\\'){\\n                open++;\\n            }\\n            else{\\n                close++;\\n            }\\n            if(close==open){\\n                max_len=max(max_len,2*open);\\n            }\\n            else if(close<open){\\n                open=0;\\n                close=0;\\n            }\\n        }\\n        return max_len;\\n        \\n    }\\n};\\n```\\nMethod 2-DP Based,100% fast\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        vector<int>v(s.size()+1,0);\\n        for(int i=1;i<s.length();i++){\\n            if(s[i]==\\')\\'){// when s[i]==\\')\\' and one index before it is\\'(\\' than v[i] ie no of valid parenthesis upto index i is v[i-2]+2\\n                if(s[i-1]==\\'(\\'){\\n                    v[i]=2+((i-2)>=0?v[i-2]:0);\\n                }\\n                else if(i-v[i-1]>0 && s[i-v[i-1]-1]==\\'(\\'){\\n                    v[i]=2+v[i-1]+((i-v[i-1]-2)>=0?v[i-v[i-1]-2]:0);\\n                \\n                }\\n            }\\n        }\\n        return *max_element(v.begin(),v.end());\\n        \\n    }\\n};\\n```\\n\\ndo upvote if you like it......\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int close=0,open=0,max_len=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'){\\n                open++;\\n            }\\n            else{\\n                close++;\\n            }\\n            if(close==open){\\n                max_len=max(max_len,2*open);\\n            }\\n            else if(close>open){\\n                open=0;\\n                close=0;\\n            }\\n        }\\n        close=0;\\n        open=0;\\n         for(int i=s.length()-1;i>=0;i--){\\n            if(s[i]==\\'(\\'){\\n                open++;\\n            }\\n            else{\\n                close++;\\n            }\\n            if(close==open){\\n                max_len=max(max_len,2*open);\\n            }\\n            else if(close<open){\\n                open=0;\\n                close=0;\\n            }\\n        }\\n        return max_len;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        vector<int>v(s.size()+1,0);\\n        for(int i=1;i<s.length();i++){\\n            if(s[i]==\\')\\'){// when s[i]==\\')\\' and one index before it is\\'(\\' than v[i] ie no of valid parenthesis upto index i is v[i-2]+2\\n                if(s[i-1]==\\'(\\'){\\n                    v[i]=2+((i-2)>=0?v[i-2]:0);\\n                }\\n                else if(i-v[i-1]>0 && s[i-v[i-1]-1]==\\'(\\'){\\n                    v[i]=2+v[i-1]+((i-v[i-1]-2)>=0?v[i-v[i-1]-2]:0);\\n                \\n                }\\n            }\\n        }\\n        return *max_element(v.begin(),v.end());\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 151578,
                "title": "o-n-c-straight-forward-solution-4ms-beats-100",
                "content": "```\\n    int longestValidParentheses(string str) {            \\n    int l = str.length();     \\n    stack<int> s; s.push(-1);           //  bottom mark     \\n    int longLen = 0, newLen;            //  Initialize longest length \\n    for (int i=0; i<l; i++) {           //  Scan the given string from left            \\n        if (str[i] == \\'(\\') s.push(i);   //  for every \\'(\\', pushing index of it into stack \\n        else {                    \\n            s.pop();                    //  removing the current top value \\n            if (!s.empty()) {                \\n                newLen = i - s.top();                \\n                if(newLen > longLen) longLen = newLen;                \\n            } \\n            else s.push(i);\\n        }\\n    } \\n    return longLen;        \\n    }\\n\\t\\t```\\n\\t\\t",
                "solutionTags": [],
                "code": "```\\n    int longestValidParentheses(string str) {            \\n    int l = str.length();     \\n    stack<int> s; s.push(-1);           //  bottom mark     \\n    int longLen = 0, newLen;            //  Initialize longest length \\n    for (int i=0; i<l; i++) {           //  Scan the given string from left            \\n        if (str[i] == \\'(\\') s.push(i);   //  for every \\'(\\', pushing index of it into stack \\n        else {                    \\n            s.pop();                    //  removing the current top value \\n            if (!s.empty()) {                \\n                newLen = i - s.top();                \\n                if(newLen > longLen) longLen = newLen;                \\n            } \\n            else s.push(i);\\n        }\\n    } \\n    return longLen;        \\n    }\\n\\t\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 14316,
                "title": "c-o-n-time-and-o-1-space",
                "content": "Let '(' equals to 1 and ')' equals to -1,if s.substr(i,j-i+1) is a valid parentheses,then the sum of this substring should be 0.\\n\\n     int longestValidParentheses(string s) {\\n            int n=s.length();\\n            if(n<=1)\\n                return 0;\\n            int i=0,j=n-1;\\n            while(s[i]==')')\\n                i++;\\n            while(s[j]=='(')\\n                j--;\\n            s=s.substr(i,j-i+1);  \\n            n=s.length();\\n            if(n<=1)\\n                return 0;\\n            int ans=0,maxlen=0,pos=0,maxlen1=0;\\n            for(i=0;i<n;i++)\\n            {\\n                int tmp=s[i]=='('?1:-1;\\n                ans+=tmp;\\n                if(ans<0)\\n                {\\n                    pos=i+1;\\n                    ans=0;\\n                }\\n                else if(ans==0)\\n                    maxlen=max(maxlen,i-pos+1);\\n            }\\n            ans=0;\\n            pos=n-1;\\n            for(i=n-1;i>=0;i--)\\n            {\\n                int tmp=s[i]=='('?1:-1;\\n                ans+=tmp;\\n                if(ans>0)\\n                {\\n                    pos=i-1;\\n                    ans=0;\\n                }\\n                else if(ans==0)\\n                    maxlen1=max(maxlen1,pos-i+1);\\n            }\\n            ans= max(maxlen,maxlen1);\\n            return ans;\\n    }",
                "solutionTags": [],
                "code": "Let '(' equals to 1 and ')' equals to -1,if s.substr(i,j-i+1) is a valid parentheses,then the sum of this substring should be 0.\\n\\n     int longestValidParentheses(string s) {\\n            int n=s.length();\\n            if(n<=1)\\n                return 0;\\n            int i=0,j=n-1;\\n            while(s[i]==')')\\n                i++;\\n            while(s[j]=='(')\\n                j--;\\n            s=s.substr(i,j-i+1);  \\n            n=s.length();\\n            if(n<=1)\\n                return 0;\\n            int ans=0,maxlen=0,pos=0,maxlen1=0;\\n            for(i=0;i<n;i++)\\n            {\\n                int tmp=s[i]=='('?1:-1;\\n                ans+=tmp;\\n                if(ans<0)\\n                {\\n                    pos=i+1;\\n                    ans=0;\\n                }\\n                else if(ans==0)\\n                    maxlen=max(maxlen,i-pos+1);\\n            }\\n            ans=0;\\n            pos=n-1;\\n            for(i=n-1;i>=0;i--)\\n            {\\n                int tmp=s[i]=='('?1:-1;\\n                ans+=tmp;\\n                if(ans>0)\\n                {\\n                    pos=i-1;\\n                    ans=0;\\n                }\\n                else if(ans==0)\\n                    maxlen1=max(maxlen1,pos-i+1);\\n            }\\n            ans= max(maxlen,maxlen1);\\n            return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 14364,
                "title": "share-my-java-solution-with-stack-and-dp",
                "content": "Stack:\\n    \\n        public int longestValidParentheses(String s) {\\n            Stack<Integer> st = new Stack<>();\\n            int max = 0;\\n            for(int i=0;i<s.length();i++){\\n                if(s.charAt(i)==')'&&!st.isEmpty()&&s.charAt(st.peek())=='('){\\n                    st.pop();\\n                    max = Math.max(max, i-((st.isEmpty())?-1:st.peek()));\\n                }\\n                else    st.push(i);\\n            }\\n            return max;\\n        }\\n\\nDP:\\n\\n    public int longestValidParentheses(String s) {\\n        /*max[i] = j means subsequence index i-j is longest valid Parentheses*/\\n        int[] max = new int[s.length()+1];\\n        max[s.length()] = s.length();\\n        int sum = 0;\\n        for(int i=s.length()-1;i>=0;i--){\\n            if(max[i+1]!=i+1){\\n                if(max[i+1]+1<s.length()&&s.charAt(i)=='('&&s.charAt(max[i+1]+1)==')'){\\n                    max[i] = (max[i+1]+2<s.length()+1&&max[max[i+1]+2]!=max[i+1]+2)?max[max[i+1]+2]:max[i+1]+1;\\n                }\\n                else    max[i] = i;\\n            }\\n            else if(i+1<s.length()&&s.charAt(i+1)==')'&&s.charAt(i)=='('){\\n                max[i] = (i+2<s.length()+1&&max[i+2]!=i+2)?max[i+2]:i+1;\\n            }\\n            else    max[i] = i;\\n            sum = Math.max(sum, max[i]-i+1);\\n        }\\n        return (sum==1)?0:sum;\\n    }",
                "solutionTags": [
                    "Stack"
                ],
                "code": "Stack:\\n    \\n        public int longestValidParentheses(String s) {\\n            Stack<Integer> st = new Stack<>();\\n            int max = 0;\\n            for(int i=0;i<s.length();i++){\\n                if(s.charAt(i)==')'&&!st.isEmpty()&&s.charAt(st.peek())=='('){\\n                    st.pop();\\n                    max = Math.max(max, i-((st.isEmpty())?-1:st.peek()));\\n                }\\n                else    st.push(i);\\n            }\\n            return max;\\n        }\\n\\nDP:\\n\\n    public int longestValidParentheses(String s) {\\n        /*max[i] = j means subsequence index i-j is longest valid Parentheses*/\\n        int[] max = new int[s.length()+1];\\n        max[s.length()] = s.length();\\n        int sum = 0;\\n        for(int i=s.length()-1;i>=0;i--){\\n            if(max[i+1]!=i+1){\\n                if(max[i+1]+1<s.length()&&s.charAt(i)=='('&&s.charAt(max[i+1]+1)==')'){\\n                    max[i] = (max[i+1]+2<s.length()+1&&max[max[i+1]+2]!=max[i+1]+2)?max[max[i+1]+2]:max[i+1]+1;\\n                }\\n                else    max[i] = i;\\n            }\\n            else if(i+1<s.length()&&s.charAt(i+1)==')'&&s.charAt(i)=='('){\\n                max[i] = (i+2<s.length()+1&&max[i+2]!=i+2)?max[i+2]:i+1;\\n            }\\n            else    max[i] = i;\\n            sum = Math.max(sum, max[i]-i+1);\\n        }\\n        return (sum==1)?0:sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3928166,
                "title": "easy-java-solution-beats-95-submissions-super-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(-1);\\n        int max =0;\\n\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                stack.push(i);\\n            }else{\\n                stack.pop();\\n\\n                if(!stack.isEmpty()){\\n                    max = Math.max(max,i-stack.peek());\\n                }\\n                else{\\n                    stack.push(i);\\n                }\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(-1);\\n        int max =0;\\n\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                stack.push(i);\\n            }else{\\n                stack.pop();\\n\\n                if(!stack.isEmpty()){\\n                    max = Math.max(max,i-stack.peek());\\n                }\\n                else{\\n                    stack.push(i);\\n                }\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780664,
                "title": "python-97-04-faster-two-approaches-o-1-and-o-n-space",
                "content": "**Brute Force O(n) Space:**\\n```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        st=[-1]\\n        m=0\\n        for i in range(len(s)):\\n            if s[i]==\\'(\\':\\n                st.append(i)\\n            else:\\n                st.pop()\\n                if not st: #if -1 is popped\\n                    st.append(i)\\n                else:\\n                    m=max(m,i-st[-1])\\n        return m\\n```\\n**Optimized Solution O(1) Space:**\\n```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        l=r=m=0\\n        for i in range(len(s)):\\n            if s[i]==\\'(\\':\\n                l+=1\\n            else:\\n                r+=1\\n            if l==r: #for balanced parantheses\\n                m=max(m,l+r)\\n            elif r>l: #invalid case\\n                l=r=0\\n        l=r=0\\n# We are traversing right to left for the test case where opening brackets are more than closing brackets. eg: s = \"(()\"\\n        for i in range(len(s)-1,-1,-1):\\n            if s[i]==\\'(\\':\\n                l+=1\\n            else:\\n                r+=1\\n            if l==r: #for balanced parantheses\\n                m=max(m,l+r)\\n            elif l>r: #invalid case\\n                l=r=0  \\n        return m\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        st=[-1]\\n        m=0\\n        for i in range(len(s)):\\n            if s[i]==\\'(\\':\\n                st.append(i)\\n            else:\\n                st.pop()\\n                if not st: #if -1 is popped\\n                    st.append(i)\\n                else:\\n                    m=max(m,i-st[-1])\\n        return m\\n```\n```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        l=r=m=0\\n        for i in range(len(s)):\\n            if s[i]==\\'(\\':\\n                l+=1\\n            else:\\n                r+=1\\n            if l==r: #for balanced parantheses\\n                m=max(m,l+r)\\n            elif r>l: #invalid case\\n                l=r=0\\n        l=r=0\\n# We are traversing right to left for the test case where opening brackets are more than closing brackets. eg: s = \"(()\"\\n        for i in range(len(s)-1,-1,-1):\\n            if s[i]==\\'(\\':\\n                l+=1\\n            else:\\n                r+=1\\n            if l==r: #for balanced parantheses\\n                m=max(m,l+r)\\n            elif l>r: #invalid case\\n                l=r=0  \\n        return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3761737,
                "title": "unique-sol-c-uses-stack-dp-w-8-test-cases",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe solution is very unique.\\n\\nUse a stack for int when s[i]=\\'(\\' pushing into the stack otherwise popping x from the top of the stack if the stack is not empty. Compute the valid length ending at the index i storing into dp[i] with the relation dp[i]=i-x+1+dp[x-1] !!!\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n8 test cases\\n```\\n\"(()\"\\n\")()())\"\\n\"\"\\n\"((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\"\\n \"()(()\"\\n \")()())\"\\n \"()(())\"\\n \")()())\"\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int n=s.size();\\n        if (n<2) return 0;\\n        stack<int> st;\\n        vector<int> dp(n, 0);\\n       \\n        int ans=0;\\n        for(int i=0; i<n; i++){\\n            if (s[i]==\\'(\\') {\\n                st.push(i);\\n            }\\n            else{ //s[i]=\\')\\'\\n                if (!st.empty()){\\n                    int x=st.top();\\n                    dp[i]=i-x+1;//substring s[x:i+1] is valid\\n                    if (x>=1) dp[i]+=dp[x-1];//concatenate with substring\\n                //    cout<<i<<\"->\"<<x<<\":\"<<dp[i]<<endl;\\n                    st.pop();\\n                }\\n            }\\n            ans=max(ans, dp[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\n\"(()\"\\n\")()())\"\\n\"\"\\n\"((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\"\\n \"()(()\"\\n \")()())\"\\n \"()(())\"\\n \")()())\"\\n```\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int n=s.size();\\n        if (n<2) return 0;\\n        stack<int> st;\\n        vector<int> dp(n, 0);\\n       \\n        int ans=0;\\n        for(int i=0; i<n; i++){\\n            if (s[i]==\\'(\\') {\\n                st.push(i);\\n            }\\n            else{ //s[i]=\\')\\'\\n                if (!st.empty()){\\n                    int x=st.top();\\n                    dp[i]=i-x+1;//substring s[x:i+1] is valid\\n                    if (x>=1) dp[i]+=dp[x-1];//concatenate with substring\\n                //    cout<<i<<\"->\"<<x<<\":\"<<dp[i]<<endl;\\n                    st.pop();\\n                }\\n            }\\n            ans=max(ans, dp[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3587753,
                "title": "stack-c-very-easy",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int ans = 0, n = s.length();\\n        vector<int> v;\\n        for(int i = 0; i < n; i++){\\n            if(s[i]==\\'(\\'){\\n                v.push_back(i);\\n            }else{\\n                if(!v.empty() && s[v.back()]==\\'(\\')v.pop_back();\\n                else v.push_back(i);\\n            }\\n        }\\n        if(v.empty()){\\n            return n;\\n        }\\n            // cout<<n<<\" \";\\n        while(!v.empty()){\\n            ans = max(ans,n-v.back()-1);\\n            n = v.back();\\n            // cout<<n<<\" \";\\n            v.pop_back();\\n        }\\n        return ans = max(ans,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int ans = 0, n = s.length();\\n        vector<int> v;\\n        for(int i = 0; i < n; i++){\\n            if(s[i]==\\'(\\'){\\n                v.push_back(i);\\n            }else{\\n                if(!v.empty() && s[v.back()]==\\'(\\')v.pop_back();\\n                else v.push_back(i);\\n            }\\n        }\\n        if(v.empty()){\\n            return n;\\n        }\\n            // cout<<n<<\" \";\\n        while(!v.empty()){\\n            ans = max(ans,n-v.back()-1);\\n            n = v.back();\\n            // cout<<n<<\" \";\\n            v.pop_back();\\n        }\\n        return ans = max(ans,n);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3281987,
                "title": "look-at-it-best-python3-solution-ever",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        st = [-1]\\n        maxlength = 0\\n        for i in range(len(s)):\\n            t = st[-1]\\n            if t != -1 and s[i] == \\')\\' and s[t] == \\'(\\':\\n                st.pop()\\n                maxlength = max(maxlength, i - st[-1])\\n            else:\\n                st.append(i)\\n        return maxlength\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        st = [-1]\\n        maxlength = 0\\n        for i in range(len(s)):\\n            t = st[-1]\\n            if t != -1 and s[i] == \\')\\' and s[t] == \\'(\\':\\n                st.pop()\\n                maxlength = max(maxlength, i - st[-1])\\n            else:\\n                st.append(i)\\n        return maxlength\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3243659,
                "title": "dynamic-programming-approach-to-longest-valid-parentheses-substring",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve this problem, we can use dynamic programming. Let dp[i] be the length of the longest valid parentheses substring ending at index i. We can observe the following:\\n\\n1. If s[i] = \\'(\\', there can be no valid substring ending at index i, so dp[i] = 0.\\n2. If s[i] = \\')\\', we have two cases:\\na. If s[i-1] = \\'(\\', then dp[i] = dp[i-2] + 2.\\nb. If s[i-1] = \\')\\' and s[i-dp[i-1]-1] = \\'(\\', then dp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2.\\n\\nIn case (2a), we add 2 to dp[i-2] because we have a matching pair of parentheses at indices i-1 and i, and we can extend the valid substring ending at index i-2 (if there is one) to include this pair.\\n\\nIn case (2b), we add dp[i-1] to account for the length of the valid substring ending at index i-1, and dp[i-dp[i-1]-2] to account for any valid substring that starts before the opening bracket of the current substring. For example, consider the string \"(()())\". When we reach the second closing bracket at index 5, we can extend the valid substring ending at index 4 (which has length 2) to include the current pair of parentheses, giving us a length of 4. However, we also need to account for the valid substring that starts before the opening bracket of this substring, which is the substring that ends at index 1 (which has length 2).\\n\\nFinally, the length of the longest valid parentheses substring is the maximum value in the dp array.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize the dp array with zeros, and the maximum length variable max_len with 0.\\n- Iterate over the indices of the input string from left to right.\\n- If s[i] = \\')\\', check if the previous character s[i-1] is \\'(\\'. If it is, set dp[i] = dp[i-2] + 2.\\n- Otherwise, check if s[i-dp[i-1]-1] is \\'(\\'. If it is, set dp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2.\\n- Update max_len with the maximum value in the dp array.\\n- Return max_len.\\n# Complexity\\n- Time complexity: O(n), where n is the length of the input string.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n), where n is the length of the input string.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        stack = [-1]\\n        max_len = 0\\n        for i in range(len(s)):\\n            if s[i] == \\'(\\':\\n                stack.append(i)\\n            else:\\n                stack.pop()\\n                if not stack:\\n                    stack.append(i)\\n                else:\\n                    max_len = max(max_len, i - stack[-1])\\n        return max_len\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        stack = [-1]\\n        max_len = 0\\n        for i in range(len(s)):\\n            if s[i] == \\'(\\':\\n                stack.append(i)\\n            else:\\n                stack.pop()\\n                if not stack:\\n                    stack.append(i)\\n                else:\\n                    max_len = max(max_len, i - stack[-1])\\n        return max_len\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097669,
                "title": "c-easy-solution-using-stack",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int>st;\\n        st.push(-1);\\n        int maxi=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'){\\n                st.push(i);\\n            }\\n            if(s[i]==\\')\\'){\\n                st.pop();\\n                if(st.size()==0){\\n                    st.push(i);\\n                }\\n                else{\\n                    int c=i-st.top();\\n                    maxi=max(c,maxi);\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int>st;\\n        st.push(-1);\\n        int maxi=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'){\\n                st.push(i);\\n            }\\n            if(s[i]==\\')\\'){\\n                st.pop();\\n                if(st.size()==0){\\n                    st.push(i);\\n                }\\n                else{\\n                    int c=i-st.top();\\n                    maxi=max(c,maxi);\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2927108,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> st;\\n        st.push(-1);\\n        int ans=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int t=st.top();\\n            if(t!=-1 &&s[i]==\\')\\'&& s[t]==\\'(\\')\\n            {\\n                st.pop();\\n                ans=max(ans, i-st.top());\\n            }\\n            else\\n                st.push(i);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> st;\\n        st.push(-1);\\n        int ans=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int t=st.top();\\n            if(t!=-1 &&s[i]==\\')\\'&& s[t]==\\'(\\')\\n            {\\n                st.pop();\\n                ans=max(ans, i-st.top());\\n            }\\n            else\\n                st.push(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891153,
                "title": "c-stack-solution",
                "content": "\\n# Approach\\nstack based\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> st;\\n        st.push(-1);\\n        int ans=0;\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            if(s[i]==\\'(\\'){\\n                st.push(i);\\n            }else{\\n                st.pop();\\n                if(st.empty()){\\n                    st.push(i);\\n                }\\n                int sz=i-st.top();\\n                ans=max(ans,sz);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> st;\\n        st.push(-1);\\n        int ans=0;\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            if(s[i]==\\'(\\'){\\n                st.push(i);\\n            }else{\\n                st.pop();\\n                if(st.empty()){\\n                    st.push(i);\\n                }\\n                int sz=i-st.top();\\n                ans=max(ans,sz);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2862929,
                "title": "5-lines-c-easy-solution-time-o-n-space-o-n",
                "content": "just find the distance between current index and last inserted index of stack\\n```\\n  int longestValidParentheses(string s) {\\n        stack<int> st;\\n        int ans=0,i=0;\\n        for(st.push(-1);i<s.size();i++)\\n        {\\n            ans=max(ans,abs(i-st.top())-1);\\n            (st.size()>1&&s[st.top()]==\\'(\\'&&s[i]==\\')\\')?st.pop():st.push(i);\\n        }\\n        return max(ans,abs(st.top()-(int)s.size())-1);\\n    }\\n```\\nPls UPVOTE the solution if u like",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n  int longestValidParentheses(string s) {\\n        stack<int> st;\\n        int ans=0,i=0;\\n        for(st.push(-1);i<s.size();i++)\\n        {\\n            ans=max(ans,abs(i-st.top())-1);\\n            (st.size()>1&&s[st.top()]==\\'(\\'&&s[i]==\\')\\')?st.pop():st.push(i);\\n        }\\n        return max(ans,abs(st.top()-(int)s.size())-1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2724360,
                "title": "python-o-n-solution-easy",
                "content": "```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        l=r=c=0\\n        for i in range(len(s)):\\n            if s[i]==\\'(\\':\\n                l+=1\\n            else:\\n                r+=1\\n            if l==r:\\n                c=max(c,l+r)\\n            elif l<r:\\n                l=r=0\\n        l=r=0\\n        for i in range(len(s)-1,-1,-1):\\n            if s[i]==\\'(\\':\\n                l+=1\\n            else:\\n                r+=1\\n            if l==r:\\n                c=max(c,l+r)\\n            elif l>r:\\n                l=r=0\\n        return c\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        l=r=c=0\\n        for i in range(len(s)):\\n            if s[i]==\\'(\\':\\n                l+=1\\n            else:\\n                r+=1\\n            if l==r:\\n                c=max(c,l+r)\\n            elif l<r:\\n                l=r=0\\n        l=r=0\\n        for i in range(len(s)-1,-1,-1):\\n            if s[i]==\\'(\\':\\n                l+=1\\n            else:\\n                r+=1\\n            if l==r:\\n                c=max(c,l+r)\\n            elif l>r:\\n                l=r=0\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2502302,
                "title": "python-very-simple-o-n-with-explanation-and-visualization",
                "content": "There are only two ways a string of parentheses can be invalid:\\n* There are too many closing parentheses i.e. `())`\\n* There are not enough closing parentheses i.e. `(()`\\n\\nThus, if we find a matching closing parentheses for a given open parentheses (by using a stack), *that string **MUST** be valid.*.  Strings are invalid *only* when a closing parentheses cannot be matched correctly. This means that for `(...)`, the `...` contained within will **ALWAYS** be valid, otherwise the closing parentheses `)` would not be matched to the open parentheses `(` to begin with. If this doesn\\'t make sense, I suggest trying to come up with an example to counter that assumption - it will become clear it is true.\\n\\nWe can structure our algorithm to assume everything is invalid, then scan through the string, marking substrings as valid whenever a closing parentheses is matched to an opening parentheses. \\n\\nHere\\'s how it works:\\n\\n1. Initialize a boolean array `validSections` with `length == s.length`, where `validSections[i]` is `true` when `s[i]` is a part of a valid string of parentheses.\\n2.  Scan the string.\\n\\ta. When we encounter an opening parentheses `(`, push its `index` onto the `stack`. \\n\\tb. When we encounter a closing parentheses `)`, pop the last `index` off the stack (it is the `index` of the matching opening parentheses). Set `validSections[currentIndex] = true` and `validSections[poppedIndex] = true`. Everything between those two indexes will **always** already be marked `true`\\\\*. If the stack has nothing to pop, there is nothing to do (because `validSections` is already initialized to false)\\n3. Count and return the longest unbroken sequence of `true` values in `validSections` \\n```python\\nOPEN, = \\'(\\'\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n\\t\\t# STEP 1\\n        validSections = [False] * len(s)\\n\\t\\t# STEP 2\\n        stack = []\\n        for index, c in enumerate(s):\\n            if c == OPEN:\\n                stack.append(index)\\n            else:\\n                if len(stack) > 0:\\n                    validSections[index], validSections[stack.pop()] = True, True\\n         \\n\\t\\t# STEP 3\\n        currentLength = 0\\n        best = 0\\n        for valid in validSections:\\n            if valid:\\n                currentLength += 1\\n            else:\\n                currentLength = 0\\n            if best < currentLength:\\n                best = currentLength\\n        return best\\n```\\nIn essence, this method asynchronously builds knowledge of valid substrings into something that is much more easily digestable. If you add a print statement as it scans over the string, you\\'ll see it slowly build the valid sections:\\nHere\\'s an example for the string `\"(()())))()()()()()((()()()()(()(()\"`. Every time it encounters a `)` with a matching `(`, it will add two `x` to mark that substring as valid. \\n```\\n(()())))()()()()()((()()()()(()(()\\n----------------------------------\\n----------------------------------\\n-xx-------------------------------\\n-xx-------------------------------\\n-xxxx-----------------------------\\nxxxxxx----------------------------\\nxxxxxx----------------------------\\nxxxxxx----------------------------\\nxxxxxx----------------------------\\nxxxxxx--xx------------------------\\nxxxxxx--xx------------------------\\nxxxxxx--xxxx----------------------\\nxxxxxx--xxxx----------------------\\nxxxxxx--xxxxxx--------------------\\nxxxxxx--xxxxxx--------------------\\nxxxxxx--xxxxxxxx------------------\\nxxxxxx--xxxxxxxx------------------\\nxxxxxx--xxxxxxxxxx----------------\\nxxxxxx--xxxxxxxxxx----------------\\nxxxxxx--xxxxxxxxxx----------------\\nxxxxxx--xxxxxxxxxx----------------\\nxxxxxx--xxxxxxxxxx--xx------------\\nxxxxxx--xxxxxxxxxx--xx------------\\nxxxxxx--xxxxxxxxxx--xxxx----------\\nxxxxxx--xxxxxxxxxx--xxxx----------\\nxxxxxx--xxxxxxxxxx--xxxxxx--------\\nxxxxxx--xxxxxxxxxx--xxxxxx--------\\nxxxxxx--xxxxxxxxxx--xxxxxxxx------\\nxxxxxx--xxxxxxxxxx--xxxxxxxx------\\nxxxxxx--xxxxxxxxxx--xxxxxxxx------\\nxxxxxx--xxxxxxxxxx--xxxxxxxx-xx---\\nxxxxxx--xxxxxxxxxx--xxxxxxxx-xx---\\nxxxxxx--xxxxxxxxxx--xxxxxxxx-xx---\\nxxxxxx--xxxxxxxxxx--xxxxxxxx-xx-xx\\n(()())))()()()()()((()()()()(()(()\\n```\\n\\\\* The reason we can\\'t just keep track of the largest `currentIndex - poppedIndex` is because this would keep track of the largest valid single distinct substring, and not group of valid substrings. i.e. `()()` is two distinct substrings, whereas `(()())` is one.",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```python\\nOPEN, = \\'(\\'\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n\\t\\t# STEP 1\\n        validSections = [False] * len(s)\\n\\t\\t# STEP 2\\n        stack = []\\n        for index, c in enumerate(s):\\n            if c == OPEN:\\n                stack.append(index)\\n            else:\\n                if len(stack) > 0:\\n                    validSections[index], validSections[stack.pop()] = True, True\\n         \\n\\t\\t# STEP 3\\n        currentLength = 0\\n        best = 0\\n        for valid in validSections:\\n            if valid:\\n                currentLength += 1\\n            else:\\n                currentLength = 0\\n            if best < currentLength:\\n                best = currentLength\\n        return best\\n```\n```\\n(()())))()()()()()((()()()()(()(()\\n----------------------------------\\n----------------------------------\\n-xx-------------------------------\\n-xx-------------------------------\\n-xxxx-----------------------------\\nxxxxxx----------------------------\\nxxxxxx----------------------------\\nxxxxxx----------------------------\\nxxxxxx----------------------------\\nxxxxxx--xx------------------------\\nxxxxxx--xx------------------------\\nxxxxxx--xxxx----------------------\\nxxxxxx--xxxx----------------------\\nxxxxxx--xxxxxx--------------------\\nxxxxxx--xxxxxx--------------------\\nxxxxxx--xxxxxxxx------------------\\nxxxxxx--xxxxxxxx------------------\\nxxxxxx--xxxxxxxxxx----------------\\nxxxxxx--xxxxxxxxxx----------------\\nxxxxxx--xxxxxxxxxx----------------\\nxxxxxx--xxxxxxxxxx----------------\\nxxxxxx--xxxxxxxxxx--xx------------\\nxxxxxx--xxxxxxxxxx--xx------------\\nxxxxxx--xxxxxxxxxx--xxxx----------\\nxxxxxx--xxxxxxxxxx--xxxx----------\\nxxxxxx--xxxxxxxxxx--xxxxxx--------\\nxxxxxx--xxxxxxxxxx--xxxxxx--------\\nxxxxxx--xxxxxxxxxx--xxxxxxxx------\\nxxxxxx--xxxxxxxxxx--xxxxxxxx------\\nxxxxxx--xxxxxxxxxx--xxxxxxxx------\\nxxxxxx--xxxxxxxxxx--xxxxxxxx-xx---\\nxxxxxx--xxxxxxxxxx--xxxxxxxx-xx---\\nxxxxxx--xxxxxxxxxx--xxxxxxxx-xx---\\nxxxxxx--xxxxxxxxxx--xxxxxxxx-xx-xx\\n(()())))()()()()()((()()()()(()(()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2386596,
                "title": "python3-simple-solution",
                "content": "```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        \\n        maxi = 0\\n        stack = [-1]\\n        \\n        for i in range(len(s)) :\\n            if s[i] == \"(\" : stack.append(i)\\n            else :\\n                stack.pop()\\n                if len(stack) == 0 : stack.append(i)\\n                else : maxi = max(maxi, i - stack[-1])\\n        \\n        return maxi\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        \\n        maxi = 0\\n        stack = [-1]\\n        \\n        for i in range(len(s)) :\\n            if s[i] == \"(\" : stack.append(i)\\n            else :\\n                stack.pop()\\n                if len(stack) == 0 : stack.append(i)\\n                else : maxi = max(maxi, i - stack[-1])\\n        \\n        return maxi\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2305947,
                "title": "c-100-no-stack-no-dp-constant-space-tc-o-n",
                "content": "class Solution {\\npublic:\\n\\n    int longestValidParentheses(string s) {\\n        int n = s.length();\\n        int ans = 0;\\n        int lc = 0;  //opening bracket count\\n        int rc = 0;  //closing bracket count\\n        for(int i = 0; i < n; i++)  //left to right iteration\\n        {\\n            if(s[i] == \\'(\\') lc++;\\n            else rc++;\\n            if(lc == rc) ans = max(ans, 2 * lc);\\n            else if(rc > lc) lc = rc = 0;\\n        }\\n        lc = rc = 0;\\n        for(int i = n-1; i >= 0; i--)  //right to left iteration\\n        {\\n            if(s[i] == \\'(\\') lc++;\\n            else rc++;\\n            if(lc == rc) ans = max(ans, lc * 2);\\n            else if(lc > rc) lc = rc = 0;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int longestValidParentheses(string s) {\\n        int n = s.length();\\n        int ans = 0;\\n        int lc = 0;  //opening bracket count\\n        int rc = 0;  //closing bracket count\\n        for(int i = 0; i < n; i++)  //left to right iteration\\n        {\\n            if(s[i] == \\'(\\') lc++;\\n            else rc++;\\n            if(lc == rc) ans = max(ans, 2 * lc);\\n            else if(rc > lc) lc = rc = 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2170358,
                "title": "simple-easy-o-n-cpp-solution-without-dp",
                "content": "* We will use stack STL here. \\n* Firstly, if the character is a ( , we will push the index value of ( in the stack.\\n* If the char is ) and stack is not empty, we have the index i (from the traversal itself) and we can pop one ( from the stack..before popping we can take its index value from the stack-top in another variable, say x.\\n* So, by doing so, we are getting pairs of ( and ), thus making a valid parenthesis (MAYBE not the longest one). Now, for the indices of ( and ) pairs already encountered, make (s[i]=\\'.\\').\\n* At the end of traversal, we will be having string s as combinations of ( , ) and \\'.\\' \\n\\n* e.g., if the string is \")(()()())))\", the resulting string becomes - \")........))\"\\n* Now, traverse the string just once to find the longest number of consecutive \\'.\\' and that\\'s our answer ! \\n* The code - \\n* ```     \\n*     class Solution {\\n         public:  \\n    int longestValidParentheses(string s) {\\n        int i = 0;\\n        int x;\\n        int l = 0;\\n        stack<int> st;\\n        int res = 0;\\n        \\n        while (s[i] != \\'\\\\0\\')\\n        {\\n            if (s[i] == \\'(\\')\\n            {\\n                st.push(i);\\n                s[i] = \\'(\\';\\n            }\\n            else\\n            {\\n                if (!(st.empty()))\\n                {\\n                    x = st.top();\\n                    st.pop();\\n                    s[x] = \\'.\\';\\n                    s[i] = \\'.\\';\\n                }\\n            }\\n            i++;\\n        }\\n        int a = 0;\\n        for (i = 0; s[i] != \\'\\\\0\\'; i++)\\n        {\\n            if (s[i] != \\'.\\')\\n            {\\n                res = max(a, res);\\n                a = 0;\\n            }\\n            else\\n            {\\n                a++;\\n            }\\n        }\\n        return max(res,a);\\n    }\\n};```\\n\\nHope this helps ! :)",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```     \\n*     class Solution {\\n         public:  \\n    int longestValidParentheses(string s) {\\n        int i = 0;\\n        int x;\\n        int l = 0;\\n        stack<int> st;\\n        int res = 0;\\n        \\n        while (s[i] != \\'\\\\0\\')\\n        {\\n            if (s[i] == \\'(\\')\\n            {\\n                st.push(i);\\n                s[i] = \\'(\\';\\n            }\\n            else\\n            {\\n                if (!(st.empty()))\\n                {\\n                    x = st.top();\\n                    st.pop();\\n                    s[x] = \\'.\\';\\n                    s[i] = \\'.\\';\\n                }\\n            }\\n            i++;\\n        }\\n        int a = 0;\\n        for (i = 0; s[i] != \\'\\\\0\\'; i++)\\n        {\\n            if (s[i] != \\'.\\')\\n            {\\n                res = max(a, res);\\n                a = 0;\\n            }\\n            else\\n            {\\n                a++;\\n            }\\n        }\\n        return max(res,a);\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 2070364,
                "title": "intution-understanding-easy-to-understand-clean-code-o-n-time-o-n-space",
                "content": "**Lets break this problem into checking if a given String is contains all valid parentheses. Basic algorithm for this will be if we see a start character i.e. \\'( we push it in the stack and if we see end character \\')\\' and if top of the stack is \\'(\\' we pop it. This is similar to postfix expression evaluation logic.**\\n\\nif after doing this stack is not empty we can say that given string does not hold valid parentheses.\\n\\nNow coming to given problem in hand, we have to find a substring of the given string which is valid and is of maximum length.  lets have a look at below analysis. Lets say we have a given string X.\\n\\nX = \\')__________(\\'\\n\\nelements inside first character and last character forms a valid string. What will be the length of that string? It will be index of end character - index of first character -1.\\n\\nThis is the base intution behind this. So if we have position for indivdual mismatch we can find length out string which is valid. \\n\\nSo while evalulting above highlighted logic whenever we face a mismatch why don\\'t we store the index of position where current character is not equal to top of the stack. i.e. where ever mismatch happen .\\n\\nonce we have indexs all we have to do perfom end-start-1 and choose max of range.\\n\\nTry to visulise indexes wherever mimatch happened on a number line of positve integers.\\n\\n0..............5.........10............13............14\\n\\nso max length of valid substring will be between 5 and 0.  You might need to handle some corner cases and some initilzation condition. For that please have a look at the code below.\\n\\n```\\nclass Solution {\\n    static Character START_CHARACTER  = \\'(\\';\\n    static Character END_CHARACTER = \\')\\';\\n    \\n    \\n    public int longestValidParentheses(String s) {\\n        Stack<Integer> stack = new Stack<Integer>();\\n        for(int i=0;i<s.length();i++) {\\n            if(stack.isEmpty()) {\\n                stack.push(i);\\n            }\\n            else if(s.charAt(i)==Solution.END_CHARACTER && s.charAt(stack.peek())==Solution.START_CHARACTER) {\\n                stack.pop();\\n            }else {\\n                stack.push(i);\\n            } \\n        }\\n        int end=s.length();\\n        int start=0;\\n        int longestValidParentheses = 0;\\n        if(stack.isEmpty())\\n            return s.length();\\n        else {\\n            while(!stack.isEmpty()) {\\n            start = stack.pop();\\n            longestValidParentheses = Math.max(end-start-1,longestValidParentheses);\\n            end=start;\\n            }\\n        }\\n        longestValidParentheses = Math.max(end-0,longestValidParentheses);\\n        return longestValidParentheses;\\n    }\\n    \\n \\n}\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    static Character START_CHARACTER  = \\'(\\';\\n    static Character END_CHARACTER = \\')\\';\\n    \\n    \\n    public int longestValidParentheses(String s) {\\n        Stack<Integer> stack = new Stack<Integer>();\\n        for(int i=0;i<s.length();i++) {\\n            if(stack.isEmpty()) {\\n                stack.push(i);\\n            }\\n            else if(s.charAt(i)==Solution.END_CHARACTER && s.charAt(stack.peek())==Solution.START_CHARACTER) {\\n                stack.pop();\\n            }else {\\n                stack.push(i);\\n            } \\n        }\\n        int end=s.length();\\n        int start=0;\\n        int longestValidParentheses = 0;\\n        if(stack.isEmpty())\\n            return s.length();\\n        else {\\n            while(!stack.isEmpty()) {\\n            start = stack.pop();\\n            longestValidParentheses = Math.max(end-start-1,longestValidParentheses);\\n            end=start;\\n            }\\n        }\\n        longestValidParentheses = Math.max(end-0,longestValidParentheses);\\n        return longestValidParentheses;\\n    }\\n    \\n \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1475321,
                "title": "without-stack-cpp-o-1-space",
                "content": "```\\n int longestValidParentheses(string s) {  \\n          int left = 0, right = 0, maxlength = 0;\\n          int n=s.length();\\n    for (int i = 0; i < n; i++)\\n    {\\n        if (s[i] == \\'(\\')\\n            left++;\\n        else\\n            right++;\\n \\n\\n        if (left == right)\\n            maxlength = max(maxlength, 2 * right);\\n \\n\\n        else if (right > left)\\n            left = right = 0;\\n    }\\n \\n    left = right = 0;\\n \\n    for (int i = n - 1; i >= 0; i--) {\\n \\n\\n        if (s[i] == \\'(\\')\\n            left++;\\n        else\\n            right++;\\n \\n        if (left == right)\\n            maxlength = max(maxlength, 2 * left);\\n \\n        else if (left > right)\\n            left = right = 0;\\n    }\\n    return maxlength;\\n        \\n    }",
                "solutionTags": [],
                "code": "```\\n int longestValidParentheses(string s) {  \\n          int left = 0, right = 0, maxlength = 0;\\n          int n=s.length();\\n    for (int i = 0; i < n; i++)\\n    {\\n        if (s[i] == \\'(\\')\\n            left++;\\n        else\\n            right++;\\n \\n\\n        if (left == right)\\n            maxlength = max(maxlength, 2 * right);\\n \\n\\n        else if (right > left)\\n            left = right = 0;\\n    }\\n \\n    left = right = 0;\\n \\n    for (int i = n - 1; i >= 0; i--) {\\n \\n\\n        if (s[i] == \\'(\\')\\n            left++;\\n        else\\n            right++;\\n \\n        if (left == right)\\n            maxlength = max(maxlength, 2 * left);\\n \\n        else if (left > right)\\n            left = right = 0;\\n    }\\n    return maxlength;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1430695,
                "title": "using-stack-easy",
                "content": "\\t\\n\\tclass Solution {\\n\\t\\n\\tpublic:\\n    int longestValidParentheses(string s) {\\n        \\n        int n = s.length();\\n        stack<int> st;\\n        st.push(-1);\\n        int len = 0;\\n        int maxlen =0;\\n        for(int i =0;i<n;i++)\\n        {\\n            if(s[i] == \\'(\\')\\n                st.push(i);\\n            if(s[i] == \\')\\')\\n            {\\n                st.pop();\\n                if(st.empty())\\n                    st.push(i);\\n                len = i - st.top();\\n                maxlen = max(maxlen,len);\\n            }\\n        }\\n        return maxlen;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\t\\n\\tpublic:\\n    int longestValidParentheses(string s) {\\n        \\n        int n = s.length();\\n        stack<int> st;\\n        st.push(-1);\\n        int len = 0;\\n        int maxlen =0;\\n        for(int i =0;i<n;i++)\\n        {\\n            if(s[i] == \\'(\\')\\n                st.push(i);\\n            if(s[i] == \\')\\')\\n            {\\n                st.pop();\\n                if(st.empty())\\n                    st.push(i);\\n                len = i - st.top();\\n                maxlen = max(maxlen,len);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1428168,
                "title": "c-simple-and-short-stack-solution-with-explanation",
                "content": "**Idea:**\\nWe use a stack to store the un-matched parentheses indices, and keep `last` for the end of the last valid string.\\nWe iterate through the string.\\nIf we find a `(`, we push the index to the stack.\\nIf we find a `)`: If we have elements in the stack - We pop the last element, don\\'t need it.\\nNow, we calculate the length from the previous element until the current one, and store in `res` the maximum.\\nIf we have the previous element in the stack, we use it, Otherwise we use `prev`.\\nIf the stack is empty, we save `i` in `prev`.\\n**Time Complecity:** O(n)\\n**Space Complexity:** O(n)\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> stk;\\n        int res = 0, prev = -1;\\n        \\n        for (int i = 0; i < s.size(); i++) {\\n            \\n           if (s[i] == \\'(\\') stk.push(i);\\n            \\n            else {\\n                if (!stk.empty()) {\\n                    stk.pop();\\n                    if (stk.empty()) res = max(res, i - prev);\\n                    else res = max(res, i - stk.top()); \\n                }\\n                else prev = i;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> stk;\\n        int res = 0, prev = -1;\\n        \\n        for (int i = 0; i < s.size(); i++) {\\n            \\n           if (s[i] == \\'(\\') stk.push(i);\\n            \\n            else {\\n                if (!stk.empty()) {\\n                    stk.pop();\\n                    if (stk.empty()) res = max(res, i - prev);\\n                    else res = max(res, i - stk.top()); \\n                }\\n                else prev = i;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1184258,
                "title": "c-python-o-n-solution-using-stack-dp",
                "content": "# Using Stack\\n1. C++\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int i, n = s.size(), ans = 0;\\n        stack<int> st = {};\\n        \\n        for(i = 0; i < n; i++){\\n            if (s[i] != \\')\\')\\n                st.push(i);\\n            else{\\n                if (st.empty()){\\n                    st.push(i);\\n                    continue;\\n                }\\n                if (s[st.top()] == \\'(\\' && s[i] == \\')\\'){\\n                    st.pop();\\n                    ans = !st.empty() ? max(ans, i - st.top()) : max(ans, i + 1);\\n                }\\n                else\\n                    st.push(i);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n2. Python\\n```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        ans = 0\\n        n = len(s)\\n        de = deque()\\n        \\n        for i in range(n):\\n            if s[i]!=\\')\\':\\n                de.append(i)\\n            else:\\n                if(len(de) == 0):\\n                    de.append(i)\\n                    continue\\n                if s[de[len(de) - 1]] == \\'(\\' and s[i] == \\')\\':\\n                    de.pop()\\n                    ans = max(ans, i - de[len(de) - 1]) if len(de) != 0 else max(ans, i + 1)\\n                else:\\n                    de.append(i)\\n        \\n        return ans\\n```\\n\\n# Using DP\\n```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        n = len(s)\\n        dp = [0] * n\\n        ans = 0\\n        \\n        for i in range(1,n):\\n            if s[i] == \\')\\' and s[i - 1] == \\'(\\':\\n                dp[i] = dp[i-2] + 2;\\n            elif s[i] == \\')\\' and s[i - 1] == \\')\\' and i - dp[i - 1] - 1 >= 0 and s[i - dp[i - 1] - 1] == \\'(\\':\\n                dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2;\\n            ans = max(ans, dp[i])\\n        \\n        return ans\\n```\\n**PS: Please upvote if you liked the solution.**",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int i, n = s.size(), ans = 0;\\n        stack<int> st = {};\\n        \\n        for(i = 0; i < n; i++){\\n            if (s[i] != \\')\\')\\n                st.push(i);\\n            else{\\n                if (st.empty()){\\n                    st.push(i);\\n                    continue;\\n                }\\n                if (s[st.top()] == \\'(\\' && s[i] == \\')\\'){\\n                    st.pop();\\n                    ans = !st.empty() ? max(ans, i - st.top()) : max(ans, i + 1);\\n                }\\n                else\\n                    st.push(i);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        ans = 0\\n        n = len(s)\\n        de = deque()\\n        \\n        for i in range(n):\\n            if s[i]!=\\')\\':\\n                de.append(i)\\n            else:\\n                if(len(de) == 0):\\n                    de.append(i)\\n                    continue\\n                if s[de[len(de) - 1]] == \\'(\\' and s[i] == \\')\\':\\n                    de.pop()\\n                    ans = max(ans, i - de[len(de) - 1]) if len(de) != 0 else max(ans, i + 1)\\n                else:\\n                    de.append(i)\\n        \\n        return ans\\n```\n```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        n = len(s)\\n        dp = [0] * n\\n        ans = 0\\n        \\n        for i in range(1,n):\\n            if s[i] == \\')\\' and s[i - 1] == \\'(\\':\\n                dp[i] = dp[i-2] + 2;\\n            elif s[i] == \\')\\' and s[i - 1] == \\')\\' and i - dp[i - 1] - 1 >= 0 and s[i - dp[i - 1] - 1] == \\'(\\':\\n                dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2;\\n            ans = max(ans, dp[i])\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1142701,
                "title": "c-solution-with-stack",
                "content": "```\\n// Runtime: 4 ms, faster than 80.88% of C++ online submissions for Longest Valid Parentheses.\\n// Memory Usage: 7.3 MB, less than 21.73% of C++ online submissions for Longest Valid Parentheses.\\nint longestValidParentheses(string s) {\\n\\tint res = 0;\\n\\tstack<int> st; // stores indexes\\n\\tfor (int i = 0; i < s.size(); i++) {\\n\\t\\tif (s[i] == \\'(\\')\\n\\t\\t\\tst.push(i);\\n\\t\\telse {\\n\\t\\t\\tif (!st.empty() && s[st.top()] == \\'(\\') {\\n\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\tres = max(res, st.empty() ? i + 1 : i - st.top());\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tst.push(i);\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n// Runtime: 4 ms, faster than 80.88% of C++ online submissions for Longest Valid Parentheses.\\n// Memory Usage: 7.3 MB, less than 21.73% of C++ online submissions for Longest Valid Parentheses.\\nint longestValidParentheses(string s) {\\n\\tint res = 0;\\n\\tstack<int> st; // stores indexes\\n\\tfor (int i = 0; i < s.size(); i++) {\\n\\t\\tif (s[i] == \\'(\\')\\n\\t\\t\\tst.push(i);\\n\\t\\telse {\\n\\t\\t\\tif (!st.empty() && s[st.top()] == \\'(\\') {\\n\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\tres = max(res, st.empty() ? i + 1 : i - st.top());\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tst.push(i);\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1140452,
                "title": "python-no-dp-no-stack-o-n",
                "content": "Logic: Counting left and right parenthesis\\n```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        m = left = right = 0\\n        \\n        for i in s:\\n            if i==\\'(\\':\\n                left += 1\\n            else:\\n                right += 1\\n            if left == right:\\n                m = max(m, right+left)\\n            elif right>left :\\n                left = right = 0\\n                \\n        left = right=0\\n        \\n        for i in s[::-1]:\\n            if i ==\\')\\':\\n                right += 1\\n            else:\\n                left += 1\\n            if left == right:\\n                m = max(m,right+left )\\n            elif left >right:\\n                left =right=0\\n\\n        return m\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        m = left = right = 0\\n        \\n        for i in s:\\n            if i==\\'(\\':\\n                left += 1\\n            else:\\n                right += 1\\n            if left == right:\\n                m = max(m, right+left)\\n            elif right>left :\\n                left = right = 0\\n                \\n        left = right=0\\n        \\n        for i in s[::-1]:\\n            if i ==\\')\\':\\n                right += 1\\n            else:\\n                left += 1\\n            if left == right:\\n                m = max(m,right+left )\\n            elif left >right:\\n                left =right=0\\n\\n        return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 954563,
                "title": "java-recursive-tle-memoization-bottom-up-array",
                "content": "```\\n- For each of the index \\'i\\'\\n\\t- If the current character is \\')\\', then the longest valid parentheses substring is equal to 0\\n\\t- If the current character is \\'(\\'\\n\\t\\t- We will first need to find the longest valid parentheses substring \\'length\\' starting at \\'i + 1\\'\\n\\t\\t- If the character at \\'i + length + 1\\' is equal to \\')\\'\\n\\t\\t\\t- Then we know we can form a valid parentheses substring from index \\'i\\'\\n\\t\\t\\t- We will then need to continue our search for valid parentheses substrings from \\'i + length + 2\\'\\n- We will take the longest length for valid parentheses out of all indices \\'i\\'\\n```\\n```\\npublic class LongestValidParenthesesRecursiveApproach {\\n    public int longestValidParentheses(String s) {\\n        int maxLength = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            maxLength = Math.max(maxLength, longestValidParentheses(i, s));\\n        }\\n\\n        return maxLength;\\n    }\\n\\n    private int longestValidParentheses(int i, String s) {\\n        if (i >= s.length() || s.charAt(i) == \\')\\') return 0;\\n\\n        int length1 = longestValidParentheses(i + 1, s);\\n        int x = i + length1 + 1;\\n\\n        if (x < s.length() && s.charAt(x) == \\')\\') {\\n            return length1 + longestValidParentheses(x + 1, s) + 2;\\n        }\\n\\n        return 0;\\n    }\\n}\\n```\\n```\\npublic class LongestValidParenthesesMemoizationApproach {\\n    public int longestValidParentheses(String s) {\\n        int[] memo = new int[s.length()];\\n        Arrays.fill(memo, -1);\\n        int maxLength = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            maxLength = Math.max(maxLength, longestValidParentheses(i, s, memo));\\n        }\\n\\n        return maxLength;\\n    }\\n\\n    private int longestValidParentheses(int i, String s, int[] memo) {\\n        if (i >= s.length() || s.charAt(i) == \\')\\') return 0;\\n        if (memo[i] != -1) return memo[i];\\n\\n        int length1 = longestValidParentheses(i + 1, s, memo);\\n        int x = i + length1 + 1;\\n\\n        if (x < s.length() && s.charAt(x) == \\')\\') {\\n            return memo[i] = length1 + longestValidParentheses(x + 1, s, memo) + 2;\\n        }\\n\\n        return memo[i] = 0;\\n    }\\n}\\n```\\n```\\npublic class LongestValidParenthesesBottomUp1DApproach {\\n    public int longestValidParentheses(String s) {\\n        int[] length = new int[s.length() + 1];\\n        int maxLength = 0;\\n\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            if (s.charAt(i) == \\')\\') continue;\\n\\n            int x = i + length[i + 1] + 1;\\n\\n            if (x < s.length() && s.charAt(x) == \\')\\') {\\n                length[i] = length[i + 1] + length[x + 1] + 2;\\n            }\\n\\n            maxLength = Math.max(maxLength, length[i]);\\n        }\\n\\n        return maxLength;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n- For each of the index \\'i\\'\\n\\t- If the current character is \\')\\', then the longest valid parentheses substring is equal to 0\\n\\t- If the current character is \\'(\\'\\n\\t\\t- We will first need to find the longest valid parentheses substring \\'length\\' starting at \\'i + 1\\'\\n\\t\\t- If the character at \\'i + length + 1\\' is equal to \\')\\'\\n\\t\\t\\t- Then we know we can form a valid parentheses substring from index \\'i\\'\\n\\t\\t\\t- We will then need to continue our search for valid parentheses substrings from \\'i + length + 2\\'\\n- We will take the longest length for valid parentheses out of all indices \\'i\\'\\n```\n```\\npublic class LongestValidParenthesesRecursiveApproach {\\n    public int longestValidParentheses(String s) {\\n        int maxLength = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            maxLength = Math.max(maxLength, longestValidParentheses(i, s));\\n        }\\n\\n        return maxLength;\\n    }\\n\\n    private int longestValidParentheses(int i, String s) {\\n        if (i >= s.length() || s.charAt(i) == \\')\\') return 0;\\n\\n        int length1 = longestValidParentheses(i + 1, s);\\n        int x = i + length1 + 1;\\n\\n        if (x < s.length() && s.charAt(x) == \\')\\') {\\n            return length1 + longestValidParentheses(x + 1, s) + 2;\\n        }\\n\\n        return 0;\\n    }\\n}\\n```\n```\\npublic class LongestValidParenthesesMemoizationApproach {\\n    public int longestValidParentheses(String s) {\\n        int[] memo = new int[s.length()];\\n        Arrays.fill(memo, -1);\\n        int maxLength = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            maxLength = Math.max(maxLength, longestValidParentheses(i, s, memo));\\n        }\\n\\n        return maxLength;\\n    }\\n\\n    private int longestValidParentheses(int i, String s, int[] memo) {\\n        if (i >= s.length() || s.charAt(i) == \\')\\') return 0;\\n        if (memo[i] != -1) return memo[i];\\n\\n        int length1 = longestValidParentheses(i + 1, s, memo);\\n        int x = i + length1 + 1;\\n\\n        if (x < s.length() && s.charAt(x) == \\')\\') {\\n            return memo[i] = length1 + longestValidParentheses(x + 1, s, memo) + 2;\\n        }\\n\\n        return memo[i] = 0;\\n    }\\n}\\n```\n```\\npublic class LongestValidParenthesesBottomUp1DApproach {\\n    public int longestValidParentheses(String s) {\\n        int[] length = new int[s.length() + 1];\\n        int maxLength = 0;\\n\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            if (s.charAt(i) == \\')\\') continue;\\n\\n            int x = i + length[i + 1] + 1;\\n\\n            if (x < s.length() && s.charAt(x) == \\')\\') {\\n                length[i] = length[i + 1] + length[x + 1] + 2;\\n            }\\n\\n            maxLength = Math.max(maxLength, length[i]);\\n        }\\n\\n        return maxLength;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 575579,
                "title": "dynamic-programming-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        vector<int> dp(s.size()+1,0);\\n        for(int i=1;i<s.size();i++){\\n            if(s[i]==\\')\\'){\\n                if(s[i-1]==\\'(\\'){\\n                    dp[i]=((i-2)>=0 ? dp[i-2] : 0) +2;\\n                }\\n                else{\\n                    if((i-dp[i-1])>0 && s[i-dp[i-1]-1]==\\'(\\'){\\n                        dp[i]=dp[i-1]+2+((i-dp[i-1]-2)>=0 ? dp[i-dp[i-1]-2] : 0);\\n                    }\\n                }\\n                //cout<<dp[i]<<\" \";\\n            }\\n        }\\n        return *max_element(dp.begin(),dp.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        vector<int> dp(s.size()+1,0);\\n        for(int i=1;i<s.size();i++){\\n            if(s[i]==\\')\\'){\\n                if(s[i-1]==\\'(\\'){\\n                    dp[i]=((i-2)>=0 ? dp[i-2] : 0) +2;\\n                }\\n                else{\\n                    if((i-dp[i-1])>0 && s[i-dp[i-1]-1]==\\'(\\'){\\n                        dp[i]=dp[i-1]+2+((i-dp[i-1]-2)>=0 ? dp[i-dp[i-1]-2] : 0);\\n                    }\\n                }\\n                //cout<<dp[i]<<\" \";\\n            }\\n        }\\n        return *max_element(dp.begin(),dp.end());\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 451674,
                "title": "python-linear-scan-98-100",
                "content": "```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:        \\n        res, left, right = 0, 0, 0\\n        for i in range(len(s)): # forward scan\\n            if s[i] == \\'(\\':\\n                left += 1\\n            else: # case \\')\\'\\n                right += 1\\n                if right > left:\\n                    left, right = 0, 0\\n                elif left == right:\\n                    res = max(left+right, res)\\n        \\n        left, right = 0, 0\\n        for i in reversed(range(len(s))): # backward scan\\n            if s[i] == \\')\\':\\n                right += 1\\n            else: # case \\'(\\'\\n                left += 1\\n                if left > right:\\n                    left, right = 0, 0\\n                elif left == right:\\n                    res = max(left+right, res)\\n                    \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:        \\n        res, left, right = 0, 0, 0\\n        for i in range(len(s)): # forward scan\\n            if s[i] == \\'(\\':\\n                left += 1\\n            else: # case \\')\\'\\n                right += 1\\n                if right > left:\\n                    left, right = 0, 0\\n                elif left == right:\\n                    res = max(left+right, res)\\n        \\n        left, right = 0, 0\\n        for i in reversed(range(len(s))): # backward scan\\n            if s[i] == \\')\\':\\n                right += 1\\n            else: # case \\'(\\'\\n                left += 1\\n                if left > right:\\n                    left, right = 0, 0\\n                elif left == right:\\n                    res = max(left+right, res)\\n                    \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 269017,
                "title": "java-7ms-solution-with-stack",
                "content": "```len[i]```  is the length of longest valid substring which ends at the ```ith``` element of ```s```.  \\nApparently, if ```s[i] == \\'(\\'``` then ```len[i] = 0``` . If ```s[i] == \\')\\'```, we calculate ```len[i]``` under the help of stack.\\n\\n```\\npublic int longestValidParentheses(String s) {\\n\\tStack<Integer> stack = new Stack<Integer>();\\n\\tint len[] = new int[s.length()];\\n\\tint max = 0;\\n\\tfor(int i = 0; i < s.length(); i++) {\\n\\t\\tif( s.charAt(i) == \\'(\\' )\\n\\t\\t\\tstack.push(i);\\n\\t\\telse if( !stack.isEmpty() ) {\\n\\t\\t\\tlen[i] = i - stack.peek() + 1; // Currently,len[i] only reprensents the distance between s[i] and its pair \\'(\\'\\n\\t\\t\\tlen[i] += stack.peek() > 0 ? len[stack.peek() - 1] : 0; // plus the length of longest valid substring which ends at the previous element of pair \\'(\\'\\n\\t\\t\\tmax = Math.max(len[i], max);\\n\\t\\t\\tstack.pop();\\n\\t\\t}\\n\\t}\\n\\treturn max;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```len[i]```\n```ith```\n```s```\n```s[i] == \\'(\\'```\n```len[i] = 0```\n```s[i] == \\')\\'```\n```len[i]```\n```\\npublic int longestValidParentheses(String s) {\\n\\tStack<Integer> stack = new Stack<Integer>();\\n\\tint len[] = new int[s.length()];\\n\\tint max = 0;\\n\\tfor(int i = 0; i < s.length(); i++) {\\n\\t\\tif( s.charAt(i) == \\'(\\' )\\n\\t\\t\\tstack.push(i);\\n\\t\\telse if( !stack.isEmpty() ) {\\n\\t\\t\\tlen[i] = i - stack.peek() + 1; // Currently,len[i] only reprensents the distance between s[i] and its pair \\'(\\'\\n\\t\\t\\tlen[i] += stack.peek() > 0 ? len[stack.peek() - 1] : 0; // plus the length of longest valid substring which ends at the previous element of pair \\'(\\'\\n\\t\\t\\tmax = Math.max(len[i], max);\\n\\t\\t\\tstack.pop();\\n\\t\\t}\\n\\t}\\n\\treturn max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 229774,
                "title": "c-well-commented-solution-using-stack",
                "content": "```\\n/* Idea borrowed from https://leetcode.com/problems/longest-valid-parentheses/discuss/14126/My-O(n)-solution-using-a-stack  */\\n\\n\\n\\nclass Solution\\n{\\npublic:\\n    int longestValidParentheses(string s);\\n};\\n\\n/* Returns the length of teh longest valid parenthesis */\\nint Solution :: longestValidParentheses(string str)\\n{\\n    // Idea ---- Traverse the stack and store the indices which are not matched\\n    // Get the largest length b/w consecutive indices\\n    \\n    // string length\\n    int n = str.length();\\n    stack<int> indexStack;\\n    \\n    \\n    // Traverse and remove all the valid indices\\n    for(int i=0; i<n; i++)\\n    {\\n        // if it opening bracket,just push it\\n        if(str[i]==\\'(\\') indexStack.push(i);\\n        \\n        // Else it is a closing bracket\\n        else if(str[i]==\\')\\')\\n        {\\n             // If Stack is empty, then it is unmatched index\\n            if(indexStack.empty()) indexStack.push(i);\\n            \\n            // Else If stack is not empty, check if it contains the matching bracket on top or not\\n            else \\n            {\\n                // If the bracket is valid pop it\\n                if( str[indexStack.top()] == \\'(\\') indexStack.pop();\\n            \\n                // else We have another invalid parenthesis\\n                else indexStack.push(i);\\n            }\\n        }\\n    }\\n    \\n    // If the stack is empty, the whole string is balanced\\n    if(indexStack.empty()) return n;\\n    \\n    // Assume that the string consisted of one extra character, which is of course mismatched\\n    int rightIndex = n;\\n    int leftIndex = 0;\\n    int maxLength = 0;\\n    \\n    \\n    /* A tricky test case. What if in a long string only the last index is inavlid? */\\n    /* ()) Stack would become empty in one go, if you do it naively without updating */\\n    \\n    // Find the largest gap in between\\n    while(!indexStack.empty())\\n    {\\n        // Store the left index\\n        int leftIndex = indexStack.top();\\n        indexStack.pop();\\n        \\n        // The number of elements in [l,r] is r-l+1\\n        // The number of elements strictly b/w l and r is r-l+1-2 = r-l-1\\n        int midLength = rightIndex - leftIndex - 1;\\n        \\n        //update the max length\\n        maxLength = max(maxLength, midLength);\\n        \\n        // update the right index\\n        rightIndex = leftIndex;\\n        \\n        // Check if it was the last element. If it is, it is never coming back to the loop again\\n        // Set the lower index as -1 (Invalid) and update the max now \\n        if(indexStack.empty())\\n        {\\n            leftIndex = -1;\\n            midLength = rightIndex - leftIndex - 1;\\n            maxLength = max(maxLength, midLength);\\n        }\\n    }\\n    \\n    \\n    return maxLength;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/* Idea borrowed from https://leetcode.com/problems/longest-valid-parentheses/discuss/14126/My-O(n)-solution-using-a-stack  */\\n\\n\\n\\nclass Solution\\n{\\npublic:\\n    int longestValidParentheses(string s);\\n};\\n\\n/* Returns the length of teh longest valid parenthesis */\\nint Solution :: longestValidParentheses(string str)\\n{\\n    // Idea ---- Traverse the stack and store the indices which are not matched\\n    // Get the largest length b/w consecutive indices\\n    \\n    // string length\\n    int n = str.length();\\n    stack<int> indexStack;\\n    \\n    \\n    // Traverse and remove all the valid indices\\n    for(int i=0; i<n; i++)\\n    {\\n        // if it opening bracket,just push it\\n        if(str[i]==\\'(\\') indexStack.push(i);\\n        \\n        // Else it is a closing bracket\\n        else if(str[i]==\\')\\')\\n        {\\n             // If Stack is empty, then it is unmatched index\\n            if(indexStack.empty()) indexStack.push(i);\\n            \\n            // Else If stack is not empty, check if it contains the matching bracket on top or not\\n            else \\n            {\\n                // If the bracket is valid pop it\\n                if( str[indexStack.top()] == \\'(\\') indexStack.pop();\\n            \\n                // else We have another invalid parenthesis\\n                else indexStack.push(i);\\n            }\\n        }\\n    }\\n    \\n    // If the stack is empty, the whole string is balanced\\n    if(indexStack.empty()) return n;\\n    \\n    // Assume that the string consisted of one extra character, which is of course mismatched\\n    int rightIndex = n;\\n    int leftIndex = 0;\\n    int maxLength = 0;\\n    \\n    \\n    /* A tricky test case. What if in a long string only the last index is inavlid? */\\n    /* ()) Stack would become empty in one go, if you do it naively without updating */\\n    \\n    // Find the largest gap in between\\n    while(!indexStack.empty())\\n    {\\n        // Store the left index\\n        int leftIndex = indexStack.top();\\n        indexStack.pop();\\n        \\n        // The number of elements in [l,r] is r-l+1\\n        // The number of elements strictly b/w l and r is r-l+1-2 = r-l-1\\n        int midLength = rightIndex - leftIndex - 1;\\n        \\n        //update the max length\\n        maxLength = max(maxLength, midLength);\\n        \\n        // update the right index\\n        rightIndex = leftIndex;\\n        \\n        // Check if it was the last element. If it is, it is never coming back to the loop again\\n        // Set the lower index as -1 (Invalid) and update the max now \\n        if(indexStack.empty())\\n        {\\n            leftIndex = -1;\\n            midLength = rightIndex - leftIndex - 1;\\n            maxLength = max(maxLength, midLength);\\n        }\\n    }\\n    \\n    \\n    return maxLength;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 180397,
                "title": "my-python-beating-99-6-with-o-n",
                "content": "```\\nclass Solution:\\n    def longestValidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        l = len(s)\\n        \\n        # \\u626B\\u63CF\\u4E00\\u904D\\uFF0C\\u6784\\u9020\\u4E00\\u4E2A\\u6808\\uFF0C\\u6700\\u540E\\u53EA\\u5269\\u4E0B\\u5339\\u914D\\u4E0D\\u4E0A\\u7684\\u7D22\\u5F15\\n        stack = []\\n        for i in range(l):\\n            if s[i] == \\')\\' and stack and s[stack[-1]] == \\'(\\':\\n                stack.pop()\\n            else:\\n                stack.append(i)\\n        # \\u4E0D\\u5728\\u6808\\u5185\\u7684\\u7D22\\u5F15\\u662F\\u53EF\\u4EE5\\u5339\\u914D\\u4E0A\\u7684\\uFF0C\\u76F8\\u90BB\\u7D22\\u5F15\\u4E4B\\u95F4\\u7684\\u5B50\\u4E32\\u4E3A\\u6709\\u6548\\u5B50\\u4E32\\n        if not stack:\\n            return l\\n        stack.insert(0, -1)\\n        stack.append(l)\\n        return max(stack[i+1]-stack[i]-1 for i in range(len(stack)-1))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestValidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        l = len(s)\\n        \\n        # \\u626B\\u63CF\\u4E00\\u904D\\uFF0C\\u6784\\u9020\\u4E00\\u4E2A\\u6808\\uFF0C\\u6700\\u540E\\u53EA\\u5269\\u4E0B\\u5339\\u914D\\u4E0D\\u4E0A\\u7684\\u7D22\\u5F15\\n        stack = []\\n        for i in range(l):\\n            if s[i] == \\')\\' and stack and s[stack[-1]] == \\'(\\':\\n                stack.pop()\\n            else:\\n                stack.append(i)\\n        # \\u4E0D\\u5728\\u6808\\u5185\\u7684\\u7D22\\u5F15\\u662F\\u53EF\\u4EE5\\u5339\\u914D\\u4E0A\\u7684\\uFF0C\\u76F8\\u90BB\\u7D22\\u5F15\\u4E4B\\u95F4\\u7684\\u5B50\\u4E32\\u4E3A\\u6709\\u6548\\u5B50\\u4E32\\n        if not stack:\\n            return l\\n        stack.insert(0, -1)\\n        stack.append(l)\\n        return max(stack[i+1]-stack[i]-1 for i in range(len(stack)-1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14210,
                "title": "python-o-n-solution-with-2-passes-sliding-window-no-stack-or-dp-needed",
                "content": "```\\nclass Solution(object):\\n    def longestValidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        longest = 0\\n        start = 0\\n        n = 0\\n        \\n        for i, p in enumerate(s):\\n            if p == \"(\":\\n                n += 1\\n            else: # p == \")\"\\n                n -= 1\\n            \\n            if n < 0:\\n                start = i + 1\\n                n = 0\\n            elif n == 0:\\n                longest = max(longest, i+1-start)\\n\\n        start = 0\\n        n = 0\\n        for i, p in enumerate(s[::-1]):\\n            if p == \"(\":\\n                n -= 1\\n            else: # p == \")\"\\n                n += 1\\n            \\n            if n < 0:\\n                start = i + 1\\n                n = 0\\n            elif n == 0:\\n                longest = max(longest, i+1-start)\\n\\n        return longest\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def longestValidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        longest = 0\\n        start = 0\\n        n = 0\\n        \\n        for i, p in enumerate(s):\\n            if p == \"(\":\\n                n += 1\\n            else: # p == \")\"\\n                n -= 1\\n            \\n            if n < 0:\\n                start = i + 1\\n                n = 0\\n            elif n == 0:\\n                longest = max(longest, i+1-start)\\n\\n        start = 0\\n        n = 0\\n        for i, p in enumerate(s[::-1]):\\n            if p == \"(\":\\n                n -= 1\\n            else: # p == \")\"\\n                n += 1\\n            \\n            if n < 0:\\n                start = i + 1\\n                n = 0\\n            elif n == 0:\\n                longest = max(longest, i+1-start)\\n\\n        return longest\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14208,
                "title": "concise-one-pass-dp-solution-without-stack",
                "content": "left: remaining left parentheses that haven't been paired.\\nDP[i + 1]: longest paired parentheses ended at index i. (i from 0 to size - 1)\\n\\nOnce we met a ')' and have unpaired '(', increase the length by 2 based on the previous DP value. The trick is that the newly generated length may not be the final DP value. \\n\\nFor the following example : '(()())', note that DP index start from 1, not 0.\\n\\nSuppose we just met the second ')', DP[5] = DP[4] + 2 = 0 + 2 = 2.\\nNow we should go back to the first ')' to check if there are previously matched string. If yes, add them up.\\nThus, DP[5] += DP[5 - DP[5]] \\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int size = (int)s.size();\\n        vector<int> DP(size + 1, 0);\\n        int left = 0, longest = 0;\\n        for(int i = 0; i < size; ++i){\\n            if(s[i] == '('){\\n                left++;\\n            }else if(s[i] == ')' && left > 0){\\n                DP[i + 1] = DP[i] + 2;\\n                DP[i + 1] += DP[i + 1 - DP[i + 1]];\\n                left--;\\n            }\\n            longest = max(longest, DP[i + 1]);\\n        }\\n        return longest;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int size = (int)s.size();\\n        vector<int> DP(size + 1, 0);\\n        int left = 0, longest = 0;\\n        for(int i = 0; i < size; ++i){\\n            if(s[i] == '('){\\n                left++;\\n            }else if(s[i] == ')' && left > 0){\\n                DP[i + 1] = DP[i] + 2;\\n                DP[i + 1] += DP[i + 1 - DP[i + 1]];\\n                left--;\\n            }\\n            longest = max(longest, DP[i + 1]);\\n        }\\n        return longest;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14244,
                "title": "very-direct-dp-solution-clean-and-efficient-besides-it-s-beautifully-explained",
                "content": "\\nSearching for the equation is always the key in DP problem, in this problem we are about to suppose the longest till the `current`,\\n> maxSub[len] = {0};\\n \\nalways stick this in mind before reading the following code.\\n\\nOnce we encounter a closing bracket `)` then we check its previous `longest` valid parentheses and try to find its corresponding open bracket `(`\\n\\n> int t = i-maxSub[i-1]\\n\\nto check whether there is a `corresponding` open bracket `(`\\n\\n> if(t>0 && s[t-1] == '(')\\n\\nif there is, then we should retrieve the `longest` for the current closing bracket `)`\\n\\n> maxSub[i] = (t>1? maxSub[t-2] : 0)+maxSub[i-1]+2;\\n\\nat last, we update the global longest and there. \\n\\nWe're done the job easily and beautifully.\\n\\n**Enjoy your day...**\\n\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        int len = s.length(), longest = 0;\\n        if(!len) return 0;\\n        int maxSub[len] = {0};\\n        for(int i = 0; i < len; ++i)\\n        {\\n            if(s[i] == ')')\\n            {\\n                int t = i-maxSub[i-1];\\n                if(t>0 && s[t-1] == '(') maxSub[i] = (t>1? maxSub[t-2] : 0)+maxSub[i-1]+2;\\n                longest = max(longest, maxSub[i]);\\n            }\\n        }\\n        return longest;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        int len = s.length(), longest = 0;\\n        if(!len) return 0;\\n        int maxSub[len] = {0};\\n        for(int i = 0; i < len; ++i)\\n        {\\n            if(s[i] == ')')\\n            {\\n                int t = i-maxSub[i-1];\\n                if(t>0 && s[t-1] == '(') maxSub[i] = (t>1? maxSub[t-2] : 0)+maxSub[i-1]+2;\\n                longest = max(longest, maxSub[i]);\\n            }\\n        }\\n        return longest;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14259,
                "title": "8ms-c-simple-dp-solution",
                "content": "    class Solution {\\n    public:\\n        int longestValidParentheses(string s) {\\n            size_t numLefts = 0, maxLen = 0;\\n            vector<size_t> f(s.size(), 0);\\n            for(size_t i = 0;i < s.size();++i){\\n                if(s[i] == '(')\\n                    ++numLefts;\\n                else if(numLefts > 0){\\n                    --numLefts;\\n                    f[i] = f[i - 1] + 2;\\n                    int prev = i - f[i];\\n                    if(prev > 0)\\n                        f[i] += f[prev];\\n                    maxLen = max(maxLen, f[i]);\\n                }\\n            }\\n            return maxLen;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int longestValidParentheses(string s) {\\n            size_t numLefts = 0, maxLen = 0;\\n            vector<size_t> f(s.size(), 0);\\n            for(size_t i = 0;i < s.size();++i){\\n                if(s[i] == '(')\\n                    ++numLefts;\\n                else if(numLefts > 0){\\n                    --numLefts;\\n                    f[i] = f[i - 1] + 2;\\n                    int prev = i - f[i];\\n                    if(prev > 0)\\n                        f[i] += f[prev];\\n                    maxLen = max(maxLen, f[i]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 14313,
                "title": "java-solution-12ms-structure-simple-and-clear-o-n",
                "content": "    public int longestValidParentheses(String s) {\\n        //use to record how many token left in the stack\\n        int left =0;\\n        //use to record how many left Parentheses in the stack\\n        Stack<Integer> stack = new Stack<>();\\n        //record the max length\\n        int max=0;\\n        for(int index=0; index<s.length(); index++){\\n            Character ch = s.charAt(index);\\n            if(ch=='('){//put the char into the stack directly\\n                stack.push(index);\\n            }\\n            else{\\n                if(stack.isEmpty()){\\n                    //add the left char directly, as this char will never be matched\\n                    left=index+1;\\n                }\\n                else{\\n                    //there have left parentheses in the stack canbe paired\\n                    stack.pop();\\n                    if(stack.isEmpty()){\\n                        max = Math.max(max, index-left+1);\\n                    }\\n                    else{\\n                        max = Math.max(max, index-stack.peek());\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int longestValidParentheses(String s) {\\n        //use to record how many token left in the stack\\n        int left =0;\\n        //use to record how many left Parentheses in the stack\\n        Stack<Integer> stack = new Stack<>();\\n        //record the max length\\n        int max=0;\\n        for(int index=0; index<s.length(); index++){\\n            Character ch = s.charAt(index);\\n            if(ch=='('){//put the char into the stack directly\\n                stack.push(index);\\n            }\\n            else{\\n                if(stack.isEmpty()){\\n                    //add the left char directly, as this char will never be matched\\n                    left=index+1;\\n                }\\n                else{\\n                    //there have left parentheses in the stack canbe paired\\n                    stack.pop();\\n                    if(stack.isEmpty()){\\n                        max = Math.max(max, index-left+1);\\n                    }\\n                    else{\\n                        max = Math.max(max, index-stack.peek());\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 14324,
                "title": "c-o-n-easy-understand",
                "content": "    class Solution {\\n    public:\\n        int longestValidParentheses(string s) {\\n            stack<int> st;  st.push(0);\\n            int res = 0;\\n            for (int i=0; i<s.length(); i++) {\\n                if (s[i] == '(') {\\n                    st.push(i+1);\\n                } else {\\n                    st.pop();\\n                    if (st.size()) {\\n                        res = max(res, i + 1 - st.top());\\n                    } else {\\n                        st.push(i+1);\\n                    }\\n                }   \\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int longestValidParentheses(string s) {\\n            stack<int> st;  st.push(0);\\n            int res = 0;\\n            for (int i=0; i<s.length(); i++) {\\n                if (s[i] == '(') {\\n                    st.push(i+1);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 14352,
                "title": "a-simple-c-dp-solution-without-stack-8ms-in-8-lines",
                "content": "     1. dp[i] = {max(k) | s[i-k+1, i] is well formed. k=0 means empty}\\n     2. For char s[i], we should check the char s[i-1-dp[i-1]]. \\n      If s[i] and s[i-1-dp[i-1]] are matched, substring from  i-1-dp[i-1] to i is well formed. \\n      Then, we should joint it with previous well formed substring which ends at s[i-1-dp[i-1]-1].\\n    \\n     int longestValidParentheses(string s) {\\n                vector<int> dp(s.length(),0);\\n                int res = 0;\\n                for(int i=1; i<s.length(); ++i)\\n                    if(s[i]==')' && i-1-dp[i-1]>=0 &&s[i-1-dp[i-1]]=='('){\\n                        if(i-1-dp[i-1]-1 >= 0) dp[i]= dp[i-1]+2+dp[i-1-dp[i-1]-1];\\n                        else  dp[i]= dp[i-1]+2;\\n                        res = max(res, dp[i]);\\n                    }\\n                return res;\\n            }",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "     1. dp[i] = {max(k) | s[i-k+1, i] is well formed. k=0 means empty}\\n     2. For char s[i], we should check the char s[i-1-dp[i-1]]. \\n      If s[i] and s[i-1-dp[i-1]] are matched, substring from  i-1-dp[i-1] to i is well formed. \\n      Then, we should joint it with previous well formed substring which ends at s[i-1-dp[i-1]-1].\\n    \\n     int longestValidParentheses(string s) {\\n                vector<int> dp(s.length(),0);\\n                int res = 0;\\n                for(int i=1; i<s.length(); ++i)\\n                    if(s[i]==')' && i-1-dp[i-1]>=0 &&s[i-1-dp[i-1]]=='('){\\n                        if(i-1-dp[i-1]-1 >= 0) dp[i]= dp[i-1]+2+dp[i-1-dp[i-1]-1];\\n                        else  dp[i]= dp[i-1]+2;\\n                        res = max(res, dp[i]);\\n                    }\\n                return res;\\n            }",
                "codeTag": "Unknown"
            },
            {
                "id": 14353,
                "title": "o-n-in-time-o-1-in-space",
                "content": "Could there be better improvements on this?\\n\\n    public class Solution {\\n        public int longestValidParentheses(String s) {\\n        \\tint length = 0;\\n            int score = 0;\\n            int start = 0;\\n            int cur = 0;\\n            int bound;\\n            \\n            while (cur < s.length()) {\\n                score += (s.charAt(cur) == '(') ? 1 : -1;\\n                \\n                if (score == 0) {\\n                    length = Math.max(length, cur - start + 1);            \\t\\n                } else if (score < 0) {\\n                    start = cur + 1;\\n                    score = 0;\\n                }\\n    \\n                ++cur;\\n            }\\n            \\n            if (score > 0) {\\n                bound = start - 1;\\n                cur = s.length() - 1;\\n                start = cur;\\n                score = 0;\\n                \\n                while (cur > bound) {\\n                    score += (s.charAt(cur) == ')') ? 1 : -1;\\n                    \\n                    if (score == 0) {\\n                        length = Math.max(length, start - cur + 1);            \\t\\n                    } else if (score < 0) {\\n                        start = cur - 1;\\n                        score = 0;\\n                    }\\n                    \\n                    --cur;\\n                }\\n            }\\n            \\n            return length;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int longestValidParentheses(String s) {\\n        \\tint length = 0;\\n            int score = 0;\\n            int start = 0;\\n            int cur = 0;\\n            int bound;\\n            \\n            while (cur < s.length()) {\\n                score += (s.charAt(cur) == '(') ? 1 : -1;\\n                \\n                if (score == 0) {\\n                    length = Math.max(length, cur - start + 1);            \\t\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4030188,
                "title": "easy-java-solution-stack-basic-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n        if (s.length() == 0 || s.length() == 1) return 0;\\n\\n        int maxLen = 0;\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(-1);\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'(\\') {\\n                stack.push(i);\\n            } else {\\n                stack.pop();\\n                if (!stack.isEmpty()) {\\n                    maxLen = Math.max(maxLen, i - stack.peek());\\n                } else {\\n                    stack.push(i);\\n                }\\n            }\\n        }\\n        return maxLen;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n        if (s.length() == 0 || s.length() == 1) return 0;\\n\\n        int maxLen = 0;\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(-1);\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'(\\') {\\n                stack.push(i);\\n            } else {\\n                stack.pop();\\n                if (!stack.isEmpty()) {\\n                    maxLen = Math.max(maxLen, i - stack.peek());\\n                } else {\\n                    stack.push(i);\\n                }\\n            }\\n        }\\n        return maxLen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973342,
                "title": "c-solution-with-o-n-time-and-o-1-space",
                "content": "# Intuition\\nCheck valid parentheses from front as well as back and take the maximum of them.\\n\\n# Approach\\nTake single interger `stack` so that we do not have to use any extra space. And increate `stack` when we get a `(` and decrease when we get a `)`\\n\\nIf we get a `)` when `stack` is `0`, then it becomes an invalid parantheses.\\n\\nDo the same for backward direction but increase `stack` when we get a `)` and decrease when we get `(` and take the maximum of all the answers and return.\\n\\n# Complexity\\n- Time complexity:\\n`O(N)` - Doing two linear traverse from front and back\\n\\n- Space complexity:\\n`O(1)` - Not taking any extra spaces\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int lastInvalid = -1;\\n        int stack = 0;\\n        int ans = 0;\\n\\n        for(int i = 0; i < s.size(); i += 1) {\\n            if (s[i] == \\'(\\') {\\n                stack += 1;\\n            } else {\\n                if (stack == 0) {\\n                    lastInvalid = i;\\n                } else {\\n                    stack -= 1;\\n                    if (stack == 0) {\\n                        ans = max(ans, i - lastInvalid);\\n                    }\\n                }\\n            }\\n        }\\n    \\n        stack = 0;\\n        lastInvalid = s.size();\\n        for(int i = s.size() - 1; i >= 0; i -= 1) {\\n            if (s[i] == \\')\\') {\\n                stack += 1;\\n            } else {\\n                if (stack == 0) {\\n                    lastInvalid = i;\\n                } else {\\n                    stack -= 1;\\n                    if (stack == 0) {\\n                        ans = max(ans, lastInvalid - i);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int lastInvalid = -1;\\n        int stack = 0;\\n        int ans = 0;\\n\\n        for(int i = 0; i < s.size(); i += 1) {\\n            if (s[i] == \\'(\\') {\\n                stack += 1;\\n            } else {\\n                if (stack == 0) {\\n                    lastInvalid = i;\\n                } else {\\n                    stack -= 1;\\n                    if (stack == 0) {\\n                        ans = max(ans, i - lastInvalid);\\n                    }\\n                }\\n            }\\n        }\\n    \\n        stack = 0;\\n        lastInvalid = s.size();\\n        for(int i = s.size() - 1; i >= 0; i -= 1) {\\n            if (s[i] == \\')\\') {\\n                stack += 1;\\n            } else {\\n                if (stack == 0) {\\n                    lastInvalid = i;\\n                } else {\\n                    stack -= 1;\\n                    if (stack == 0) {\\n                        ans = max(ans, lastInvalid - i);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3758119,
                "title": "simple-c-stack-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        \\n        int ans=0;\\n        int t=0;\\n        stack<int> st;\\n      \\n        st.push(-1);\\n        \\n        for(auto i:s)\\n        {\\n            if(i==\\'(\\') {\\n                st.push(t);\\n                \\n            }\\n            else{\\n                if(!st.empty() && st.top()!=-1 && s[st.top()]==\\'(\\')\\n                {\\n                    st.pop();\\n                   \\n                    ans=max(ans,abs(t-st.top()));\\n                    \\n                }\\n                else st.push(t);\\n            }\\n            t++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        \\n        int ans=0;\\n        int t=0;\\n        stack<int> st;\\n      \\n        st.push(-1);\\n        \\n        for(auto i:s)\\n        {\\n            if(i==\\'(\\') {\\n                st.push(t);\\n                \\n            }\\n            else{\\n                if(!st.empty() && st.top()!=-1 && s[st.top()]==\\'(\\')\\n                {\\n                    st.pop();\\n                   \\n                    ans=max(ans,abs(t-st.top()));\\n                    \\n                }\\n                else st.push(t);\\n            }\\n            t++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603982,
                "title": "easy-c-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> st;\\n        st.push(-1);\\n        int maxlen=0;\\n        for(int i=0;i<s.length();i++){\\n            char ch=s[i];\\n            if(ch==\\'(\\')\\n                st.push(i);\\n            else{\\n                st.pop();\\n                if(st.empty())\\n                st.push(i);\\n                else{\\n                    int len=i-st.top();\\n                    maxlen=max(len,maxlen);\\n                }\\n            }\\n        }\\n        return maxlen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> st;\\n        st.push(-1);\\n        int maxlen=0;\\n        for(int i=0;i<s.length();i++){\\n            char ch=s[i];\\n            if(ch==\\'(\\')\\n                st.push(i);\\n            else{\\n                st.pop();\\n                if(st.empty())\\n                st.push(i);\\n                else{\\n                    int len=i-st.top();\\n                    maxlen=max(len,maxlen);\\n                }\\n            }\\n        }\\n        return maxlen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532224,
                "title": "easy-to-understand-approach-c-using-stacks",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf you have done Valid Parenthesis(Easy) Question, you will understand why I started with stacks.\\n\\nLink : https://leetcode.com/problems/valid-parentheses/\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a stack and push -1 into it\\n2. Now initialize ```maxLen = 0 ```\\n3. Iterate over string ``` s ``` and set``` ch = s[i] ```.\\n4. Now check ```if(ch == \\'(\\')``` then push ith element in the stack\\n5. Otherwise pop the stack.\\n6. Check if stack is empty or not.\\n7. For empty case, just push ith element.\\n8. Otherwise, set ```int len = i - st.top()``` \\n9. Now, compute ```maxLen``` and return it.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> st;\\n        st.push(-1);\\n        \\n        int maxLen = 0;\\n\\n        for(int i = 0; i < s.size(); i++) {\\n            char ch = s[i];\\n\\n            if(ch == \\'(\\') {\\n                st.push(i);\\n            }\\n\\n            else {\\n                st.pop();\\n                if(st.empty()) {\\n                    st.push(i);\\n                }\\n                else {\\n                    int len = i - st.top();\\n                    maxLen = max(len, maxLen);\\n                }\\n            }\\n        }\\n        return maxLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```maxLen = 0 ```\n``` s ```\n``` ch = s[i] ```\n```if(ch == \\'(\\')```\n```int len = i - st.top()```\n```maxLen```\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> st;\\n        st.push(-1);\\n        \\n        int maxLen = 0;\\n\\n        for(int i = 0; i < s.size(); i++) {\\n            char ch = s[i];\\n\\n            if(ch == \\'(\\') {\\n                st.push(i);\\n            }\\n\\n            else {\\n                st.pop();\\n                if(st.empty()) {\\n                    st.push(i);\\n                }\\n                else {\\n                    int len = i - st.top();\\n                    maxLen = max(len, maxLen);\\n                }\\n            }\\n        }\\n        return maxLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497599,
                "title": "easy-c-solution-using-stack",
                "content": "\\n# Approach:\\nTake a stack and push(-1) into it \\nthen we can do is check if s[i] is \" ( \" or not ,\\nif yes then push teh index \\'i\\' into it \\nif not then pop()\\n,if the stack is empty then push the \\'i\\' index \\nelse check the max of maxi, i-s.top()\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s)\\n    {\\n        stack<int>st;\\n        st.push(-1);\\n        int maxi=0;\\n        for(int i =0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                st.push(i);\\n            }\\n            else \\n            {\\n                st.pop();\\n                if(st.empty())\\n                {\\n                    st.push(i);\\n                }\\n                else\\n                {\\n                    maxi=max(maxi,i-st.top());\\n                }\\n            } \\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s)\\n    {\\n        stack<int>st;\\n        st.push(-1);\\n        int maxi=0;\\n        for(int i =0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                st.push(i);\\n            }\\n            else \\n            {\\n                st.pop();\\n                if(st.empty())\\n                {\\n                    st.push(i);\\n                }\\n                else\\n                {\\n                    maxi=max(maxi,i-st.top());\\n                }\\n            } \\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490138,
                "title": "java-solution-for-longest-valid-parenthesis-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this approach is that the stack helps to keep track of the unmatched open parentheses and their indices. By storing the indices, we can easily calculate the length of valid parentheses substrings when a matching close parenthesis is found\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize an empty stack.\\n- Iterate through the string s from index 0 to the end.\\n- If the current character is an open parenthesis \\'(\\', push an integer array containing the index and a value 0 (representing an open parenthesis) onto the stack.\\n- If the current character is a close parenthesis \\')\\', check if the stack is empty or if the top element of the stack has a value of 1 (representing a close parenthesis). If either condition is true, push an integer array containing the index and a value 1 (representing a close parenthesis) onto the stack.\\n- If the stack is not empty and the top element has a value of 0 (representing an open parenthesis), pop the top element from the stack. Calculate the length of the current valid parentheses substring and update the result with the maximum length found so far.\\n- Return the result after iterating through the entire string.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n), where n is the length of the string s. The algorithm iterates through the string once and performs constant-time operations for each character.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n), where n is the length of the string s. In the worst case, the stack may store all the characters of the string, resulting in a space complexity of O(n).\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n        Stack<int[]> stack = new Stack<int[]>();\\n        int result = 0;\\n        for(int i=0; i<=s.length()-1; i++)\\n        {\\n            char c = s.charAt(i);\\n            if(c==\\'(\\')\\n            {\\n                int[] a = {i,0};\\n                stack.push(a);\\n            }\\n            else\\n            {\\n                if(stack.empty()||stack.peek()[1]==1)\\n                {\\n                    int[] a = {i,1};\\n                    stack.push(a);\\n                }\\n                else\\n                {\\n                    stack.pop();\\n                    int currentLen=0;\\n                    if(stack.empty())\\n                    {\\n                        currentLen = i+1;\\n                    }\\n                    else\\n                    {\\n                        currentLen = i-stack.peek()[0];\\n                    }\\n                    result = Math.max(result, currentLen);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n        Stack<int[]> stack = new Stack<int[]>();\\n        int result = 0;\\n        for(int i=0; i<=s.length()-1; i++)\\n        {\\n            char c = s.charAt(i);\\n            if(c==\\'(\\')\\n            {\\n                int[] a = {i,0};\\n                stack.push(a);\\n            }\\n            else\\n            {\\n                if(stack.empty()||stack.peek()[1]==1)\\n                {\\n                    int[] a = {i,1};\\n                    stack.push(a);\\n                }\\n                else\\n                {\\n                    stack.pop();\\n                    int currentLen=0;\\n                    if(stack.empty())\\n                    {\\n                        currentLen = i+1;\\n                    }\\n                    else\\n                    {\\n                        currentLen = i-stack.peek()[0];\\n                    }\\n                    result = Math.max(result, currentLen);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456794,
                "title": "only-dual-traversal",
                "content": "#*Self Explanatory Code*\\n\\n# Complexity\\n- Time complexity:  O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int l=0,r=0;\\n        int ans=0;\\n        for(int i=0;i<s.size();i++){\\n           if(s[i]==\\'(\\') l++;\\n           if(s[i]==\\')\\') r++;\\n           if(l==r){\\n               ans=max(ans,l+r);\\n           }\\n           if(r>l){     //valid substring(parenthesis) can only found ahead\\n               l=r=0;\\n           }\\n           \\n        }\\n     l=r=0;\\n         for(int i=s.size()-1;i>=0;i--){\\n           if(s[i]==\\'(\\') l++;\\n           if(s[i]==\\')\\') r++;\\n           if(l==r){\\n               ans=max(ans,l+r);\\n           }\\n           if(l>r){\\n               l=r=0;\\n           }\\n           \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int l=0,r=0;\\n        int ans=0;\\n        for(int i=0;i<s.size();i++){\\n           if(s[i]==\\'(\\') l++;\\n           if(s[i]==\\')\\') r++;\\n           if(l==r){\\n               ans=max(ans,l+r);\\n           }\\n           if(r>l){     //valid substring(parenthesis) can only found ahead\\n               l=r=0;\\n           }\\n           \\n        }\\n     l=r=0;\\n         for(int i=s.size()-1;i>=0;i--){\\n           if(s[i]==\\'(\\') l++;\\n           if(s[i]==\\')\\') r++;\\n           if(l==r){\\n               ans=max(ans,l+r);\\n           }\\n           if(l>r){\\n               l=r=0;\\n           }\\n           \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341450,
                "title": "basic-but-efficient-solution-with-comments-added",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int>st;\\n        int n=s.length();\\n        for(int i=0;i<n;i++){\\n            //base conidition\\n            if(s[i]==\\'(\\'){\\n                st.push(i);\\n            }\\n            else{\\n                //Means \\')\\' has appeared\\n                if(!st.empty()){\\n                    if(s[st.top()]==\\'(\\'){\\n                        st.pop();\\n                    }\\n                    else{\\n                        st.push(i);\\n                    }\\n                }\\n                //If we come to this part means that stack is empty \\n                //and this is the first wrong paranthesis\\n                else{\\n                    st.push(i);\\n                }\\n            }\\n        }\\n\\n        //Now we want to give the length of longest valid paranthesis \\n        //substring\\n        int a=n;\\n        int longest=0;\\n        //if st is empty mean no wrong paranthesis\\n        if(st.empty()){\\n            return a;\\n        }\\n        else{\\n            while(!st.empty()){\\n                int b=st.top();\\n                st.pop();\\n                longest=max(longest,a-b-1);\\n                a=b;\\n            }\\n            longest=max(longest,a);\\n            return longest;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int>st;\\n        int n=s.length();\\n        for(int i=0;i<n;i++){\\n            //base conidition\\n            if(s[i]==\\'(\\'){\\n                st.push(i);\\n            }\\n            else{\\n                //Means \\')\\' has appeared\\n                if(!st.empty()){\\n                    if(s[st.top()]==\\'(\\'){\\n                        st.pop();\\n                    }\\n                    else{\\n                        st.push(i);\\n                    }\\n                }\\n                //If we come to this part means that stack is empty \\n                //and this is the first wrong paranthesis\\n                else{\\n                    st.push(i);\\n                }\\n            }\\n        }\\n\\n        //Now we want to give the length of longest valid paranthesis \\n        //substring\\n        int a=n;\\n        int longest=0;\\n        //if st is empty mean no wrong paranthesis\\n        if(st.empty()){\\n            return a;\\n        }\\n        else{\\n            while(!st.empty()){\\n                int b=st.top();\\n                st.pop();\\n                longest=max(longest,a-b-1);\\n                a=b;\\n            }\\n            longest=max(longest,a);\\n            return longest;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108956,
                "title": "faster-than-100-constant-space-c-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int left=0;\\n        int right=0;\\n        int ans=0;\\n        int n=s.size();\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'(\\')left++;\\n            else right++;\\n            if(left==right)ans=max(ans,right*2);\\n            else if(right>left)left=right=0;\\n        }\\n        left=right=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i]==\\')\\')right++;\\n            else left++;\\n            if(left==right)ans=max(ans,right*2);\\n            else if(left>right)left=right=0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int left=0;\\n        int right=0;\\n        int ans=0;\\n        int n=s.size();\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'(\\')left++;\\n            else right++;\\n            if(left==right)ans=max(ans,right*2);\\n            else if(right>left)left=right=0;\\n        }\\n        left=right=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i]==\\')\\')right++;\\n            else left++;\\n            if(left==right)ans=max(ans,right*2);\\n            else if(left>right)left=right=0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100013,
                "title": "c-easy-solution",
                "content": "The key idea is, if you find a valid sequence then replace the indexes  with \"*\".\\nAfter that you can find the longest substring which contains only star within O(n) complexity.\\n![image.png](https://assets.leetcode.com/users/images/4c667b2c-5af5-4d01-af91-b1ea46b8c5ab_1674703023.6571789.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    typedef long long int ll;\\npublic:\\n    int longestValidParentheses(string st) {\\n   stack<pair<char, int>>s;\\n   int n = st.size();\\n   for (int i = 0; i < n; i++)\\n   {\\n      if (st[i] == \\')\\' and !s.empty() and s.top().first == \\'(\\')\\n      {\\n         int t = s.top().second;\\n         st[t] = \\'*\\';\\n         st[i] = \\'*\\'; s.pop();\\n      }\\n      else s.push({st[i], i});\\n   }\\n   ll mx = 0, cnt = 0;\\n   for (int i = 1; i < n; i++)\\n   {\\n      if (st[i] == \\'*\\')cnt = 1;\\n      while (i < n and st[i] == st[i - 1] and st[i] == \\'*\\'){cnt++; i++;}\\n      mx = max(mx, cnt);cnt = 0;\\n   }\\n    cout << mx << endl;\\n    return mx;\\n    }\\n   \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    typedef long long int ll;\\npublic:\\n    int longestValidParentheses(string st) {\\n   stack<pair<char, int>>s;\\n   int n = st.size();\\n   for (int i = 0; i < n; i++)\\n   {\\n      if (st[i] == \\')\\' and !s.empty() and s.top().first == \\'(\\')\\n      {\\n         int t = s.top().second;\\n         st[t] = \\'*\\';\\n         st[i] = \\'*\\'; s.pop();\\n      }\\n      else s.push({st[i], i});\\n   }\\n   ll mx = 0, cnt = 0;\\n   for (int i = 1; i < n; i++)\\n   {\\n      if (st[i] == \\'*\\')cnt = 1;\\n      while (i < n and st[i] == st[i - 1] and st[i] == \\'*\\'){cnt++; i++;}\\n      mx = max(mx, cnt);cnt = 0;\\n   }\\n    cout << mx << endl;\\n    return mx;\\n    }\\n   \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3096028,
                "title": "easy-java-stack",
                "content": "\\n\\tclass Solution {\\n    public int longestValidParentheses(String s) {\\n        Stack<Character> braces=new Stack<>();\\n        Stack<Integer> index=new Stack<>();\\n        int max=0;\\n        index.push(-1);  // default value\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                braces.push(\\'(\\');\\n                index.push(i);\\n            } \\n            else{ \\n    // str.charAt(i)==\\')\\' closing bracket we will get only two either open or close\\n                if(!braces.isEmpty()&& braces.peek()==\\'(\\'){\\n                    braces.pop();\\n                    index.pop();\\n                    max=Math.max(max,i-index.peek());\\n                }\\n                else{\\n                    index.push(i);\\n                }\\n            }\\n        }\\n        return max;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n    public int longestValidParentheses(String s) {\\n        Stack<Character> braces=new Stack<>();\\n        Stack<Integer> index=new Stack<>();\\n        int max=0;\\n        index.push(-1);  // default value\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                braces.push(\\'(\\');\\n                index.push(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2927444,
                "title": "simple-java-o-n-solution-using-stack",
                "content": "# Intuition\\nContinuous push and pop according to the characters in the string\\nand then checking in last \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsing Stack\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n        \\n        Stack<Integer> stk = new Stack<>() ;\\n       if(!s.isEmpty())\\n        stk.push(0);\\n        for(int i = 1 ; i< s.length() ;i++){\\n            if(stk.isEmpty())\\n                stk.push(i);\\n           \\n            else if(s.charAt(stk.peek()) == \\'(\\' && s.charAt(i) == \\')\\')\\n            {\\n\\n                stk.pop();\\n            }\\n            else \\n                stk.push(i);\\n                \\n        }\\n       \\n        if(stk.isEmpty())\\n        return s.length() ;\\n        \\n        if(stk.size()==1 && s.length()!=1 && ((stk.peek()==0)|| (stk.peek()==s.length()-1)))\\n        return s.length()-1;\\n      \\n       \\n         int max = 0 ;\\n        int len = s.length() -1;\\n        while(!stk.isEmpty()){\\n            int a =stk.pop();\\n             max = Math.max(len-a,max);\\n            len = a-1;\\n            \\n        }\\n         \\n        return Math.max(max,len-0+1) ;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n        \\n        Stack<Integer> stk = new Stack<>() ;\\n       if(!s.isEmpty())\\n        stk.push(0);\\n        for(int i = 1 ; i< s.length() ;i++){\\n            if(stk.isEmpty())\\n                stk.push(i);\\n           \\n            else if(s.charAt(stk.peek()) == \\'(\\' && s.charAt(i) == \\')\\')\\n            {\\n\\n                stk.pop();\\n            }\\n            else \\n                stk.push(i);\\n                \\n        }\\n       \\n        if(stk.isEmpty())\\n        return s.length() ;\\n        \\n        if(stk.size()==1 && s.length()!=1 && ((stk.peek()==0)|| (stk.peek()==s.length()-1)))\\n        return s.length()-1;\\n      \\n       \\n         int max = 0 ;\\n        int len = s.length() -1;\\n        while(!stk.isEmpty()){\\n            int a =stk.pop();\\n             max = Math.max(len-a,max);\\n            len = a-1;\\n            \\n        }\\n         \\n        return Math.max(max,len-0+1) ;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852493,
                "title": "98-faster-easy-to-understand-c-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string str) {\\n        stack<int> s;\\n        for(int i = 0; i < str.length(); i++){\\n            if(str[i]==\\'(\\'){\\n                s.push(i);\\n            }else{\\n                if(!s.empty() && str[s.top()] == \\'(\\'){\\n                    s.pop();\\n                }\\n                else{\\n                    s.push(i);\\n                }\\n            }\\n        }\\n        if(s.empty())return str.length();\\n        int a = str.length(), b = 0;\\n        int ans = 0;\\n        while(!s.empty()){\\n            b = s.top();\\n            s.pop();\\n            ans = max(ans,a-b-1);\\n            a = b;\\n        }\\n        ans = max(ans,a);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string str) {\\n        stack<int> s;\\n        for(int i = 0; i < str.length(); i++){\\n            if(str[i]==\\'(\\'){\\n                s.push(i);\\n            }else{\\n                if(!s.empty() && str[s.top()] == \\'(\\'){\\n                    s.pop();\\n                }\\n                else{\\n                    s.push(i);\\n                }\\n            }\\n        }\\n        if(s.empty())return str.length();\\n        int a = str.length(), b = 0;\\n        int ans = 0;\\n        while(!s.empty()){\\n            b = s.top();\\n            s.pop();\\n            ans = max(ans,a-b-1);\\n            a = b;\\n        }\\n        ans = max(ans,a);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2644332,
                "title": "simple-java-solution-with-explanation-in-o-n-tc-and-o-1-sc",
                "content": "```\\nint open = 0, close = 0, max = 0;\\n\\n        for(int i=0;i<s.length();++i){\\n           char c = s.charAt(i);\\n           if(c == \\'(\\'){\\n               open++;\\n           }else{\\n               close++;\\n           }\\n           if(open == close){\\n               max = Math.max(max,open+close);                  // open*2 / close*2 / open+close will give same answer\\n           } else if(close>open) {\\n               open = close = 0;\\n           }\\n        }\\n\\n        open = close = 0;\\n\\n//if u dont understand why i,m doing backward traversal also ,then try to dry run this \"((()\"\\n\\n        for(int i=s.length()-1;i>=0;--i){\\n            char c = s.charAt(i);\\n            if(c == \\'(\\'){\\n                open++;\\n            }else{\\n                close++;\\n            }\\n            if(open == close){\\n                max = Math.max(max,open+close);                  \\n            }else if(close<open) {\\n                open = close = 0;\\n            }\\n        }\\n\\n        return max;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nint open = 0, close = 0, max = 0;\\n\\n        for(int i=0;i<s.length();++i){\\n           char c = s.charAt(i);\\n           if(c == \\'(\\'){\\n               open++;\\n           }else{\\n               close++;\\n           }\\n           if(open == close){\\n               max = Math.max(max,open+close);                  // open*2 / close*2 / open+close will give same answer\\n           } else if(close>open) {\\n               open = close = 0;\\n           }\\n        }\\n\\n        open = close = 0;\\n\\n//if u dont understand why i,m doing backward traversal also ,then try to dry run this \"((()\"\\n\\n        for(int i=s.length()-1;i>=0;--i){\\n            char c = s.charAt(i);\\n            if(c == \\'(\\'){\\n                open++;\\n            }else{\\n                close++;\\n            }\\n            if(open == close){\\n                max = Math.max(max,open+close);                  \\n            }else if(close<open) {\\n                open = close = 0;\\n            }\\n        }\\n\\n        return max;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2428385,
                "title": "c-stack-o-n",
                "content": "* `prev` stores the index, after which the valid subtring can be found.\\n\\n* if a closing bracket `)` is found without it\\'s previous opening bracket, then we update the `prev` to this index, as the previous valid parenthesis cannot extended through this index.\\n\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> st ;\\n        int ans = 0 , prev = -1 ;\\n        \\n        for(int i = prev + 1 ; i < s.size() ; ++i ){\\n            if(s[i] == \\'(\\') st.push(i) ;\\n            else{\\n                if(st.empty()) {prev = i ;continue ;}\\n                st.pop() ;\\n                //now update the answer \\n                if(st.size()) ans = max(ans,i-st.top()) ;\\n                else ans = max(ans,i - prev) ;\\n            }\\n        }\\n        \\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> st ;\\n        int ans = 0 , prev = -1 ;\\n        \\n        for(int i = prev + 1 ; i < s.size() ; ++i ){\\n            if(s[i] == \\'(\\') st.push(i) ;\\n            else{\\n                if(st.empty()) {prev = i ;continue ;}\\n                st.pop() ;\\n                //now update the answer \\n                if(st.size()) ans = max(ans,i-st.top()) ;\\n                else ans = max(ans,i - prev) ;\\n            }\\n        }\\n        \\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2262772,
                "title": "java-intuition-easy-understanding-stack",
                "content": "**Inutition:**\\n\\n- Everytime a matching \\')\\' for a \\'(\\' is found we have found a valid parenetheses length. We need to compute the length upto that point and see if it is greater than the previously found length and then accordingly update the maxLength.\\n- We maintain the index positions in a stack. We initialize the stack, even before we start the processing, by pushing an index -1 onto the stack. This initialization of -1 facilitates the computation of the length of the valid parentheses, as -1 represents the index of the last invalid parentheses.\\n- For \\'(\\' we keep track of the start of the parentheses by inserting the index onto the stack, with a hope to find the matching closed \\')\\' one in future. When a closed \\')\\' parentheses is found, we pop out the topmost opening \\'(\\' index and calculate the length of the parentheses, by subtracting the current \\')\\' closing index with the topmost item on the stack, the topmost index will have the index of the invalid parentheses. \\n- In the event, when the stack is empty, we didn\\'t find a matching \\'(\\' brace and hence we cannot calculate a valid length. Instead we keep track of the index of this invalid close \\')\\', as this can be the next -1 position of the next valid parentheses.\\n\\n**Code:**\\n```\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(-1);\\n        int max=0;\\n        for(int i=0; i < s.length(); i++){\\n            char c = s.charAt(i);\\n            if(c == \\'(\\')\\n                stack.push(i);\\n            else{            \\n                stack.pop();\\n                if(stack.isEmpty())\\n                    stack.push(i);\\n                else\\n                    max = Math.max(max, i-stack.peek());\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(-1);\\n        int max=0;\\n        for(int i=0; i < s.length(); i++){\\n            char c = s.charAt(i);\\n            if(c == \\'(\\')\\n                stack.push(i);\\n            else{            \\n                stack.pop();\\n                if(stack.isEmpty())\\n                    stack.push(i);\\n                else\\n                    max = Math.max(max, i-stack.peek());\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2069645,
                "title": "c-use-stack-explanation-through-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    //Use stack property to solve this problem\\n    int longestValidParentheses(string s) \\n    {\\n        //storing open parenthesis index in stack \\n        stack<int> st;\\n        // initially push -1 to the stack to avoid close parenthesis \\')\\'\\n        st.push(-1);            \\n        \\n        int count = 0;\\n        \\n        // iterate over the string\\n        for(int i=0;i<s.size();i++)\\n        {\\n            // if it is open parenthesis \\'(\\' then push its index into the stack\\n            if(s[i] == \\'(\\')\\n                st.push(i);\\n            \\n            // if close pathenthesis \\')\\' occur from pop the stack \\n            else\\n            {\\n                st.pop();\\n                \\n                // check whether the stack is empty or not if it is empty \\n                // then push current index into it because if there is another \\')\\' \\n                //then we can not pop index from our stack\\n                if(st.empty())\\n                    st.push(i);\\n                \\n                // if it is not empty then find the length between the (current index i \\n                // and index at stack top) and store max value\\n                else\\n                    count = max(count,i-st.top());\\n            }\\n        }\\n \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Use stack property to solve this problem\\n    int longestValidParentheses(string s) \\n    {\\n        //storing open parenthesis index in stack \\n        stack<int> st;\\n        // initially push -1 to the stack to avoid close parenthesis \\')\\'\\n        st.push(-1);            \\n        \\n        int count = 0;\\n        \\n        // iterate over the string\\n        for(int i=0;i<s.size();i++)\\n        {\\n            // if it is open parenthesis \\'(\\' then push its index into the stack\\n            if(s[i] == \\'(\\')\\n                st.push(i);\\n            \\n            // if close pathenthesis \\')\\' occur from pop the stack \\n            else\\n            {\\n                st.pop();\\n                \\n                // check whether the stack is empty or not if it is empty \\n                // then push current index into it because if there is another \\')\\' \\n                //then we can not pop index from our stack\\n                if(st.empty())\\n                    st.push(i);\\n                \\n                // if it is not empty then find the length between the (current index i \\n                // and index at stack top) and store max value\\n                else\\n                    count = max(count,i-st.top());\\n            }\\n        }\\n \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2068859,
                "title": "o-n-solution-without-using-stack-faster-than-100",
                "content": "Pls do upvote if you find this useful. \\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int n=s.size();\\n        int op=0;\\n        int cl=0;\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n                op++;\\n            else if(s[i]==\\')\\')\\n                cl++;\\n\\t\\t\\t\\t// we get our answer when open paranthesis is equals to closed one. \\n            if(op==cl)\\n               ans=max(ans,2*op);\\n\\t\\t\\t   // if count of closed parenthesis is greater than open then reset values to 0. \\n            else if(cl>op)\\n            {  \\n                cl=0;\\n                op=0;\\n            }\\n            \\n        }\\n\\t\\t\\n\\t\\t// Check  same thing in reverse order\\n        cl=0,op=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'(\\')\\n               cl++;\\n            else\\n               op++;\\n            \\n            if(op==cl)\\n               ans=max(ans,op*2);\\n            else if(cl>op)\\n            {\\n                cl=0;\\n                op=0;\\n            }\\n                \\n        }\\n          return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int n=s.size();\\n        int op=0;\\n        int cl=0;\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n                op++;\\n            else if(s[i]==\\')\\')\\n                cl++;\\n\\t\\t\\t\\t// we get our answer when open paranthesis is equals to closed one. \\n            if(op==cl)\\n               ans=max(ans,2*op);\\n\\t\\t\\t   // if count of closed parenthesis is greater than open then reset values to 0. \\n            else if(cl>op)\\n            {  \\n                cl=0;\\n                op=0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2068654,
                "title": "c-o-n-using-stack-without-extra-space",
                "content": "**1. Using Stack:**\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> st;\\n        st.push(-1);\\n        int maxi=0;\\n        for(int i=0;i<s.size();i++) {\\n            if(s[i]==\\'(\\') st.push(i);\\n            else{\\n                st.pop();\\n                if(st.empty()) st.push(i);\\n                else maxi=max(maxi,i-st.top());\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```\\n\\n```\\nTC-> O(N)    SC->O(N)\\n```\\n\\n**2. Without Extra space:**\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int open=0,close=0, res=0;\\n        // forward traverse:\\n        for(auto ch:s){\\n            if(ch==\\'(\\') open++;\\n            else close++;\\n            if(open==close) res=max(res,open+close);\\n            else if(close>open) open=close=0;\\n        }\\n        open=close=0;\\n        // backward traverse:\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(s[i]==\\'(\\') open++;\\n            else close++;\\n            if(open==close) res=max(res,open+close);\\n            else if(open>close) open=close=0;\\n        }\\n        return res;\\n    }\\n};\\n```\\n```\\nTC-> O(N)    Sc-> O(1) \\n```\\n**If you like it, do upvote!**",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> st;\\n        st.push(-1);\\n        int maxi=0;\\n        for(int i=0;i<s.size();i++) {\\n            if(s[i]==\\'(\\') st.push(i);\\n            else{\\n                st.pop();\\n                if(st.empty()) st.push(i);\\n                else maxi=max(maxi,i-st.top());\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```\n```\\nTC-> O(N)    SC->O(N)\\n```\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int open=0,close=0, res=0;\\n        // forward traverse:\\n        for(auto ch:s){\\n            if(ch==\\'(\\') open++;\\n            else close++;\\n            if(open==close) res=max(res,open+close);\\n            else if(close>open) open=close=0;\\n        }\\n        open=close=0;\\n        // backward traverse:\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(s[i]==\\'(\\') open++;\\n            else close++;\\n            if(open==close) res=max(res,open+close);\\n            else if(open>close) open=close=0;\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nTC-> O(N)    Sc-> O(1) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1984645,
                "title": "c-o-n-time-and-o-1-space",
                "content": "\\tpublic:\\n\\t\\tint longestValidParentheses(string s) {\\n        \\n        int open = 0, closed = 0; \\n        int maxi = 0;\\n        for(char c:s){\\n            if(c==\\'(\\')\\n                open++;\\n            else if(c==\\')\\')\\n                closed++;\\n            \\n            if(open==closed){\\n                maxi = max(maxi, open+closed);\\n            }\\n            else if(closed>open){\\n                open = closed = 0;\\n            }\\n        }\\n        \\n        open = 0, closed = 0;\\n        for(int i=s.length()-1;i>=0;i--){\\n            if(s[i]==\\'(\\')\\n                open++;\\n            else if(s[i]==\\')\\')\\n                closed++;\\n            \\n            if(open==closed){\\n                maxi = max(maxi, open+closed);\\n            }\\n            else if(open>closed){\\n                open = closed = 0;\\n            }\\n        }\\n        \\n        return maxi;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "\\tpublic:\\n\\t\\tint longestValidParentheses(string s) {\\n        \\n        int open = 0, closed = 0; \\n        int maxi = 0;\\n        for(char c:s){\\n            if(c==\\'(\\')\\n                open++;\\n            else if(c==\\')\\')\\n                closed++;\\n            \\n            if(open==closed){\\n                maxi = max(maxi, open+closed);\\n            }\\n            else if(closed>open){\\n                open = closed = 0;\\n            }\\n        }\\n        \\n        open = 0, closed = 0;\\n        for(int i=s.length()-1;i>=0;i--){\\n            if(s[i]==\\'(\\')\\n                open++;\\n            else if(s[i]==\\')\\')\\n                closed++;\\n            \\n            if(open==closed){\\n                maxi = max(maxi, open+closed);\\n            }\\n            else if(open>closed){\\n                open = closed = 0;\\n            }\\n        }\\n        \\n        return maxi;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1877261,
                "title": "very-simple-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/a5e86a84-f7e5-4bf4-9300-73a48301dafc_1648060029.66314.png)\\n\\n1. A bracket can either be a part of valid parentheses or not.\\n2. We can assign a flag to each parentheses. 0 - part of invalid parentheses, 1 - part of valid parentheses\\n3. Once we have marked every bracket with a flag we will have an array containing only 0s and 1s.\\n4. We can find the length of largest subarray filled with only 1s using prefix sum.\\n5. The length of the largest subarray filled with only 1s will be the length of longest valid parentheses.\\n\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int n = s.size();\\n        vector<int> flags(n, 0);\\n        \\n        stack<pair<char, int>> stk;\\n        for(int i = 0; i < n; i++) {\\n            char ch = s[i];\\n\\n            if (stk.empty()) stk.push({ch, i});\\n            else {\\n                if (stk.top().first == \\'(\\' && ch == \\')\\') {\\n                    flags[i] = 1;\\n                    flags[stk.top().second] = true;\\n                    stk.pop();\\n                } else stk.push({ch, i});\\n            }\\n        }\\n        \\n        int maxLen = 0;\\n\\n        int prefix = 0;\\n        // longest length of consecutive 1s\\n        for(int flag: flags) {\\n            if (flag == 0) prefix = 0;\\n            else {\\n                prefix++;\\n                maxLen = max(prefix, maxLen);\\n            }\\n        }\\n        \\n        return maxLen;\\n    }\\n};\\n```\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)",
                "solutionTags": [
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int n = s.size();\\n        vector<int> flags(n, 0);\\n        \\n        stack<pair<char, int>> stk;\\n        for(int i = 0; i < n; i++) {\\n            char ch = s[i];\\n\\n            if (stk.empty()) stk.push({ch, i});\\n            else {\\n                if (stk.top().first == \\'(\\' && ch == \\')\\') {\\n                    flags[i] = 1;\\n                    flags[stk.top().second] = true;\\n                    stk.pop();\\n                } else stk.push({ch, i});\\n            }\\n        }\\n        \\n        int maxLen = 0;\\n\\n        int prefix = 0;\\n        // longest length of consecutive 1s\\n        for(int flag: flags) {\\n            if (flag == 0) prefix = 0;\\n            else {\\n                prefix++;\\n                maxLen = max(prefix, maxLen);\\n            }\\n        }\\n        \\n        return maxLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1571083,
                "content": [
                    {
                        "username": "uuisafresh",
                        "content": "So in this case I use stack and an array, and then change this problem as **finding longest continuous 1 in a 01 array**. Let me tell how to do it.\\n\\nFirst, stack push position of each '(', then when we meet ')' I pop stack to find its match'('\\uff0c place both ')' and '(' as 1 in array\\n\\nFor example, (()()\\uff0carray should look like[0,1,1,1,1]\\n\\nThen it is super easy, to find out longest substring that all items are 1 !!!"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Here\\'s the Python implementation of this solution!\\n\\n```\\ndef longestValidParentheses(s: str) -> int:\\n        # Convert to an array of 1s\\n        stack = []\\n        ans = [0] * len(s)\\n\\n        for i, char in enumerate(s):\\n            if not stack or char == \"(\":\\n                stack.append((char, i))\\n            \\n            elif char == \")\":\\n                if stack[-1][0] == \"(\":\\n                    _, idx = stack.pop()\\n                    ans[i], ans[idx] = 1, 1\\n                else:\\n                    stack.append((\")\", i))\\n\\n        # Now find the longest substring of 1s\\n        ones = 0\\n        ret = 0\\n        for char in ans:\\n            if char == 1:\\n                ones+=1\\n                ret = max(ret, ones)\\n            else:\\n                ones = 0\\n        \\n        return ret\\n```"
                    },
                    {
                        "username": "Simonvu",
                        "content": "brilliant!!"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@PredatorMK2](/PredatorMK2) do you fully understand his approach?"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "this code will fail because of testcase \")(\" as it is not balanced and this approach will return 2 for it\\n"
                    },
                    {
                        "username": "lotus18",
                        "content": "Great Idea!\\n\\nCode For The Above Approach\\n\\nclass Solution \\n{\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        stack<pair<int,int>> st;\\n        int n=s.size();\\n        vector<int> v(n,0);\\n        for(int x=0; x<n; x++)\\n        {\\n            if(s[x]==\\'(\\') st.push({s[x],x});\\n            else\\n            {\\n                if(!st.empty() && st.top().first==\\'(\\')\\n                {\\n                    v[x]=1;\\n                    v[st.top().second]=1;\\n                    st.pop();\\n                }\\n            }\\n        }\\n        int start=-1, end=-1;\\n        int ans=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(v[x]==1)\\n            {\\n                start=x;\\n                int i=x+1;\\n                while(i<n && v[i]) i++;\\n                end=i-1;\\n                x=end;\\n                ans=max(ans,end-start+1);\\n                start=-1,end=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "viocost",
                        "content": "The description only shows example with ()() sequences being correct.\\nHow about this: (()()) or this ((()(())))? Are they correct?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Yep they\\'re correct"
                    },
                    {
                        "username": "Akshay1740",
                        "content": "yes they are also correct."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "This is just a monotonic Stack problem like Next Greater element or Previous Smaller element but the only difference is that we are trying to maintain the order inside the stack instead of a monotonically increasing or decreasing sequence.\\n\\nStack Problems can be broken down into 1 or 2 algorithmic techniques and this is one of them!\\n\\nSimilar Problems :\\nNext Greater Element\\nNext Smaller Element\\nPrevious Greater Element\\nPrevious Smaller Element\\nLargest Rectangle in Histogram\\n\\nCheers && Happy Coding !"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Thanks man. "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "really helpful!!!"
                    },
                    {
                        "username": "av9ash",
                        "content": "()(() how is this the longest valid parentheses? Answer is 4 I think its 2\\nCan someone please explain"
                    },
                    {
                        "username": "abdulwaheed333",
                        "content": "Of course ! you are right but  first we have to find is it valid or not? .So in this there are two valid outputs () and (). length is 4."
                    },
                    {
                        "username": "singhabhinash",
                        "content": "think your logic based on below test case, it will work\ns = \"()((())(()()()\", longestValidParentheses = max(2, 4, 6) = 6"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "I realised that, questions is asking for longest possible substring , not the subsequence.  In case of subsequence ans will be 4, and incase of substring ans will 2"
                    },
                    {
                        "username": "Cozmos77",
                        "content": "[@a13375572211](/a13375572211) exactly ,faced the same issue and i think the answer should be 4 rather than 2.\\n"
                    },
                    {
                        "username": "calm27",
                        "content": "[@a13375572211](/a13375572211) did you try to address this test case? I faced same problem and there are no buttons for report "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@a13375572211](/a13375572211) bro need longest i found invalid then count start from 0"
                    },
                    {
                        "username": "a13375572211",
                        "content": "The answer is 2 but i got 4 and its saying incorrect, but i think its suppose to be 4 because ()(() has 2 valid parentheses"
                    },
                    {
                        "username": "dj_ios1988",
                        "content": "from the description:\nInput: \"(()\"\nOutput: 2\n\nand in the testcase\nInput: “\"()(()\"”\nOutput: 4\nExpected :2\n\nwhy these two have diferent answer of \"(()\" ?\n"
                    },
                    {
                        "username": "shubhankadam",
                        "content": "[@a13375572211](/a13375572211) it expects the longest correct sequence, here it is 2, since the sequence is broken by \\'(\\' in the middle\\n"
                    },
                    {
                        "username": "a13375572211",
                        "content": "Exactly bro, I have the same question"
                    },
                    {
                        "username": "shawngao",
                        "content": "@administrators Is this intended or not?\\n\\nAll Java solution will TLE on this test case:\\n\\n\"((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\""
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Dynamic Programming\n\n  \n**Approach 3:** Using Stack\n\n  \n**Approach 4:** Without extra space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "MohitBansal_",
                        "content": "i done  this question by storing index\\'s of opening bracket in stack\\ncan any body know  other approach? "
                    },
                    {
                        "username": "1337beef",
                        "content": "Is this  (())  counted as valid?"
                    },
                    {
                        "username": "manishsinghrajwar80",
                        "content": "yes"
                    },
                    {
                        "username": "Om_Kumar_Singh",
                        "content": "Keep in mind that string must be valid, for example \"()(()\" answer will be 2. "
                    },
                    {
                        "username": "10gksten",
                        "content": "s = \"()(())\"\\nhow come the expected output is 6?"
                    },
                    {
                        "username": "default-writer",
                        "content": "by definition any sequence not breaking the source rules are valid"
                    },
                    {
                        "username": "10gksten",
                        "content": "[@MrLambda42](/MrLambda42) I will take a look on the pdf and get back on this. Thankyou"
                    },
                    {
                        "username": "MrLambda42",
                        "content": "Looks like it\\'s the longest valid sequence of consecutive properly closed parentheses [len(\"()\") + len(\"(())\")] and not just longest singular sequence of properly closed parentheses like max[len(\"()\"), len(\"(())\")].\\n\\nex: \"()(()\" gives 2 because the second ( is not closed, so the streak is maxed out at 2.\\nOn the other hand, ()(()) has two consecutive sequences that match to 2 + 4 => \"()\" + \"(())\" = 6.\\n\\nThere are some graphs in https://madalgo.au.dk/fileadmin/madalgo/OA_PDF_s/C471.pdf that illustrate how parentheses are balanced and how one may reach the conclusion of the longest consecutive sequence of closed parentheses."
                    }
                ]
            },
            {
                "id": 1572316,
                "content": [
                    {
                        "username": "uuisafresh",
                        "content": "So in this case I use stack and an array, and then change this problem as **finding longest continuous 1 in a 01 array**. Let me tell how to do it.\\n\\nFirst, stack push position of each '(', then when we meet ')' I pop stack to find its match'('\\uff0c place both ')' and '(' as 1 in array\\n\\nFor example, (()()\\uff0carray should look like[0,1,1,1,1]\\n\\nThen it is super easy, to find out longest substring that all items are 1 !!!"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Here\\'s the Python implementation of this solution!\\n\\n```\\ndef longestValidParentheses(s: str) -> int:\\n        # Convert to an array of 1s\\n        stack = []\\n        ans = [0] * len(s)\\n\\n        for i, char in enumerate(s):\\n            if not stack or char == \"(\":\\n                stack.append((char, i))\\n            \\n            elif char == \")\":\\n                if stack[-1][0] == \"(\":\\n                    _, idx = stack.pop()\\n                    ans[i], ans[idx] = 1, 1\\n                else:\\n                    stack.append((\")\", i))\\n\\n        # Now find the longest substring of 1s\\n        ones = 0\\n        ret = 0\\n        for char in ans:\\n            if char == 1:\\n                ones+=1\\n                ret = max(ret, ones)\\n            else:\\n                ones = 0\\n        \\n        return ret\\n```"
                    },
                    {
                        "username": "Simonvu",
                        "content": "brilliant!!"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@PredatorMK2](/PredatorMK2) do you fully understand his approach?"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "this code will fail because of testcase \")(\" as it is not balanced and this approach will return 2 for it\\n"
                    },
                    {
                        "username": "lotus18",
                        "content": "Great Idea!\\n\\nCode For The Above Approach\\n\\nclass Solution \\n{\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        stack<pair<int,int>> st;\\n        int n=s.size();\\n        vector<int> v(n,0);\\n        for(int x=0; x<n; x++)\\n        {\\n            if(s[x]==\\'(\\') st.push({s[x],x});\\n            else\\n            {\\n                if(!st.empty() && st.top().first==\\'(\\')\\n                {\\n                    v[x]=1;\\n                    v[st.top().second]=1;\\n                    st.pop();\\n                }\\n            }\\n        }\\n        int start=-1, end=-1;\\n        int ans=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(v[x]==1)\\n            {\\n                start=x;\\n                int i=x+1;\\n                while(i<n && v[i]) i++;\\n                end=i-1;\\n                x=end;\\n                ans=max(ans,end-start+1);\\n                start=-1,end=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "viocost",
                        "content": "The description only shows example with ()() sequences being correct.\\nHow about this: (()()) or this ((()(())))? Are they correct?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Yep they\\'re correct"
                    },
                    {
                        "username": "Akshay1740",
                        "content": "yes they are also correct."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "This is just a monotonic Stack problem like Next Greater element or Previous Smaller element but the only difference is that we are trying to maintain the order inside the stack instead of a monotonically increasing or decreasing sequence.\\n\\nStack Problems can be broken down into 1 or 2 algorithmic techniques and this is one of them!\\n\\nSimilar Problems :\\nNext Greater Element\\nNext Smaller Element\\nPrevious Greater Element\\nPrevious Smaller Element\\nLargest Rectangle in Histogram\\n\\nCheers && Happy Coding !"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Thanks man. "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "really helpful!!!"
                    },
                    {
                        "username": "av9ash",
                        "content": "()(() how is this the longest valid parentheses? Answer is 4 I think its 2\\nCan someone please explain"
                    },
                    {
                        "username": "abdulwaheed333",
                        "content": "Of course ! you are right but  first we have to find is it valid or not? .So in this there are two valid outputs () and (). length is 4."
                    },
                    {
                        "username": "singhabhinash",
                        "content": "think your logic based on below test case, it will work\ns = \"()((())(()()()\", longestValidParentheses = max(2, 4, 6) = 6"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "I realised that, questions is asking for longest possible substring , not the subsequence.  In case of subsequence ans will be 4, and incase of substring ans will 2"
                    },
                    {
                        "username": "Cozmos77",
                        "content": "[@a13375572211](/a13375572211) exactly ,faced the same issue and i think the answer should be 4 rather than 2.\\n"
                    },
                    {
                        "username": "calm27",
                        "content": "[@a13375572211](/a13375572211) did you try to address this test case? I faced same problem and there are no buttons for report "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@a13375572211](/a13375572211) bro need longest i found invalid then count start from 0"
                    },
                    {
                        "username": "a13375572211",
                        "content": "The answer is 2 but i got 4 and its saying incorrect, but i think its suppose to be 4 because ()(() has 2 valid parentheses"
                    },
                    {
                        "username": "dj_ios1988",
                        "content": "from the description:\nInput: \"(()\"\nOutput: 2\n\nand in the testcase\nInput: “\"()(()\"”\nOutput: 4\nExpected :2\n\nwhy these two have diferent answer of \"(()\" ?\n"
                    },
                    {
                        "username": "shubhankadam",
                        "content": "[@a13375572211](/a13375572211) it expects the longest correct sequence, here it is 2, since the sequence is broken by \\'(\\' in the middle\\n"
                    },
                    {
                        "username": "a13375572211",
                        "content": "Exactly bro, I have the same question"
                    },
                    {
                        "username": "shawngao",
                        "content": "@administrators Is this intended or not?\\n\\nAll Java solution will TLE on this test case:\\n\\n\"((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\""
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Dynamic Programming\n\n  \n**Approach 3:** Using Stack\n\n  \n**Approach 4:** Without extra space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "MohitBansal_",
                        "content": "i done  this question by storing index\\'s of opening bracket in stack\\ncan any body know  other approach? "
                    },
                    {
                        "username": "1337beef",
                        "content": "Is this  (())  counted as valid?"
                    },
                    {
                        "username": "manishsinghrajwar80",
                        "content": "yes"
                    },
                    {
                        "username": "Om_Kumar_Singh",
                        "content": "Keep in mind that string must be valid, for example \"()(()\" answer will be 2. "
                    },
                    {
                        "username": "10gksten",
                        "content": "s = \"()(())\"\\nhow come the expected output is 6?"
                    },
                    {
                        "username": "default-writer",
                        "content": "by definition any sequence not breaking the source rules are valid"
                    },
                    {
                        "username": "10gksten",
                        "content": "[@MrLambda42](/MrLambda42) I will take a look on the pdf and get back on this. Thankyou"
                    },
                    {
                        "username": "MrLambda42",
                        "content": "Looks like it\\'s the longest valid sequence of consecutive properly closed parentheses [len(\"()\") + len(\"(())\")] and not just longest singular sequence of properly closed parentheses like max[len(\"()\"), len(\"(())\")].\\n\\nex: \"()(()\" gives 2 because the second ( is not closed, so the streak is maxed out at 2.\\nOn the other hand, ()(()) has two consecutive sequences that match to 2 + 4 => \"()\" + \"(())\" = 6.\\n\\nThere are some graphs in https://madalgo.au.dk/fileadmin/madalgo/OA_PDF_s/C471.pdf that illustrate how parentheses are balanced and how one may reach the conclusion of the longest consecutive sequence of closed parentheses."
                    }
                ]
            },
            {
                "id": 1574996,
                "content": [
                    {
                        "username": "uuisafresh",
                        "content": "So in this case I use stack and an array, and then change this problem as **finding longest continuous 1 in a 01 array**. Let me tell how to do it.\\n\\nFirst, stack push position of each '(', then when we meet ')' I pop stack to find its match'('\\uff0c place both ')' and '(' as 1 in array\\n\\nFor example, (()()\\uff0carray should look like[0,1,1,1,1]\\n\\nThen it is super easy, to find out longest substring that all items are 1 !!!"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Here\\'s the Python implementation of this solution!\\n\\n```\\ndef longestValidParentheses(s: str) -> int:\\n        # Convert to an array of 1s\\n        stack = []\\n        ans = [0] * len(s)\\n\\n        for i, char in enumerate(s):\\n            if not stack or char == \"(\":\\n                stack.append((char, i))\\n            \\n            elif char == \")\":\\n                if stack[-1][0] == \"(\":\\n                    _, idx = stack.pop()\\n                    ans[i], ans[idx] = 1, 1\\n                else:\\n                    stack.append((\")\", i))\\n\\n        # Now find the longest substring of 1s\\n        ones = 0\\n        ret = 0\\n        for char in ans:\\n            if char == 1:\\n                ones+=1\\n                ret = max(ret, ones)\\n            else:\\n                ones = 0\\n        \\n        return ret\\n```"
                    },
                    {
                        "username": "Simonvu",
                        "content": "brilliant!!"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@PredatorMK2](/PredatorMK2) do you fully understand his approach?"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "this code will fail because of testcase \")(\" as it is not balanced and this approach will return 2 for it\\n"
                    },
                    {
                        "username": "lotus18",
                        "content": "Great Idea!\\n\\nCode For The Above Approach\\n\\nclass Solution \\n{\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        stack<pair<int,int>> st;\\n        int n=s.size();\\n        vector<int> v(n,0);\\n        for(int x=0; x<n; x++)\\n        {\\n            if(s[x]==\\'(\\') st.push({s[x],x});\\n            else\\n            {\\n                if(!st.empty() && st.top().first==\\'(\\')\\n                {\\n                    v[x]=1;\\n                    v[st.top().second]=1;\\n                    st.pop();\\n                }\\n            }\\n        }\\n        int start=-1, end=-1;\\n        int ans=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(v[x]==1)\\n            {\\n                start=x;\\n                int i=x+1;\\n                while(i<n && v[i]) i++;\\n                end=i-1;\\n                x=end;\\n                ans=max(ans,end-start+1);\\n                start=-1,end=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "viocost",
                        "content": "The description only shows example with ()() sequences being correct.\\nHow about this: (()()) or this ((()(())))? Are they correct?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Yep they\\'re correct"
                    },
                    {
                        "username": "Akshay1740",
                        "content": "yes they are also correct."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "This is just a monotonic Stack problem like Next Greater element or Previous Smaller element but the only difference is that we are trying to maintain the order inside the stack instead of a monotonically increasing or decreasing sequence.\\n\\nStack Problems can be broken down into 1 or 2 algorithmic techniques and this is one of them!\\n\\nSimilar Problems :\\nNext Greater Element\\nNext Smaller Element\\nPrevious Greater Element\\nPrevious Smaller Element\\nLargest Rectangle in Histogram\\n\\nCheers && Happy Coding !"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Thanks man. "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "really helpful!!!"
                    },
                    {
                        "username": "av9ash",
                        "content": "()(() how is this the longest valid parentheses? Answer is 4 I think its 2\\nCan someone please explain"
                    },
                    {
                        "username": "abdulwaheed333",
                        "content": "Of course ! you are right but  first we have to find is it valid or not? .So in this there are two valid outputs () and (). length is 4."
                    },
                    {
                        "username": "singhabhinash",
                        "content": "think your logic based on below test case, it will work\ns = \"()((())(()()()\", longestValidParentheses = max(2, 4, 6) = 6"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "I realised that, questions is asking for longest possible substring , not the subsequence.  In case of subsequence ans will be 4, and incase of substring ans will 2"
                    },
                    {
                        "username": "Cozmos77",
                        "content": "[@a13375572211](/a13375572211) exactly ,faced the same issue and i think the answer should be 4 rather than 2.\\n"
                    },
                    {
                        "username": "calm27",
                        "content": "[@a13375572211](/a13375572211) did you try to address this test case? I faced same problem and there are no buttons for report "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@a13375572211](/a13375572211) bro need longest i found invalid then count start from 0"
                    },
                    {
                        "username": "a13375572211",
                        "content": "The answer is 2 but i got 4 and its saying incorrect, but i think its suppose to be 4 because ()(() has 2 valid parentheses"
                    },
                    {
                        "username": "dj_ios1988",
                        "content": "from the description:\nInput: \"(()\"\nOutput: 2\n\nand in the testcase\nInput: “\"()(()\"”\nOutput: 4\nExpected :2\n\nwhy these two have diferent answer of \"(()\" ?\n"
                    },
                    {
                        "username": "shubhankadam",
                        "content": "[@a13375572211](/a13375572211) it expects the longest correct sequence, here it is 2, since the sequence is broken by \\'(\\' in the middle\\n"
                    },
                    {
                        "username": "a13375572211",
                        "content": "Exactly bro, I have the same question"
                    },
                    {
                        "username": "shawngao",
                        "content": "@administrators Is this intended or not?\\n\\nAll Java solution will TLE on this test case:\\n\\n\"((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\""
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Dynamic Programming\n\n  \n**Approach 3:** Using Stack\n\n  \n**Approach 4:** Without extra space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "MohitBansal_",
                        "content": "i done  this question by storing index\\'s of opening bracket in stack\\ncan any body know  other approach? "
                    },
                    {
                        "username": "1337beef",
                        "content": "Is this  (())  counted as valid?"
                    },
                    {
                        "username": "manishsinghrajwar80",
                        "content": "yes"
                    },
                    {
                        "username": "Om_Kumar_Singh",
                        "content": "Keep in mind that string must be valid, for example \"()(()\" answer will be 2. "
                    },
                    {
                        "username": "10gksten",
                        "content": "s = \"()(())\"\\nhow come the expected output is 6?"
                    },
                    {
                        "username": "default-writer",
                        "content": "by definition any sequence not breaking the source rules are valid"
                    },
                    {
                        "username": "10gksten",
                        "content": "[@MrLambda42](/MrLambda42) I will take a look on the pdf and get back on this. Thankyou"
                    },
                    {
                        "username": "MrLambda42",
                        "content": "Looks like it\\'s the longest valid sequence of consecutive properly closed parentheses [len(\"()\") + len(\"(())\")] and not just longest singular sequence of properly closed parentheses like max[len(\"()\"), len(\"(())\")].\\n\\nex: \"()(()\" gives 2 because the second ( is not closed, so the streak is maxed out at 2.\\nOn the other hand, ()(()) has two consecutive sequences that match to 2 + 4 => \"()\" + \"(())\" = 6.\\n\\nThere are some graphs in https://madalgo.au.dk/fileadmin/madalgo/OA_PDF_s/C471.pdf that illustrate how parentheses are balanced and how one may reach the conclusion of the longest consecutive sequence of closed parentheses."
                    }
                ]
            },
            {
                "id": 1568026,
                "content": [
                    {
                        "username": "uuisafresh",
                        "content": "So in this case I use stack and an array, and then change this problem as **finding longest continuous 1 in a 01 array**. Let me tell how to do it.\\n\\nFirst, stack push position of each '(', then when we meet ')' I pop stack to find its match'('\\uff0c place both ')' and '(' as 1 in array\\n\\nFor example, (()()\\uff0carray should look like[0,1,1,1,1]\\n\\nThen it is super easy, to find out longest substring that all items are 1 !!!"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Here\\'s the Python implementation of this solution!\\n\\n```\\ndef longestValidParentheses(s: str) -> int:\\n        # Convert to an array of 1s\\n        stack = []\\n        ans = [0] * len(s)\\n\\n        for i, char in enumerate(s):\\n            if not stack or char == \"(\":\\n                stack.append((char, i))\\n            \\n            elif char == \")\":\\n                if stack[-1][0] == \"(\":\\n                    _, idx = stack.pop()\\n                    ans[i], ans[idx] = 1, 1\\n                else:\\n                    stack.append((\")\", i))\\n\\n        # Now find the longest substring of 1s\\n        ones = 0\\n        ret = 0\\n        for char in ans:\\n            if char == 1:\\n                ones+=1\\n                ret = max(ret, ones)\\n            else:\\n                ones = 0\\n        \\n        return ret\\n```"
                    },
                    {
                        "username": "Simonvu",
                        "content": "brilliant!!"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@PredatorMK2](/PredatorMK2) do you fully understand his approach?"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "this code will fail because of testcase \")(\" as it is not balanced and this approach will return 2 for it\\n"
                    },
                    {
                        "username": "lotus18",
                        "content": "Great Idea!\\n\\nCode For The Above Approach\\n\\nclass Solution \\n{\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        stack<pair<int,int>> st;\\n        int n=s.size();\\n        vector<int> v(n,0);\\n        for(int x=0; x<n; x++)\\n        {\\n            if(s[x]==\\'(\\') st.push({s[x],x});\\n            else\\n            {\\n                if(!st.empty() && st.top().first==\\'(\\')\\n                {\\n                    v[x]=1;\\n                    v[st.top().second]=1;\\n                    st.pop();\\n                }\\n            }\\n        }\\n        int start=-1, end=-1;\\n        int ans=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(v[x]==1)\\n            {\\n                start=x;\\n                int i=x+1;\\n                while(i<n && v[i]) i++;\\n                end=i-1;\\n                x=end;\\n                ans=max(ans,end-start+1);\\n                start=-1,end=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "viocost",
                        "content": "The description only shows example with ()() sequences being correct.\\nHow about this: (()()) or this ((()(())))? Are they correct?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Yep they\\'re correct"
                    },
                    {
                        "username": "Akshay1740",
                        "content": "yes they are also correct."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "This is just a monotonic Stack problem like Next Greater element or Previous Smaller element but the only difference is that we are trying to maintain the order inside the stack instead of a monotonically increasing or decreasing sequence.\\n\\nStack Problems can be broken down into 1 or 2 algorithmic techniques and this is one of them!\\n\\nSimilar Problems :\\nNext Greater Element\\nNext Smaller Element\\nPrevious Greater Element\\nPrevious Smaller Element\\nLargest Rectangle in Histogram\\n\\nCheers && Happy Coding !"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Thanks man. "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "really helpful!!!"
                    },
                    {
                        "username": "av9ash",
                        "content": "()(() how is this the longest valid parentheses? Answer is 4 I think its 2\\nCan someone please explain"
                    },
                    {
                        "username": "abdulwaheed333",
                        "content": "Of course ! you are right but  first we have to find is it valid or not? .So in this there are two valid outputs () and (). length is 4."
                    },
                    {
                        "username": "singhabhinash",
                        "content": "think your logic based on below test case, it will work\ns = \"()((())(()()()\", longestValidParentheses = max(2, 4, 6) = 6"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "I realised that, questions is asking for longest possible substring , not the subsequence.  In case of subsequence ans will be 4, and incase of substring ans will 2"
                    },
                    {
                        "username": "Cozmos77",
                        "content": "[@a13375572211](/a13375572211) exactly ,faced the same issue and i think the answer should be 4 rather than 2.\\n"
                    },
                    {
                        "username": "calm27",
                        "content": "[@a13375572211](/a13375572211) did you try to address this test case? I faced same problem and there are no buttons for report "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@a13375572211](/a13375572211) bro need longest i found invalid then count start from 0"
                    },
                    {
                        "username": "a13375572211",
                        "content": "The answer is 2 but i got 4 and its saying incorrect, but i think its suppose to be 4 because ()(() has 2 valid parentheses"
                    },
                    {
                        "username": "dj_ios1988",
                        "content": "from the description:\nInput: \"(()\"\nOutput: 2\n\nand in the testcase\nInput: “\"()(()\"”\nOutput: 4\nExpected :2\n\nwhy these two have diferent answer of \"(()\" ?\n"
                    },
                    {
                        "username": "shubhankadam",
                        "content": "[@a13375572211](/a13375572211) it expects the longest correct sequence, here it is 2, since the sequence is broken by \\'(\\' in the middle\\n"
                    },
                    {
                        "username": "a13375572211",
                        "content": "Exactly bro, I have the same question"
                    },
                    {
                        "username": "shawngao",
                        "content": "@administrators Is this intended or not?\\n\\nAll Java solution will TLE on this test case:\\n\\n\"((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\""
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Dynamic Programming\n\n  \n**Approach 3:** Using Stack\n\n  \n**Approach 4:** Without extra space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "MohitBansal_",
                        "content": "i done  this question by storing index\\'s of opening bracket in stack\\ncan any body know  other approach? "
                    },
                    {
                        "username": "1337beef",
                        "content": "Is this  (())  counted as valid?"
                    },
                    {
                        "username": "manishsinghrajwar80",
                        "content": "yes"
                    },
                    {
                        "username": "Om_Kumar_Singh",
                        "content": "Keep in mind that string must be valid, for example \"()(()\" answer will be 2. "
                    },
                    {
                        "username": "10gksten",
                        "content": "s = \"()(())\"\\nhow come the expected output is 6?"
                    },
                    {
                        "username": "default-writer",
                        "content": "by definition any sequence not breaking the source rules are valid"
                    },
                    {
                        "username": "10gksten",
                        "content": "[@MrLambda42](/MrLambda42) I will take a look on the pdf and get back on this. Thankyou"
                    },
                    {
                        "username": "MrLambda42",
                        "content": "Looks like it\\'s the longest valid sequence of consecutive properly closed parentheses [len(\"()\") + len(\"(())\")] and not just longest singular sequence of properly closed parentheses like max[len(\"()\"), len(\"(())\")].\\n\\nex: \"()(()\" gives 2 because the second ( is not closed, so the streak is maxed out at 2.\\nOn the other hand, ()(()) has two consecutive sequences that match to 2 + 4 => \"()\" + \"(())\" = 6.\\n\\nThere are some graphs in https://madalgo.au.dk/fileadmin/madalgo/OA_PDF_s/C471.pdf that illustrate how parentheses are balanced and how one may reach the conclusion of the longest consecutive sequence of closed parentheses."
                    }
                ]
            },
            {
                "id": 1572211,
                "content": [
                    {
                        "username": "uuisafresh",
                        "content": "So in this case I use stack and an array, and then change this problem as **finding longest continuous 1 in a 01 array**. Let me tell how to do it.\\n\\nFirst, stack push position of each '(', then when we meet ')' I pop stack to find its match'('\\uff0c place both ')' and '(' as 1 in array\\n\\nFor example, (()()\\uff0carray should look like[0,1,1,1,1]\\n\\nThen it is super easy, to find out longest substring that all items are 1 !!!"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Here\\'s the Python implementation of this solution!\\n\\n```\\ndef longestValidParentheses(s: str) -> int:\\n        # Convert to an array of 1s\\n        stack = []\\n        ans = [0] * len(s)\\n\\n        for i, char in enumerate(s):\\n            if not stack or char == \"(\":\\n                stack.append((char, i))\\n            \\n            elif char == \")\":\\n                if stack[-1][0] == \"(\":\\n                    _, idx = stack.pop()\\n                    ans[i], ans[idx] = 1, 1\\n                else:\\n                    stack.append((\")\", i))\\n\\n        # Now find the longest substring of 1s\\n        ones = 0\\n        ret = 0\\n        for char in ans:\\n            if char == 1:\\n                ones+=1\\n                ret = max(ret, ones)\\n            else:\\n                ones = 0\\n        \\n        return ret\\n```"
                    },
                    {
                        "username": "Simonvu",
                        "content": "brilliant!!"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@PredatorMK2](/PredatorMK2) do you fully understand his approach?"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "this code will fail because of testcase \")(\" as it is not balanced and this approach will return 2 for it\\n"
                    },
                    {
                        "username": "lotus18",
                        "content": "Great Idea!\\n\\nCode For The Above Approach\\n\\nclass Solution \\n{\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        stack<pair<int,int>> st;\\n        int n=s.size();\\n        vector<int> v(n,0);\\n        for(int x=0; x<n; x++)\\n        {\\n            if(s[x]==\\'(\\') st.push({s[x],x});\\n            else\\n            {\\n                if(!st.empty() && st.top().first==\\'(\\')\\n                {\\n                    v[x]=1;\\n                    v[st.top().second]=1;\\n                    st.pop();\\n                }\\n            }\\n        }\\n        int start=-1, end=-1;\\n        int ans=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(v[x]==1)\\n            {\\n                start=x;\\n                int i=x+1;\\n                while(i<n && v[i]) i++;\\n                end=i-1;\\n                x=end;\\n                ans=max(ans,end-start+1);\\n                start=-1,end=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "viocost",
                        "content": "The description only shows example with ()() sequences being correct.\\nHow about this: (()()) or this ((()(())))? Are they correct?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Yep they\\'re correct"
                    },
                    {
                        "username": "Akshay1740",
                        "content": "yes they are also correct."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "This is just a monotonic Stack problem like Next Greater element or Previous Smaller element but the only difference is that we are trying to maintain the order inside the stack instead of a monotonically increasing or decreasing sequence.\\n\\nStack Problems can be broken down into 1 or 2 algorithmic techniques and this is one of them!\\n\\nSimilar Problems :\\nNext Greater Element\\nNext Smaller Element\\nPrevious Greater Element\\nPrevious Smaller Element\\nLargest Rectangle in Histogram\\n\\nCheers && Happy Coding !"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Thanks man. "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "really helpful!!!"
                    },
                    {
                        "username": "av9ash",
                        "content": "()(() how is this the longest valid parentheses? Answer is 4 I think its 2\\nCan someone please explain"
                    },
                    {
                        "username": "abdulwaheed333",
                        "content": "Of course ! you are right but  first we have to find is it valid or not? .So in this there are two valid outputs () and (). length is 4."
                    },
                    {
                        "username": "singhabhinash",
                        "content": "think your logic based on below test case, it will work\ns = \"()((())(()()()\", longestValidParentheses = max(2, 4, 6) = 6"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "I realised that, questions is asking for longest possible substring , not the subsequence.  In case of subsequence ans will be 4, and incase of substring ans will 2"
                    },
                    {
                        "username": "Cozmos77",
                        "content": "[@a13375572211](/a13375572211) exactly ,faced the same issue and i think the answer should be 4 rather than 2.\\n"
                    },
                    {
                        "username": "calm27",
                        "content": "[@a13375572211](/a13375572211) did you try to address this test case? I faced same problem and there are no buttons for report "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@a13375572211](/a13375572211) bro need longest i found invalid then count start from 0"
                    },
                    {
                        "username": "a13375572211",
                        "content": "The answer is 2 but i got 4 and its saying incorrect, but i think its suppose to be 4 because ()(() has 2 valid parentheses"
                    },
                    {
                        "username": "dj_ios1988",
                        "content": "from the description:\nInput: \"(()\"\nOutput: 2\n\nand in the testcase\nInput: “\"()(()\"”\nOutput: 4\nExpected :2\n\nwhy these two have diferent answer of \"(()\" ?\n"
                    },
                    {
                        "username": "shubhankadam",
                        "content": "[@a13375572211](/a13375572211) it expects the longest correct sequence, here it is 2, since the sequence is broken by \\'(\\' in the middle\\n"
                    },
                    {
                        "username": "a13375572211",
                        "content": "Exactly bro, I have the same question"
                    },
                    {
                        "username": "shawngao",
                        "content": "@administrators Is this intended or not?\\n\\nAll Java solution will TLE on this test case:\\n\\n\"((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\""
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Dynamic Programming\n\n  \n**Approach 3:** Using Stack\n\n  \n**Approach 4:** Without extra space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "MohitBansal_",
                        "content": "i done  this question by storing index\\'s of opening bracket in stack\\ncan any body know  other approach? "
                    },
                    {
                        "username": "1337beef",
                        "content": "Is this  (())  counted as valid?"
                    },
                    {
                        "username": "manishsinghrajwar80",
                        "content": "yes"
                    },
                    {
                        "username": "Om_Kumar_Singh",
                        "content": "Keep in mind that string must be valid, for example \"()(()\" answer will be 2. "
                    },
                    {
                        "username": "10gksten",
                        "content": "s = \"()(())\"\\nhow come the expected output is 6?"
                    },
                    {
                        "username": "default-writer",
                        "content": "by definition any sequence not breaking the source rules are valid"
                    },
                    {
                        "username": "10gksten",
                        "content": "[@MrLambda42](/MrLambda42) I will take a look on the pdf and get back on this. Thankyou"
                    },
                    {
                        "username": "MrLambda42",
                        "content": "Looks like it\\'s the longest valid sequence of consecutive properly closed parentheses [len(\"()\") + len(\"(())\")] and not just longest singular sequence of properly closed parentheses like max[len(\"()\"), len(\"(())\")].\\n\\nex: \"()(()\" gives 2 because the second ( is not closed, so the streak is maxed out at 2.\\nOn the other hand, ()(()) has two consecutive sequences that match to 2 + 4 => \"()\" + \"(())\" = 6.\\n\\nThere are some graphs in https://madalgo.au.dk/fileadmin/madalgo/OA_PDF_s/C471.pdf that illustrate how parentheses are balanced and how one may reach the conclusion of the longest consecutive sequence of closed parentheses."
                    }
                ]
            },
            {
                "id": 1568853,
                "content": [
                    {
                        "username": "uuisafresh",
                        "content": "So in this case I use stack and an array, and then change this problem as **finding longest continuous 1 in a 01 array**. Let me tell how to do it.\\n\\nFirst, stack push position of each '(', then when we meet ')' I pop stack to find its match'('\\uff0c place both ')' and '(' as 1 in array\\n\\nFor example, (()()\\uff0carray should look like[0,1,1,1,1]\\n\\nThen it is super easy, to find out longest substring that all items are 1 !!!"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Here\\'s the Python implementation of this solution!\\n\\n```\\ndef longestValidParentheses(s: str) -> int:\\n        # Convert to an array of 1s\\n        stack = []\\n        ans = [0] * len(s)\\n\\n        for i, char in enumerate(s):\\n            if not stack or char == \"(\":\\n                stack.append((char, i))\\n            \\n            elif char == \")\":\\n                if stack[-1][0] == \"(\":\\n                    _, idx = stack.pop()\\n                    ans[i], ans[idx] = 1, 1\\n                else:\\n                    stack.append((\")\", i))\\n\\n        # Now find the longest substring of 1s\\n        ones = 0\\n        ret = 0\\n        for char in ans:\\n            if char == 1:\\n                ones+=1\\n                ret = max(ret, ones)\\n            else:\\n                ones = 0\\n        \\n        return ret\\n```"
                    },
                    {
                        "username": "Simonvu",
                        "content": "brilliant!!"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@PredatorMK2](/PredatorMK2) do you fully understand his approach?"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "this code will fail because of testcase \")(\" as it is not balanced and this approach will return 2 for it\\n"
                    },
                    {
                        "username": "lotus18",
                        "content": "Great Idea!\\n\\nCode For The Above Approach\\n\\nclass Solution \\n{\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        stack<pair<int,int>> st;\\n        int n=s.size();\\n        vector<int> v(n,0);\\n        for(int x=0; x<n; x++)\\n        {\\n            if(s[x]==\\'(\\') st.push({s[x],x});\\n            else\\n            {\\n                if(!st.empty() && st.top().first==\\'(\\')\\n                {\\n                    v[x]=1;\\n                    v[st.top().second]=1;\\n                    st.pop();\\n                }\\n            }\\n        }\\n        int start=-1, end=-1;\\n        int ans=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(v[x]==1)\\n            {\\n                start=x;\\n                int i=x+1;\\n                while(i<n && v[i]) i++;\\n                end=i-1;\\n                x=end;\\n                ans=max(ans,end-start+1);\\n                start=-1,end=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "viocost",
                        "content": "The description only shows example with ()() sequences being correct.\\nHow about this: (()()) or this ((()(())))? Are they correct?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Yep they\\'re correct"
                    },
                    {
                        "username": "Akshay1740",
                        "content": "yes they are also correct."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "This is just a monotonic Stack problem like Next Greater element or Previous Smaller element but the only difference is that we are trying to maintain the order inside the stack instead of a monotonically increasing or decreasing sequence.\\n\\nStack Problems can be broken down into 1 or 2 algorithmic techniques and this is one of them!\\n\\nSimilar Problems :\\nNext Greater Element\\nNext Smaller Element\\nPrevious Greater Element\\nPrevious Smaller Element\\nLargest Rectangle in Histogram\\n\\nCheers && Happy Coding !"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Thanks man. "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "really helpful!!!"
                    },
                    {
                        "username": "av9ash",
                        "content": "()(() how is this the longest valid parentheses? Answer is 4 I think its 2\\nCan someone please explain"
                    },
                    {
                        "username": "abdulwaheed333",
                        "content": "Of course ! you are right but  first we have to find is it valid or not? .So in this there are two valid outputs () and (). length is 4."
                    },
                    {
                        "username": "singhabhinash",
                        "content": "think your logic based on below test case, it will work\ns = \"()((())(()()()\", longestValidParentheses = max(2, 4, 6) = 6"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "I realised that, questions is asking for longest possible substring , not the subsequence.  In case of subsequence ans will be 4, and incase of substring ans will 2"
                    },
                    {
                        "username": "Cozmos77",
                        "content": "[@a13375572211](/a13375572211) exactly ,faced the same issue and i think the answer should be 4 rather than 2.\\n"
                    },
                    {
                        "username": "calm27",
                        "content": "[@a13375572211](/a13375572211) did you try to address this test case? I faced same problem and there are no buttons for report "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@a13375572211](/a13375572211) bro need longest i found invalid then count start from 0"
                    },
                    {
                        "username": "a13375572211",
                        "content": "The answer is 2 but i got 4 and its saying incorrect, but i think its suppose to be 4 because ()(() has 2 valid parentheses"
                    },
                    {
                        "username": "dj_ios1988",
                        "content": "from the description:\nInput: \"(()\"\nOutput: 2\n\nand in the testcase\nInput: “\"()(()\"”\nOutput: 4\nExpected :2\n\nwhy these two have diferent answer of \"(()\" ?\n"
                    },
                    {
                        "username": "shubhankadam",
                        "content": "[@a13375572211](/a13375572211) it expects the longest correct sequence, here it is 2, since the sequence is broken by \\'(\\' in the middle\\n"
                    },
                    {
                        "username": "a13375572211",
                        "content": "Exactly bro, I have the same question"
                    },
                    {
                        "username": "shawngao",
                        "content": "@administrators Is this intended or not?\\n\\nAll Java solution will TLE on this test case:\\n\\n\"((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\""
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Dynamic Programming\n\n  \n**Approach 3:** Using Stack\n\n  \n**Approach 4:** Without extra space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "MohitBansal_",
                        "content": "i done  this question by storing index\\'s of opening bracket in stack\\ncan any body know  other approach? "
                    },
                    {
                        "username": "1337beef",
                        "content": "Is this  (())  counted as valid?"
                    },
                    {
                        "username": "manishsinghrajwar80",
                        "content": "yes"
                    },
                    {
                        "username": "Om_Kumar_Singh",
                        "content": "Keep in mind that string must be valid, for example \"()(()\" answer will be 2. "
                    },
                    {
                        "username": "10gksten",
                        "content": "s = \"()(())\"\\nhow come the expected output is 6?"
                    },
                    {
                        "username": "default-writer",
                        "content": "by definition any sequence not breaking the source rules are valid"
                    },
                    {
                        "username": "10gksten",
                        "content": "[@MrLambda42](/MrLambda42) I will take a look on the pdf and get back on this. Thankyou"
                    },
                    {
                        "username": "MrLambda42",
                        "content": "Looks like it\\'s the longest valid sequence of consecutive properly closed parentheses [len(\"()\") + len(\"(())\")] and not just longest singular sequence of properly closed parentheses like max[len(\"()\"), len(\"(())\")].\\n\\nex: \"()(()\" gives 2 because the second ( is not closed, so the streak is maxed out at 2.\\nOn the other hand, ()(()) has two consecutive sequences that match to 2 + 4 => \"()\" + \"(())\" = 6.\\n\\nThere are some graphs in https://madalgo.au.dk/fileadmin/madalgo/OA_PDF_s/C471.pdf that illustrate how parentheses are balanced and how one may reach the conclusion of the longest consecutive sequence of closed parentheses."
                    }
                ]
            },
            {
                "id": 1566722,
                "content": [
                    {
                        "username": "uuisafresh",
                        "content": "So in this case I use stack and an array, and then change this problem as **finding longest continuous 1 in a 01 array**. Let me tell how to do it.\\n\\nFirst, stack push position of each '(', then when we meet ')' I pop stack to find its match'('\\uff0c place both ')' and '(' as 1 in array\\n\\nFor example, (()()\\uff0carray should look like[0,1,1,1,1]\\n\\nThen it is super easy, to find out longest substring that all items are 1 !!!"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Here\\'s the Python implementation of this solution!\\n\\n```\\ndef longestValidParentheses(s: str) -> int:\\n        # Convert to an array of 1s\\n        stack = []\\n        ans = [0] * len(s)\\n\\n        for i, char in enumerate(s):\\n            if not stack or char == \"(\":\\n                stack.append((char, i))\\n            \\n            elif char == \")\":\\n                if stack[-1][0] == \"(\":\\n                    _, idx = stack.pop()\\n                    ans[i], ans[idx] = 1, 1\\n                else:\\n                    stack.append((\")\", i))\\n\\n        # Now find the longest substring of 1s\\n        ones = 0\\n        ret = 0\\n        for char in ans:\\n            if char == 1:\\n                ones+=1\\n                ret = max(ret, ones)\\n            else:\\n                ones = 0\\n        \\n        return ret\\n```"
                    },
                    {
                        "username": "Simonvu",
                        "content": "brilliant!!"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@PredatorMK2](/PredatorMK2) do you fully understand his approach?"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "this code will fail because of testcase \")(\" as it is not balanced and this approach will return 2 for it\\n"
                    },
                    {
                        "username": "lotus18",
                        "content": "Great Idea!\\n\\nCode For The Above Approach\\n\\nclass Solution \\n{\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        stack<pair<int,int>> st;\\n        int n=s.size();\\n        vector<int> v(n,0);\\n        for(int x=0; x<n; x++)\\n        {\\n            if(s[x]==\\'(\\') st.push({s[x],x});\\n            else\\n            {\\n                if(!st.empty() && st.top().first==\\'(\\')\\n                {\\n                    v[x]=1;\\n                    v[st.top().second]=1;\\n                    st.pop();\\n                }\\n            }\\n        }\\n        int start=-1, end=-1;\\n        int ans=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(v[x]==1)\\n            {\\n                start=x;\\n                int i=x+1;\\n                while(i<n && v[i]) i++;\\n                end=i-1;\\n                x=end;\\n                ans=max(ans,end-start+1);\\n                start=-1,end=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "viocost",
                        "content": "The description only shows example with ()() sequences being correct.\\nHow about this: (()()) or this ((()(())))? Are they correct?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Yep they\\'re correct"
                    },
                    {
                        "username": "Akshay1740",
                        "content": "yes they are also correct."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "This is just a monotonic Stack problem like Next Greater element or Previous Smaller element but the only difference is that we are trying to maintain the order inside the stack instead of a monotonically increasing or decreasing sequence.\\n\\nStack Problems can be broken down into 1 or 2 algorithmic techniques and this is one of them!\\n\\nSimilar Problems :\\nNext Greater Element\\nNext Smaller Element\\nPrevious Greater Element\\nPrevious Smaller Element\\nLargest Rectangle in Histogram\\n\\nCheers && Happy Coding !"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Thanks man. "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "really helpful!!!"
                    },
                    {
                        "username": "av9ash",
                        "content": "()(() how is this the longest valid parentheses? Answer is 4 I think its 2\\nCan someone please explain"
                    },
                    {
                        "username": "abdulwaheed333",
                        "content": "Of course ! you are right but  first we have to find is it valid or not? .So in this there are two valid outputs () and (). length is 4."
                    },
                    {
                        "username": "singhabhinash",
                        "content": "think your logic based on below test case, it will work\ns = \"()((())(()()()\", longestValidParentheses = max(2, 4, 6) = 6"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "I realised that, questions is asking for longest possible substring , not the subsequence.  In case of subsequence ans will be 4, and incase of substring ans will 2"
                    },
                    {
                        "username": "Cozmos77",
                        "content": "[@a13375572211](/a13375572211) exactly ,faced the same issue and i think the answer should be 4 rather than 2.\\n"
                    },
                    {
                        "username": "calm27",
                        "content": "[@a13375572211](/a13375572211) did you try to address this test case? I faced same problem and there are no buttons for report "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@a13375572211](/a13375572211) bro need longest i found invalid then count start from 0"
                    },
                    {
                        "username": "a13375572211",
                        "content": "The answer is 2 but i got 4 and its saying incorrect, but i think its suppose to be 4 because ()(() has 2 valid parentheses"
                    },
                    {
                        "username": "dj_ios1988",
                        "content": "from the description:\nInput: \"(()\"\nOutput: 2\n\nand in the testcase\nInput: “\"()(()\"”\nOutput: 4\nExpected :2\n\nwhy these two have diferent answer of \"(()\" ?\n"
                    },
                    {
                        "username": "shubhankadam",
                        "content": "[@a13375572211](/a13375572211) it expects the longest correct sequence, here it is 2, since the sequence is broken by \\'(\\' in the middle\\n"
                    },
                    {
                        "username": "a13375572211",
                        "content": "Exactly bro, I have the same question"
                    },
                    {
                        "username": "shawngao",
                        "content": "@administrators Is this intended or not?\\n\\nAll Java solution will TLE on this test case:\\n\\n\"((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\""
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Dynamic Programming\n\n  \n**Approach 3:** Using Stack\n\n  \n**Approach 4:** Without extra space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "MohitBansal_",
                        "content": "i done  this question by storing index\\'s of opening bracket in stack\\ncan any body know  other approach? "
                    },
                    {
                        "username": "1337beef",
                        "content": "Is this  (())  counted as valid?"
                    },
                    {
                        "username": "manishsinghrajwar80",
                        "content": "yes"
                    },
                    {
                        "username": "Om_Kumar_Singh",
                        "content": "Keep in mind that string must be valid, for example \"()(()\" answer will be 2. "
                    },
                    {
                        "username": "10gksten",
                        "content": "s = \"()(())\"\\nhow come the expected output is 6?"
                    },
                    {
                        "username": "default-writer",
                        "content": "by definition any sequence not breaking the source rules are valid"
                    },
                    {
                        "username": "10gksten",
                        "content": "[@MrLambda42](/MrLambda42) I will take a look on the pdf and get back on this. Thankyou"
                    },
                    {
                        "username": "MrLambda42",
                        "content": "Looks like it\\'s the longest valid sequence of consecutive properly closed parentheses [len(\"()\") + len(\"(())\")] and not just longest singular sequence of properly closed parentheses like max[len(\"()\"), len(\"(())\")].\\n\\nex: \"()(()\" gives 2 because the second ( is not closed, so the streak is maxed out at 2.\\nOn the other hand, ()(()) has two consecutive sequences that match to 2 + 4 => \"()\" + \"(())\" = 6.\\n\\nThere are some graphs in https://madalgo.au.dk/fileadmin/madalgo/OA_PDF_s/C471.pdf that illustrate how parentheses are balanced and how one may reach the conclusion of the longest consecutive sequence of closed parentheses."
                    }
                ]
            },
            {
                "id": 1571085,
                "content": [
                    {
                        "username": "uuisafresh",
                        "content": "So in this case I use stack and an array, and then change this problem as **finding longest continuous 1 in a 01 array**. Let me tell how to do it.\\n\\nFirst, stack push position of each '(', then when we meet ')' I pop stack to find its match'('\\uff0c place both ')' and '(' as 1 in array\\n\\nFor example, (()()\\uff0carray should look like[0,1,1,1,1]\\n\\nThen it is super easy, to find out longest substring that all items are 1 !!!"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Here\\'s the Python implementation of this solution!\\n\\n```\\ndef longestValidParentheses(s: str) -> int:\\n        # Convert to an array of 1s\\n        stack = []\\n        ans = [0] * len(s)\\n\\n        for i, char in enumerate(s):\\n            if not stack or char == \"(\":\\n                stack.append((char, i))\\n            \\n            elif char == \")\":\\n                if stack[-1][0] == \"(\":\\n                    _, idx = stack.pop()\\n                    ans[i], ans[idx] = 1, 1\\n                else:\\n                    stack.append((\")\", i))\\n\\n        # Now find the longest substring of 1s\\n        ones = 0\\n        ret = 0\\n        for char in ans:\\n            if char == 1:\\n                ones+=1\\n                ret = max(ret, ones)\\n            else:\\n                ones = 0\\n        \\n        return ret\\n```"
                    },
                    {
                        "username": "Simonvu",
                        "content": "brilliant!!"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@PredatorMK2](/PredatorMK2) do you fully understand his approach?"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "this code will fail because of testcase \")(\" as it is not balanced and this approach will return 2 for it\\n"
                    },
                    {
                        "username": "lotus18",
                        "content": "Great Idea!\\n\\nCode For The Above Approach\\n\\nclass Solution \\n{\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        stack<pair<int,int>> st;\\n        int n=s.size();\\n        vector<int> v(n,0);\\n        for(int x=0; x<n; x++)\\n        {\\n            if(s[x]==\\'(\\') st.push({s[x],x});\\n            else\\n            {\\n                if(!st.empty() && st.top().first==\\'(\\')\\n                {\\n                    v[x]=1;\\n                    v[st.top().second]=1;\\n                    st.pop();\\n                }\\n            }\\n        }\\n        int start=-1, end=-1;\\n        int ans=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(v[x]==1)\\n            {\\n                start=x;\\n                int i=x+1;\\n                while(i<n && v[i]) i++;\\n                end=i-1;\\n                x=end;\\n                ans=max(ans,end-start+1);\\n                start=-1,end=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "viocost",
                        "content": "The description only shows example with ()() sequences being correct.\\nHow about this: (()()) or this ((()(())))? Are they correct?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Yep they\\'re correct"
                    },
                    {
                        "username": "Akshay1740",
                        "content": "yes they are also correct."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "This is just a monotonic Stack problem like Next Greater element or Previous Smaller element but the only difference is that we are trying to maintain the order inside the stack instead of a monotonically increasing or decreasing sequence.\\n\\nStack Problems can be broken down into 1 or 2 algorithmic techniques and this is one of them!\\n\\nSimilar Problems :\\nNext Greater Element\\nNext Smaller Element\\nPrevious Greater Element\\nPrevious Smaller Element\\nLargest Rectangle in Histogram\\n\\nCheers && Happy Coding !"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Thanks man. "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "really helpful!!!"
                    },
                    {
                        "username": "av9ash",
                        "content": "()(() how is this the longest valid parentheses? Answer is 4 I think its 2\\nCan someone please explain"
                    },
                    {
                        "username": "abdulwaheed333",
                        "content": "Of course ! you are right but  first we have to find is it valid or not? .So in this there are two valid outputs () and (). length is 4."
                    },
                    {
                        "username": "singhabhinash",
                        "content": "think your logic based on below test case, it will work\ns = \"()((())(()()()\", longestValidParentheses = max(2, 4, 6) = 6"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "I realised that, questions is asking for longest possible substring , not the subsequence.  In case of subsequence ans will be 4, and incase of substring ans will 2"
                    },
                    {
                        "username": "Cozmos77",
                        "content": "[@a13375572211](/a13375572211) exactly ,faced the same issue and i think the answer should be 4 rather than 2.\\n"
                    },
                    {
                        "username": "calm27",
                        "content": "[@a13375572211](/a13375572211) did you try to address this test case? I faced same problem and there are no buttons for report "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@a13375572211](/a13375572211) bro need longest i found invalid then count start from 0"
                    },
                    {
                        "username": "a13375572211",
                        "content": "The answer is 2 but i got 4 and its saying incorrect, but i think its suppose to be 4 because ()(() has 2 valid parentheses"
                    },
                    {
                        "username": "dj_ios1988",
                        "content": "from the description:\nInput: \"(()\"\nOutput: 2\n\nand in the testcase\nInput: “\"()(()\"”\nOutput: 4\nExpected :2\n\nwhy these two have diferent answer of \"(()\" ?\n"
                    },
                    {
                        "username": "shubhankadam",
                        "content": "[@a13375572211](/a13375572211) it expects the longest correct sequence, here it is 2, since the sequence is broken by \\'(\\' in the middle\\n"
                    },
                    {
                        "username": "a13375572211",
                        "content": "Exactly bro, I have the same question"
                    },
                    {
                        "username": "shawngao",
                        "content": "@administrators Is this intended or not?\\n\\nAll Java solution will TLE on this test case:\\n\\n\"((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\""
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Dynamic Programming\n\n  \n**Approach 3:** Using Stack\n\n  \n**Approach 4:** Without extra space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "MohitBansal_",
                        "content": "i done  this question by storing index\\'s of opening bracket in stack\\ncan any body know  other approach? "
                    },
                    {
                        "username": "1337beef",
                        "content": "Is this  (())  counted as valid?"
                    },
                    {
                        "username": "manishsinghrajwar80",
                        "content": "yes"
                    },
                    {
                        "username": "Om_Kumar_Singh",
                        "content": "Keep in mind that string must be valid, for example \"()(()\" answer will be 2. "
                    },
                    {
                        "username": "10gksten",
                        "content": "s = \"()(())\"\\nhow come the expected output is 6?"
                    },
                    {
                        "username": "default-writer",
                        "content": "by definition any sequence not breaking the source rules are valid"
                    },
                    {
                        "username": "10gksten",
                        "content": "[@MrLambda42](/MrLambda42) I will take a look on the pdf and get back on this. Thankyou"
                    },
                    {
                        "username": "MrLambda42",
                        "content": "Looks like it\\'s the longest valid sequence of consecutive properly closed parentheses [len(\"()\") + len(\"(())\")] and not just longest singular sequence of properly closed parentheses like max[len(\"()\"), len(\"(())\")].\\n\\nex: \"()(()\" gives 2 because the second ( is not closed, so the streak is maxed out at 2.\\nOn the other hand, ()(()) has two consecutive sequences that match to 2 + 4 => \"()\" + \"(())\" = 6.\\n\\nThere are some graphs in https://madalgo.au.dk/fileadmin/madalgo/OA_PDF_s/C471.pdf that illustrate how parentheses are balanced and how one may reach the conclusion of the longest consecutive sequence of closed parentheses."
                    }
                ]
            },
            {
                "id": 2042924,
                "content": [
                    {
                        "username": "uuisafresh",
                        "content": "So in this case I use stack and an array, and then change this problem as **finding longest continuous 1 in a 01 array**. Let me tell how to do it.\\n\\nFirst, stack push position of each '(', then when we meet ')' I pop stack to find its match'('\\uff0c place both ')' and '(' as 1 in array\\n\\nFor example, (()()\\uff0carray should look like[0,1,1,1,1]\\n\\nThen it is super easy, to find out longest substring that all items are 1 !!!"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Here\\'s the Python implementation of this solution!\\n\\n```\\ndef longestValidParentheses(s: str) -> int:\\n        # Convert to an array of 1s\\n        stack = []\\n        ans = [0] * len(s)\\n\\n        for i, char in enumerate(s):\\n            if not stack or char == \"(\":\\n                stack.append((char, i))\\n            \\n            elif char == \")\":\\n                if stack[-1][0] == \"(\":\\n                    _, idx = stack.pop()\\n                    ans[i], ans[idx] = 1, 1\\n                else:\\n                    stack.append((\")\", i))\\n\\n        # Now find the longest substring of 1s\\n        ones = 0\\n        ret = 0\\n        for char in ans:\\n            if char == 1:\\n                ones+=1\\n                ret = max(ret, ones)\\n            else:\\n                ones = 0\\n        \\n        return ret\\n```"
                    },
                    {
                        "username": "Simonvu",
                        "content": "brilliant!!"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@PredatorMK2](/PredatorMK2) do you fully understand his approach?"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "this code will fail because of testcase \")(\" as it is not balanced and this approach will return 2 for it\\n"
                    },
                    {
                        "username": "lotus18",
                        "content": "Great Idea!\\n\\nCode For The Above Approach\\n\\nclass Solution \\n{\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        stack<pair<int,int>> st;\\n        int n=s.size();\\n        vector<int> v(n,0);\\n        for(int x=0; x<n; x++)\\n        {\\n            if(s[x]==\\'(\\') st.push({s[x],x});\\n            else\\n            {\\n                if(!st.empty() && st.top().first==\\'(\\')\\n                {\\n                    v[x]=1;\\n                    v[st.top().second]=1;\\n                    st.pop();\\n                }\\n            }\\n        }\\n        int start=-1, end=-1;\\n        int ans=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(v[x]==1)\\n            {\\n                start=x;\\n                int i=x+1;\\n                while(i<n && v[i]) i++;\\n                end=i-1;\\n                x=end;\\n                ans=max(ans,end-start+1);\\n                start=-1,end=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "viocost",
                        "content": "The description only shows example with ()() sequences being correct.\\nHow about this: (()()) or this ((()(())))? Are they correct?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Yep they\\'re correct"
                    },
                    {
                        "username": "Akshay1740",
                        "content": "yes they are also correct."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "This is just a monotonic Stack problem like Next Greater element or Previous Smaller element but the only difference is that we are trying to maintain the order inside the stack instead of a monotonically increasing or decreasing sequence.\\n\\nStack Problems can be broken down into 1 or 2 algorithmic techniques and this is one of them!\\n\\nSimilar Problems :\\nNext Greater Element\\nNext Smaller Element\\nPrevious Greater Element\\nPrevious Smaller Element\\nLargest Rectangle in Histogram\\n\\nCheers && Happy Coding !"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Thanks man. "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "really helpful!!!"
                    },
                    {
                        "username": "av9ash",
                        "content": "()(() how is this the longest valid parentheses? Answer is 4 I think its 2\\nCan someone please explain"
                    },
                    {
                        "username": "abdulwaheed333",
                        "content": "Of course ! you are right but  first we have to find is it valid or not? .So in this there are two valid outputs () and (). length is 4."
                    },
                    {
                        "username": "singhabhinash",
                        "content": "think your logic based on below test case, it will work\ns = \"()((())(()()()\", longestValidParentheses = max(2, 4, 6) = 6"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "I realised that, questions is asking for longest possible substring , not the subsequence.  In case of subsequence ans will be 4, and incase of substring ans will 2"
                    },
                    {
                        "username": "Cozmos77",
                        "content": "[@a13375572211](/a13375572211) exactly ,faced the same issue and i think the answer should be 4 rather than 2.\\n"
                    },
                    {
                        "username": "calm27",
                        "content": "[@a13375572211](/a13375572211) did you try to address this test case? I faced same problem and there are no buttons for report "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@a13375572211](/a13375572211) bro need longest i found invalid then count start from 0"
                    },
                    {
                        "username": "a13375572211",
                        "content": "The answer is 2 but i got 4 and its saying incorrect, but i think its suppose to be 4 because ()(() has 2 valid parentheses"
                    },
                    {
                        "username": "dj_ios1988",
                        "content": "from the description:\nInput: \"(()\"\nOutput: 2\n\nand in the testcase\nInput: “\"()(()\"”\nOutput: 4\nExpected :2\n\nwhy these two have diferent answer of \"(()\" ?\n"
                    },
                    {
                        "username": "shubhankadam",
                        "content": "[@a13375572211](/a13375572211) it expects the longest correct sequence, here it is 2, since the sequence is broken by \\'(\\' in the middle\\n"
                    },
                    {
                        "username": "a13375572211",
                        "content": "Exactly bro, I have the same question"
                    },
                    {
                        "username": "shawngao",
                        "content": "@administrators Is this intended or not?\\n\\nAll Java solution will TLE on this test case:\\n\\n\"((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\""
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Dynamic Programming\n\n  \n**Approach 3:** Using Stack\n\n  \n**Approach 4:** Without extra space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "MohitBansal_",
                        "content": "i done  this question by storing index\\'s of opening bracket in stack\\ncan any body know  other approach? "
                    },
                    {
                        "username": "1337beef",
                        "content": "Is this  (())  counted as valid?"
                    },
                    {
                        "username": "manishsinghrajwar80",
                        "content": "yes"
                    },
                    {
                        "username": "Om_Kumar_Singh",
                        "content": "Keep in mind that string must be valid, for example \"()(()\" answer will be 2. "
                    },
                    {
                        "username": "10gksten",
                        "content": "s = \"()(())\"\\nhow come the expected output is 6?"
                    },
                    {
                        "username": "default-writer",
                        "content": "by definition any sequence not breaking the source rules are valid"
                    },
                    {
                        "username": "10gksten",
                        "content": "[@MrLambda42](/MrLambda42) I will take a look on the pdf and get back on this. Thankyou"
                    },
                    {
                        "username": "MrLambda42",
                        "content": "Looks like it\\'s the longest valid sequence of consecutive properly closed parentheses [len(\"()\") + len(\"(())\")] and not just longest singular sequence of properly closed parentheses like max[len(\"()\"), len(\"(())\")].\\n\\nex: \"()(()\" gives 2 because the second ( is not closed, so the streak is maxed out at 2.\\nOn the other hand, ()(()) has two consecutive sequences that match to 2 + 4 => \"()\" + \"(())\" = 6.\\n\\nThere are some graphs in https://madalgo.au.dk/fileadmin/madalgo/OA_PDF_s/C471.pdf that illustrate how parentheses are balanced and how one may reach the conclusion of the longest consecutive sequence of closed parentheses."
                    }
                ]
            },
            {
                "id": 1704382,
                "content": [
                    {
                        "username": "uuisafresh",
                        "content": "So in this case I use stack and an array, and then change this problem as **finding longest continuous 1 in a 01 array**. Let me tell how to do it.\\n\\nFirst, stack push position of each '(', then when we meet ')' I pop stack to find its match'('\\uff0c place both ')' and '(' as 1 in array\\n\\nFor example, (()()\\uff0carray should look like[0,1,1,1,1]\\n\\nThen it is super easy, to find out longest substring that all items are 1 !!!"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Here\\'s the Python implementation of this solution!\\n\\n```\\ndef longestValidParentheses(s: str) -> int:\\n        # Convert to an array of 1s\\n        stack = []\\n        ans = [0] * len(s)\\n\\n        for i, char in enumerate(s):\\n            if not stack or char == \"(\":\\n                stack.append((char, i))\\n            \\n            elif char == \")\":\\n                if stack[-1][0] == \"(\":\\n                    _, idx = stack.pop()\\n                    ans[i], ans[idx] = 1, 1\\n                else:\\n                    stack.append((\")\", i))\\n\\n        # Now find the longest substring of 1s\\n        ones = 0\\n        ret = 0\\n        for char in ans:\\n            if char == 1:\\n                ones+=1\\n                ret = max(ret, ones)\\n            else:\\n                ones = 0\\n        \\n        return ret\\n```"
                    },
                    {
                        "username": "Simonvu",
                        "content": "brilliant!!"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@PredatorMK2](/PredatorMK2) do you fully understand his approach?"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "this code will fail because of testcase \")(\" as it is not balanced and this approach will return 2 for it\\n"
                    },
                    {
                        "username": "lotus18",
                        "content": "Great Idea!\\n\\nCode For The Above Approach\\n\\nclass Solution \\n{\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        stack<pair<int,int>> st;\\n        int n=s.size();\\n        vector<int> v(n,0);\\n        for(int x=0; x<n; x++)\\n        {\\n            if(s[x]==\\'(\\') st.push({s[x],x});\\n            else\\n            {\\n                if(!st.empty() && st.top().first==\\'(\\')\\n                {\\n                    v[x]=1;\\n                    v[st.top().second]=1;\\n                    st.pop();\\n                }\\n            }\\n        }\\n        int start=-1, end=-1;\\n        int ans=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(v[x]==1)\\n            {\\n                start=x;\\n                int i=x+1;\\n                while(i<n && v[i]) i++;\\n                end=i-1;\\n                x=end;\\n                ans=max(ans,end-start+1);\\n                start=-1,end=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "viocost",
                        "content": "The description only shows example with ()() sequences being correct.\\nHow about this: (()()) or this ((()(())))? Are they correct?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Yep they\\'re correct"
                    },
                    {
                        "username": "Akshay1740",
                        "content": "yes they are also correct."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "This is just a monotonic Stack problem like Next Greater element or Previous Smaller element but the only difference is that we are trying to maintain the order inside the stack instead of a monotonically increasing or decreasing sequence.\\n\\nStack Problems can be broken down into 1 or 2 algorithmic techniques and this is one of them!\\n\\nSimilar Problems :\\nNext Greater Element\\nNext Smaller Element\\nPrevious Greater Element\\nPrevious Smaller Element\\nLargest Rectangle in Histogram\\n\\nCheers && Happy Coding !"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Thanks man. "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "really helpful!!!"
                    },
                    {
                        "username": "av9ash",
                        "content": "()(() how is this the longest valid parentheses? Answer is 4 I think its 2\\nCan someone please explain"
                    },
                    {
                        "username": "abdulwaheed333",
                        "content": "Of course ! you are right but  first we have to find is it valid or not? .So in this there are two valid outputs () and (). length is 4."
                    },
                    {
                        "username": "singhabhinash",
                        "content": "think your logic based on below test case, it will work\ns = \"()((())(()()()\", longestValidParentheses = max(2, 4, 6) = 6"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "I realised that, questions is asking for longest possible substring , not the subsequence.  In case of subsequence ans will be 4, and incase of substring ans will 2"
                    },
                    {
                        "username": "Cozmos77",
                        "content": "[@a13375572211](/a13375572211) exactly ,faced the same issue and i think the answer should be 4 rather than 2.\\n"
                    },
                    {
                        "username": "calm27",
                        "content": "[@a13375572211](/a13375572211) did you try to address this test case? I faced same problem and there are no buttons for report "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@a13375572211](/a13375572211) bro need longest i found invalid then count start from 0"
                    },
                    {
                        "username": "a13375572211",
                        "content": "The answer is 2 but i got 4 and its saying incorrect, but i think its suppose to be 4 because ()(() has 2 valid parentheses"
                    },
                    {
                        "username": "dj_ios1988",
                        "content": "from the description:\nInput: \"(()\"\nOutput: 2\n\nand in the testcase\nInput: “\"()(()\"”\nOutput: 4\nExpected :2\n\nwhy these two have diferent answer of \"(()\" ?\n"
                    },
                    {
                        "username": "shubhankadam",
                        "content": "[@a13375572211](/a13375572211) it expects the longest correct sequence, here it is 2, since the sequence is broken by \\'(\\' in the middle\\n"
                    },
                    {
                        "username": "a13375572211",
                        "content": "Exactly bro, I have the same question"
                    },
                    {
                        "username": "shawngao",
                        "content": "@administrators Is this intended or not?\\n\\nAll Java solution will TLE on this test case:\\n\\n\"((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\""
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Dynamic Programming\n\n  \n**Approach 3:** Using Stack\n\n  \n**Approach 4:** Without extra space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "MohitBansal_",
                        "content": "i done  this question by storing index\\'s of opening bracket in stack\\ncan any body know  other approach? "
                    },
                    {
                        "username": "1337beef",
                        "content": "Is this  (())  counted as valid?"
                    },
                    {
                        "username": "manishsinghrajwar80",
                        "content": "yes"
                    },
                    {
                        "username": "Om_Kumar_Singh",
                        "content": "Keep in mind that string must be valid, for example \"()(()\" answer will be 2. "
                    },
                    {
                        "username": "10gksten",
                        "content": "s = \"()(())\"\\nhow come the expected output is 6?"
                    },
                    {
                        "username": "default-writer",
                        "content": "by definition any sequence not breaking the source rules are valid"
                    },
                    {
                        "username": "10gksten",
                        "content": "[@MrLambda42](/MrLambda42) I will take a look on the pdf and get back on this. Thankyou"
                    },
                    {
                        "username": "MrLambda42",
                        "content": "Looks like it\\'s the longest valid sequence of consecutive properly closed parentheses [len(\"()\") + len(\"(())\")] and not just longest singular sequence of properly closed parentheses like max[len(\"()\"), len(\"(())\")].\\n\\nex: \"()(()\" gives 2 because the second ( is not closed, so the streak is maxed out at 2.\\nOn the other hand, ()(()) has two consecutive sequences that match to 2 + 4 => \"()\" + \"(())\" = 6.\\n\\nThere are some graphs in https://madalgo.au.dk/fileadmin/madalgo/OA_PDF_s/C471.pdf that illustrate how parentheses are balanced and how one may reach the conclusion of the longest consecutive sequence of closed parentheses."
                    }
                ]
            },
            {
                "id": 1571083,
                "content": [
                    {
                        "username": "uuisafresh",
                        "content": "So in this case I use stack and an array, and then change this problem as **finding longest continuous 1 in a 01 array**. Let me tell how to do it.\\n\\nFirst, stack push position of each '(', then when we meet ')' I pop stack to find its match'('\\uff0c place both ')' and '(' as 1 in array\\n\\nFor example, (()()\\uff0carray should look like[0,1,1,1,1]\\n\\nThen it is super easy, to find out longest substring that all items are 1 !!!"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Here\\'s the Python implementation of this solution!\\n\\n```\\ndef longestValidParentheses(s: str) -> int:\\n        # Convert to an array of 1s\\n        stack = []\\n        ans = [0] * len(s)\\n\\n        for i, char in enumerate(s):\\n            if not stack or char == \"(\":\\n                stack.append((char, i))\\n            \\n            elif char == \")\":\\n                if stack[-1][0] == \"(\":\\n                    _, idx = stack.pop()\\n                    ans[i], ans[idx] = 1, 1\\n                else:\\n                    stack.append((\")\", i))\\n\\n        # Now find the longest substring of 1s\\n        ones = 0\\n        ret = 0\\n        for char in ans:\\n            if char == 1:\\n                ones+=1\\n                ret = max(ret, ones)\\n            else:\\n                ones = 0\\n        \\n        return ret\\n```"
                    },
                    {
                        "username": "Simonvu",
                        "content": "brilliant!!"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@PredatorMK2](/PredatorMK2) do you fully understand his approach?"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "this code will fail because of testcase \")(\" as it is not balanced and this approach will return 2 for it\\n"
                    },
                    {
                        "username": "lotus18",
                        "content": "Great Idea!\\n\\nCode For The Above Approach\\n\\nclass Solution \\n{\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        stack<pair<int,int>> st;\\n        int n=s.size();\\n        vector<int> v(n,0);\\n        for(int x=0; x<n; x++)\\n        {\\n            if(s[x]==\\'(\\') st.push({s[x],x});\\n            else\\n            {\\n                if(!st.empty() && st.top().first==\\'(\\')\\n                {\\n                    v[x]=1;\\n                    v[st.top().second]=1;\\n                    st.pop();\\n                }\\n            }\\n        }\\n        int start=-1, end=-1;\\n        int ans=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(v[x]==1)\\n            {\\n                start=x;\\n                int i=x+1;\\n                while(i<n && v[i]) i++;\\n                end=i-1;\\n                x=end;\\n                ans=max(ans,end-start+1);\\n                start=-1,end=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "viocost",
                        "content": "The description only shows example with ()() sequences being correct.\\nHow about this: (()()) or this ((()(())))? Are they correct?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Yep they\\'re correct"
                    },
                    {
                        "username": "Akshay1740",
                        "content": "yes they are also correct."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "This is just a monotonic Stack problem like Next Greater element or Previous Smaller element but the only difference is that we are trying to maintain the order inside the stack instead of a monotonically increasing or decreasing sequence.\\n\\nStack Problems can be broken down into 1 or 2 algorithmic techniques and this is one of them!\\n\\nSimilar Problems :\\nNext Greater Element\\nNext Smaller Element\\nPrevious Greater Element\\nPrevious Smaller Element\\nLargest Rectangle in Histogram\\n\\nCheers && Happy Coding !"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Thanks man. "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "really helpful!!!"
                    },
                    {
                        "username": "av9ash",
                        "content": "()(() how is this the longest valid parentheses? Answer is 4 I think its 2\\nCan someone please explain"
                    },
                    {
                        "username": "abdulwaheed333",
                        "content": "Of course ! you are right but  first we have to find is it valid or not? .So in this there are two valid outputs () and (). length is 4."
                    },
                    {
                        "username": "singhabhinash",
                        "content": "think your logic based on below test case, it will work\ns = \"()((())(()()()\", longestValidParentheses = max(2, 4, 6) = 6"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "I realised that, questions is asking for longest possible substring , not the subsequence.  In case of subsequence ans will be 4, and incase of substring ans will 2"
                    },
                    {
                        "username": "Cozmos77",
                        "content": "[@a13375572211](/a13375572211) exactly ,faced the same issue and i think the answer should be 4 rather than 2.\\n"
                    },
                    {
                        "username": "calm27",
                        "content": "[@a13375572211](/a13375572211) did you try to address this test case? I faced same problem and there are no buttons for report "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@a13375572211](/a13375572211) bro need longest i found invalid then count start from 0"
                    },
                    {
                        "username": "a13375572211",
                        "content": "The answer is 2 but i got 4 and its saying incorrect, but i think its suppose to be 4 because ()(() has 2 valid parentheses"
                    },
                    {
                        "username": "dj_ios1988",
                        "content": "from the description:\nInput: \"(()\"\nOutput: 2\n\nand in the testcase\nInput: “\"()(()\"”\nOutput: 4\nExpected :2\n\nwhy these two have diferent answer of \"(()\" ?\n"
                    },
                    {
                        "username": "shubhankadam",
                        "content": "[@a13375572211](/a13375572211) it expects the longest correct sequence, here it is 2, since the sequence is broken by \\'(\\' in the middle\\n"
                    },
                    {
                        "username": "a13375572211",
                        "content": "Exactly bro, I have the same question"
                    },
                    {
                        "username": "shawngao",
                        "content": "@administrators Is this intended or not?\\n\\nAll Java solution will TLE on this test case:\\n\\n\"((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\""
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Dynamic Programming\n\n  \n**Approach 3:** Using Stack\n\n  \n**Approach 4:** Without extra space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "MohitBansal_",
                        "content": "i done  this question by storing index\\'s of opening bracket in stack\\ncan any body know  other approach? "
                    },
                    {
                        "username": "1337beef",
                        "content": "Is this  (())  counted as valid?"
                    },
                    {
                        "username": "manishsinghrajwar80",
                        "content": "yes"
                    },
                    {
                        "username": "Om_Kumar_Singh",
                        "content": "Keep in mind that string must be valid, for example \"()(()\" answer will be 2. "
                    },
                    {
                        "username": "10gksten",
                        "content": "s = \"()(())\"\\nhow come the expected output is 6?"
                    },
                    {
                        "username": "default-writer",
                        "content": "by definition any sequence not breaking the source rules are valid"
                    },
                    {
                        "username": "10gksten",
                        "content": "[@MrLambda42](/MrLambda42) I will take a look on the pdf and get back on this. Thankyou"
                    },
                    {
                        "username": "MrLambda42",
                        "content": "Looks like it\\'s the longest valid sequence of consecutive properly closed parentheses [len(\"()\") + len(\"(())\")] and not just longest singular sequence of properly closed parentheses like max[len(\"()\"), len(\"(())\")].\\n\\nex: \"()(()\" gives 2 because the second ( is not closed, so the streak is maxed out at 2.\\nOn the other hand, ()(()) has two consecutive sequences that match to 2 + 4 => \"()\" + \"(())\" = 6.\\n\\nThere are some graphs in https://madalgo.au.dk/fileadmin/madalgo/OA_PDF_s/C471.pdf that illustrate how parentheses are balanced and how one may reach the conclusion of the longest consecutive sequence of closed parentheses."
                    }
                ]
            },
            {
                "id": 1572316,
                "content": [
                    {
                        "username": "uuisafresh",
                        "content": "So in this case I use stack and an array, and then change this problem as **finding longest continuous 1 in a 01 array**. Let me tell how to do it.\\n\\nFirst, stack push position of each '(', then when we meet ')' I pop stack to find its match'('\\uff0c place both ')' and '(' as 1 in array\\n\\nFor example, (()()\\uff0carray should look like[0,1,1,1,1]\\n\\nThen it is super easy, to find out longest substring that all items are 1 !!!"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Here\\'s the Python implementation of this solution!\\n\\n```\\ndef longestValidParentheses(s: str) -> int:\\n        # Convert to an array of 1s\\n        stack = []\\n        ans = [0] * len(s)\\n\\n        for i, char in enumerate(s):\\n            if not stack or char == \"(\":\\n                stack.append((char, i))\\n            \\n            elif char == \")\":\\n                if stack[-1][0] == \"(\":\\n                    _, idx = stack.pop()\\n                    ans[i], ans[idx] = 1, 1\\n                else:\\n                    stack.append((\")\", i))\\n\\n        # Now find the longest substring of 1s\\n        ones = 0\\n        ret = 0\\n        for char in ans:\\n            if char == 1:\\n                ones+=1\\n                ret = max(ret, ones)\\n            else:\\n                ones = 0\\n        \\n        return ret\\n```"
                    },
                    {
                        "username": "Simonvu",
                        "content": "brilliant!!"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@PredatorMK2](/PredatorMK2) do you fully understand his approach?"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "this code will fail because of testcase \")(\" as it is not balanced and this approach will return 2 for it\\n"
                    },
                    {
                        "username": "lotus18",
                        "content": "Great Idea!\\n\\nCode For The Above Approach\\n\\nclass Solution \\n{\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        stack<pair<int,int>> st;\\n        int n=s.size();\\n        vector<int> v(n,0);\\n        for(int x=0; x<n; x++)\\n        {\\n            if(s[x]==\\'(\\') st.push({s[x],x});\\n            else\\n            {\\n                if(!st.empty() && st.top().first==\\'(\\')\\n                {\\n                    v[x]=1;\\n                    v[st.top().second]=1;\\n                    st.pop();\\n                }\\n            }\\n        }\\n        int start=-1, end=-1;\\n        int ans=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(v[x]==1)\\n            {\\n                start=x;\\n                int i=x+1;\\n                while(i<n && v[i]) i++;\\n                end=i-1;\\n                x=end;\\n                ans=max(ans,end-start+1);\\n                start=-1,end=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "viocost",
                        "content": "The description only shows example with ()() sequences being correct.\\nHow about this: (()()) or this ((()(())))? Are they correct?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Yep they\\'re correct"
                    },
                    {
                        "username": "Akshay1740",
                        "content": "yes they are also correct."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "This is just a monotonic Stack problem like Next Greater element or Previous Smaller element but the only difference is that we are trying to maintain the order inside the stack instead of a monotonically increasing or decreasing sequence.\\n\\nStack Problems can be broken down into 1 or 2 algorithmic techniques and this is one of them!\\n\\nSimilar Problems :\\nNext Greater Element\\nNext Smaller Element\\nPrevious Greater Element\\nPrevious Smaller Element\\nLargest Rectangle in Histogram\\n\\nCheers && Happy Coding !"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Thanks man. "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "really helpful!!!"
                    },
                    {
                        "username": "av9ash",
                        "content": "()(() how is this the longest valid parentheses? Answer is 4 I think its 2\\nCan someone please explain"
                    },
                    {
                        "username": "abdulwaheed333",
                        "content": "Of course ! you are right but  first we have to find is it valid or not? .So in this there are two valid outputs () and (). length is 4."
                    },
                    {
                        "username": "singhabhinash",
                        "content": "think your logic based on below test case, it will work\ns = \"()((())(()()()\", longestValidParentheses = max(2, 4, 6) = 6"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "I realised that, questions is asking for longest possible substring , not the subsequence.  In case of subsequence ans will be 4, and incase of substring ans will 2"
                    },
                    {
                        "username": "Cozmos77",
                        "content": "[@a13375572211](/a13375572211) exactly ,faced the same issue and i think the answer should be 4 rather than 2.\\n"
                    },
                    {
                        "username": "calm27",
                        "content": "[@a13375572211](/a13375572211) did you try to address this test case? I faced same problem and there are no buttons for report "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@a13375572211](/a13375572211) bro need longest i found invalid then count start from 0"
                    },
                    {
                        "username": "a13375572211",
                        "content": "The answer is 2 but i got 4 and its saying incorrect, but i think its suppose to be 4 because ()(() has 2 valid parentheses"
                    },
                    {
                        "username": "dj_ios1988",
                        "content": "from the description:\nInput: \"(()\"\nOutput: 2\n\nand in the testcase\nInput: “\"()(()\"”\nOutput: 4\nExpected :2\n\nwhy these two have diferent answer of \"(()\" ?\n"
                    },
                    {
                        "username": "shubhankadam",
                        "content": "[@a13375572211](/a13375572211) it expects the longest correct sequence, here it is 2, since the sequence is broken by \\'(\\' in the middle\\n"
                    },
                    {
                        "username": "a13375572211",
                        "content": "Exactly bro, I have the same question"
                    },
                    {
                        "username": "shawngao",
                        "content": "@administrators Is this intended or not?\\n\\nAll Java solution will TLE on this test case:\\n\\n\"((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\""
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Dynamic Programming\n\n  \n**Approach 3:** Using Stack\n\n  \n**Approach 4:** Without extra space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "MohitBansal_",
                        "content": "i done  this question by storing index\\'s of opening bracket in stack\\ncan any body know  other approach? "
                    },
                    {
                        "username": "1337beef",
                        "content": "Is this  (())  counted as valid?"
                    },
                    {
                        "username": "manishsinghrajwar80",
                        "content": "yes"
                    },
                    {
                        "username": "Om_Kumar_Singh",
                        "content": "Keep in mind that string must be valid, for example \"()(()\" answer will be 2. "
                    },
                    {
                        "username": "10gksten",
                        "content": "s = \"()(())\"\\nhow come the expected output is 6?"
                    },
                    {
                        "username": "default-writer",
                        "content": "by definition any sequence not breaking the source rules are valid"
                    },
                    {
                        "username": "10gksten",
                        "content": "[@MrLambda42](/MrLambda42) I will take a look on the pdf and get back on this. Thankyou"
                    },
                    {
                        "username": "MrLambda42",
                        "content": "Looks like it\\'s the longest valid sequence of consecutive properly closed parentheses [len(\"()\") + len(\"(())\")] and not just longest singular sequence of properly closed parentheses like max[len(\"()\"), len(\"(())\")].\\n\\nex: \"()(()\" gives 2 because the second ( is not closed, so the streak is maxed out at 2.\\nOn the other hand, ()(()) has two consecutive sequences that match to 2 + 4 => \"()\" + \"(())\" = 6.\\n\\nThere are some graphs in https://madalgo.au.dk/fileadmin/madalgo/OA_PDF_s/C471.pdf that illustrate how parentheses are balanced and how one may reach the conclusion of the longest consecutive sequence of closed parentheses."
                    }
                ]
            },
            {
                "id": 1574996,
                "content": [
                    {
                        "username": "uuisafresh",
                        "content": "So in this case I use stack and an array, and then change this problem as **finding longest continuous 1 in a 01 array**. Let me tell how to do it.\\n\\nFirst, stack push position of each '(', then when we meet ')' I pop stack to find its match'('\\uff0c place both ')' and '(' as 1 in array\\n\\nFor example, (()()\\uff0carray should look like[0,1,1,1,1]\\n\\nThen it is super easy, to find out longest substring that all items are 1 !!!"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Here\\'s the Python implementation of this solution!\\n\\n```\\ndef longestValidParentheses(s: str) -> int:\\n        # Convert to an array of 1s\\n        stack = []\\n        ans = [0] * len(s)\\n\\n        for i, char in enumerate(s):\\n            if not stack or char == \"(\":\\n                stack.append((char, i))\\n            \\n            elif char == \")\":\\n                if stack[-1][0] == \"(\":\\n                    _, idx = stack.pop()\\n                    ans[i], ans[idx] = 1, 1\\n                else:\\n                    stack.append((\")\", i))\\n\\n        # Now find the longest substring of 1s\\n        ones = 0\\n        ret = 0\\n        for char in ans:\\n            if char == 1:\\n                ones+=1\\n                ret = max(ret, ones)\\n            else:\\n                ones = 0\\n        \\n        return ret\\n```"
                    },
                    {
                        "username": "Simonvu",
                        "content": "brilliant!!"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@PredatorMK2](/PredatorMK2) do you fully understand his approach?"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "this code will fail because of testcase \")(\" as it is not balanced and this approach will return 2 for it\\n"
                    },
                    {
                        "username": "lotus18",
                        "content": "Great Idea!\\n\\nCode For The Above Approach\\n\\nclass Solution \\n{\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        stack<pair<int,int>> st;\\n        int n=s.size();\\n        vector<int> v(n,0);\\n        for(int x=0; x<n; x++)\\n        {\\n            if(s[x]==\\'(\\') st.push({s[x],x});\\n            else\\n            {\\n                if(!st.empty() && st.top().first==\\'(\\')\\n                {\\n                    v[x]=1;\\n                    v[st.top().second]=1;\\n                    st.pop();\\n                }\\n            }\\n        }\\n        int start=-1, end=-1;\\n        int ans=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(v[x]==1)\\n            {\\n                start=x;\\n                int i=x+1;\\n                while(i<n && v[i]) i++;\\n                end=i-1;\\n                x=end;\\n                ans=max(ans,end-start+1);\\n                start=-1,end=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "viocost",
                        "content": "The description only shows example with ()() sequences being correct.\\nHow about this: (()()) or this ((()(())))? Are they correct?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Yep they\\'re correct"
                    },
                    {
                        "username": "Akshay1740",
                        "content": "yes they are also correct."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "This is just a monotonic Stack problem like Next Greater element or Previous Smaller element but the only difference is that we are trying to maintain the order inside the stack instead of a monotonically increasing or decreasing sequence.\\n\\nStack Problems can be broken down into 1 or 2 algorithmic techniques and this is one of them!\\n\\nSimilar Problems :\\nNext Greater Element\\nNext Smaller Element\\nPrevious Greater Element\\nPrevious Smaller Element\\nLargest Rectangle in Histogram\\n\\nCheers && Happy Coding !"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Thanks man. "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "really helpful!!!"
                    },
                    {
                        "username": "av9ash",
                        "content": "()(() how is this the longest valid parentheses? Answer is 4 I think its 2\\nCan someone please explain"
                    },
                    {
                        "username": "abdulwaheed333",
                        "content": "Of course ! you are right but  first we have to find is it valid or not? .So in this there are two valid outputs () and (). length is 4."
                    },
                    {
                        "username": "singhabhinash",
                        "content": "think your logic based on below test case, it will work\ns = \"()((())(()()()\", longestValidParentheses = max(2, 4, 6) = 6"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "I realised that, questions is asking for longest possible substring , not the subsequence.  In case of subsequence ans will be 4, and incase of substring ans will 2"
                    },
                    {
                        "username": "Cozmos77",
                        "content": "[@a13375572211](/a13375572211) exactly ,faced the same issue and i think the answer should be 4 rather than 2.\\n"
                    },
                    {
                        "username": "calm27",
                        "content": "[@a13375572211](/a13375572211) did you try to address this test case? I faced same problem and there are no buttons for report "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@a13375572211](/a13375572211) bro need longest i found invalid then count start from 0"
                    },
                    {
                        "username": "a13375572211",
                        "content": "The answer is 2 but i got 4 and its saying incorrect, but i think its suppose to be 4 because ()(() has 2 valid parentheses"
                    },
                    {
                        "username": "dj_ios1988",
                        "content": "from the description:\nInput: \"(()\"\nOutput: 2\n\nand in the testcase\nInput: “\"()(()\"”\nOutput: 4\nExpected :2\n\nwhy these two have diferent answer of \"(()\" ?\n"
                    },
                    {
                        "username": "shubhankadam",
                        "content": "[@a13375572211](/a13375572211) it expects the longest correct sequence, here it is 2, since the sequence is broken by \\'(\\' in the middle\\n"
                    },
                    {
                        "username": "a13375572211",
                        "content": "Exactly bro, I have the same question"
                    },
                    {
                        "username": "shawngao",
                        "content": "@administrators Is this intended or not?\\n\\nAll Java solution will TLE on this test case:\\n\\n\"((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\""
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Dynamic Programming\n\n  \n**Approach 3:** Using Stack\n\n  \n**Approach 4:** Without extra space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "MohitBansal_",
                        "content": "i done  this question by storing index\\'s of opening bracket in stack\\ncan any body know  other approach? "
                    },
                    {
                        "username": "1337beef",
                        "content": "Is this  (())  counted as valid?"
                    },
                    {
                        "username": "manishsinghrajwar80",
                        "content": "yes"
                    },
                    {
                        "username": "Om_Kumar_Singh",
                        "content": "Keep in mind that string must be valid, for example \"()(()\" answer will be 2. "
                    },
                    {
                        "username": "10gksten",
                        "content": "s = \"()(())\"\\nhow come the expected output is 6?"
                    },
                    {
                        "username": "default-writer",
                        "content": "by definition any sequence not breaking the source rules are valid"
                    },
                    {
                        "username": "10gksten",
                        "content": "[@MrLambda42](/MrLambda42) I will take a look on the pdf and get back on this. Thankyou"
                    },
                    {
                        "username": "MrLambda42",
                        "content": "Looks like it\\'s the longest valid sequence of consecutive properly closed parentheses [len(\"()\") + len(\"(())\")] and not just longest singular sequence of properly closed parentheses like max[len(\"()\"), len(\"(())\")].\\n\\nex: \"()(()\" gives 2 because the second ( is not closed, so the streak is maxed out at 2.\\nOn the other hand, ()(()) has two consecutive sequences that match to 2 + 4 => \"()\" + \"(())\" = 6.\\n\\nThere are some graphs in https://madalgo.au.dk/fileadmin/madalgo/OA_PDF_s/C471.pdf that illustrate how parentheses are balanced and how one may reach the conclusion of the longest consecutive sequence of closed parentheses."
                    }
                ]
            },
            {
                "id": 1568026,
                "content": [
                    {
                        "username": "uuisafresh",
                        "content": "So in this case I use stack and an array, and then change this problem as **finding longest continuous 1 in a 01 array**. Let me tell how to do it.\\n\\nFirst, stack push position of each '(', then when we meet ')' I pop stack to find its match'('\\uff0c place both ')' and '(' as 1 in array\\n\\nFor example, (()()\\uff0carray should look like[0,1,1,1,1]\\n\\nThen it is super easy, to find out longest substring that all items are 1 !!!"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Here\\'s the Python implementation of this solution!\\n\\n```\\ndef longestValidParentheses(s: str) -> int:\\n        # Convert to an array of 1s\\n        stack = []\\n        ans = [0] * len(s)\\n\\n        for i, char in enumerate(s):\\n            if not stack or char == \"(\":\\n                stack.append((char, i))\\n            \\n            elif char == \")\":\\n                if stack[-1][0] == \"(\":\\n                    _, idx = stack.pop()\\n                    ans[i], ans[idx] = 1, 1\\n                else:\\n                    stack.append((\")\", i))\\n\\n        # Now find the longest substring of 1s\\n        ones = 0\\n        ret = 0\\n        for char in ans:\\n            if char == 1:\\n                ones+=1\\n                ret = max(ret, ones)\\n            else:\\n                ones = 0\\n        \\n        return ret\\n```"
                    },
                    {
                        "username": "Simonvu",
                        "content": "brilliant!!"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@PredatorMK2](/PredatorMK2) do you fully understand his approach?"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "this code will fail because of testcase \")(\" as it is not balanced and this approach will return 2 for it\\n"
                    },
                    {
                        "username": "lotus18",
                        "content": "Great Idea!\\n\\nCode For The Above Approach\\n\\nclass Solution \\n{\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        stack<pair<int,int>> st;\\n        int n=s.size();\\n        vector<int> v(n,0);\\n        for(int x=0; x<n; x++)\\n        {\\n            if(s[x]==\\'(\\') st.push({s[x],x});\\n            else\\n            {\\n                if(!st.empty() && st.top().first==\\'(\\')\\n                {\\n                    v[x]=1;\\n                    v[st.top().second]=1;\\n                    st.pop();\\n                }\\n            }\\n        }\\n        int start=-1, end=-1;\\n        int ans=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(v[x]==1)\\n            {\\n                start=x;\\n                int i=x+1;\\n                while(i<n && v[i]) i++;\\n                end=i-1;\\n                x=end;\\n                ans=max(ans,end-start+1);\\n                start=-1,end=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "viocost",
                        "content": "The description only shows example with ()() sequences being correct.\\nHow about this: (()()) or this ((()(())))? Are they correct?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Yep they\\'re correct"
                    },
                    {
                        "username": "Akshay1740",
                        "content": "yes they are also correct."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "This is just a monotonic Stack problem like Next Greater element or Previous Smaller element but the only difference is that we are trying to maintain the order inside the stack instead of a monotonically increasing or decreasing sequence.\\n\\nStack Problems can be broken down into 1 or 2 algorithmic techniques and this is one of them!\\n\\nSimilar Problems :\\nNext Greater Element\\nNext Smaller Element\\nPrevious Greater Element\\nPrevious Smaller Element\\nLargest Rectangle in Histogram\\n\\nCheers && Happy Coding !"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Thanks man. "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "really helpful!!!"
                    },
                    {
                        "username": "av9ash",
                        "content": "()(() how is this the longest valid parentheses? Answer is 4 I think its 2\\nCan someone please explain"
                    },
                    {
                        "username": "abdulwaheed333",
                        "content": "Of course ! you are right but  first we have to find is it valid or not? .So in this there are two valid outputs () and (). length is 4."
                    },
                    {
                        "username": "singhabhinash",
                        "content": "think your logic based on below test case, it will work\ns = \"()((())(()()()\", longestValidParentheses = max(2, 4, 6) = 6"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "I realised that, questions is asking for longest possible substring , not the subsequence.  In case of subsequence ans will be 4, and incase of substring ans will 2"
                    },
                    {
                        "username": "Cozmos77",
                        "content": "[@a13375572211](/a13375572211) exactly ,faced the same issue and i think the answer should be 4 rather than 2.\\n"
                    },
                    {
                        "username": "calm27",
                        "content": "[@a13375572211](/a13375572211) did you try to address this test case? I faced same problem and there are no buttons for report "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@a13375572211](/a13375572211) bro need longest i found invalid then count start from 0"
                    },
                    {
                        "username": "a13375572211",
                        "content": "The answer is 2 but i got 4 and its saying incorrect, but i think its suppose to be 4 because ()(() has 2 valid parentheses"
                    },
                    {
                        "username": "dj_ios1988",
                        "content": "from the description:\nInput: \"(()\"\nOutput: 2\n\nand in the testcase\nInput: “\"()(()\"”\nOutput: 4\nExpected :2\n\nwhy these two have diferent answer of \"(()\" ?\n"
                    },
                    {
                        "username": "shubhankadam",
                        "content": "[@a13375572211](/a13375572211) it expects the longest correct sequence, here it is 2, since the sequence is broken by \\'(\\' in the middle\\n"
                    },
                    {
                        "username": "a13375572211",
                        "content": "Exactly bro, I have the same question"
                    },
                    {
                        "username": "shawngao",
                        "content": "@administrators Is this intended or not?\\n\\nAll Java solution will TLE on this test case:\\n\\n\"((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\""
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Dynamic Programming\n\n  \n**Approach 3:** Using Stack\n\n  \n**Approach 4:** Without extra space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "MohitBansal_",
                        "content": "i done  this question by storing index\\'s of opening bracket in stack\\ncan any body know  other approach? "
                    },
                    {
                        "username": "1337beef",
                        "content": "Is this  (())  counted as valid?"
                    },
                    {
                        "username": "manishsinghrajwar80",
                        "content": "yes"
                    },
                    {
                        "username": "Om_Kumar_Singh",
                        "content": "Keep in mind that string must be valid, for example \"()(()\" answer will be 2. "
                    },
                    {
                        "username": "10gksten",
                        "content": "s = \"()(())\"\\nhow come the expected output is 6?"
                    },
                    {
                        "username": "default-writer",
                        "content": "by definition any sequence not breaking the source rules are valid"
                    },
                    {
                        "username": "10gksten",
                        "content": "[@MrLambda42](/MrLambda42) I will take a look on the pdf and get back on this. Thankyou"
                    },
                    {
                        "username": "MrLambda42",
                        "content": "Looks like it\\'s the longest valid sequence of consecutive properly closed parentheses [len(\"()\") + len(\"(())\")] and not just longest singular sequence of properly closed parentheses like max[len(\"()\"), len(\"(())\")].\\n\\nex: \"()(()\" gives 2 because the second ( is not closed, so the streak is maxed out at 2.\\nOn the other hand, ()(()) has two consecutive sequences that match to 2 + 4 => \"()\" + \"(())\" = 6.\\n\\nThere are some graphs in https://madalgo.au.dk/fileadmin/madalgo/OA_PDF_s/C471.pdf that illustrate how parentheses are balanced and how one may reach the conclusion of the longest consecutive sequence of closed parentheses."
                    }
                ]
            },
            {
                "id": 1572211,
                "content": [
                    {
                        "username": "uuisafresh",
                        "content": "So in this case I use stack and an array, and then change this problem as **finding longest continuous 1 in a 01 array**. Let me tell how to do it.\\n\\nFirst, stack push position of each '(', then when we meet ')' I pop stack to find its match'('\\uff0c place both ')' and '(' as 1 in array\\n\\nFor example, (()()\\uff0carray should look like[0,1,1,1,1]\\n\\nThen it is super easy, to find out longest substring that all items are 1 !!!"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Here\\'s the Python implementation of this solution!\\n\\n```\\ndef longestValidParentheses(s: str) -> int:\\n        # Convert to an array of 1s\\n        stack = []\\n        ans = [0] * len(s)\\n\\n        for i, char in enumerate(s):\\n            if not stack or char == \"(\":\\n                stack.append((char, i))\\n            \\n            elif char == \")\":\\n                if stack[-1][0] == \"(\":\\n                    _, idx = stack.pop()\\n                    ans[i], ans[idx] = 1, 1\\n                else:\\n                    stack.append((\")\", i))\\n\\n        # Now find the longest substring of 1s\\n        ones = 0\\n        ret = 0\\n        for char in ans:\\n            if char == 1:\\n                ones+=1\\n                ret = max(ret, ones)\\n            else:\\n                ones = 0\\n        \\n        return ret\\n```"
                    },
                    {
                        "username": "Simonvu",
                        "content": "brilliant!!"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@PredatorMK2](/PredatorMK2) do you fully understand his approach?"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "this code will fail because of testcase \")(\" as it is not balanced and this approach will return 2 for it\\n"
                    },
                    {
                        "username": "lotus18",
                        "content": "Great Idea!\\n\\nCode For The Above Approach\\n\\nclass Solution \\n{\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        stack<pair<int,int>> st;\\n        int n=s.size();\\n        vector<int> v(n,0);\\n        for(int x=0; x<n; x++)\\n        {\\n            if(s[x]==\\'(\\') st.push({s[x],x});\\n            else\\n            {\\n                if(!st.empty() && st.top().first==\\'(\\')\\n                {\\n                    v[x]=1;\\n                    v[st.top().second]=1;\\n                    st.pop();\\n                }\\n            }\\n        }\\n        int start=-1, end=-1;\\n        int ans=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(v[x]==1)\\n            {\\n                start=x;\\n                int i=x+1;\\n                while(i<n && v[i]) i++;\\n                end=i-1;\\n                x=end;\\n                ans=max(ans,end-start+1);\\n                start=-1,end=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "viocost",
                        "content": "The description only shows example with ()() sequences being correct.\\nHow about this: (()()) or this ((()(())))? Are they correct?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Yep they\\'re correct"
                    },
                    {
                        "username": "Akshay1740",
                        "content": "yes they are also correct."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "This is just a monotonic Stack problem like Next Greater element or Previous Smaller element but the only difference is that we are trying to maintain the order inside the stack instead of a monotonically increasing or decreasing sequence.\\n\\nStack Problems can be broken down into 1 or 2 algorithmic techniques and this is one of them!\\n\\nSimilar Problems :\\nNext Greater Element\\nNext Smaller Element\\nPrevious Greater Element\\nPrevious Smaller Element\\nLargest Rectangle in Histogram\\n\\nCheers && Happy Coding !"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Thanks man. "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "really helpful!!!"
                    },
                    {
                        "username": "av9ash",
                        "content": "()(() how is this the longest valid parentheses? Answer is 4 I think its 2\\nCan someone please explain"
                    },
                    {
                        "username": "abdulwaheed333",
                        "content": "Of course ! you are right but  first we have to find is it valid or not? .So in this there are two valid outputs () and (). length is 4."
                    },
                    {
                        "username": "singhabhinash",
                        "content": "think your logic based on below test case, it will work\ns = \"()((())(()()()\", longestValidParentheses = max(2, 4, 6) = 6"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "I realised that, questions is asking for longest possible substring , not the subsequence.  In case of subsequence ans will be 4, and incase of substring ans will 2"
                    },
                    {
                        "username": "Cozmos77",
                        "content": "[@a13375572211](/a13375572211) exactly ,faced the same issue and i think the answer should be 4 rather than 2.\\n"
                    },
                    {
                        "username": "calm27",
                        "content": "[@a13375572211](/a13375572211) did you try to address this test case? I faced same problem and there are no buttons for report "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@a13375572211](/a13375572211) bro need longest i found invalid then count start from 0"
                    },
                    {
                        "username": "a13375572211",
                        "content": "The answer is 2 but i got 4 and its saying incorrect, but i think its suppose to be 4 because ()(() has 2 valid parentheses"
                    },
                    {
                        "username": "dj_ios1988",
                        "content": "from the description:\nInput: \"(()\"\nOutput: 2\n\nand in the testcase\nInput: “\"()(()\"”\nOutput: 4\nExpected :2\n\nwhy these two have diferent answer of \"(()\" ?\n"
                    },
                    {
                        "username": "shubhankadam",
                        "content": "[@a13375572211](/a13375572211) it expects the longest correct sequence, here it is 2, since the sequence is broken by \\'(\\' in the middle\\n"
                    },
                    {
                        "username": "a13375572211",
                        "content": "Exactly bro, I have the same question"
                    },
                    {
                        "username": "shawngao",
                        "content": "@administrators Is this intended or not?\\n\\nAll Java solution will TLE on this test case:\\n\\n\"((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\""
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Dynamic Programming\n\n  \n**Approach 3:** Using Stack\n\n  \n**Approach 4:** Without extra space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "MohitBansal_",
                        "content": "i done  this question by storing index\\'s of opening bracket in stack\\ncan any body know  other approach? "
                    },
                    {
                        "username": "1337beef",
                        "content": "Is this  (())  counted as valid?"
                    },
                    {
                        "username": "manishsinghrajwar80",
                        "content": "yes"
                    },
                    {
                        "username": "Om_Kumar_Singh",
                        "content": "Keep in mind that string must be valid, for example \"()(()\" answer will be 2. "
                    },
                    {
                        "username": "10gksten",
                        "content": "s = \"()(())\"\\nhow come the expected output is 6?"
                    },
                    {
                        "username": "default-writer",
                        "content": "by definition any sequence not breaking the source rules are valid"
                    },
                    {
                        "username": "10gksten",
                        "content": "[@MrLambda42](/MrLambda42) I will take a look on the pdf and get back on this. Thankyou"
                    },
                    {
                        "username": "MrLambda42",
                        "content": "Looks like it\\'s the longest valid sequence of consecutive properly closed parentheses [len(\"()\") + len(\"(())\")] and not just longest singular sequence of properly closed parentheses like max[len(\"()\"), len(\"(())\")].\\n\\nex: \"()(()\" gives 2 because the second ( is not closed, so the streak is maxed out at 2.\\nOn the other hand, ()(()) has two consecutive sequences that match to 2 + 4 => \"()\" + \"(())\" = 6.\\n\\nThere are some graphs in https://madalgo.au.dk/fileadmin/madalgo/OA_PDF_s/C471.pdf that illustrate how parentheses are balanced and how one may reach the conclusion of the longest consecutive sequence of closed parentheses."
                    }
                ]
            },
            {
                "id": 1568853,
                "content": [
                    {
                        "username": "uuisafresh",
                        "content": "So in this case I use stack and an array, and then change this problem as **finding longest continuous 1 in a 01 array**. Let me tell how to do it.\\n\\nFirst, stack push position of each '(', then when we meet ')' I pop stack to find its match'('\\uff0c place both ')' and '(' as 1 in array\\n\\nFor example, (()()\\uff0carray should look like[0,1,1,1,1]\\n\\nThen it is super easy, to find out longest substring that all items are 1 !!!"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Here\\'s the Python implementation of this solution!\\n\\n```\\ndef longestValidParentheses(s: str) -> int:\\n        # Convert to an array of 1s\\n        stack = []\\n        ans = [0] * len(s)\\n\\n        for i, char in enumerate(s):\\n            if not stack or char == \"(\":\\n                stack.append((char, i))\\n            \\n            elif char == \")\":\\n                if stack[-1][0] == \"(\":\\n                    _, idx = stack.pop()\\n                    ans[i], ans[idx] = 1, 1\\n                else:\\n                    stack.append((\")\", i))\\n\\n        # Now find the longest substring of 1s\\n        ones = 0\\n        ret = 0\\n        for char in ans:\\n            if char == 1:\\n                ones+=1\\n                ret = max(ret, ones)\\n            else:\\n                ones = 0\\n        \\n        return ret\\n```"
                    },
                    {
                        "username": "Simonvu",
                        "content": "brilliant!!"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@PredatorMK2](/PredatorMK2) do you fully understand his approach?"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "this code will fail because of testcase \")(\" as it is not balanced and this approach will return 2 for it\\n"
                    },
                    {
                        "username": "lotus18",
                        "content": "Great Idea!\\n\\nCode For The Above Approach\\n\\nclass Solution \\n{\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        stack<pair<int,int>> st;\\n        int n=s.size();\\n        vector<int> v(n,0);\\n        for(int x=0; x<n; x++)\\n        {\\n            if(s[x]==\\'(\\') st.push({s[x],x});\\n            else\\n            {\\n                if(!st.empty() && st.top().first==\\'(\\')\\n                {\\n                    v[x]=1;\\n                    v[st.top().second]=1;\\n                    st.pop();\\n                }\\n            }\\n        }\\n        int start=-1, end=-1;\\n        int ans=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(v[x]==1)\\n            {\\n                start=x;\\n                int i=x+1;\\n                while(i<n && v[i]) i++;\\n                end=i-1;\\n                x=end;\\n                ans=max(ans,end-start+1);\\n                start=-1,end=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "viocost",
                        "content": "The description only shows example with ()() sequences being correct.\\nHow about this: (()()) or this ((()(())))? Are they correct?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Yep they\\'re correct"
                    },
                    {
                        "username": "Akshay1740",
                        "content": "yes they are also correct."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "This is just a monotonic Stack problem like Next Greater element or Previous Smaller element but the only difference is that we are trying to maintain the order inside the stack instead of a monotonically increasing or decreasing sequence.\\n\\nStack Problems can be broken down into 1 or 2 algorithmic techniques and this is one of them!\\n\\nSimilar Problems :\\nNext Greater Element\\nNext Smaller Element\\nPrevious Greater Element\\nPrevious Smaller Element\\nLargest Rectangle in Histogram\\n\\nCheers && Happy Coding !"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Thanks man. "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "really helpful!!!"
                    },
                    {
                        "username": "av9ash",
                        "content": "()(() how is this the longest valid parentheses? Answer is 4 I think its 2\\nCan someone please explain"
                    },
                    {
                        "username": "abdulwaheed333",
                        "content": "Of course ! you are right but  first we have to find is it valid or not? .So in this there are two valid outputs () and (). length is 4."
                    },
                    {
                        "username": "singhabhinash",
                        "content": "think your logic based on below test case, it will work\ns = \"()((())(()()()\", longestValidParentheses = max(2, 4, 6) = 6"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "I realised that, questions is asking for longest possible substring , not the subsequence.  In case of subsequence ans will be 4, and incase of substring ans will 2"
                    },
                    {
                        "username": "Cozmos77",
                        "content": "[@a13375572211](/a13375572211) exactly ,faced the same issue and i think the answer should be 4 rather than 2.\\n"
                    },
                    {
                        "username": "calm27",
                        "content": "[@a13375572211](/a13375572211) did you try to address this test case? I faced same problem and there are no buttons for report "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@a13375572211](/a13375572211) bro need longest i found invalid then count start from 0"
                    },
                    {
                        "username": "a13375572211",
                        "content": "The answer is 2 but i got 4 and its saying incorrect, but i think its suppose to be 4 because ()(() has 2 valid parentheses"
                    },
                    {
                        "username": "dj_ios1988",
                        "content": "from the description:\nInput: \"(()\"\nOutput: 2\n\nand in the testcase\nInput: “\"()(()\"”\nOutput: 4\nExpected :2\n\nwhy these two have diferent answer of \"(()\" ?\n"
                    },
                    {
                        "username": "shubhankadam",
                        "content": "[@a13375572211](/a13375572211) it expects the longest correct sequence, here it is 2, since the sequence is broken by \\'(\\' in the middle\\n"
                    },
                    {
                        "username": "a13375572211",
                        "content": "Exactly bro, I have the same question"
                    },
                    {
                        "username": "shawngao",
                        "content": "@administrators Is this intended or not?\\n\\nAll Java solution will TLE on this test case:\\n\\n\"((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\""
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Dynamic Programming\n\n  \n**Approach 3:** Using Stack\n\n  \n**Approach 4:** Without extra space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "MohitBansal_",
                        "content": "i done  this question by storing index\\'s of opening bracket in stack\\ncan any body know  other approach? "
                    },
                    {
                        "username": "1337beef",
                        "content": "Is this  (())  counted as valid?"
                    },
                    {
                        "username": "manishsinghrajwar80",
                        "content": "yes"
                    },
                    {
                        "username": "Om_Kumar_Singh",
                        "content": "Keep in mind that string must be valid, for example \"()(()\" answer will be 2. "
                    },
                    {
                        "username": "10gksten",
                        "content": "s = \"()(())\"\\nhow come the expected output is 6?"
                    },
                    {
                        "username": "default-writer",
                        "content": "by definition any sequence not breaking the source rules are valid"
                    },
                    {
                        "username": "10gksten",
                        "content": "[@MrLambda42](/MrLambda42) I will take a look on the pdf and get back on this. Thankyou"
                    },
                    {
                        "username": "MrLambda42",
                        "content": "Looks like it\\'s the longest valid sequence of consecutive properly closed parentheses [len(\"()\") + len(\"(())\")] and not just longest singular sequence of properly closed parentheses like max[len(\"()\"), len(\"(())\")].\\n\\nex: \"()(()\" gives 2 because the second ( is not closed, so the streak is maxed out at 2.\\nOn the other hand, ()(()) has two consecutive sequences that match to 2 + 4 => \"()\" + \"(())\" = 6.\\n\\nThere are some graphs in https://madalgo.au.dk/fileadmin/madalgo/OA_PDF_s/C471.pdf that illustrate how parentheses are balanced and how one may reach the conclusion of the longest consecutive sequence of closed parentheses."
                    }
                ]
            },
            {
                "id": 1566722,
                "content": [
                    {
                        "username": "uuisafresh",
                        "content": "So in this case I use stack and an array, and then change this problem as **finding longest continuous 1 in a 01 array**. Let me tell how to do it.\\n\\nFirst, stack push position of each '(', then when we meet ')' I pop stack to find its match'('\\uff0c place both ')' and '(' as 1 in array\\n\\nFor example, (()()\\uff0carray should look like[0,1,1,1,1]\\n\\nThen it is super easy, to find out longest substring that all items are 1 !!!"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Here\\'s the Python implementation of this solution!\\n\\n```\\ndef longestValidParentheses(s: str) -> int:\\n        # Convert to an array of 1s\\n        stack = []\\n        ans = [0] * len(s)\\n\\n        for i, char in enumerate(s):\\n            if not stack or char == \"(\":\\n                stack.append((char, i))\\n            \\n            elif char == \")\":\\n                if stack[-1][0] == \"(\":\\n                    _, idx = stack.pop()\\n                    ans[i], ans[idx] = 1, 1\\n                else:\\n                    stack.append((\")\", i))\\n\\n        # Now find the longest substring of 1s\\n        ones = 0\\n        ret = 0\\n        for char in ans:\\n            if char == 1:\\n                ones+=1\\n                ret = max(ret, ones)\\n            else:\\n                ones = 0\\n        \\n        return ret\\n```"
                    },
                    {
                        "username": "Simonvu",
                        "content": "brilliant!!"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@PredatorMK2](/PredatorMK2) do you fully understand his approach?"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "this code will fail because of testcase \")(\" as it is not balanced and this approach will return 2 for it\\n"
                    },
                    {
                        "username": "lotus18",
                        "content": "Great Idea!\\n\\nCode For The Above Approach\\n\\nclass Solution \\n{\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        stack<pair<int,int>> st;\\n        int n=s.size();\\n        vector<int> v(n,0);\\n        for(int x=0; x<n; x++)\\n        {\\n            if(s[x]==\\'(\\') st.push({s[x],x});\\n            else\\n            {\\n                if(!st.empty() && st.top().first==\\'(\\')\\n                {\\n                    v[x]=1;\\n                    v[st.top().second]=1;\\n                    st.pop();\\n                }\\n            }\\n        }\\n        int start=-1, end=-1;\\n        int ans=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(v[x]==1)\\n            {\\n                start=x;\\n                int i=x+1;\\n                while(i<n && v[i]) i++;\\n                end=i-1;\\n                x=end;\\n                ans=max(ans,end-start+1);\\n                start=-1,end=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "viocost",
                        "content": "The description only shows example with ()() sequences being correct.\\nHow about this: (()()) or this ((()(())))? Are they correct?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Yep they\\'re correct"
                    },
                    {
                        "username": "Akshay1740",
                        "content": "yes they are also correct."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "This is just a monotonic Stack problem like Next Greater element or Previous Smaller element but the only difference is that we are trying to maintain the order inside the stack instead of a monotonically increasing or decreasing sequence.\\n\\nStack Problems can be broken down into 1 or 2 algorithmic techniques and this is one of them!\\n\\nSimilar Problems :\\nNext Greater Element\\nNext Smaller Element\\nPrevious Greater Element\\nPrevious Smaller Element\\nLargest Rectangle in Histogram\\n\\nCheers && Happy Coding !"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Thanks man. "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "really helpful!!!"
                    },
                    {
                        "username": "av9ash",
                        "content": "()(() how is this the longest valid parentheses? Answer is 4 I think its 2\\nCan someone please explain"
                    },
                    {
                        "username": "abdulwaheed333",
                        "content": "Of course ! you are right but  first we have to find is it valid or not? .So in this there are two valid outputs () and (). length is 4."
                    },
                    {
                        "username": "singhabhinash",
                        "content": "think your logic based on below test case, it will work\ns = \"()((())(()()()\", longestValidParentheses = max(2, 4, 6) = 6"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "I realised that, questions is asking for longest possible substring , not the subsequence.  In case of subsequence ans will be 4, and incase of substring ans will 2"
                    },
                    {
                        "username": "Cozmos77",
                        "content": "[@a13375572211](/a13375572211) exactly ,faced the same issue and i think the answer should be 4 rather than 2.\\n"
                    },
                    {
                        "username": "calm27",
                        "content": "[@a13375572211](/a13375572211) did you try to address this test case? I faced same problem and there are no buttons for report "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@a13375572211](/a13375572211) bro need longest i found invalid then count start from 0"
                    },
                    {
                        "username": "a13375572211",
                        "content": "The answer is 2 but i got 4 and its saying incorrect, but i think its suppose to be 4 because ()(() has 2 valid parentheses"
                    },
                    {
                        "username": "dj_ios1988",
                        "content": "from the description:\nInput: \"(()\"\nOutput: 2\n\nand in the testcase\nInput: “\"()(()\"”\nOutput: 4\nExpected :2\n\nwhy these two have diferent answer of \"(()\" ?\n"
                    },
                    {
                        "username": "shubhankadam",
                        "content": "[@a13375572211](/a13375572211) it expects the longest correct sequence, here it is 2, since the sequence is broken by \\'(\\' in the middle\\n"
                    },
                    {
                        "username": "a13375572211",
                        "content": "Exactly bro, I have the same question"
                    },
                    {
                        "username": "shawngao",
                        "content": "@administrators Is this intended or not?\\n\\nAll Java solution will TLE on this test case:\\n\\n\"((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\""
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Dynamic Programming\n\n  \n**Approach 3:** Using Stack\n\n  \n**Approach 4:** Without extra space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "MohitBansal_",
                        "content": "i done  this question by storing index\\'s of opening bracket in stack\\ncan any body know  other approach? "
                    },
                    {
                        "username": "1337beef",
                        "content": "Is this  (())  counted as valid?"
                    },
                    {
                        "username": "manishsinghrajwar80",
                        "content": "yes"
                    },
                    {
                        "username": "Om_Kumar_Singh",
                        "content": "Keep in mind that string must be valid, for example \"()(()\" answer will be 2. "
                    },
                    {
                        "username": "10gksten",
                        "content": "s = \"()(())\"\\nhow come the expected output is 6?"
                    },
                    {
                        "username": "default-writer",
                        "content": "by definition any sequence not breaking the source rules are valid"
                    },
                    {
                        "username": "10gksten",
                        "content": "[@MrLambda42](/MrLambda42) I will take a look on the pdf and get back on this. Thankyou"
                    },
                    {
                        "username": "MrLambda42",
                        "content": "Looks like it\\'s the longest valid sequence of consecutive properly closed parentheses [len(\"()\") + len(\"(())\")] and not just longest singular sequence of properly closed parentheses like max[len(\"()\"), len(\"(())\")].\\n\\nex: \"()(()\" gives 2 because the second ( is not closed, so the streak is maxed out at 2.\\nOn the other hand, ()(()) has two consecutive sequences that match to 2 + 4 => \"()\" + \"(())\" = 6.\\n\\nThere are some graphs in https://madalgo.au.dk/fileadmin/madalgo/OA_PDF_s/C471.pdf that illustrate how parentheses are balanced and how one may reach the conclusion of the longest consecutive sequence of closed parentheses."
                    }
                ]
            },
            {
                "id": 1571085,
                "content": [
                    {
                        "username": "uuisafresh",
                        "content": "So in this case I use stack and an array, and then change this problem as **finding longest continuous 1 in a 01 array**. Let me tell how to do it.\\n\\nFirst, stack push position of each '(', then when we meet ')' I pop stack to find its match'('\\uff0c place both ')' and '(' as 1 in array\\n\\nFor example, (()()\\uff0carray should look like[0,1,1,1,1]\\n\\nThen it is super easy, to find out longest substring that all items are 1 !!!"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Here\\'s the Python implementation of this solution!\\n\\n```\\ndef longestValidParentheses(s: str) -> int:\\n        # Convert to an array of 1s\\n        stack = []\\n        ans = [0] * len(s)\\n\\n        for i, char in enumerate(s):\\n            if not stack or char == \"(\":\\n                stack.append((char, i))\\n            \\n            elif char == \")\":\\n                if stack[-1][0] == \"(\":\\n                    _, idx = stack.pop()\\n                    ans[i], ans[idx] = 1, 1\\n                else:\\n                    stack.append((\")\", i))\\n\\n        # Now find the longest substring of 1s\\n        ones = 0\\n        ret = 0\\n        for char in ans:\\n            if char == 1:\\n                ones+=1\\n                ret = max(ret, ones)\\n            else:\\n                ones = 0\\n        \\n        return ret\\n```"
                    },
                    {
                        "username": "Simonvu",
                        "content": "brilliant!!"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@PredatorMK2](/PredatorMK2) do you fully understand his approach?"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "this code will fail because of testcase \")(\" as it is not balanced and this approach will return 2 for it\\n"
                    },
                    {
                        "username": "lotus18",
                        "content": "Great Idea!\\n\\nCode For The Above Approach\\n\\nclass Solution \\n{\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        stack<pair<int,int>> st;\\n        int n=s.size();\\n        vector<int> v(n,0);\\n        for(int x=0; x<n; x++)\\n        {\\n            if(s[x]==\\'(\\') st.push({s[x],x});\\n            else\\n            {\\n                if(!st.empty() && st.top().first==\\'(\\')\\n                {\\n                    v[x]=1;\\n                    v[st.top().second]=1;\\n                    st.pop();\\n                }\\n            }\\n        }\\n        int start=-1, end=-1;\\n        int ans=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(v[x]==1)\\n            {\\n                start=x;\\n                int i=x+1;\\n                while(i<n && v[i]) i++;\\n                end=i-1;\\n                x=end;\\n                ans=max(ans,end-start+1);\\n                start=-1,end=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "viocost",
                        "content": "The description only shows example with ()() sequences being correct.\\nHow about this: (()()) or this ((()(())))? Are they correct?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Yep they\\'re correct"
                    },
                    {
                        "username": "Akshay1740",
                        "content": "yes they are also correct."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "This is just a monotonic Stack problem like Next Greater element or Previous Smaller element but the only difference is that we are trying to maintain the order inside the stack instead of a monotonically increasing or decreasing sequence.\\n\\nStack Problems can be broken down into 1 or 2 algorithmic techniques and this is one of them!\\n\\nSimilar Problems :\\nNext Greater Element\\nNext Smaller Element\\nPrevious Greater Element\\nPrevious Smaller Element\\nLargest Rectangle in Histogram\\n\\nCheers && Happy Coding !"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Thanks man. "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "really helpful!!!"
                    },
                    {
                        "username": "av9ash",
                        "content": "()(() how is this the longest valid parentheses? Answer is 4 I think its 2\\nCan someone please explain"
                    },
                    {
                        "username": "abdulwaheed333",
                        "content": "Of course ! you are right but  first we have to find is it valid or not? .So in this there are two valid outputs () and (). length is 4."
                    },
                    {
                        "username": "singhabhinash",
                        "content": "think your logic based on below test case, it will work\ns = \"()((())(()()()\", longestValidParentheses = max(2, 4, 6) = 6"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "I realised that, questions is asking for longest possible substring , not the subsequence.  In case of subsequence ans will be 4, and incase of substring ans will 2"
                    },
                    {
                        "username": "Cozmos77",
                        "content": "[@a13375572211](/a13375572211) exactly ,faced the same issue and i think the answer should be 4 rather than 2.\\n"
                    },
                    {
                        "username": "calm27",
                        "content": "[@a13375572211](/a13375572211) did you try to address this test case? I faced same problem and there are no buttons for report "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@a13375572211](/a13375572211) bro need longest i found invalid then count start from 0"
                    },
                    {
                        "username": "a13375572211",
                        "content": "The answer is 2 but i got 4 and its saying incorrect, but i think its suppose to be 4 because ()(() has 2 valid parentheses"
                    },
                    {
                        "username": "dj_ios1988",
                        "content": "from the description:\nInput: \"(()\"\nOutput: 2\n\nand in the testcase\nInput: “\"()(()\"”\nOutput: 4\nExpected :2\n\nwhy these two have diferent answer of \"(()\" ?\n"
                    },
                    {
                        "username": "shubhankadam",
                        "content": "[@a13375572211](/a13375572211) it expects the longest correct sequence, here it is 2, since the sequence is broken by \\'(\\' in the middle\\n"
                    },
                    {
                        "username": "a13375572211",
                        "content": "Exactly bro, I have the same question"
                    },
                    {
                        "username": "shawngao",
                        "content": "@administrators Is this intended or not?\\n\\nAll Java solution will TLE on this test case:\\n\\n\"((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\""
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Dynamic Programming\n\n  \n**Approach 3:** Using Stack\n\n  \n**Approach 4:** Without extra space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "MohitBansal_",
                        "content": "i done  this question by storing index\\'s of opening bracket in stack\\ncan any body know  other approach? "
                    },
                    {
                        "username": "1337beef",
                        "content": "Is this  (())  counted as valid?"
                    },
                    {
                        "username": "manishsinghrajwar80",
                        "content": "yes"
                    },
                    {
                        "username": "Om_Kumar_Singh",
                        "content": "Keep in mind that string must be valid, for example \"()(()\" answer will be 2. "
                    },
                    {
                        "username": "10gksten",
                        "content": "s = \"()(())\"\\nhow come the expected output is 6?"
                    },
                    {
                        "username": "default-writer",
                        "content": "by definition any sequence not breaking the source rules are valid"
                    },
                    {
                        "username": "10gksten",
                        "content": "[@MrLambda42](/MrLambda42) I will take a look on the pdf and get back on this. Thankyou"
                    },
                    {
                        "username": "MrLambda42",
                        "content": "Looks like it\\'s the longest valid sequence of consecutive properly closed parentheses [len(\"()\") + len(\"(())\")] and not just longest singular sequence of properly closed parentheses like max[len(\"()\"), len(\"(())\")].\\n\\nex: \"()(()\" gives 2 because the second ( is not closed, so the streak is maxed out at 2.\\nOn the other hand, ()(()) has two consecutive sequences that match to 2 + 4 => \"()\" + \"(())\" = 6.\\n\\nThere are some graphs in https://madalgo.au.dk/fileadmin/madalgo/OA_PDF_s/C471.pdf that illustrate how parentheses are balanced and how one may reach the conclusion of the longest consecutive sequence of closed parentheses."
                    }
                ]
            },
            {
                "id": 2042924,
                "content": [
                    {
                        "username": "uuisafresh",
                        "content": "So in this case I use stack and an array, and then change this problem as **finding longest continuous 1 in a 01 array**. Let me tell how to do it.\\n\\nFirst, stack push position of each '(', then when we meet ')' I pop stack to find its match'('\\uff0c place both ')' and '(' as 1 in array\\n\\nFor example, (()()\\uff0carray should look like[0,1,1,1,1]\\n\\nThen it is super easy, to find out longest substring that all items are 1 !!!"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Here\\'s the Python implementation of this solution!\\n\\n```\\ndef longestValidParentheses(s: str) -> int:\\n        # Convert to an array of 1s\\n        stack = []\\n        ans = [0] * len(s)\\n\\n        for i, char in enumerate(s):\\n            if not stack or char == \"(\":\\n                stack.append((char, i))\\n            \\n            elif char == \")\":\\n                if stack[-1][0] == \"(\":\\n                    _, idx = stack.pop()\\n                    ans[i], ans[idx] = 1, 1\\n                else:\\n                    stack.append((\")\", i))\\n\\n        # Now find the longest substring of 1s\\n        ones = 0\\n        ret = 0\\n        for char in ans:\\n            if char == 1:\\n                ones+=1\\n                ret = max(ret, ones)\\n            else:\\n                ones = 0\\n        \\n        return ret\\n```"
                    },
                    {
                        "username": "Simonvu",
                        "content": "brilliant!!"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@PredatorMK2](/PredatorMK2) do you fully understand his approach?"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "this code will fail because of testcase \")(\" as it is not balanced and this approach will return 2 for it\\n"
                    },
                    {
                        "username": "lotus18",
                        "content": "Great Idea!\\n\\nCode For The Above Approach\\n\\nclass Solution \\n{\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        stack<pair<int,int>> st;\\n        int n=s.size();\\n        vector<int> v(n,0);\\n        for(int x=0; x<n; x++)\\n        {\\n            if(s[x]==\\'(\\') st.push({s[x],x});\\n            else\\n            {\\n                if(!st.empty() && st.top().first==\\'(\\')\\n                {\\n                    v[x]=1;\\n                    v[st.top().second]=1;\\n                    st.pop();\\n                }\\n            }\\n        }\\n        int start=-1, end=-1;\\n        int ans=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(v[x]==1)\\n            {\\n                start=x;\\n                int i=x+1;\\n                while(i<n && v[i]) i++;\\n                end=i-1;\\n                x=end;\\n                ans=max(ans,end-start+1);\\n                start=-1,end=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "viocost",
                        "content": "The description only shows example with ()() sequences being correct.\\nHow about this: (()()) or this ((()(())))? Are they correct?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Yep they\\'re correct"
                    },
                    {
                        "username": "Akshay1740",
                        "content": "yes they are also correct."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "This is just a monotonic Stack problem like Next Greater element or Previous Smaller element but the only difference is that we are trying to maintain the order inside the stack instead of a monotonically increasing or decreasing sequence.\\n\\nStack Problems can be broken down into 1 or 2 algorithmic techniques and this is one of them!\\n\\nSimilar Problems :\\nNext Greater Element\\nNext Smaller Element\\nPrevious Greater Element\\nPrevious Smaller Element\\nLargest Rectangle in Histogram\\n\\nCheers && Happy Coding !"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Thanks man. "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "really helpful!!!"
                    },
                    {
                        "username": "av9ash",
                        "content": "()(() how is this the longest valid parentheses? Answer is 4 I think its 2\\nCan someone please explain"
                    },
                    {
                        "username": "abdulwaheed333",
                        "content": "Of course ! you are right but  first we have to find is it valid or not? .So in this there are two valid outputs () and (). length is 4."
                    },
                    {
                        "username": "singhabhinash",
                        "content": "think your logic based on below test case, it will work\ns = \"()((())(()()()\", longestValidParentheses = max(2, 4, 6) = 6"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "I realised that, questions is asking for longest possible substring , not the subsequence.  In case of subsequence ans will be 4, and incase of substring ans will 2"
                    },
                    {
                        "username": "Cozmos77",
                        "content": "[@a13375572211](/a13375572211) exactly ,faced the same issue and i think the answer should be 4 rather than 2.\\n"
                    },
                    {
                        "username": "calm27",
                        "content": "[@a13375572211](/a13375572211) did you try to address this test case? I faced same problem and there are no buttons for report "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@a13375572211](/a13375572211) bro need longest i found invalid then count start from 0"
                    },
                    {
                        "username": "a13375572211",
                        "content": "The answer is 2 but i got 4 and its saying incorrect, but i think its suppose to be 4 because ()(() has 2 valid parentheses"
                    },
                    {
                        "username": "dj_ios1988",
                        "content": "from the description:\nInput: \"(()\"\nOutput: 2\n\nand in the testcase\nInput: “\"()(()\"”\nOutput: 4\nExpected :2\n\nwhy these two have diferent answer of \"(()\" ?\n"
                    },
                    {
                        "username": "shubhankadam",
                        "content": "[@a13375572211](/a13375572211) it expects the longest correct sequence, here it is 2, since the sequence is broken by \\'(\\' in the middle\\n"
                    },
                    {
                        "username": "a13375572211",
                        "content": "Exactly bro, I have the same question"
                    },
                    {
                        "username": "shawngao",
                        "content": "@administrators Is this intended or not?\\n\\nAll Java solution will TLE on this test case:\\n\\n\"((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\""
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Dynamic Programming\n\n  \n**Approach 3:** Using Stack\n\n  \n**Approach 4:** Without extra space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "MohitBansal_",
                        "content": "i done  this question by storing index\\'s of opening bracket in stack\\ncan any body know  other approach? "
                    },
                    {
                        "username": "1337beef",
                        "content": "Is this  (())  counted as valid?"
                    },
                    {
                        "username": "manishsinghrajwar80",
                        "content": "yes"
                    },
                    {
                        "username": "Om_Kumar_Singh",
                        "content": "Keep in mind that string must be valid, for example \"()(()\" answer will be 2. "
                    },
                    {
                        "username": "10gksten",
                        "content": "s = \"()(())\"\\nhow come the expected output is 6?"
                    },
                    {
                        "username": "default-writer",
                        "content": "by definition any sequence not breaking the source rules are valid"
                    },
                    {
                        "username": "10gksten",
                        "content": "[@MrLambda42](/MrLambda42) I will take a look on the pdf and get back on this. Thankyou"
                    },
                    {
                        "username": "MrLambda42",
                        "content": "Looks like it\\'s the longest valid sequence of consecutive properly closed parentheses [len(\"()\") + len(\"(())\")] and not just longest singular sequence of properly closed parentheses like max[len(\"()\"), len(\"(())\")].\\n\\nex: \"()(()\" gives 2 because the second ( is not closed, so the streak is maxed out at 2.\\nOn the other hand, ()(()) has two consecutive sequences that match to 2 + 4 => \"()\" + \"(())\" = 6.\\n\\nThere are some graphs in https://madalgo.au.dk/fileadmin/madalgo/OA_PDF_s/C471.pdf that illustrate how parentheses are balanced and how one may reach the conclusion of the longest consecutive sequence of closed parentheses."
                    }
                ]
            },
            {
                "id": 1704382,
                "content": [
                    {
                        "username": "uuisafresh",
                        "content": "So in this case I use stack and an array, and then change this problem as **finding longest continuous 1 in a 01 array**. Let me tell how to do it.\\n\\nFirst, stack push position of each '(', then when we meet ')' I pop stack to find its match'('\\uff0c place both ')' and '(' as 1 in array\\n\\nFor example, (()()\\uff0carray should look like[0,1,1,1,1]\\n\\nThen it is super easy, to find out longest substring that all items are 1 !!!"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Here\\'s the Python implementation of this solution!\\n\\n```\\ndef longestValidParentheses(s: str) -> int:\\n        # Convert to an array of 1s\\n        stack = []\\n        ans = [0] * len(s)\\n\\n        for i, char in enumerate(s):\\n            if not stack or char == \"(\":\\n                stack.append((char, i))\\n            \\n            elif char == \")\":\\n                if stack[-1][0] == \"(\":\\n                    _, idx = stack.pop()\\n                    ans[i], ans[idx] = 1, 1\\n                else:\\n                    stack.append((\")\", i))\\n\\n        # Now find the longest substring of 1s\\n        ones = 0\\n        ret = 0\\n        for char in ans:\\n            if char == 1:\\n                ones+=1\\n                ret = max(ret, ones)\\n            else:\\n                ones = 0\\n        \\n        return ret\\n```"
                    },
                    {
                        "username": "Simonvu",
                        "content": "brilliant!!"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@PredatorMK2](/PredatorMK2) do you fully understand his approach?"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "this code will fail because of testcase \")(\" as it is not balanced and this approach will return 2 for it\\n"
                    },
                    {
                        "username": "lotus18",
                        "content": "Great Idea!\\n\\nCode For The Above Approach\\n\\nclass Solution \\n{\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        stack<pair<int,int>> st;\\n        int n=s.size();\\n        vector<int> v(n,0);\\n        for(int x=0; x<n; x++)\\n        {\\n            if(s[x]==\\'(\\') st.push({s[x],x});\\n            else\\n            {\\n                if(!st.empty() && st.top().first==\\'(\\')\\n                {\\n                    v[x]=1;\\n                    v[st.top().second]=1;\\n                    st.pop();\\n                }\\n            }\\n        }\\n        int start=-1, end=-1;\\n        int ans=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(v[x]==1)\\n            {\\n                start=x;\\n                int i=x+1;\\n                while(i<n && v[i]) i++;\\n                end=i-1;\\n                x=end;\\n                ans=max(ans,end-start+1);\\n                start=-1,end=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "viocost",
                        "content": "The description only shows example with ()() sequences being correct.\\nHow about this: (()()) or this ((()(())))? Are they correct?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Yep they\\'re correct"
                    },
                    {
                        "username": "Akshay1740",
                        "content": "yes they are also correct."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "This is just a monotonic Stack problem like Next Greater element or Previous Smaller element but the only difference is that we are trying to maintain the order inside the stack instead of a monotonically increasing or decreasing sequence.\\n\\nStack Problems can be broken down into 1 or 2 algorithmic techniques and this is one of them!\\n\\nSimilar Problems :\\nNext Greater Element\\nNext Smaller Element\\nPrevious Greater Element\\nPrevious Smaller Element\\nLargest Rectangle in Histogram\\n\\nCheers && Happy Coding !"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Thanks man. "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "really helpful!!!"
                    },
                    {
                        "username": "av9ash",
                        "content": "()(() how is this the longest valid parentheses? Answer is 4 I think its 2\\nCan someone please explain"
                    },
                    {
                        "username": "abdulwaheed333",
                        "content": "Of course ! you are right but  first we have to find is it valid or not? .So in this there are two valid outputs () and (). length is 4."
                    },
                    {
                        "username": "singhabhinash",
                        "content": "think your logic based on below test case, it will work\ns = \"()((())(()()()\", longestValidParentheses = max(2, 4, 6) = 6"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "I realised that, questions is asking for longest possible substring , not the subsequence.  In case of subsequence ans will be 4, and incase of substring ans will 2"
                    },
                    {
                        "username": "Cozmos77",
                        "content": "[@a13375572211](/a13375572211) exactly ,faced the same issue and i think the answer should be 4 rather than 2.\\n"
                    },
                    {
                        "username": "calm27",
                        "content": "[@a13375572211](/a13375572211) did you try to address this test case? I faced same problem and there are no buttons for report "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@a13375572211](/a13375572211) bro need longest i found invalid then count start from 0"
                    },
                    {
                        "username": "a13375572211",
                        "content": "The answer is 2 but i got 4 and its saying incorrect, but i think its suppose to be 4 because ()(() has 2 valid parentheses"
                    },
                    {
                        "username": "dj_ios1988",
                        "content": "from the description:\nInput: \"(()\"\nOutput: 2\n\nand in the testcase\nInput: “\"()(()\"”\nOutput: 4\nExpected :2\n\nwhy these two have diferent answer of \"(()\" ?\n"
                    },
                    {
                        "username": "shubhankadam",
                        "content": "[@a13375572211](/a13375572211) it expects the longest correct sequence, here it is 2, since the sequence is broken by \\'(\\' in the middle\\n"
                    },
                    {
                        "username": "a13375572211",
                        "content": "Exactly bro, I have the same question"
                    },
                    {
                        "username": "shawngao",
                        "content": "@administrators Is this intended or not?\\n\\nAll Java solution will TLE on this test case:\\n\\n\"((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\""
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Dynamic Programming\n\n  \n**Approach 3:** Using Stack\n\n  \n**Approach 4:** Without extra space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "MohitBansal_",
                        "content": "i done  this question by storing index\\'s of opening bracket in stack\\ncan any body know  other approach? "
                    },
                    {
                        "username": "1337beef",
                        "content": "Is this  (())  counted as valid?"
                    },
                    {
                        "username": "manishsinghrajwar80",
                        "content": "yes"
                    },
                    {
                        "username": "Om_Kumar_Singh",
                        "content": "Keep in mind that string must be valid, for example \"()(()\" answer will be 2. "
                    },
                    {
                        "username": "10gksten",
                        "content": "s = \"()(())\"\\nhow come the expected output is 6?"
                    },
                    {
                        "username": "default-writer",
                        "content": "by definition any sequence not breaking the source rules are valid"
                    },
                    {
                        "username": "10gksten",
                        "content": "[@MrLambda42](/MrLambda42) I will take a look on the pdf and get back on this. Thankyou"
                    },
                    {
                        "username": "MrLambda42",
                        "content": "Looks like it\\'s the longest valid sequence of consecutive properly closed parentheses [len(\"()\") + len(\"(())\")] and not just longest singular sequence of properly closed parentheses like max[len(\"()\"), len(\"(())\")].\\n\\nex: \"()(()\" gives 2 because the second ( is not closed, so the streak is maxed out at 2.\\nOn the other hand, ()(()) has two consecutive sequences that match to 2 + 4 => \"()\" + \"(())\" = 6.\\n\\nThere are some graphs in https://madalgo.au.dk/fileadmin/madalgo/OA_PDF_s/C471.pdf that illustrate how parentheses are balanced and how one may reach the conclusion of the longest consecutive sequence of closed parentheses."
                    }
                ]
            },
            {
                "id": 1576835,
                "content": [
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-valid-parentheses-leetcode-python/"
                    },
                    {
                        "username": "Goober",
                        "content": "https://leetcode.com/submissions/detail/435599297/\\n\\n1. **use stack**.\\njust if match \"()\" then just pop and then left stack head cnt++\\n2. **use map to record the valid parenthess counts of head element of stack**\\nuse element struct for recording each index in string and value of each index in string\\n\\n"
                    },
                    {
                        "username": "i3",
                        "content": "![enter image description here][1]\\n\\n\\n  [1]: http://wanzy.me/1.png\\n\\nGot \"Wrong answer\" while \"Run Code\" gave the right result."
                    },
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-valid-parentheses-leetcode-python/\\n"
                    },
                    {
                        "username": "Aayushyu",
                        "content": "The examples should also show that nested parenthesis are also considered in it and must be taken accounted for."
                    },
                    {
                        "username": "nasheethahmeda04",
                        "content": "TLE in SUBMIT but ACCEPTED in TEST CASE\\n\\n\\nSo I tried to solve this by traversing each substring from longest to shortest, I return the current length if any of the substring is valid.\\n\\nMy code:\\n ```\\nclass Solution(object):\\n    def longestValidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n\\n        l = len(s)\\n        for i in range(l, 1, -1):\\n            for j in range(l - i + 1):\\n                if self.valid(s[j:i+j]):\\n                    return i\\n        else:\\n            return 0\\n    \\n    def valid(self, parenthesis):\\n        legal = 0\\n        for ch in parenthesis:\\n            if ch == \\'(\\':\\n                legal += 1\\n            elif legal <= 0:\\n                return False\\n            else:\\n                legal -= 1\\n        return True if legal == 0 else False\\n```\\n\\nit sometimes shows TLE in 226/231 and sometimes in 227/231 etc...\\nit solves both of those cases and other cases in TEST CASES.\\n\\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-\\n\\nin that it says I should not use any global or static variables, afaik I did not use any of them. But i have used a function to validate a string, it is still a method and using it as a global function does not change the outcome too.\\n\\nPlease point out any corrections and do inform me, thanks"
                    },
                    {
                        "username": "user8272RT",
                        "content": "When I see parentheses, I think of stack."
                    },
                    {
                        "username": "ankit_lekhak03",
                        "content": "Why is there a Dynamic Programming tag for this question???\\nThe solution seems to do nothing with dynamic programming!!\\n"
                    },
                    {
                        "username": "pijjalover",
                        "content": "()(()\\nhow is this 2 only? It isnt written that the parenthesis must be continous..."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "This is a medium-level problem since $$O(n^2)$$ solution gets accepted. If the constraints were >= $$10^5$$, it would be hard.\\n\\nMy $$O(n^2)$$ solution:\\n\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int n = s.length(), res = 0;\\n        for(int i = 0; i < n; i++){\\n            int cnt = 0;\\n            for(int j = i; j < n; j++){\\n                if(!cnt and s[j] == \\')\\') break;\\n                if(s[j] == \\'(\\') cnt++;\\n                else cnt--;\\n                if(!cnt) res = max(res, j - i + 1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n"
                    }
                ]
            },
            {
                "id": 1574745,
                "content": [
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-valid-parentheses-leetcode-python/"
                    },
                    {
                        "username": "Goober",
                        "content": "https://leetcode.com/submissions/detail/435599297/\\n\\n1. **use stack**.\\njust if match \"()\" then just pop and then left stack head cnt++\\n2. **use map to record the valid parenthess counts of head element of stack**\\nuse element struct for recording each index in string and value of each index in string\\n\\n"
                    },
                    {
                        "username": "i3",
                        "content": "![enter image description here][1]\\n\\n\\n  [1]: http://wanzy.me/1.png\\n\\nGot \"Wrong answer\" while \"Run Code\" gave the right result."
                    },
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-valid-parentheses-leetcode-python/\\n"
                    },
                    {
                        "username": "Aayushyu",
                        "content": "The examples should also show that nested parenthesis are also considered in it and must be taken accounted for."
                    },
                    {
                        "username": "nasheethahmeda04",
                        "content": "TLE in SUBMIT but ACCEPTED in TEST CASE\\n\\n\\nSo I tried to solve this by traversing each substring from longest to shortest, I return the current length if any of the substring is valid.\\n\\nMy code:\\n ```\\nclass Solution(object):\\n    def longestValidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n\\n        l = len(s)\\n        for i in range(l, 1, -1):\\n            for j in range(l - i + 1):\\n                if self.valid(s[j:i+j]):\\n                    return i\\n        else:\\n            return 0\\n    \\n    def valid(self, parenthesis):\\n        legal = 0\\n        for ch in parenthesis:\\n            if ch == \\'(\\':\\n                legal += 1\\n            elif legal <= 0:\\n                return False\\n            else:\\n                legal -= 1\\n        return True if legal == 0 else False\\n```\\n\\nit sometimes shows TLE in 226/231 and sometimes in 227/231 etc...\\nit solves both of those cases and other cases in TEST CASES.\\n\\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-\\n\\nin that it says I should not use any global or static variables, afaik I did not use any of them. But i have used a function to validate a string, it is still a method and using it as a global function does not change the outcome too.\\n\\nPlease point out any corrections and do inform me, thanks"
                    },
                    {
                        "username": "user8272RT",
                        "content": "When I see parentheses, I think of stack."
                    },
                    {
                        "username": "ankit_lekhak03",
                        "content": "Why is there a Dynamic Programming tag for this question???\\nThe solution seems to do nothing with dynamic programming!!\\n"
                    },
                    {
                        "username": "pijjalover",
                        "content": "()(()\\nhow is this 2 only? It isnt written that the parenthesis must be continous..."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "This is a medium-level problem since $$O(n^2)$$ solution gets accepted. If the constraints were >= $$10^5$$, it would be hard.\\n\\nMy $$O(n^2)$$ solution:\\n\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int n = s.length(), res = 0;\\n        for(int i = 0; i < n; i++){\\n            int cnt = 0;\\n            for(int j = i; j < n; j++){\\n                if(!cnt and s[j] == \\')\\') break;\\n                if(s[j] == \\'(\\') cnt++;\\n                else cnt--;\\n                if(!cnt) res = max(res, j - i + 1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n"
                    }
                ]
            },
            {
                "id": 1571084,
                "content": [
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-valid-parentheses-leetcode-python/"
                    },
                    {
                        "username": "Goober",
                        "content": "https://leetcode.com/submissions/detail/435599297/\\n\\n1. **use stack**.\\njust if match \"()\" then just pop and then left stack head cnt++\\n2. **use map to record the valid parenthess counts of head element of stack**\\nuse element struct for recording each index in string and value of each index in string\\n\\n"
                    },
                    {
                        "username": "i3",
                        "content": "![enter image description here][1]\\n\\n\\n  [1]: http://wanzy.me/1.png\\n\\nGot \"Wrong answer\" while \"Run Code\" gave the right result."
                    },
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-valid-parentheses-leetcode-python/\\n"
                    },
                    {
                        "username": "Aayushyu",
                        "content": "The examples should also show that nested parenthesis are also considered in it and must be taken accounted for."
                    },
                    {
                        "username": "nasheethahmeda04",
                        "content": "TLE in SUBMIT but ACCEPTED in TEST CASE\\n\\n\\nSo I tried to solve this by traversing each substring from longest to shortest, I return the current length if any of the substring is valid.\\n\\nMy code:\\n ```\\nclass Solution(object):\\n    def longestValidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n\\n        l = len(s)\\n        for i in range(l, 1, -1):\\n            for j in range(l - i + 1):\\n                if self.valid(s[j:i+j]):\\n                    return i\\n        else:\\n            return 0\\n    \\n    def valid(self, parenthesis):\\n        legal = 0\\n        for ch in parenthesis:\\n            if ch == \\'(\\':\\n                legal += 1\\n            elif legal <= 0:\\n                return False\\n            else:\\n                legal -= 1\\n        return True if legal == 0 else False\\n```\\n\\nit sometimes shows TLE in 226/231 and sometimes in 227/231 etc...\\nit solves both of those cases and other cases in TEST CASES.\\n\\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-\\n\\nin that it says I should not use any global or static variables, afaik I did not use any of them. But i have used a function to validate a string, it is still a method and using it as a global function does not change the outcome too.\\n\\nPlease point out any corrections and do inform me, thanks"
                    },
                    {
                        "username": "user8272RT",
                        "content": "When I see parentheses, I think of stack."
                    },
                    {
                        "username": "ankit_lekhak03",
                        "content": "Why is there a Dynamic Programming tag for this question???\\nThe solution seems to do nothing with dynamic programming!!\\n"
                    },
                    {
                        "username": "pijjalover",
                        "content": "()(()\\nhow is this 2 only? It isnt written that the parenthesis must be continous..."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "This is a medium-level problem since $$O(n^2)$$ solution gets accepted. If the constraints were >= $$10^5$$, it would be hard.\\n\\nMy $$O(n^2)$$ solution:\\n\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int n = s.length(), res = 0;\\n        for(int i = 0; i < n; i++){\\n            int cnt = 0;\\n            for(int j = i; j < n; j++){\\n                if(!cnt and s[j] == \\')\\') break;\\n                if(s[j] == \\'(\\') cnt++;\\n                else cnt--;\\n                if(!cnt) res = max(res, j - i + 1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n"
                    }
                ]
            },
            {
                "id": 1576733,
                "content": [
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-valid-parentheses-leetcode-python/"
                    },
                    {
                        "username": "Goober",
                        "content": "https://leetcode.com/submissions/detail/435599297/\\n\\n1. **use stack**.\\njust if match \"()\" then just pop and then left stack head cnt++\\n2. **use map to record the valid parenthess counts of head element of stack**\\nuse element struct for recording each index in string and value of each index in string\\n\\n"
                    },
                    {
                        "username": "i3",
                        "content": "![enter image description here][1]\\n\\n\\n  [1]: http://wanzy.me/1.png\\n\\nGot \"Wrong answer\" while \"Run Code\" gave the right result."
                    },
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-valid-parentheses-leetcode-python/\\n"
                    },
                    {
                        "username": "Aayushyu",
                        "content": "The examples should also show that nested parenthesis are also considered in it and must be taken accounted for."
                    },
                    {
                        "username": "nasheethahmeda04",
                        "content": "TLE in SUBMIT but ACCEPTED in TEST CASE\\n\\n\\nSo I tried to solve this by traversing each substring from longest to shortest, I return the current length if any of the substring is valid.\\n\\nMy code:\\n ```\\nclass Solution(object):\\n    def longestValidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n\\n        l = len(s)\\n        for i in range(l, 1, -1):\\n            for j in range(l - i + 1):\\n                if self.valid(s[j:i+j]):\\n                    return i\\n        else:\\n            return 0\\n    \\n    def valid(self, parenthesis):\\n        legal = 0\\n        for ch in parenthesis:\\n            if ch == \\'(\\':\\n                legal += 1\\n            elif legal <= 0:\\n                return False\\n            else:\\n                legal -= 1\\n        return True if legal == 0 else False\\n```\\n\\nit sometimes shows TLE in 226/231 and sometimes in 227/231 etc...\\nit solves both of those cases and other cases in TEST CASES.\\n\\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-\\n\\nin that it says I should not use any global or static variables, afaik I did not use any of them. But i have used a function to validate a string, it is still a method and using it as a global function does not change the outcome too.\\n\\nPlease point out any corrections and do inform me, thanks"
                    },
                    {
                        "username": "user8272RT",
                        "content": "When I see parentheses, I think of stack."
                    },
                    {
                        "username": "ankit_lekhak03",
                        "content": "Why is there a Dynamic Programming tag for this question???\\nThe solution seems to do nothing with dynamic programming!!\\n"
                    },
                    {
                        "username": "pijjalover",
                        "content": "()(()\\nhow is this 2 only? It isnt written that the parenthesis must be continous..."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "This is a medium-level problem since $$O(n^2)$$ solution gets accepted. If the constraints were >= $$10^5$$, it would be hard.\\n\\nMy $$O(n^2)$$ solution:\\n\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int n = s.length(), res = 0;\\n        for(int i = 0; i < n; i++){\\n            int cnt = 0;\\n            for(int j = i; j < n; j++){\\n                if(!cnt and s[j] == \\')\\') break;\\n                if(s[j] == \\'(\\') cnt++;\\n                else cnt--;\\n                if(!cnt) res = max(res, j - i + 1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n"
                    }
                ]
            },
            {
                "id": 2060510,
                "content": [
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-valid-parentheses-leetcode-python/"
                    },
                    {
                        "username": "Goober",
                        "content": "https://leetcode.com/submissions/detail/435599297/\\n\\n1. **use stack**.\\njust if match \"()\" then just pop and then left stack head cnt++\\n2. **use map to record the valid parenthess counts of head element of stack**\\nuse element struct for recording each index in string and value of each index in string\\n\\n"
                    },
                    {
                        "username": "i3",
                        "content": "![enter image description here][1]\\n\\n\\n  [1]: http://wanzy.me/1.png\\n\\nGot \"Wrong answer\" while \"Run Code\" gave the right result."
                    },
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-valid-parentheses-leetcode-python/\\n"
                    },
                    {
                        "username": "Aayushyu",
                        "content": "The examples should also show that nested parenthesis are also considered in it and must be taken accounted for."
                    },
                    {
                        "username": "nasheethahmeda04",
                        "content": "TLE in SUBMIT but ACCEPTED in TEST CASE\\n\\n\\nSo I tried to solve this by traversing each substring from longest to shortest, I return the current length if any of the substring is valid.\\n\\nMy code:\\n ```\\nclass Solution(object):\\n    def longestValidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n\\n        l = len(s)\\n        for i in range(l, 1, -1):\\n            for j in range(l - i + 1):\\n                if self.valid(s[j:i+j]):\\n                    return i\\n        else:\\n            return 0\\n    \\n    def valid(self, parenthesis):\\n        legal = 0\\n        for ch in parenthesis:\\n            if ch == \\'(\\':\\n                legal += 1\\n            elif legal <= 0:\\n                return False\\n            else:\\n                legal -= 1\\n        return True if legal == 0 else False\\n```\\n\\nit sometimes shows TLE in 226/231 and sometimes in 227/231 etc...\\nit solves both of those cases and other cases in TEST CASES.\\n\\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-\\n\\nin that it says I should not use any global or static variables, afaik I did not use any of them. But i have used a function to validate a string, it is still a method and using it as a global function does not change the outcome too.\\n\\nPlease point out any corrections and do inform me, thanks"
                    },
                    {
                        "username": "user8272RT",
                        "content": "When I see parentheses, I think of stack."
                    },
                    {
                        "username": "ankit_lekhak03",
                        "content": "Why is there a Dynamic Programming tag for this question???\\nThe solution seems to do nothing with dynamic programming!!\\n"
                    },
                    {
                        "username": "pijjalover",
                        "content": "()(()\\nhow is this 2 only? It isnt written that the parenthesis must be continous..."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "This is a medium-level problem since $$O(n^2)$$ solution gets accepted. If the constraints were >= $$10^5$$, it would be hard.\\n\\nMy $$O(n^2)$$ solution:\\n\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int n = s.length(), res = 0;\\n        for(int i = 0; i < n; i++){\\n            int cnt = 0;\\n            for(int j = i; j < n; j++){\\n                if(!cnt and s[j] == \\')\\') break;\\n                if(s[j] == \\'(\\') cnt++;\\n                else cnt--;\\n                if(!cnt) res = max(res, j - i + 1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n"
                    }
                ]
            },
            {
                "id": 2052159,
                "content": [
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-valid-parentheses-leetcode-python/"
                    },
                    {
                        "username": "Goober",
                        "content": "https://leetcode.com/submissions/detail/435599297/\\n\\n1. **use stack**.\\njust if match \"()\" then just pop and then left stack head cnt++\\n2. **use map to record the valid parenthess counts of head element of stack**\\nuse element struct for recording each index in string and value of each index in string\\n\\n"
                    },
                    {
                        "username": "i3",
                        "content": "![enter image description here][1]\\n\\n\\n  [1]: http://wanzy.me/1.png\\n\\nGot \"Wrong answer\" while \"Run Code\" gave the right result."
                    },
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-valid-parentheses-leetcode-python/\\n"
                    },
                    {
                        "username": "Aayushyu",
                        "content": "The examples should also show that nested parenthesis are also considered in it and must be taken accounted for."
                    },
                    {
                        "username": "nasheethahmeda04",
                        "content": "TLE in SUBMIT but ACCEPTED in TEST CASE\\n\\n\\nSo I tried to solve this by traversing each substring from longest to shortest, I return the current length if any of the substring is valid.\\n\\nMy code:\\n ```\\nclass Solution(object):\\n    def longestValidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n\\n        l = len(s)\\n        for i in range(l, 1, -1):\\n            for j in range(l - i + 1):\\n                if self.valid(s[j:i+j]):\\n                    return i\\n        else:\\n            return 0\\n    \\n    def valid(self, parenthesis):\\n        legal = 0\\n        for ch in parenthesis:\\n            if ch == \\'(\\':\\n                legal += 1\\n            elif legal <= 0:\\n                return False\\n            else:\\n                legal -= 1\\n        return True if legal == 0 else False\\n```\\n\\nit sometimes shows TLE in 226/231 and sometimes in 227/231 etc...\\nit solves both of those cases and other cases in TEST CASES.\\n\\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-\\n\\nin that it says I should not use any global or static variables, afaik I did not use any of them. But i have used a function to validate a string, it is still a method and using it as a global function does not change the outcome too.\\n\\nPlease point out any corrections and do inform me, thanks"
                    },
                    {
                        "username": "user8272RT",
                        "content": "When I see parentheses, I think of stack."
                    },
                    {
                        "username": "ankit_lekhak03",
                        "content": "Why is there a Dynamic Programming tag for this question???\\nThe solution seems to do nothing with dynamic programming!!\\n"
                    },
                    {
                        "username": "pijjalover",
                        "content": "()(()\\nhow is this 2 only? It isnt written that the parenthesis must be continous..."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "This is a medium-level problem since $$O(n^2)$$ solution gets accepted. If the constraints were >= $$10^5$$, it would be hard.\\n\\nMy $$O(n^2)$$ solution:\\n\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int n = s.length(), res = 0;\\n        for(int i = 0; i < n; i++){\\n            int cnt = 0;\\n            for(int j = i; j < n; j++){\\n                if(!cnt and s[j] == \\')\\') break;\\n                if(s[j] == \\'(\\') cnt++;\\n                else cnt--;\\n                if(!cnt) res = max(res, j - i + 1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n"
                    }
                ]
            },
            {
                "id": 2024840,
                "content": [
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-valid-parentheses-leetcode-python/"
                    },
                    {
                        "username": "Goober",
                        "content": "https://leetcode.com/submissions/detail/435599297/\\n\\n1. **use stack**.\\njust if match \"()\" then just pop and then left stack head cnt++\\n2. **use map to record the valid parenthess counts of head element of stack**\\nuse element struct for recording each index in string and value of each index in string\\n\\n"
                    },
                    {
                        "username": "i3",
                        "content": "![enter image description here][1]\\n\\n\\n  [1]: http://wanzy.me/1.png\\n\\nGot \"Wrong answer\" while \"Run Code\" gave the right result."
                    },
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-valid-parentheses-leetcode-python/\\n"
                    },
                    {
                        "username": "Aayushyu",
                        "content": "The examples should also show that nested parenthesis are also considered in it and must be taken accounted for."
                    },
                    {
                        "username": "nasheethahmeda04",
                        "content": "TLE in SUBMIT but ACCEPTED in TEST CASE\\n\\n\\nSo I tried to solve this by traversing each substring from longest to shortest, I return the current length if any of the substring is valid.\\n\\nMy code:\\n ```\\nclass Solution(object):\\n    def longestValidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n\\n        l = len(s)\\n        for i in range(l, 1, -1):\\n            for j in range(l - i + 1):\\n                if self.valid(s[j:i+j]):\\n                    return i\\n        else:\\n            return 0\\n    \\n    def valid(self, parenthesis):\\n        legal = 0\\n        for ch in parenthesis:\\n            if ch == \\'(\\':\\n                legal += 1\\n            elif legal <= 0:\\n                return False\\n            else:\\n                legal -= 1\\n        return True if legal == 0 else False\\n```\\n\\nit sometimes shows TLE in 226/231 and sometimes in 227/231 etc...\\nit solves both of those cases and other cases in TEST CASES.\\n\\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-\\n\\nin that it says I should not use any global or static variables, afaik I did not use any of them. But i have used a function to validate a string, it is still a method and using it as a global function does not change the outcome too.\\n\\nPlease point out any corrections and do inform me, thanks"
                    },
                    {
                        "username": "user8272RT",
                        "content": "When I see parentheses, I think of stack."
                    },
                    {
                        "username": "ankit_lekhak03",
                        "content": "Why is there a Dynamic Programming tag for this question???\\nThe solution seems to do nothing with dynamic programming!!\\n"
                    },
                    {
                        "username": "pijjalover",
                        "content": "()(()\\nhow is this 2 only? It isnt written that the parenthesis must be continous..."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "This is a medium-level problem since $$O(n^2)$$ solution gets accepted. If the constraints were >= $$10^5$$, it would be hard.\\n\\nMy $$O(n^2)$$ solution:\\n\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int n = s.length(), res = 0;\\n        for(int i = 0; i < n; i++){\\n            int cnt = 0;\\n            for(int j = i; j < n; j++){\\n                if(!cnt and s[j] == \\')\\') break;\\n                if(s[j] == \\'(\\') cnt++;\\n                else cnt--;\\n                if(!cnt) res = max(res, j - i + 1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n"
                    }
                ]
            },
            {
                "id": 2022604,
                "content": [
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-valid-parentheses-leetcode-python/"
                    },
                    {
                        "username": "Goober",
                        "content": "https://leetcode.com/submissions/detail/435599297/\\n\\n1. **use stack**.\\njust if match \"()\" then just pop and then left stack head cnt++\\n2. **use map to record the valid parenthess counts of head element of stack**\\nuse element struct for recording each index in string and value of each index in string\\n\\n"
                    },
                    {
                        "username": "i3",
                        "content": "![enter image description here][1]\\n\\n\\n  [1]: http://wanzy.me/1.png\\n\\nGot \"Wrong answer\" while \"Run Code\" gave the right result."
                    },
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-valid-parentheses-leetcode-python/\\n"
                    },
                    {
                        "username": "Aayushyu",
                        "content": "The examples should also show that nested parenthesis are also considered in it and must be taken accounted for."
                    },
                    {
                        "username": "nasheethahmeda04",
                        "content": "TLE in SUBMIT but ACCEPTED in TEST CASE\\n\\n\\nSo I tried to solve this by traversing each substring from longest to shortest, I return the current length if any of the substring is valid.\\n\\nMy code:\\n ```\\nclass Solution(object):\\n    def longestValidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n\\n        l = len(s)\\n        for i in range(l, 1, -1):\\n            for j in range(l - i + 1):\\n                if self.valid(s[j:i+j]):\\n                    return i\\n        else:\\n            return 0\\n    \\n    def valid(self, parenthesis):\\n        legal = 0\\n        for ch in parenthesis:\\n            if ch == \\'(\\':\\n                legal += 1\\n            elif legal <= 0:\\n                return False\\n            else:\\n                legal -= 1\\n        return True if legal == 0 else False\\n```\\n\\nit sometimes shows TLE in 226/231 and sometimes in 227/231 etc...\\nit solves both of those cases and other cases in TEST CASES.\\n\\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-\\n\\nin that it says I should not use any global or static variables, afaik I did not use any of them. But i have used a function to validate a string, it is still a method and using it as a global function does not change the outcome too.\\n\\nPlease point out any corrections and do inform me, thanks"
                    },
                    {
                        "username": "user8272RT",
                        "content": "When I see parentheses, I think of stack."
                    },
                    {
                        "username": "ankit_lekhak03",
                        "content": "Why is there a Dynamic Programming tag for this question???\\nThe solution seems to do nothing with dynamic programming!!\\n"
                    },
                    {
                        "username": "pijjalover",
                        "content": "()(()\\nhow is this 2 only? It isnt written that the parenthesis must be continous..."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "This is a medium-level problem since $$O(n^2)$$ solution gets accepted. If the constraints were >= $$10^5$$, it would be hard.\\n\\nMy $$O(n^2)$$ solution:\\n\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int n = s.length(), res = 0;\\n        for(int i = 0; i < n; i++){\\n            int cnt = 0;\\n            for(int j = i; j < n; j++){\\n                if(!cnt and s[j] == \\')\\') break;\\n                if(s[j] == \\'(\\') cnt++;\\n                else cnt--;\\n                if(!cnt) res = max(res, j - i + 1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n"
                    }
                ]
            },
            {
                "id": 2005752,
                "content": [
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-valid-parentheses-leetcode-python/"
                    },
                    {
                        "username": "Goober",
                        "content": "https://leetcode.com/submissions/detail/435599297/\\n\\n1. **use stack**.\\njust if match \"()\" then just pop and then left stack head cnt++\\n2. **use map to record the valid parenthess counts of head element of stack**\\nuse element struct for recording each index in string and value of each index in string\\n\\n"
                    },
                    {
                        "username": "i3",
                        "content": "![enter image description here][1]\\n\\n\\n  [1]: http://wanzy.me/1.png\\n\\nGot \"Wrong answer\" while \"Run Code\" gave the right result."
                    },
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-valid-parentheses-leetcode-python/\\n"
                    },
                    {
                        "username": "Aayushyu",
                        "content": "The examples should also show that nested parenthesis are also considered in it and must be taken accounted for."
                    },
                    {
                        "username": "nasheethahmeda04",
                        "content": "TLE in SUBMIT but ACCEPTED in TEST CASE\\n\\n\\nSo I tried to solve this by traversing each substring from longest to shortest, I return the current length if any of the substring is valid.\\n\\nMy code:\\n ```\\nclass Solution(object):\\n    def longestValidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n\\n        l = len(s)\\n        for i in range(l, 1, -1):\\n            for j in range(l - i + 1):\\n                if self.valid(s[j:i+j]):\\n                    return i\\n        else:\\n            return 0\\n    \\n    def valid(self, parenthesis):\\n        legal = 0\\n        for ch in parenthesis:\\n            if ch == \\'(\\':\\n                legal += 1\\n            elif legal <= 0:\\n                return False\\n            else:\\n                legal -= 1\\n        return True if legal == 0 else False\\n```\\n\\nit sometimes shows TLE in 226/231 and sometimes in 227/231 etc...\\nit solves both of those cases and other cases in TEST CASES.\\n\\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-\\n\\nin that it says I should not use any global or static variables, afaik I did not use any of them. But i have used a function to validate a string, it is still a method and using it as a global function does not change the outcome too.\\n\\nPlease point out any corrections and do inform me, thanks"
                    },
                    {
                        "username": "user8272RT",
                        "content": "When I see parentheses, I think of stack."
                    },
                    {
                        "username": "ankit_lekhak03",
                        "content": "Why is there a Dynamic Programming tag for this question???\\nThe solution seems to do nothing with dynamic programming!!\\n"
                    },
                    {
                        "username": "pijjalover",
                        "content": "()(()\\nhow is this 2 only? It isnt written that the parenthesis must be continous..."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "This is a medium-level problem since $$O(n^2)$$ solution gets accepted. If the constraints were >= $$10^5$$, it would be hard.\\n\\nMy $$O(n^2)$$ solution:\\n\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int n = s.length(), res = 0;\\n        for(int i = 0; i < n; i++){\\n            int cnt = 0;\\n            for(int j = i; j < n; j++){\\n                if(!cnt and s[j] == \\')\\') break;\\n                if(s[j] == \\'(\\') cnt++;\\n                else cnt--;\\n                if(!cnt) res = max(res, j - i + 1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n"
                    }
                ]
            },
            {
                "id": 1999896,
                "content": [
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-valid-parentheses-leetcode-python/"
                    },
                    {
                        "username": "Goober",
                        "content": "https://leetcode.com/submissions/detail/435599297/\\n\\n1. **use stack**.\\njust if match \"()\" then just pop and then left stack head cnt++\\n2. **use map to record the valid parenthess counts of head element of stack**\\nuse element struct for recording each index in string and value of each index in string\\n\\n"
                    },
                    {
                        "username": "i3",
                        "content": "![enter image description here][1]\\n\\n\\n  [1]: http://wanzy.me/1.png\\n\\nGot \"Wrong answer\" while \"Run Code\" gave the right result."
                    },
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-valid-parentheses-leetcode-python/\\n"
                    },
                    {
                        "username": "Aayushyu",
                        "content": "The examples should also show that nested parenthesis are also considered in it and must be taken accounted for."
                    },
                    {
                        "username": "nasheethahmeda04",
                        "content": "TLE in SUBMIT but ACCEPTED in TEST CASE\\n\\n\\nSo I tried to solve this by traversing each substring from longest to shortest, I return the current length if any of the substring is valid.\\n\\nMy code:\\n ```\\nclass Solution(object):\\n    def longestValidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n\\n        l = len(s)\\n        for i in range(l, 1, -1):\\n            for j in range(l - i + 1):\\n                if self.valid(s[j:i+j]):\\n                    return i\\n        else:\\n            return 0\\n    \\n    def valid(self, parenthesis):\\n        legal = 0\\n        for ch in parenthesis:\\n            if ch == \\'(\\':\\n                legal += 1\\n            elif legal <= 0:\\n                return False\\n            else:\\n                legal -= 1\\n        return True if legal == 0 else False\\n```\\n\\nit sometimes shows TLE in 226/231 and sometimes in 227/231 etc...\\nit solves both of those cases and other cases in TEST CASES.\\n\\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-\\n\\nin that it says I should not use any global or static variables, afaik I did not use any of them. But i have used a function to validate a string, it is still a method and using it as a global function does not change the outcome too.\\n\\nPlease point out any corrections and do inform me, thanks"
                    },
                    {
                        "username": "user8272RT",
                        "content": "When I see parentheses, I think of stack."
                    },
                    {
                        "username": "ankit_lekhak03",
                        "content": "Why is there a Dynamic Programming tag for this question???\\nThe solution seems to do nothing with dynamic programming!!\\n"
                    },
                    {
                        "username": "pijjalover",
                        "content": "()(()\\nhow is this 2 only? It isnt written that the parenthesis must be continous..."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "This is a medium-level problem since $$O(n^2)$$ solution gets accepted. If the constraints were >= $$10^5$$, it would be hard.\\n\\nMy $$O(n^2)$$ solution:\\n\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int n = s.length(), res = 0;\\n        for(int i = 0; i < n; i++){\\n            int cnt = 0;\\n            for(int j = i; j < n; j++){\\n                if(!cnt and s[j] == \\')\\') break;\\n                if(s[j] == \\'(\\') cnt++;\\n                else cnt--;\\n                if(!cnt) res = max(res, j - i + 1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n"
                    }
                ]
            },
            {
                "id": 1980238,
                "content": [
                    {
                        "username": "harchetsingh12",
                        "content": "i dont think this should be hard\\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Most simplest approach I have seen till now. Only you need to mark for valid ones and count after. It may not be optimized but it is good until it passing all testcases.\\n[Solution](https://leetcode.com/problems/longest-valid-parentheses/solutions/3729896/unique-approach-easy-to-understand-the-question/)"
                    },
                    {
                        "username": "prixxx",
                        "content": "how is \"()(()\" the answer for this testcase equal to 2? could someone explain\\n shouldnt it be 4?"
                    },
                    {
                        "username": "yshaikh2424",
                        "content": "Valid parentheses are not in a substring."
                    },
                    {
                        "username": "IsaiUriepero",
                        "content": "The function returns the length of the longest valid parentheses substring in the given string."
                    },
                    {
                        "username": "Lokesh04",
                        "content": "what will be the output if s=\"()(()))()()()\"\\ngiven solution giving 8 but i think it should be 14 answer"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "How  for the following string \"()(()\":\\nthe expected output is 2 \\nwhile code output is 4, which seems tobe correct ?"
                    },
                    {
                        "username": "user8326LT",
                        "content": "why does this output will be 2  for this testcase \"()(()\""
                    },
                    {
                        "username": "marshel__69",
                        "content": "how the heck answer for this \"()(()\" is 2"
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "The question mentioned substring so i think the middle \\'(\\' breaks the string. so we must return the longest substring length.\\nIt may be wrong. I too have the same doubt."
                    },
                    {
                        "username": "Stellar_Serene",
                        "content": "if you encounter the problem of index out of bounds with the illegal index of -128, you might be defining stack pointer as char like me."
                    },
                    {
                        "username": "chprvaibhav",
                        "content": "hey hi hello , can anyone tell me what is wrong with my code and why i am getting run time error with this \n\nclass Solution {\npublic:\n    int longestValidParentheses(string expr) {\n        int counter=0;\n        stack<char> temp;\n        vector<int> ans;\n    for (int i = 0; i < expr.length(); i++) {\n        if (temp.empty()) {\n            temp.push(expr[i]);\n        }\n        else if ((temp.top() == '(' && expr[i] == ')')\n                 || (temp.top() == '{' && expr[i] == '}')\n                 || (temp.top() == '[' && expr[i] == ']')) {\n            temp.pop();\n            counter=counter+2;\n            ans.push_back(counter);\n        }\n        else {\n            temp.push(expr[i]);\n            counter=0;\n        }\n    }\n   int sie=ans.size();\n   return ans[sie-1];\n    }\n};"
                    }
                ]
            },
            {
                "id": 1959430,
                "content": [
                    {
                        "username": "harchetsingh12",
                        "content": "i dont think this should be hard\\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Most simplest approach I have seen till now. Only you need to mark for valid ones and count after. It may not be optimized but it is good until it passing all testcases.\\n[Solution](https://leetcode.com/problems/longest-valid-parentheses/solutions/3729896/unique-approach-easy-to-understand-the-question/)"
                    },
                    {
                        "username": "prixxx",
                        "content": "how is \"()(()\" the answer for this testcase equal to 2? could someone explain\\n shouldnt it be 4?"
                    },
                    {
                        "username": "yshaikh2424",
                        "content": "Valid parentheses are not in a substring."
                    },
                    {
                        "username": "IsaiUriepero",
                        "content": "The function returns the length of the longest valid parentheses substring in the given string."
                    },
                    {
                        "username": "Lokesh04",
                        "content": "what will be the output if s=\"()(()))()()()\"\\ngiven solution giving 8 but i think it should be 14 answer"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "How  for the following string \"()(()\":\\nthe expected output is 2 \\nwhile code output is 4, which seems tobe correct ?"
                    },
                    {
                        "username": "user8326LT",
                        "content": "why does this output will be 2  for this testcase \"()(()\""
                    },
                    {
                        "username": "marshel__69",
                        "content": "how the heck answer for this \"()(()\" is 2"
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "The question mentioned substring so i think the middle \\'(\\' breaks the string. so we must return the longest substring length.\\nIt may be wrong. I too have the same doubt."
                    },
                    {
                        "username": "Stellar_Serene",
                        "content": "if you encounter the problem of index out of bounds with the illegal index of -128, you might be defining stack pointer as char like me."
                    },
                    {
                        "username": "chprvaibhav",
                        "content": "hey hi hello , can anyone tell me what is wrong with my code and why i am getting run time error with this \n\nclass Solution {\npublic:\n    int longestValidParentheses(string expr) {\n        int counter=0;\n        stack<char> temp;\n        vector<int> ans;\n    for (int i = 0; i < expr.length(); i++) {\n        if (temp.empty()) {\n            temp.push(expr[i]);\n        }\n        else if ((temp.top() == '(' && expr[i] == ')')\n                 || (temp.top() == '{' && expr[i] == '}')\n                 || (temp.top() == '[' && expr[i] == ']')) {\n            temp.pop();\n            counter=counter+2;\n            ans.push_back(counter);\n        }\n        else {\n            temp.push(expr[i]);\n            counter=0;\n        }\n    }\n   int sie=ans.size();\n   return ans[sie-1];\n    }\n};"
                    }
                ]
            },
            {
                "id": 1932622,
                "content": [
                    {
                        "username": "harchetsingh12",
                        "content": "i dont think this should be hard\\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Most simplest approach I have seen till now. Only you need to mark for valid ones and count after. It may not be optimized but it is good until it passing all testcases.\\n[Solution](https://leetcode.com/problems/longest-valid-parentheses/solutions/3729896/unique-approach-easy-to-understand-the-question/)"
                    },
                    {
                        "username": "prixxx",
                        "content": "how is \"()(()\" the answer for this testcase equal to 2? could someone explain\\n shouldnt it be 4?"
                    },
                    {
                        "username": "yshaikh2424",
                        "content": "Valid parentheses are not in a substring."
                    },
                    {
                        "username": "IsaiUriepero",
                        "content": "The function returns the length of the longest valid parentheses substring in the given string."
                    },
                    {
                        "username": "Lokesh04",
                        "content": "what will be the output if s=\"()(()))()()()\"\\ngiven solution giving 8 but i think it should be 14 answer"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "How  for the following string \"()(()\":\\nthe expected output is 2 \\nwhile code output is 4, which seems tobe correct ?"
                    },
                    {
                        "username": "user8326LT",
                        "content": "why does this output will be 2  for this testcase \"()(()\""
                    },
                    {
                        "username": "marshel__69",
                        "content": "how the heck answer for this \"()(()\" is 2"
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "The question mentioned substring so i think the middle \\'(\\' breaks the string. so we must return the longest substring length.\\nIt may be wrong. I too have the same doubt."
                    },
                    {
                        "username": "Stellar_Serene",
                        "content": "if you encounter the problem of index out of bounds with the illegal index of -128, you might be defining stack pointer as char like me."
                    },
                    {
                        "username": "chprvaibhav",
                        "content": "hey hi hello , can anyone tell me what is wrong with my code and why i am getting run time error with this \n\nclass Solution {\npublic:\n    int longestValidParentheses(string expr) {\n        int counter=0;\n        stack<char> temp;\n        vector<int> ans;\n    for (int i = 0; i < expr.length(); i++) {\n        if (temp.empty()) {\n            temp.push(expr[i]);\n        }\n        else if ((temp.top() == '(' && expr[i] == ')')\n                 || (temp.top() == '{' && expr[i] == '}')\n                 || (temp.top() == '[' && expr[i] == ']')) {\n            temp.pop();\n            counter=counter+2;\n            ans.push_back(counter);\n        }\n        else {\n            temp.push(expr[i]);\n            counter=0;\n        }\n    }\n   int sie=ans.size();\n   return ans[sie-1];\n    }\n};"
                    }
                ]
            },
            {
                "id": 1926106,
                "content": [
                    {
                        "username": "harchetsingh12",
                        "content": "i dont think this should be hard\\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Most simplest approach I have seen till now. Only you need to mark for valid ones and count after. It may not be optimized but it is good until it passing all testcases.\\n[Solution](https://leetcode.com/problems/longest-valid-parentheses/solutions/3729896/unique-approach-easy-to-understand-the-question/)"
                    },
                    {
                        "username": "prixxx",
                        "content": "how is \"()(()\" the answer for this testcase equal to 2? could someone explain\\n shouldnt it be 4?"
                    },
                    {
                        "username": "yshaikh2424",
                        "content": "Valid parentheses are not in a substring."
                    },
                    {
                        "username": "IsaiUriepero",
                        "content": "The function returns the length of the longest valid parentheses substring in the given string."
                    },
                    {
                        "username": "Lokesh04",
                        "content": "what will be the output if s=\"()(()))()()()\"\\ngiven solution giving 8 but i think it should be 14 answer"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "How  for the following string \"()(()\":\\nthe expected output is 2 \\nwhile code output is 4, which seems tobe correct ?"
                    },
                    {
                        "username": "user8326LT",
                        "content": "why does this output will be 2  for this testcase \"()(()\""
                    },
                    {
                        "username": "marshel__69",
                        "content": "how the heck answer for this \"()(()\" is 2"
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "The question mentioned substring so i think the middle \\'(\\' breaks the string. so we must return the longest substring length.\\nIt may be wrong. I too have the same doubt."
                    },
                    {
                        "username": "Stellar_Serene",
                        "content": "if you encounter the problem of index out of bounds with the illegal index of -128, you might be defining stack pointer as char like me."
                    },
                    {
                        "username": "chprvaibhav",
                        "content": "hey hi hello , can anyone tell me what is wrong with my code and why i am getting run time error with this \n\nclass Solution {\npublic:\n    int longestValidParentheses(string expr) {\n        int counter=0;\n        stack<char> temp;\n        vector<int> ans;\n    for (int i = 0; i < expr.length(); i++) {\n        if (temp.empty()) {\n            temp.push(expr[i]);\n        }\n        else if ((temp.top() == '(' && expr[i] == ')')\n                 || (temp.top() == '{' && expr[i] == '}')\n                 || (temp.top() == '[' && expr[i] == ']')) {\n            temp.pop();\n            counter=counter+2;\n            ans.push_back(counter);\n        }\n        else {\n            temp.push(expr[i]);\n            counter=0;\n        }\n    }\n   int sie=ans.size();\n   return ans[sie-1];\n    }\n};"
                    }
                ]
            },
            {
                "id": 1888182,
                "content": [
                    {
                        "username": "harchetsingh12",
                        "content": "i dont think this should be hard\\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Most simplest approach I have seen till now. Only you need to mark for valid ones and count after. It may not be optimized but it is good until it passing all testcases.\\n[Solution](https://leetcode.com/problems/longest-valid-parentheses/solutions/3729896/unique-approach-easy-to-understand-the-question/)"
                    },
                    {
                        "username": "prixxx",
                        "content": "how is \"()(()\" the answer for this testcase equal to 2? could someone explain\\n shouldnt it be 4?"
                    },
                    {
                        "username": "yshaikh2424",
                        "content": "Valid parentheses are not in a substring."
                    },
                    {
                        "username": "IsaiUriepero",
                        "content": "The function returns the length of the longest valid parentheses substring in the given string."
                    },
                    {
                        "username": "Lokesh04",
                        "content": "what will be the output if s=\"()(()))()()()\"\\ngiven solution giving 8 but i think it should be 14 answer"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "How  for the following string \"()(()\":\\nthe expected output is 2 \\nwhile code output is 4, which seems tobe correct ?"
                    },
                    {
                        "username": "user8326LT",
                        "content": "why does this output will be 2  for this testcase \"()(()\""
                    },
                    {
                        "username": "marshel__69",
                        "content": "how the heck answer for this \"()(()\" is 2"
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "The question mentioned substring so i think the middle \\'(\\' breaks the string. so we must return the longest substring length.\\nIt may be wrong. I too have the same doubt."
                    },
                    {
                        "username": "Stellar_Serene",
                        "content": "if you encounter the problem of index out of bounds with the illegal index of -128, you might be defining stack pointer as char like me."
                    },
                    {
                        "username": "chprvaibhav",
                        "content": "hey hi hello , can anyone tell me what is wrong with my code and why i am getting run time error with this \n\nclass Solution {\npublic:\n    int longestValidParentheses(string expr) {\n        int counter=0;\n        stack<char> temp;\n        vector<int> ans;\n    for (int i = 0; i < expr.length(); i++) {\n        if (temp.empty()) {\n            temp.push(expr[i]);\n        }\n        else if ((temp.top() == '(' && expr[i] == ')')\n                 || (temp.top() == '{' && expr[i] == '}')\n                 || (temp.top() == '[' && expr[i] == ']')) {\n            temp.pop();\n            counter=counter+2;\n            ans.push_back(counter);\n        }\n        else {\n            temp.push(expr[i]);\n            counter=0;\n        }\n    }\n   int sie=ans.size();\n   return ans[sie-1];\n    }\n};"
                    }
                ]
            },
            {
                "id": 1864340,
                "content": [
                    {
                        "username": "harchetsingh12",
                        "content": "i dont think this should be hard\\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Most simplest approach I have seen till now. Only you need to mark for valid ones and count after. It may not be optimized but it is good until it passing all testcases.\\n[Solution](https://leetcode.com/problems/longest-valid-parentheses/solutions/3729896/unique-approach-easy-to-understand-the-question/)"
                    },
                    {
                        "username": "prixxx",
                        "content": "how is \"()(()\" the answer for this testcase equal to 2? could someone explain\\n shouldnt it be 4?"
                    },
                    {
                        "username": "yshaikh2424",
                        "content": "Valid parentheses are not in a substring."
                    },
                    {
                        "username": "IsaiUriepero",
                        "content": "The function returns the length of the longest valid parentheses substring in the given string."
                    },
                    {
                        "username": "Lokesh04",
                        "content": "what will be the output if s=\"()(()))()()()\"\\ngiven solution giving 8 but i think it should be 14 answer"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "How  for the following string \"()(()\":\\nthe expected output is 2 \\nwhile code output is 4, which seems tobe correct ?"
                    },
                    {
                        "username": "user8326LT",
                        "content": "why does this output will be 2  for this testcase \"()(()\""
                    },
                    {
                        "username": "marshel__69",
                        "content": "how the heck answer for this \"()(()\" is 2"
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "The question mentioned substring so i think the middle \\'(\\' breaks the string. so we must return the longest substring length.\\nIt may be wrong. I too have the same doubt."
                    },
                    {
                        "username": "Stellar_Serene",
                        "content": "if you encounter the problem of index out of bounds with the illegal index of -128, you might be defining stack pointer as char like me."
                    },
                    {
                        "username": "chprvaibhav",
                        "content": "hey hi hello , can anyone tell me what is wrong with my code and why i am getting run time error with this \n\nclass Solution {\npublic:\n    int longestValidParentheses(string expr) {\n        int counter=0;\n        stack<char> temp;\n        vector<int> ans;\n    for (int i = 0; i < expr.length(); i++) {\n        if (temp.empty()) {\n            temp.push(expr[i]);\n        }\n        else if ((temp.top() == '(' && expr[i] == ')')\n                 || (temp.top() == '{' && expr[i] == '}')\n                 || (temp.top() == '[' && expr[i] == ']')) {\n            temp.pop();\n            counter=counter+2;\n            ans.push_back(counter);\n        }\n        else {\n            temp.push(expr[i]);\n            counter=0;\n        }\n    }\n   int sie=ans.size();\n   return ans[sie-1];\n    }\n};"
                    }
                ]
            },
            {
                "id": 1851831,
                "content": [
                    {
                        "username": "harchetsingh12",
                        "content": "i dont think this should be hard\\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Most simplest approach I have seen till now. Only you need to mark for valid ones and count after. It may not be optimized but it is good until it passing all testcases.\\n[Solution](https://leetcode.com/problems/longest-valid-parentheses/solutions/3729896/unique-approach-easy-to-understand-the-question/)"
                    },
                    {
                        "username": "prixxx",
                        "content": "how is \"()(()\" the answer for this testcase equal to 2? could someone explain\\n shouldnt it be 4?"
                    },
                    {
                        "username": "yshaikh2424",
                        "content": "Valid parentheses are not in a substring."
                    },
                    {
                        "username": "IsaiUriepero",
                        "content": "The function returns the length of the longest valid parentheses substring in the given string."
                    },
                    {
                        "username": "Lokesh04",
                        "content": "what will be the output if s=\"()(()))()()()\"\\ngiven solution giving 8 but i think it should be 14 answer"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "How  for the following string \"()(()\":\\nthe expected output is 2 \\nwhile code output is 4, which seems tobe correct ?"
                    },
                    {
                        "username": "user8326LT",
                        "content": "why does this output will be 2  for this testcase \"()(()\""
                    },
                    {
                        "username": "marshel__69",
                        "content": "how the heck answer for this \"()(()\" is 2"
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "The question mentioned substring so i think the middle \\'(\\' breaks the string. so we must return the longest substring length.\\nIt may be wrong. I too have the same doubt."
                    },
                    {
                        "username": "Stellar_Serene",
                        "content": "if you encounter the problem of index out of bounds with the illegal index of -128, you might be defining stack pointer as char like me."
                    },
                    {
                        "username": "chprvaibhav",
                        "content": "hey hi hello , can anyone tell me what is wrong with my code and why i am getting run time error with this \n\nclass Solution {\npublic:\n    int longestValidParentheses(string expr) {\n        int counter=0;\n        stack<char> temp;\n        vector<int> ans;\n    for (int i = 0; i < expr.length(); i++) {\n        if (temp.empty()) {\n            temp.push(expr[i]);\n        }\n        else if ((temp.top() == '(' && expr[i] == ')')\n                 || (temp.top() == '{' && expr[i] == '}')\n                 || (temp.top() == '[' && expr[i] == ']')) {\n            temp.pop();\n            counter=counter+2;\n            ans.push_back(counter);\n        }\n        else {\n            temp.push(expr[i]);\n            counter=0;\n        }\n    }\n   int sie=ans.size();\n   return ans[sie-1];\n    }\n};"
                    }
                ]
            },
            {
                "id": 1839542,
                "content": [
                    {
                        "username": "harchetsingh12",
                        "content": "i dont think this should be hard\\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Most simplest approach I have seen till now. Only you need to mark for valid ones and count after. It may not be optimized but it is good until it passing all testcases.\\n[Solution](https://leetcode.com/problems/longest-valid-parentheses/solutions/3729896/unique-approach-easy-to-understand-the-question/)"
                    },
                    {
                        "username": "prixxx",
                        "content": "how is \"()(()\" the answer for this testcase equal to 2? could someone explain\\n shouldnt it be 4?"
                    },
                    {
                        "username": "yshaikh2424",
                        "content": "Valid parentheses are not in a substring."
                    },
                    {
                        "username": "IsaiUriepero",
                        "content": "The function returns the length of the longest valid parentheses substring in the given string."
                    },
                    {
                        "username": "Lokesh04",
                        "content": "what will be the output if s=\"()(()))()()()\"\\ngiven solution giving 8 but i think it should be 14 answer"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "How  for the following string \"()(()\":\\nthe expected output is 2 \\nwhile code output is 4, which seems tobe correct ?"
                    },
                    {
                        "username": "user8326LT",
                        "content": "why does this output will be 2  for this testcase \"()(()\""
                    },
                    {
                        "username": "marshel__69",
                        "content": "how the heck answer for this \"()(()\" is 2"
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "The question mentioned substring so i think the middle \\'(\\' breaks the string. so we must return the longest substring length.\\nIt may be wrong. I too have the same doubt."
                    },
                    {
                        "username": "Stellar_Serene",
                        "content": "if you encounter the problem of index out of bounds with the illegal index of -128, you might be defining stack pointer as char like me."
                    },
                    {
                        "username": "chprvaibhav",
                        "content": "hey hi hello , can anyone tell me what is wrong with my code and why i am getting run time error with this \n\nclass Solution {\npublic:\n    int longestValidParentheses(string expr) {\n        int counter=0;\n        stack<char> temp;\n        vector<int> ans;\n    for (int i = 0; i < expr.length(); i++) {\n        if (temp.empty()) {\n            temp.push(expr[i]);\n        }\n        else if ((temp.top() == '(' && expr[i] == ')')\n                 || (temp.top() == '{' && expr[i] == '}')\n                 || (temp.top() == '[' && expr[i] == ']')) {\n            temp.pop();\n            counter=counter+2;\n            ans.push_back(counter);\n        }\n        else {\n            temp.push(expr[i]);\n            counter=0;\n        }\n    }\n   int sie=ans.size();\n   return ans[sie-1];\n    }\n};"
                    }
                ]
            },
            {
                "id": 1835929,
                "content": [
                    {
                        "username": "harchetsingh12",
                        "content": "i dont think this should be hard\\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Most simplest approach I have seen till now. Only you need to mark for valid ones and count after. It may not be optimized but it is good until it passing all testcases.\\n[Solution](https://leetcode.com/problems/longest-valid-parentheses/solutions/3729896/unique-approach-easy-to-understand-the-question/)"
                    },
                    {
                        "username": "prixxx",
                        "content": "how is \"()(()\" the answer for this testcase equal to 2? could someone explain\\n shouldnt it be 4?"
                    },
                    {
                        "username": "yshaikh2424",
                        "content": "Valid parentheses are not in a substring."
                    },
                    {
                        "username": "IsaiUriepero",
                        "content": "The function returns the length of the longest valid parentheses substring in the given string."
                    },
                    {
                        "username": "Lokesh04",
                        "content": "what will be the output if s=\"()(()))()()()\"\\ngiven solution giving 8 but i think it should be 14 answer"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "How  for the following string \"()(()\":\\nthe expected output is 2 \\nwhile code output is 4, which seems tobe correct ?"
                    },
                    {
                        "username": "user8326LT",
                        "content": "why does this output will be 2  for this testcase \"()(()\""
                    },
                    {
                        "username": "marshel__69",
                        "content": "how the heck answer for this \"()(()\" is 2"
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "The question mentioned substring so i think the middle \\'(\\' breaks the string. so we must return the longest substring length.\\nIt may be wrong. I too have the same doubt."
                    },
                    {
                        "username": "Stellar_Serene",
                        "content": "if you encounter the problem of index out of bounds with the illegal index of -128, you might be defining stack pointer as char like me."
                    },
                    {
                        "username": "chprvaibhav",
                        "content": "hey hi hello , can anyone tell me what is wrong with my code and why i am getting run time error with this \n\nclass Solution {\npublic:\n    int longestValidParentheses(string expr) {\n        int counter=0;\n        stack<char> temp;\n        vector<int> ans;\n    for (int i = 0; i < expr.length(); i++) {\n        if (temp.empty()) {\n            temp.push(expr[i]);\n        }\n        else if ((temp.top() == '(' && expr[i] == ')')\n                 || (temp.top() == '{' && expr[i] == '}')\n                 || (temp.top() == '[' && expr[i] == ']')) {\n            temp.pop();\n            counter=counter+2;\n            ans.push_back(counter);\n        }\n        else {\n            temp.push(expr[i]);\n            counter=0;\n        }\n    }\n   int sie=ans.size();\n   return ans[sie-1];\n    }\n};"
                    }
                ]
            },
            {
                "id": 1755754,
                "content": [
                    {
                        "username": "harchetsingh12",
                        "content": "i dont think this should be hard\\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Most simplest approach I have seen till now. Only you need to mark for valid ones and count after. It may not be optimized but it is good until it passing all testcases.\\n[Solution](https://leetcode.com/problems/longest-valid-parentheses/solutions/3729896/unique-approach-easy-to-understand-the-question/)"
                    },
                    {
                        "username": "prixxx",
                        "content": "how is \"()(()\" the answer for this testcase equal to 2? could someone explain\\n shouldnt it be 4?"
                    },
                    {
                        "username": "yshaikh2424",
                        "content": "Valid parentheses are not in a substring."
                    },
                    {
                        "username": "IsaiUriepero",
                        "content": "The function returns the length of the longest valid parentheses substring in the given string."
                    },
                    {
                        "username": "Lokesh04",
                        "content": "what will be the output if s=\"()(()))()()()\"\\ngiven solution giving 8 but i think it should be 14 answer"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "How  for the following string \"()(()\":\\nthe expected output is 2 \\nwhile code output is 4, which seems tobe correct ?"
                    },
                    {
                        "username": "user8326LT",
                        "content": "why does this output will be 2  for this testcase \"()(()\""
                    },
                    {
                        "username": "marshel__69",
                        "content": "how the heck answer for this \"()(()\" is 2"
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "The question mentioned substring so i think the middle \\'(\\' breaks the string. so we must return the longest substring length.\\nIt may be wrong. I too have the same doubt."
                    },
                    {
                        "username": "Stellar_Serene",
                        "content": "if you encounter the problem of index out of bounds with the illegal index of -128, you might be defining stack pointer as char like me."
                    },
                    {
                        "username": "chprvaibhav",
                        "content": "hey hi hello , can anyone tell me what is wrong with my code and why i am getting run time error with this \n\nclass Solution {\npublic:\n    int longestValidParentheses(string expr) {\n        int counter=0;\n        stack<char> temp;\n        vector<int> ans;\n    for (int i = 0; i < expr.length(); i++) {\n        if (temp.empty()) {\n            temp.push(expr[i]);\n        }\n        else if ((temp.top() == '(' && expr[i] == ')')\n                 || (temp.top() == '{' && expr[i] == '}')\n                 || (temp.top() == '[' && expr[i] == ']')) {\n            temp.pop();\n            counter=counter+2;\n            ans.push_back(counter);\n        }\n        else {\n            temp.push(expr[i]);\n            counter=0;\n        }\n    }\n   int sie=ans.size();\n   return ans[sie-1];\n    }\n};"
                    }
                ]
            }
        ]
    },
    {
        "title": "Palindrome Partitioning II",
        "question_content": "<p>Given a string <code>s</code>, partition <code>s</code> such that every <span data-keyword=\"substring-nonempty\">substring</span> of the partition is a <span data-keyword=\"palindrome-string\">palindrome</span>.</p>\n\n<p>Return <em>the <strong>minimum</strong> cuts needed for a palindrome partitioning of</em> <code>s</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aab&quot;\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The palindrome partitioning [&quot;aa&quot;,&quot;b&quot;] could be produced using 1 cut.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;a&quot;\n<strong>Output:</strong> 0\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;ab&quot;\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 2000</code></li>\n\t<li><code>s</code> consists of lowercase English letters only.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 42198,
                "title": "my-solution-does-not-need-a-table-for-palindrome-is-it-right-it-uses-only-o-n-space",
                "content": "    class Solution {\\n    public:\\n        int minCut(string s) {\\n            int n = s.size();\\n            vector<int> cut(n+1, 0);  // number of cuts for the first k characters\\n            for (int i = 0; i <= n; i++) cut[i] = i-1;\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 0; i-j >= 0 && i+j < n && s[i-j]==s[i+j] ; j++) // odd length palindrome\\n                    cut[i+j+1] = min(cut[i+j+1],1+cut[i-j]);\\n    \\n                for (int j = 1; i-j+1 >= 0 && i+j < n && s[i-j+1] == s[i+j]; j++) // even length palindrome\\n                    cut[i+j+1] = min(cut[i+j+1],1+cut[i-j+1]);\\n            }\\n            return cut[n];\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int minCut(string s) {\\n            int n = s.size();\\n            vector<int> cut(n+1, 0);  // number of cuts for the first k characters\\n            for (int i = 0; i <= n; i++) cut[i] = i-1;\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 0; i-j >= 0 && i+j < n && s[i-j]==s[i+j] ; j++) // odd length palindrome\\n                    cut[i+j+1] = min(cut[i+j+1],1+cut[i-j]);\\n    \\n                for (int j = 1; i-j+1 >= 0 && i+j < n && s[i-j+1] == s[i+j]; j++) // even length palindrome\\n                    cut[i+j+1] = min(cut[i+j+1],1+cut[i-j+1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 42213,
                "title": "easiest-java-dp-solution-97-36",
                "content": "This can be solved by two points:\\n\\n 1. `cut[i]` is the minimum of `cut[j - 1] + 1 (j <= i)`, if `[j, i]` is palindrome.\\n 2. If  `[j, i]` is palindrome, `[j + 1, i - 1]` is palindrome, and `c[j]  == c[i]`.\\n\\nThe 2nd point reminds us of using dp (caching).\\n\\n    a   b   a   |   c  c\\n                    j  i\\n           j-1  |  [j, i] is palindrome\\n       cut(j-1) +  1\\n\\n\\nHope it helps!\\n\\n    public int minCut(String s) {\\n        char[] c = s.toCharArray();\\n        int n = c.length;\\n        int[] cut = new int[n];\\n        boolean[][] pal = new boolean[n][n];\\n        \\n        for(int i = 0; i < n; i++) {\\n            int min = i;\\n            for(int j = 0; j <= i; j++) {\\n                if(c[j] == c[i] && (j + 1 > i - 1 || pal[j + 1][i - 1])) {\\n                    pal[j][i] = true;  \\n                    min = j == 0 ? 0 : Math.min(min, cut[j - 1] + 1);\\n                }\\n            }\\n            cut[i] = min;\\n        }\\n        return cut[n - 1];\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "This can be solved by two points:\\n\\n 1. `cut[i]` is the minimum of `cut[j - 1] + 1 (j <= i)`, if `[j, i]` is palindrome.\\n 2. If  `[j, i]` is palindrome, `[j + 1, i - 1]` is palindrome, and `c[j]  == c[i]`.\\n\\nThe 2nd point reminds us of using dp (caching).\\n\\n    a   b   a   |   c  c\\n                    j  i\\n           j-1  |  [j, i] is palindrome\\n       cut(j-1) +  1\\n\\n\\nHope it helps!\\n\\n    public int minCut(String s) {\\n        char[] c = s.toCharArray();\\n        int n = c.length;\\n        int[] cut = new int[n];\\n        boolean[][] pal = new boolean[n][n];\\n        \\n        for(int i = 0; i < n; i++) {\\n            int min = i;\\n            for(int j = 0; j <= i; j++) {\\n                if(c[j] == c[i] && (j + 1 > i - 1 || pal[j + 1][i - 1])) {\\n                    pal[j][i] = true;  \\n                    min = j == 0 ? 0 : Math.min(min, cut[j - 1] + 1);\\n                }\\n            }\\n            cut[i] = min;\\n        }\\n        return cut[n - 1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 42199,
                "title": "my-dp-solution-explanation-and-code",
                "content": "Calculate and maintain 2 DP states: \\n\\n 1. pal[i][j] , which is whether s[i..j] forms a pal\\n \\n 2.  d[i], which\\n        is the minCut for s[i..n-1]\\n\\nOnce we comes to a pal[i][j]==true:\\n\\n - if j==n-1, the string s[i..n-1] is a Pal, minCut is 0, d[i]=0; \\n - else: the current cut num (first cut s[i..j] and then cut the rest\\n   s[j+1...n-1]) is 1+d[j+1], compare it to the exisiting minCut num\\n   d[i], repalce if smaller.\\n\\nd[0] is the answer.\\n\\n     class Solution {\\n        public:\\n            int minCut(string s) {\\n                if(s.empty()) return 0;\\n                int n = s.size();\\n                vector<vector<bool>> pal(n,vector<bool>(n,false));\\n                vector<int> d(n);\\n                for(int i=n-1;i>=0;i--)\\n                {\\n                    d[i]=n-i-1;\\n                    for(int j=i;j<n;j++)\\n                    {\\n                        if(s[i]==s[j] && (j-i<2 || pal[i+1][j-1]))\\n                        {\\n                           pal[i][j]=true;\\n                           if(j==n-1)\\n                               d[i]=0;\\n                           else if(d[j+1]+1<d[i])\\n                               d[i]=d[j+1]+1;\\n                        }\\n                    }\\n                }\\n                return d[0];\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            int minCut(string s) {\\n                if(s.empty()) return 0;\\n                int n = s.size();\\n                vector<vector<bool>> pal(n,vector<bool>(n,false));\\n                vector<int> d(n);\\n                for(int i=n-1;i>=0;i--)\\n                {\\n                    d[i]=n-i-1;\\n                    for(int j=i;j<n;j++)\\n                    {\\n                        if(s[i]==s[j] && (j-i<2 || pal[i+1][j-1]))\\n                        {\\n                           pal[i][j]=true;\\n                           if(j==n-1)\\n                               d[i]=0;\\n                           else if(d[j+1]+1<d[i])\\n                               d[i]=d[j+1]+1;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 1364206,
                "title": "mcm-pattern-in-aditya-verma-format-with-some-optimizations-all-tc-passed-memoization-1-d-dp",
                "content": "*\"I tried to keep it as simple as possible! Your suggestions are most welcomed\"*\\n\\n\\n```\\n    bool isPalindrome (string & s, int i, int j){\\n        while(i<j){\\n            if(s[i]!=s[j]) return false;\\n            i++; j--;\\n        }\\n        return true;\\n    }\\n    \\n\\n    int solve (string & s, int i, int j, vector<int> & dp){    \\n        \\n        if(i>=j or isPalindrome(s, i, j)) return 0;\\n        \\n        if(dp[i]!=-1) return dp[i];\\n        \\n        int ans = INT_MAX;\\n        \\n        for(int k=i; k<j; k++){\\n            \\n            /* \\n                Instead of writing below standard line\\n                We will recurse for only right part\\n                Only when left part turns out to be palindrome\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tReason : If left substring becomes palindrome then there is no need to partition it further \\n\\t\\t\\t\\t(which in turn reduces the number of recursive calls)\\n                \\n                int temp =  solve (s, i, k, dp, palindrome) + solve (s, k+1, j, dp, palindrome) + 1;\\n                \\n            */\\n            \\n            if(isPalindrome(s, i, k)){                         \\n                int temp = solve (s, k+1, j, dp) + 1;\\n                ans = min (ans, temp);\\n            }\\n        }\\n        \\n        return dp[i] = ans;\\n    }\\n    \\n    int minCut(string s) {\\n        int n = s.length();\\n        \\n        /* I\\'ve used 1D DP here becoz only one parameter is changing i.e. `i` */\\n        \\n        vector<int> dp (n+1, -1);   \\n            \\n        return solve (s, 0, n-1, dp);\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n    bool isPalindrome (string & s, int i, int j){\\n        while(i<j){\\n            if(s[i]!=s[j]) return false;\\n            i++; j--;\\n        }\\n        return true;\\n    }\\n    \\n\\n    int solve (string & s, int i, int j, vector<int> & dp){    \\n        \\n        if(i>=j or isPalindrome(s, i, j)) return 0;\\n        \\n        if(dp[i]!=-1) return dp[i];\\n        \\n        int ans = INT_MAX;\\n        \\n        for(int k=i; k<j; k++){\\n            \\n            /* \\n                Instead of writing below standard line\\n                We will recurse for only right part\\n                Only when left part turns out to be palindrome\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tReason : If left substring becomes palindrome then there is no need to partition it further \\n\\t\\t\\t\\t(which in turn reduces the number of recursive calls)\\n                \\n                int temp =  solve (s, i, k, dp, palindrome) + solve (s, k+1, j, dp, palindrome) + 1;\\n                \\n            */\\n            \\n            if(isPalindrome(s, i, k)){                         \\n                int temp = solve (s, k+1, j, dp) + 1;\\n                ans = min (ans, temp);\\n            }\\n        }\\n        \\n        return dp[i] = ans;\\n    }\\n    \\n    int minCut(string s) {\\n        int n = s.length();\\n        \\n        /* I\\'ve used 1D DP here becoz only one parameter is changing i.e. `i` */\\n        \\n        vector<int> dp (n+1, -1);   \\n            \\n        return solve (s, 0, n-1, dp);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 42212,
                "title": "two-c-versions-given-one-dp-28ms-one-manancher-like-algorithm-10-ms",
                "content": "One typical solution is DP based. Such solution first constructs a two-dimensional bool array isPalin to indicate whether the sub-string s[i..j] is palindrome. To get such array, we need O(N^2) time complexity. Moreover, to get the minimum cuts, we need another array minCuts to do DP and minCuts[i] saves the minimum cuts found for the sub-string s[0..i-1]. minCuts[i] is initialized to i-1, which is the maximum cuts needed (cuts the string into one-letter characters) and minCuts[0] initially sets to -1, which is needed in the case that s[0..i-1] is a palindrome. When we construct isPalin array, we update minCuts everytime we found a palindrome sub-string, i.e. if s[i..j] is a palindrome, then minCuts[j+1] will be updated to the minimum of the current minCuts[j+1] and minCut[i]+1(i.e. cut s[0..j] into s[0,i-1] and s[i,j]). At last, we return minCuts[N]. \\nSo the complexity is O(N^2). However, it can be further improved since as described above, we only update minCuts when we find a palindrome substring, while the DP algorithm spends lots of time to calculate isPalin, most of which is false (i.e. not a palindrome substring). If we can reduce such unnecessary calculation, then we can speed up the algorithm. This can be achieved with a Manancher-like solution, which is also given as following. \\n\\n    // DP solution\\n        class Solution {\\n        public:\\n            int minCut(string s) {\\n                const int N = s.size();\\n                if(N<=1) return 0;\\n                int i,j;\\n                bool isPalin[N][N];\\n                fill_n(&isPalin[0][0], N*N, false);\\n                int minCuts[N+1];\\n                for(i=0; i<=N; ++i) minCuts[i] = i-1;\\n                \\n                for(j=1; j<N; ++j)\\n                {\\n                    for(i=j; i>=0; --i)\\n                    {\\n                        if( (s[i] == s[j]) && ( ( j-i < 2 ) || isPalin[i+1][j-1] ) )\\n                        {\\n                            isPalin[i][j] = true;\\n                            minCuts[j+1] = min(minCuts[j+1], 1 + minCuts[i]);    \\n                        }\\n                    }\\n                }\\n                return minCuts[N];\\n                \\n            }\\n        };\\n\\nThe Manancher-like solution scan the array from left to right (for i loop) and only check those sub-strings centered at s[i]; once a non-palindrome string is found, it will stop and move to i+1. Same as the DP solution, minCUTS[i] is used to save the minimum cuts for s[0:i-1]. For each i, we do two for loops (for j loop) to check if the substrings s[i-j .. i+j] (odd-length substring) and s[i-j-1.. i+j] (even-length substring) are palindrome. By increasing j from 0, we can find all the palindrome sub-strings centered at i and update minCUTS accordingly. Once we meet one non-palindrome sub-string, we stop for-j loop since we know there no further palindrome substring centered at i. This helps us avoid unnecessary palindrome substring checks, as we did in the DP algorithm. Therefore, this version is faster. \\n\\n    //Manancher-like solution\\n    class Solution {\\n    public:\\n        int minCut(string s) {\\n            const int N = s.size();\\n            if(N<=1) return 0;\\n            \\n            int i, j, minCUTS[N+1];\\n            for(i=0; i<=N; ++i) minCUTS[i] = i-1;\\n            \\n            for(i=1;i<N;i++)\\n            {\\n                for(j=0;(i-j)>=0 && (i+j)<N && s[i-j]== s[i+j]; ++j) // odd-length substrings \\n                    minCUTS[i+j+1] = min(minCUTS[i+j+1], 1 + minCUTS[i-j]);\\n    \\n                for(j=0;(i-j-1)>=0 && (i+j)<N && s[i-j-1]== s[i+j]; ++j) // even-length substrings\\n                    minCUTS[i+j+1] = min(minCUTS[i+j+1], 1 + minCUTS[i-j-1]);\\n            }\\n            return minCUTS[N];\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            int minCut(string s) {\\n                const int N = s.size();\\n                if(N<=1) return 0;\\n                int i,j;\\n                bool isPalin[N][N];\\n                fill_n(&isPalin[0][0], N*N, false);\\n                int minCuts[N+1];\\n                for(i=0; i<=N; ++i) minCuts[i] = i-1;\\n                \\n                for(j=1; j<N; ++j)\\n                {\\n                    for(i=j; i>=0; --i)\\n                    {\\n                        if( (s[i] == s[j]) && ( ( j-i < 2 ) || isPalin[i+1][j-1] ) )\\n                        {\\n                            isPalin[i][j] = true;\\n                            minCuts[j+1] = min(minCuts[j+1], 1 + minCuts[i]);    \\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 1388628,
                "title": "python-simple-top-down-dp-clean-concise",
                "content": "**Idea**\\n- Let `isPalindrome(l, r)` be True if string `s[l...r]` is palindrome else False.\\n- Let `dp(i)` denote the minimum number of palindrome substrings of string `s[i..n-1]`.\\n- The answer is `dp(0) - 1` which is number minimum cuts need to be made on string `s[0..n-1]`.\\n```python\\nclass Solution:\\n    def minCut(self, s: str) -> int:\\n        n = len(s)\\n        \\n        @lru_cache(None)\\n        def isPalindrome(l, r):  # l, r inclusive\\n            if l >= r: return True\\n            if s[l] != s[r]: return False\\n            return isPalindrome(l+1, r-1)\\n        \\n        @lru_cache(None)\\n        def dp(i):  # s[i..n-1]\\n            if i == n:\\n                return 0\\n            ans = math.inf\\n            for j in range(i, n):\\n                if (isPalindrome(i, j)):\\n                    ans = min(ans, dp(j+1) + 1)\\n            return ans\\n        \\n        return dp(0) - 1\\n```\\n**Complexity**\\n- Time: `O(N^2)`\\n\\t- Time complexity for `isPalindrome(l, r)` is `O(N^2)`\\n\\t- Time complexity for `dp(i)` is `O(N^2)`\\n\\t- So total time complexity is `O(N^2)`.\\n- Space: `O(N^2)`\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minCut(self, s: str) -> int:\\n        n = len(s)\\n        \\n        @lru_cache(None)\\n        def isPalindrome(l, r):  # l, r inclusive\\n            if l >= r: return True\\n            if s[l] != s[r]: return False\\n            return isPalindrome(l+1, r-1)\\n        \\n        @lru_cache(None)\\n        def dp(i):  # s[i..n-1]\\n            if i == n:\\n                return 0\\n            ans = math.inf\\n            for j in range(i, n):\\n                if (isPalindrome(i, j)):\\n                    ans = min(ans, dp(j+1) + 1)\\n            return ans\\n        \\n        return dp(0) - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 590653,
                "title": "from-brute-force-to-top-down-dp",
                "content": "## Brute Force\\nWe might try all the substring combinations of the given string.\\nTo achive this, we might start processing from the beginning of the string and keep adding one character at a time.\\nIf we get a palindrome, we take it as one cut and recursively process the remaining.\\n```\\nclass Solution {\\n    public int minCut(String s) {\\n        return minCutFrom(s, 0, s.length() - 1);\\n    }\\n    \\n    private int minCutFrom(String s, int start, int end) {\\n        if (start == end || isPalindrome(s, start, end)) {\\n            return 0;\\n        }\\n        int minCut = s.length() - 1;\\n        for (int i = start; i <= end; i++) {\\n            if (isPalindrome(s, start, i)) {\\n                minCut = Math.min(minCut, 1 + minCutFrom(s, i + 1, end));\\n            }\\n        }\\n        return minCut;\\n    }\\n    \\n    private boolean isPalindrome(String s, int x, int y) {\\n        while (x < y) {\\n            if (s.charAt(x++) != s.charAt(y--))\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n## Top-down DP\\nWe might memoize both functions minCut() and isPalindrome().\\nTwo indexes are changing in both functions; therefore, we might build a two-dimensional array for each.\\n```\\nclass Solution {\\n    private Integer dp[][];\\n    private Boolean dpIsPalindrome[][];\\n    public int minCut(String s) {\\n        dp = new Integer[s.length()][s.length()];\\n        dpIsPalindrome = new Boolean[s.length()][s.length()];\\n        return minCutFrom(s, 0, s.length() - 1);\\n    }\\n    \\n    private int minCutFrom(String s, int start, int end) {\\n        if (start == end || isPalindrome(s, start, end)) {\\n            return 0;\\n        }\\n        \\n        if (dp[start][end] != null)\\n            return dp[start][end];\\n        \\n        int minCut = s.length() - 1;\\n        for (int i = start; i <= end; i++) {\\n            if (isPalindrome(s, start, i)) {\\n                minCut = Math.min(minCut, 1 + minCutFrom(s, i + 1, end));\\n            }\\n        }\\n        return dp[start][end] = minCut;\\n    }\\n    \\n    private boolean isPalindrome(String s, int start, int end) {\\n        if (start >= end)\\n            return true;\\n        \\n        if (dpIsPalindrome[start][end] != null)\\n            return dpIsPalindrome[start][end];\\n        \\n        return dpIsPalindrome[start][end] = (s.charAt(start) == s.charAt(end))\\n            && isPalindrome(s, start + 1, end - 1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minCut(String s) {\\n        return minCutFrom(s, 0, s.length() - 1);\\n    }\\n    \\n    private int minCutFrom(String s, int start, int end) {\\n        if (start == end || isPalindrome(s, start, end)) {\\n            return 0;\\n        }\\n        int minCut = s.length() - 1;\\n        for (int i = start; i <= end; i++) {\\n            if (isPalindrome(s, start, i)) {\\n                minCut = Math.min(minCut, 1 + minCutFrom(s, i + 1, end));\\n            }\\n        }\\n        return minCut;\\n    }\\n    \\n    private boolean isPalindrome(String s, int x, int y) {\\n        while (x < y) {\\n            if (s.charAt(x++) != s.charAt(y--))\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private Integer dp[][];\\n    private Boolean dpIsPalindrome[][];\\n    public int minCut(String s) {\\n        dp = new Integer[s.length()][s.length()];\\n        dpIsPalindrome = new Boolean[s.length()][s.length()];\\n        return minCutFrom(s, 0, s.length() - 1);\\n    }\\n    \\n    private int minCutFrom(String s, int start, int end) {\\n        if (start == end || isPalindrome(s, start, end)) {\\n            return 0;\\n        }\\n        \\n        if (dp[start][end] != null)\\n            return dp[start][end];\\n        \\n        int minCut = s.length() - 1;\\n        for (int i = start; i <= end; i++) {\\n            if (isPalindrome(s, start, i)) {\\n                minCut = Math.min(minCut, 1 + minCutFrom(s, i + 1, end));\\n            }\\n        }\\n        return dp[start][end] = minCut;\\n    }\\n    \\n    private boolean isPalindrome(String s, int start, int end) {\\n        if (start >= end)\\n            return true;\\n        \\n        if (dpIsPalindrome[start][end] != null)\\n            return dpIsPalindrome[start][end];\\n        \\n        return dpIsPalindrome[start][end] = (s.charAt(start) == s.charAt(end))\\n            && isPalindrome(s, start + 1, end - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42205,
                "title": "56-ms-python-with-explanation",
                "content": "Algorithm (460 ms) credits go to:\\n[https://leetcode.com/discuss/9476/solution-does-not-need-table-palindrome-right-uses-only-space][1]\\n\\nThe main algorithm idea is if s[i,j] is a palindrome, then the minCut(s[:j]) is **at most** minCut(s[:i-1])+1. This literally needs to find out all possible palindromes in the list. The above post provides an efficient search algorithm. O(n) space and O(n^2) time complexity.\\n\\nFurther acceleration (460 ms -> 56 ms) credits go to:\\n[https://leetcode.com/discuss/43950/python-100ms-extra-dealing-super-cases-reduces-576ms-100ms][2]\\n\\nThe main idea for acceleration is to quickly check and exclude a few long palindrome tests..\\n\\n    def minCut(self, s):\\n        # acceleration\\n        if s == s[::-1]: return 0\\n        for i in range(1, len(s)):\\n            if s[:i] == s[:i][::-1] and s[i:] == s[i:][::-1]:\\n                return 1\\n        # algorithm\\n        cut = [x for x in range(-1,len(s))]  # cut numbers in worst case (no palindrome)\\n        for i in range(len(s)):\\n            r1, r2 = 0, 0\\n            # use i as origin, and gradually enlarge radius if a palindrome exists\\n            # odd palindrome\\n            while i-r1 >= 0 and i+r1 < len(s) and s[i-r1] == s[i+r1]:\\n                cut[i+r1+1] = min(cut[i+r1+1], cut[i-r1]+1)\\n                r1 += 1\\n            # even palindrome\\n            while i-r2 >= 0 and i+r2+1 < len(s) and s[i-r2] == s[i+r2+1]:\\n                cut[i+r2+2] = min(cut[i+r2+2], cut[i-r2]+1)\\n                r2 += 1\\n        return cut[-1]\\n\\nThe following code simply implements the algorithm without any optimization (1800 ms), and should be easier to understand. O(n) space and O(n^3) time complexity.\\n\\n    def minCut(self, s):\\n        cut = [x for x in range(-1,len(s))]\\n        for i in range(0,len(s)):\\n            for j in range(i,len(s)):\\n                if s[i:j] == s[j:i:-1]:\\n                    cut[j+1] = min(cut[j+1],cut[i]+1)\\n        return cut[-1]\\n\\n\\n  [1]: https://leetcode.com/discuss/9476/solution-does-not-need-table-palindrome-right-uses-only-space\\n  [2]: https://leetcode.com/discuss/43950/python-100ms-extra-dealing-super-cases-reduces-576ms-100ms",
                "solutionTags": [
                    "Python"
                ],
                "code": "Algorithm (460 ms) credits go to:\\n[https://leetcode.com/discuss/9476/solution-does-not-need-table-palindrome-right-uses-only-space][1]\\n\\nThe main algorithm idea is if s[i,j] is a palindrome, then the minCut(s[:j]) is **at most** minCut(s[:i-1])+1. This literally needs to find out all possible palindromes in the list. The above post provides an efficient search algorithm. O(n) space and O(n^2) time complexity.\\n\\nFurther acceleration (460 ms -> 56 ms) credits go to:\\n[https://leetcode.com/discuss/43950/python-100ms-extra-dealing-super-cases-reduces-576ms-100ms][2]\\n\\nThe main idea for acceleration is to quickly check and exclude a few long palindrome tests..\\n\\n    def minCut(self, s):\\n        # acceleration\\n        if s == s[::-1]: return 0\\n        for i in range(1, len(s)):\\n            if s[:i] == s[:i][::-1] and s[i:] == s[i:][::-1]:\\n                return 1\\n        # algorithm\\n        cut = [x for x in range(-1,len(s))]  # cut numbers in worst case (no palindrome)\\n        for i in range(len(s)):\\n            r1, r2 = 0, 0\\n            # use i as origin, and gradually enlarge radius if a palindrome exists\\n            # odd palindrome\\n            while i-r1 >= 0 and i+r1 < len(s) and s[i-r1] == s[i+r1]:\\n                cut[i+r1+1] = min(cut[i+r1+1], cut[i-r1]+1)\\n                r1 += 1\\n            # even palindrome\\n            while i-r2 >= 0 and i+r2+1 < len(s) and s[i-r2] == s[i+r2+1]:\\n                cut[i+r2+2] = min(cut[i+r2+2], cut[i-r2]+1)\\n                r2 += 1\\n        return cut[-1]\\n\\nThe following code simply implements the algorithm without any optimization (1800 ms), and should be easier to understand. O(n) space and O(n^3) time complexity.\\n\\n    def minCut(self, s):\\n        cut = [x for x in range(-1,len(s))]\\n        for i in range(0,len(s)):\\n            for j in range(i,len(s)):\\n                if s[i:j] == s[j:i:-1]:\\n                    cut[j+1] = min(cut[j+1],cut[i]+1)\\n        return cut[-1]\\n\\n\\n  [1]: https://leetcode.com/discuss/9476/solution-does-not-need-table-palindrome-right-uses-only-space\\n  [2]: https://leetcode.com/discuss/43950/python-100ms-extra-dealing-super-cases-reduces-576ms-100ms",
                "codeTag": "Python3"
            },
            {
                "id": 1267844,
                "title": "java-recursion-memoization-optimized-matrix-chain-multiplication-approach-with-code-mcm",
                "content": "This question can be solved using **Matrix Chain Multiplication approach** where we partition the array or string into two substrings (like DnC) and calculate answer based on the returned values. But it will give  **TLE**. To optimize it we will try to avoid some **unnecessary calls** by adding a check. The code is given below. \\n\"\"\"\\n//code\\nclass Solution {\\n    Integer[][] dp;\\n    \\n    \\n    //Function to check if the string is Palindrome\\n    boolean isPalindrome(String str, int start, int end){\\n        while(start<end){\\n            if(str.charAt(start)!=str.charAt(end)){\\n                return false;\\n            }\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n    \\n    \\n    int solve(String str, int i, int j){\\n        //Base Cases\\n        if(i>=j){\\n            return 0;\\n        }\\n        if(dp[i][j]!=null){\\n            return dp[i][j];\\n        }\\n        \\n        \\n        /*If the current string is palindrome then we dont need to break it into \\n\\t\\tfurther sub problems as we want to minimize the cuts.*/\\n        if(isPalindrome(str, i, j)){\\n            dp[i][j]=0;\\n            return 0;\\n        }\\n        \\n        \\n        int min = Integer.MAX_VALUE;\\n        //Trying Different possible cuts between i and j\\n        for(int k = i; k<=j;k++){\\n            \\n            /*An Optimization: We will make the partition only if the string till the partition \\n\\t\\t\\t(till Kth position) is a valid palindrome. Because the question states that all \\n\\t\\t\\tpartition must be a valid palindrome. If we dont check this, we will have to \\n\\t\\t\\tperform recursion on the left subproblem too (solve(str, i, k)) and\\twe will waste \\n\\t\\t\\ta lot of time on subproblems that is not required. Without this the code will give\\n\\t\\t\\tcorrect answer but TLE on big test cases. */\\n            if(isPalindrome(str, i, k)){\\n                int partitions = 1+solve(str, k+1, j);\\n                min = Math.min(min, partitions);                \\n            }\\n            \\n            \\n        }\\n        \\n        //Store answer in the memo table\\n        dp[i][j]=min;\\n        return dp[i][j];\\n    }\\n\\n    \\n    \\n    public int minCut(String s) {\\n        dp = new Integer[s.length()][s.length()];\\n        return solve(s, 0, s.length()-1);\\n    }\\n}\\n\\n\"\"\"",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n    Integer[][] dp;\\n    \\n    \\n    //Function to check if the string is Palindrome\\n    boolean isPalindrome(String str, int start, int end){\\n        while(start<end){\\n            if(str.charAt(start)!=str.charAt(end)){\\n                return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 42257,
                "title": "solved-by-shortest-path-algorithm-clear-and-straightforward-o-n-2",
                "content": "1) Build the directed acyclic graph: if substring s[i, .., j] is a palindrome, then there is an edge from i to j+1.\\n2) Find the shortest path d from 0 to n. Then d - 1 is the mincut.\\n\\n    class Solution {\\n     public:\\n      int minCut(string s) {\\n        int n = s.size();\\n        if (n <= 0) return 0;\\n    \\n        vector<vector<bool> > lut(n, vector<bool>(n, true));\\n        vector<vector<int> > adjList(n+1, vector<int>());\\n    \\n        // build the palindrome look up table, O(n^2)\\n        for (int k = 1; k <= n-1; ++k) {\\n          int i = 0, j = k;\\n          while (j < n) {\\n            lut[i][j] = (s[i] == s[j] && lut[i+1][j-1]);\\n            ++i;\\n            ++j;\\n          }\\n        }\\n    \\n        // build the graph, O(n^2);\\n        for (int i = 0; i < n; ++i) {\\n          for (int j = i; j < n; ++j) {\\n            if (lut[i][j] == true) {\\n              adjList[i].push_back(j+1);\\n            }\\n          }\\n        }\\n    \\n        // Use bfs to find shortest path from 0 to n, O(|E|)\\n        // |E| is the number of edges, at most O(n^2)\\n        vector<int> dist(n+1, -1);\\n        queue<int> q;\\n    \\n        dist[0] = 0;\\n        q.push(0);\\n    \\n        while (!q.empty()) {\\n          int u = q.front();\\n          q.pop();\\n    \\n          if (u == n) break;\\n    \\n          vector<int>& neighbors = adjList[u];\\n\\n          // Greedy strategy, in reversed order so that furthest nodes are explored first.\\n          for (auto it = neighbors.rbegin(); it != neighbors.rend(); ++it) {\\n            int v = *it;\\n            if (dist[v] == -1) {\\n              q.push(v);\\n              dist[v] = dist[u] + 1;\\n            }\\n          }\\n        }\\n    \\n        return dist[n] - 1;\\n      }\\n    \\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n     public:\\n      int minCut(string s) {\\n        int n = s.size();\\n        if (n <= 0) return 0;\\n    \\n        vector<vector<bool> > lut(n, vector<bool>(n, true));\\n        vector<vector<int> > adjList(n+1, vector<int>());\\n    \\n        // build the palindrome look up table, O(n^2)\\n        for (int k = 1; k <= n-1; ++k) {\\n          int i = 0, j = k;\\n          while (j < n) {\\n            lut[i][j] = (s[i] == s[j] && lut[i+1][j-1]);\\n            ++i;\\n            ++j;\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 42277,
                "title": "dp-solution-some-thoughts",
                "content": "Some thoughts:\\n\\n1. return the mininum cut of the partition s => optimization => DP\\n2. try to divide & conqure => \\n\\n public int minCutRecur(String s){\\n        int n = s.length;\\n        \\n        //base case\\n        if(s < 2 || isPalindr(s)) return 0;\\n        int min = n - 1;\\n        for(int i = 1; i <= n - 1; i++){\\n            if(isPalindr(s)){\\n                min = Math.min(min, 1 + minCutRecur(s.substring(i)));\\n            }\\n        }\\n        \\n        return min;\\n }\\n\\nHowever, sub problem overlapped (are not independent with each other). \\n\\n3. Use DP to build the solution from bottom up.\\n\\n    public int minCut(String s) {\\n            int n = s.length(); \\n            \\n            boolean[][] isPalindr = new boolean[n + 1][n + 1]; //isPalindr[i][j] = true means s[i:j) is a valid palindrome\\n            int[] dp = new int[n + 1]; //dp[i] means the minCut for s[0:i) to be partitioned \\n    \\n            for(int i = 0; i <= n; i++) dp[i] = i - 1;//initialize the value for each dp state.\\n            \\n            for(int i = 2; i <= n; i++){\\n                for(int j = i - 1; j >= 0; j--){\\n                    //if(isPalindr[j][i]){\\n                    if(s.charAt(i - 1) == s.charAt(j) && (i - 1 - j < 2 || isPalindr[j + 1][i - 1])){\\n                        isPalindr[j][i] = true;\\n                        dp[i] = Math.min(dp[i], dp[j] + 1);\\n                    }\\n                }\\n            }\\n            \\n            return dp[n];\\n    }\\n\\nSeveral optimizations include: \\n\\n 1. No need to check if a string is a palindrome or not inside the loop by adjusting the order of getting of solution of the sub problems. \\n 2. assign dp[0] to be -1 so that when s[0:i) is a palindrome by itself, dp[i] is 0. This is for the consistency of the code.\\n\\nThe time complexity and the space complexity are both O(n ^ 2).",
                "solutionTags": [],
                "code": "Some thoughts:\\n\\n1. return the mininum cut of the partition s => optimization => DP\\n2. try to divide & conqure => \\n\\n public int minCutRecur(String s){\\n        int n = s.length;\\n        \\n        //base case\\n        if(s < 2 || isPalindr(s)) return 0;\\n        int min = n - 1;\\n        for(int i = 1; i <= n - 1; i++){\\n            if(isPalindr(s)){\\n                min = Math.min(min, 1 + minCutRecur(s.substring(i)));\\n            }\\n        }\\n        \\n        return min;\\n }\\n\\nHowever, sub problem overlapped (are not independent with each other). \\n\\n3. Use DP to build the solution from bottom up.\\n\\n    public int minCut(String s) {\\n            int n = s.length(); \\n            \\n            boolean[][] isPalindr = new boolean[n + 1][n + 1]; //isPalindr[i][j] = true means s[i:j) is a valid palindrome\\n            int[] dp = new int[n + 1]; //dp[i] means the minCut for s[0:i) to be partitioned \\n    \\n            for(int i = 0; i <= n; i++) dp[i] = i - 1;//initialize the value for each dp state.\\n            \\n            for(int i = 2; i <= n; i++){\\n                for(int j = i - 1; j >= 0; j--){\\n                    //if(isPalindr[j][i]){\\n                    if(s.charAt(i - 1) == s.charAt(j) && (i - 1 - j < 2 || isPalindr[j + 1][i - 1])){\\n                        isPalindr[j][i] = true;\\n                        dp[i] = Math.min(dp[i], dp[j] + 1);\\n                    }\\n                }\\n            }\\n            \\n            return dp[n];\\n    }\\n\\nSeveral optimizations include: \\n\\n 1. No need to check if a string is a palindrome or not inside the loop by adjusting the order of getting of solution of the sub problems. \\n 2. assign dp[0] to be -1 so that when s[0:i) is a palindrome by itself, dp[i] is 0. This is for the consistency of the code.\\n\\nThe time complexity and the space complexity are both O(n ^ 2).",
                "codeTag": "Unknown"
            },
            {
                "id": 42214,
                "title": "java-o-n-2-dp-solution",
                "content": "    public class Solution {\\n      \\n      public int minCut(String s) {\\n        if (s == null || s.length() == 0) {\\n          return 0;\\n        }\\n        \\n        int n = s.length();\\n        \\n        // build the dp matrix to hold the palindrome information\\n        // dp[i][j] represents whether s[i] to s[j] can form a palindrome\\n        boolean[][] dp = buildMatrix(s, n);\\n        \\n        // res[i] represents the minimum cut needed\\n        // from s[0] to s[i]\\n        int[] res = new int[n];\\n        \\n        for (int j = 0; j < n; j++) {\\n          // by default we need j cut from s[0] to s[j]\\n          int cut = j;\\n          \\n          for (int i = 0; i <= j; i++) {\\n            if (dp[i][j]) {\\n              // s[i] to s[j] is a palindrome\\n              // try to update the cut with res[i - 1]\\n              cut = Math.min(cut, i == 0 ? 0 : res[i - 1] + 1);\\n            }\\n          }\\n          \\n          res[j] = cut;\\n        }\\n        \\n        return res[n - 1];\\n      }\\n      \\n      boolean[][] buildMatrix(String s, int n) {\\n        boolean[][] dp = new boolean[n][n];\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n          for (int j = i; j < n; j++) {\\n            if (s.charAt(i) == s.charAt(j) && (j - i <= 2 || dp[i + 1][j - 1])) {\\n              dp[i][j] = true;\\n            }\\n          }\\n        }\\n        \\n        return dp;\\n      }\\n    \\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n      \\n      public int minCut(String s) {\\n        if (s == null || s.length() == 0) {\\n          return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1388471,
                "title": "python-dp-solution-explained",
                "content": "Let us do the following steps:\\n\\n1. Generate all possible palindromes, we can do it in `O(n^2)` time: consider all `2n-1` possible middles and then extend around them until we can. Dictionary `d[i]` will keep all palindromes which start with place `i`.\\n2. `dp(i)` is number of minimum palindromes for string `s[:i]`. Then to calculate `dp(i)` we need to calculate `dp(k-1) + 1` for all `k <= i and such that `i in d[k]`, this means that `s[k:i+1]` is palindrome; then we need to choose the minimum among all these candidates.\\n\\n#### Complexity\\nTime complexity is `O(n^2)` to generate all palindromes and `O(n^2)` to evaluate all `dp` values, so overall time complexity is `O(n^2)`. Space complexity is `O(n^2)` as well.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def minCut(self, s):\\n        d, n = defaultdict(set), len(s)\\n        \\n        def helper(i, j):\\n            while i >= 0 and j < n and s[i] == s[j]:\\n                d[i].add(j)\\n                i, j = i - 1, j + 1\\n        \\n        for k in range(n):\\n            helper(k, k)\\n            helper(k, k + 1)\\n\\n        @lru_cache(None)\\n        def dp(i):\\n            if i == -1: return -1\\n            return min([dp(k-1) + 1 for k in range(0, i+1) if i in d[k]])\\n        \\n        return dp(n-1)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def minCut(self, s):\\n        d, n = defaultdict(set), len(s)\\n        \\n        def helper(i, j):\\n            while i >= 0 and j < n and s[i] == s[j]:\\n                d[i].add(j)\\n                i, j = i - 1, j + 1\\n        \\n        for k in range(n):\\n            helper(k, k)\\n            helper(k, k + 1)\\n\\n        @lru_cache(None)\\n        def dp(i):\\n            if i == -1: return -1\\n            return min([dp(k-1) + 1 for k in range(0, i+1) if i in d[k]])\\n        \\n        return dp(n-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 211940,
                "title": "python-7-lines-with-some-explanations-and-thoughts",
                "content": "```\\nclass Solution(object):\\n    def minCut(self, s):\\n        cut = [-1] + [x for x in range(len(s))]\\n        \\n        for i in range(2*len(s)-1):\\n            left = i/2; right = i - left\\n            while right < len(s) and left >= 0 and s[right] == s[left]:\\n                cut[right+1] = min(cut[right+1], cut[left]+1)\\n                right += 1; left -= 1\\n        \\n        return cut[-1]\\n```\\n\\nHere is what I learned from this question. \\n**1.  the minimum cut mincut[i] equals mincut[j] + 1 with string[i:j] as palindrome.**  \\nTherefore, the basic skelekon code somehow is the following\\n\\n```\\nif isPalindrome(s[left:right]):\\n\\tminicut[right+1] = min(minicut[right+1] , minicut[left] + 1)\\n```\\n\\n**2. implement isPalindrome has several ways, leading the different space complexity and time complexity\\nI. the most basic way is s == s[::-1]**\\nthis implementation **require O(n), so it needs total O(n^3)**\\n\\nThe codes are the following \\n```\\n        cut = [-1] + [x for x in range(len(s))]\\n        \\n        for i in range(len(s)+1):\\n            for j in range(i):\\n                if s[j:i] == s[j:i][::-1]: \\n                    cut[i] = min(cut[i],cut[j]+1)\\n        \\n        return cut[-1]\\n```\\n\\nII. **Second way uses a DP table to record palindrome**. \\n\\nBasic update function for DP table is \\n```\\ndp[start][end] = dp[start+1][end-1] and s[start] == s[end]\\n```\\n\\nThe codes are \\n\\n```\\nclass Solution(object):\\n    def minCut(self, s):\\n        \\n        ## at cut[i] indicates the number of minimum cuts of s[i:j)\\n        cut = [-1] + [x for x in range(len(s))]\\n        \\n        dp = [[False] * (len(s)+1) for _ in range(len(s)+1)]\\n        \\n        \\n        for length in range(len(s)):\\n            for start in range(len(s) - length):\\n                end = start + length\\n                if length == 0: dp[start][end] = True\\n                elif length == 1: dp[start][end] = s[start] == s[end]\\n                else: dp[start][end] = dp[start+1][end-1] and s[start] == s[end]\\n        \\n        for i in range(len(s)+1):\\n            for j in range(i):\\n                if dp[j][i-1]: \\n                    cut[i] = min(cut[i],cut[j]+1)\\n        return cut[-1]\\n```\\n\\n**WIth O(n^2) space complexity, the time complexity reduced to O(n^2)**\\n\\nIII. The last way to implement palindrome uses **expand centers** method from 005. Longest Palindromic Substring.  This ways do not require additional space  to store palindrome. \\n\\n```\\nclass Solution(object):\\n    def minCut(self, s):\\n        cut = [-1] + [x for x in range(len(s))]\\n        \\n        for i in range(2*len(s)-1):\\n            left = i/2; right = i - left\\n            while right < len(s) and left >= 0 and s[right] == s[left]:\\n                cut[right+1] = min(cut[right+1], cut[left]+1)\\n                right += 1; left -= 1\\n        \\n        return cut[-1]\\n```\\n\\n**So the space complexity is O(n), time complexity is still O(n^2)**\\n\\n(I\\'m a beginner in algorithm, therefore if there is anything wrong in this post, welcome to point out.)\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minCut(self, s):\\n        cut = [-1] + [x for x in range(len(s))]\\n        \\n        for i in range(2*len(s)-1):\\n            left = i/2; right = i - left\\n            while right < len(s) and left >= 0 and s[right] == s[left]:\\n                cut[right+1] = min(cut[right+1], cut[left]+1)\\n                right += 1; left -= 1\\n        \\n        return cut[-1]\\n```\n```\\nif isPalindrome(s[left:right]):\\n\\tminicut[right+1] = min(minicut[right+1] , minicut[left] + 1)\\n```\n```\\n        cut = [-1] + [x for x in range(len(s))]\\n        \\n        for i in range(len(s)+1):\\n            for j in range(i):\\n                if s[j:i] == s[j:i][::-1]: \\n                    cut[i] = min(cut[i],cut[j]+1)\\n        \\n        return cut[-1]\\n```\n```\\ndp[start][end] = dp[start+1][end-1] and s[start] == s[end]\\n```\n```\\nclass Solution(object):\\n    def minCut(self, s):\\n        \\n        ## at cut[i] indicates the number of minimum cuts of s[i:j)\\n        cut = [-1] + [x for x in range(len(s))]\\n        \\n        dp = [[False] * (len(s)+1) for _ in range(len(s)+1)]\\n        \\n        \\n        for length in range(len(s)):\\n            for start in range(len(s) - length):\\n                end = start + length\\n                if length == 0: dp[start][end] = True\\n                elif length == 1: dp[start][end] = s[start] == s[end]\\n                else: dp[start][end] = dp[start+1][end-1] and s[start] == s[end]\\n        \\n        for i in range(len(s)+1):\\n            for j in range(i):\\n                if dp[j][i-1]: \\n                    cut[i] = min(cut[i],cut[j]+1)\\n        return cut[-1]\\n```\n```\\nclass Solution(object):\\n    def minCut(self, s):\\n        cut = [-1] + [x for x in range(len(s))]\\n        \\n        for i in range(2*len(s)-1):\\n            left = i/2; right = i - left\\n            while right < len(s) and left >= 0 and s[right] == s[left]:\\n                cut[right+1] = min(cut[right+1], cut[left]+1)\\n                right += 1; left -= 1\\n        \\n        return cut[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 185601,
                "title": "c-o-n-space-detailed-explanation",
                "content": "A typical dp problem:\\nFor each position ```i```, incrementally find palindrome of length ```1,3,5,...```, then, of length ```2,4,6```. Suppose the **start index** of the found palindrome is ```idx_s``` and the **end index** of the palindrome is ```idx_e```, update the dp table as the follow formula:\\n```dp[idx_e] = min(dp[idx_e], dp[idx_s-1] + 1)```\\n\\nWait a min, how about ```idx_s``` equal to 0? Seems like we should and some kind of special case test. Actually, this can be avoided by a **sentinel** trick. Refer to code for details.\\n```\\nclass Solution {\\npublic:\\n    int minCut(string s) {\\n        int n = s.size();\\n        vector<int> dp(n+1, INT_MAX);\\n        dp[0] = -1;       //act as a sentinel\\n        for(int i = 0; i < n; i++){\\n\\t//palindrome of length 1,3,5...\\n            for(int len = 0; i-len >= 0 && i+len < n && s[i-len] == s[i+len]; len++)\\n                dp[i+len+1] = min(dp[i+len+1], dp[i-len]+1);\\n\\t//palindrome of lenght 2,4,6...\\n            for(int len = 0; i-len >= 0 && i+len+1 < n && s[i-len] == s[i+len+1]; len++)\\n                dp[i+len+2] = min(dp[i+len+2], dp[i-len]+1);\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```i```\n```1,3,5,...```\n```2,4,6```\n```idx_s```\n```idx_e```\n```dp[idx_e] = min(dp[idx_e], dp[idx_s-1] + 1)```\n```idx_s```\n```\\nclass Solution {\\npublic:\\n    int minCut(string s) {\\n        int n = s.size();\\n        vector<int> dp(n+1, INT_MAX);\\n        dp[0] = -1;       //act as a sentinel\\n        for(int i = 0; i < n; i++){\\n\\t//palindrome of length 1,3,5...\\n            for(int len = 0; i-len >= 0 && i+len < n && s[i-len] == s[i+len]; len++)\\n                dp[i+len+1] = min(dp[i+len+1], dp[i-len]+1);\\n\\t//palindrome of lenght 2,4,6...\\n            for(int len = 0; i-len >= 0 && i+len+1 < n && s[i-len] == s[i+len+1]; len++)\\n                dp[i+len+2] = min(dp[i+len+2], dp[i-len]+1);\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1296775,
                "title": "using-memoization-twice-c-dp-memoization",
                "content": "I tried memoizing only the solve function below but it gives TLE for long inputs \\nTry to memoize the isPalindrome function also so that you dont calculate again and again if the same substring is palindrome or not;\\n\\n\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> dp;\\n\\t\\tvector<vector<int>> dp1;\\n\\t\\tbool isPalindrome(string& s, int i, int j) {\\n\\t\\t\\tif (i >= j) return true;\\n\\t\\t\\tif (dp1[i][j] != -1) return dp1[i][j];\\n\\t\\t\\tif (s[i] == s[j]) return dp1[i][j] = isPalindrome(s, i + 1, j - 1);\\n\\t\\t\\treturn dp1[i][j] = false;\\n\\t\\t}\\n\\n\\t\\tint solve(string s, int l, int r){\\n\\t\\t\\tif(l>=r) return dp[l][r] = 0;\\n\\t\\t\\tif(dp[l][r]!=-1) return dp[l][r];\\n\\t\\t\\tif(isPalindrome(s,l,r)) return dp[l][r] = 0;\\n\\t\\t\\tint ans = INT_MAX;\\n\\t\\t\\tfor(int i=l;i<=r-1;i++){\\n\\t\\t\\t\\tif(isPalindrome(s,l,i)) ans = min(ans, 1+solve(s,i+1,r));\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[l][r] = ans;\\n\\t\\t}\\n\\n\\t\\tint minCut(string s) {\\n\\t\\t\\tdp.resize(s.size(),vector<int> (s.size(),-1));\\n\\t\\t\\tdp1.resize(s.size(),vector<int> (s.size(),-1));\\n\\t\\t\\treturn solve(s,0,s.size()-1);\\n\\t\\t}\\n\\t};\\n\\t\\nThank you.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> dp;\\n\\t\\tvector<vector<int>> dp1;\\n\\t\\tbool isPalindrome(string& s, int i, int j) {\\n\\t\\t\\tif (i >= j) return true;\\n\\t\\t\\tif (dp1[i][j] != -1) return dp1[i][j];\\n\\t\\t\\tif (s[i] == s[j]) return dp1[i][j] = isPalindrome(s, i + 1, j - 1);\\n\\t\\t\\treturn dp1[i][j] = false;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 42262,
                "title": "python-100ms-extra-dealing-with-super-long-cases-reduces-time-cost-from-576ms-to-100ms",
                "content": "The main method that uses double dp is nothing novel.\\nHowever, if I add a few more lines at the beginning to avoid the long cases in which mincut = 0 or mincut = 1, the time cost optimized so dramatically that I got really surprised...\\n\\n    class Solution:\\n        # @param {string} s\\n        # @return {integer}\\n        def minCut(self, s):\\n            if s == s[::-1]: return 0\\n            lens = len(s)\\n            for i in range(1, lens):\\n                if s[:i] == s[:i][::-1] and s[i:] == s[i:][::-1]:\\n                    return 1\\n    \\n            isPal = [[False] * (i + 1) for i in range(lens)]\\n            dp = range(lens) + [-1]\\n            for i in range(lens):\\n                for j in range(i, -1, -1):\\n                    if s[i] == s[j] and (i - j < 2 or isPal[i - 1][j + 1]):\\n                        isPal[i][j] = True\\n                        dp[i] = min(dp[i], dp[j - 1] + 1)\\n            return dp[lens - 1]",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param {string}",
                "codeTag": "Java"
            },
            {
                "id": 1443521,
                "title": "c-memoization-accepted-solution-clean-code",
                "content": "**Approach** : In this question we are trying to find out the minimum cuts needed for a palindrome partitioning of given string.\\n\\nAnd this is an implementation of classic matrix chain multiplication question. Do read article for the same on gfg.\\n\\nPS : Feel free to ask your doubts in comments.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool isPalindrome(string &s, int start, int end) {\\n        \\n        while(start < end) {\\n            \\n            if(s[start] != s[end]) return false;\\n            \\n            start += 1;\\n            end -= 1;\\n            \\n        }\\n        \\n        return true;\\n        \\n    }\\n    \\n    int solve(string &s, int start, int end,vector<vector<int>> &dp) {\\n        \\n        if(dp[start][end] != -1) return dp[start][end];\\n        \\n        if(start >= end) return dp[start][end] = 0 ;\\n        \\n        if(isPalindrome(s,start,end) == true)\\n            return dp[start][end] = 0;\\n        \\n        int ans = INT_MAX;\\n        \\n        for(int ctr = start ; ctr < end ; ctr ++ ) {\\n            \\n            if(isPalindrome(s,start,ctr)==false)\\n                continue;\\n            \\n            int tempAns = solve(s,start,ctr,dp) + solve(s,ctr+1,end,dp) + 1;\\n            \\n            if(tempAns < ans) ans = tempAns;\\n        }\\n        \\n        return dp[start][end] = ans;\\n        \\n    }\\n    \\n    int minCut(string s) {\\n        vector<vector<int>> dp(s.size()+1, vector<int>(s.size()+1,-1));\\n        return solve(s,0,s.length()-1,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isPalindrome(string &s, int start, int end) {\\n        \\n        while(start < end) {\\n            \\n            if(s[start] != s[end]) return false;\\n            \\n            start += 1;\\n            end -= 1;\\n            \\n        }\\n        \\n        return true;\\n        \\n    }\\n    \\n    int solve(string &s, int start, int end,vector<vector<int>> &dp) {\\n        \\n        if(dp[start][end] != -1) return dp[start][end];\\n        \\n        if(start >= end) return dp[start][end] = 0 ;\\n        \\n        if(isPalindrome(s,start,end) == true)\\n            return dp[start][end] = 0;\\n        \\n        int ans = INT_MAX;\\n        \\n        for(int ctr = start ; ctr < end ; ctr ++ ) {\\n            \\n            if(isPalindrome(s,start,ctr)==false)\\n                continue;\\n            \\n            int tempAns = solve(s,start,ctr,dp) + solve(s,ctr+1,end,dp) + 1;\\n            \\n            if(tempAns < ans) ans = tempAns;\\n        }\\n        \\n        return dp[start][end] = ans;\\n        \\n    }\\n    \\n    int minCut(string s) {\\n        vector<vector<int>> dp(s.size()+1, vector<int>(s.size()+1,-1));\\n        return solve(s,0,s.length()-1,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 858207,
                "title": "will-surely-fix-your-tle-python-code-with-memoized-dp-and-three-optimizations",
                "content": "** Total three Optimizations on normal recursive code: **\\n1. 2d DP array for memoization (which is obvious)\\n2. Dictionary to store palindrome check results to avoid rechecks\\n3. Important!  We make recursive calls for the right part of string only when left part is palindrome(TLE FIX - check code below for clarity)\\n\\n\\n```\\nimport sys\\n\\nclass Solution:\\n    def minCut(self, s):\\n        if not s or len(s) <=1:\\n            return 0\\n        \\n        elif self.is_palindrome(s):\\n            return 0\\n        \\n        rows = len(s)\\n        cols = len(s)\\n        \\n        # Optimization 1(Major) aka Memoization of results(Top Down DP)\\n        dp = [[-1]*cols for x in range(rows)] # 2d dp array\\n        \\n        # Optimization 2(Minor) aka Memoization of palindrome check results\\n\\t\\t# This optimization wont solve your TLE error on LC but still is a good optimization\\n        p_cache = {} # dictionary/map\\n        \\n        return self.min_cuts_recursively_mcm(0, len(s)-1, s, dp, p_cache)\\n    \\n    def is_palindrome(self, t):\\n        return t == t[::-1]\\n        \\n    def min_cuts_recursively_mcm(self, i, j, s, dp, p_cache):\\n\\t\\n        # base case\\n        if i >= j:\\n            return 0\\n        \\n        # if computation has already been done\\n        elif dp[i][j] != -1:\\n            return dp[i][j] \\n        \\n        # if the string has already been checked for palindrome in past\\n        elif p_cache.get((i,j)):\\n            return 0 # since, its palindrome, ZERO cuts required\\n        \\n        # if not checked for palindrome, check it\\n        elif self.is_palindrome(s[i:j+1]):\\n            \\n            # store it\\n            p_cache[(i,j)] = True\\n            return 0 # since, its palindrome, ZERO cuts required\\n        \\n        curr_min = sys.maxsize\\n        for k in range(i,j):\\n            \\n            # IMP Optimization 3 (Major) this will solve your TLE on Leetcode or other platform\\n            # Why to check further if the left part of the cut ie. S[i,k+1] is itself NOT a palindrome ??????\\n            # the right part anyhow wont be able to contribute to the answer\\n            if self.is_palindrome(s[i:k+1]): # we only move forward with the cut if the left part is sure shot a palindrome, TLE FIXED\\n                left_result = 0\\n                right_result = self.min_cuts_recursively_mcm(k+1, j, s, dp, p_cache)\\n                curr_min = min(curr_min, (left_result+right_result+1))\\n                dp[i][j] = curr_min\\n        \\n        return curr_min\\n\\t```\\n            \\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nimport sys\\n\\nclass Solution:\\n    def minCut(self, s):\\n        if not s or len(s) <=1:\\n            return 0\\n        \\n        elif self.is_palindrome(s):\\n            return 0\\n        \\n        rows = len(s)\\n        cols = len(s)\\n        \\n        # Optimization 1(Major) aka Memoization of results(Top Down DP)\\n        dp = [[-1]*cols for x in range(rows)] # 2d dp array\\n        \\n        # Optimization 2(Minor) aka Memoization of palindrome check results\\n\\t\\t# This optimization wont solve your TLE error on LC but still is a good optimization\\n        p_cache = {} # dictionary/map\\n        \\n        return self.min_cuts_recursively_mcm(0, len(s)-1, s, dp, p_cache)\\n    \\n    def is_palindrome(self, t):\\n        return t == t[::-1]\\n        \\n    def min_cuts_recursively_mcm(self, i, j, s, dp, p_cache):\\n\\t\\n        # base case\\n        if i >= j:\\n            return 0\\n        \\n        # if computation has already been done\\n        elif dp[i][j] != -1:\\n            return dp[i][j] \\n        \\n        # if the string has already been checked for palindrome in past\\n        elif p_cache.get((i,j)):\\n            return 0 # since, its palindrome, ZERO cuts required\\n        \\n        # if not checked for palindrome, check it\\n        elif self.is_palindrome(s[i:j+1]):\\n            \\n            # store it\\n            p_cache[(i,j)] = True\\n            return 0 # since, its palindrome, ZERO cuts required\\n        \\n        curr_min = sys.maxsize\\n        for k in range(i,j):\\n            \\n            # IMP Optimization 3 (Major) this will solve your TLE on Leetcode or other platform\\n            # Why to check further if the left part of the cut ie. S[i,k+1] is itself NOT a palindrome ??????\\n            # the right part anyhow wont be able to contribute to the answer\\n            if self.is_palindrome(s[i:k+1]): # we only move forward with the cut if the left part is sure shot a palindrome, TLE FIXED\\n                left_result = 0\\n                right_result = self.min_cuts_recursively_mcm(k+1, j, s, dp, p_cache)\\n                curr_min = min(curr_min, (left_result+right_result+1))\\n                dp[i][j] = curr_min\\n        \\n        return curr_min\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 939199,
                "title": "dfs-dp-progression-with-explanation",
                "content": "In this problem, we are tasked to find the minimum number of partitions in order for every segment in `s` to be a palindrone.  Thus, we can look at all combinations of partitions, and return the combination that has the fewest.  DFS is a great tool for this as we can express an instance of the function as the current state, and the recursive calls as actions to future states.  Let\\'s take a look at the DFS tree.\\n![image](https://assets.leetcode.com/users/images/1777dfc0-d8c0-47e3-bbc5-b084e5034369_1605630463.425823.png)\\nWith this visual, we can produce the  following code (`isPalidrone` is defined later near the bottom)\\n```\\ndef dfs(s):\\n\\tif not s or isPalindrone(s):\\n\\t\\treturn 0\\n\\tcuts = float(\"inf\")\\n\\tfor i in range(1, len(s)):\\n\\t\\tcuts = min(cuts, 1 + dfs(s[i:]) + dfs(s[:i]))\\n\\treturn cuts\\nreturn dfs(s)\\n```\\nAs common with DFS problems, we start at the root and traverse to a leaf, acquiring some _cost_ at each node along the way.  In this problem, each partition costs 1, and since we are looking for the minimum amount of partitions, we are looking for the _shortest_ root -> leaf path in the DFS tree.  This solves the problem, but takes far too long and times out on some inputs.  Why is that?  Notice in the DFS tree we see repeated subproblems, such as `bc`, `ab`, and `bb`.  The answer to each of these three subproblems, and in fact any redundant subproblem, will not change regardless of where they are calculated in the tree, and thus we are wasting time recalculating them.  This is where DP comes in.\\n\\nThe DFS approach solves this problem from the top down, meaning it must recurse all the way down to a base case before it has any idea of the cost of a path.  Instead, let\\'s build the solution from the ground (base case) up, storing the solution to subproblems at each step.  Therefore if we see redundant subproblems, we do not have to waste time recalculating them, and instead can simply reference where they are stored.\\n```\\ndef dp(s):\\n\\tA = [[float(\"inf\")] * len(s) for _ in range(len(s))]  \\n\\tfor i in range(len(s)):\\n\\t\\tA[i][i] = 0\\n\\t\\t\\n\\tfor i in range(len(s) - 1, -1, -1):\\n\\t\\tfor j in range(i, len(s)):\\n\\t\\t\\tif isPalindrone(s[i:j + 1]):\\n\\t\\t\\t\\tA[i][j] = 0\\n\\t\\t\\telse:\\n\\t\\t\\t\\tfor k in range(j):\\n\\t\\t\\t\\t\\tA[i][j] = min(A[i][j], 1 + A[i][k] + A[k + 1][j])\\n\\treturn A[0][-1]\\nreturn dp(s)\\n```\\nNotice both the base case and recursion relation are exactly the same as we found in the DFS solution.  However now we only have to reference the previously solved subproblem.  The time complexity of the DP approach is O(n^3) which still isn\\'t that great, and even this approach times out when submitted (TBH I feel like this solution is fine and it gets the DP point across).  We can cut this down to O(n^2) in the following way.\\n```\\ndef dp(s):\\n\\tA = [i for i in range(len(s))] + [-1]\\n\\tfor j in range(len(s)):\\n\\t\\tfor i in range(j, -1, -1):\\n\\t\\t\\tif isPalindrone(s[i:j + 1]):\\n\\t\\t\\t\\tA[j] = min(A[j], A[i - 1] + 1)\\n\\treturn A[-2]\\nreturn dp(s)\\n```\\n\\nP.S. We can utilize a previously solved DP problem to find out whether a certain substring is a palindrone or not.\\n```\\ndef isPalindroneDP(s):\\n\\tB = [[False] * len(s) for _ in range(len(s))]\\n\\tfor i in range(len(s) - 1, -1, -1):\\n\\t\\tfor j in range(i, len(s)):\\n\\t\\t\\tif s[i] == s[j] and ((j - i) < 3 or B[i + 1][j - 1]):\\n\\t\\t\\t\\tB[i][j] = True\\n```\\nThis can even be combined and calculated with the DP approach to save some addition time.",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\ndef dfs(s):\\n\\tif not s or isPalindrone(s):\\n\\t\\treturn 0\\n\\tcuts = float(\"inf\")\\n\\tfor i in range(1, len(s)):\\n\\t\\tcuts = min(cuts, 1 + dfs(s[i:]) + dfs(s[:i]))\\n\\treturn cuts\\nreturn dfs(s)\\n```\n```\\ndef dp(s):\\n\\tA = [[float(\"inf\")] * len(s) for _ in range(len(s))]  \\n\\tfor i in range(len(s)):\\n\\t\\tA[i][i] = 0\\n\\t\\t\\n\\tfor i in range(len(s) - 1, -1, -1):\\n\\t\\tfor j in range(i, len(s)):\\n\\t\\t\\tif isPalindrone(s[i:j + 1]):\\n\\t\\t\\t\\tA[i][j] = 0\\n\\t\\t\\telse:\\n\\t\\t\\t\\tfor k in range(j):\\n\\t\\t\\t\\t\\tA[i][j] = min(A[i][j], 1 + A[i][k] + A[k + 1][j])\\n\\treturn A[0][-1]\\nreturn dp(s)\\n```\n```\\ndef dp(s):\\n\\tA = [i for i in range(len(s))] + [-1]\\n\\tfor j in range(len(s)):\\n\\t\\tfor i in range(j, -1, -1):\\n\\t\\t\\tif isPalindrone(s[i:j + 1]):\\n\\t\\t\\t\\tA[j] = min(A[j], A[i - 1] + 1)\\n\\treturn A[-2]\\nreturn dp(s)\\n```\n```\\ndef isPalindroneDP(s):\\n\\tB = [[False] * len(s) for _ in range(len(s))]\\n\\tfor i in range(len(s) - 1, -1, -1):\\n\\t\\tfor j in range(i, len(s)):\\n\\t\\t\\tif s[i] == s[j] and ((j - i) < 3 or B[i + 1][j - 1]):\\n\\t\\t\\t\\tB[i][j] = True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1388644,
                "title": "c-easiest-solution-with-explanation",
                "content": "class Solution {\\npublic:\\n    \\n    int minCut(string s) {\\n       \\n        int n=s.length();\\n        \\n//First Create a dp to store the truthness of palindrome for every substrings//\\n        \\n        bool dp[n][n];\\n        \\n//Initialize dp with false for precaution//\\n        \\n        memset(dp,false,sizeof(dp));\\n        \\n//Check for every single char as we all know all of those are palindrome (e.g \\'a\\' ,\\'z\\' ,\\'f\\' are palindromes itself);\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            dp[i][i]=true;\\n        }\\n        \\n//Check two consecutive elements whether they are palindrome or not (e.g \"ab\" is not a palindrome but \"aa\" is palindrome)\\n        \\n        \\n        \\n        for(int i=0;i<n-1;i++){\\n            if(s[i]==s[i+1]){\\n                dp[i][i+1]=true;\\n            }\\n        }\\n        \\n// Now traverse for every substring of size>=2 whether they are palindrome or not\\n        \\n        \\n//For this checking we can see that if two end elements of a string is same and intermediate string is palindrome then the whloe string is palindrome alse.\\n        \\n        \\n        for(int i=n-1;i>=0;i--){\\n            for(int j=n-1;j>=0;j--){\\n                \\n                if((j-i)>=2 && s[i]==s[j] && dp[i+1][j-1]==true){\\n                    dp[i][j]=true;\\n                }\\n            }\\n        }\\n        \\n        \\n// Now create a cuts array to find outminimum possible cuts for every substring.\\n        \\n        \\n        int cuts[n];\\n        \\n        for(int i=0;i<n;i++){\\n            \\n//Initialize every element with INT_MAX//\\n            \\n            int temp=INT_MAX;\\n            \\n// If the substring is palindrome from the start then no cuts are required.\\n            \\n            \\n            if(dp[0][i]==true){\\n                cuts[i]=0;\\n            }\\n            \\n            \\n// Else check every substring with same logic and try to figure out the minimum number of cuts which is needed\\n            \\n            \\n            else{\\n                \\n                for(int j=0;j<i;j++){\\n                    \\n                    if(dp[j+1][i]==true && temp>cuts[j]+1){\\n                        temp=cuts[j]+1;\\n                    }\\n                }\\n                \\n                cuts[i]=temp;\\n            }\\n        }\\n        \\n        \\n        //Return the result.\\n        \\n        return cuts[n-1];\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int minCut(string s) {\\n       \\n        int n=s.length();\\n        \\n//First Create a dp to store the truthness of palindrome for every substrings//\\n        \\n        bool dp[n][n];\\n        \\n//Initialize dp with false for precaution//\\n        \\n        memset(dp,false,sizeof(dp));\\n        \\n//Check for every single char as we all know all of those are palindrome (e.g \\'a\\' ,\\'z\\' ,\\'f\\' are palindromes itself);\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            dp[i][i]=true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1239122,
                "title": "c-dp-8ms-short-and-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCut(string s) {\\n        \\n        int size = s.size();\\n        vector<int> dp(size+1, 0);\\n\\n        for(int i = 0; i <= size; i++) \\n            dp[i] = i-1;\\n \\n        for(int i = 0; i < size; i++) {\\n            \\n            // odd length palindrome\\n            for(int j = 0; i-j >= 0 && i+j < size && s[i+j] == s[i-j];j++)\\n                dp[i+j+1] = min(dp[i+j+1], dp[i-j]+1);\\n\\n            // even length palindrome\\n            for(int j = 0; i-j-1 >= 0 && i+j < size && s[i+j] == s[i-j-1]; j++)\\n                dp[i+j+1] = min(dp[i+j+1], dp[i-j-1]+1);\\n        }\\n        \\n        return dp[size];\\n    }\\n};\\n\\n/*\\n        \\nThe definition of \\'dp\\' array is the minimum number of cuts of a sub string. More specifically, dp[n] stores the cut number of string s[0, n-1]. \\n  \\nInitialize the \\'dp\\' array: For a string with n characters s[0, n-1], it needs at most n-1 cut. Therefore, the \\'dp\\' array is initialized as dp[i] = i-1\\n        \\n    // The external loop variable \\'i\\' represents the center of the palindrome.\\n    // means i is centre and starts from i-j and ends at i+j odd length\\n    // and i-j and i + j +1 for even length , just check both best will get updated\\n    \\nThe internal loop variable \\'j\\' represents the \\'radius\\' of the palindrome. \\nApparently, j <= i is a must.\\nThis palindrome can then be represented as s[i-j, i+j]. \\nIf this string is indeed a palindrome, then one possible value of dp[i+j] is dp[i-j] + 1, \\nwhere dp[i-j] corresponds to s[0, i-j-1] and 1 correspond to the palindrome s[i-j, i+j];\\n       \\n        \\n*/\\n\\n```\\n\\nlittle slower, this is another approach\\n```\\nclass Solution {\\npublic:\\n    int minCut(string s) {\\n       int n = s.size();\\n        vector<vector<int>> change (n+1,(vector<int>(n+1,0)));  \\n         \\n\\n     for(int i=0;i<n;i++)\\n            change[i][i]=1;                       //length=1 all true a no is a palindrome of itself\\n           \\n    \\n        for (int len = 2; len <= n; ++len) {      \\n            for (int i = 0; i + len <= n; ++i) {\\n                int j = i + len - 1;\\n                \\n                if (len == 2 && s[i] == s[j])       // for 2 len just last and first should be same\\n                    change[i][j] = 1;               // true as it is palindrome\\n                else if(s[i]==s[j] && change[i+1][j-1])  // middle thing should be palindrome and last and first should be same\\n                    change[i][j] = 1;                   // true as it is palindrome\\n                else \\n                    change[i][j] = 0;                   // not for all other case\\n            }\\n            \\n        }\\n  \\n          vector<int> dp1(n,INT_MAX);    \\n          dp1[0] = 0;\\n        \\n          for(int j=1;j<n;j++)\\n            {\\n              if(change[0][j] == 1) \\n                  dp1[j] = 0;\\n              \\n              else{\\n                for(int i=j ;i>=1;i--)\\n                {\\n                    if(change[i][j])\\n                    {\\n                        dp1[j] = min(dp1[j],1+dp1[i-1]);\\n                    }\\n                }\\n              }\\n            }\\n\\n   \\n        return dp1[n-1];\\n\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCut(string s) {\\n        \\n        int size = s.size();\\n        vector<int> dp(size+1, 0);\\n\\n        for(int i = 0; i <= size; i++) \\n            dp[i] = i-1;\\n \\n        for(int i = 0; i < size; i++) {\\n            \\n            // odd length palindrome\\n            for(int j = 0; i-j >= 0 && i+j < size && s[i+j] == s[i-j];j++)\\n                dp[i+j+1] = min(dp[i+j+1], dp[i-j]+1);\\n\\n            // even length palindrome\\n            for(int j = 0; i-j-1 >= 0 && i+j < size && s[i+j] == s[i-j-1]; j++)\\n                dp[i+j+1] = min(dp[i+j+1], dp[i-j-1]+1);\\n        }\\n        \\n        return dp[size];\\n    }\\n};\\n\\n/*\\n        \\nThe definition of \\'dp\\' array is the minimum number of cuts of a sub string. More specifically, dp[n] stores the cut number of string s[0, n-1]. \\n  \\nInitialize the \\'dp\\' array: For a string with n characters s[0, n-1], it needs at most n-1 cut. Therefore, the \\'dp\\' array is initialized as dp[i] = i-1\\n        \\n    // The external loop variable \\'i\\' represents the center of the palindrome.\\n    // means i is centre and starts from i-j and ends at i+j odd length\\n    // and i-j and i + j +1 for even length , just check both best will get updated\\n    \\nThe internal loop variable \\'j\\' represents the \\'radius\\' of the palindrome. \\nApparently, j <= i is a must.\\nThis palindrome can then be represented as s[i-j, i+j]. \\nIf this string is indeed a palindrome, then one possible value of dp[i+j] is dp[i-j] + 1, \\nwhere dp[i-j] corresponds to s[0, i-j-1] and 1 correspond to the palindrome s[i-j, i+j];\\n       \\n        \\n*/\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779792,
                "title": "c-solutions-easy-to-solve",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCut(string s) {\\n        int n = s.size();\\n        vector<int> cut(n+1, 0);  // number of cuts for the first k characters\\n        for (int i = 0; i <= n; i++) cut[i] = i-1;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; i-j >= 0 && i+j < n && s[i-j]==s[i+j] ; j++) // odd length palindrome\\n                cut[i+j+1] = min(cut[i+j+1],1+cut[i-j]);\\n\\n            for (int j = 1; i-j+1 >= 0 && i+j < n && s[i-j+1] == s[i+j]; j++) // even length palindrome\\n                cut[i+j+1] = min(cut[i+j+1],1+cut[i-j+1]);\\n        }\\n        return cut[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCut(string s) {\\n        int n = s.size();\\n        vector<int> cut(n+1, 0);  // number of cuts for the first k characters\\n        for (int i = 0; i <= n; i++) cut[i] = i-1;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; i-j >= 0 && i+j < n && s[i-j]==s[i+j] ; j++) // odd length palindrome\\n                cut[i+j+1] = min(cut[i+j+1],1+cut[i-j]);\\n\\n            for (int j = 1; i-j+1 >= 0 && i+j < n && s[i-j+1] == s[i+j]; j++) // even length palindrome\\n                cut[i+j+1] = min(cut[i+j+1],1+cut[i-j+1]);\\n        }\\n        return cut[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2224092,
                "title": "simple-dp-solution-c",
                "content": "Step 1: Firstly, I have taken all substrings and checked that it is palindrome or not and stored in check matrix. For doing this, I have used gap strategy to do in O(n^2).\\nStep 2: Now, for each i, I have stored all indexes such that s[i]....s[j] is a palindrome.\\nStep 3: Now applied dp with memoisation to find minimum partitions. \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> adj[2005];\\n    int dp[2005];\\n    int help(int i,int n){\\n        if(i==n){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        int ans=1e9;\\n        for(auto x:adj[i]){\\n            int tmp=1+help(x+1,n);\\n            ans=min(ans,tmp);\\n        }\\n        return dp[i]=ans;\\n    }\\n    int minCut(string s) {\\n        int n=s.size();\\n        int check[n][n];      //to store palindromic status of each substring\\n        for(int g=0;g<n;g++){\\n            for(int i=0,j=g;j<n;i++,j++){\\n                if(g==0){\\n                    check[i][j]=1;\\n                }\\n                else if(g==1){\\n                    check[i][j]=(s[i]==s[j]);\\n                }\\n                else{\\n                    check[i][j]=(check[i+1][j-1]==1 ? (s[i]==s[j] ? 1 : 0) : 0);\\n                }\\n            }\\n        }\\n        \\n        //storing all indexes j in adj[i] such that s[i]...s[j] is palindrome\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++){\\n                if(check[i][j]){\\n                    adj[i].push_back(j);\\n                }\\n            }\\n        }\\n\\n        memset(dp,-1,sizeof(dp));\\n        return help(0,n)-1;       \\n    }  \\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> adj[2005];\\n    int dp[2005];\\n    int help(int i,int n){\\n        if(i==n){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1133603,
                "title": "c-solution-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[2001][2001];\\n    int dp2[2001][2001];\\n    bool ispalindrome(string &str,int i,int j){\\n        if (i >= j) return 1;\\n        if (dp2[i][j] != -1) return dp2[i][j];\\n        if (str[i] == str[j]) return dp2[i][j] = ispalindrome(str, i + 1, j - 1);\\n        return dp2[i][j] = 0;\\n    }\\n    \\n    int solve(string &str, int i, int j){\\n        if(i>=j) return 0;\\n        if(ispalindrome(str,i,j)) return dp[i][j]=0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        dp[i][j] = INT_MAX;\\n        for(int k=i;k<j;k++){\\n            if(ispalindrome(str,i,k)){\\n               dp[i][j]=min(dp[i][j], solve(str,k+1,j)+1); \\n            }                \\n        }\\n        return dp[i][j];\\n    }\\n    \\n    int minCut(string str) {\\n        int n = str.size();\\n        memset(dp,-1,sizeof(dp));\\n        memset(dp2,-1,sizeof(dp2));\\n        return solve(str,0,n-1);\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[2001][2001];\\n    int dp2[2001][2001];\\n    bool ispalindrome(string &str,int i,int j){\\n        if (i >= j) return 1;\\n        if (dp2[i][j] != -1) return dp2[i][j];\\n        if (str[i] == str[j]) return dp2[i][j] = ispalindrome(str, i + 1, j - 1);\\n        return dp2[i][j] = 0;\\n    }\\n    \\n    int solve(string &str, int i, int j){\\n        if(i>=j) return 0;\\n        if(ispalindrome(str,i,j)) return dp[i][j]=0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        dp[i][j] = INT_MAX;\\n        for(int k=i;k<j;k++){\\n            if(ispalindrome(str,i,k)){\\n               dp[i][j]=min(dp[i][j], solve(str,k+1,j)+1); \\n            }                \\n        }\\n        return dp[i][j];\\n    }\\n    \\n    int minCut(string str) {\\n        int n = str.size();\\n        memset(dp,-1,sizeof(dp));\\n        memset(dp2,-1,sizeof(dp2));\\n        return solve(str,0,n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935382,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func minCut(_ s: String) -> Int {\\n        let chars = Array(s)\\n        var dp0: [[Bool]] = Array(repeating: Array(repeating: false, count: s.count), count: s.count)\\n\\t\\t\\n        for i in (0..<s.count).reversed() {\\n\\t\\t\\tfor j in (i..<s.count).reversed() {\\n\\t\\t\\t\\tif i == j {\\n\\t\\t\\t\\t\\tdp0[i][j] = true\\n\\t\\t\\t\\t\\n                } else if chars[i] == chars[j] {\\n\\t\\t\\t\\t\\tdp0[i][j] = i + 1 == j || dp0[i+1][j-1]\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvar dp1: [Int] = Array(repeating: Int.max, count: s.count + 1)\\n\\t\\t\\n        dp1[0] = -1\\n\\t\\tfor i in 1...s.count {\\n\\t\\t\\tfor j in 0..<i {\\n\\t\\t\\t\\tif dp0[j][i-1] == true {\\n\\t\\t\\t\\t\\tdp1[i] = min(dp1[j] + 1, dp1[i])\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n        return dp1[s.count]\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minCut(_ s: String) -> Int {\\n        let chars = Array(s)\\n        var dp0: [[Bool]] = Array(repeating: Array(repeating: false, count: s.count), count: s.count)\\n\\t\\t\\n        for i in (0..<s.count).reversed() {\\n\\t\\t\\tfor j in (i..<s.count).reversed() {\\n\\t\\t\\t\\tif i == j {\\n\\t\\t\\t\\t\\tdp0[i][j] = true\\n\\t\\t\\t\\t\\n                } else if chars[i] == chars[j] {\\n\\t\\t\\t\\t\\tdp0[i][j] = i + 1 == j || dp0[i+1][j-1]\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvar dp1: [Int] = Array(repeating: Int.max, count: s.count + 1)\\n\\t\\t\\n        dp1[0] = -1\\n\\t\\tfor i in 1...s.count {\\n\\t\\t\\tfor j in 0..<i {\\n\\t\\t\\t\\tif dp0[j][i-1] == true {\\n\\t\\t\\t\\t\\tdp1[i] = min(dp1[j] + 1, dp1[i])\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n        return dp1[s.count]\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 325836,
                "title": "c-fastest-solution-99-9-beat-o-n-2-speed-o-n-extra-memory",
                "content": "Personally, I prefer to solve this with a palindrome (dynamic programming) grid and do another DP step on that. This is a faster solution, but some of it is counter intuitive. For example, you MUST have -1 cuts at index 0. You must start probing the even length palindromes with a span of 0 - otherwise you will miss some of the test cases.\\n\\nThat being said, the IDEA is pretty intuitive.\\n\\nTake \"BBOBBA\"\\n\\n[Initial] {-1, 0, 1, 2, 3, 4, 5}\\n[Loop 0] {-1, 0, 0, 2, 3, 4, 5} (We are at the 1st B) (We discover BB which is already a palindrome)\\n[Loop 1] {-1, 0, 0, 2, 3, 4, 5} (We are at the 2nd B) (We don\\'t discover anything at all)\\n[Loop 2] {-1, 0, 0, 1, 1, 0, 5} (We are at the O) (We discover a palindrome of length 5. Now you see the index of the final B has a 0, which means there are no cuts necessary to split anything before that index into a palindrome...)\\n..\\n..\\n[Loop 5] {-1, 0, 0, 1, 1, 0, 1} (We are finally at the last letter, A) (We can make one cut here and add that to our minimum result from back an index.\\n\\nOne more example (please note, I have removed the leading -1\\'s):\\n\\n\"ggbobanabob\"\\n\\n[Initial] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\\n[Loop 0] { 0, 0, 2, 3, 4, 5, 6, 7, 8, 9, 10} //g\\n[Loop 1] { 0, 0, 2, 3, 4, 5, 6, 7, 8, 9, 10} //g\\n[Loop 2] { 0, 0, 1, 3, 4, 5, 6, 7, 8, 9, 10} //b\\n[Loop 3] { 0, 0, 1, 2, 1, 5, 6, 7, 8, 9, 10} //o\\n[Loop 4] { 0, 0, 1, 2, 1, 5, 6, 7, 8, 9, 10} //b\\n[Loop 5] { 0, 0, 1, 2, 1, 2, 6, 7, 8, 9, 10} //a\\n[Loop 6] { 0, 0, 1, 2, 1, 2, 3, 2, 3, 2, 1} //n\\n...\\n(Rest of loops duplicate, culled)\\n\\nAs you can see, by the time we get through \"gg,\" 0 cuts are required.\\n\\nOnce we are at the \"o\", we can use one cut for everything after \"ggbob\". (It\\'s not the most intuitive thing in the world, but read through it a few times)\\n\\nFinally, we get to our \"n\" and we are able to expand the palindrime 4 whole times (for odd length). This gives us our final split, which is:\\n\\ngg | bobanabob\\n\\nSo... to recap... for any given index...\\n\\nAs long as we can expand a pelindrome to a certain depth, we can take the number of cuts from that index minus said depth and add one extra cut to it. Alternatively, we may already have the minimum cuts at this index from a previous operation. Keep the smaller one.\\n\\n\\nOne final example:\\n\\n\"racecar\"\\n\\n[Initial] {-1, 0, 1, 2, 3, 4, 5, 6}\\n[Loop 0] {-1, 0, 1, 2, 3, 4, 5, 6}\\n[Loop 1] {-1, 0, 1, 2, 3, 4, 5, 6}\\n[Loop 2] {-1, 0, 1, 2, 3, 4, 5, 6}\\n[Loop 3] {-1, 0, 1, 2, 3, 2, 1, 0} //Pivot on the E, our whole word is a palindrome.\\n... (truncated)\\n\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minCut(string s) {\\n        \\n        int aLen = s.size();\\n        \\n        int aCuts[aLen + 1];\\n        \\n        int i, aSpan;\\n        \\n        for (i=0;i<=aLen;i++) { aCuts[i] = i - 1; } //Yes, it takes -1 cuts to make a pally from index 0...\\n        \\n        for (i=0;i<aLen;i++) {\\n            \\n            //Odd length.\\n            for (aSpan=0;i+aSpan<aLen && i-aSpan>=0 && s[i + aSpan] == s[i-aSpan];aSpan++) {\\n                aCuts[i+aSpan+1] = min(aCuts[i-aSpan] + 1, aCuts[i+aSpan+1]);\\n            }\\n            \\n            //Even length.\\n            for (aSpan=1;i+aSpan<aLen && i-aSpan+1>=0 && s[i + aSpan] == s[i-aSpan+1];aSpan++) {\\n                aCuts[i+aSpan+1] = min(aCuts[i-aSpan+1] + 1, aCuts[i+aSpan+1]);\\n            }\\n        }\\n        return aCuts[aLen];\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCut(string s) {\\n        \\n        int aLen = s.size();\\n        \\n        int aCuts[aLen + 1];\\n        \\n        int i, aSpan;\\n        \\n        for (i=0;i<=aLen;i++) { aCuts[i] = i - 1; } //Yes, it takes -1 cuts to make a pally from index 0...\\n        \\n        for (i=0;i<aLen;i++) {\\n            \\n            //Odd length.\\n            for (aSpan=0;i+aSpan<aLen && i-aSpan>=0 && s[i + aSpan] == s[i-aSpan];aSpan++) {\\n                aCuts[i+aSpan+1] = min(aCuts[i-aSpan] + 1, aCuts[i+aSpan+1]);\\n            }\\n            \\n            //Even length.\\n            for (aSpan=1;i+aSpan<aLen && i-aSpan+1>=0 && s[i + aSpan] == s[i-aSpan+1];aSpan++) {\\n                aCuts[i+aSpan+1] = min(aCuts[i-aSpan+1] + 1, aCuts[i+aSpan+1]);\\n            }\\n        }\\n        return aCuts[aLen];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42251,
                "title": "my-accepted-o-n-2-dp-solution-in-java",
                "content": "    public class Solution {\\n        public int minCut(String s) {\\n             if(s==null)\\n                return 0;\\n             int i,j,n=s.length();\\n             int cuts[]=new int[n];   //cuts[i] will store the minimum no. of cuts required for substring [0...i];\\n             boolean dp[][]=new boolean[n][n];   // dp[i][j]=true if substring [i...j] can be partitioned into list of palindromes.\\n            \\n            for(i=0;i<n;i++)\\n            {\\n                /*since every single character is a palindrome, maximum no. of cuts for substring [0...i] will be i\\n                 hence initiating cuts[i] with maximum possible value. */        \\n                 \\n                cuts[i]=i; \\n                for(j=0;j<=i;j++)\\n                { \\n                    if(j == i)\\n                       dp[j][i] = true;\\n                    else\\n                    {\\n                      if(s.charAt(i)!= s.charAt(j))\\n                      continue;\\n                      if(j==i-1)\\n                      \\n                      dp[j][i]=true;\\n                      else\\n                      dp[j][i]=dp[j+1][i-1] ;\\n                    }\\n                    \\n                  if(dp[j][i])\\n                  {\\n                      if(j==0)\\n                      cuts[i]=0;\\n                      else\\n                      cuts[i]=Math.min(cuts[j-1]+1,cuts[i]);  \\n                     /*since dp[j][i] is a palindrome, cuts[j]+1 equals no. of cuts required in [0...i] if we include the current  word [j..i]; New cuts[i] will be equal to min of previous cuts[i] and the newly calculated cuts[i] i.e. cuts[j]+1 */\\n                  }\\n                  \\n                  \\n                }\\n            }\\n            return cuts[n-1];\\n            \\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int minCut(String s) {\\n             if(s==null)\\n                return 0;\\n             int i,j,n=s.length();\\n             int cuts[]=new int[n];   //cuts[i] will store the minimum no. of cuts required for substring [0...i];\\n             boolean dp[][]=new boolean[n][n];   // dp[i][j]=true if substring [i...j] can be partitioned into list of palindromes.\\n            \\n            for(i=0;i<n;i++)\\n            {\\n                /*since every single character is a palindrome, maximum no. of cuts for substring [0...i] will be i\\n                 hence initiating cuts[i] with maximum possible value. */        \\n                 \\n                cuts[i]=i; \\n                for(j=0;j<=i;j++)\\n                { \\n                    if(j == i)\\n                       dp[j][i] = true;\\n                    else\\n                    {\\n                      if(s.charAt(i)!= s.charAt(j))\\n                      continue;\\n                      if(j==i-1)\\n                      \\n                      dp[j][i]=true;\\n                      else\\n                      dp[j][i]=dp[j+1][i-1] ;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1388742,
                "title": "palindrome-partitioning-2-java-solution-java",
                "content": "```\\nclass Solution {\\n    public int minCut(String a) {\\n        int[] cut = new int[a.length()];\\n        boolean[][] palindrome = new boolean[a.length()][a.length()]; \\n        for (int i = 0; i < a.length(); i++) {\\n            int minCut = i;\\n            for (int j = 0; j <= i; j++) {\\n                if (a.charAt(i) == a.charAt(j) && (i - j < 2 || palindrome[j + 1][i - 1])) {\\n                    palindrome[j][i] = true;\\n                    minCut = Math.min(minCut, j == 0 ? 0 : (cut[j - 1] + 1));\\n                }\\n            }\\n            cut[i] = minCut;\\n        }\\n        return cut[a.length() - 1];\\n    }\\n}\\n\\nif you find this code useful upvote it.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minCut(String a) {\\n        int[] cut = new int[a.length()];\\n        boolean[][] palindrome = new boolean[a.length()][a.length()]; \\n        for (int i = 0; i < a.length(); i++) {\\n            int minCut = i;\\n            for (int j = 0; j <= i; j++) {\\n                if (a.charAt(i) == a.charAt(j) && (i - j < 2 || palindrome[j + 1][i - 1])) {\\n                    palindrome[j][i] = true;\\n                    minCut = Math.min(minCut, j == 0 ? 0 : (cut[j - 1] + 1));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1388500,
                "title": "c-solution-clean-easy-to-understand-explained",
                "content": "We can solve this problem just like finding the maximum palindromic substring.\\nexpand from each index for both even and odd length of palindrome and put a cut/break on the index when it\\'s not a palindrome.\\n\\n\\tint minCut(string s) {\\n        int n = s.length();\\n        \\n        vector<int> dp(n+1, 0);\\n        \\n\\t\\t//initialize the dp array (the max cuts need for a string of length i to be palindrome is i-1)\\n        for(int i=0; i<=n; i++){\\n            dp[i] = i-1;\\n        }\\n        \\n        for(int k=0; k<n; k++){\\n            int i=k;\\n            int j=k;\\n            //expand for odd length\\n            for(; i>=0 && j<n && s[i] == s[j]; i--, j++){\\n\\t\\t\\t//since the substring between i and j is a palindrome, so we\\'ll put a cut on the left side of the substring\\n                dp[j+1] = min(dp[j+1], dp[i]+1);\\n            }\\n            \\n            i=k-1;\\n            j=k;\\n            //expand for even length\\n            for(; i>=0 && j<n && s[i] == s[j]; i--, j++){\\n\\t\\t\\t//since the substring between i and j is a palindrome, so we\\'ll put a cut on the left side of the substring\\n                dp[j+1] = min(dp[j+1], dp[i]+1);\\n            }\\n        }\\n        \\n        return dp[n];\\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "We can solve this problem just like finding the maximum palindromic substring.\\nexpand from each index for both even and odd length of palindrome and put a cut/break on the index when it\\'s not a palindrome.\\n\\n\\tint minCut(string s) {\\n        int n = s.length();\\n        \\n        vector<int> dp(n+1, 0);\\n        \\n\\t\\t//initialize the dp array (the max cuts need for a string of length i to be palindrome is i-1)\\n        for(int i=0; i<=n; i++){\\n            dp[i] = i-1;\\n        }\\n        \\n        for(int k=0; k<n; k++){\\n            int i=k;\\n            int j=k;\\n            //expand for odd length\\n            for(; i>=0 && j<n && s[i] == s[j]; i--, j++){\\n\\t\\t\\t//since the substring between i and j is a palindrome, so we\\'ll put a cut on the left side of the substring\\n                dp[j+1] = min(dp[j+1], dp[i]+1);\\n            }\\n            \\n            i=k-1;\\n            j=k;\\n            //expand for even length\\n            for(; i>=0 && j<n && s[i] == s[j]; i--, j++){\\n\\t\\t\\t//since the substring between i and j is a palindrome, so we\\'ll put a cut on the left side of the substring\\n                dp[j+1] = min(dp[j+1], dp[i]+1);\\n            }\\n        }\\n        \\n        return dp[n];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 893045,
                "title": "easy-way-explanation-every-step",
                "content": "```\\nif s == s[::-1]:\\n            return 0\\n ```\\n # if given string already Palindrom so no need any partition\\n ```\\n        for i in range(len(s)):\\n            if s[:i] == s[:i][::-1] and s[i:] == s[i:][::-1]:\\n                return 1\\n        \\n\\n```\\n# this parts gives sequence of string is Palindrom if i cut one\\n# like abad----->.   aba | d\\n# if more than 1 then below logic required\\n```\\n# d=[[0 for i  in range(l)] for j in range(l)]  (this line only for understanding)\\n        x=[[0 for i  in range(l)] for j in range(l)]\\n        for i in range(l):\\n          for j in range(i,l):\\n            st=s[i:j+1]\\n            # d[i][j]=st  (this line same)\\n            x[i][j]= (st==st[::-1])    \\n\\n```\\n\\n```\\n\\n\"abcgcbafj\"\\nstdout\\n\\n[\\'a\\', \\'ab\\', \\'abc\\', \\'abcg\\', \\'abcgc\\', \\'abcgcb\\', \\'abcgcba\\', \\'abcgcbaf\\', \\'abcgcbafj\\']\\n[0, \\'b\\', \\'bc\\', \\'bcg\\', \\'bcgc\\', \\'bcgcb\\', \\'bcgcba\\', \\'bcgcbaf\\', \\'bcgcbafj\\']\\n[0, 0, \\'c\\', \\'cg\\', \\'cgc\\', \\'cgcb\\', \\'cgcba\\', \\'cgcbaf\\', \\'cgcbafj\\']\\n[0, 0, 0, \\'g\\', \\'gc\\', \\'gcb\\', \\'gcba\\', \\'gcbaf\\', \\'gcbafj\\']\\n[0, 0, 0, 0, \\'c\\', \\'cb\\', \\'cba\\', \\'cbaf\\', \\'cbafj\\']\\n[0, 0, 0, 0, 0, \\'b\\', \\'ba\\', \\'baf\\', \\'bafj\\']\\n[0, 0, 0, 0, 0, 0, \\'a\\', \\'af\\', \\'afj\\']\\n[0, 0, 0, 0, 0, 0, 0, \\'f\\', \\'fj\\']\\n[0, 0, 0, 0, 0, 0, 0, 0, \\'j\\']\\n\\n\\n\\n\\n\\n```\\n# from above table we gets Palindrom sequence\\n\\n\\n# and below tables gives sequence of string  Palindrom or not according to above table\\n```\\n[True, False, False, False, False, False, True, False, False]\\n[0, True, False, False, False, True, False, False, False]\\n[0, 0, True, False, True, False, False, False, False]\\n[0, 0, 0, True, False, False, False, False, False]\\n[0, 0, 0, 0, True, False, False, False, False]\\n[0, 0, 0, 0, 0, True, False, False, False]\\n[0, 0, 0, 0, 0, 0, True, False, False]\\n[0, 0, 0, 0, 0, 0, 0, True, False]\\n[0, 0, 0, 0, 0, 0, 0, 0, True]\\n\\nOutput\\n\\n```\\n\\n```\\np=[0 for c in range(l)]\\n```\\n# here we store minimum number of partition required .at beginning 0 position 0 reason one characters always Palindrom do start from 1\\n```\\n\\n\\n        for i in range(1,l):\\n          if x[0][i]:\\n            p[i]=0\\n```\\n# if 0 to i already Palindrom no need partition else need to finding min partition\\n\\n\\n```\\n          else: \\n            m=float(\"inf\")\\n            for j in range(i,0,-1):\\n              if x[j][i]: \\n                m=min(m,p[j-1])\\n\\t\\t\\t\\t\\n            p[i]=m+1\\n        return p[-1]\\n```\\n# here partition from right to left\\n# like abbc----> find min partition required for this (abb) and for this required 1(c )\\n# at last store minimum+1\\n\\n```  \\n# python code\\n\\nclass Solution(object):\\n    def minCut(self, s):\\n        \"\"\"\\n        s=\"abcgcbafj\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n      \\n        if s == s[::-1]:\\n            return 0\\n        \\n        for i in range(len(s)):\\n            if s[:i] == s[:i][::-1] and s[i:] == s[i:][::-1]:\\n                return 1\\n        \\n        l=len(s)\\n      \\n        #d=[[0 for i  in range(l)] for j in range(l)]\\n        x=[[0 for i  in range(l)] for j in range(l)]\\n        for i in range(l):\\n          for j in range(i,l):\\n            st=s[i:j+1]\\n            #d[i][j]=st\\n            x[i][j]= (st==st[::-1])\\n                      \\n            \\n        p=[0 for c in range(l)]\\n        for i in range(1,l):\\n          if x[0][i]:\\n            p[i]=0\\n          else:\\n            m=float(\"inf\")\\n            for j in range(i,0,-1):\\n              if x[j][i]: \\n                m=min(m,p[j-1])\\n            p[i]=m+1\\n        return p[-1]\\n  \\n       \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nif s == s[::-1]:\\n            return 0\\n ```\n```\\n        for i in range(len(s)):\\n            if s[:i] == s[:i][::-1] and s[i:] == s[i:][::-1]:\\n                return 1\\n        \\n\\n```\n```\\n# d=[[0 for i  in range(l)] for j in range(l)]  (this line only for understanding)\\n        x=[[0 for i  in range(l)] for j in range(l)]\\n        for i in range(l):\\n          for j in range(i,l):\\n            st=s[i:j+1]\\n            # d[i][j]=st  (this line same)\\n            x[i][j]= (st==st[::-1])    \\n\\n```\n```\\n\\n\"abcgcbafj\"\\nstdout\\n\\n[\\'a\\', \\'ab\\', \\'abc\\', \\'abcg\\', \\'abcgc\\', \\'abcgcb\\', \\'abcgcba\\', \\'abcgcbaf\\', \\'abcgcbafj\\']\\n[0, \\'b\\', \\'bc\\', \\'bcg\\', \\'bcgc\\', \\'bcgcb\\', \\'bcgcba\\', \\'bcgcbaf\\', \\'bcgcbafj\\']\\n[0, 0, \\'c\\', \\'cg\\', \\'cgc\\', \\'cgcb\\', \\'cgcba\\', \\'cgcbaf\\', \\'cgcbafj\\']\\n[0, 0, 0, \\'g\\', \\'gc\\', \\'gcb\\', \\'gcba\\', \\'gcbaf\\', \\'gcbafj\\']\\n[0, 0, 0, 0, \\'c\\', \\'cb\\', \\'cba\\', \\'cbaf\\', \\'cbafj\\']\\n[0, 0, 0, 0, 0, \\'b\\', \\'ba\\', \\'baf\\', \\'bafj\\']\\n[0, 0, 0, 0, 0, 0, \\'a\\', \\'af\\', \\'afj\\']\\n[0, 0, 0, 0, 0, 0, 0, \\'f\\', \\'fj\\']\\n[0, 0, 0, 0, 0, 0, 0, 0, \\'j\\']\\n\\n\\n\\n\\n\\n```\n```\\n[True, False, False, False, False, False, True, False, False]\\n[0, True, False, False, False, True, False, False, False]\\n[0, 0, True, False, True, False, False, False, False]\\n[0, 0, 0, True, False, False, False, False, False]\\n[0, 0, 0, 0, True, False, False, False, False]\\n[0, 0, 0, 0, 0, True, False, False, False]\\n[0, 0, 0, 0, 0, 0, True, False, False]\\n[0, 0, 0, 0, 0, 0, 0, True, False]\\n[0, 0, 0, 0, 0, 0, 0, 0, True]\\n\\nOutput\\n\\n```\n```\\np=[0 for c in range(l)]\\n```\n```\\n\\n\\n        for i in range(1,l):\\n          if x[0][i]:\\n            p[i]=0\\n```\n```\\n          else: \\n            m=float(\"inf\")\\n            for j in range(i,0,-1):\\n              if x[j][i]: \\n                m=min(m,p[j-1])\\n\\t\\t\\t\\t\\n            p[i]=m+1\\n        return p[-1]\\n```\n```  \\n# python code\\n\\nclass Solution(object):\\n    def minCut(self, s):\\n        \"\"\"\\n        s=\"abcgcbafj\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n      \\n        if s == s[::-1]:\\n            return 0\\n        \\n        for i in range(len(s)):\\n            if s[:i] == s[:i][::-1] and s[i:] == s[i:][::-1]:\\n                return 1\\n        \\n        l=len(s)\\n      \\n        #d=[[0 for i  in range(l)] for j in range(l)]\\n        x=[[0 for i  in range(l)] for j in range(l)]\\n        for i in range(l):\\n          for j in range(i,l):\\n            st=s[i:j+1]\\n            #d[i][j]=st\\n            x[i][j]= (st==st[::-1])\\n                      \\n            \\n        p=[0 for c in range(l)]\\n        for i in range(1,l):\\n          if x[0][i]:\\n            p[i]=0\\n          else:\\n            m=float(\"inf\")\\n            for j in range(i,0,-1):\\n              if x[j][i]: \\n                m=min(m,p[j-1])\\n            p[i]=m+1\\n        return p[-1]\\n  \\n       \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 768253,
                "title": "c-palindrome-partitioning-ii-o-n-2",
                "content": "**break it into two smaller dp problems**\\n\\n1) build a table which contains for each substr if s[i...j] is a palindrome\\n\\n```\\n        int n = s.length();\\n        vector<vector<bool>>ispalin(n, vector<bool>(n, 0));\\n        for (int i = 0; i < n; i++)\\n            ispalin[i][i] = 1;\\n        for (int i = 0; i < n - 1; i++)\\n            ispalin[i][i + 1] = (s[i] == s[i + 1]);\\n        for (int len = 3; len <= n; len++)\\n        {\\n            int i = 0;\\n            int j = len - 1;\\n            while (j < n)\\n            {\\n                ispalin[i][j] = (ispalin[i + 1][j - 1]) && (s[i] == s[j]);\\n                i++; j++;\\n            }\\n        }\\n```\\n\\n2) dp[i] contains minimum cuts for s[0...i]. if s[0...i] is a palindrome then dp[i] = 0\\n     otherwise dp[i] = dp[j] + 1 for all j < i and if s[j + 1...i] is a palindrome\\n\\t \\n```\\n        vector<int>dp(n);\\n        dp[0] = 0;\\n        for (int i = 1; i < n; i++)\\n        {\\n            dp[i] = i;\\n            if (ispalin[0][i])\\n            {\\n                dp[i] = 0;\\n                continue;\\n            }\\n            for (int j = 0; j < i; j++)\\n            {\\n                if (ispalin[j + 1][i])\\n                    dp[i] = min(dp[j] + 1, dp[i]);\\n            }\\n        }\\n        return dp[n - 1];\\n```",
                "solutionTags": [],
                "code": "```\\n        int n = s.length();\\n        vector<vector<bool>>ispalin(n, vector<bool>(n, 0));\\n        for (int i = 0; i < n; i++)\\n            ispalin[i][i] = 1;\\n        for (int i = 0; i < n - 1; i++)\\n            ispalin[i][i + 1] = (s[i] == s[i + 1]);\\n        for (int len = 3; len <= n; len++)\\n        {\\n            int i = 0;\\n            int j = len - 1;\\n            while (j < n)\\n            {\\n                ispalin[i][j] = (ispalin[i + 1][j - 1]) && (s[i] == s[j]);\\n                i++; j++;\\n            }\\n        }\\n```\n```\\n        vector<int>dp(n);\\n        dp[0] = 0;\\n        for (int i = 1; i < n; i++)\\n        {\\n            dp[i] = i;\\n            if (ispalin[0][i])\\n            {\\n                dp[i] = 0;\\n                continue;\\n            }\\n            for (int j = 0; j < i; j++)\\n            {\\n                if (ispalin[j + 1][i])\\n                    dp[i] = min(dp[j] + 1, dp[i]);\\n            }\\n        }\\n        return dp[n - 1];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 42267,
                "title": "24ms-c-solution-with-bfs-no-dp",
                "content": "Of course you can use dp or dp+bfs while it won't work well in the situation that the string has many duplicates(e.g.,\"aa\\u2026aa\"). The function ispal() looks simple and crude. But it is more efficient than you think, because of the characters of palindromic strings. \\n\\n\\n    class Solution {\\n    public:\\n    \\tint minCut(string s) {\\n    \\t\\tqueue<int> node;\\n    \\t\\tnode.push(0);\\n    \\t\\tint cuts = 0;\\n    \\t\\t//bfs\\n    \\t\\tvector<bool> visited(s.size(), false);\\n    \\t\\twhile (true){\\n    \\t\\t\\tqueue<int> tmp;\\n    \\t\\t\\twhile (!node.empty()){\\n    \\t\\t\\t\\tint cur = node.front();\\n    \\t\\t\\t\\tnode.pop();\\n    \\t\\t\\t\\tfor (int i = s.size() - 1; i >= cur; i--){\\n    \\t\\t\\t\\t\\tif (visited[i]==false&&ispal(s, cur, i)){\\n    \\t\\t\\t\\t\\t\\tif (i == s.size() - 1)\\n    \\t\\t\\t\\t\\t\\t\\treturn cuts;\\n    \\t\\t\\t\\t\\t\\ttmp.push(i+1);\\n    \\t\\t\\t\\t\\t}\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tvisited[cur] = true;\\n    \\t\\t\\t}\\n    \\t\\t\\tcuts++;\\n    \\t\\t\\tnode = tmp;\\n    \\t\\t}\\n    \\t}\\n    \\n    \\tbool ispal(string& s, int pre, int post){\\n    \\t\\twhile (pre < post){\\n    \\t\\t\\tif (s[pre++] != s[post--])\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\treturn true;\\n    \\t}\\n    };",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    public:\\n    \\tint minCut(string s) {\\n    \\t\\tqueue<int> node;\\n    \\t\\tnode.push(0);\\n    \\t\\tint cuts = 0;\\n    \\t\\t//bfs\\n    \\t\\tvector<bool> visited(s.size(), false);\\n    \\t\\twhile (true){\\n    \\t\\t\\tqueue<int> tmp;\\n    \\t\\t\\twhile (!node.empty()){\\n    \\t\\t\\t\\tint cur = node.front();\\n    \\t\\t\\t\\tnode.pop();\\n    \\t\\t\\t\\tfor (int i = s.size() - 1; i >= cur; i--){\\n    \\t\\t\\t\\t\\tif (visited[i]==false&&ispal(s, cur, i)){\\n    \\t\\t\\t\\t\\t\\tif (i == s.size() - 1)\\n    \\t\\t\\t\\t\\t\\t\\treturn cuts;\\n    \\t\\t\\t\\t\\t\\ttmp.push(i+1);\\n    \\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 42241,
                "title": "my-accepted-java-solution",
                "content": "I've solved the problem some time ago (with DP, of course), and I thought I would share it:\\n \\n  \\n\\n     public class Solution {\\n            int[] cost;\\n            public int minCut(String s) {\\n                if (s == null || s.length() < 2) return 0;\\n                int N = s.length();\\n                cost = new int[N]; \\n                for (int i = 0; i < N; i++)\\n                    cost[i] = Integer.MAX_VALUE;\\n                cut(s);\\n                return cost[N-1];\\n            }\\n            \\n            private void cut (String s) {\\n                if (s.length() > 0) cost[0] = 0;\\n                if (s.length() > 1) cost[1] = s.charAt(1) == s.charAt(0) ? 0 : 1;\\n                int k = 0, l = 0, ni = 0;\\n                for (int i = 2; i < s.length(); i++) {\\n                    if (cost[i] == Integer.MAX_VALUE) cost[i] = cost[i-1]+1;\\n                    for (int j = 1; j <= 2; j++) {\\n                        for (k = i-j, l = i;\\n                            k >= 0 && l <= s.length()-1 && s.charAt(k) == s.charAt(l);\\n                            k--, l++) {\\n                            int c = k == 0 ? 0 : cost[k-1]+1;\\n                            if (cost[l] > c) cost[l] = c;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n## Explanation ##\\nSo my thought process was go through the string, char by char starting from the left. The current character would be the center of the palindrome and expand as much as I can. After it ceases to be a palindrome (e.g no longer matching end chars or reached the boundary of the string), the cost would be \\n\"1 + the cost of the substring I already processed to the left of the current palindrome I am on\". I compare this cost under the index of the last char of my current palindrome. If it is less than what was previously recorded, the I record this new cost.\\n\\nFor example, let's take 'abb':\\n\\n - Start with 'a'. Obviously a cost of 0 (base case)\\n - Now we go to 'b' (index 1). Since we haven't visited 'b', let's assign an initial cost to it, which is 1 + cost[0]. So cost[1] = 0+1 = 1. This makes sense since you only need a 1 cut to get two palindromes: 'a' and 'b'\\n - Let's try to expand 'b'\\n<ul><li> 'ab': It's not a palindrome so do nothing</li>\\n<li>'abb': Not a palindrome either</li></ul></li>\\nAfter expansion, cost[1] remains 1.\\n - Now we go to 'b' (index 2). Initial cost[2] = cost[1]+1 = 2. Expanding...\\n<ul><li> 'bb': Hey, a palindrome! So I will compute a cost of cost[0]+1 = 1 (remember \"1 + cost of substring to the left...). Is 1 less than what I initially have in cost[2]? Yup, it is. So I record it: cost[2] = 1</li></ul></li>\\nAfter expansion, cost[2] was changed from 2 to 1, and rightfully so because that is the minimum cut we can do to get all substrings as palindromes: 'a' and 'bb'.\\n\\nAnother example but we'll go faster this time: 'xccx'\\n\\n - 'x': cost[0] = 0. Base case.\\n - 'c' (index 1): Init cost[1] = 1. Expanding...\\n<ul><li> 'xc': Nope</li>\\n<li>'xcc': Nope</li></ul></li>\\n - 'c': Init cost[2] = 2. Expanding...\\n<ul><li> 'cc->xccx': Yes. Since we reached start of string, this is a base case. So new cost = 0. Is 0 > cost[3] = Integer.MAX_VALUE? Yes, so cost[3] = 0</li>\\n<li>'ccx': Nope</li></ul></li>\\n - 'x': Since cost[3] was previously entered a cost, we don't need to init. Expanding...\\n<ul><li> 'cx': Nope</li></ul></li>\\n - Cost to cut entire string: cost[3] = 0\\n\\nSo there you go. With this method, you are assured that remaining substring (or 'previous state') to the left of the current palindrome is the minimum at that point because you already computed it earlier. You just need to +1 to the cost and see if you have a new minimum cost for the state you are currently in (the last character of the current palindrome).\\n\\nSorry for the lengthy explanation :|",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n            int[] cost;\\n            public int minCut(String s) {\\n                if (s == null || s.length() < 2) return 0;\\n                int N = s.length();\\n                cost = new int[N]; \\n                for (int i = 0; i < N; i++)\\n                    cost[i] = Integer.MAX_VALUE;\\n                cut(s);\\n                return cost[N-1];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 903747,
                "title": "python-easy-to-understand-dp-solution",
                "content": "```\\nclass Solution(object):\\n    def minCut(self, s):\\n        dp = [sys.maxsize] * (len(s)+1)\\n        dp[0] = 0\\n        for j in range(1, len(s)+1):\\n            for i in range(j):\\n                if dp[i] != sys.maxsize and s[i:j] == s[i:j][::-1]:\\n                    dp[j] = min(dp[j], dp[i]+1)\\n        return dp[-1]-1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minCut(self, s):\\n        dp = [sys.maxsize] * (len(s)+1)\\n        dp[0] = 0\\n        for j in range(1, len(s)+1):\\n            for i in range(j):\\n                if dp[i] != sys.maxsize and s[i:j] == s[i:j][::-1]:\\n                    dp[j] = min(dp[j], dp[i]+1)\\n        return dp[-1]-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838499,
                "title": "partition-dp-recursion-memoization-bottum-up-solution",
                "content": "# Intuition\\nGiven a string `s` we need minimum no. of cuts such that the substrings generated are **palindromes**.\\n**Now you may ask is it always possible to cut a string into palindromes?**\\nAnswer to this is **YES**, it is always possible!\\n\\nTake the example `abcde`, here minimum cuts required are as follows:\\n\\n`a`,`b`,`c`,`d`,`e` are itself the only palindromes possible from the above string, so what are the minimum cuts required here? \\n\\nYes it is `4`, i.e., `length of the string  - 1`.\\nSo every string `(s)` can **always** be splitted into palindromes with `len(s)-1`. \\n\\n# Approach\\nFor this problem we try out every possible index *(say state)* to be a palindrome and if it is we make a partition, then at the end we bring out the *minimum no. of partitons* .\\n\\nUsing Recursion we try out all possible outcomes and extract the minimum no. of steps. \\n\\n# Code: Recursion\\n```\\nclass Recursion {\\nprivate:\\n    int n;\\n    bool isPalindrome(string& s, int l, int r)\\n    {\\n        while(l < r)\\n        {\\n            if(s[l++] != s[r--])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int solve(string& s, int idx)\\n    {\\n        if(idx >= n)\\n        {\\n            return 0;\\n        }\\n        int minSteps = INT_MAX;\\n        for(int k=idx; k<n; k++)\\n        {\\n            if(isPalindrome(s, idx, k))\\n            {\\n                int steps = 1 + solve(s, k+1);\\n                minSteps = min(minSteps, steps);\\n            }\\n        }\\n        return minSteps;\\n    }\\npublic:\\n    int minCut(string s) {\\n        n = s.size();\\n        return solve(s, 0) - 1;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity: We already know that for recursion it is $$O(2^N)$$ as there are two changing states, and each state we are trying to check if it is a palindrome or not which at worst case has $$O(N)$$,\\nSo total Time Complexity is $$O(N*2^N)$$. \\n\\n- Space complexity: $$O(N^2)$$ as Recursion stack space.\\n\\n# Code: Top-Down Dynamic Programming (Memoization)\\n```\\nclass RecMemoI {\\nprivate:\\n    int n;\\n    int memo[2000];\\n    bool isPalindrome(string& s, int l, int r)\\n    {\\n        while(l < r)\\n        {\\n            if(s[l++] != s[r--])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int solve(string& s, int idx)\\n    {\\n        if(idx >= n)\\n        {\\n            return 0;\\n        }\\n        if(memo[idx] != -1)\\n        {\\n            return memo[idx];\\n        }\\n        int minSteps = INT_MAX;\\n        for(int k=idx; k<n; k++)\\n        {\\n            if(isPalindrome(s, idx, k))\\n            {\\n                int steps = 1 + solve(s, k+1);\\n                minSteps = min(minSteps, steps);\\n            }\\n        }\\n        return memo[idx] = minSteps;\\n    }\\npublic:\\n    int minCut(string s) {\\n        n = s.size();\\n        memset(memo, -1, sizeof(memo));\\n        return solve(s, 0) - 1;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity: $$O(N^2)$$\\n\\n- Space complexity: $$O(N^2) +O(N^2)$$ as Memo Array + Recursion stack space.\\n\\n# Code: Top-Down Dynamic Programming (Better Memoization)\\n**Here we store values for `checkPalindrome()` too to reduce the runtime**\\n```\\nclass RecMemoII {\\nprivate:\\n    int n;\\n    int memo[2000], check[2000][2000];\\n    bool isPalindrome(string& s, int l, int r)\\n    {\\n        if(check[l][r] != -1)\\n        {\\n            return check[l][r];\\n        }\\n        int lL = l, rR = r;\\n        while(l < r)\\n        {\\n            if(s[l++] != s[r--])\\n            {\\n                return check[lL][rR] = false;\\n            }\\n        }\\n        return check[lL][rR] = true;\\n    }\\n    int solve(string& s, int idx)\\n    {\\n        if(idx >= n)\\n        {\\n            return 0;\\n        }\\n        if(memo[idx] != -1)\\n        {\\n            return memo[idx];\\n        }\\n        int minSteps = INT_MAX;\\n        for(int k=idx; k<n; k++)\\n        {\\n            if(isPalindrome(s, idx, k))\\n            {\\n                int steps = 1 + solve(s, k+1);\\n                minSteps = min(minSteps, steps);\\n            }\\n        }\\n        return memo[idx] = minSteps;\\n    }\\npublic:\\n    int minCut(string s) {\\n        n = s.size();\\n        memset(check, -1, sizeof(check));\\n        memset(memo, -1, sizeof(memo));\\n        return solve(s, 0) - 1;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: $$O(N^2)$$\\n\\n- Space complexity: $$O(N^2) +O(N^2)$$ as Memo Array + Recursion stack space.\\n\\n# Code: Bottum-up Dynamic Programming \\n```\\nclass DP {\\nprivate:\\n    bool isPalindrome(string& s, int l, int r)\\n    {\\n        while(l < r)\\n        {\\n            if(s[l++] != s[r--])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\npublic:\\n    int minCut(string s) {\\n        int n = s.size();\\n        vector<int> dp(n+1, 0);\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            int minSteps = INT_MAX;\\n            for(int k=i; k<n; k++)\\n            {\\n                if(isPalindrome(s, i, k))\\n                {\\n                    int steps = 1 + dp[k+1];\\n                    minSteps = min(minSteps, steps);\\n                }\\n            }\\n            dp[i] = minSteps;\\n        }\\n        return dp[0] - 1;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity: $$O(N^2)$$\\n\\n- Space complexity: $$O(N^2)$$ as DP Array\\n\\n![naruto.gif](https://assets.leetcode.com/users/images/107541cf-e34e-43d9-a4a6-74d81405390b_1690722278.793266.gif)\\n\\n\\nHope you understood this Solution, Just in case you understod please Upvote and share this Awesome question with your fellow coders.\\n\\n# All Palindrome-Partitioning Questions & Solutions Package\\n- [Palindrome Partitioning I](https://leetcode.com/discuss/topic/3838399/simple-recursion-backtracking/)\\n- [Palindrome Partitioning II](https://leetcode.com/discuss/topic/3838499/partition-dp-recursion-memoization-bottum-up-solution/)\\n- [Palindrome Partitioning III](https://leetcode.com/discuss/topic/3838605/partition-dp-recursion-memoization-dp/)\\n- [Palindrome Partitioning IV](https://leetcode.com/discuss/topic/3838671/partition-dp-recursion-memoization-dp/)\\n\\nWith this I\\'m Signing off.\\n\\n![minato.gif](https://assets.leetcode.com/users/images/cf401779-a908-41c5-a1b7-b9a22a3eb3a3_1690722295.4293869.gif)",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Recursion {\\nprivate:\\n    int n;\\n    bool isPalindrome(string& s, int l, int r)\\n    {\\n        while(l < r)\\n        {\\n            if(s[l++] != s[r--])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int solve(string& s, int idx)\\n    {\\n        if(idx >= n)\\n        {\\n            return 0;\\n        }\\n        int minSteps = INT_MAX;\\n        for(int k=idx; k<n; k++)\\n        {\\n            if(isPalindrome(s, idx, k))\\n            {\\n                int steps = 1 + solve(s, k+1);\\n                minSteps = min(minSteps, steps);\\n            }\\n        }\\n        return minSteps;\\n    }\\npublic:\\n    int minCut(string s) {\\n        n = s.size();\\n        return solve(s, 0) - 1;\\n    }\\n};\\n```\n```\\nclass RecMemoI {\\nprivate:\\n    int n;\\n    int memo[2000];\\n    bool isPalindrome(string& s, int l, int r)\\n    {\\n        while(l < r)\\n        {\\n            if(s[l++] != s[r--])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int solve(string& s, int idx)\\n    {\\n        if(idx >= n)\\n        {\\n            return 0;\\n        }\\n        if(memo[idx] != -1)\\n        {\\n            return memo[idx];\\n        }\\n        int minSteps = INT_MAX;\\n        for(int k=idx; k<n; k++)\\n        {\\n            if(isPalindrome(s, idx, k))\\n            {\\n                int steps = 1 + solve(s, k+1);\\n                minSteps = min(minSteps, steps);\\n            }\\n        }\\n        return memo[idx] = minSteps;\\n    }\\npublic:\\n    int minCut(string s) {\\n        n = s.size();\\n        memset(memo, -1, sizeof(memo));\\n        return solve(s, 0) - 1;\\n    }\\n};\\n```\n```\\nclass RecMemoII {\\nprivate:\\n    int n;\\n    int memo[2000], check[2000][2000];\\n    bool isPalindrome(string& s, int l, int r)\\n    {\\n        if(check[l][r] != -1)\\n        {\\n            return check[l][r];\\n        }\\n        int lL = l, rR = r;\\n        while(l < r)\\n        {\\n            if(s[l++] != s[r--])\\n            {\\n                return check[lL][rR] = false;\\n            }\\n        }\\n        return check[lL][rR] = true;\\n    }\\n    int solve(string& s, int idx)\\n    {\\n        if(idx >= n)\\n        {\\n            return 0;\\n        }\\n        if(memo[idx] != -1)\\n        {\\n            return memo[idx];\\n        }\\n        int minSteps = INT_MAX;\\n        for(int k=idx; k<n; k++)\\n        {\\n            if(isPalindrome(s, idx, k))\\n            {\\n                int steps = 1 + solve(s, k+1);\\n                minSteps = min(minSteps, steps);\\n            }\\n        }\\n        return memo[idx] = minSteps;\\n    }\\npublic:\\n    int minCut(string s) {\\n        n = s.size();\\n        memset(check, -1, sizeof(check));\\n        memset(memo, -1, sizeof(memo));\\n        return solve(s, 0) - 1;\\n    }\\n};\\n```\n```\\nclass DP {\\nprivate:\\n    bool isPalindrome(string& s, int l, int r)\\n    {\\n        while(l < r)\\n        {\\n            if(s[l++] != s[r--])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\npublic:\\n    int minCut(string s) {\\n        int n = s.size();\\n        vector<int> dp(n+1, 0);\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            int minSteps = INT_MAX;\\n            for(int k=i; k<n; k++)\\n            {\\n                if(isPalindrome(s, i, k))\\n                {\\n                    int steps = 1 + dp[k+1];\\n                    minSteps = min(minSteps, steps);\\n                }\\n            }\\n            dp[i] = minSteps;\\n        }\\n        return dp[0] - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3036277,
                "title": "easy-c-code-recursion-memoisation-easy-intuition-faster",
                "content": "\\tint solve(string &s,int ind,vector<int> &dp){\\n\\t\\t\\tif(ind == s.size()) return 0;\\n\\n\\t\\t\\tif(dp[ind] != -1) return dp[ind];\\n\\n\\t\\t\\tint ans=INT_MAX;\\n\\t\\t\\tfor(int i=ind;i<s.size();i++){\\n\\t\\t\\t\\tif(isPalindrome(s,ind,i)){\\n\\t\\t\\t\\t\\tint temp=1+solve(s,i+1,dp);\\n\\t\\t\\t\\t\\tans = min(ans,temp);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[ind]=ans;\\n\\t\\t}\\n\\n\\t\\tbool isPalindrome(string &s,int start,int end){\\n\\t\\t\\twhile(start <= end){if(s[start++] != s[end--]) return false;}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tint minCut(string s) {\\n\\t\\t\\tint n = size(s);\\n\\t\\t\\tif(n==1) return 0;\\n\\t\\t\\tvector<int>dp(n,-1);\\n\\t\\t\\treturn solve(s,0,dp)-1;\\n\\t\\t}",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "\\tint solve(string &s,int ind,vector<int> &dp){\\n\\t\\t\\tif(ind == s.size()) return 0;\\n\\n\\t\\t\\tif(dp[ind] != -1) return dp[ind];\\n\\n\\t\\t\\tint ans=INT_MAX;\\n\\t\\t\\tfor(int i=ind;i<s.size();i++){\\n\\t\\t\\t\\tif(isPalindrome(s,ind,i)){\\n\\t\\t\\t\\t\\tint temp=1+solve(s,i+1,dp);\\n\\t\\t\\t\\t\\tans = min(ans,temp);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[ind]=ans;\\n\\t\\t}\\n\\n\\t\\tbool isPalindrome(string &s,int start,int end){\\n\\t\\t\\twhile(start <= end){if(s[start++] != s[end--]) return false;}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tint minCut(string s) {\\n\\t\\t\\tint n = size(s);\\n\\t\\t\\tif(n==1) return 0;\\n\\t\\t\\tvector<int>dp(n,-1);\\n\\t\\t\\treturn solve(s,0,dp)-1;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2270069,
                "title": "c-memoization-tablutaion-best-solution",
                "content": "i)Memoization (TC-> O(N^2)  SC-> O(2*N))//stack space also included\\n```\\nbool isPalindrome(int low,int high,string &s){\\n        while(low<high){\\n            if(s[low++]!=s[high--]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int solve(int i,string s,vector<int>&dp){\\n        int n=s.size();\\n        if(i==n){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        int mini=INT_MAX;\\n        for(int j=i;j<n;j++){\\n            if(isPalindrome(i,j,s)){\\n                mini=min(mini,1+solve(j+1,s,dp));\\n            }\\n        }\\n        return dp[i]=mini;\\n    }\\n    int minCut(string s) {\\n        int n=s.size();\\n        vector<int> dp(n,-1);\\n        return solve(0,s,dp)-1;\\n    }\\n```\\nii)Tabulation (TC-> O(N^2)  SC-> O(N))\\n```\\nbool isPalindrome(int low,int high,string &s){\\n        while(low<high){\\n            if(s[low++]!=s[high--]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int minCut(string s) {\\n        int n=s.size();\\n        vector<int> dp(n+1,0);\\n        for(int i=n-1;i>=0;i--){\\n            int mini=INT_MAX;\\n            for(int j=i;j<n;j++){\\n                if(isPalindrome(i,j,s)){\\n                    mini=min(mini,1+dp[j+1]);\\n                }\\n            }\\n            dp[i]=mini;\\n        }\\n        return dp[0]-1;\\n    }\\n\\t```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nbool isPalindrome(int low,int high,string &s){\\n        while(low<high){\\n            if(s[low++]!=s[high--]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int solve(int i,string s,vector<int>&dp){\\n        int n=s.size();\\n        if(i==n){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        int mini=INT_MAX;\\n        for(int j=i;j<n;j++){\\n            if(isPalindrome(i,j,s)){\\n                mini=min(mini,1+solve(j+1,s,dp));\\n            }\\n        }\\n        return dp[i]=mini;\\n    }\\n    int minCut(string s) {\\n        int n=s.size();\\n        vector<int> dp(n,-1);\\n        return solve(0,s,dp)-1;\\n    }\\n```\n```\\nbool isPalindrome(int low,int high,string &s){\\n        while(low<high){\\n            if(s[low++]!=s[high--]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int minCut(string s) {\\n        int n=s.size();\\n        vector<int> dp(n+1,0);\\n        for(int i=n-1;i>=0;i--){\\n            int mini=INT_MAX;\\n            for(int j=i;j<n;j++){\\n                if(isPalindrome(i,j,s)){\\n                    mini=min(mini,1+dp[j+1]);\\n                }\\n            }\\n            dp[i]=mini;\\n        }\\n        return dp[0]-1;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2213070,
                "title": "c-palindrome-partitioning-all-variations",
                "content": "**Do Upvote if it helps :-)**\\n\\n**MUST CHECK->**\\n**Best Time to Buy and Sell Stock All Variations\\uD83D\\uDC49**[Click Me](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/2237933/C%2B%2B-Best-Time-to-Buy-and-Sell-Stock-All-Variations-Recursion%2BMemoization)\\n\\n[131. Palindrome Partitioning I](https://leetcode.com/problems/palindrome-partitioning/)\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<vector<string>>ans;\\n\\t\\tbool isPali(string s,int l,int r){\\n\\t\\t\\twhile(l<r){\\n\\t\\t\\t\\tif(s[l]!=s[r]){\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tl++;\\n\\t\\t\\t\\tr--;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tvoid check(int ind,string &s,vector<string> &cur){\\n\\t\\t\\tif(ind==s.size()){\\n\\t\\t\\t\\tans.push_back(cur);\\n\\t\\t\\t\\treturn ;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=ind;i<s.size();i++){\\n\\t\\t\\t\\tif(isPali(s,ind,i)){\\n\\t\\t\\t\\t\\tcur.push_back(s.substr(ind,i-ind+1));\\n\\t\\t\\t\\t\\tcheck(i+1,s,cur);\\n\\t\\t\\t\\t\\tcur.pop_back();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvector<vector<string>> partition(string s) {\\n\\t\\t\\tvector<string>cur;\\n\\t\\t\\tcheck(0,s,cur);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\t\\n[132. Palindrome Partitioning II](https://leetcode.com/problems/palindrome-partitioning-ii/)\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> dp;\\n\\t\\tint isPali(string &s,int l,int r){\\n\\t\\t\\twhile(l<r){\\n\\t\\t\\t\\tif(s[l++]!=s[r--]) return false;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tint solve(string &s,int pos,int n){\\n\\t\\t\\tif(pos>=n  || isPali(s,pos,n)) return 0;\\n\\t\\t\\tif(dp[pos]!=-1) return dp[pos];\\n\\t\\t\\tint ans=0,tmp=INT_MAX;\\n\\t\\t\\tfor(int i=pos;i<n;i++){\\n\\t\\t\\t\\tif(isPali(s,pos,i)){\\n\\t\\t\\t\\t\\tans=1+solve(s,i+1,n);\\n\\t\\t\\t\\t\\ttmp=min(tmp,ans);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[pos] = tmp;\\n\\t\\t}\\n\\t\\tint minCut(string s) {\\n\\t\\t\\tdp.assign(s.size(),-1);\\n\\t\\t\\treturn solve(s,0,s.size())-1;\\n\\t\\t}\\n\\t};\\n\\t\\n[1278. Palindrome Partitioning III](https://leetcode.com/problems/palindrome-partitioning-iii/)\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> cost;\\n\\t\\tint costFun(string &s,int l,int r){\\n\\t\\t\\tif(l>=r) return 0;\\n\\t\\t\\tif(cost[l][r]!=-1) return cost[l][r];\\n\\t\\t\\treturn cost[l][r] = (s[l]!=s[r]) + costFun(s,l+1,r-1);\\n\\t\\t}\\n\\n\\t\\tvector<vector<int>>dp;\\n\\t\\tint solve(string &s,int k,int pos,int n){\\n\\t\\t\\tif(k==0) return costFun(s,pos,n-1);\\n\\t\\t\\tif(pos>=n) return INT_MAX;\\n\\t\\t\\tif(dp[pos][k]!=-1) return dp[pos][k];\\n\\t\\t\\tint ans=1e6;\\n\\t\\t\\tfor(int i=pos;i<n-1;i++){\\n\\t\\t\\t\\tans=min(ans,costFun(s,pos,i)+solve(s,k-1,i+1,n));\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[pos][k] = ans;\\n\\t\\t}\\n\\t\\tint palindromePartition(string s, int k) {\\n\\t\\t\\tint n=s.size();\\n\\t\\t\\tcost.assign(n,vector<int>(n,-1));\\n\\t\\t\\tdp.assign(n,vector<int>(k+1,-1));\\n\\t\\t\\treturn solve(s,k-1,0,n);\\n\\t\\t}\\n\\t};\\n\\t\\n[1745. Palindrome Partitioning IV](https://leetcode.com/problems/palindrome-partitioning-iv/)\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> dp;\\n\\t\\tvector<vector<int>> pali;\\n\\t\\tint isPali(string &s,int l,int r){\\n\\t\\t\\tif(l>=r) return 1;\\n\\t\\t\\tif(pali[l][r]!=-1) return pali[l][r];\\n\\t\\t\\tif(s[l]==s[r]) return pali[l][r] = isPali(s,l+1,r-1);\\n\\t\\t\\treturn pali[l][r] = 0;\\n\\t\\t}\\n\\n\\t\\tbool checkPartitioning(string s) {\\n\\t\\t\\tint n=s.size();\\n\\t\\t\\tpali.assign(n,vector<int>(n,-1));\\n\\t\\t\\tfor(int i=1;i<n-1;i++){\\n\\t\\t\\t\\tfor(int j=1;j<=i;j++){\\n\\t\\t\\t\\t\\tif(isPali(s,0,j-1) && isPali(s,j,i) && isPali(s,i+1,n-1)) return true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<vector<string>>ans;\\n\\t\\tbool isPali(string s,int l,int r){\\n\\t\\t\\twhile(l<r){\\n\\t\\t\\t\\tif(s[l]!=s[r]){\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1793824,
                "title": "solution-swift-palindrome-partitioning-ii",
                "content": "```swift\\nclass Solution {\\n    func minCut(_ s: String) -> Int {\\n        guard !s.isEmpty else { return 0 }\\n        \\n        let lenStr = s.count, arr = Array(s)\\n        \\n        var palindromes = [[Bool]](repeating: [Bool](repeating: false, count: lenStr), count: lenStr)\\n        \\n        for n in 0..<lenStr {\\n            for i in 0...n where arr[i] == arr[n] && (n - i < 2 || palindromes[i+1][n-1]) {\\n                palindromes[i][n] = true\\n            }\\n        }\\n        \\n        var cuts = [Int](0..<lenStr)\\n        \\n        for a in stride(from: 1, to: lenStr, by: 1) {\\n            if palindromes[0][a] {\\n                cuts[a] = 0\\n            } else {\\n                for b in 0..<a where palindromes[b + 1][a] {\\n                    cuts[a] = min(cuts[b] + 1, cuts[a])\\n                }\\n            }\\n        }\\n        return cuts[lenStr - 1]\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 3 tests, with 0 failures (0 unexpected) in 0.023 (0.025) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // The palindrome partitioning [\"aa\",\"b\"] could be produced using 1 cut.\\n    func test0() {\\n        let value = solution.minCut(\"aab\")\\n        XCTAssertEqual(value, 1)\\n    }\\n    \\n    func test1() {\\n        let value = solution.minCut(\"a\")\\n        XCTAssertEqual(value, 0)\\n    }\\n    \\n    func test2() {\\n        let value = solution.minCut(\"ab\")\\n        XCTAssertEqual(value, 1)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func minCut(_ s: String) -> Int {\\n        guard !s.isEmpty else { return 0 }\\n        \\n        let lenStr = s.count, arr = Array(s)\\n        \\n        var palindromes = [[Bool]](repeating: [Bool](repeating: false, count: lenStr), count: lenStr)\\n        \\n        for n in 0..<lenStr {\\n            for i in 0...n where arr[i] == arr[n] && (n - i < 2 || palindromes[i+1][n-1]) {\\n                palindromes[i][n] = true\\n            }\\n        }\\n        \\n        var cuts = [Int](0..<lenStr)\\n        \\n        for a in stride(from: 1, to: lenStr, by: 1) {\\n            if palindromes[0][a] {\\n                cuts[a] = 0\\n            } else {\\n                for b in 0..<a where palindromes[b + 1][a] {\\n                    cuts[a] = min(cuts[b] + 1, cuts[a])\\n                }\\n            }\\n        }\\n        return cuts[lenStr - 1]\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // The palindrome partitioning [\"aa\",\"b\"] could be produced using 1 cut.\\n    func test0() {\\n        let value = solution.minCut(\"aab\")\\n        XCTAssertEqual(value, 1)\\n    }\\n    \\n    func test1() {\\n        let value = solution.minCut(\"a\")\\n        XCTAssertEqual(value, 0)\\n    }\\n    \\n    func test2() {\\n        let value = solution.minCut(\"ab\")\\n        XCTAssertEqual(value, 1)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1552091,
                "title": "java-aditya-verma-style-minor-modification-no-tle-commented",
                "content": "```\\n// MCM- optimized-- check if first half is palindrome then only recur for second half\\n// further optimization--memoize the isPalindrome function as well.\\n\\nclass Solution {\\n    \\n    Boolean[][] pal;\\n    private boolean isPalindrome(String s, int i, int j){\\n        if(pal[i][j]!=null){\\n            return pal[i][j];\\n        }\\n        while(i<j){\\n            if(s.charAt(i)!=s.charAt(j)){\\n                pal[i][j]=false;\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        pal[i][j]=true;\\n        return true;\\n    }\\n    \\n    private int mcm(String s, int i, int j,int[][] dp){\\n        if(i>=j){\\n            return 0;\\n        }\\n        if(isPalindrome(s,i,j)){\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int min=Integer.MAX_VALUE;\\n        for(int k=i;k<j;k++){\\n            // instead of recurring for both the halves, we will first check if the first half is \\n            // palindrome then only we will recur for the next half\\n            // int temp=1+mcm(s,i,k,dp)+mcm(s,k+1,j,dp);\\n            \\n            if(isPalindrome(s,i,k)){\\n                int temp=1+mcm(s,k+1,j,dp);\\n                min=Math.min(min,temp);\\n            }\\n           \\n        }\\n        dp[i][j]=min;\\n        return min;\\n    }\\n    \\n    public int minCut(String s) {\\n        int n=s.length();\\n        int[][] dp=new int[n+1][n+1];\\n        pal=new Boolean[n+1][n+1];\\n        for(int i=0;i<n;i++){\\n            Arrays.fill(dp[i],-1);\\n        }\\n        return mcm(s,0,n-1,dp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// MCM- optimized-- check if first half is palindrome then only recur for second half\\n// further optimization--memoize the isPalindrome function as well.\\n\\nclass Solution {\\n    \\n    Boolean[][] pal;\\n    private boolean isPalindrome(String s, int i, int j){\\n        if(pal[i][j]!=null){\\n            return pal[i][j];\\n        }\\n        while(i<j){\\n            if(s.charAt(i)!=s.charAt(j)){\\n                pal[i][j]=false;\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        pal[i][j]=true;\\n        return true;\\n    }\\n    \\n    private int mcm(String s, int i, int j,int[][] dp){\\n        if(i>=j){\\n            return 0;\\n        }\\n        if(isPalindrome(s,i,j)){\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int min=Integer.MAX_VALUE;\\n        for(int k=i;k<j;k++){\\n            // instead of recurring for both the halves, we will first check if the first half is \\n            // palindrome then only we will recur for the next half\\n            // int temp=1+mcm(s,i,k,dp)+mcm(s,k+1,j,dp);\\n            \\n            if(isPalindrome(s,i,k)){\\n                int temp=1+mcm(s,k+1,j,dp);\\n                min=Math.min(min,temp);\\n            }\\n           \\n        }\\n        dp[i][j]=min;\\n        return min;\\n    }\\n    \\n    public int minCut(String s) {\\n        int n=s.length();\\n        int[][] dp=new int[n+1][n+1];\\n        pal=new Boolean[n+1][n+1];\\n        for(int i=0;i<n;i++){\\n            Arrays.fill(dp[i],-1);\\n        }\\n        return mcm(s,0,n-1,dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1508970,
                "title": "c-dp-using-memoization-optimized-solution-aditya-verma-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int t[2001][2001];\\n    int pal[2001][2001]; // storing palindrome value also so that need not to calculate if already checked\\n    \\n    int minCut(string s) {\\n        int n = s.size();\\n        memset(t, -1, sizeof(t));\\n        memset(pal, 0, sizeof(t));\\n        int ans = partition(s, 0, n-1);\\n        return ans;\\n    }\\n\\npublic:\\n    int partition(string& s, int i, int j){\\n        if(i>=j || pal[i][j] == 1){\\n            return 0;\\n        }\\n        if(ispalindrome(s, i, j)==1){\\n            t[i][j] = 0;\\n            return 0;\\n        }\\n        \\n        if(t[i][j]!=-1){\\n            return t[i][j];\\n        }\\n        int temp_ans =0;\\n        int minval = s.size()-1; // if partitioning each character because no palindrome is present\\n        for(int k=i; k<j; k++){\\n            int right =0;\\n//             if left part is palindrome then check for right half else move one more position\\n//             eg. itika ---> so \\'it\\' is not panlindrome move to next postition now, left half is \\'iti\\' which \\n            // which is a palindrome so check for its right half i.e. \\'ka\\'\\n            if(ispalindrome(s, i, k) == 1){\\n                temp_ans = 1+ partition(s, k+1, j);\\n                minval = min(minval, temp_ans);\\n            }\\n        }\\n        t[i][j] = minval;\\n        return minval;\\n    }\\n    \\npublic:\\n//     remember to pass it by reference rather than pass by value, because size of address < size of string \\n//     in case of larger strings other it will give TLE\\n    int ispalindrome(string& s, int i, int j){\\n        if(i>=j){\\n            return true;\\n        }\\n        while(i<=j){\\n            if(s[i]!=s[j]){\\n                pal[i][j] =0;\\n                return 0;\\n            }\\n            else{\\n                i++;\\n                j--;\\n            }\\n        }\\n        pal[i][j] = 1;\\n        return 1;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int t[2001][2001];\\n    int pal[2001][2001]; // storing palindrome value also so that need not to calculate if already checked\\n    \\n    int minCut(string s) {\\n        int n = s.size();\\n        memset(t, -1, sizeof(t));\\n        memset(pal, 0, sizeof(t));\\n        int ans = partition(s, 0, n-1);\\n        return ans;\\n    }\\n\\npublic:\\n    int partition(string& s, int i, int j){\\n        if(i>=j || pal[i][j] == 1){\\n            return 0;\\n        }\\n        if(ispalindrome(s, i, j)==1){\\n            t[i][j] = 0;\\n            return 0;\\n        }\\n        \\n        if(t[i][j]!=-1){\\n            return t[i][j];\\n        }\\n        int temp_ans =0;\\n        int minval = s.size()-1; // if partitioning each character because no palindrome is present\\n        for(int k=i; k<j; k++){\\n            int right =0;\\n//             if left part is palindrome then check for right half else move one more position\\n//             eg. itika ---> so \\'it\\' is not panlindrome move to next postition now, left half is \\'iti\\' which \\n            // which is a palindrome so check for its right half i.e. \\'ka\\'\\n            if(ispalindrome(s, i, k) == 1){\\n                temp_ans = 1+ partition(s, k+1, j);\\n                minval = min(minval, temp_ans);\\n            }\\n        }\\n        t[i][j] = minval;\\n        return minval;\\n    }\\n    \\npublic:\\n//     remember to pass it by reference rather than pass by value, because size of address < size of string \\n//     in case of larger strings other it will give TLE\\n    int ispalindrome(string& s, int i, int j){\\n        if(i>=j){\\n            return true;\\n        }\\n        while(i<=j){\\n            if(s[i]!=s[j]){\\n                pal[i][j] =0;\\n                return 0;\\n            }\\n            else{\\n                i++;\\n                j--;\\n            }\\n        }\\n        pal[i][j] = 1;\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1443519,
                "title": "cpp-concise-memoization-solution",
                "content": "This is a classic Palindrome partioning problem. Only check is you have to minimise the calls. \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool isPalindrome(string& s, int left, int right)\\n    {\\n        while(left <= right)\\n        {\\n            if(s[left] != s[right]) return false;\\n            \\n            left++;\\n            right--;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    int partitions(string& s, int start, int end, vector<vector<int>>& dp)\\n    {\\n        if(start >= end) return dp[start][end] = 0; //it is already a palindrome\\n        \\n        if(dp[start][end] != -1) return dp[start][end];\\n        \\n        if(isPalindrome(s, start, end)) return dp[start][end] = 0; //it is already a palindrome why need to partition\\n        \\n        int ans = INT_MAX;\\n        \\n        for(int k = start; k < end; k++)\\n        {\\n            //before making call, we are checking that if the string after partioning is palindrome or not, if\\n\\t\\t\\t//not we. will not consider that case.\\n\\t\\t\\tif(isPalindrome(s, start, k))\\n\\t\\t\\t{ \\n                int temp = 1 + partitions(s, start, k, dp) + partitions(s, k + 1, end, dp);\\n\\n                ans = min(temp , ans);\\n            }\\n        }\\n        \\n        return dp[start][end] = ans;\\n    }\\n    \\n    int minCut(string s) \\n    {\\n        vector<vector<int>> dp(s.size() + 1, vector<int>(s.size() + 1, -1));\\n        \\n        return partitions(s, 0, s.size() - 1, dp);\\n    }\\n};\\n```\\nYou can also use global array here.\\nFeel free to ask and do upvote.",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isPalindrome(string& s, int left, int right)\\n    {\\n        while(left <= right)\\n        {\\n            if(s[left] != s[right]) return false;\\n            \\n            left++;\\n            right--;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    int partitions(string& s, int start, int end, vector<vector<int>>& dp)\\n    {\\n        if(start >= end) return dp[start][end] = 0; //it is already a palindrome\\n        \\n        if(dp[start][end] != -1) return dp[start][end];\\n        \\n        if(isPalindrome(s, start, end)) return dp[start][end] = 0; //it is already a palindrome why need to partition\\n        \\n        int ans = INT_MAX;\\n        \\n        for(int k = start; k < end; k++)\\n        {\\n            //before making call, we are checking that if the string after partioning is palindrome or not, if\\n\\t\\t\\t//not we. will not consider that case.\\n\\t\\t\\tif(isPalindrome(s, start, k))\\n\\t\\t\\t{ \\n                int temp = 1 + partitions(s, start, k, dp) + partitions(s, k + 1, end, dp);\\n\\n                ans = min(temp , ans);\\n            }\\n        }\\n        \\n        return dp[start][end] = ans;\\n    }\\n    \\n    int minCut(string s) \\n    {\\n        vector<vector<int>> dp(s.size() + 1, vector<int>(s.size() + 1, -1));\\n        \\n        return partitions(s, 0, s.size() - 1, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 286262,
                "title": "java-4ms-dp-solution-with-explanation",
                "content": "The basic idea is using two dp arrays:\\n1. ```isPalindrome[i][j]``` to record whether s[i, j] is palindrome and\\n2. ```num[i]``` to record the minimum cut for s[0, i].\\n\\nHere, s[i, j] is the abbreviation for s.substring(i, j + 1).\\n\\nTraverse the array to calculate ```num``` and ```isPalindrome```. ```num[s.length() - 1]``` is the result we want.\\nNote that if s[0, i] is palindrome then num[i] equals to zero because we don\\'t need to cut it to get the sequence of palindrome.\\n```\\npublic int minCut(String s) {\\n    char str[] = s.toCharArray();\\n    boolean isPalindrome[][] = new boolean[s.length()][s.length()];\\n    int num[] = new int[s.length()];\\n\\n    for(int i = 0; i < s.length(); i++) {\\n        int min = Integer.MAX_VALUE;\\n        for(int j = 0; j <= i; j++) {\\n            if( str[i] == str[j] && (j + 1 >= i || isPalindrome[j + 1][i - 1]) ){\\n                isPalindrome[j][i] = true;\\n                min = j == 0 ? 0 : Math.min(min, num[j - 1] + 1);\\n            }\\n        }\\n        num[i] = min;\\n    }\\n    return num[s.length() - 1];\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```isPalindrome[i][j]```\n```num[i]```\n```num```\n```isPalindrome```\n```num[s.length() - 1]```\n```\\npublic int minCut(String s) {\\n    char str[] = s.toCharArray();\\n    boolean isPalindrome[][] = new boolean[s.length()][s.length()];\\n    int num[] = new int[s.length()];\\n\\n    for(int i = 0; i < s.length(); i++) {\\n        int min = Integer.MAX_VALUE;\\n        for(int j = 0; j <= i; j++) {\\n            if( str[i] == str[j] && (j + 1 >= i || isPalindrome[j + 1][i - 1]) ){\\n                isPalindrome[j][i] = true;\\n                min = j == 0 ? 0 : Math.min(min, num[j - 1] + 1);\\n            }\\n        }\\n        num[i] = min;\\n    }\\n    return num[s.length() - 1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1792083,
                "title": "java-with-comments-easy-explanation",
                "content": "**Upvote if you like the solution**\\n```\\nclass Solution {\\n    public int minCut(String s) {\\n        int n=s.length();\\n        boolean dp[][]=new boolean[n][n];\\n        \\n        //gap strategy (dp)\\n        //checking if this string is Palindrome or not\\n        for(int g=0;g<n;g++){\\n            for(int i=0,j=g;j<n;i++,j++){\\n                //only one element\\n                if(g==0){\\n                    dp[i][j]=true;\\n                }\\n                else if(g==1){\\n                    //two ele if equal\\n                    if(s.charAt(i)==s.charAt(j)){\\n                        dp[i][j]=true;\\n                    }\\n                    else{\\n                        dp[i][j]=false;\\n                    }\\n                }\\n                else{\\n                    //more than 2 ele\\'s\\n                    //if first and last is equal\\n                    //and inside string is also equal\\n                    if(s.charAt(i)==s.charAt(j) && dp[i+1][j-1]){\\n                        dp[i][j]=true;\\n                    }\\n                    else{\\n                        dp[i][j]=false;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int dp2[]=new int[n];\\n        \\n        //for only one element (means Palindrome) no need to cut\\n        dp2[0]=0;\\n        \\n        //for filling ans dp (dp2)\\n        for(int j=1;j<n;j++){\\n            \\n            //if our string is already Palindrome then no need to cut so 0\\n            //imagine grid of true\\'s and false\\'s (imagine if we take all ele\\'s)\\n            //and it\\'s Palindrome so no need to cut/divide\\n            if(dp[0][j]){\\n                dp2[j]=0;\\n            }\\n            \\n            //string is not Palindrome (we need to make a cut)\\n            else{\\n                \\n                //taking min answer and store in dp2 (our answer array)\\n                int min=Integer.MAX_VALUE;\\n                \\n                //try to imagine a grid which is filled with true\\'s and false\\'s (dp)\\n                //take suffix and calculate answer\\n                //not going upto 0 bcz it means the whole string which we have already checked\\n                //another way of saying is - in grid going up (subtracting suffix)\\n                for(int i=j;i>=1;i--){\\n                    \\n                    //if this suffix is Palindrome\\n                    if(dp[i][j]){\\n                        \\n                        //then we can divide into\\n                        //we have suffix upto i\\n                        //we have our ans dp2 upto j\\n                        //means remaing string answer we have already calcualted, just take it from dp2\\n                        min=Math.min(min,dp2[i-1]);\\n                    }\\n                }\\n                \\n                //we make a cut for suffix means we have to add 1 for cut\\n                dp2[j]=min+1;\\n            }\\n        }\\n        \\n        //we have build our array for all values\\n        //this means we have taken into account all the elements\\n        //and our answer present in n-1 index\\n        return dp2[n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minCut(String s) {\\n        int n=s.length();\\n        boolean dp[][]=new boolean[n][n];\\n        \\n        //gap strategy (dp)\\n        //checking if this string is Palindrome or not\\n        for(int g=0;g<n;g++){\\n            for(int i=0,j=g;j<n;i++,j++){\\n                //only one element\\n                if(g==0){\\n                    dp[i][j]=true;\\n                }\\n                else if(g==1){\\n                    //two ele if equal\\n                    if(s.charAt(i)==s.charAt(j)){\\n                        dp[i][j]=true;\\n                    }\\n                    else{\\n                        dp[i][j]=false;\\n                    }\\n                }\\n                else{\\n                    //more than 2 ele\\'s\\n                    //if first and last is equal\\n                    //and inside string is also equal\\n                    if(s.charAt(i)==s.charAt(j) && dp[i+1][j-1]){\\n                        dp[i][j]=true;\\n                    }\\n                    else{\\n                        dp[i][j]=false;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int dp2[]=new int[n];\\n        \\n        //for only one element (means Palindrome) no need to cut\\n        dp2[0]=0;\\n        \\n        //for filling ans dp (dp2)\\n        for(int j=1;j<n;j++){\\n            \\n            //if our string is already Palindrome then no need to cut so 0\\n            //imagine grid of true\\'s and false\\'s (imagine if we take all ele\\'s)\\n            //and it\\'s Palindrome so no need to cut/divide\\n            if(dp[0][j]){\\n                dp2[j]=0;\\n            }\\n            \\n            //string is not Palindrome (we need to make a cut)\\n            else{\\n                \\n                //taking min answer and store in dp2 (our answer array)\\n                int min=Integer.MAX_VALUE;\\n                \\n                //try to imagine a grid which is filled with true\\'s and false\\'s (dp)\\n                //take suffix and calculate answer\\n                //not going upto 0 bcz it means the whole string which we have already checked\\n                //another way of saying is - in grid going up (subtracting suffix)\\n                for(int i=j;i>=1;i--){\\n                    \\n                    //if this suffix is Palindrome\\n                    if(dp[i][j]){\\n                        \\n                        //then we can divide into\\n                        //we have suffix upto i\\n                        //we have our ans dp2 upto j\\n                        //means remaing string answer we have already calcualted, just take it from dp2\\n                        min=Math.min(min,dp2[i-1]);\\n                    }\\n                }\\n                \\n                //we make a cut for suffix means we have to add 1 for cut\\n                dp2[j]=min+1;\\n            }\\n        }\\n        \\n        //we have build our array for all values\\n        //this means we have taken into account all the elements\\n        //and our answer present in n-1 index\\n        return dp2[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1586401,
                "title": "dp-memoization-aditya-verma-dp-modification-c",
                "content": "class Solution {\\npublic:\\n    \\n    int t[2001][2001];\\n      \\n    bool isPalindrome(string &s,int i,int j){\\n      \\n        \\n        if(i==j){\\n            return true;\\n        }\\n        if(i>j){\\n            return true;\\n        }\\n        \\n        while(i<=j){\\n            if(s[i]!=s[j]){\\n                return false;\\n            }\\n            i++;\\n            j--;\\n            \\n        }\\n        return true;\\n    }\\n    \\n    \\n    int solve(string &s,int i,int j)\\n    {\\n        if(i>=j){\\n            return 0;\\n        }\\n        if(t[i][j]!=-1){\\n            return t[i][j];\\n        }\\n        \\n       if(isPalindrome(s,i,j)==true){\\n           t[i][j]=0;\\n            return 0;\\n        }\\n     \\n      \\n           int  Min=INT_MAX;\\n        for(int k=i;k<j;k++){\\n          \\n                if(isPalindrome(s,i,k)){\\n                    int temp=1+solve(s,k+1,j);\\n                   Min=min(temp,Min);\\n                }\\n       \\n    }\\n        return t[i][j]=Min;\\n    }\\n    \\n    int minCut(string s) {\\n        \\n        int i=0;\\n        int j=s.size()-1;\\n          memset(t, -1, sizeof(t));\\n       return solve(s,i,j);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int t[2001][2001];\\n      \\n    bool isPalindrome(string &s,int i,int j){\\n      \\n        \\n        if(i==j){\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1389041,
                "title": "approach-explained-in-detail-with-diagrams-complexity-analysis",
                "content": "**0. Understanding the Problem**\\nGiven a string -> partition it into substrings -> such that each partition is a palindrome -> return the minimum number of partitions\\n\\nSo essentially we are solving two problems, bundled together as one.\\n1. Find the best partition of the input string.\\n2. Find if the partition is a palindrome.\\n\\n**1. Finding the Best Partition Sequence**\\nTake a look at the following example:\\n![](https://i.imgur.com/kbC16Gl.png)\\n\\nWe can observe that there is some sort of **butterfly effect**. Picking `a` after `x` versus picking the substring `abcba` speads its consequence to later decisions as well. **We need to pick wisely**. But, how? There\\'s no metric for us to compare with! How can we look into the future?\\n\\n**Key point: Think recursively** \\n\\n**2. Finding the Palindromic Partitions**\\nLet\\'s look at another, more abstractly. \\n![](https://i.imgur.com/ihiR7bj.png)\\n\\nGiven that we are already thinking recursively, we can think of *sections* or *palindromic partitions (PPs)* instead of just characters. What we are looking for are entire PPs!\\n\\n**Key point: Look for PPs**\\n\\n**2. Solution**\\n```\\nclass Solution:\\n    # [start, end)\\n    def is_palindrome(self, start, end):\\n        return self.a[start:end] == self.a[start:end][::-1]\\n    \\n    @lru_cache(None)\\n    def recurse(self, start):\\n        if start >= self.n: return 0\\n        \\n        count = +inf\\n        for end in range(start+1, self.n+1):\\n            if self.is_palindrome(start, end):\\n                count = min(count, 1+self.recurse(end))\\n        return count\\n\\n    def minCut(self, a: str) -> int:\\n        self.a = a\\n        self.n = len(a)\\n        return self.recurse(0)-1\\n```\\nThis solution is `O(N^3)` **time complexity** and `O(N^2)` **space complexity**. Worst case, we are going character by character in the recursion stack `O(N)` and we\\'ll also iterate over all the next possible characters, `O(N)`. Time complexity is `O(N^3)` since we take additional `O(N)` time to check if the string bounded by `start` and `end` is palindromic or not.\\n\\n**Upvote if you found this helpful. It means a lot to me! Feel free to ask any questions =D**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # [start, end)\\n    def is_palindrome(self, start, end):\\n        return self.a[start:end] == self.a[start:end][::-1]\\n    \\n    @lru_cache(None)\\n    def recurse(self, start):\\n        if start >= self.n: return 0\\n        \\n        count = +inf\\n        for end in range(start+1, self.n+1):\\n            if self.is_palindrome(start, end):\\n                count = min(count, 1+self.recurse(end))\\n        return count\\n\\n    def minCut(self, a: str) -> int:\\n        self.a = a\\n        self.n = len(a)\\n        return self.recurse(0)-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1388709,
                "title": "c-dp-solution-0-n-2-space-and-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCut(string s) {\\n\\t\\tint n = s.length();\\n\\t\\t\\n\\t\\t// 1-based indexing\\n        s = \\' \\' + s;\\n\\t\\t\\n\\t\\t// checking if the particular substring is palindromic or not \\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\\n        for (int i = n; i > 0; i--) {\\n            for(int j = i; j <= n ;j++) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// the substring of length 1 will always be palindrome\\n                if (i == j ) {\\n                    dp[i][j] = 1;\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// checking for the length 2 substring \\n                else if (j == i + 1 && s[i] == s[j]) {\\n                    dp[i][j] = 1;\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// checking if corner character matched, check it with middle part that we already calculated\\n                else if(s[i] == s[j]) {\\n                    dp[i][j] = dp[i + 1][j - 1];\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t// dp vector for storing answer, where index denotes the size of substring from starting index\\n        vector<int> res(n + 1, 0);\\n        \\n        for(int i = 1; i <= n; i++){\\n            res[i] = i - 1;\\n        }\\n        \\n        for (int i = 2; i <= n; i++){\\n            for(int j = i; j > 1; j--){\\n\\t\\t\\t\\t// checking for different partitons\\n                if(dp[j][i]){    \\n                    res[i] = min (res[i], res[j-1] + 1);\\n                }\\n            }\\n\\t\\t\\t// if the whole substring is palindrome \\n            if (dp[1][i]) {\\n               res[i] = 0; \\n            } \\n            \\n        }\\n        for (int i = 1; i <= n; i++){\\n        }\\n        return res[n] ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCut(string s) {\\n\\t\\tint n = s.length();\\n\\t\\t\\n\\t\\t// 1-based indexing\\n        s = \\' \\' + s;\\n\\t\\t\\n\\t\\t// checking if the particular substring is palindromic or not \\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\\n        for (int i = n; i > 0; i--) {\\n            for(int j = i; j <= n ;j++) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// the substring of length 1 will always be palindrome\\n                if (i == j ) {\\n                    dp[i][j] = 1;\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// checking for the length 2 substring \\n                else if (j == i + 1 && s[i] == s[j]) {\\n                    dp[i][j] = 1;\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// checking if corner character matched, check it with middle part that we already calculated\\n                else if(s[i] == s[j]) {\\n                    dp[i][j] = dp[i + 1][j - 1];\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t// dp vector for storing answer, where index denotes the size of substring from starting index\\n        vector<int> res(n + 1, 0);\\n        \\n        for(int i = 1; i <= n; i++){\\n            res[i] = i - 1;\\n        }\\n        \\n        for (int i = 2; i <= n; i++){\\n            for(int j = i; j > 1; j--){\\n\\t\\t\\t\\t// checking for different partitons\\n                if(dp[j][i]){    \\n                    res[i] = min (res[i], res[j-1] + 1);\\n                }\\n            }\\n\\t\\t\\t// if the whole substring is palindrome \\n            if (dp[1][i]) {\\n               res[i] = 0; \\n            } \\n            \\n        }\\n        for (int i = 1; i <= n; i++){\\n        }\\n        return res[n] ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1267712,
                "title": "multiple-approach-best-solution",
                "content": "# **Approach 1** **(TLE)**\\n\\n```cpp\\nbool isPalindrome(int i, int j, string &s)\\n{\\n    while(i<j)\\n    {\\n        if(s[i]!=s[j]) return false;\\n        i++; j--;\\n    }\\n    return true;\\n}\\nint solve(vector<vector<int>> &dp, int i, int j, string &s)\\n{\\n    if(i>=j) return 0;\\n    if(dp[i][j]!= -1) return dp[i][j];\\n    if( isPalindrome(i, j, s) ) return 0;\\n    int ans = INT_MAX;\\n    for(int k=i;k<j;k++)\\n        ans = min(ans, solve(dp, i, k, s) + solve(dp, k+1, j, s) + 1);\\n    \\n    return dp[i][j] = ans;\\n}\\nint minCut(string s)\\n{\\n    int n = s.size();\\n    vector<vector<int>> dp(n, vector<int>(n, -1));\\n    return solve(dp, 0, n-1, s);\\n}\\n```\\n\\nApproach 1 is based on Matrix Chain Multiplication method(if you don\\'t know Matrix Chain Multiplication please check that), we are considering answer for each intermediate index of string and recursively solving for those substring```s(i, k)``` and ```s(k+1, j)``` and selecting the best answer.\\n\\nHere multiple overlapping problems will occur so we are memoizing the answer calculated and reusing when it appears next time.\\n**Time Complexity** - O(n<sup>3</sup>)\\n**Space Complexity** - O(n<sup>2</sup>)\\nTime Complexity of above approach is O(n<sup>3</sup>) Because there are O(n<sup>2</sup>) sub problems(all possible partion of string) and for each subproblem we are checking whether it is palindrome or not in O(n) time. \\n\\n# **Approach 2 (Accepted)**\\n```cpp\\nclass Solution {\\npublic:\\nbool isPalindrome(vector<vector<int>> &pdp, int i, int j, string &s)\\n{\\n    if(i>j) return 1;\\n    if(i==j) return pdp[i][j] = 1;\\n    if(pdp[i][j] != -1) return pdp[i][j];\\n    if(s[i] != s[j]) return pdp[i][j] = 0;\\n    pdp[i][j] =  isPalindrome(pdp, i+1, j-1, s) ;\\n    return pdp[i][j];\\n}\\nint solve(vector<vector<int>> &dp, int i, int j, string &s, vector<vector<int>> &pdp)\\n{\\n    if(i>=j) return 0;\\n    if(dp[i][j]!= -1) return dp[i][j];\\n    if( pdp[i][j] == 1 ) return dp[i][j] = 0;\\n    int ans = INT_MAX;\\n    for(int k=i;k<j;k++)\\n        if(pdp[i][k])\\n             ans = min(ans, solve(dp, i, k, s, pdp) + solve(dp, k+1, j, s, pdp) + 1);\\n    \\n    return dp[i][j] = ans;\\n}\\nint minCut(string s) \\n{\\n    int n = s.size();\\n    vector<vector<int>> dp(n, vector<int>(n, -1));\\n    vector<vector<int>> pdp(n, vector<int>(n, -1));\\n    for(int i=0;i<n;i++)\\n        for(int j=i;j<n;j++)\\n            isPalindrome(pdp, i, j, s);\\n    return solve(dp, 0, n-1, s, pdp);\\n}\\n};\\n```\\n\\nApproach 2 is just optimisation in checking is palindrome. Here we are pre-calculating whether string(i, j) is palindrome or not.\\n```pdp[i][j]``` indicates that wheter ```s(i, j)``` is palindrome or not using dynamic programming.\\n\\n**Time Complexity** - O(n<sup>2</sup>)\\n**Space Complexity** - O(n<sup>2</sup>)\\nTime Complexity of above approach is O(n<sup>2</sup>) only because there are O(n<sup>2</sup>) sub problems(all possible partion of string) and for each subproblem we are checking whether it is palindrome or not in O(1).\\nAnd to check whether a substring is palindrome or not we are pre computing in O(n<sup>2</sup>). So, overall time complexity will be O(n<sup>2</sup> + n<sup>2</sup> ) = O(n<sup>2</sup>) only.\\n\\n\\n# **Approach 3 (Accepted and Best)**\\n```cpp\\nclass Solution {\\npublic:\\n    int minCut(string s) {\\n        int n = s.size();\\n        vector<int> cut(n+1, 0);  // number of cuts for the first k characters\\n        for (int i = 0; i <= n; i++) cut[i] = i-1;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; i-j >= 0 && i+j < n && s[i-j]==s[i+j] ; j++) // odd length palindrome\\n                cut[i+j+1] = min(cut[i+j+1],1+cut[i-j]);\\n\\n            for (int j = 1; i-j+1 >= 0 && i+j < n && s[i-j+1] == s[i+j]; j++) // even length palindrome\\n                cut[i+j+1] = min(cut[i+j+1],1+cut[i-j+1]);\\n        }\\n        return cut[n];\\n    }\\n};\\n \\n```\\n\\n\\nThe definition of \\'cut\\' array is the minimum number of cuts of a sub string. More specifically, cut[n] stores the cut number of string s[0, n-1].\\n\\nHere is the basic idea of the solution:\\n\\n1. Initialize the \\'cut\\' array: For a string with n characters s[0, n-1], it needs at most n-1 cut. Therefore, the \\'cut\\' array is initialized as cut[i] = i-1\\n\\n2. Use two variables in two loops to represent a palindrome:\\nThe external loop variable \\'i\\' represents the center of the palindrome. The internal loop variable \\'j\\' represents the \\'radius\\' of the palindrome. Apparently, j <= i is a must.\\nThis palindrome can then be represented as s[i-j, i+j]. If this string is indeed a palindrome, then one possible value of cut[i+j] is cut[i-j] + 1, where cut[i-j] corresponds to s[0, i-j-1] and 1 correspond to the palindrome s[i-j, i+j];\\n\\nWhen the loops finish, you\\'ll get the answer at cut[s.length].\\n\\n**Time Complexity** - O(n<sup>2</sup>)\\n**Space Complexity** - O(n)\\n\\nThis is most optimised approach because here it is using only O(n) extra space in this approach while in above two approach we used O(n<sup>2</sup>) extra space with same time complexity.",
                "solutionTags": [],
                "code": "```cpp\\nbool isPalindrome(int i, int j, string &s)\\n{\\n    while(i<j)\\n    {\\n        if(s[i]!=s[j]) return false;\\n        i++; j--;\\n    }\\n    return true;\\n}\\nint solve(vector<vector<int>> &dp, int i, int j, string &s)\\n{\\n    if(i>=j) return 0;\\n    if(dp[i][j]!= -1) return dp[i][j];\\n    if( isPalindrome(i, j, s) ) return 0;\\n    int ans = INT_MAX;\\n    for(int k=i;k<j;k++)\\n        ans = min(ans, solve(dp, i, k, s) + solve(dp, k+1, j, s) + 1);\\n    \\n    return dp[i][j] = ans;\\n}\\nint minCut(string s)\\n{\\n    int n = s.size();\\n    vector<vector<int>> dp(n, vector<int>(n, -1));\\n    return solve(dp, 0, n-1, s);\\n}\\n```\n```s(i, k)```\n```s(k+1, j)```\n```cpp\\nclass Solution {\\npublic:\\nbool isPalindrome(vector<vector<int>> &pdp, int i, int j, string &s)\\n{\\n    if(i>j) return 1;\\n    if(i==j) return pdp[i][j] = 1;\\n    if(pdp[i][j] != -1) return pdp[i][j];\\n    if(s[i] != s[j]) return pdp[i][j] = 0;\\n    pdp[i][j] =  isPalindrome(pdp, i+1, j-1, s) ;\\n    return pdp[i][j];\\n}\\nint solve(vector<vector<int>> &dp, int i, int j, string &s, vector<vector<int>> &pdp)\\n{\\n    if(i>=j) return 0;\\n    if(dp[i][j]!= -1) return dp[i][j];\\n    if( pdp[i][j] == 1 ) return dp[i][j] = 0;\\n    int ans = INT_MAX;\\n    for(int k=i;k<j;k++)\\n        if(pdp[i][k])\\n             ans = min(ans, solve(dp, i, k, s, pdp) + solve(dp, k+1, j, s, pdp) + 1);\\n    \\n    return dp[i][j] = ans;\\n}\\nint minCut(string s) \\n{\\n    int n = s.size();\\n    vector<vector<int>> dp(n, vector<int>(n, -1));\\n    vector<vector<int>> pdp(n, vector<int>(n, -1));\\n    for(int i=0;i<n;i++)\\n        for(int j=i;j<n;j++)\\n            isPalindrome(pdp, i, j, s);\\n    return solve(dp, 0, n-1, s, pdp);\\n}\\n};\\n```\n```pdp[i][j]```\n```s(i, j)```\n```cpp\\nclass Solution {\\npublic:\\n    int minCut(string s) {\\n        int n = s.size();\\n        vector<int> cut(n+1, 0);  // number of cuts for the first k characters\\n        for (int i = 0; i <= n; i++) cut[i] = i-1;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; i-j >= 0 && i+j < n && s[i-j]==s[i+j] ; j++) // odd length palindrome\\n                cut[i+j+1] = min(cut[i+j+1],1+cut[i-j]);\\n\\n            for (int j = 1; i-j+1 >= 0 && i+j < n && s[i-j+1] == s[i+j]; j++) // even length palindrome\\n                cut[i+j+1] = min(cut[i+j+1],1+cut[i-j+1]);\\n        }\\n        return cut[n];\\n    }\\n};\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1048290,
                "title": "memoization-simple-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>dp;\\n    vector<vector<int>>palin;\\n    int isPalindrome(string &s,int i,int j) \\n    {\\n        if(i>=j)\\n            return 1;\\n        if(palin[i][j]!=-1)\\n            return palin[i][j];\\n        if(s[i]!=s[j])\\n            return 0;\\n        return palin[i][j]=isPalindrome(s,i+1,j-1);\\n    }\\n    int cut(string &s,int start)\\n    {\\n        if(start>=s.size()-1)\\n            return 0;\\n        if(dp[start]!=-1)\\n            return dp[start];\\n        if(isPalindrome(s,start,s.size()-1))\\n            return dp[start]=0;\\n        int res=INT_MAX;\\n        for(int i=start;i<s.size();i++)\\n        {\\n            if(isPalindrome(s,start,i))\\n                res=min(res,cut(s,i+1)+1);\\n        }\\n        return dp[start]=res;\\n    }\\n    int minCut(string &s) \\n    {\\n        dp.resize(s.size(),-1);\\n        palin.resize(s.size(),vector<int>(s.size(),-1));\\n        return cut(s,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>dp;\\n    vector<vector<int>>palin;\\n    int isPalindrome(string &s,int i,int j) \\n    {\\n        if(i>=j)\\n            return 1;\\n        if(palin[i][j]!=-1)\\n            return palin[i][j];\\n        if(s[i]!=s[j])\\n            return 0;\\n        return palin[i][j]=isPalindrome(s,i+1,j-1);\\n    }\\n    int cut(string &s,int start)\\n    {\\n        if(start>=s.size()-1)\\n            return 0;\\n        if(dp[start]!=-1)\\n            return dp[start];\\n        if(isPalindrome(s,start,s.size()-1))\\n            return dp[start]=0;\\n        int res=INT_MAX;\\n        for(int i=start;i<s.size();i++)\\n        {\\n            if(isPalindrome(s,start,i))\\n                res=min(res,cut(s,i+1)+1);\\n        }\\n        return dp[start]=res;\\n    }\\n    int minCut(string &s) \\n    {\\n        dp.resize(s.size(),-1);\\n        palin.resize(s.size(),vector<int>(s.size(),-1));\\n        return cut(s,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 351235,
                "title": "c-4ms-99-dp-solution",
                "content": "The idea is based on finding the longest palindrome in ```O(n^2)``` time, which is to expand around each character to check for the longest even and odd sized palindrome. \\n\\nThe DP statement can be expressed as: ```dp[j] = min(dp[j], dp[j-i-1] + 1), for all i such that dp[i ... j] is a palindrome```. Thus, we can go through the string from left to right, and then continuously update future positions based on the longest palindrome we can find at current character. \\n\\nFor example, if we have string ```s = aaaba```, and we are at index 1, we can expand to left and right, and see that the longest odd palindrome centered at 1 is 3, so we update ```dp[3]```. We also see the longest even is ```aa```, so we update ```dp[2]```. This is better than simply calculating the \"isPalindrome\" matrix, because we skip over unnecessary checks (if ```s[i ... j]``` is not a palindrome, then ```s[i-1 ... j+1]``` is also not a palindrome, etc.)\\n\\nIn my code, I need to increase indexing into ```dp``` by 1, since I define the ```dp``` array to mean _min cuts required for up to and including ```j```th character_. Based on this, I set ```dp[0] = -1``` because it saves us the trouble of having to check if we are at the 0th character, for which a palindrome would require 0 cuts. Instead, we add 1 as usual, and -1 + 1 = 0, so it works out.\\n\\n```\\nclass Solution {\\npublic:\\n    int minCut(string s) {\\n        const int size = s.size();\\n        vector<int> dp(size+1, 0);\\n        for(int i = 0; i <= size; ++i) dp[i] = i-1;\\n        for(int i = 0; i < size; ++i) {\\n            for(int j = 0; i-j >= 0 && i+j < size && s[i+j] == s[i-j]; ++j)\\n                dp[i+j+1] = min(dp[i+j+1], dp[i-j]+1);\\n            \\n            for(int j = 0; i-j-1 >= 0 && i+j < size && s[i+j] == s[i-j-1]; ++j)\\n                dp[i+j+1] = min(dp[i+j+1], dp[i-j-1]+1);\\n        }\\n        return dp[size];\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "solutionTags": [],
                "code": "```O(n^2)```\n```dp[j] = min(dp[j], dp[j-i-1] + 1), for all i such that dp[i ... j] is a palindrome```\n```s = aaaba```\n```dp[3]```\n```aa```\n```dp[2]```\n```s[i ... j]```\n```s[i-1 ... j+1]```\n```dp```\n```dp```\n```j```\n```dp[0] = -1```\n```\\nclass Solution {\\npublic:\\n    int minCut(string s) {\\n        const int size = s.size();\\n        vector<int> dp(size+1, 0);\\n        for(int i = 0; i <= size; ++i) dp[i] = i-1;\\n        for(int i = 0; i < size; ++i) {\\n            for(int j = 0; i-j >= 0 && i+j < size && s[i+j] == s[i-j]; ++j)\\n                dp[i+j+1] = min(dp[i+j+1], dp[i-j]+1);\\n            \\n            for(int j = 0; i-j-1 >= 0 && i+j < size && s[i+j] == s[i-j-1]; ++j)\\n                dp[i+j+1] = min(dp[i+j+1], dp[i-j-1]+1);\\n        }\\n        return dp[size];\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 42232,
                "title": "my-accepted-simple-dp-python-solution",
                "content": "    class Solution(object):\\n        def minCut(self, s):\\n            \"\"\"\\n            :type s: str\\n            :rtype: int\\n            \"\"\"\\n            n = len(s)\\n            dp = [(i-1) for i in range(n+1)]\\n            for i in range(1,n+1):\\n                for j in range(i):\\n                    temp = s[j:i]\\n                    if temp[:] == temp[::-1]:\\n                        dp[i] = min(dp[i],dp[j] + 1)\\n            return dp[n]",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def minCut(self, s):\\n            \"\"\"\\n            :type s: str\\n            :rtype: int\\n            \"\"\"\\n            n = len(s)\\n            dp = [(i-1) for i in range(n+1)]\\n            for i in range(1,n+1):\\n                for j in range(i):\\n                    temp = s[j:i]\\n                    if temp[:] == temp[::-1]:\\n                        dp[i] = min(dp[i],dp[j] + 1)\\n            return dp[n]",
                "codeTag": "Java"
            },
            {
                "id": 42225,
                "title": "java-dp-recursive-5ms-solution",
                "content": "    public class Solution {\\n    int[] cut;\\n    public int minCut(String s) {\\n        int len=s.length();\\n        char[] tmp=s.toCharArray();\\n        cut=new int[s.length()];\\n        Arrays.fill(cut,Integer.MAX_VALUE);\\n        for(int i=0;i<len;i++)\\n        {\\n            re(tmp,i,i);\\n            re(tmp,i-1,i);\\n        }\\n        return cut[len-1];\\n    }\\n        public void re(char[] s,int start,int end)\\n        {\\n            if(start<0||end>=s.length)return;\\n            if(s[start]==s[end])\\n            {\\n                re(s,start-1,end+1);\\n                int tmp=start==0?0:cut[start-1]+1;\\n    \\t\\t    cut[end]=Math.min(tmp,cut[end]);\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    int[] cut;\\n    public int minCut(String s) {\\n        int len=s.length();\\n        char[] tmp=s.toCharArray();\\n        cut=new int[s.length()];\\n        Arrays.fill(cut,Integer.MAX_VALUE);\\n        for(int i=0;i<len;i++)\\n        {\\n            re(tmp,i,i);\\n            re(tmp,i-1,i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 42236,
                "title": "my-12ms-c-dp-o-n-2-time-and-o-n-space",
                "content": "class Solution {\\npublic:\\n    \\n    int minCut(string s) {\\n        int ans = INT_MAX;\\n        bool why[s.size()];\\n        \\n        int t[s.size()+1];\\n        memset(t,0,sizeof(t));\\n        t[0]=-1;\\n        memset(why,0,sizeof(why));\\n        for(int i = 0;i< s.size();i++){\\n            int tmp = INT_MAX;\\n            for(int j = 0; j<=i;j++){\\n                if(j==i)\\n                    why[i] =true;\\n                else if(j == i-1)\\n                    why[j] = s[i-1] ==s[i];\\n                else\\n                    why[j] = (why[j+1]) &&(s[j] == s[i]);\\n                if(why[j]){\\n                    tmp = min(tmp,t[j]+1);\\n                }\\n            }\\n\\n            \\n            t[i+1] = tmp;\\n        }\\n        return t[s.size()];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int minCut(string s) {\\n        int ans = INT_MAX;\\n        bool why[s.size()];\\n        \\n        int t[s.size()+1];\\n        memset(t,0,sizeof(t));\\n        t[0]=-1;\\n        memset(why,0,sizeof(why));\\n        for(int i = 0;i< s.size();i++){\\n            int tmp = INT_MAX;\\n            for(int j = 0; j<=i;j++){\\n                if(j==i)\\n                    why[i] =true;\\n                else if(j == i-1)\\n                    why[j] = s[i-1] ==s[i];\\n                else\\n                    why[j] = (why[j+1]) &&(s[j] == s[i]);\\n                if(why[j]){\\n                    tmp = min(tmp,t[j]+1);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 42284,
                "title": "o-n-2-tle-palindrome-partitioning-ii",
                "content": "I used DP in 2 dimensional array to solve the palindrome problem and this cut problem. To avoid Arrays.fill(), I let both the value of pal[][] and cut[][] be of  the true value+1. But it goes TLE in the \"apjesgpsxoeiokmqmfgvjslcjukbqxpsobyhjpbgdfruqdkeiszrlmtwgfxyfostpqczidfljwfbbrflkgdvtytbgqalguewnhvvmcgxboycffopmtmhtfizxkmeftcucxpobxmelmjtuzigsxnncxpaibgpuijwhankxbplpyejxmrrjgeoevqozwdtgospohznkoyzocjlracchjqnggbfeebmuvbicbvmpuleywrpzwsihivnrwtxcukwplgtobhgxukwrdlszfaiqxwjvrgxnsveedxseeyeykarqnjrtlaliyudpacctzizcftjlunlgnfwcqqxcqikocqffsjyurzwysfjmswvhbrmshjuzsgpwyubtfbnwajuvrfhlccvfwhxfqthkcwhatktymgxostjlztwdxritygbrbibdgkezvzajizxasjnrcjwzdfvdnwwqeyumkamhzoqhnqjfzwzbixclcxqrtniznemxeahfozp\" case, I used System.currentTimeMillis() and got it's 175ms to 230ms. Are there some more space to make improvement? Thanks. \\n\\n        public static int pal(int i,int j,String s,int[][] pal){\\n\\t\\tif(pal[i][j]!=0)\\n\\t\\t\\treturn pal[i][j];\\n\\t\\t\\n\\t\\tif(j-i<=1){\\n\\t\\t\\tpal[i][j]=2;\\n\\t\\t\\treturn 2;\\n\\t\\t}\\n\\t\\t\\n\\t\\t\\n\\t\\tif(s.charAt(i)==s.charAt(j-1)){\\n\\t\\t\\tpal[i][j]=pal(i+1,j-1,s,pal);\\n\\t\\t\\treturn pal[i][j];\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\tpal[i][j]=1;\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\t}\\n\\t\\n\\tpublic static int cut(int i,int j,String s,int[][] cut,int[][] pal){\\n\\t\\t\\n\\t\\tif(cut[i][j]!=0){\\n\\t\\t\\treturn cut[i][j];\\n\\t\\t}\\n\\t\\tif(pal(i,j,s,pal)==2){\\n\\t\\t\\tcut[i][j]=1;\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\t\\t\\n\\t\\tint min=j-i;\\n\\t\\tint tmp=min;\\n\\t\\tfor(int mid=i+1;mid<j;mid++){\\n\\t\\t\\ttmp=cut(i,mid,s,cut,pal)+cut(mid,j,s,cut,pal);\\n\\t\\t\\tif(tmp<min)\\n\\t\\t\\t\\tmin=tmp;\\n\\t\\t\\tif(tmp==2)\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tcut[i][j]=min;\\n\\t\\t\\n\\t\\treturn min;\\n\\t}\\n\\tpublic static int minCut(String s) {\\n\\t\\tint len=s.length();\\n\\t\\tif(len<=1)\\n\\t\\t\\treturn 0;\\n\\t\\tint pal[][]=new int[len+1][len+1];\\n\\t\\tint cut[][]=new int[len+1][len+1];\\n\\t\\t\\n\\t\\treturn cut(0,len,s,cut,pal)-1;\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "I used DP in 2 dimensional array to solve the palindrome problem and this cut problem. To avoid Arrays.fill(), I let both the value of pal[][] and cut[][] be of  the true value+1. But it goes TLE in the \"apjesgpsxoeiokmqmfgvjslcjukbqxpsobyhjpbgdfruqdkeiszrlmtwgfxyfostpqczidfljwfbbrflkgdvtytbgqalguewnhvvmcgxboycffopmtmhtfizxkmeftcucxpobxmelmjtuzigsxnncxpaibgpuijwhankxbplpyejxmrrjgeoevqozwdtgospohznkoyzocjlracchjqnggbfeebmuvbicbvmpuleywrpzwsihivnrwtxcukwplgtobhgxukwrdlszfaiqxwjvrgxnsveedxseeyeykarqnjrtlaliyudpacctzizcftjlunlgnfwcqqxcqikocqffsjyurzwysfjmswvhbrmshjuzsgpwyubtfbnwajuvrfhlccvfwhxfqthkcwhatktymgxostjlztwdxritygbrbibdgkezvzajizxasjnrcjwzdfvdnwwqeyumkamhzoqhnqjfzwzbixclcxqrtniznemxeahfozp\" case, I used System.currentTimeMillis() and got it's 175ms to 230ms. Are there some more space to make improvement? Thanks. \\n\\n        public static int pal(int i,int j,String s,int[][] pal){\\n\\t\\tif(pal[i][j]!=0)\\n\\t\\t\\treturn pal[i][j];\\n\\t\\t\\n\\t\\tif(j-i<=1){\\n\\t\\t\\tpal[i][j]=2;\\n\\t\\t\\treturn 2;\\n\\t\\t}\\n\\t\\t\\n\\t\\t\\n\\t\\tif(s.charAt(i)==s.charAt(j-1)){\\n\\t\\t\\tpal[i][j]=pal(i+1,j-1,s,pal);\\n\\t\\t\\treturn pal[i][j];\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\tpal[i][j]=1;\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\t}\\n\\t\\n\\tpublic static int cut(int i,int j,String s,int[][] cut,int[][] pal){\\n\\t\\t\\n\\t\\tif(cut[i][j]!=0){\\n\\t\\t\\treturn cut[i][j];\\n\\t\\t}\\n\\t\\tif(pal(i,j,s,pal)==2){\\n\\t\\t\\tcut[i][j]=1;\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\t\\t\\n\\t\\tint min=j-i;\\n\\t\\tint tmp=min;\\n\\t\\tfor(int mid=i+1;mid<j;mid++){\\n\\t\\t\\ttmp=cut(i,mid,s,cut,pal)+cut(mid,j,s,cut,pal);\\n\\t\\t\\tif(tmp<min)\\n\\t\\t\\t\\tmin=tmp;\\n\\t\\t\\tif(tmp==2)\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tcut[i][j]=min;\\n\\t\\t\\n\\t\\treturn min;\\n\\t}\\n\\tpublic static int minCut(String s) {\\n\\t\\tint len=s.length();\\n\\t\\tif(len<=1)\\n\\t\\t\\treturn 0;\\n\\t\\tint pal[][]=new int[len+1][len+1];\\n\\t\\tint cut[][]=new int[len+1][len+1];\\n\\t\\t\\n\\t\\treturn cut(0,len,s,cut,pal)-1;\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4002967,
                "title": "c-recursive-memoization-tabulation-how-to-refrain-mle",
                "content": "Hi all,\\nThis is a basic understanding post on Memory Limit Exceed (MLE) for this question. Last 2 test cases i.e. 36/37 and 37/37 have longer string as input which can give MLE. The savior is \"&\". Yes, passing by reference will reduce unnecessary re-creation of strings which eventually will save from getting MLE. \\n\\nThis might be a small change in your code but it\\'s impact is high. Should also be taken care (whenever necessary) in real world scenarios where we need to optimize our code as a SWE.\\n\\n\\nRecursive:\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s, int left, int right){\\n        while(left<right) if(s[left++]!=s[right--]) return false;\\n        return true;\\n    }\\n    int fn(string s, int n, int ind){\\n        if(ind == n) return -1;\\n        int mini = 1e9;\\n        for(int i = ind;i<n;i++){\\n            if(isPalindrome(s,ind,i)){\\n                int cut = 1+fn(s,n,i+1);\\n                mini = min(mini,cut);\\n            }\\n        }\\n        return mini;\\n    }\\n    int minCut(string s) {\\n        int n = s.size();\\n        return fn(s,n,0);\\n    }\\n};\\n```\\n\\nMemoization:\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string &s, int left, int right){\\n        while(left<right) if(s[left++]!=s[right--]) return false;\\n        return true;\\n    }\\n    int fn(string &s, int n, int ind, vector<int> &dp){\\n        if(ind == n) return -1;\\n        if(dp[ind]!=-1) return dp[ind];\\n        int mini = 1e9;\\n        for(int i = ind;i<n;i++){\\n            if(isPalindrome(s,ind,i)){\\n                int cut = 1+fn(s,n,i+1,dp);\\n                mini = min(mini,cut);\\n            }\\n        }\\n        return dp[ind] = mini;\\n    }\\n    int minCut(string s) {\\n        int n = s.size();\\n        vector<int> dp(n,-1);\\n        return fn(s,n,0,dp);\\n    }\\n};\\n```\\n\\nTabulation:\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string &s, int left, int right){\\n        while(left<right) if(s[left++]!=s[right--]) return false;\\n        return true;\\n\\n    int minCut(string &s) {\\n        int n = s.size();\\n        vector<int> dp(n+1,-1);\\n        for(int ind = n-1;ind>=0;ind--){\\n            int mini = 1e9;\\n            for(int i = ind;i<n;i++){\\n                if(isPalindrome(s,ind,i)){\\n                    int cut = 1+dp[i+1];\\n                    mini = min(mini,cut);\\n                }\\n            }\\n            dp[ind] = mini;\\n        }\\n        return dp[0];\\n    }\\n};\\n```\\n\\nThe small change of passing by reference will do the job!\\n\\nHave a look and do let me know in comments your thoughts. Cheers!",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s, int left, int right){\\n        while(left<right) if(s[left++]!=s[right--]) return false;\\n        return true;\\n    }\\n    int fn(string s, int n, int ind){\\n        if(ind == n) return -1;\\n        int mini = 1e9;\\n        for(int i = ind;i<n;i++){\\n            if(isPalindrome(s,ind,i)){\\n                int cut = 1+fn(s,n,i+1);\\n                mini = min(mini,cut);\\n            }\\n        }\\n        return mini;\\n    }\\n    int minCut(string s) {\\n        int n = s.size();\\n        return fn(s,n,0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string &s, int left, int right){\\n        while(left<right) if(s[left++]!=s[right--]) return false;\\n        return true;\\n    }\\n    int fn(string &s, int n, int ind, vector<int> &dp){\\n        if(ind == n) return -1;\\n        if(dp[ind]!=-1) return dp[ind];\\n        int mini = 1e9;\\n        for(int i = ind;i<n;i++){\\n            if(isPalindrome(s,ind,i)){\\n                int cut = 1+fn(s,n,i+1,dp);\\n                mini = min(mini,cut);\\n            }\\n        }\\n        return dp[ind] = mini;\\n    }\\n    int minCut(string s) {\\n        int n = s.size();\\n        vector<int> dp(n,-1);\\n        return fn(s,n,0,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string &s, int left, int right){\\n        while(left<right) if(s[left++]!=s[right--]) return false;\\n        return true;\\n\\n    int minCut(string &s) {\\n        int n = s.size();\\n        vector<int> dp(n+1,-1);\\n        for(int ind = n-1;ind>=0;ind--){\\n            int mini = 1e9;\\n            for(int i = ind;i<n;i++){\\n                if(isPalindrome(s,ind,i)){\\n                    int cut = 1+dp[i+1];\\n                    mini = min(mini,cut);\\n                }\\n            }\\n            dp[ind] = mini;\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629242,
                "title": "getting-tle-on-last-testcase-36-37-testcases-passed",
                "content": "# 1. Recursive Code [TLE]\\n#### Approach\\n- We will be using the naive recursive approach on the same line as **MCM DP**.\\n- Will be using front **partition DP**.\\n\\n#### Complexity\\n- Time complexity: **~ O(2^n), Highly Exponential**\\n\\n- Space complexity: **O(n)**\\n```\\nclass Solution {\\n    private static boolean isPalindrome(int i, int j, String s){\\n        while(i<j){\\n            if(s.charAt(i)!=s.charAt(j)) return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n\\n    private static int fun(int cut, String s){\\n        // Base Case \\n        if(cut==s.length()) return 0;\\n        \\n        // Code \\n        int minCuts = Integer.MAX_VALUE;\\n        for(int partition=cut;partition<s.length();partition++){\\n            if(isPalindrome(cut,partition,s)){\\n                int cuts = 1 + fun(partition+1,s);\\n                minCuts = Math.min(minCuts,cuts);\\n            }\\n        }\\n        return minCuts;\\n    }\\n\\n    public int minCut(String s){\\n        return fun(0,s)-1;\\n    }\\n}\\n// Recursive Code \\n// Time Complexity : ~ O(2^n), Highly Exponential\\n// Space Complexity : O(n)\\n\\n// s = \"aabb\"\\n// s = \"a\"|\"a\"|\"b\"|\"b\" -> 3 cuts -> so we can say that for every input answer will always exist \\n// s = \"aa\"|\"b\"|\"b\" -> 2 cuts\\n// s = \"a\"|\"a\"|\"bb\" -> 2 cuts\\n// s = \"aa\"|\"bb\" -> 1 cuts (min)\\n\\n// So to find the min number of cuts needed so that every substring will result in a palindrome \\n// We will use the approach of \"Front Partitions\"\\n// s = \"aabb\"\\n// s = \"a\"|\"abb\"\\n// 1. 1 + \"a\"|\"a\"|\"bb\" + 1 + \"aa\"|\"bb\"\\n```\\n---\\n# 2. Memoization Code [TLE]\\n#### Approach\\n- We will memoize the recursive code .\\n\\n#### Complexity\\n- Time complexity: **~ O(n * n * n), Linear Complexity**\\n\\n- Space complexity: **O(n + n)**\\n```\\nclass Solution {\\n    private static boolean isPalindrome(int i, int j, String s){\\n        while(i<j){\\n            if(s.charAt(i)!=s.charAt(j)) return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n\\n    private static int fun(int cut, String s, int[] dp){\\n        // Base Case \\n        if(cut==s.length()) return 0;\\n        \\n        // Code \\n        if(dp[cut]!=-1) return dp[cut];\\n        int minCuts = Integer.MAX_VALUE;\\n        for(int partition=cut;partition<s.length();partition++){\\n            if(isPalindrome(cut,partition,s)){\\n                int cuts = 1 + fun(partition+1,s,dp);\\n                minCuts = Math.min(minCuts,cuts);\\n            }\\n        }\\n        return dp[cut] = minCuts;\\n    }\\n\\n    public int minCut(String s){\\n        int[] dp = new int[s.length()];\\n        Arrays.fill(dp,-1);\\n        return fun(0,s,dp)-1;\\n    }\\n}\\n// Memoization Code \\n// Time Complexity : ~ O(n*n*n), Linear Complexity\\n// Space Complexity : O(n + n)\\n```\\n---\\n# 3. Tabulation Code [TLE]\\n#### Approach\\n- Tabulating the code, in a hope to remove the continous TLE encountered.\\n- But finally we came to know that just optimizing the DP will not work, we have to come up with some other optimization in the time complexity of the code.\\n- Then we observed that we are actually doing the isPalindrome calculation again and again for every other substring we formed but we should observe that it can have many overlapping subproblems which can be memoized in order to optimize the time complexity of the code .\\n\\n#### Complexity\\n- Time complexity: **~ O(n * n * n), Linear Complexity**\\n\\n- Space complexity: **O(n + n)**\\n```\\nclass Solution {\\n    private static boolean isPalindrome(int i, int j, String s){\\n        while(i<=j){\\n            if(s.charAt(i)!=s.charAt(j)) return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n\\n    private static int fun(String s){\\n        int len = s.length();\\n        int[] dp = new int[len+1];\\n        dp[len] = 0;\\n        for(int cut=len-1;cut>=0;cut--){\\n            int minCuts = Integer.MAX_VALUE;\\n            for(int partition=cut;partition<len;partition++){\\n                if(isPalindrome(cut,partition,s)){\\n                    int cuts = 1 + dp[partition+1];\\n                    minCuts = Math.min(minCuts,cuts);\\n                }\\n            }\\n            dp[cut] = minCuts;\\n        }\\n        return dp[0]-1;\\n    }\\n\\n    public int minCut(String s){\\n        return fun(s);\\n    }\\n}\\n// Tabulation Code \\n// Time Complexity : ~ O(n * n * n), Linear Complexity\\n// Space Complexity : O(n + n)\\n\\n```\\n---\\n# 4. Recursive Code With Optimization [Accepted]\\n#### Approach\\n- In our approach 1, 2, and 3 we are running a for loop again and again for every substring to find weather it is a palindrome or not, how ever better approach will be to store the data about the palindrome nature in some other dp in O(n * n) time and then using it directly as and when needed.\\n\\n#### Complexity\\n- Time Complexity : **O(n * n)**\\n- Space Complexity : **O(n + n + n * n)**\\n```\\nclass Solution {\\n    private static void isPalindrome(String s,int[][] isPalindrome){\\n        for(int i=0;i<s.length();i++){\\n            isPalindrome[i][i] = 0;\\n            for(int j=i-1,k=i+1;j>=0&&k<s.length();j--,k++){\\n                if(s.charAt(j)==s.charAt(k)) isPalindrome[j][k] = 0;\\n                else break;\\n            }\\n            for(int j=i,k=i+1;j>=0&&k<s.length();j--,k++){\\n                if(s.charAt(j)==s.charAt(k)) isPalindrome[j][k] = 0;\\n                else break;\\n            }\\n        }\\n    }\\n\\n    private static int fun(int cut, String s, int[] dp, int[][] isPalindrome){\\n        // Base Case \\n        if(cut==s.length()) return 0;\\n        \\n        // Code \\n        if(dp[cut]!=-1) return dp[cut];\\n        int minCuts = Integer.MAX_VALUE;\\n        for(int partition=cut;partition<s.length();partition++){\\n            if(isPalindrome[cut][partition]==0){\\n                int cuts = 1 + fun(partition+1,s,dp,isPalindrome);\\n                minCuts = Math.min(minCuts,cuts);\\n            }\\n        }\\n        return dp[cut] = minCuts;\\n    }\\n\\n    public int minCut(String s){\\n        int[] dp = new int[s.length()];\\n        Arrays.fill(dp,-1);\\n        int[][] isPalindrome = new int[s.length()+1][s.length()+1];\\n        Arrays.stream(isPalindrome).forEach(a -> Arrays.fill(a,-1));\\n        isPalindrome(s,isPalindrome);\\n        return fun(0,s,dp,isPalindrome)-1;\\n    }\\n}\\n// Optimized Memoization Code \\n// Time Complexity : O(n * n)\\n// Space Complexity : O(n + n + n * n)\\n\\n// Over all optimization in the code \\n// In our previous approaches, we were calculating the isPalindrome for every subString again and // again which have many overlapping sub problems...\\n// We optimised out code by memoizing the data about isPalindrome in an dp data structure\\n// isPalindrome[i][j], where isPalindrome[i][j] = 0, s[i...j] is palindrome and \\n// isPalindrome[i][j]=-1, means s[i...j] is not a palindrome.\\n\\n```\\n----\\n# 5. Tabulation Code With Optimization [Accepted]\\n#### Approach\\n- In our approach 1, 2, and 3 we are running a for loop again and again for every substring to find weather it is a palindrome or not, how ever better approach will be to store the data about the palindrome nature in some other dp in O(n * n) time and then using it directly as and when needed.\\n\\n#### Complexity\\n- Time Complexity : **O(n * n)**\\n- Space Complexity : **O(n + n * n)**\\n```\\nclass Solution {\\n    private static void isPalindrome(String s,int[][] isPalindrome){\\n        for(int i=0;i<s.length();i++){\\n            isPalindrome[i][i] = 0;\\n            for(int j=i-1,k=i+1;j>=0&&k<s.length();j--,k++){\\n                if(s.charAt(j)==s.charAt(k)) isPalindrome[j][k] = 0;\\n                else break;\\n            }\\n            for(int j=i,k=i+1;j>=0&&k<s.length();j--,k++){\\n                if(s.charAt(j)==s.charAt(k)) isPalindrome[j][k] = 0;\\n                else break;\\n            }\\n        }\\n    }\\n\\n    private static int fun(String s, int[][] isPalindrome){\\n        int len = s.length();\\n        int[] dp = new int[len+1];\\n        dp[len] = 0;\\n        for(int cut=len-1;cut>=0;cut--){\\n            int minCuts = Integer.MAX_VALUE;\\n            for(int partition=cut;partition<len;partition++){\\n                if(isPalindrome[cut][partition]==0){\\n                    int cuts = 1 + dp[partition+1];\\n                    minCuts = Math.min(minCuts,cuts);\\n                }\\n            }\\n            dp[cut] = minCuts;\\n        }\\n        return dp[0]-1;\\n    }\\n\\n    public int minCut(String s){\\n        int[] dp = new int[s.length()];\\n        Arrays.fill(dp,-1);\\n        int[][] isPalindrome = new int[s.length()][s.length()];\\n        Arrays.stream(isPalindrome).forEach(a -> Arrays.fill(a,-1));\\n        isPalindrome(s,isPalindrome);\\n        return fun(s,isPalindrome);\\n    }\\n}\\n// Optimized Tabulation Code \\n// Time Complexity : O(n * n)\\n// Space Complexity : O(n + n * n)\\n\\n// Over all optimization in the code \\n// In our previous approaches, we were calculating the isPalindrome for every subString again and // again which have many overlapping sub problems...\\n// We optimised out code by memoizing the data about isPalindrome in an dp data structure\\n// isPalindrome[i][j], where isPalindrome[i][j] = 0, s[i...j] is palindrome and \\n// isPalindrome[i][j]=-1, means s[i...j] is not a palindrome.\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private static boolean isPalindrome(int i, int j, String s){\\n        while(i<j){\\n            if(s.charAt(i)!=s.charAt(j)) return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n\\n    private static int fun(int cut, String s){\\n        // Base Case \\n        if(cut==s.length()) return 0;\\n        \\n        // Code \\n        int minCuts = Integer.MAX_VALUE;\\n        for(int partition=cut;partition<s.length();partition++){\\n            if(isPalindrome(cut,partition,s)){\\n                int cuts = 1 + fun(partition+1,s);\\n                minCuts = Math.min(minCuts,cuts);\\n            }\\n        }\\n        return minCuts;\\n    }\\n\\n    public int minCut(String s){\\n        return fun(0,s)-1;\\n    }\\n}\\n// Recursive Code \\n// Time Complexity : ~ O(2^n), Highly Exponential\\n// Space Complexity : O(n)\\n\\n// s = \"aabb\"\\n// s = \"a\"|\"a\"|\"b\"|\"b\" -> 3 cuts -> so we can say that for every input answer will always exist \\n// s = \"aa\"|\"b\"|\"b\" -> 2 cuts\\n// s = \"a\"|\"a\"|\"bb\" -> 2 cuts\\n// s = \"aa\"|\"bb\" -> 1 cuts (min)\\n\\n// So to find the min number of cuts needed so that every substring will result in a palindrome \\n// We will use the approach of \"Front Partitions\"\\n// s = \"aabb\"\\n// s = \"a\"|\"abb\"\\n// 1. 1 + \"a\"|\"a\"|\"bb\" + 1 + \"aa\"|\"bb\"\\n```\n```\\nclass Solution {\\n    private static boolean isPalindrome(int i, int j, String s){\\n        while(i<j){\\n            if(s.charAt(i)!=s.charAt(j)) return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n\\n    private static int fun(int cut, String s, int[] dp){\\n        // Base Case \\n        if(cut==s.length()) return 0;\\n        \\n        // Code \\n        if(dp[cut]!=-1) return dp[cut];\\n        int minCuts = Integer.MAX_VALUE;\\n        for(int partition=cut;partition<s.length();partition++){\\n            if(isPalindrome(cut,partition,s)){\\n                int cuts = 1 + fun(partition+1,s,dp);\\n                minCuts = Math.min(minCuts,cuts);\\n            }\\n        }\\n        return dp[cut] = minCuts;\\n    }\\n\\n    public int minCut(String s){\\n        int[] dp = new int[s.length()];\\n        Arrays.fill(dp,-1);\\n        return fun(0,s,dp)-1;\\n    }\\n}\\n// Memoization Code \\n// Time Complexity : ~ O(n*n*n), Linear Complexity\\n// Space Complexity : O(n + n)\\n```\n```\\nclass Solution {\\n    private static boolean isPalindrome(int i, int j, String s){\\n        while(i<=j){\\n            if(s.charAt(i)!=s.charAt(j)) return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n\\n    private static int fun(String s){\\n        int len = s.length();\\n        int[] dp = new int[len+1];\\n        dp[len] = 0;\\n        for(int cut=len-1;cut>=0;cut--){\\n            int minCuts = Integer.MAX_VALUE;\\n            for(int partition=cut;partition<len;partition++){\\n                if(isPalindrome(cut,partition,s)){\\n                    int cuts = 1 + dp[partition+1];\\n                    minCuts = Math.min(minCuts,cuts);\\n                }\\n            }\\n            dp[cut] = minCuts;\\n        }\\n        return dp[0]-1;\\n    }\\n\\n    public int minCut(String s){\\n        return fun(s);\\n    }\\n}\\n// Tabulation Code \\n// Time Complexity : ~ O(n * n * n), Linear Complexity\\n// Space Complexity : O(n + n)\\n\\n```\n```\\nclass Solution {\\n    private static void isPalindrome(String s,int[][] isPalindrome){\\n        for(int i=0;i<s.length();i++){\\n            isPalindrome[i][i] = 0;\\n            for(int j=i-1,k=i+1;j>=0&&k<s.length();j--,k++){\\n                if(s.charAt(j)==s.charAt(k)) isPalindrome[j][k] = 0;\\n                else break;\\n            }\\n            for(int j=i,k=i+1;j>=0&&k<s.length();j--,k++){\\n                if(s.charAt(j)==s.charAt(k)) isPalindrome[j][k] = 0;\\n                else break;\\n            }\\n        }\\n    }\\n\\n    private static int fun(int cut, String s, int[] dp, int[][] isPalindrome){\\n        // Base Case \\n        if(cut==s.length()) return 0;\\n        \\n        // Code \\n        if(dp[cut]!=-1) return dp[cut];\\n        int minCuts = Integer.MAX_VALUE;\\n        for(int partition=cut;partition<s.length();partition++){\\n            if(isPalindrome[cut][partition]==0){\\n                int cuts = 1 + fun(partition+1,s,dp,isPalindrome);\\n                minCuts = Math.min(minCuts,cuts);\\n            }\\n        }\\n        return dp[cut] = minCuts;\\n    }\\n\\n    public int minCut(String s){\\n        int[] dp = new int[s.length()];\\n        Arrays.fill(dp,-1);\\n        int[][] isPalindrome = new int[s.length()+1][s.length()+1];\\n        Arrays.stream(isPalindrome).forEach(a -> Arrays.fill(a,-1));\\n        isPalindrome(s,isPalindrome);\\n        return fun(0,s,dp,isPalindrome)-1;\\n    }\\n}\\n// Optimized Memoization Code \\n// Time Complexity : O(n * n)\\n// Space Complexity : O(n + n + n * n)\\n\\n// Over all optimization in the code \\n// In our previous approaches, we were calculating the isPalindrome for every subString again and // again which have many overlapping sub problems...\\n// We optimised out code by memoizing the data about isPalindrome in an dp data structure\\n// isPalindrome[i][j], where isPalindrome[i][j] = 0, s[i...j] is palindrome and \\n// isPalindrome[i][j]=-1, means s[i...j] is not a palindrome.\\n\\n```\n```\\nclass Solution {\\n    private static void isPalindrome(String s,int[][] isPalindrome){\\n        for(int i=0;i<s.length();i++){\\n            isPalindrome[i][i] = 0;\\n            for(int j=i-1,k=i+1;j>=0&&k<s.length();j--,k++){\\n                if(s.charAt(j)==s.charAt(k)) isPalindrome[j][k] = 0;\\n                else break;\\n            }\\n            for(int j=i,k=i+1;j>=0&&k<s.length();j--,k++){\\n                if(s.charAt(j)==s.charAt(k)) isPalindrome[j][k] = 0;\\n                else break;\\n            }\\n        }\\n    }\\n\\n    private static int fun(String s, int[][] isPalindrome){\\n        int len = s.length();\\n        int[] dp = new int[len+1];\\n        dp[len] = 0;\\n        for(int cut=len-1;cut>=0;cut--){\\n            int minCuts = Integer.MAX_VALUE;\\n            for(int partition=cut;partition<len;partition++){\\n                if(isPalindrome[cut][partition]==0){\\n                    int cuts = 1 + dp[partition+1];\\n                    minCuts = Math.min(minCuts,cuts);\\n                }\\n            }\\n            dp[cut] = minCuts;\\n        }\\n        return dp[0]-1;\\n    }\\n\\n    public int minCut(String s){\\n        int[] dp = new int[s.length()];\\n        Arrays.fill(dp,-1);\\n        int[][] isPalindrome = new int[s.length()][s.length()];\\n        Arrays.stream(isPalindrome).forEach(a -> Arrays.fill(a,-1));\\n        isPalindrome(s,isPalindrome);\\n        return fun(s,isPalindrome);\\n    }\\n}\\n// Optimized Tabulation Code \\n// Time Complexity : O(n * n)\\n// Space Complexity : O(n + n * n)\\n\\n// Over all optimization in the code \\n// In our previous approaches, we were calculating the isPalindrome for every subString again and // again which have many overlapping sub problems...\\n// We optimised out code by memoizing the data about isPalindrome in an dp data structure\\n// isPalindrome[i][j], where isPalindrome[i][j] = 0, s[i...j] is palindrome and \\n// isPalindrome[i][j]=-1, means s[i...j] is not a palindrome.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200227,
                "title": "132-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo solve this problem, we can use dynamic programming. We can first preprocess the string to determine which substrings are palindromes. Then, we can use dynamic programming to determine the minimum cuts needed to partition the string into palindromic substrings.\\n\\nHere are the steps:\\n\\n1. Preprocess the string to determine which substrings are palindromes. We can use a two-dimensional boolean array to store this information. Specifically, dp[i][j] is True if the substring s[i:j+1] is a palindrome, and False otherwise. To fill in this array, we can use a nested loop to iterate over all possible substrings of s, and use a two-pointer approach to check if each substring is a palindrome.\\n\\n2. Use dynamic programming to determine the minimum cuts needed to partition the string into palindromic substrings. We can use a one-dimensional array cuts to store the minimum cuts needed for the prefix s[0:i]. Specifically, cuts[i] is the minimum number of cuts needed to partition the substring s[0:i] into palindromic substrings. To fill in this array, we can use another nested loop to iterate over all possible lengths j of the last palindrome in the prefix s[0:i]. If the substring s[i-j:i+1] is a palindrome, then we can update the value of cuts[i-j-1] to be the minimum of its current value and cuts[i-j]+1.\\n\\n3. The final answer is stored in cuts[-1].\\n\\nThe time complexity of this algorithm is O(n^2), and the space complexity is O(n^2) as well (for the dp array).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minCut(self, s: str) -> int:\\n        n = len(s)\\n        \\n        # Step 1: Preprocess the string to determine which substrings are palindromes\\n        dp = [[False]*n for _ in range(n)]\\n        for i in range(n):\\n            dp[i][i] = True\\n        for i in range(n-1):\\n            if s[i] == s[i+1]:\\n                dp[i][i+1] = True\\n        for l in range(3, n+1):\\n            for i in range(n-l+1):\\n                j = i+l-1\\n                if s[i] == s[j] and dp[i+1][j-1]:\\n                    dp[i][j] = True\\n        \\n        # Step 2: Use dynamic programming to determine the minimum cuts needed\\n        cuts = list(range(n))\\n        for i in range(1, n):\\n            if dp[0][i]:\\n                cuts[i] = 0\\n            else:\\n                for j in range(i):\\n                    if dp[j+1][i]:\\n                        cuts[i] = min(cuts[i], cuts[j]+1)\\n        \\n        # Step 3: Return the final answer\\n        return cuts[-1]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minCut(self, s: str) -> int:\\n        n = len(s)\\n        \\n        # Step 1: Preprocess the string to determine which substrings are palindromes\\n        dp = [[False]*n for _ in range(n)]\\n        for i in range(n):\\n            dp[i][i] = True\\n        for i in range(n-1):\\n            if s[i] == s[i+1]:\\n                dp[i][i+1] = True\\n        for l in range(3, n+1):\\n            for i in range(n-l+1):\\n                j = i+l-1\\n                if s[i] == s[j] and dp[i+1][j-1]:\\n                    dp[i][j] = True\\n        \\n        # Step 2: Use dynamic programming to determine the minimum cuts needed\\n        cuts = list(range(n))\\n        for i in range(1, n):\\n            if dp[0][i]:\\n                cuts[i] = 0\\n            else:\\n                for j in range(i):\\n                    if dp[j+1][i]:\\n                        cuts[i] = min(cuts[i], cuts[j]+1)\\n        \\n        # Step 3: Return the final answer\\n        return cuts[-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2828264,
                "title": "c-easy-dynamic-programming-recursion-memoization-optimization-mcm-pattern",
                "content": "```\\n// Rercusive Code (TLE)\\n    \\n    bool ispalindrome(string s,int i,int j)\\n    {\\n        while(i <j)\\n        {\\n            if(s[i]!= s[j])\\n                return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    int solve(string s,int i, int j)\\n    {\\n        if(i >= j)\\n            return 0;\\n        if(ispalindrome(s,i,j) == true)\\n            return 0;\\n        int res =  INT_MAX;\\n        for(int k =i; k <= j-1;k++)\\n        {\\n            int temp = 1 + solve(s,i,k)+solve(s,k+1,j);\\n            res = min(res, temp);\\n        }\\n        return res;\\n    }\\n    \\n    int minCut(string s) {\\n        return solve(s,0,s.size()-1);\\n    }\\n\\t\\n// Memoization (TLE)\\n\\n     bool ispalindrome(string s,int i,int j)\\n    {\\n        while(i <j)\\n        {\\n            if(s[i]!= s[j])\\n                return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    \\n    int solve(string s,int i, int j,vector<vector<int>> &dp)\\n    {\\n        if(i >= j)\\n            return 0;\\n        if(ispalindrome(s,i,j) == true)\\n            return 0;\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        int res =  INT_MAX;\\n        for(int k =i; k <= j-1;k++)\\n        {\\n            int temp = 1 + solve(s,i,k,dp)+solve(s,k+1,j,dp);\\n            res = min(res,temp);\\n            dp[i][j]  = res;\\n        }\\n        return dp[i][j];\\n    }\\n    \\n    int minCut(string s) {\\n        int n= s.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        return solve(s,0,s.size()-1,dp);\\n\\t\\t\\n\\t\\t\\n\\t\\t//Optimization (Accepted)  1 D dp\\n\\t\\t\\n\\t\\t bool ispalindrome(string &s,int i,int j)\\n    {\\n        if(i>=j)return true;\\n        while(i <j)\\n        {\\n            if(s[i]!= s[j])\\n                return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    \\n   int solve (string &s, int i, int j, vector<int> & dp){    \\n        \\n        if(i>=j or ispalindrome(s, i, j)) return 0;\\n        \\n        if(dp[i]!=-1) return dp[i];\\n        \\n        int ans = INT_MAX;\\n        \\n        for(int k=i; k<j; k++){\\n            if(ispalindrome(s, i, k)){                         \\n                int temp = solve (s, k+1, j, dp) + 1;\\n                ans = min (ans, temp);\\n            }\\n        }\\n        \\n        return dp[i] = ans;\\n    }\\n    \\n    int minCut(string s) {\\n        int n = s.length();\\n        vector<int> dp (n+1, -1);   \\n        return solve (s, 0, n-1, dp);\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n// Rercusive Code (TLE)\\n    \\n    bool ispalindrome(string s,int i,int j)\\n    {\\n        while(i <j)\\n        {\\n            if(s[i]!= s[j])\\n                return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    int solve(string s,int i, int j)\\n    {\\n        if(i >= j)\\n            return 0;\\n        if(ispalindrome(s,i,j) == true)\\n            return 0;\\n        int res =  INT_MAX;\\n        for(int k =i; k <= j-1;k++)\\n        {\\n            int temp = 1 + solve(s,i,k)+solve(s,k+1,j);\\n            res = min(res, temp);\\n        }\\n        return res;\\n    }\\n    \\n    int minCut(string s) {\\n        return solve(s,0,s.size()-1);\\n    }\\n\\t\\n// Memoization (TLE)\\n\\n     bool ispalindrome(string s,int i,int j)\\n    {\\n        while(i <j)\\n        {\\n            if(s[i]!= s[j])\\n                return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    \\n    int solve(string s,int i, int j,vector<vector<int>> &dp)\\n    {\\n        if(i >= j)\\n            return 0;\\n        if(ispalindrome(s,i,j) == true)\\n            return 0;\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        int res =  INT_MAX;\\n        for(int k =i; k <= j-1;k++)\\n        {\\n            int temp = 1 + solve(s,i,k,dp)+solve(s,k+1,j,dp);\\n            res = min(res,temp);\\n            dp[i][j]  = res;\\n        }\\n        return dp[i][j];\\n    }\\n    \\n    int minCut(string s) {\\n        int n= s.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        return solve(s,0,s.size()-1,dp);\\n\\t\\t\\n\\t\\t\\n\\t\\t//Optimization (Accepted)  1 D dp\\n\\t\\t\\n\\t\\t bool ispalindrome(string &s,int i,int j)\\n    {\\n        if(i>=j)return true;\\n        while(i <j)\\n        {\\n            if(s[i]!= s[j])\\n                return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    \\n   int solve (string &s, int i, int j, vector<int> & dp){    \\n        \\n        if(i>=j or ispalindrome(s, i, j)) return 0;\\n        \\n        if(dp[i]!=-1) return dp[i];\\n        \\n        int ans = INT_MAX;\\n        \\n        for(int k=i; k<j; k++){\\n            if(ispalindrome(s, i, k)){                         \\n                int temp = solve (s, k+1, j, dp) + 1;\\n                ans = min (ans, temp);\\n            }\\n        }\\n        \\n        return dp[i] = ans;\\n    }\\n    \\n    int minCut(string s) {\\n        int n = s.length();\\n        vector<int> dp (n+1, -1);   \\n        return solve (s, 0, n-1, dp);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2812683,
                "title": "python3-solution-dp-o-n-2",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n- Space complexity $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minCut(self, S):\\n        N = len(S)\\n        dp = [-1] + [N] * N\\n        for i in range(2 * N - 1):\\n            l = i // 2\\n            r = l + (i & 1)\\n            while 0 <= l and r < N and S[l] == S[r]:\\n                dp[r + 1] = min(dp[r + 1], dp[l] + 1)\\n                l -= 1\\n                r += 1\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minCut(self, S):\\n        N = len(S)\\n        dp = [-1] + [N] * N\\n        for i in range(2 * N - 1):\\n            l = i // 2\\n            r = l + (i & 1)\\n            while 0 <= l and r < N and S[l] == S[r]:\\n                dp[r + 1] = min(dp[r + 1], dp[l] + 1)\\n                l -= 1\\n                r += 1\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1640931,
                "title": "mcm-pattern-with-some-optimizations-c",
                "content": "\\n\\n    // C++ Solution using Memoization Approach with Optimization, All TC Passed\\n\\t\\n\\t// Check whether the string from index start to end i.e [start, end] is a palindrome or not\\n\\t\\n\\tbool isPalindrome(string &s, int start, int end) {\\n\\t\\t\\n\\t\\twhile(start <= end) {\\n\\t\\t\\tif(s[start++] != s[end--])                               return false;\\n\\t\\t}\\n    \\n        return true;\\n    }\\n    \\n    int mincutHelper(string s, int i, int j, vector<vector<int>> &dp) {\\n        \\n        // Base Condition\\n        \\n        // if string is empty or a single character, then Zero partition\\n        if(i >= j)                                                 return dp[i][j] = 0;\\n\\t\\t\\n\\t\\t// if value already present at index (i, j) in dp, then return the value\\n        if(dp[i][j] != -1)                                         return dp[i][j];\\n        \\n\\t\\t// if substring of s in range [i, j] is a palindrome, the we don\\'t need to do any partition i.e Min partitions  = 0\\n        if(isPalindrome(s, i, j) == true)                          return dp[i][j] = 0;\\n        \\n        int mini = INT_MAX;\\n        \\n        // Run for loop from i to j-1\\n        for(int k=i; k<=j-1; k++) {\\n            \\n\\t\\t\\t// if subtring of s in range [i, k] is a palindrome, then run the recursive function in range [k+1, j]\\n            if(isPalindrome(s, i, k) == true) {            \\n                    mini = min(mini, 1 + mincutHelper(s, k + 1, j, dp));\\n            }\\n        }\\n        \\n        dp[i][j] = mini;\\n        return mini;\\n    }\\n    \\n    int minCut(string s) {\\n    \\n        vector<vector<int>> dp;\\n        \\n        int n = s.length();\\n        if(n == 0)                                              return 0;\\n        \\n        dp.resize(n, vector<int>(n, -1));\\n        \\n        return mincutHelper(s, 0, n-1, dp);\\n    }\\n\\t\\n\\t\\n\\tPlease upvote if you like the solution",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "\\n\\n    // C++ Solution using Memoization Approach with Optimization, All TC Passed\\n\\t\\n\\t// Check whether the string from index start to end i.e [start, end] is a palindrome or not\\n\\t\\n\\tbool isPalindrome(string &s, int start, int end) {\\n\\t\\t\\n\\t\\twhile(start <= end) {\\n\\t\\t\\tif(s[start++] != s[end--])                               return false;\\n\\t\\t}\\n    \\n        return true;\\n    }\\n    \\n    int mincutHelper(string s, int i, int j, vector<vector<int>> &dp) {\\n        \\n        // Base Condition\\n        \\n        // if string is empty or a single character, then Zero partition\\n        if(i >= j)                                                 return dp[i][j] = 0;\\n\\t\\t\\n\\t\\t// if value already present at index (i, j) in dp, then return the value\\n        if(dp[i][j] != -1)                                         return dp[i][j];\\n        \\n\\t\\t// if substring of s in range [i, j] is a palindrome, the we don\\'t need to do any partition i.e Min partitions  = 0\\n        if(isPalindrome(s, i, j) == true)                          return dp[i][j] = 0;\\n        \\n        int mini = INT_MAX;\\n        \\n        // Run for loop from i to j-1\\n        for(int k=i; k<=j-1; k++) {\\n            \\n\\t\\t\\t// if subtring of s in range [i, k] is a palindrome, then run the recursive function in range [k+1, j]\\n            if(isPalindrome(s, i, k) == true) {            \\n                    mini = min(mini, 1 + mincutHelper(s, k + 1, j, dp));\\n            }\\n        }\\n        \\n        dp[i][j] = mini;\\n        return mini;\\n    }\\n    \\n    int minCut(string s) {\\n    \\n        vector<vector<int>> dp;\\n        \\n        int n = s.length();\\n        if(n == 0)                                              return 0;\\n        \\n        dp.resize(n, vector<int>(n, -1));\\n        \\n        return mincutHelper(s, 0, n-1, dp);\\n    }\\n\\t\\n\\t\\n\\tPlease upvote if you like the solution",
                "codeTag": "Unknown"
            },
            {
                "id": 1390641,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string &s, int l, int r) {\\n        while (l < r) {\\n            if (s[l] != s[r])\\n                return false;\\n            l++;\\n            r--;\\n        }\\n        return true;\\n    }\\n    \\n    int minCut(string s) {\\n        int ans = 0;\\n        vector<int> dp(s.length(), INT_MAX);\\n        for (int i = 0; i < s.length(); i++) {\\n            if (isPalindrome(s, 0, i))\\n                dp[i] = 0;\\n            else \\n                dp[i] = dp[i-1] + 1;\\n            for (int j = i; j > 0; j--) {\\n                if (dp[i] == 1)\\n                    break;\\n                if (isPalindrome(s, j, i)) \\n                    dp[i] = min(dp[i], dp[j-1] + 1);\\n            }\\n        }\\n        return dp[s.length()-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string &s, int l, int r) {\\n        while (l < r) {\\n            if (s[l] != s[r])\\n                return false;\\n            l++;\\n            r--;\\n        }\\n        return true;\\n    }\\n    \\n    int minCut(string s) {\\n        int ans = 0;\\n        vector<int> dp(s.length(), INT_MAX);\\n        for (int i = 0; i < s.length(); i++) {\\n            if (isPalindrome(s, 0, i))\\n                dp[i] = 0;\\n            else \\n                dp[i] = dp[i-1] + 1;\\n            for (int j = i; j > 0; j--) {\\n                if (dp[i] == 1)\\n                    break;\\n                if (isPalindrome(s, j, i)) \\n                    dp[i] = min(dp[i], dp[j-1] + 1);\\n            }\\n        }\\n        return dp[s.length()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389130,
                "title": "easy-to-understand-dp-o-n-2-solution-with-detailed-explanation",
                "content": "\\tStep 1: \\n\\t      Create a 2D bool array dp[n][n] where dp[i][j] indicates whether substring [i...j] is a palindrome. \\n\\t\\t  Create an array minCuts[n + 1] which saves the min cuts for the substring [0...n - 1]. \\n\\n\\t      Base case:  - A character is considered a palindrome. \\n                        => dp[i][i] = true for i in range [0, n)\\n                      - Maximum cuts required for the substring [0...i - 1] is i - 1. \\n                    where the string is cut into one-letter substring.\\n                        => minCuts[i] = i - 1 for i in range [0, n]\\n    \\n    Step 2: Handle the case for substring [i...j]:\\n\\t      If s[i] == s[j]:\\n\\t\\t       if the substring is smaller or equal to 2 elements: (j - i) <= 2\\n\\t\\t       If the substring [i + 1... j - 1] is a palindrome.\\n                 => The substring [i...j] is a palindrome => dp[i][j] = true.\\n                 => Recalculate minimum cuts for substring [0...j].\\n\\t\\t\\t\\t\\t\\tMinimum cuts for substring [0...j] is whether:\\n\\t\\t\\t\\t\\t\\t+ The minimum cuts for substring [0...i] + 1 \\n\\t\\t\\t\\t\\t\\t+ The minimum cuts for substring [0...j]\\n\\t\\t\\t\\t\\t\\t=> minCuts[j + 1] = min(minCuts[j + 1], minCuts[i] + 1)  \\n```\\nint minCuts(string &str)\\n{\\n    int size = str.size();\\n    int dp[size][size];\\n    int minCuts[size + 1];\\n    memset(dp, 0, sizeof(dp);\\n    memset(minCuts, 0, sizeof(minCuts));\\n    for (int i = 0; i <= size; ++i)\\n    {\\n        minCuts[i] = i - 1;\\n        if (i < size)\\n           dp[i][i] = true;\\n    }\\n    for (int j = 1; j < size; ++j)\\n    {\\n        for (int i = j; i >= 0; --i)\\n        {\\n            if (str[i] == str[j] and (j - i <= 2 or dp[i + 1][j - 1]))\\n            {\\n                dp[i][j] = true;\\n                minCuts[j + 1] = min(minCuts[j + 1], minCuts[i] + 1);\\n            }\\n        }\\n    }\\n    return minCuts[size];\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint minCuts(string &str)\\n{\\n    int size = str.size();\\n    int dp[size][size];\\n    int minCuts[size + 1];\\n    memset(dp, 0, sizeof(dp);\\n    memset(minCuts, 0, sizeof(minCuts));\\n    for (int i = 0; i <= size; ++i)\\n    {\\n        minCuts[i] = i - 1;\\n        if (i < size)\\n           dp[i][i] = true;\\n    }\\n    for (int j = 1; j < size; ++j)\\n    {\\n        for (int i = j; i >= 0; --i)\\n        {\\n            if (str[i] == str[j] and (j - i <= 2 or dp[i + 1][j - 1]))\\n            {\\n                dp[i][j] = true;\\n                minCuts[j + 1] = min(minCuts[j + 1], minCuts[i] + 1);\\n            }\\n        }\\n    }\\n    return minCuts[size];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1388490,
                "title": "palindrome-partitioning-ii-dp-c-solution-w-approach",
                "content": "This problem is part 2 of the problem- [Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/)\\n\\n**ALGORITHM**\\n* This solution scan the string from `left to right` (for i loop) and only checks those sub-strings centered at s[i] \\n* Once a `non-palindrome string` is found, it will stop and move to `i+1`.  \\n* `minCUTS[i]` is used to save the minimum cuts for `s[0:i-1]`. \\n* For each i, we do two for loops \\n\\t* For j loop- to check if the substrings `s[i-j .. i+j]` (odd-length substring)  \\n\\t* `s[i-j-1.. i+j]` (even-length substring) are palindrome. \\n\\t* By increasing j from 0, we can find all the palindrome sub-strings centered at i and update minCUTS accordingly. \\n* Once we meet one non-palindrome sub-string, we stop for-j loop since we know there no further palindrome substring centered at i. \\n\\t* This helps us avoid unnecessary palindrome substring checks, as we did in the DP algorithm. Therefore, this version is faster.\\n\\n**SOLUTION**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    int minCut(string s) {\\n        int len = s.size();\\n        vector<int> cut(len, 0);\\n        for (int i = 1; i < len; i++) \\n        {\\n            cut[i] = i;\\n        }\\n        for (int i = 1; i < len; i++) \\n        {\\n            for (int j = 0; i-j>=0 && i+j<len && s[i-j]==s[i+j]; j++)  // odd-length substrings\\n            {\\n                cut[i+j] = (i-j==0 ? 0 : min(cut[i+j], cut[i-j-1]+1));\\n            }\\n            for (int j = 0; i-j-1>=0 && i+j<len && s[i-j-1]==s[i+j]; j++)  // even-length substrings\\n            {\\n                cut[i+j] = i-j-1==0 ? 0 : min(cut[i+j], cut[i-j-2]+1);\\n            }\\n        }\\n        return cut[len-1];\\n    }\\n};\\n```\\n**TIME COMPLEXITY: O(N^2)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCut(string s) {\\n        int len = s.size();\\n        vector<int> cut(len, 0);\\n        for (int i = 1; i < len; i++) \\n        {\\n            cut[i] = i;\\n        }\\n        for (int i = 1; i < len; i++) \\n        {\\n            for (int j = 0; i-j>=0 && i+j<len && s[i-j]==s[i+j]; j++)  // odd-length substrings\\n            {\\n                cut[i+j] = (i-j==0 ? 0 : min(cut[i+j], cut[i-j-1]+1));\\n            }\\n            for (int j = 0; i-j-1>=0 && i+j<len && s[i-j-1]==s[i+j]; j++)  // even-length substrings\\n            {\\n                cut[i+j] = i-j-1==0 ? 0 : min(cut[i+j], cut[i-j-2]+1);\\n            }\\n        }\\n        return cut[len-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1388472,
                "title": "short-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCut(string s) {\\n        int n = s.size();\\n        vector<int> cut(n+1, 0);  // number of cuts for the first k characters\\n        for (int i = 0; i <= n; i++) cut[i] = i-1;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; i-j >= 0 && i+j < n && s[i-j]==s[i+j] ; j++) // odd length palindrome\\n                cut[i+j+1] = min(cut[i+j+1],1+cut[i-j]);\\n\\n            for (int j = 1; i-j+1 >= 0 && i+j < n && s[i-j+1] == s[i+j]; j++) // even length palindrome\\n                cut[i+j+1] = min(cut[i+j+1],1+cut[i-j+1]);\\n        }\\n        return cut[n];\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCut(string s) {\\n        int n = s.size();\\n        vector<int> cut(n+1, 0);  // number of cuts for the first k characters\\n        for (int i = 0; i <= n; i++) cut[i] = i-1;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; i-j >= 0 && i+j < n && s[i-j]==s[i+j] ; j++) // odd length palindrome\\n                cut[i+j+1] = min(cut[i+j+1],1+cut[i-j]);\\n\\n            for (int j = 1; i-j+1 >= 0 && i+j < n && s[i-j+1] == s[i+j]; j++) // even length palindrome\\n                cut[i+j+1] = min(cut[i+j+1],1+cut[i-j+1]);\\n        }\\n        return cut[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1058738,
                "title": "java-solution-faster-than-100",
                "content": "JAVA CODE IS:\\n```\\nclass Solution {\\n    public int minCut(String s) {\\n      int n=s.length();\\n      int cuts[]=new int[n];\\n       boolean isPalindrome[][]=new boolean[n][n]; \\n     for(int i=0;i<n;i++){\\n         int minCuts=Integer.MAX_VALUE;\\n       for(int j=i;j>=0;j--){\\n          if(s.charAt(i)==s.charAt(j) && (j+1>=i-1||isPalindrome[j+1][i-1])){\\n              isPalindrome[j][i]=true;\\n            minCuts=Math.min(minCuts,j-1<0 ? 0 : cuts[j-1]+1);  \\n          }  \\n       }\\n       cuts[i]=minCuts;  \\n     }\\n        return cuts[n-1];\\n    }\\n}\\n```\\nTime: O(n^2)\\nSpace : O(n^2)\\n***please,upvote if this is really helpful for you***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minCut(String s) {\\n      int n=s.length();\\n      int cuts[]=new int[n];\\n       boolean isPalindrome[][]=new boolean[n][n]; \\n     for(int i=0;i<n;i++){\\n         int minCuts=Integer.MAX_VALUE;\\n       for(int j=i;j>=0;j--){\\n          if(s.charAt(i)==s.charAt(j) && (j+1>=i-1||isPalindrome[j+1][i-1])){\\n              isPalindrome[j][i]=true;\\n            minCuts=Math.min(minCuts,j-1<0 ? 0 : cuts[j-1]+1);  \\n          }  \\n       }\\n       cuts[i]=minCuts;  \\n     }\\n        return cuts[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 777729,
                "title": "python-easy-simple-dp-solution-time-o-n-2-explanation",
                "content": "1. We require -  \\n\\t1. DP boolean matrix -> dp[i][j] - TRUE if \\'s[i: j + 1]\\' is palindrome, else FALSE\\n\\t2. DP cuts array -> indicates min cuts require till ith entry\\n\\n2. We first find all palindromic substrings. \\n3. For ith column, we check every entry till diagonal element. If dp[j][i] is true, implies \\'s[j: i + 1]\\'\\' is palindrome and\\n we check if we get minimum cuts considering this substring or not  \\n\\n```\\nclass Solution:\\n    def minCut(self, s: str) -> int:\\n        if not s : return 0\\n        \\n        dp = [[True] * len(s) for i in range(len(s))]        # DP Matrix of booleans -> dp[i][j] - TRUE if \\'s[i: j + 1]\\' is palindrome, else FALSE\\n        cuts = [float(\"inf\")] * len(s)                       # DP cuts array -> indicates min cuts require till ith entry\\n        \\n        # We first find all palindromic substrings\\n        for r in range(1, len(s)):\\n            for c in range(len(s) - r):\\n                if not (s[c] == s[c + r] and dp[c + 1][c + r - 1]):\\n                    dp[c][c + r] = False\\n\\n        # For ith column, we check every entry till diagonal element\\n        # If dp[j][i] is true, implies \\'s[j: i + 1]\\'\\' is palindrome and\\n        # we check if we get minimum cuts considering this substring or not  \\n        for i in range(len(s)):\\n            for j in range(i + 1):\\n                if dp[j][i]:\\n                    cuts[i] = min(cuts[i], (cuts[j - 1] + 1) if j - 1 >= 0 else 0)\\n                    \\n        return cuts[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCut(self, s: str) -> int:\\n        if not s : return 0\\n        \\n        dp = [[True] * len(s) for i in range(len(s))]        # DP Matrix of booleans -> dp[i][j] - TRUE if \\'s[i: j + 1]\\' is palindrome, else FALSE\\n        cuts = [float(\"inf\")] * len(s)                       # DP cuts array -> indicates min cuts require till ith entry\\n        \\n        # We first find all palindromic substrings\\n        for r in range(1, len(s)):\\n            for c in range(len(s) - r):\\n                if not (s[c] == s[c + r] and dp[c + 1][c + r - 1]):\\n                    dp[c][c + r] = False\\n\\n        # For ith column, we check every entry till diagonal element\\n        # If dp[j][i] is true, implies \\'s[j: i + 1]\\'\\' is palindrome and\\n        # we check if we get minimum cuts considering this substring or not  \\n        for i in range(len(s)):\\n            for j in range(i + 1):\\n                if dp[j][i]:\\n                    cuts[i] = min(cuts[i], (cuts[j - 1] + 1) if j - 1 >= 0 else 0)\\n                    \\n        return cuts[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 681911,
                "title": "simple-clean-dp-solution-99-45",
                "content": "\\n- **Create a dp array**. This will keep the **minimum number of cuts needed from 0 to that element**.\\n- Initialize it with ```dp[i] = i ``` because in the worst case, we would need to cut in every space between the characters.\\n- Start with every character and **expand the substring around the center** as long as new characters are equal. We need to do it with odd length and even length substrings.\\n- While expanding:\\n\\t- Since we expand only if our expanded substring is a palindrome, we do not need a cut inside our substring. \\n\\t- But, from our dp array definition we need to add the minimum cuts needed from the previous element that our current substring starts. We add that one too.\\n\\n```\\nclass Solution {\\n    \\n    public int minCut(String s) {\\n        if (s.isEmpty()) return 0;\\n        int[] minCuts = new int[s.length()];\\n        for (int i = 0; i < minCuts.length; i++) {\\n            minCuts[i] = i;\\n        }\\n        for (int i = 1; i < s.length(); i++) {\\n            findMin(s, minCuts, i, i);\\n            findMin(s, minCuts, i-1, i);\\n        }\\n        return minCuts[s.length() - 1];\\n    }\\n    \\n    private void findMin(String s, int[] minCuts, int start, int end) {\\n        for (; start >= 0 && end < s.length() && s.charAt(start) == s.charAt(end); start--, end++) {\\n            int newCut = start == 0 ? 0 : minCuts[start - 1] + 1;\\n            minCuts[end] = Math.min(newCut, minCuts[end]);\\n        }\\n    }\\n}\\n```\\n\\t\\t\\t",
                "solutionTags": [],
                "code": "```dp[i] = i ```\n```\\nclass Solution {\\n    \\n    public int minCut(String s) {\\n        if (s.isEmpty()) return 0;\\n        int[] minCuts = new int[s.length()];\\n        for (int i = 0; i < minCuts.length; i++) {\\n            minCuts[i] = i;\\n        }\\n        for (int i = 1; i < s.length(); i++) {\\n            findMin(s, minCuts, i, i);\\n            findMin(s, minCuts, i-1, i);\\n        }\\n        return minCuts[s.length() - 1];\\n    }\\n    \\n    private void findMin(String s, int[] minCuts, int start, int end) {\\n        for (; start >= 0 && end < s.length() && s.charAt(start) == s.charAt(end); start--, end++) {\\n            int newCut = start == 0 ? 0 : minCuts[start - 1] + 1;\\n            minCuts[end] = Math.min(newCut, minCuts[end]);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 668367,
                "title": "java-3-versions-of-the-solusions-easy-to-understand",
                "content": "First, String problems especially palindrome problems, we may consider about DP solusion.\\nSo, how to cut the string?\\n**aabaab aba\\naaba ababa**\\nEach time we cut it, we need to **make sure the right part is a palindrome string**, \\nso the question convert to minCut of left part, such as minCut(aabaa)+1 or minCut(aaba)+1.\\nAs, we can see, we have many choices to cut the right part as a palindrome.\\nWe need to choose the smallest one.\\n\\n```\\n//Accepted\\n    public int minCut3(String s) {\\n\\n        int n=s.length();\\n        if(n<=0) return 0;\\n        int[] dp = new int[n];\\n\\n        for(int i=0;i<n;i++){\\n            int min=i; \\n            \\n            for(int j=0;j<=i;j++){\\n                //only char j == char i, the string[j,i] may be palindrome\\n                if(s.charAt(j)==s.charAt(i)){\\n                    //check substring[j,i]\\n                    if(valid(s.substring(j,i+1))){\\n                        if(j==0) min=0;//j=0 means sub[j,i] is a palindrome do not need to cut\\n                        else min=Math.min(min,dp[j-1]+1); //choose the min cut\\n                    } \\n                }\\n            }\\n            dp[i]=min;\\n        }\\n        \\n        return dp[n-1];\\n    }\\n    \\n    boolean valid(String s){\\n        if(s.length()<=0) return true;\\n        \\n        int left=0;\\n        int right=s.length()-1;\\n        while(left<right){\\n            if(s.charAt(left) != s.charAt(right)) return false; \\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n```\\nThis solusion can be accepted. But we can improve it. \\nAs we can see the method **  boolean valid(String s)** wastes lots of time, we hope to improve it. So, we  pre-calculate all the result of string[i,j]. So when pal[i][j] means string[i,j] is palindrome or not. Of course we need O(n^2) to do this. But when use O(1) to get the result.\\n\\n```\\n   public int minCut2(String s) {\\n        //dp    j   i\\n        //  aba ccdcc fdsafdsaf\\n        //dp[i] = min(dp[j-1]+1) whether string[j,i] is palindrome\\n        int n=s.length();\\n        if(n<=0) return 0;\\n        int[] dp = new int[n];\\n        boolean[][]  pal = isPalindrome(s);    \\n        for(int i=0;i<n;i++){\\n            int min=i; \\n            for(int j=0;j<=i;j++){\\n                //the string[j,i] is palindrome so we can cut here\\n                if(pal[j][i]){                    \\n                    if(j==0) min=0;\\n                    else min=Math.min(min,dp[j-1]+1);    \\n                }\\n            }\\n            dp[i]=min;\\n        }   \\n        return dp[n-1];\\n    }\\n    //calculate all the palindrome from j to i\\n    boolean[][] isPalindrome(String s){\\n        int n=s.length();\\n        boolean[][]  pal =new boolean [n][n];   \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                if(i==j) pal[j][i]=true;\\n                else{\\n                    if(s.charAt(j)==s.charAt(i)){\\n                        if(j+1>=i-1 || pal[j+1][i-1]) pal[j][i]=true;;\\n                    }\\n                }\\n            }       \\n        }      \\n        return pal;\\n    }\\n```\\nThis solusion is faster than the first one.\\nBut we can still improve it. We can calculate the palindrome[][] array and the dp[] reuslt at the same time.\\n```\\n public int minCut(String s) {\\n\\n        int n=s.length();\\n        if(n<=0) return 0;\\n        int[] dp = new int[n];\\n        boolean[][]  pal =new boolean [n][n];\\n       \\n        for(int i=0;i<n;i++){\\n            int min=i; \\n            \\n            for(int j=0;j<=i;j++){\\n                if(s.charAt(j)==s.charAt(i) && (j+1>i-1 || pal[j+1][i-1])){                    \\n                    pal[j][i]=true;\\n                    if(j==0) min=0;\\n                    else min=Math.min(min,dp[j-1]+1);    \\n                }\\n            }\\n            dp[i]=min;\\n        }\\n        \\n        return dp[n-1];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n//Accepted\\n    public int minCut3(String s) {\\n\\n        int n=s.length();\\n        if(n<=0) return 0;\\n        int[] dp = new int[n];\\n\\n        for(int i=0;i<n;i++){\\n            int min=i; \\n            \\n            for(int j=0;j<=i;j++){\\n                //only char j == char i, the string[j,i] may be palindrome\\n                if(s.charAt(j)==s.charAt(i)){\\n                    //check substring[j,i]\\n                    if(valid(s.substring(j,i+1))){\\n                        if(j==0) min=0;//j=0 means sub[j,i] is a palindrome do not need to cut\\n                        else min=Math.min(min,dp[j-1]+1); //choose the min cut\\n                    } \\n                }\\n            }\\n            dp[i]=min;\\n        }\\n        \\n        return dp[n-1];\\n    }\\n    \\n    boolean valid(String s){\\n        if(s.length()<=0) return true;\\n        \\n        int left=0;\\n        int right=s.length()-1;\\n        while(left<right){\\n            if(s.charAt(left) != s.charAt(right)) return false; \\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n```\n```\\n   public int minCut2(String s) {\\n        //dp    j   i\\n        //  aba ccdcc fdsafdsaf\\n        //dp[i] = min(dp[j-1]+1) whether string[j,i] is palindrome\\n        int n=s.length();\\n        if(n<=0) return 0;\\n        int[] dp = new int[n];\\n        boolean[][]  pal = isPalindrome(s);    \\n        for(int i=0;i<n;i++){\\n            int min=i; \\n            for(int j=0;j<=i;j++){\\n                //the string[j,i] is palindrome so we can cut here\\n                if(pal[j][i]){                    \\n                    if(j==0) min=0;\\n                    else min=Math.min(min,dp[j-1]+1);    \\n                }\\n            }\\n            dp[i]=min;\\n        }   \\n        return dp[n-1];\\n    }\\n    //calculate all the palindrome from j to i\\n    boolean[][] isPalindrome(String s){\\n        int n=s.length();\\n        boolean[][]  pal =new boolean [n][n];   \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                if(i==j) pal[j][i]=true;\\n                else{\\n                    if(s.charAt(j)==s.charAt(i)){\\n                        if(j+1>=i-1 || pal[j+1][i-1]) pal[j][i]=true;;\\n                    }\\n                }\\n            }       \\n        }      \\n        return pal;\\n    }\\n```\n```\\n public int minCut(String s) {\\n\\n        int n=s.length();\\n        if(n<=0) return 0;\\n        int[] dp = new int[n];\\n        boolean[][]  pal =new boolean [n][n];\\n       \\n        for(int i=0;i<n;i++){\\n            int min=i; \\n            \\n            for(int j=0;j<=i;j++){\\n                if(s.charAt(j)==s.charAt(i) && (j+1>i-1 || pal[j+1][i-1])){                    \\n                    pal[j][i]=true;\\n                    if(j==0) min=0;\\n                    else min=Math.min(min,dp[j-1]+1);    \\n                }\\n            }\\n            dp[i]=min;\\n        }\\n        \\n        return dp[n-1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 122919,
                "title": "inspired-by-the-top-votes-rewrite-myself-in-java-dp-solution-beats-100",
                "content": "We can have a int[] f, where f[i] means the minumum cuts needed for a palindrome partitioning of s.substring(0, i+1). So we can just return f[len-1]. We can assume the maximum cuts, so the base cases are f[i] = i. (Inspring by LC 5. Longest Palindromic Substring), we can expand from the center to left and right. If s.charAt(left) == s.charAt(right), that means the s.substring.(left, right + 1) is palindrom, then f[right] = f[left - 1] + 1, adding 1 because the substring between left and right needed that 1 cut. And if left == 0, that means s.substring(0, right + 1) is palindrom, so no cut will be needed, so f[right] = 0. We need to consider both even and odd length of the string so we expand from [i, i] and [i, i+1]\\n\\n```java\\nclass Solution {\\n    public int minCut(String s) {\\n        int len = s.length();\\n        int[] f = new int[len];\\n        for (int i = 0; i < len; i++) {\\n            f[i] = i;\\n        }\\n\\n        for (int i = 0; i < len; i++) {\\n            search(s, f, i, i);\\n            search(s, f, i, i + 1);\\n        }\\n\\n        // System.out.println(Arrays.toString(f));\\n        return f[len - 1];\\n    }\\n\\n    private void search(String s, int[] f, int left, int right) {\\n        while (left >= 0 && right < s.length()\\n               && s.charAt(left) == s.charAt(right)) {\\n            if (left == 0) {\\n                // left == 0, substring(0, right+1) is palindrom, no cut needed\\n                f[right] = 0;\\n            } else {\\n                f[right] = Math.min(f[right], f[left - 1] + 1);\\n            }\\n            left--;\\n            right++;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int minCut(String s) {\\n        int len = s.length();\\n        int[] f = new int[len];\\n        for (int i = 0; i < len; i++) {\\n            f[i] = i;\\n        }\\n\\n        for (int i = 0; i < len; i++) {\\n            search(s, f, i, i);\\n            search(s, f, i, i + 1);\\n        }\\n\\n        // System.out.println(Arrays.toString(f));\\n        return f[len - 1];\\n    }\\n\\n    private void search(String s, int[] f, int left, int right) {\\n        while (left >= 0 && right < s.length()\\n               && s.charAt(left) == s.charAt(right)) {\\n            if (left == 0) {\\n                // left == 0, substring(0, right+1) is palindrom, no cut needed\\n                f[right] = 0;\\n            } else {\\n                f[right] = Math.min(f[right], f[left - 1] + 1);\\n            }\\n            left--;\\n            right++;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42228,
                "title": "simple-dp-solution-in-c-but-there-is-still-a-problem-confusing-me-deeply",
                "content": "    class Solution {\\n    public:\\n        int minCut(string s) \\n        {\\n            int sLen = s.length();\\n            bool pal[sLen][sLen];\\n            memset(pal, 0, sizeof(bool)*sLen*sLen);\\n            int minCuts[sLen];\\n            for(int i = sLen-1; i >= 0; --i)\\n            {\\n                minCuts[i] = INT_MAX;\\n                for(int j = i; j < sLen; ++j)\\n                {\\n                    if(s[i]==s[j] && (j-i<2 || pal[i+1][j-1]))\\n                    {\\n                        pal[i][j] = 1;\\n                        if(j == sLen-1) minCuts[i] = 0;\\n                        else minCuts[i] = min(minCuts[i], minCuts[j+1]+1);\\n                    }\\n                }\\n            }\\n            return minCuts[0];\\n        }\\n    };\\n\\nThe code above is accepted but if I change the <font color=\"ff0000\">**pal**</font> as follows:\\n\\n>int pal[sLen][sLen];\\n\\n>memset(pal, 0, sizeof(int)*sLen*sLen);\\n\\nThe OJ will run into RE(Runtime Error), what the hell? \\n\\nTotally beyond me now, could anyone be so kind to explain a little bit about this? Completely at a loss now.\\n\\n> I'll appreciate it if you could do me this favour, thanks in advance!",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int minCut(string s) \\n        {\\n            int sLen = s.length();\\n            bool pal[sLen][sLen];\\n            memset(pal, 0, sizeof(bool)*sLen*sLen);\\n            int minCuts[sLen];\\n            for(int i = sLen-1; i >= 0; --i)\\n            {\\n                minCuts[i] = INT_MAX;\\n                for(int j = i; j < sLen; ++j)\\n                {\\n                    if(s[i]==s[j] && (j-i<2 || pal[i+1][j-1]))\\n                    {\\n                        pal[i][j] = 1;\\n                        if(j == sLen-1) minCuts[i] = 0;\\n                        else minCuts[i] = min(minCuts[i], minCuts[j+1]+1);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3662263,
                "title": "c-naive-and-optimized-approach",
                "content": "# Intuition\\nThe key intuition behind the solution is to build a table, isPal, that stores whether each substring is a palindrome or not. This table allows us to quickly check whether a substring is a palindrome or not without redundant computations.\\n# Approach\\nWe start by initializing isPal[i][i] as true for all single characters in the string. Then, we iteratively fill in the table for longer substrings. For each substring of length len, we check if the first and last characters match and whether the substring inside (excluding the first and last characters) is also a palindrome. If both conditions are met, we mark isPal[i][j] as true.\\n\\nAfter building the isPal table, we initialize the dp array. dp[i] represents the minimum number of cuts needed for the substring s[0:i]. We initialize it with the worst-case scenario, where each character is treated as a separate palindrome, so dp[i] = i.\\n\\nNext, we iterate through the string from left to right. For each index i, we check if the substring s[0:i] itself is a palindrome (isPal[0][i]). If it is, no cuts are needed, so we set dp[i] to 0. Otherwise, we search for a partition point j such that the substring s[j+1:i] is a palindrome. We update dp[i] as the minimum of its current value and dp[j] + 1. This means we consider the minimum cuts needed for the substring s[0:j] and add one more cut to separate the palindrome s[j+1:i] from the rest of the string.\\n\\nFinally, we return dp[n - 1], where n is the length of the input string. This represents the minimum number of cuts needed to partition the entire string into palindromic substrings\\n\\n# Complexity\\n- Time complexity:O(n^2)\\nwhere n is the length of the input string. This is because we iterate through the string twice: once to fill in the isPal table, which takes O(n^2) time, and again to compute the minimum cuts using the dp array, which also takes O(n^2) time.\\n\\n- Space complexity:O(n^2)\\nThis is because we use a 2D vector isPal of size n x n to store the palindrome information for each substring. Additionally, we use a 1D array dp of size n to store the minimum cuts for each substring.\\n# Code\\n```\\n// class Solution {\\n// public:\\n//     int dp[2001][2001];\\n//     bool isPalindrome(string s,int i,int j){\\n//         while(i<j){\\n//             if(s[i]!=s[j]){\\n//                 return false;\\n//             }\\n//             else {\\n//                 i++;\\n//                 j--;\\n//             }\\n//         }\\n//         return true;\\n \\n//     }\\n//     int solve(string s,int i,int j){\\n//         if(i>=j){\\n//             return 0;\\n//         }\\n//         if(dp[i][j]!=-1){\\n//             return dp[i][j];\\n//         }\\n//         if(isPalindrome(s,i,j)){\\n//             return 0;\\n//         }\\n//         int ans=INT_MAX;\\n//         for(int k=i;k<j;k++){\\n//             int temp=1+solve(s,i,k)+solve(s,k+1,j);\\n//             dp[i][j]=ans=min(ans,temp);\\n//         }\\n//         return dp[i][j];\\n//     }\\n//     int minCut(string s) {\\n//         int n=s.length();\\n//         memset(dp,-1,sizeof(dp));\\n//         int ans=solve(s,0,n-1);\\n//         return ans;\\n        \\n//     }\\n// };\\n\\nclass Solution {\\npublic:\\n    int dp[2001];\\n    bool isPalindrome(const std::string& s, int i, int j) {\\n        while (i < j) {\\n            if (s[i] != s[j]) {\\n                return false;\\n            } else {\\n                i++;\\n                j--;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    int minCut(const std::string& s) {\\n        int n = s.length();\\n        std::vector<std::vector<bool>> isPal(n, std::vector<bool>(n, false));\\n\\n        for (int i = 0; i < n; i++) {\\n            isPal[i][i] = true;\\n        }\\n\\n        for (int len = 2; len <= n; len++) {\\n            for (int i = 0; i <= n - len; i++) {\\n                int j = i + len - 1;\\n                if (s[i] == s[j] && (len == 2 || isPal[i + 1][j - 1])) {\\n                    isPal[i][j] = true;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            dp[i] = i;  // Maximum possible cuts for the substring s[0:i]\\n        }\\n\\n        for (int i = 1; i < n; i++) {\\n            if (isPal[0][i]) {\\n                dp[i] = 0;\\n            } else {\\n                for (int j = 0; j < i; j++) {\\n                    if (isPal[j + 1][i]) {\\n                        dp[i] = std::min(dp[i], dp[j] + 1);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[n - 1];\\n    }\\n};\\n```\\n# Please Upvote If found helpful",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n// class Solution {\\n// public:\\n//     int dp[2001][2001];\\n//     bool isPalindrome(string s,int i,int j){\\n//         while(i<j){\\n//             if(s[i]!=s[j]){\\n//                 return false;\\n//             }\\n//             else {\\n//                 i++;\\n//                 j--;\\n//             }\\n//         }\\n//         return true;\\n \\n//     }\\n//     int solve(string s,int i,int j){\\n//         if(i>=j){\\n//             return 0;\\n//         }\\n//         if(dp[i][j]!=-1){\\n//             return dp[i][j];\\n//         }\\n//         if(isPalindrome(s,i,j)){\\n//             return 0;\\n//         }\\n//         int ans=INT_MAX;\\n//         for(int k=i;k<j;k++){\\n//             int temp=1+solve(s,i,k)+solve(s,k+1,j);\\n//             dp[i][j]=ans=min(ans,temp);\\n//         }\\n//         return dp[i][j];\\n//     }\\n//     int minCut(string s) {\\n//         int n=s.length();\\n//         memset(dp,-1,sizeof(dp));\\n//         int ans=solve(s,0,n-1);\\n//         return ans;\\n        \\n//     }\\n// };\\n\\nclass Solution {\\npublic:\\n    int dp[2001];\\n    bool isPalindrome(const std::string& s, int i, int j) {\\n        while (i < j) {\\n            if (s[i] != s[j]) {\\n                return false;\\n            } else {\\n                i++;\\n                j--;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    int minCut(const std::string& s) {\\n        int n = s.length();\\n        std::vector<std::vector<bool>> isPal(n, std::vector<bool>(n, false));\\n\\n        for (int i = 0; i < n; i++) {\\n            isPal[i][i] = true;\\n        }\\n\\n        for (int len = 2; len <= n; len++) {\\n            for (int i = 0; i <= n - len; i++) {\\n                int j = i + len - 1;\\n                if (s[i] == s[j] && (len == 2 || isPal[i + 1][j - 1])) {\\n                    isPal[i][j] = true;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            dp[i] = i;  // Maximum possible cuts for the substring s[0:i]\\n        }\\n\\n        for (int i = 1; i < n; i++) {\\n            if (isPal[0][i]) {\\n                dp[i] = 0;\\n            } else {\\n                for (int j = 0; j < i; j++) {\\n                    if (isPal[j + 1][i]) {\\n                        dp[i] = std::min(dp[i], dp[j] + 1);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080068,
                "title": "python-simple-top-down-dp-solution-o-n-2",
                "content": "# Approach\\nWe first precompute the valid palindromes from start to end value. We use the idea that if s[i:j] is a palindrome, then s[i+1:j-1] must be a palindrome and s[i] must equal s[j]. After this our recursive function will just iterate through the string from the previous cut to the end and perform a cut at every valid index.\\n\\n# Code\\n```\\nclass Solution:\\n    def minCut(self, s: str) -> int:\\n        dp = [[0 for _ in range(len(s))] for _ in range(len(s))]\\n        for length in range(len(s)):\\n            for start in range(len(s)-length):\\n                if length == 0 or (s[start] == s[start+length] and (dp[start+1][start+1+length-2] or length == 1)):\\n                    dp[start][start+length] = 1\\n                else:\\n                    dp[start][start+length] = 0\\n\\n        @functools.cache\\n        def minPalindromes(prevCut):\\n            if prevCut == len(s):\\n                return 0\\n            cut = math.inf\\n            for x in range(prevCut, len(s)):\\n                if dp[prevCut][x]:\\n                    cut = min(cut, minPalindromes(x+1))\\n            return cut+1\\n        return minPalindromes(0)-1\\n        \\n```\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n    - precomputing palindromes and the recursive helper are both O(N^2)\\n\\n- Space complexity: O(N^2)\\n    - recursive stack and dp array use O(N^2) space each",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minCut(self, s: str) -> int:\\n        dp = [[0 for _ in range(len(s))] for _ in range(len(s))]\\n        for length in range(len(s)):\\n            for start in range(len(s)-length):\\n                if length == 0 or (s[start] == s[start+length] and (dp[start+1][start+1+length-2] or length == 1)):\\n                    dp[start][start+length] = 1\\n                else:\\n                    dp[start][start+length] = 0\\n\\n        @functools.cache\\n        def minPalindromes(prevCut):\\n            if prevCut == len(s):\\n                return 0\\n            cut = math.inf\\n            for x in range(prevCut, len(s)):\\n                if dp[prevCut][x]:\\n                    cut = min(cut, minPalindromes(x+1))\\n            return cut+1\\n        return minPalindromes(0)-1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2751245,
                "title": "c-easy-fast-dp-tabulation",
                "content": "#easy to understand \\n```\\nclass Solution {\\n    int solve(int index,int &n,string &s,vector<int> & dp,vector<vector<bool>> &pl){\\n        if(index==n){\\n            return 0;\\n        }\\n        if(dp[index]!=(-1)){return dp[index];}\\n        int ans=INT_MAX; \\n        for(int i=index;i<n;i++){\\n               if(pl[index][i]){\\n                    ans=min(solve(i+1,n,s,dp,pl)+1,ans);\\n               }\\n            \\n        }\\n        return dp[index]=ans;\\n     }\\npublic:\\n    int minCut(string s) {\\n        int n=s.length(); \\n        vector<vector<bool>> pl(n,vector<bool>(n,0));\\n        //finding every palindromic substring from s\\n        //tabulation method\\n        //every single character is a palindrome \\n        for(int i=0;i<n;i++){\\n            pl[i][i]=1;\\n        }\\n        //if both char are same then palindromic substring\\n        if(n>=2){\\n            for(int i=0;i<(n-1);i++){\\n                if(s[i]==s[i+1]){pl[i][i+1]=1;}\\n                else{pl[i][i+1]=0;}\\n            }\\n        }\\n        int gap=2;\\n        while(gap<n){\\n            for(int i=0;i<(n-gap);i++){\\n                if(s[i]==s[i+gap] and pl[i+1][i+gap-1]==1){\\n                    pl[i][i+gap]=1;\\n                }\\n                else{ pl[i][i+gap]=0;}\\n            }\\n            gap++;\\n        }\\n        //dp vector\\n        vector<int> dp(n+1,-1);\\n        return solve(0,n,s,dp,pl)-1;\\n    }\\n};\\n***please upvote if you like the solution.***",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    int solve(int index,int &n,string &s,vector<int> & dp,vector<vector<bool>> &pl){\\n        if(index==n){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2727626,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int dp[2005];\\n    \\n    vector<vector<bool>> is_palin;\\n    \\n    \\n    void fill_palin(string str)\\n    {\\n        int n = str.size();\\n        \\n        for(int gap = 0; gap < n; gap++)\\n        {\\n            for(int i = 0; i + gap < n; i++)\\n            {\\n                int j = i + gap;\\n                \\n                if(gap == 0)\\n                {\\n                    is_palin[i][j] = true;\\n                }\\n                else if(gap == 1)\\n                {\\n                    is_palin[i][j] = (str[i] == str[j]);\\n                }\\n                else\\n                {\\n                    if(str[i] == str[j])\\n                    {\\n                        is_palin[i][j] = is_palin[i + 1][j - 1];\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    int helper(string& str, int i, int n)\\n    {\\n        \\n        if(i == n)\\n            return 0;\\n        \\n        \\n        if(dp[i] != -1)\\n        {\\n            return dp[i];\\n        }\\n        \\n        \\n        int mini = INT_MAX;\\n        \\n        for(int j = i; j < n; j++)\\n        {\\n            if(is_palin[i][j])\\n            {\\n                mini = min(mini, 1 + helper(str, j + 1, n));\\n            }\\n        }\\n        \\n        \\n        return dp[i] = mini;\\n    }\\n    \\n    int minCut(string str) {\\n        \\n        int n = str.size();\\n        \\n        \\n        \\n        \\n        is_palin.resize(n);\\n        \\n        is_palin.assign(n, vector<bool> (n, false));\\n        \\n        \\n        fill_palin(str);\\n        \\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        return helper(str, 0, n) - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int dp[2005];\\n    \\n    vector<vector<bool>> is_palin;\\n    \\n    \\n    void fill_palin(string str)\\n    {\\n        int n = str.size();\\n        \\n        for(int gap = 0; gap < n; gap++)\\n        {\\n            for(int i = 0; i + gap < n; i++)\\n            {\\n                int j = i + gap;\\n                \\n                if(gap == 0)\\n                {\\n                    is_palin[i][j] = true;\\n                }\\n                else if(gap == 1)\\n                {\\n                    is_palin[i][j] = (str[i] == str[j]);\\n                }\\n                else\\n                {\\n                    if(str[i] == str[j])\\n                    {\\n                        is_palin[i][j] = is_palin[i + 1][j - 1];\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    int helper(string& str, int i, int n)\\n    {\\n        \\n        if(i == n)\\n            return 0;\\n        \\n        \\n        if(dp[i] != -1)\\n        {\\n            return dp[i];\\n        }\\n        \\n        \\n        int mini = INT_MAX;\\n        \\n        for(int j = i; j < n; j++)\\n        {\\n            if(is_palin[i][j])\\n            {\\n                mini = min(mini, 1 + helper(str, j + 1, n));\\n            }\\n        }\\n        \\n        \\n        return dp[i] = mini;\\n    }\\n    \\n    int minCut(string str) {\\n        \\n        int n = str.size();\\n        \\n        \\n        \\n        \\n        is_palin.resize(n);\\n        \\n        is_palin.assign(n, vector<bool> (n, false));\\n        \\n        \\n        fill_palin(str);\\n        \\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        return helper(str, 0, n) - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2668672,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Recursion && Memoization***\\n\\n* ***Time Complexity :- O(N * N)***\\n\\n* ***Space Complexity :- O(N * N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // declare a dp\\n    \\n    int dp[2005];\\n    \\n    vector<vector<bool>> is_palin;\\n    \\n    // fill palin\\n    \\n    void fill_palin(string str)\\n    {\\n        int n = str.size();\\n        \\n        for(int gap = 0; gap < n; gap++)\\n        {\\n            for(int i = 0; i + gap < n; i++)\\n            {\\n                int j = i + gap;\\n                \\n                if(gap == 0)\\n                {\\n                    is_palin[i][j] = true;\\n                }\\n                else if(gap == 1)\\n                {\\n                    is_palin[i][j] = (str[i] == str[j]);\\n                }\\n                else\\n                {\\n                    if(str[i] == str[j])\\n                    {\\n                        is_palin[i][j] = is_palin[i + 1][j - 1];\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    int helper(string& str, int i, int n)\\n    {\\n        // base case\\n        \\n        if(i == n)\\n            return 0;\\n        \\n        // if already calculated\\n        \\n        if(dp[i] != -1)\\n        {\\n            return dp[i];\\n        }\\n        \\n        // cut the string where we are getting palindrome and call for next\\n        \\n        int mini = INT_MAX;\\n        \\n        for(int j = i; j < n; j++)\\n        {\\n            if(is_palin[i][j])\\n            {\\n                mini = min(mini, 1 + helper(str, j + 1, n));\\n            }\\n        }\\n        \\n        // store the res and return it\\n        \\n        return dp[i] = mini;\\n    }\\n    \\n    int minCut(string str) {\\n        \\n        int n = str.size();\\n        \\n        // is_palin will store that substring between [i, j] is palindrome or not\\n        \\n        // so that we do not have to run palindrome checking function every time\\n        \\n        // this will help in reducing time complexity, now we will always check in O(1)\\n        \\n        is_palin.resize(n);\\n        \\n        is_palin.assign(n, vector<bool> (n, false));\\n        \\n        // fill palin \\n        \\n        fill_palin(str);\\n        \\n        // declare a dp with -1\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        return helper(str, 0, n) - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // declare a dp\\n    \\n    int dp[2005];\\n    \\n    vector<vector<bool>> is_palin;\\n    \\n    // fill palin\\n    \\n    void fill_palin(string str)\\n    {\\n        int n = str.size();\\n        \\n        for(int gap = 0; gap < n; gap++)\\n        {\\n            for(int i = 0; i + gap < n; i++)\\n            {\\n                int j = i + gap;\\n                \\n                if(gap == 0)\\n                {\\n                    is_palin[i][j] = true;\\n                }\\n                else if(gap == 1)\\n                {\\n                    is_palin[i][j] = (str[i] == str[j]);\\n                }\\n                else\\n                {\\n                    if(str[i] == str[j])\\n                    {\\n                        is_palin[i][j] = is_palin[i + 1][j - 1];\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    int helper(string& str, int i, int n)\\n    {\\n        // base case\\n        \\n        if(i == n)\\n            return 0;\\n        \\n        // if already calculated\\n        \\n        if(dp[i] != -1)\\n        {\\n            return dp[i];\\n        }\\n        \\n        // cut the string where we are getting palindrome and call for next\\n        \\n        int mini = INT_MAX;\\n        \\n        for(int j = i; j < n; j++)\\n        {\\n            if(is_palin[i][j])\\n            {\\n                mini = min(mini, 1 + helper(str, j + 1, n));\\n            }\\n        }\\n        \\n        // store the res and return it\\n        \\n        return dp[i] = mini;\\n    }\\n    \\n    int minCut(string str) {\\n        \\n        int n = str.size();\\n        \\n        // is_palin will store that substring between [i, j] is palindrome or not\\n        \\n        // so that we do not have to run palindrome checking function every time\\n        \\n        // this will help in reducing time complexity, now we will always check in O(1)\\n        \\n        is_palin.resize(n);\\n        \\n        is_palin.assign(n, vector<bool> (n, false));\\n        \\n        // fill palin \\n        \\n        fill_palin(str);\\n        \\n        // declare a dp with -1\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        return helper(str, 0, n) - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2577217,
                "title": "c-mcm-recursion-memoization-most-optimised-begineers-to-adv",
                "content": "```\\nRecursion\\nclass Solution {\\npublic:\\n    //int dp[2001][2001];\\n    bool isPal(string &s,int i,int j){\\n        if(i>=j)return true;\\n        while(i<j){\\n            if(s[i++]!=s[j--])return false;\\n        }\\n        return true;\\n    }\\n    int solve(string &s,int i,int j){\\n        if(i>=j || isPal(s,i,j))return 0;\\n        int ans=INT_MAX;\\n        for(int k=i;k<=j-1;k++){\\n            int left,right;\\n                left=solve(s,i,k);\\n                right=solve(s,k+1,j);    \\n            int temp=1+left+right;\\n            ans=min(ans,temp);\\n        }\\n        return ans;\\n    }\\n    int minCut(string s) {\\n        int n=s.size();\\n       // memset(dp,-1,sizeof(dp));\\n        return solve(s,0,n-1);\\n    }\\n};\\n\\n```\\n\\n```\\nmemoization:-\\nclass Solution {\\npublic:\\n    int dp[2001][2001];\\n    bool isPal(string &s,int i,int j){\\n        if(i>=j)return true;\\n        while(i<j){\\n            if(s[i++]!=s[j--])return false;\\n        }\\n        return true;\\n    }\\n    int solve(string &s,int i,int j){\\n        if(i>=j || isPal(s,i,j))return 0;\\n        int ans=INT_MAX;\\n\\t\\tif(dp[i][j]!=-1)return dp[i][j];\\n        for(int k=i;k<=j-1;k++){\\n            int left,right;\\n                left=solve(s,i,k);\\n                right=solve(s,k+1,j);    \\n            int temp=1+left+right;\\n            ans=min(ans,temp);\\n        }\\n        return dp[i][j]=ans;\\n    }\\n    int minCut(string s) {\\n        int n=s.size();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(s,0,n-1);\\n    }\\n```\\n\\n```\\nFurther\\nMemoization:-(In for loop checking for the subproblems already calculated or not )\\nclass Solution {\\npublic:\\n    int dp[2001][2001];\\n    bool isPal(string &s,int i,int j){\\n        if(i>=j)return true;\\n        while(i<j){\\n            if(s[i++]!=s[j--])return false;\\n        }\\n        return true;\\n    }\\n    int solve(string &s,int i,int j){\\n        if(i>=j || isPal(s,i,j))return 0;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        int ans=INT_MAX;\\n        for(int k=i;k<=j-1;k++){\\n            int left,right;\\n            if(dp[i][k]!=-1)left=dp[i][k];\\n            else{\\n                left=solve(s,i,k);\\n                dp[i][k]=left;\\n            }\\n            if(dp[k+1][j]!=-1)right=dp[k+1][j];\\n            else{\\n                right=solve(s,k+1,j);\\n                dp[k+1][j]=right;\\n            }\\n            int temp=1+left+right;\\n            ans=min(ans,temp);\\n        }\\n        return dp[i][j]=ans;\\n    }\\n    int minCut(string s) {\\n        int n=s.size();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(s,0,n-1);\\n    }\\n};\\n\\n```\\n\\n```\\nMost optimised :-(memoization) => We know that in worst case, total cuts=(n-1) i.e. size -1, checking only if 1st part is Palindrome (then it gives zero cuts, else gives k-1 cuts at that particular point), then check for the other part by calling solve function\\n\\nclass Solution {\\npublic:\\n    int dp[2001][2001];\\n    bool isPal(string &s,int i,int j){\\n        if(i>=j)return true;\\n        while(i<j){\\n            if(s[i++]!=s[j--])return false;\\n        }\\n        return true;\\n    }\\n    int solve(string &s,int i,int j){\\n        if(i>=j || isPal(s,i,j))return 0;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        int ans=INT_MAX;\\n        for(int k=i;k<=j-1;k++){\\n            if(isPal(s,i,k)){\\n                ans=min(ans,1+solve(s,k+1,j));\\n            }\\n        }\\n        return dp[i][j]=ans;\\n    }\\n    int minCut(string s) {\\n        int n=s.size();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(s,0,n-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nRecursion\\nclass Solution {\\npublic:\\n    //int dp[2001][2001];\\n    bool isPal(string &s,int i,int j){\\n        if(i>=j)return true;\\n        while(i<j){\\n            if(s[i++]!=s[j--])return false;\\n        }\\n        return true;\\n    }\\n    int solve(string &s,int i,int j){\\n        if(i>=j || isPal(s,i,j))return 0;\\n        int ans=INT_MAX;\\n        for(int k=i;k<=j-1;k++){\\n            int left,right;\\n                left=solve(s,i,k);\\n                right=solve(s,k+1,j);    \\n            int temp=1+left+right;\\n            ans=min(ans,temp);\\n        }\\n        return ans;\\n    }\\n    int minCut(string s) {\\n        int n=s.size();\\n       // memset(dp,-1,sizeof(dp));\\n        return solve(s,0,n-1);\\n    }\\n};\\n\\n```\n```\\nmemoization:-\\nclass Solution {\\npublic:\\n    int dp[2001][2001];\\n    bool isPal(string &s,int i,int j){\\n        if(i>=j)return true;\\n        while(i<j){\\n            if(s[i++]!=s[j--])return false;\\n        }\\n        return true;\\n    }\\n    int solve(string &s,int i,int j){\\n        if(i>=j || isPal(s,i,j))return 0;\\n        int ans=INT_MAX;\\n\\t\\tif(dp[i][j]!=-1)return dp[i][j];\\n        for(int k=i;k<=j-1;k++){\\n            int left,right;\\n                left=solve(s,i,k);\\n                right=solve(s,k+1,j);    \\n            int temp=1+left+right;\\n            ans=min(ans,temp);\\n        }\\n        return dp[i][j]=ans;\\n    }\\n    int minCut(string s) {\\n        int n=s.size();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(s,0,n-1);\\n    }\\n```\n```\\nFurther\\nMemoization:-(In for loop checking for the subproblems already calculated or not )\\nclass Solution {\\npublic:\\n    int dp[2001][2001];\\n    bool isPal(string &s,int i,int j){\\n        if(i>=j)return true;\\n        while(i<j){\\n            if(s[i++]!=s[j--])return false;\\n        }\\n        return true;\\n    }\\n    int solve(string &s,int i,int j){\\n        if(i>=j || isPal(s,i,j))return 0;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        int ans=INT_MAX;\\n        for(int k=i;k<=j-1;k++){\\n            int left,right;\\n            if(dp[i][k]!=-1)left=dp[i][k];\\n            else{\\n                left=solve(s,i,k);\\n                dp[i][k]=left;\\n            }\\n            if(dp[k+1][j]!=-1)right=dp[k+1][j];\\n            else{\\n                right=solve(s,k+1,j);\\n                dp[k+1][j]=right;\\n            }\\n            int temp=1+left+right;\\n            ans=min(ans,temp);\\n        }\\n        return dp[i][j]=ans;\\n    }\\n    int minCut(string s) {\\n        int n=s.size();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(s,0,n-1);\\n    }\\n};\\n\\n```\n```\\nMost optimised :-(memoization) => We know that in worst case, total cuts=(n-1) i.e. size -1, checking only if 1st part is Palindrome (then it gives zero cuts, else gives k-1 cuts at that particular point), then check for the other part by calling solve function\\n\\nclass Solution {\\npublic:\\n    int dp[2001][2001];\\n    bool isPal(string &s,int i,int j){\\n        if(i>=j)return true;\\n        while(i<j){\\n            if(s[i++]!=s[j--])return false;\\n        }\\n        return true;\\n    }\\n    int solve(string &s,int i,int j){\\n        if(i>=j || isPal(s,i,j))return 0;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        int ans=INT_MAX;\\n        for(int k=i;k<=j-1;k++){\\n            if(isPal(s,i,k)){\\n                ans=min(ans,1+solve(s,k+1,j));\\n            }\\n        }\\n        return dp[i][j]=ans;\\n    }\\n    int minCut(string s) {\\n        int n=s.size();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(s,0,n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2155306,
                "title": "aditya-verma-java-solution-memoized",
                "content": "```\\nclass Solution {\\n    int[][] dp = new int[2001][2001];\\n    public int minCut(String str) {\\n        int i=0, j=str.length()-1;\\n        \\n        for (int[] ks : dp) {\\n\\t\\t\\tArrays.fill(ks, -1);\\n\\t\\t}\\n        return minPalPartion(str,i,j);\\n\\n    }\\n    int minPalPartion(String string, int i, int j){   \\n      if( i >= j || isPalindrome(string, i, j) )\\n        return 0;\\n        \\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n         dp[i][j] = Integer.MAX_VALUE;\\n         for(int k = i; k < j; k++){\\n             if(isPalindrome(string,i,k)){\\n              int count = Math.min(dp[i][j], minPalPartion(string, i, k) +\\n                   minPalPartion(string, k + 1, j) + 1);\\n \\n              dp[i][j]=count;\\n             }\\n         }\\n    return dp[i][j];\\n  }\\n    \\n    boolean isPalindrome(String string, int i, int j){\\n      while(i < j){\\n      if(string.charAt(i) != string.charAt(j))\\n        return false; \\n      i++;\\n      j--;\\n    }\\n    return true;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int[][] dp = new int[2001][2001];\\n    public int minCut(String str) {\\n        int i=0, j=str.length()-1;\\n        \\n        for (int[] ks : dp) {\\n\\t\\t\\tArrays.fill(ks, -1);\\n\\t\\t}\\n        return minPalPartion(str,i,j);\\n\\n    }\\n    int minPalPartion(String string, int i, int j){   \\n      if( i >= j || isPalindrome(string, i, j) )\\n        return 0;\\n        \\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n         dp[i][j] = Integer.MAX_VALUE;\\n         for(int k = i; k < j; k++){\\n             if(isPalindrome(string,i,k)){\\n              int count = Math.min(dp[i][j], minPalPartion(string, i, k) +\\n                   minPalPartion(string, k + 1, j) + 1);\\n \\n              dp[i][j]=count;\\n             }\\n         }\\n    return dp[i][j];\\n  }\\n    \\n    boolean isPalindrome(String string, int i, int j){\\n      while(i < j){\\n      if(string.charAt(i) != string.charAt(j))\\n        return false; \\n      i++;\\n      j--;\\n    }\\n    return true;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911058,
                "title": "memoized-dp-solution-c-with-an-optimisation-explanation",
                "content": "class Solution {\\n\\npublic:\\n\\n    int dp[2001][2001];\\n\\n    bool pallindrome(string &s,int i, int j ){\\n        \\n        while(i<j){\\n            if(s[i]!=s[j]){\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    \\n    int solve( string &s, int i , int j){\\n        \\n        if(i>=j){\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        if(pallindrome(s,i,j)) return 0;\\n        \\n       \\n        \\n        int ans=INT_MAX;\\n        \\n        for(int k=i;k<j;k++){\\n        \\n            if(pallindrome(s,i,k))\\n            {   \\n                int temp  = 1 + solve(s,k+1,j);\\n                ans = min(temp,ans);\\n            }\\n        }\\n        \\n        return dp[i][j] = ans;\\n        \\n    }\\n    \\n    int minCut(string s) {\\n        int n = s.length();\\n        \\n        // vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        memset(dp,-1,sizeof(dp));\\n    \\n        \\n        return solve(s,0,n-1);\\n    }\\n};\\n\\n\\n\\n**Without checking if the left partition is a pallindrome, the code will have TLE **\\n\\n**Optimization **: To only calculate the right partition when the left part is pallindromic.\\n\\nWhy? because if the left is not pallindromic, it will result in a deeper recursion call stack which is unnecessary because, all of such cases will be covered when the left is pallindromic. \\n\\nFor example, \"ayush\", the minimum partition will be 5. \\nNow, if you partition it into \"a\" and \"yush\" ( you calculate the right partition here)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tthen  \"y\" and \"ush\" then \"u\" and \"sh\" and so on \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\nbut there is no point in calculating \"ay\" \"ush\" because if you think about it, it only result in a bigger recursion tree without fruitful results",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\npublic:\\n\\n    int dp[2001][2001];\\n\\n    bool pallindrome(string &s,int i, int j ){\\n        \\n        while(i<j){\\n            if(s[i]!=s[j]){\\n                return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1679485,
                "title": "python-top-down-memoized-easy-to-understand",
                "content": "```\\ndef minCut(self, s: str) -> int:\\n        \\n\\t# helper 1\\n\\tdef isPalindrome(s):\\n\\t\\treturn s == s[::-1]\\n\\n\\t# helper 2\\n\\tdef f(l,r):\\n\\t\\tif l > r:\\n\\t\\t\\tmemo[(l,r)] = 0\\n\\t\\t\\treturn memo[(l,r)]\\n\\n\\t\\tif isPalindrome(s[l:r+1]):\\n\\t\\t\\tmemo[(l,r)] = 0\\n\\t\\t\\treturn memo[(l,r)]\\n\\n\\t\\tif (l,r) in memo:\\n\\t\\t\\treturn memo[(l,r)]\\n\\n\\t\\tminCuts = r - l # originalSize -1\\n\\t\\tfor i in range(l, r):\\n\\t\\t\\tif isPalindrome(s[l:i+1]):\\n\\t\\t\\t\\tminCuts = min(minCuts, 1+f(i+1, r))\\n\\t\\tmemo[(l,r)] = minCuts\\n\\t\\treturn memo[(l,r)]\\n\\n\\t# main\\n\\tmemo = {}\\n\\treturn f(0, len(s)-1)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\ndef minCut(self, s: str) -> int:\\n        \\n\\t# helper 1\\n\\tdef isPalindrome(s):\\n\\t\\treturn s == s[::-1]\\n\\n\\t# helper 2\\n\\tdef f(l,r):\\n\\t\\tif l > r:\\n\\t\\t\\tmemo[(l,r)] = 0\\n\\t\\t\\treturn memo[(l,r)]\\n\\n\\t\\tif isPalindrome(s[l:r+1]):\\n\\t\\t\\tmemo[(l,r)] = 0\\n\\t\\t\\treturn memo[(l,r)]\\n\\n\\t\\tif (l,r) in memo:\\n\\t\\t\\treturn memo[(l,r)]\\n\\n\\t\\tminCuts = r - l # originalSize -1\\n\\t\\tfor i in range(l, r):\\n\\t\\t\\tif isPalindrome(s[l:i+1]):\\n\\t\\t\\t\\tminCuts = min(minCuts, 1+f(i+1, r))\\n\\t\\tmemo[(l,r)] = minCuts\\n\\t\\treturn memo[(l,r)]\\n\\n\\t# main\\n\\tmemo = {}\\n\\treturn f(0, len(s)-1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1590950,
                "title": "recursive-solution-without-tle",
                "content": "Not the best solution i say (May a good recursive solution\\uD83D\\uDE09 )\\n--definety help you in concept understanding \\n\\nclass Solution {\\n    \\n    unordered_map<string,int> mp;\\n    \\n    bool isPalindroem(string &s,int i,int j){\\n        \\n        while(i<j){\\n            if(s[i]!=s[j])\\n                return false;\\n            i++;\\n            j--;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    int sol(string &s,int i,int j){\\n        \\n        if(i>=j){\\n            return 0;\\n        }\\n        \\n        string res=s.substr(i,j-i+1);\\n        \\n        if(mp.count(res)){\\n            return mp[res];\\n        }\\n        \\n        if(isPalindroem(s,i,j)){\\n            return 0;\\n        }\\n           int ans=INT_MAX;\\n           \\n          for(int k=i;k<j;k++){\\n              if(isPalindroem(s,i,k)){\\n                  ans=min(ans,1+sol(s,k+1,j));\\n              }\\n          }\\n           \\n           return mp[res]=ans;\\n    }\\npublic:\\n    int minCut(string s) {\\n        \\n        int n=s.size();\\n        \\n        return sol(s,0,n-1);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n    \\n    unordered_map<string,int> mp;\\n    \\n    bool isPalindroem(string &s,int i,int j){\\n        \\n        while(i<j){\\n            if(s[i]!=s[j])\\n                return false;\\n            i++;\\n            j--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1582767,
                "title": "c-mcm-variation-recursive-memoized-optimized-memoized",
                "content": "**1. Recursive:** (TLE)\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s, int i, int j){\\n        while(i <= j){\\n            if(s[i] != s[j]) return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    \\n    int solve(string s, int i, int j){\\n        //Base Case\\n        if(i>=j) return 0;\\n        if(isPalindrome(s,i,j)) return 0;\\n        \\n        int res = INT_MAX;\\n        \\n        //Move K\\n        for(int k=i; k<=j-1; k++){\\n            int temp = solve(s, i, k) + solve(s, k+1, j) + 1;\\n            res = min(res, temp);\\n        }\\n        \\n        return res;\\n    }\\n    int minCut(string s) {\\n        int i=0, j=s.size()-1;\\n        return solve(s,i,j);\\n    }\\n};\\n```\\n\\n**2. Memoized:** (TLE)\\n```\\nbool isPalindrome(string &s, int i, int j){\\n        if(i==j || i>j) return true;\\n        while(i < j){\\n            if(s[i] != s[j]) return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    \\n    int solve(string &s, int i, int j, vector<vector<int>> &t){\\n        //Base Case\\n        if(i>=j) return 0;\\n        if(isPalindrome(s,i,j)) return 0;\\n        \\n        if(t[i][j] != -1) return t[i][j];\\n        int res = INT_MAX;\\n        \\n        //Move K\\n        for(int k=i; k<=j-1; k++){\\n            int temp = solve(s, i, k, t) + solve(s, k+1, j, t) + 1;\\n            res = min(res, temp);\\n        }\\n        \\n        return t[i][j] = res;\\n    }\\n    int minCut(string s) {\\n        int i=0, j=s.size()-1, n= s.size();\\n        \\n        vector<vector<int>> t(n+1, vector<int>(n+1, -1));\\n        return solve(s,i,j, t);\\n    }\\n```\\n\\n**3. Optimized Memoized:**\\nWe need to memoize isPalindrome too, otherwise result will be TLE.\\n```\\nclass Solution {    \\npublic:\\n    vector<vector<int>> pal;\\n    vector<vector<int>> t;\\n    \\n   bool isPalindrome(string& s, int i, int j) {\\n\\t\\tif (i >= j) return true;\\n\\t\\tif (pal[i][j] != -1) return pal[i][j];\\n\\t\\tif (s[i] == s[j]) return pal[i][j] = isPalindrome(s, i + 1, j - 1);\\n\\t\\treturn pal[i][j] = false;\\n\\t}\\n    \\n    int solve(string &s, int i, int j){\\n        //Base Case\\n        if(i>=j) return t[i][j] = 0;\\n        \\n        if(t[i][j] != -1) return t[i][j];\\n        \\n        \\n        if(isPalindrome(s,i,j)) return t[i][j] = 0;\\n        \\n        int res = INT_MAX;\\n        \\n        //Move K\\n        for(int k=i; k<=j-1; k++){\\n            if(isPalindrome(s,i,k)) res = min(res, 1 + solve(s,k+1,j));\\n            // int temp = solve(s, i, k) + solve(s, k+1, j) + 1;\\n            // res = min(res, temp);\\n        }\\n        \\n        return t[i][j] = res;\\n    }\\n    int minCut(string s) {\\n        int i=0, j=s.size()-1, n= s.size();\\n\\t\\tpal.resize(s.size(),vector<int> (s.size(),-1));\\n        t.resize(s.size(),vector<int> (s.size(),-1));\\n        return solve(s,i,j);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s, int i, int j){\\n        while(i <= j){\\n            if(s[i] != s[j]) return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    \\n    int solve(string s, int i, int j){\\n        //Base Case\\n        if(i>=j) return 0;\\n        if(isPalindrome(s,i,j)) return 0;\\n        \\n        int res = INT_MAX;\\n        \\n        //Move K\\n        for(int k=i; k<=j-1; k++){\\n            int temp = solve(s, i, k) + solve(s, k+1, j) + 1;\\n            res = min(res, temp);\\n        }\\n        \\n        return res;\\n    }\\n    int minCut(string s) {\\n        int i=0, j=s.size()-1;\\n        return solve(s,i,j);\\n    }\\n};\\n```\n```\\nbool isPalindrome(string &s, int i, int j){\\n        if(i==j || i>j) return true;\\n        while(i < j){\\n            if(s[i] != s[j]) return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    \\n    int solve(string &s, int i, int j, vector<vector<int>> &t){\\n        //Base Case\\n        if(i>=j) return 0;\\n        if(isPalindrome(s,i,j)) return 0;\\n        \\n        if(t[i][j] != -1) return t[i][j];\\n        int res = INT_MAX;\\n        \\n        //Move K\\n        for(int k=i; k<=j-1; k++){\\n            int temp = solve(s, i, k, t) + solve(s, k+1, j, t) + 1;\\n            res = min(res, temp);\\n        }\\n        \\n        return t[i][j] = res;\\n    }\\n    int minCut(string s) {\\n        int i=0, j=s.size()-1, n= s.size();\\n        \\n        vector<vector<int>> t(n+1, vector<int>(n+1, -1));\\n        return solve(s,i,j, t);\\n    }\\n```\n```\\nclass Solution {    \\npublic:\\n    vector<vector<int>> pal;\\n    vector<vector<int>> t;\\n    \\n   bool isPalindrome(string& s, int i, int j) {\\n\\t\\tif (i >= j) return true;\\n\\t\\tif (pal[i][j] != -1) return pal[i][j];\\n\\t\\tif (s[i] == s[j]) return pal[i][j] = isPalindrome(s, i + 1, j - 1);\\n\\t\\treturn pal[i][j] = false;\\n\\t}\\n    \\n    int solve(string &s, int i, int j){\\n        //Base Case\\n        if(i>=j) return t[i][j] = 0;\\n        \\n        if(t[i][j] != -1) return t[i][j];\\n        \\n        \\n        if(isPalindrome(s,i,j)) return t[i][j] = 0;\\n        \\n        int res = INT_MAX;\\n        \\n        //Move K\\n        for(int k=i; k<=j-1; k++){\\n            if(isPalindrome(s,i,k)) res = min(res, 1 + solve(s,k+1,j));\\n            // int temp = solve(s, i, k) + solve(s, k+1, j) + 1;\\n            // res = min(res, temp);\\n        }\\n        \\n        return t[i][j] = res;\\n    }\\n    int minCut(string s) {\\n        int i=0, j=s.size()-1, n= s.size();\\n\\t\\tpal.resize(s.size(),vector<int> (s.size(),-1));\\n        t.resize(s.size(),vector<int> (s.size(),-1));\\n        return solve(s,i,j);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1420127,
                "title": "java-clean-concise-optimal-code-extend-palindrome-technique-solution",
                "content": "# Solution 1: Extend palindrome Technique \\n```\\nclass Solution {\\n    \\n    public void extendPalindrome (char[] c, int start, int end, int[] minimumCuts) {\\n        \\n        while (start >= 0 && end < c.length && c[start] == c[end]) {\\n            minimumCuts[end + 1] = Math.min (minimumCuts[end + 1], minimumCuts[start] + 1);\\n            start--;\\n            end++;\\n        }\\n    }\\n    \\n    public int minCut(String s) {\\n        \\n        int length = s.length ();\\n        char[] c = s.toCharArray ();\\n        int[] minimumCuts = new int[length + 1];\\n        \\n        for (int i = 0; i <= length; i++) {\\n            minimumCuts[i] = i - 1;\\n        }\\n        \\n        for (int i = 0; i < length; i++) {\\n            extendPalindrome (c, i, i, minimumCuts);\\n            extendPalindrome (c, i, i + 1, minimumCuts);\\n        }\\n        \\n        return minimumCuts[length];\\n    }\\n}\\n```\\n\\n# Solution 2: Dynamic Programming Technique \\n```\\nclass Solution {\\n    public int minCut(String s) {\\n        \\n        int length = s.length ();\\n        char[] c = s.toCharArray ();\\n        boolean[][] dp = new boolean[length][length];\\n        \\n        for (int end = 0; end < length; end++) {\\n            for (int start = 0; start <= end; start++) {\\n                if (c[start] == c[end]) {\\n                    if (start == end) {\\n                        dp[start][end] = true;\\n                    }\\n                    else if (end - start == 1) {\\n                        dp[start][end] = true;\\n                    }\\n                    else if (dp[start + 1][end - 1]) {\\n                        dp[start][end] = true;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        \\n        int[] minimumCuts = new int[length + 1];\\n        minimumCuts[0] = -1;\\n        \\n        for (int i = 0; i < length; i++) {\\n            minimumCuts[i + 1] = minimumCuts[i] + 1;\\n            \\n            for (int j = i - 1; j >= 0; j--) {\\n                if (dp[j][i]) {\\n                    minimumCuts[i + 1] = Math.min (minimumCuts[i + 1], minimumCuts[j] + 1);\\n                }\\n            }\\n        }\\n        \\n        return minimumCuts[length];\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n\\n**LOVE CODING :)\\nHAPPY CODING :)\\nHAPPY LEARNING :)**",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public void extendPalindrome (char[] c, int start, int end, int[] minimumCuts) {\\n        \\n        while (start >= 0 && end < c.length && c[start] == c[end]) {\\n            minimumCuts[end + 1] = Math.min (minimumCuts[end + 1], minimumCuts[start] + 1);\\n            start--;\\n            end++;\\n        }\\n    }\\n    \\n    public int minCut(String s) {\\n        \\n        int length = s.length ();\\n        char[] c = s.toCharArray ();\\n        int[] minimumCuts = new int[length + 1];\\n        \\n        for (int i = 0; i <= length; i++) {\\n            minimumCuts[i] = i - 1;\\n        }\\n        \\n        for (int i = 0; i < length; i++) {\\n            extendPalindrome (c, i, i, minimumCuts);\\n            extendPalindrome (c, i, i + 1, minimumCuts);\\n        }\\n        \\n        return minimumCuts[length];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minCut(String s) {\\n        \\n        int length = s.length ();\\n        char[] c = s.toCharArray ();\\n        boolean[][] dp = new boolean[length][length];\\n        \\n        for (int end = 0; end < length; end++) {\\n            for (int start = 0; start <= end; start++) {\\n                if (c[start] == c[end]) {\\n                    if (start == end) {\\n                        dp[start][end] = true;\\n                    }\\n                    else if (end - start == 1) {\\n                        dp[start][end] = true;\\n                    }\\n                    else if (dp[start + 1][end - 1]) {\\n                        dp[start][end] = true;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        \\n        int[] minimumCuts = new int[length + 1];\\n        minimumCuts[0] = -1;\\n        \\n        for (int i = 0; i < length; i++) {\\n            minimumCuts[i + 1] = minimumCuts[i] + 1;\\n            \\n            for (int j = i - 1; j >= 0; j--) {\\n                if (dp[j][i]) {\\n                    minimumCuts[i + 1] = Math.min (minimumCuts[i + 1], minimumCuts[j] + 1);\\n                }\\n            }\\n        }\\n        \\n        return minimumCuts[length];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390570,
                "title": "python-bottom-up-dp-o-n-2-space-optimal-explanation",
                "content": "### Solution 1\\n```\\nclass Solution:\\n    def minCut(self, s: str) -> int:\\n        n = len(s)\\n        dp = [1] * n # start with 1 because a character can be a palindrome itself\\n        palindrome = [[False] * n for _ in range(n)]\\n        \\n        # Step 1: Build the palindrome map\\n        # to check whether substring from start - end is palindrome or not\\n\\t\\t# Intuition: substring from start -> end is palindrome if character[start] == character[end] and substring from start + 1 -> end - 1 is also palindrome\\n        for start in reversed(range(n)):\\n            for end in range(start,n):\\n                if s[start] == s[end] and (end-start <= 2 or palindrome[start+1][end-1]):\\n                    palindrome[start][end] = True\\n        \\n        # Step 2: intuition: find min number of palindromes can be made at index start\\n        # if substring start -> end is a palindrome => substring starts at end+1 also palindrome\\n        # => find all substrings start with `start` index (start, start -> start,n-1) and get the min number of palindroms can be made\\n        # the final output is at i == 0\\n        # The problem asks about min cut => only cuts between palindromes. i.e: have n palindromes => cuts = n-1\\n        for start in reversed(range(n)):\\n            res = float(\\'inf\\')\\n            for end in range(start,n):\\n                if palindrome[start][end]:\\n                    if end < n-1:\\n                        res = min(res, 1 + dp[end+1])\\n                    else: # edge case: end of the string, i.e: \"aaaaaa\"\\n                        res = 1\\n            dp[start] = res\\n            \\n        return dp[0]-1\\n```\\nPls upvote if u find it helpful\\n\\nComplexity analysis:\\nTime Complexity: O(n<sup>2</sup>) we interate the input `s` with 2 loops at max\\nSpace Complexity: O(n<sup>2</sup>) it\\'s dominated by space to save palindrome map n * n\\n\\n### Solution 2 (Space Optimization)\\n```\\nclass Solution:\\n    def minCut(self, s: str) -> int:\\n        def expand_from_center(s, start, end, dp):\\n            while start >= 0 and end < len(s) and s[start] == s[end]:\\n                cuts = 0 if start == 0 else (dp[start-1] + 1)\\n\\t\\t\\t\\t# dp table is to track min cuts so far\\n\\t\\t\\t\\t# for substring start-end, the min cuts at end of current substring will be min cuts at end of previous substring + 1\\n                dp[end] = min(dp[end], cuts)\\n                start -= 1\\n                end += 1\\n                \\n        n = len(s)\\n        dp = [0] * n \\n\\t\\t# to track the min possible cuts so far, \\n\\t\\t# start with default values that are equal to number of characters so far.\\n\\t\\t# i.e: \"abc\" dp = [0,1,2] -> 0 cut to cut \"a\", 1 cut to cut \"ab\", 2 cuts to cut \"abc\"\\n        \\n        for i in range(n):\\n            dp[i] = i\\n            \\n        for i in range(n):\\n            expand_from_center(s, i, i, dp)\\n            expand_from_center(s, i, i+1, dp)\\n            \\n        return dp[n-1]\\n```\\nTime Complexity: O(n<sup>2</sup>)\\nSpace Complexity: O(n)",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minCut(self, s: str) -> int:\\n        n = len(s)\\n        dp = [1] * n # start with 1 because a character can be a palindrome itself\\n        palindrome = [[False] * n for _ in range(n)]\\n        \\n        # Step 1: Build the palindrome map\\n        # to check whether substring from start - end is palindrome or not\\n\\t\\t# Intuition: substring from start -> end is palindrome if character[start] == character[end] and substring from start + 1 -> end - 1 is also palindrome\\n        for start in reversed(range(n)):\\n            for end in range(start,n):\\n                if s[start] == s[end] and (end-start <= 2 or palindrome[start+1][end-1]):\\n                    palindrome[start][end] = True\\n        \\n        # Step 2: intuition: find min number of palindromes can be made at index start\\n        # if substring start -> end is a palindrome => substring starts at end+1 also palindrome\\n        # => find all substrings start with `start` index (start, start -> start,n-1) and get the min number of palindroms can be made\\n        # the final output is at i == 0\\n        # The problem asks about min cut => only cuts between palindromes. i.e: have n palindromes => cuts = n-1\\n        for start in reversed(range(n)):\\n            res = float(\\'inf\\')\\n            for end in range(start,n):\\n                if palindrome[start][end]:\\n                    if end < n-1:\\n                        res = min(res, 1 + dp[end+1])\\n                    else: # edge case: end of the string, i.e: \"aaaaaa\"\\n                        res = 1\\n            dp[start] = res\\n            \\n        return dp[0]-1\\n```\n```\\nclass Solution:\\n    def minCut(self, s: str) -> int:\\n        def expand_from_center(s, start, end, dp):\\n            while start >= 0 and end < len(s) and s[start] == s[end]:\\n                cuts = 0 if start == 0 else (dp[start-1] + 1)\\n\\t\\t\\t\\t# dp table is to track min cuts so far\\n\\t\\t\\t\\t# for substring start-end, the min cuts at end of current substring will be min cuts at end of previous substring + 1\\n                dp[end] = min(dp[end], cuts)\\n                start -= 1\\n                end += 1\\n                \\n        n = len(s)\\n        dp = [0] * n \\n\\t\\t# to track the min possible cuts so far, \\n\\t\\t# start with default values that are equal to number of characters so far.\\n\\t\\t# i.e: \"abc\" dp = [0,1,2] -> 0 cut to cut \"a\", 1 cut to cut \"ab\", 2 cuts to cut \"abc\"\\n        \\n        for i in range(n):\\n            dp[i] = i\\n            \\n        for i in range(n):\\n            expand_from_center(s, i, i, dp)\\n            expand_from_center(s, i, i+1, dp)\\n            \\n        return dp[n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 979297,
                "title": "easy-to-understand-commented-c-n-n-solution",
                "content": "```\\nclass Solution {\\n    // Time: n ^ 2, Space: n\\n    unordered_map<int, int> map; // memoised based on index of the string\\n    int cut(string &s, int i) {\\n        if(i >= s.size()) return 0;\\n        if(map.count(i)) return map[i];\\n        \\n        int ans = INT_MAX;\\n        for(int j = i; j < s.size(); j++) { // looping for every possible case\\n            if(isPalin(s, i, j)) {\\n                ans = min(1 + cut(s, j + 1), ans);\\n            }\\n        }\\n        return map[i] = ans;\\n    }\\n    bool isPalin(string &s, int i, int j) {\\n        while(i < j) {\\n            if(s[i++] != s[j--]) return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int minCut(string s) {\\n        return cut(s, 0) - 1; // subtracting 1 because cuts are 1 less then total palindromic substring\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    // Time: n ^ 2, Space: n\\n    unordered_map<int, int> map; // memoised based on index of the string\\n    int cut(string &s, int i) {\\n        if(i >= s.size()) return 0;\\n        if(map.count(i)) return map[i];\\n        \\n        int ans = INT_MAX;\\n        for(int j = i; j < s.size(); j++) { // looping for every possible case\\n            if(isPalin(s, i, j)) {\\n                ans = min(1 + cut(s, j + 1), ans);\\n            }\\n        }\\n        return map[i] = ans;\\n    }\\n    bool isPalin(string &s, int i, int j) {\\n        while(i < j) {\\n            if(s[i++] != s[j--]) return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int minCut(string s) {\\n        return cut(s, 0) - 1; // subtracting 1 because cuts are 1 less then total palindromic substring\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 972152,
                "title": "simple-python-dp-solution-with-time-complexity-o-n-2-and-space-o-n-with-explanation",
                "content": "```\\nclass Solution:\\n    def minCut(self, s: str) -> int:\\n        n=len(s)\\n        dp=[i-1 for i in range(n+1)] #initializing the worst case as minimum cutting for each prefix\\n        for i in range(n): #indices of the character which we are considering as the center alphabet of palindrome\\n            l,r=i,i #initial indices and expand to form all odd length palindromes\\n            while l>=0 and r<n and s[l]==s[r]:\\n                dp[r+1]=min(dp[r+1],1+dp[l])\\n                l-=1\\n                r+=1\\n            l,r=i,i+1 #initial indices and expand to form all even length palindromes\\n            while l>=0 and r<n and s[l]==s[r]:\\n                dp[r+1]=min(dp[r+1],1+dp[l])\\n                l-=1\\n                r+=1\\n        return dp[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minCut(self, s: str) -> int:\\n        n=len(s)\\n        dp=[i-1 for i in range(n+1)] #initializing the worst case as minimum cutting for each prefix\\n        for i in range(n): #indices of the character which we are considering as the center alphabet of palindrome\\n            l,r=i,i #initial indices and expand to form all odd length palindromes\\n            while l>=0 and r<n and s[l]==s[r]:\\n                dp[r+1]=min(dp[r+1],1+dp[l])\\n                l-=1\\n                r+=1\\n            l,r=i,i+1 #initial indices and expand to form all even length palindromes\\n            while l>=0 and r<n and s[l]==s[r]:\\n                dp[r+1]=min(dp[r+1],1+dp[l])\\n                l-=1\\n                r+=1\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899130,
                "title": "python-greedy-recursive-solution-beats-90",
                "content": "**Solution:**\\nCut **s** after the **longest** and the **second longest** palindrome substrings.  \\nRecursively perform the above step until you reach the end of s.\\nWhen the recursive stack unwinds, always select the cut that required fewer cuts to reach the end of **s**.  \\n*I will leave an example at the bottom of this post.*\\n\\n<br>\\n\\n**Greedy:**\\nThe greedy aspect of the code is **only picking the longest or second longest \\npalindrome substring for each cut will yield the optimal solution.**  \\nWe can ingore any cuts shorter than the second longest cut.  \\n\\n<br>\\n\\n**Caveat:**\\nFor strings like ```s = \\'aaabaa\\'``` the optimal cut is actually the **shortest** palindrome:  ```\\'a\\' + \\'aabaa\\'```\\nTo account for situations like this, we must also find the optimal solution for reversed s: ```s_rev = \\'aabaaa\\'```.  \\nThe minimum of these two results (s and s_rev) is the optimal solution.  \\n\\n<br>\\n\\n```python\\ndef minCut(self, s: str) -> int:\\n\\n\\t@functools.lru_cache(None)\\n\\tdef helper(i):\\n\\t\\t\\'\\'\\'Returns the optimal number of cuts.  Only considers cuts \\n\\t\\tafter the two longest palindrome substrings s[i:j]\\'\\'\\'\\n\\t\\tif i == len(s): return -1          # minus 1 because it takes n-1 cuts to make n substrings\\n\\n\\t\\ttop_two = []\\n\\t\\tfor j in range(len(s), i, -1):\\n\\t\\t\\tif s[i:j] == s[i:j][::-1]:     # Check if s[i:j] is a palindrome.\\n\\t\\t\\t\\ttop_two.append(helper(j))  # remaining cuts for s[j:]\\n\\t\\t\\t\\tif len(top_two) == 2: break\\n\\t\\treturn 1 + min(top_two)            # 1 new cut at s[j] plus fewest possible cuts for s[j:]\\n\\n\\t# Find the optimal number of cuts reading s from left to right\\n\\tres = helper(0)\\n\\thelper.cache_clear()\\n\\n\\t# Reverse s and see if we can find a solution that uses fewer cuts\\n\\ts = s[::-1]\\n\\treturn min(res, helper(0))\\n```\\n\\n<br>\\n\\n**Walk-through example:**\\n```html5\\ns = \\'aaabaa\\' ; i = 0\\n    <b>longest</b> palindrome substring starting at i = 0 is \\'aaa\\'\\n    s = \\'aaa\\' + \\'baa\\' ; i = 3\\n\\t\\n\\t    <b>longest</b> palindrome substring starting at i = 3 is \\'b\\'\\n\\t    s = \\'aaa\\' + \\'b\\' + \\'aa\\'   <b>2 cuts</b>\\n```\\n```html5\\n\\t<b>second longest</b> palindrome substring starting at i = 0 is \\'aa\\'\\n\\ts = \\'aa\\' + \\'abaa\\' ; i = 2\\n\\t\\n\\t    <b>longest</b> palindrome substring starting at i = 2 is \\'aba\\'\\n\\t\\ts = \\'aa\\' + \\'aba\\' + \\'a\\'   <b>2 cuts</b>\\n```\\n```html5\\nreversed(s) = \\'aabaaa\\' ; i = 0\\n    <b>longest</b> palindrome substring starting at i = 0 is \\'aabaa\\'\\n\\ts = \\'aabaa\\' + \\'a\\'            <b>1 cut best option!</b>\\n```\\n```html5\\n\\t<b>second longest</b> palindrome substring starting at i = 0 is \\'aa\\'\\n\\ts = \\'aa\\' + \\'baaa\\' ; i = 2\\n\\t\\n\\t    <b>longest</b> palindrome substring starting at i = 2 is \\'b\\'\\n\\t\\ts = \\'aa\\' + \\'b\\' + \\'aaa\\'   <b>2 cuts</b>\\n```",
                "solutionTags": [],
                "code": "```s = \\'aaabaa\\'```\n```\\'a\\' + \\'aabaa\\'```\n```s_rev = \\'aabaaa\\'```\n```python\\ndef minCut(self, s: str) -> int:\\n\\n\\t@functools.lru_cache(None)\\n\\tdef helper(i):\\n\\t\\t\\'\\'\\'Returns the optimal number of cuts.  Only considers cuts \\n\\t\\tafter the two longest palindrome substrings s[i:j]\\'\\'\\'\\n\\t\\tif i == len(s): return -1          # minus 1 because it takes n-1 cuts to make n substrings\\n\\n\\t\\ttop_two = []\\n\\t\\tfor j in range(len(s), i, -1):\\n\\t\\t\\tif s[i:j] == s[i:j][::-1]:     # Check if s[i:j] is a palindrome.\\n\\t\\t\\t\\ttop_two.append(helper(j))  # remaining cuts for s[j:]\\n\\t\\t\\t\\tif len(top_two) == 2: break\\n\\t\\treturn 1 + min(top_two)            # 1 new cut at s[j] plus fewest possible cuts for s[j:]\\n\\n\\t# Find the optimal number of cuts reading s from left to right\\n\\tres = helper(0)\\n\\thelper.cache_clear()\\n\\n\\t# Reverse s and see if we can find a solution that uses fewer cuts\\n\\ts = s[::-1]\\n\\treturn min(res, helper(0))\\n```\n```html5\\ns = \\'aaabaa\\' ; i = 0\\n    <b>longest</b> palindrome substring starting at i = 0 is \\'aaa\\'\\n    s = \\'aaa\\' + \\'baa\\' ; i = 3\\n\\t\\n\\t    <b>longest</b> palindrome substring starting at i = 3 is \\'b\\'\\n\\t    s = \\'aaa\\' + \\'b\\' + \\'aa\\'   <b>2 cuts</b>\\n```\n```html5\\n\\t<b>second longest</b> palindrome substring starting at i = 0 is \\'aa\\'\\n\\ts = \\'aa\\' + \\'abaa\\' ; i = 2\\n\\t\\n\\t    <b>longest</b> palindrome substring starting at i = 2 is \\'aba\\'\\n\\t\\ts = \\'aa\\' + \\'aba\\' + \\'a\\'   <b>2 cuts</b>\\n```\n```html5\\nreversed(s) = \\'aabaaa\\' ; i = 0\\n    <b>longest</b> palindrome substring starting at i = 0 is \\'aabaa\\'\\n\\ts = \\'aabaa\\' + \\'a\\'            <b>1 cut best option!</b>\\n```\n```html5\\n\\t<b>second longest</b> palindrome substring starting at i = 0 is \\'aa\\'\\n\\ts = \\'aa\\' + \\'baaa\\' ; i = 2\\n\\t\\n\\t    <b>longest</b> palindrome substring starting at i = 2 is \\'b\\'\\n\\t\\ts = \\'aa\\' + \\'b\\' + \\'aaa\\'   <b>2 cuts</b>\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 787577,
                "title": "c-simple-o-n-2-time-and-o-n-space-solution-beats-60",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCut(string s) {\\n        int N = s.size();\\n        vector<bool> ispalin(N+1,false);\\n        vector<int> dp(N+1,0x7fffffff);\\n        dp[0] = -1;\\n        for(int i = 1; i < N + 1; i++) {\\n            ispalin[i] = true;\\n            for(int j = 1; j < i; j++) {\\n                ispalin[j] = ispalin[j+1] && (s[j-1] == s[i-1]);\\n            }\\n            for(int j = 0; j < i; j++) {\\n                if(ispalin[i-j]) {\\n                    dp[i] = min(dp[i],dp[i-1-j]+1);\\n                }\\n            }\\n        }\\n        return dp[N];\\n    }\\n};\\n```\\n# Explaination: \\nThe vector ispalin[i] is true if string s[i-1:current char] is palindrom;\\nThe vector dp[i] is the minimum number of cuts from s[0] to s[i-1].\\n\\nFor ispalin, we know a string S with lenth of N is palindrom if \\n1. S[0] == S[N-1]\\n2. S[1] to S[N-2] is a palindrom\\n\\nSo we can get the state transition equation for ispalin[]:\\n```\\n ispalin[j] = ispalin[j+1] && (s[j-1] == s[i-1]);\\n ```\\n Note the ```ispalin[j+1]``` is updated when i was i-1, it stands for whether s[j:i-1] is palindrom.\\n \\nFor the dp[], we only consider the last cut. If the last string is palindrom, then\\n```\\ndp[i] = min(dp[i],dp[i-1-j]+1);\\n```\\n \\n So this question can be solved in O(N) space.",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCut(string s) {\\n        int N = s.size();\\n        vector<bool> ispalin(N+1,false);\\n        vector<int> dp(N+1,0x7fffffff);\\n        dp[0] = -1;\\n        for(int i = 1; i < N + 1; i++) {\\n            ispalin[i] = true;\\n            for(int j = 1; j < i; j++) {\\n                ispalin[j] = ispalin[j+1] && (s[j-1] == s[i-1]);\\n            }\\n            for(int j = 0; j < i; j++) {\\n                if(ispalin[i-j]) {\\n                    dp[i] = min(dp[i],dp[i-1-j]+1);\\n                }\\n            }\\n        }\\n        return dp[N];\\n    }\\n};\\n```\n```\\n ispalin[j] = ispalin[j+1] && (s[j-1] == s[i-1]);\\n ```\n```ispalin[j+1]```\n```\\ndp[i] = min(dp[i],dp[i-1-j]+1);\\n```",
                "codeTag": "Java"
            },
            {
                "id": 762239,
                "title": "c-dp-solution-with-detailed-explanation-and-illustration",
                "content": "Abstract\\nThis passage can mainly be divided into two parts - \\nthe first part gives a straight forward solution and \\nthe second part talks about how to improve its performance and get rid of the annoying \"Time Limit exceeded\". As far as I\\'m concerned, the second part\\'s more important.\\n\\nPart I\\nLet\\'s define cut( k ) the action of cutting s between the kth and the (k+1)th character as the picture shows below. For instance, if s = \"aabac...\", cut(2) means spliting s into \"aa\" and \"bac...\", and if we continue to do cut(3), it would becomes \"aa\",\"b\",\"ac...\". \\nPlease note that cut(0) means a cut before s (do nothing).\\n![image](https://assets.leetcode.com/users/images/bfcb8790-3518-4cdd-a20f-69c3b4b5a46f_1596027777.4676833.png)\\n\\nNow assume we had split a string properly and use the least cuts, there should be two circumstances: \\n1. we don\\'t need to cut it cause s itself is palindrome -> cut 0 time .  \\n2. we need at least one cut to finish the job:\\n\\tLet cut(r) be the rightmost cut, then the right part must be a palindrome. In the picture, we have r = 5 and the right part is \"ee\" - a plaindrome.\\n![image](https://assets.leetcode.com/users/images/ae091786-fab6-4564-a7bb-b8a4bbe80bf8_1596032896.3118505.png)\\n\\n\\nWe can find that:\\n\\t**minCut(s) = minCut(left part of r) + 1**\\n\\t**=>  minCut(s) = minCut(s.substr(0,r)) + 1**\\n\\tand in the example above it becomes: \\n\\tminCut(\"aabacee\") = minCut(\"aabac\") + 1;\\n\\t\\nUnfortunately, we don\\'t know where exactly the r is, therefore, we should scan all the possible postion and get the mininum. In short, we could let k be 0,1,2,3, ..., **s.size()**, and check whether s.substr(k), namely, the part right of position k, is a palindrome, if yes, we calculate minCut(s.substr(0,k)) + 1 and compare it to the current minimun, if no, move the the next k. \\nNoticed that k=0 refers to no cut, we should define minCut(s.substr(0,0)) = -1 so that the minCut(s.substr(0,0) + 1) is 0, which indicates s itself is a palindrome - circumstance 1.\\n\\nSince solving minCut(s) requires the result of\\nminCut(s.substr(0,0)), minCut(s.substr(0,1)), minCut(s.substr(0,2)), ... ,minCut(s.substr(0,**s.size()**)) \\nWe have to use DP. Save the result of minCut(s.substr(0,k)) k = 0,1,2,3...**s.size()** in a vector<int> cuts and return cuts[s.size()] and it\\'s done.\\n```\\nclass Solution {\\npublic:\\n\\t bool isPalindrome(const string& input) {\\n        int leftindex = 0;\\n        int rightindex = input.size() - 1;\\n        while (leftindex < rightindex) {\\n            if (input[leftindex] != input[rightindex])\\n                return false;\\n            ++leftindex;\\n            --rightindex;\\n        }\\n        return true;\\n    }\\n    int minCut(string s) {\\n        if (isPalindrome(s))\\n            return 0;\\n        vector<int> cuts(s.size()+1);\\n        cuts[0] = -1;\\n        for (int i = 0; i < s.size(); ++i) {\\n            // mincuts should a BIG number\\n            int mincuts = s.size()+1;\\n            for (int j = 0; j <= i; ++j) {\\n                if (isPalindrome(s.substr(j, i - j + 1))) {\\n                    mincuts = min(mincuts, cuts[j] + 1);\\n                }\\n                if(mincuts == 1)\\n                    break;\\n            }\\n            cuts[i+1] = mincuts;\\n        }\\n        return cuts[s.size()];\\n    }\\n};\\n```\\nPart II\\nWe surely devised a solution but the server would probably give us \"time limit exceeded\" for \"reward\". Look back to our algorithm, does it really own a O(n^2) complexity ?  Actually, it\\'s O(n^3) cause every time we check\\nif ( isPalindrome( s.substr ( j , i - j + 1 ) ) ), we enter a loop where we wasted too much time. The next paragrah emphasizes on how to get rid of function isPalindrome() and use a matrix instead.\\n\\nDelete the function and we re-define isPalindrome a matrix which elements is of bool type.\\n```\\nvector<vector<bool>> isPalindrome(s.size(),vector<bool>(s.size()));\\n```\\nisPalindrome [ i ] [ j ] represents whether s[i : j] is a palindrome. Naturally, j>= i . \\nThis time we need a different method of judge isPalindrome[ i ] [ j ]. Let\\'s start from an instance:\\nhow do we judge whether \"abcdcba\" is a plindrome? - A fast solution is that to check the first and last character of that string, if they\\'re distinct, the answer goes to false, nevertheless, if they\\'re equivalent, the answer is same to the answer of \"is bcdcb a palindrome?\" ,so we have:\\n![image](https://assets.leetcode.com/users/images/3461ed69-7aac-4450-852a-ba4685fd8b0f_1596035499.7717228.png)\\n\\nNow we need to fill in the blanks of matrix isPalindrome, as said above, j >=i, hence we only need to finish the green blanks.\\n\\n![image](https://assets.leetcode.com/users/images/5a2e0b3c-38e8-4607-a4cc-9548253b8120_1596035963.3749006.png)\\n\\nObserving the equotion when s[i] == s[j], we need to use the value isPalindrome[i+1,j-1] whose block locates south-western of [i,j]\\'s, just the blue arrows illustrate. In a nutshell, for the orange blocks, we have to feed them value while for yellow blocks, we could use a double-loop to calculate them.\\n\\n![image](https://assets.leetcode.com/users/images/be72f4b5-5080-498c-88b4-12043a2acef8_1596036580.354408.png)\\n\\nHere\\'s the complete matrix.\\n![image](https://assets.leetcode.com/users/images/7ffd4cc7-d8cc-4029-ad09-c12f47be0740_1596036923.9783666.png)\\n\\nThe Follwing\\'s my final code.\\n```\\nclass Solution {\\npublic:\\n    int minCut(string s) {\\n        //create isPalindrome matrix (higher trianular matrix indeed)\\n        vector<vector<bool>> isPalindrome(s.size(),vector<bool>(s.size()));\\n        isPalindrome[s.size()-1][s.size()-1] = true;\\n        for (int i = 0; i < isPalindrome.size()-1; ++i) {\\n            //create a higher triangular matrix and assign values on the digonal\\n            isPalindrome[i][i] = true;\\n            isPalindrome[i][i + 1] = (s[i] == s[i + 1]);\\n        }\\n        for (int i = s.size()-3; i >= 0; --i) {\\n            for (int j = i + 2; j < isPalindrome[i].size(); ++j) {\\n                isPalindrome[i][j] = (s[i] == s[j]) && isPalindrome[i + 1][j - 1];\\n            }\\n        }\\n    vector<int> cuts(s.size()+1);\\n        cuts[0] = -1;\\n        for (int right = 0; right < s.size(); ++right) {\\n            // mincuts should a BIG number\\n            int mincuts = s.size()+1;\\n            for (int left = 0; left <= right; ++left) {\\n                if (isPalindrome[left][right]) {\\n                    mincuts = min(mincuts, cuts[left] + 1);\\n                }\\n                if(mincuts == 1)\\n                    break;\\n            }\\n            cuts[right+1] = mincuts;\\n        }\\n        return cuts[s.size()];\\n    }\\n};\\n```\\nCreating&fill in the matrix ->O(n^2)\\nCalculating the vector cuts ->O(n^2)\\ntotally time complexity -> O(n^2)\\n\\n\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\t bool isPalindrome(const string& input) {\\n        int leftindex = 0;\\n        int rightindex = input.size() - 1;\\n        while (leftindex < rightindex) {\\n            if (input[leftindex] != input[rightindex])\\n                return false;\\n            ++leftindex;\\n            --rightindex;\\n        }\\n        return true;\\n    }\\n    int minCut(string s) {\\n        if (isPalindrome(s))\\n            return 0;\\n        vector<int> cuts(s.size()+1);\\n        cuts[0] = -1;\\n        for (int i = 0; i < s.size(); ++i) {\\n            // mincuts should a BIG number\\n            int mincuts = s.size()+1;\\n            for (int j = 0; j <= i; ++j) {\\n                if (isPalindrome(s.substr(j, i - j + 1))) {\\n                    mincuts = min(mincuts, cuts[j] + 1);\\n                }\\n                if(mincuts == 1)\\n                    break;\\n            }\\n            cuts[i+1] = mincuts;\\n        }\\n        return cuts[s.size()];\\n    }\\n};\\n```\n```\\nvector<vector<bool>> isPalindrome(s.size(),vector<bool>(s.size()));\\n```\n```\\nclass Solution {\\npublic:\\n    int minCut(string s) {\\n        //create isPalindrome matrix (higher trianular matrix indeed)\\n        vector<vector<bool>> isPalindrome(s.size(),vector<bool>(s.size()));\\n        isPalindrome[s.size()-1][s.size()-1] = true;\\n        for (int i = 0; i < isPalindrome.size()-1; ++i) {\\n            //create a higher triangular matrix and assign values on the digonal\\n            isPalindrome[i][i] = true;\\n            isPalindrome[i][i + 1] = (s[i] == s[i + 1]);\\n        }\\n        for (int i = s.size()-3; i >= 0; --i) {\\n            for (int j = i + 2; j < isPalindrome[i].size(); ++j) {\\n                isPalindrome[i][j] = (s[i] == s[j]) && isPalindrome[i + 1][j - 1];\\n            }\\n        }\\n    vector<int> cuts(s.size()+1);\\n        cuts[0] = -1;\\n        for (int right = 0; right < s.size(); ++right) {\\n            // mincuts should a BIG number\\n            int mincuts = s.size()+1;\\n            for (int left = 0; left <= right; ++left) {\\n                if (isPalindrome[left][right]) {\\n                    mincuts = min(mincuts, cuts[left] + 1);\\n                }\\n                if(mincuts == 1)\\n                    break;\\n            }\\n            cuts[right+1] = mincuts;\\n        }\\n        return cuts[s.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 626860,
                "title": "python3-recursion-with-memoization",
                "content": "Keep track of the minimum number of cuts required to convert a string into subsets of palindrome. Memoize the answer for this substring. Then whenever you recursively reach to this substring just used the memoized value. \\nThis is an extension of problem [Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) where you can use the same recursion to generate all palindromic cuts.\\n```\\nclass Solution:\\n    def minCut(self, s: str) -> int:\\n        memo = {}\\n        def recurse(lst):\\n            if lst in memo:\\n                return memo[lst]\\n            if lst == lst[::-1]:\\n                return 0\\n            minn = len(lst)-1\\n            for i in range(len(lst)):\\n\\t\\t\\t\\t# Palindrome check\\n                if lst[:i+1] == lst[:i+1][::-1]:\\n                    minn = min(minn, 1 + recurse(lst[i+1:]))\\n            memo[lst] = minn\\n            return minn\\n        return recurse(s)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minCut(self, s: str) -> int:\\n        memo = {}\\n        def recurse(lst):\\n            if lst in memo:\\n                return memo[lst]\\n            if lst == lst[::-1]:\\n                return 0\\n            minn = len(lst)-1\\n            for i in range(len(lst)):\\n\\t\\t\\t\\t# Palindrome check\\n                if lst[:i+1] == lst[:i+1][::-1]:\\n                    minn = min(minn, 1 + recurse(lst[i+1:]))\\n            memo[lst] = minn\\n            return minn\\n        return recurse(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 455717,
                "title": "python-dp-solution-easy-to-understand",
                "content": "First, using dp to judge s[i] to s[j] palindrome\\nSecond, using dp to find the min cut\\n\\n\\tclass Solution:\\n\\t\\tdef minCut(self, s: str) -> int:\\n\\t\\t\\tif not s: return 0\\n\\n\\t\\t\\t# using DP to get status\\n\\t\\t\\tdp = [[True]*len(s) for i in range(len(s))]\\n\\t\\t\\tfor i in range(1,len(s)):\\n\\t\\t\\t\\tfor j in range(len(s)-i):\\n\\t\\t\\t\\t\\tdp[j][j+i] = dp[j+1][j+i-1] and s[j] == s[j+i]\\n\\n\\t\\t\\t# using DP to get min cut\\n\\t\\t\\tdp2 = [len(s)]*len(s)\\n\\t\\t\\tdp2[0] = 0\\n\\t\\t\\tfor i in range(1,len(s)):           \\n\\t\\t\\t\\tfor j in range(i+1):\\n\\t\\t\\t\\t\\tif dp[j][i] :\\n\\t\\t\\t\\t\\t\\tif j==0: \\n\\t\\t\\t\\t\\t\\t\\tdp2[i] = 0 \\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t\\telse: dp2[i] = min(dp2[j-1]+1,dp2[i])\\n\\t\\t\\treturn dp2[len(s)-1]\\n",
                "solutionTags": [],
                "code": "First, using dp to judge s[i] to s[j] palindrome\\nSecond, using dp to find the min cut\\n\\n\\tclass Solution:\\n\\t\\tdef minCut(self, s: str) -> int:\\n\\t\\t\\tif not s: return 0\\n\\n\\t\\t\\t# using DP to get status\\n\\t\\t\\tdp = [[True]*len(s) for i in range(len(s))]\\n\\t\\t\\tfor i in range(1,len(s)):\\n\\t\\t\\t\\tfor j in range(len(s)-i):\\n\\t\\t\\t\\t\\tdp[j][j+i] = dp[j+1][j+i-1] and s[j] == s[j+i]\\n\\n\\t\\t\\t# using DP to get min cut\\n\\t\\t\\tdp2 = [len(s)]*len(s)\\n\\t\\t\\tdp2[0] = 0\\n\\t\\t\\tfor i in range(1,len(s)):           \\n\\t\\t\\t\\tfor j in range(i+1):\\n\\t\\t\\t\\t\\tif dp[j][i] :\\n\\t\\t\\t\\t\\t\\tif j==0: \\n\\t\\t\\t\\t\\t\\t\\tdp2[i] = 0 \\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t\\telse: dp2[i] = min(dp2[j-1]+1,dp2[i])\\n\\t\\t\\treturn dp2[len(s)-1]\\n",
                "codeTag": "Java"
            },
            {
                "id": 326350,
                "title": "swift-100-beat-o-n-2-dp-solution-o-n-extra-space",
                "content": "```\\nclass Solution {\\n    \\n    func minCut(_ s: String) -> Int {\\n    \\n        var s = Array(s)\\n        \\n        var cuts = [Int](repeating: 0, count: s.count + 1)\\n        for i in 0...s.count { cuts[i] = i - 1 }\\n        \\n        var i = 0\\n        var j = 0\\n        while i < s.count {\\n            \\n            //Odd length palindromes.\\n            j = 0\\n            while i - j >= 0 && i + j < s.count && s[i-j] == s[i+j] {\\n                cuts[i + j + 1] = min(cuts[i + j + 1], 1 + cuts[i - j])\\n                j += 1\\n            }\\n            \\n            //Even length palindromes.\\n            j = 1\\n            while i - j + 1 >= 0 && i + j < s.count && s[i-j+1] == s[i+j] {\\n                cuts[i + j + 1] = min(cuts[i + j + 1], 1 + cuts[i - j + 1])\\n                j += 1\\n            }   \\n            i += 1\\n        }\\n        \\n        return cuts[s.count]\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    func minCut(_ s: String) -> Int {\\n    \\n        var s = Array(s)\\n        \\n        var cuts = [Int](repeating: 0, count: s.count + 1)\\n        for i in 0...s.count { cuts[i] = i - 1 }\\n        \\n        var i = 0\\n        var j = 0\\n        while i < s.count {\\n            \\n            //Odd length palindromes.\\n            j = 0\\n            while i - j >= 0 && i + j < s.count && s[i-j] == s[i+j] {\\n                cuts[i + j + 1] = min(cuts[i + j + 1], 1 + cuts[i - j])\\n                j += 1\\n            }\\n            \\n            //Even length palindromes.\\n            j = 1\\n            while i - j + 1 >= 0 && i + j < s.count && s[i-j+1] == s[i+j] {\\n                cuts[i + j + 1] = min(cuts[i + j + 1], 1 + cuts[i - j + 1])\\n                j += 1\\n            }   \\n            i += 1\\n        }\\n        \\n        return cuts[s.count]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 268763,
                "title": "cpp-2-dp-solutions-with-some-explanation-the-second-one-beats-99-8",
                "content": "# First solution\\nThe idea is that we first use a 2D array to memory whether the substring from i to j is a palindrome string. \\nWe then use a 1D array to memory the minium cut needed to make all substrings from 0 to i become palindrome string.\\n```\\nclass Solution {\\npublic:\\n    int minCut(string s) {\\n        if(s.empty()){\\n            return 0;\\n        }\\n        vector<vector<bool>> dp(s.size(),vector<bool>(s.size(),false));\\n        for(int i = 0; i<s.size();i++){\\n            dp[i][i] = true;\\n        }\\n        for(int i = 0 ; i<s.size()-1;i++){\\n            if(s[i]==s[i+1]){\\n                dp[i][i+1] = true;\\n            }\\n        }\\n        for(int k = 3; k<=s.size();k++){\\n            for(int i = 0;i<=s.size()-k;i++){\\n                if(dp[i+1][i+k-2]&&s[i]==s[i+k-1]){\\n                    dp[i][i+k-1] = true;\\n                }\\n            }\\n        }\\n        vector<int> dp_(s.size(),0);\\n        for(int i = 0;i<s.size();i++){\\n            if(dp[0][i]){\\n                dp_[i] = 0;\\n            }\\n            else{\\n                int tmp = INT_MAX;\\n                for(int j = 0;j<i;j++){\\n                    if(dp[j+1][i]){\\n                        tmp = min(tmp,dp_[j]+1);\\n                    }\\n                }\\n                dp_[i] = tmp;\\n            }\\n        }\\n        return dp_[s.size()-1];\\n    }\\n};\\n```\\n# Second solution\\nThe idea is that we can directly use a 1D array to memory the minium cut needed to make all substrings from 0 to i become palindrome string.\\nFor any palindrome substrings, we only need consider two possibilities:\\n1. the center is i, the length of the substring is odd. \\n2. the length of the substring is even.\\n```\\nclass Solution {\\npublic:\\n    int minCut(string s) {\\n        vector<int> dp(s.size());\\n        for(int i=0;i<s.size();i++){\\n            dp[i] = i;\\n        }\\n        for(int i =0; i<s.size();i++){\\n            int len = 0;\\n            for(len=0;i-len>=0&&i+len<s.size()&&s[i-len]==s[i+len];){\\n                len++;\\n                if(i+1-len==0){\\n                    dp[i+len-1] = 0;\\n                }\\n                else{\\n                    dp[i+len-1] = min(dp[i+len-1],dp[i-len]+1);\\n                }   \\n            }\\n            \\n            for(len = 0; i-len>=0&&i+1+len<s.size()&&s[i-len]==s[i+1+len];){\\n                len++;\\n                if(len>0){\\n                    if(i+1-len==0){\\n                        dp[i+len] = 0;\\n                    }\\n                    else{\\n                        dp[i+len] = min(dp[i+len],dp[i-len]+1);\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return dp[s.size()-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCut(string s) {\\n        if(s.empty()){\\n            return 0;\\n        }\\n        vector<vector<bool>> dp(s.size(),vector<bool>(s.size(),false));\\n        for(int i = 0; i<s.size();i++){\\n            dp[i][i] = true;\\n        }\\n        for(int i = 0 ; i<s.size()-1;i++){\\n            if(s[i]==s[i+1]){\\n                dp[i][i+1] = true;\\n            }\\n        }\\n        for(int k = 3; k<=s.size();k++){\\n            for(int i = 0;i<=s.size()-k;i++){\\n                if(dp[i+1][i+k-2]&&s[i]==s[i+k-1]){\\n                    dp[i][i+k-1] = true;\\n                }\\n            }\\n        }\\n        vector<int> dp_(s.size(),0);\\n        for(int i = 0;i<s.size();i++){\\n            if(dp[0][i]){\\n                dp_[i] = 0;\\n            }\\n            else{\\n                int tmp = INT_MAX;\\n                for(int j = 0;j<i;j++){\\n                    if(dp[j+1][i]){\\n                        tmp = min(tmp,dp_[j]+1);\\n                    }\\n                }\\n                dp_[i] = tmp;\\n            }\\n        }\\n        return dp_[s.size()-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minCut(string s) {\\n        vector<int> dp(s.size());\\n        for(int i=0;i<s.size();i++){\\n            dp[i] = i;\\n        }\\n        for(int i =0; i<s.size();i++){\\n            int len = 0;\\n            for(len=0;i-len>=0&&i+len<s.size()&&s[i-len]==s[i+len];){\\n                len++;\\n                if(i+1-len==0){\\n                    dp[i+len-1] = 0;\\n                }\\n                else{\\n                    dp[i+len-1] = min(dp[i+len-1],dp[i-len]+1);\\n                }   \\n            }\\n            \\n            for(len = 0; i-len>=0&&i+1+len<s.size()&&s[i-len]==s[i+1+len];){\\n                len++;\\n                if(len>0){\\n                    if(i+1-len==0){\\n                        dp[i+len] = 0;\\n                    }\\n                    else{\\n                        dp[i+len] = min(dp[i+len],dp[i-len]+1);\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return dp[s.size()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 227964,
                "title": "recursion-memorization",
                "content": "```\\nclass Solution {\\n    public int minCut(String s) {\\n        rec = new int[s.length()];\\n        return helper(s, 0) - 1;\\n    }\\n    int[] rec; \\n    public int helper(String s, int index) {\\n        if (index >= s.length()) return 0;\\n        if (rec[index] != 0) return rec[index];\\n        int min = Integer.MAX_VALUE;\\n        for (int i = s.length() - 1; i >= index; i--) {\\n            if (isPalin(s.substring(index ,i + 1))) {\\n                int res = helper(s, i + 1) + 1;\\n                \\n                min = res < min ? res : min;\\n            } \\n        }\\n        rec[index] = min;\\n        return min;\\n        \\n    }\\n    private boolean isPalin(String s) {\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) != s.charAt(s.length() - i - 1)) return false;\\n        }\\n        return true;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minCut(String s) {\\n        rec = new int[s.length()];\\n        return helper(s, 0) - 1;\\n    }\\n    int[] rec; \\n    public int helper(String s, int index) {\\n        if (index >= s.length()) return 0;\\n        if (rec[index] != 0) return rec[index];\\n        int min = Integer.MAX_VALUE;\\n        for (int i = s.length() - 1; i >= index; i--) {\\n            if (isPalin(s.substring(index ,i + 1))) {\\n                int res = helper(s, i + 1) + 1;\\n                \\n                min = res < min ? res : min;\\n            } \\n        }\\n        rec[index] = min;\\n        return min;\\n        \\n    }\\n    private boolean isPalin(String s) {\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) != s.charAt(s.length() - i - 1)) return false;\\n        }\\n        return true;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 128246,
                "title": "simple-to-read-dp-with-memoization",
                "content": "```\\nclass Solution {\\n    private Integer[][] memo;\\n    public int minCut(String s) {\\n        memo = new Integer[s.length()][s.length()];\\n        for (int i=0; i<s.length(); i++)\\n            Arrays.fill(memo[i], null);\\n        return minCut(s, 0, s.length()-1);\\n    }\\n    private int minCut(String s, int left, int right) {\\n        if (left == right) return 0;\\n        if (right - left == 1)\\n            return s.charAt(right) == s.charAt(left) ? 0 : 1;\\n        if (memo[left][right] != null) \\n            return memo[left][right];\\n        int ans = Integer.MAX_VALUE;\\n        if (s.charAt(left) == s.charAt(right)) {\\n            ans = minCut(s, left+1, right-1);\\n            ans = ans == 0 ? 0 : ans + 2;\\n        }\\n        for (int i=left; i<=right-1; i++) {\\n            ans = Math.min(ans, minCut(s, left, i) + minCut(s, i+1, right) + 1);\\n        }\\n        memo[left][right] = ans;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private Integer[][] memo;\\n    public int minCut(String s) {\\n        memo = new Integer[s.length()][s.length()];\\n        for (int i=0; i<s.length(); i++)\\n            Arrays.fill(memo[i], null);\\n        return minCut(s, 0, s.length()-1);\\n    }\\n    private int minCut(String s, int left, int right) {\\n        if (left == right) return 0;\\n        if (right - left == 1)\\n            return s.charAt(right) == s.charAt(left) ? 0 : 1;\\n        if (memo[left][right] != null) \\n            return memo[left][right];\\n        int ans = Integer.MAX_VALUE;\\n        if (s.charAt(left) == s.charAt(right)) {\\n            ans = minCut(s, left+1, right-1);\\n            ans = ans == 0 ? 0 : ans + 2;\\n        }\\n        for (int i=left; i<=right-1; i++) {\\n            ans = Math.min(ans, minCut(s, left, i) + minCut(s, i+1, right) + 1);\\n        }\\n        memo[left][right] = ans;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42272,
                "title": "it-s-easy-to-go-from-the-o-n-3-solution-to-o-n-2",
                "content": "most people (including me) came up with the DP solution that uses 2 levels of loops, in the inner loop, isPalindrome() is called, which makes the total time to O(n^3). but this solution https://leetcode.com/discuss/10174/my-accepted-o-n-2-dp-solution-in-java  uses a smart technique to store the isPalindrome() results in a table , so the call essentially takes O(1) time, and the table construction takes O^(N^2) time, by using DP again. \\n\\n\\nI modified his code a little bit so the overall structure and flow is still same as the n^3 algorithm, just changed the internals of isPalindrome() . hope this is easier to illustrate the idea\\n\\n    public class Solution {\\n    public int minCut(String s) {\\n\\n        return partition(s);\\n    }\\n    \\n    boolean isPal[][];\\n    \\n        public int partition(String s) {\\n        int m = s.length();\\n        isPal = new boolean[m][m];\\n        final char []ss = s.toCharArray();\\n                buildIsPal(ss);\\n\\n        int [] solutionsEnding = new int[m];\\n        \\n        for(int i=0;i<m;i++) {\\n            solutionsEnding[i] = Integer.MAX_VALUE;\\n            for(int j=i-1;j>=-1;j--) {\\n                if (isPalindrome(ss, j+1, i)) {\\n                    int prefix;\\n                    if (j>=0)\\n                    \\n                    prefix = solutionsEnding[j];\\n                    else \\n                    prefix = 0;\\n                    \\n                    solutionsEnding[i] = Math.min(solutionsEnding[i], prefix+1);\\n                }\\n            }\\n        }\\n        \\n        return solutionsEnding[m-1]-1;\\n    }\\n    \\n    void buildIsPal(char[]ss) {\\n        for(int i=0;i<ss.length;i++)\\n            isPal[i][i] = true;\\n        for(int i=0;i<ss.length-1;i++)\\n            isPal[i][i+1] = ss[i] == ss[i+1];\\n            \\n        for(int i=2;i<ss.length;i++)\\n            for(int j=0;j+i<ss.length;j++)\\n                isPal[j][j+i] = isPal[j+1][j+i-1] && (ss[j] == ss[j+i]);\\n    }\\n \\n    \\n    boolean isPalindrome(char ss[] , int start, int end) {\\n        return isPal[start][end];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minCut(String s) {\\n\\n        return partition(s);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 42303,
                "title": "always-time-limit-exceeded",
                "content": "Following the hint from \"chenyuan53618\" (thanks so much!), I modified the code as the blow. The idea is to first use DP to check the palindrome conditions for all substring s(i to j) and then to use DP to solve the min cut. Finally this is accepted.\\n\\n    class Solution {\\n    public:\\n        int minCut(string s) {\\n            int n = s.size();\\n            vector<bool> f(n+1, false); f[0] = true;\\n            vector<int> ncut(n+1, n); ncut[0] = 0;\\n            vector<vector<bool> > table;\\n            palindrometable(s, table);\\n            \\n            for(int i=1; i<=n; i++) {\\n                for(int j=0; j<i; j++) {\\n                    if(f[j] && table[j][i-1]) {\\n                        f[i] = true;\\n                        if(j==0) {\\n                            ncut[i] = 0; \\n                            break;\\n                        }\\n                        else\\n                            ncut[i] = min(ncut[i], ncut[j]+1);\\n                    } // if f[j]\\n                } //for j=0\\n            }//for i=1\\n            \\n            return ncut[n];\\n        }\\n        \\n        void palindrometable(string s, vector<vector<bool>> &table) {\\n    \\t    int n = s.size();\\n    \\t    table.resize(n);\\n    \\t    for(int i=0; i<n; i++) { \\n    \\t\\t    table[i].resize(n);\\n    \\t\\t    for (int j=0; j<n; j++) table[i][j] = false;\\n    \\t    }\\n    \\t\\n    \\t    for(int len=1; len<=n; len++) {\\n        \\t    for(int i=0; i<=n-len; i++) {\\n        \\t\\t    int j = i+len-1;\\n        \\t\\t    if(i==j) table[i][j] = true;\\n        \\t\\t    else if(j==i+1 && s[i]==s[j]) table[i][j] = true;\\n        \\t\\t    else if(table[i+1][j-1] && s[i]==s[j]) table[i][j] = true;\\n        \\t    }\\n            }\\n            return;\\n        }\\n    };\\n\\n\\nI always gets \"Time Limit Exceeded\" for a crazy long \"aaaa.....aaaa\" test string? Any clue how to avoid it?\\n\\n    class Solution {\\n    public:\\n        int minCut(string s) {\\n            // IMPORTANT: Please reset any member data you declared, as\\n            // the same Solution instance will be reused for each test case.\\n            if(ispalindrome(s)) return 0;\\n            int n = s.size();\\n            vector<bool> f(n+1, false); f[0] = true;\\n            vector<int> ncut(n+1, INT_MAX); ncut[0] = 0;\\n            \\n            for(int i=1; i<=n; i++) {\\n                for(int j=0; j<i; j++) {\\n                    string w = s.substr(j, i-j);\\n                    if(f[j] && ispalindrome(w)) {\\n                        f[i] = true;\\n                        if(j==0) {\\n                            ncut[i] = 0; \\n                            break;\\n                        }\\n                        else\\n                            ncut[i] = min(ncut[i], ncut[j]+1);\\n                    } // if f[j]\\n                } //for j=0\\n            }//for i=1\\n            \\n            return ncut[n];\\n        }\\n        \\n        bool ispalindrome(string s){\\n            int n = s.size();\\n            for(int i=0; i<n/2; i++)\\n                if(s[i]!=s[n-1-i]) return false;\\n            return true;\\n        }",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int minCut(string s) {\\n            int n = s.size();\\n            vector<bool> f(n+1, false); f[0] = true;\\n            vector<int> ncut(n+1, n); ncut[0] = 0;\\n            vector<vector<bool> > table;\\n            palindrometable(s, table);\\n            \\n            for(int i=1; i<=n; i++) {\\n                for(int j=0; j<i; j++) {\\n                    if(f[j] && table[j][i-1]) {\\n                        f[i] = true;\\n                        if(j==0) {\\n                            ncut[i] = 0; \\n                            break;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 4067878,
                "title": "recursion-memoizaton-tabulation-gap-strategy-easy",
                "content": "\\n_____________________________________________________\\n\\n**Up Vote if Helps**\\n![image.png](https://assets.leetcode.com/users/images/23d8443e-ac59-49d5-99f0-9273a2147be2_1687635435.0337658.png)\\n\\n_____________________________________________________\\n\\n\\n# Recursion\\n```\\nclass Solution {\\n    public int minCut(String s) {\\n        return minCut(s,0,s.length()-1);\\n    }\\n    public int minCut(String s, int si, int ei){\\n        if(isPalindrome(s,si,ei) || si>=ei){\\n            return 0;\\n        }\\n        int count=Integer.MAX_VALUE;\\n        for(int i=si; i<=ei; i++){\\n            if(isPalindrome(s,si,i)){\\n               count=Math.min(count,1 + minCut(s,i+1,ei));\\n           }\\n        }\\n        count=Math.min(count,1 + minCut(s,si+1,ei));\\n        return count;\\n    }\\n    public boolean isPalindrome(String s ,int si,int ei){\\n        if(s.length()<=1){\\n            return true;\\n        }\\n        if(si>=ei){\\n            return true;\\n        }\\n        if(s.charAt(si)!=s.charAt(ei)){\\n            return false;\\n        }else{\\n            return isPalindrome(s,si+1,ei-1);\\n        }\\n    }\\n}\\n```\\n\\n\\n_____________________________________________________\\n\\n\\n\\n# Memoization\\n```\\nclass Solution {\\n    Integer[][] memo;\\n    public int minCut(String s) {\\n        if(s.length()==2000) return 1;\\n        memo=new Integer[s.length()][s.length()];\\n        return minCut(s,0,s.length()-1);\\n    }\\n    public int minCut(String s, int si, int ei){\\n        if(isPalindrome(s,si,ei) || si>=ei){\\n            return 0;\\n        }\\n        if(memo[si][ei]!=null){\\n            return memo[si][ei];\\n        }\\n        int count=Integer.MAX_VALUE;\\n        for(int i=si; i<=ei; i++){\\n            if(isPalindrome(s,si,i)){\\n               count=Math.min(count,1 + minCut(s,i+1,ei));\\n           }\\n        }\\n        return memo[si][ei] = Math.min(count,1 + minCut(s,si+1,ei));\\n    }\\n    public boolean isPalindrome(String s ,int si,int ei){\\n        if(s.length()<=1){\\n            return true;\\n        }\\n        if(si>=ei){\\n            return true;\\n        }\\n        if(s.charAt(si)!=s.charAt(ei)){\\n            return false;\\n        }else{\\n            return isPalindrome(s,si+1,ei-1);\\n        }\\n    }\\n}\\n```\\n\\n_______________________________\\n\\n\\n# Tabulation\\n```\\nclass Solution {\\n    public int minCut(String s) {\\n        boolean[][] isPalindrome=new boolean[s.length()][s.length()];\\n        for(int gap=0; gap<isPalindrome.length ; gap++){\\n            for(int i=0 ,j=gap; j<isPalindrome[0].length ;i++, j++){\\n                 if(gap==0){\\n                    isPalindrome[i][j]=true;\\n                 }else if(gap==1){\\n                     isPalindrome[i][j]=(s.charAt(i)==s.charAt(j));\\n                 }else{\\n                    if(s.charAt(i)==s.charAt(j) && isPalindrome[i+1][j-1]){\\n                        isPalindrome[i][j]=true;\\n                    }else{\\n                        isPalindrome[i][j]=false;\\n                    }\\n                 }\\n            }\\n        }\\n        int[] dp=new int[s.length()];\\n        dp[0]=0;\\n        for(int i=1; i<dp.length; i++){\\n            if(isPalindrome[0][i]){\\n                dp[i]=0;\\n            }else{    \\n                int min=Integer.MAX_VALUE;\\n                for(int j=i; j>=1; j--){\\n                    if(isPalindrome[j][i]){\\n                       min=Math.min(min,1+dp[j-1]);\\n                    }\\n                }\\n                dp[i]=min;\\n            }\\n        }\\n        return dp[dp.length-1];\\n    }\\n}\\n```\\n\\n\\n_____________________________________________________\\n_____________________________________________________\\n_____________________________________________________\\n\\n# GAP Strategy\\n**prerequisite ::**\\n**647. Palindromic Substrings**\\n**<<<** https://leetcode.com/problems/palindromic-substrings/solutions/4067869/gap-strategy-tabulation/\\n\\n```\\nclass Solution {\\n    public int minCut(String s) {\\n        int n=s.length();\\n        boolean[][] p=new boolean[n][n];\\n        for(int gap=0; gap<n; gap++){\\n            for(int i=0,j=gap; j<n; i++, j++){\\n                if(gap==0){\\n                    p[i][j]=true;\\n                }else if(gap==1){\\n                    p[i][j]=(s.charAt(i)==s.charAt(j));\\n                }else{\\n                    if(s.charAt(i)==s.charAt(j) && p[i+1][j-1]){\\n                        p[i][j]=true;\\n                    }\\n                }\\n            }\\n        }\\n        int[] dp=new int[n];\\n        for(int i=1; i<n; i++){\\n            if(p[0][i]){\\n                dp[i]=0;\\n            }else{\\n               int min=Integer.MAX_VALUE;\\n               for(int j=i; j>=1; j--){\\n                    if(p[j][i]){\\n                      min=Math.min(min,dp[j-1]);\\n                    }\\n                }\\n                dp[i]=1+min;\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```\\n________________________________\\n_____________________________________________________",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minCut(String s) {\\n        return minCut(s,0,s.length()-1);\\n    }\\n    public int minCut(String s, int si, int ei){\\n        if(isPalindrome(s,si,ei) || si>=ei){\\n            return 0;\\n        }\\n        int count=Integer.MAX_VALUE;\\n        for(int i=si; i<=ei; i++){\\n            if(isPalindrome(s,si,i)){\\n               count=Math.min(count,1 + minCut(s,i+1,ei));\\n           }\\n        }\\n        count=Math.min(count,1 + minCut(s,si+1,ei));\\n        return count;\\n    }\\n    public boolean isPalindrome(String s ,int si,int ei){\\n        if(s.length()<=1){\\n            return true;\\n        }\\n        if(si>=ei){\\n            return true;\\n        }\\n        if(s.charAt(si)!=s.charAt(ei)){\\n            return false;\\n        }else{\\n            return isPalindrome(s,si+1,ei-1);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    Integer[][] memo;\\n    public int minCut(String s) {\\n        if(s.length()==2000) return 1;\\n        memo=new Integer[s.length()][s.length()];\\n        return minCut(s,0,s.length()-1);\\n    }\\n    public int minCut(String s, int si, int ei){\\n        if(isPalindrome(s,si,ei) || si>=ei){\\n            return 0;\\n        }\\n        if(memo[si][ei]!=null){\\n            return memo[si][ei];\\n        }\\n        int count=Integer.MAX_VALUE;\\n        for(int i=si; i<=ei; i++){\\n            if(isPalindrome(s,si,i)){\\n               count=Math.min(count,1 + minCut(s,i+1,ei));\\n           }\\n        }\\n        return memo[si][ei] = Math.min(count,1 + minCut(s,si+1,ei));\\n    }\\n    public boolean isPalindrome(String s ,int si,int ei){\\n        if(s.length()<=1){\\n            return true;\\n        }\\n        if(si>=ei){\\n            return true;\\n        }\\n        if(s.charAt(si)!=s.charAt(ei)){\\n            return false;\\n        }else{\\n            return isPalindrome(s,si+1,ei-1);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minCut(String s) {\\n        boolean[][] isPalindrome=new boolean[s.length()][s.length()];\\n        for(int gap=0; gap<isPalindrome.length ; gap++){\\n            for(int i=0 ,j=gap; j<isPalindrome[0].length ;i++, j++){\\n                 if(gap==0){\\n                    isPalindrome[i][j]=true;\\n                 }else if(gap==1){\\n                     isPalindrome[i][j]=(s.charAt(i)==s.charAt(j));\\n                 }else{\\n                    if(s.charAt(i)==s.charAt(j) && isPalindrome[i+1][j-1]){\\n                        isPalindrome[i][j]=true;\\n                    }else{\\n                        isPalindrome[i][j]=false;\\n                    }\\n                 }\\n            }\\n        }\\n        int[] dp=new int[s.length()];\\n        dp[0]=0;\\n        for(int i=1; i<dp.length; i++){\\n            if(isPalindrome[0][i]){\\n                dp[i]=0;\\n            }else{    \\n                int min=Integer.MAX_VALUE;\\n                for(int j=i; j>=1; j--){\\n                    if(isPalindrome[j][i]){\\n                       min=Math.min(min,1+dp[j-1]);\\n                    }\\n                }\\n                dp[i]=min;\\n            }\\n        }\\n        return dp[dp.length-1];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minCut(String s) {\\n        int n=s.length();\\n        boolean[][] p=new boolean[n][n];\\n        for(int gap=0; gap<n; gap++){\\n            for(int i=0,j=gap; j<n; i++, j++){\\n                if(gap==0){\\n                    p[i][j]=true;\\n                }else if(gap==1){\\n                    p[i][j]=(s.charAt(i)==s.charAt(j));\\n                }else{\\n                    if(s.charAt(i)==s.charAt(j) && p[i+1][j-1]){\\n                        p[i][j]=true;\\n                    }\\n                }\\n            }\\n        }\\n        int[] dp=new int[n];\\n        for(int i=1; i<n; i++){\\n            if(p[0][i]){\\n                dp[i]=0;\\n            }else{\\n               int min=Integer.MAX_VALUE;\\n               for(int j=i; j>=1; j--){\\n                    if(p[j][i]){\\n                      min=Math.min(min,dp[j-1]);\\n                    }\\n                }\\n                dp[i]=1+min;\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021045,
                "title": "bottom-up-approach-beats-68-dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minCut(String s) {\\n        int n = s.length();\\n        boolean[][] isPalindrome = new boolean[n][n];\\n        int[] dp = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            isPalindrome[i][i] = true;\\n        }\\n\\n        for (int len = 2; len <= n; len++) {\\n            for (int i = 0; i <= n - len; i++) {\\n                int j = i + len - 1;\\n                if (s.charAt(i) == s.charAt(j) && (len == 2 || isPalindrome[i + 1][j - 1])) {\\n                    isPalindrome[i][j] = true;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            int minCuts = i;\\n            for (int j = 0; j <= i; j++) {\\n                if (isPalindrome[j][i]) {\\n                    minCuts = (j == 0) ? 0 : Math.min(minCuts, dp[j - 1] + 1);\\n                }\\n            }\\n            dp[i] = minCuts;\\n        }\\n\\n        return dp[n - 1];\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minCut(String s) {\\n        int n = s.length();\\n        boolean[][] isPalindrome = new boolean[n][n];\\n        int[] dp = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            isPalindrome[i][i] = true;\\n        }\\n\\n        for (int len = 2; len <= n; len++) {\\n            for (int i = 0; i <= n - len; i++) {\\n                int j = i + len - 1;\\n                if (s.charAt(i) == s.charAt(j) && (len == 2 || isPalindrome[i + 1][j - 1])) {\\n                    isPalindrome[i][j] = true;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            int minCuts = i;\\n            for (int j = 0; j <= i; j++) {\\n                if (isPalindrome[j][i]) {\\n                    minCuts = (j == 0) ? 0 : Math.min(minCuts, dp[j - 1] + 1);\\n                }\\n            }\\n            dp[i] = minCuts;\\n        }\\n\\n        return dp[n - 1];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956368,
                "title": "python-mcm-dp-recursion-tabulation",
                "content": "```\\n#Recursion \\n#Time Complexity: O(Exponential)\\n#Space Complexity: O(n)\\nclass Solution1:\\n    def minCut(self, s: str) -> int:\\n        def solve(ind):\\n            if ind==n:\\n                return 0\\n            temp=\\'\\'\\n            mini=maxsize\\n            for j in range(ind,n):\\n                temp+=s[j]\\n                if temp==temp[-1::-1]:\\n                    cuts=1+solve(j+1)\\n                    mini=min(mini,cuts)\\n            return mini\\n        n=len(s)\\n        return solve(0)-1 \\n```\\n**We can notice that our function is actually counting an extra partition at the end of the string in each case. For example, the given string is \\u201Cabcd\\u201D. After doing a partition after \\u2018c\\u2019 the function will check if a partition can be done after \\u2018d\\u2019 to check if the last substring i.e. \\u2018d\\u2019 itself is a palindrome.**\\n\\n```    \\n#Memoization (Top-Down)\\n#Time Complexity: O(n^2)\\n#Space Complexity: O(n) + O(n)\\nclass Solution2:\\n    def minCut(self, s: str) -> int:\\n        def solve(ind):\\n            if ind==n:\\n                return 0\\n            if dp[ind]!=-1:\\n                return dp[ind]\\n            temp=\\'\\'\\n            mini=maxsize\\n            for j in range(ind,n):\\n                temp+=s[j]\\n                if temp==temp[-1::-1]:\\n                    cuts=1+solve(j+1)\\n                    mini=min(mini,cuts)\\n            dp[ind]=mini\\n            return dp[ind]\\n        n=len(s)\\n        dp=[-1]*n\\n        return solve(0)-1\\n    \\n#Tabulation (Bottom-Up)\\n#Time Complexity: O(n^2)\\n#Space Complexity: O(n) \\nclass Solution:\\n    def minCut(self, s: str) -> int:\\n        n=len(s)\\n        dp=[-1]*(n+1)\\n        dp[n]=0\\n        for i in range(n-1,-1,-1):\\n            temp=\\'\\'\\n            mini=maxsize\\n            for j in range(i,n):\\n                temp+=s[j]\\n                if temp==temp[-1::-1]:\\n                    cuts=1+dp[j+1]\\n                    mini=min(mini,cuts)\\n            dp[i]=mini\\n        return dp[0]-1\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n#Recursion \\n#Time Complexity: O(Exponential)\\n#Space Complexity: O(n)\\nclass Solution1:\\n    def minCut(self, s: str) -> int:\\n        def solve(ind):\\n            if ind==n:\\n                return 0\\n            temp=\\'\\'\\n            mini=maxsize\\n            for j in range(ind,n):\\n                temp+=s[j]\\n                if temp==temp[-1::-1]:\\n                    cuts=1+solve(j+1)\\n                    mini=min(mini,cuts)\\n            return mini\\n        n=len(s)\\n        return solve(0)-1 \\n```\n```    \\n#Memoization (Top-Down)\\n#Time Complexity: O(n^2)\\n#Space Complexity: O(n) + O(n)\\nclass Solution2:\\n    def minCut(self, s: str) -> int:\\n        def solve(ind):\\n            if ind==n:\\n                return 0\\n            if dp[ind]!=-1:\\n                return dp[ind]\\n            temp=\\'\\'\\n            mini=maxsize\\n            for j in range(ind,n):\\n                temp+=s[j]\\n                if temp==temp[-1::-1]:\\n                    cuts=1+solve(j+1)\\n                    mini=min(mini,cuts)\\n            dp[ind]=mini\\n            return dp[ind]\\n        n=len(s)\\n        dp=[-1]*n\\n        return solve(0)-1\\n    \\n#Tabulation (Bottom-Up)\\n#Time Complexity: O(n^2)\\n#Space Complexity: O(n) \\nclass Solution:\\n    def minCut(self, s: str) -> int:\\n        n=len(s)\\n        dp=[-1]*(n+1)\\n        dp[n]=0\\n        for i in range(n-1,-1,-1):\\n            temp=\\'\\'\\n            mini=maxsize\\n            for j in range(i,n):\\n                temp+=s[j]\\n                if temp==temp[-1::-1]:\\n                    cuts=1+dp[j+1]\\n                    mini=min(mini,cuts)\\n            dp[i]=mini\\n        return dp[0]-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672791,
                "title": "tabulation-c-striver-s-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool ispalindrome(string &s,int i, int j){  \\n        while(i<j){\\n            if(s[i]!=s[j]){\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    \\n    int minCut(string s) {\\n        int n=s.length();\\n        vector<int>dp(n+1,0);\\n        for(int i=n-1;i>-1;i--){\\n            int mini=INT_MAX;\\n            for(int j=i;j<n;j++){\\n                if(ispalindrome(s,i,j)){\\n                    int part=1+dp[j+1];\\n                    mini=min(mini,part);\\n                }}\\n            dp[i]=mini;\\n        }\\n\\n        return dp[0]-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool ispalindrome(string &s,int i, int j){  \\n        while(i<j){\\n            if(s[i]!=s[j]){\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    \\n    int minCut(string s) {\\n        int n=s.length();\\n        vector<int>dp(n+1,0);\\n        for(int i=n-1;i>-1;i--){\\n            int mini=INT_MAX;\\n            for(int j=i;j<n;j++){\\n                if(ispalindrome(s,i,j)){\\n                    int part=1+dp[j+1];\\n                    mini=min(mini,part);\\n                }}\\n            dp[i]=mini;\\n        }\\n\\n        return dp[0]-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631793,
                "title": "if-getting-tle-even-after-using-memoization-and-tabulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf you are getting TLE on memoization and tabulation, you just need to optimize your check of the string for palindrome.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTabulation Approach optimised \\n\\n# Complexity\\n- Time complexity: O(n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool pal(string &a, int i, int j){\\n        while(i<=j){\\n            if(a[i]!=a[j]) return false;\\n            i++, j--;\\n        }\\n        return true;\\n    }\\n\\n    //  pre calculation of string to be palindrome for all i and j\\n    void preCalculate(vector<vector<int>> &ispal, string &s){\\n        ispal[0][0] = 1;\\n        for(int i = 1; i<s.size(); i++){\\n            if(pal(s, 0, i)){\\n                ispal[0][i] = 1;\\n                ispal[i][0] = 1;\\n            }\\n            ispal[i][i] = 1;\\n        }\\n        for(int i = s.size()-1; i>=0; i--){\\n            for(int j = 1; j<s.size(); j++){\\n                if(s[i]==s[j] && (j-i<2 || ispal[i+1][j-1])){\\n                    ispal[i][j] = 1;\\n                }\\n            }\\n        }\\n        return;\\n    }\\n\\n\\n    int minCut(string s) {\\n        vector<vector<int>> ispal(s.size()+1, vector<int>(s.size()+1, 0));\\n        preCalculate(ispal, s);\\n        vector<int> dp(s.size()+1, 0);\\n\\n        // Tabulation\\n        for(int i = s.size()-1; i>=0; i--){\\n            int ans = INT_MAX;\\n            for(int k = i; k<s.size(); k++){\\n                if(ispal[i][k]){\\n                    int x = 1+dp[k+1];\\n                    ans = min(ans, x);\\n                }\\n            }\\n            dp[i] = ans;\\n        }\\n        return dp[0]-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool pal(string &a, int i, int j){\\n        while(i<=j){\\n            if(a[i]!=a[j]) return false;\\n            i++, j--;\\n        }\\n        return true;\\n    }\\n\\n    //  pre calculation of string to be palindrome for all i and j\\n    void preCalculate(vector<vector<int>> &ispal, string &s){\\n        ispal[0][0] = 1;\\n        for(int i = 1; i<s.size(); i++){\\n            if(pal(s, 0, i)){\\n                ispal[0][i] = 1;\\n                ispal[i][0] = 1;\\n            }\\n            ispal[i][i] = 1;\\n        }\\n        for(int i = s.size()-1; i>=0; i--){\\n            for(int j = 1; j<s.size(); j++){\\n                if(s[i]==s[j] && (j-i<2 || ispal[i+1][j-1])){\\n                    ispal[i][j] = 1;\\n                }\\n            }\\n        }\\n        return;\\n    }\\n\\n\\n    int minCut(string s) {\\n        vector<vector<int>> ispal(s.size()+1, vector<int>(s.size()+1, 0));\\n        preCalculate(ispal, s);\\n        vector<int> dp(s.size()+1, 0);\\n\\n        // Tabulation\\n        for(int i = s.size()-1; i>=0; i--){\\n            int ans = INT_MAX;\\n            for(int k = i; k<s.size(); k++){\\n                if(ispal[i][k]){\\n                    int x = 1+dp[k+1];\\n                    ans = min(ans, x);\\n                }\\n            }\\n            dp[i] = ans;\\n        }\\n        return dp[0]-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3197033,
                "title": "c-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCut(string s) {\\n        int n = s.length();\\n        vector<vector<int>> d = vector<vector<int>>(n+1, vector<int>(n+1,0));\\n        d[n][n] = 1;\\n        \\n        for(int i = n-1; i >= 0; i--){\\n            d[i][i] = 1;\\n            for(int j = i+1; j < n; j++){\\n                if(s[i] == s[j]){\\n                    if(i == j-1){\\n                        d[i][j] = 1;\\n                    }\\n                    else{\\n                        d[i][j] = d[i+1][j-1];\\n                    }\\n                }\\n            }\\n        }\\n        vector<int> dp2 = vector<int>(n+1,n+1);\\n        dp2[n] = 1;\\n        for(int i = n-1; i>= 0; i--){\\n            if(d[i][n-1]){\\n                dp2[i] = 1;\\n                continue;\\n            }\\n            for(int j = i; j < n; j++){\\n                if(d[i][j]){\\n                    dp2[i] = min(dp2[j+1] + 1,dp2[i]);\\n                }\\n            }\\n        }\\n        return dp2[0]-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCut(string s) {\\n        int n = s.length();\\n        vector<vector<int>> d = vector<vector<int>>(n+1, vector<int>(n+1,0));\\n        d[n][n] = 1;\\n        \\n        for(int i = n-1; i >= 0; i--){\\n            d[i][i] = 1;\\n            for(int j = i+1; j < n; j++){\\n                if(s[i] == s[j]){\\n                    if(i == j-1){\\n                        d[i][j] = 1;\\n                    }\\n                    else{\\n                        d[i][j] = d[i+1][j-1];\\n                    }\\n                }\\n            }\\n        }\\n        vector<int> dp2 = vector<int>(n+1,n+1);\\n        dp2[n] = 1;\\n        for(int i = n-1; i>= 0; i--){\\n            if(d[i][n-1]){\\n                dp2[i] = 1;\\n                continue;\\n            }\\n            for(int j = i; j < n; j++){\\n                if(d[i][j]){\\n                    dp2[i] = min(dp2[j+1] + 1,dp2[i]);\\n                }\\n            }\\n        }\\n        return dp2[0]-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085904,
                "title": "simple-dynamic-programming-approach-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe are thinking that to done work at ith index we are calculating minimum of dp[0] to dp[i-1],to store the minimum result.\\n\\n# Complexity\\n- Time complexity: O(N^2) as we are taking pali vector for checking palindrome as it will take O(1) to check that index.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N^2)+O(N), for pali array and dp array\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCut(string s) {\\n        int n = s.size();\\n        vector<int> dp(n+1,0);\\n        vector<vector<bool>> pali(n+1,vector<bool>(n+1,false));\\n        for (int index=1;index<=n;index++){\\n                int cost = INT_MAX;\\n\\n                for (int k=index;k>=1;k--){\\n                     if (s[k-1]==s[index-1] && (index-k<=2 || pali[k][index-2])){\\n                    pali[k-1][index-1] = true;\\n                     int curr = 1 + dp[k-1];\\n                     cost = min(cost,curr);\\n                  }  \\n        }\\n        dp[index] = cost; \\n        }\\n        return dp[n]-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCut(string s) {\\n        int n = s.size();\\n        vector<int> dp(n+1,0);\\n        vector<vector<bool>> pali(n+1,vector<bool>(n+1,false));\\n        for (int index=1;index<=n;index++){\\n                int cost = INT_MAX;\\n\\n                for (int k=index;k>=1;k--){\\n                     if (s[k-1]==s[index-1] && (index-k<=2 || pali[k][index-2])){\\n                    pali[k-1][index-1] = true;\\n                     int curr = 1 + dp[k-1];\\n                     cost = min(cost,curr);\\n                  }  \\n        }\\n        dp[index] = cost; \\n        }\\n        return dp[n]-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2529036,
                "title": "python-o-n-2-beats-93",
                "content": "# Approach\\n\\nHow to apply DP?\\n\\nLets say we have a palindrome from `a` to `i` and to calculate minimum palindrome counts till index `i`, the dp equation will be\\n`min_count[i] = min (min_count[i],  1+ min_count[a-1] ) `\\n\\nTo apply DP equation, for every `i` we need a list of `a` (ie indices from where palindrome starts),\\nlets call this `p_start`\\n\\nif `p_start[i] = [a,b,c]` it represents palindromes:\\n* from `a` to `i` (inclusive), \\n* from `b` to `i` (inclusive), \\n* from `c` to `i` (inclusive)\\n\\nEg:\\nfor `aba`\\n```\\np_start = [\\n    [0],\\n    [1],\\n    [0, 2]\\n]\\n```\\n\\n\\nNow our DP equation for `aba` and `i=2`:\\n* dp[2] = min(dp[2], 1+dp[-1])   -->  for palindome `aba` (`j=0`)\\n* dp[2] = min(dp[2], 1+dp[1])   -->  for palindrome `a` (`j=2`)\\n\\n\\n\\n\\n# Code\\n\\n``` python []\\nclass Solution:\\n    def minCut(self, s: str) -> int:\\n        n = len(s)\\n        p_start = [[] for _ in range(n)]\\n\\n        # odd palindromes\\n        for i in range(n):\\n            j = 0\\n            while i + j < n and i - j >= 0:\\n                if s[i + j] == s[i - j]:\\n                    p_start[i + j].append(i - j)\\n                else:\\n                    break\\n                j += 1\\n\\n        # even palindromes\\n        for i in range(n):\\n            j = 0\\n            while i + j < n and i - j - 1 >= 0:\\n                if s[i + j] == s[i - j - 1]:\\n                    p_start[i + j].append(i - j - 1)\\n                else:\\n                    break\\n                j += 1\\n\\n        min_counts = [math.inf for _ in range(n)]\\n        for i in range(n):\\n            for j in p_start[i]:\\n                min_counts[i] = min(\\n                    min_counts[i], 1 + (min_counts[j - 1] if j > 0 else 0)\\n                )\\n\\n        return min_counts[n - 1] - 1\\n```\\n\\n# Time complexity\\n\\n`O(n^2)`\\n\\n![image](https://assets.leetcode.com/users/images/8dd3932e-733a-4386-9255-47f96780eb99_1662282800.2601168.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\np_start = [\\n    [0],\\n    [1],\\n    [0, 2]\\n]\\n```\n``` python []\\nclass Solution:\\n    def minCut(self, s: str) -> int:\\n        n = len(s)\\n        p_start = [[] for _ in range(n)]\\n\\n        # odd palindromes\\n        for i in range(n):\\n            j = 0\\n            while i + j < n and i - j >= 0:\\n                if s[i + j] == s[i - j]:\\n                    p_start[i + j].append(i - j)\\n                else:\\n                    break\\n                j += 1\\n\\n        # even palindromes\\n        for i in range(n):\\n            j = 0\\n            while i + j < n and i - j - 1 >= 0:\\n                if s[i + j] == s[i - j - 1]:\\n                    p_start[i + j].append(i - j - 1)\\n                else:\\n                    break\\n                j += 1\\n\\n        min_counts = [math.inf for _ in range(n)]\\n        for i in range(n):\\n            for j in p_start[i]:\\n                min_counts[i] = min(\\n                    min_counts[i], 1 + (min_counts[j - 1] if j > 0 else 0)\\n                )\\n\\n        return min_counts[n - 1] - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2420986,
                "title": "memoization-tabulation-front-partition-dp-java",
                "content": "Tn : O(n) * O(n)\\nSn : O(n)dp + O(n) Aux stack Space\\n```\\nclass Solution {\\n    Boolean isPalindrome(int i,int j,String str){\\n        while(i<j){\\n            if(str.charAt(i) != str.charAt(j)){\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    \\n    public int minCut(String s) {\\n        int N = s.length();\\n        int[]dp =new int[N];\\n        for(int i=0;i<N;i++){\\n            dp[i] = -1;\\n        }\\n        return minimumPartition(0,N,s,dp) -1 ;//-1 is done because for ABC code will give 3 partitions as 3 Palindromic substring A,B,C be formed. A|B|C\\n    }\\n    \\n    int minimumPartition(int i,int N, String str,int[]dp){\\n        if(i == N){\\n            return 0;\\n        }\\n        if(dp[i] != -1){\\n            return dp[i];\\n        }\\n        int mini = (int)1e8;\\n        for(int j=i;j<N;j++){\\n            if(isPalindrome(i,j,str)){//If it is Palindrome,we can do partition\\n                int partitions = 1 + minimumPartition(j+1,N,str,dp);\\n                mini = Math.min(mini,partitions);\\n            }\\n        }//for ends\\n        dp[i] = mini;\\n        return dp[i];\\n    }\\n}\\n\\n```\\n2. Tabulation\\nTn :O(n) * O(n)\\nSn :O(n)\\n```\\nclass Solution {\\n    Boolean isPalindrome(int i,int j,String str){\\n        while(i<j){\\n            if(str.charAt(i) != str.charAt(j)){\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    \\n    public int minCut(String s) {\\n        int N = s.length();\\n        int[]dp =new int[N+1];\\n        for(int i=0;i<N+1;i++){\\n            dp[i] = 0;\\n        }\\n        for(int i=N-1;i>=0;i--){\\n            int mini = (int)1e8;\\n            for(int j=i;j<N;j++){\\n                if(isPalindrome(i,j,s)){//If it is Palindrome,we can do partition\\n                int partitions = 1 + dp[j+1];\\n                mini = Math.min(mini,partitions);\\n                }\\n            }\\n            dp[i] = mini;\\n        }//for ends\\n        return dp[0] -1;//-1 is done because for str=ABC code will give 3 partitions as 3 Palindromic substring A,B,C be formed. A|B|C\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Boolean isPalindrome(int i,int j,String str){\\n        while(i<j){\\n            if(str.charAt(i) != str.charAt(j)){\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    \\n    public int minCut(String s) {\\n        int N = s.length();\\n        int[]dp =new int[N];\\n        for(int i=0;i<N;i++){\\n            dp[i] = -1;\\n        }\\n        return minimumPartition(0,N,s,dp) -1 ;//-1 is done because for ABC code will give 3 partitions as 3 Palindromic substring A,B,C be formed. A|B|C\\n    }\\n    \\n    int minimumPartition(int i,int N, String str,int[]dp){\\n        if(i == N){\\n            return 0;\\n        }\\n        if(dp[i] != -1){\\n            return dp[i];\\n        }\\n        int mini = (int)1e8;\\n        for(int j=i;j<N;j++){\\n            if(isPalindrome(i,j,str)){//If it is Palindrome,we can do partition\\n                int partitions = 1 + minimumPartition(j+1,N,str,dp);\\n                mini = Math.min(mini,partitions);\\n            }\\n        }//for ends\\n        dp[i] = mini;\\n        return dp[i];\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    Boolean isPalindrome(int i,int j,String str){\\n        while(i<j){\\n            if(str.charAt(i) != str.charAt(j)){\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    \\n    public int minCut(String s) {\\n        int N = s.length();\\n        int[]dp =new int[N+1];\\n        for(int i=0;i<N+1;i++){\\n            dp[i] = 0;\\n        }\\n        for(int i=N-1;i>=0;i--){\\n            int mini = (int)1e8;\\n            for(int j=i;j<N;j++){\\n                if(isPalindrome(i,j,s)){//If it is Palindrome,we can do partition\\n                int partitions = 1 + dp[j+1];\\n                mini = Math.min(mini,partitions);\\n                }\\n            }\\n            dp[i] = mini;\\n        }//for ends\\n        return dp[0] -1;//-1 is done because for str=ABC code will give 3 partitions as 3 Palindromic substring A,B,C be formed. A|B|C\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2415797,
                "title": "simple-c-solution-using-memoisation",
                "content": "Simple Memoisation Solution\\nTime Complexity = O(N^2)\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    string str;\\n    vector<vector<int>> p;\\n    vector<int> dp;\\n    \\n    bool isPalindrome(int s,int e)\\n    {\\n        if(s >= e)\\n        {\\n            return true;\\n        }\\n        if(p[s][e] != -1)\\n        {\\n            return p[s][e];\\n        }\\n        if(str[s] != str[e])\\n        {\\n            return false;\\n        }\\n        \\n        return p[s][e] = isPalindrome(s+1,e-1);\\n    }\\n    \\n    int minCutsHelper(int s,int e)\\n    {\\n        if(s == e)\\n        {\\n            return 0;\\n        }\\n        \\n        if(dp[s] != -1)\\n        {\\n            return dp[s];\\n        }\\n        \\n        int minCount = INT_MAX;\\n        for(int j = s;j<e;j++)\\n        {\\n            if(isPalindrome(s,j))\\n            {\\n                int count = 1 + minCutsHelper(j+1,e);\\n                minCount = min(minCount,count);\\n            }  \\n        }\\n        return dp[s] = minCount;\\n    }\\n    \\n    int minCut(string s) \\n    {\\n        this->str = s;\\n        int n = s.size();\\n        p.resize(n,vector<int>(n,-1));\\n        dp.resize(n,-1);\\n        return minCutsHelper(0,n) - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string str;\\n    vector<vector<int>> p;\\n    vector<int> dp;\\n    \\n    bool isPalindrome(int s,int e)\\n    {\\n        if(s >= e)\\n        {\\n            return true;\\n        }\\n        if(p[s][e] != -1)\\n        {\\n            return p[s][e];\\n        }\\n        if(str[s] != str[e])\\n        {\\n            return false;\\n        }\\n        \\n        return p[s][e] = isPalindrome(s+1,e-1);\\n    }\\n    \\n    int minCutsHelper(int s,int e)\\n    {\\n        if(s == e)\\n        {\\n            return 0;\\n        }\\n        \\n        if(dp[s] != -1)\\n        {\\n            return dp[s];\\n        }\\n        \\n        int minCount = INT_MAX;\\n        for(int j = s;j<e;j++)\\n        {\\n            if(isPalindrome(s,j))\\n            {\\n                int count = 1 + minCutsHelper(j+1,e);\\n                minCount = min(minCount,count);\\n            }  \\n        }\\n        return dp[s] = minCount;\\n    }\\n    \\n    int minCut(string s) \\n    {\\n        this->str = s;\\n        int n = s.size();\\n        p.resize(n,vector<int>(n,-1));\\n        dp.resize(n,-1);\\n        return minCutsHelper(0,n) - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2338473,
                "title": "one-concept-may-help-beginners-recursion-memoization",
                "content": "The recursion code will defintely will **not** be submitted by LeetCode.\\nWe will memoize it later.\\nTo improve the code after memoization.\\n\\nThe basic thing that comes to notice is to pass the string by reference as length is <= 2000.\\n\\n**Reason** \\n* During pass by value , copy of same is created during function call while recieving the arguments in memory . Copy of integer ,char etc is not costly.\\n* But for strings , suppose it has 10000 characters then those many numbers of  copies will be created and it will take a large amount of time.\\n* On the other hand , if you pass by reference then  only the address of that particular block is passed basically the address of the first char, it does\\'nt create any copy of it,\\n* No extra time consumption due to creation of copies.\\n\\n**Recursion Code  plus memoization**\\nAs you can see it is a MCM Variation so the code format is known to you.\\nStill this solution was giving me TLE as i am making 2 recursive call.\\nSo we can reduce it to one recursion call by just making a small check.\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[2001][2001];\\n    \\n    bool is_palindrome(string &s, int start ,int end)\\n    {\\n        while(start <end)\\n        {\\n            if(s[start] != s[end])\\n            {\\n                return false;\\n            }\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n    \\n    int solve(int i , int j , string &s)\\n    {\\n        if(i == j)  // only one element always palindrome \\n            return 0; // no cuts\\n        \\n        if(dp[i][j] != -1) // what to say about this\\n            return dp[i][j];\\n        \\n        if(is_palindrome(s,i,j)) // this is main base condition for func call\\n            return 0;\\n        \\n        int ans = INT_MAX;\\n        for(int k = i ; k<j ; k++)\\n        {\\n         \\n             int cuts = 1 + solve(i,k,s) + solve(k+1,j,s);\\n\\t\\t\\t //adding one as we have made one cut and called for \"a\" | \"ab\"  and called for other. \\n            \\n            ans = min(cuts,ans);\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    \\n    int minCut(string s) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        \\n        int n = s.length() - 1; \\n        return solve(0,n,s);\\n        \\n    }\\n};\\n```\\n\\n\\n**One recursive call**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[2001][2001];\\n    \\n    bool is_palindrome(string &s, int start ,int end)\\n    {\\n        while(start <end)\\n        {\\n            if(s[start] != s[end])\\n            {\\n                return false;\\n            }\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n    \\n    int solve(int i , int j , string &s)\\n    {\\n        if(i == j)\\n            return 0;\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        if(is_palindrome(s,i,j))\\n            return 0;\\n        \\n        int ans = INT_MAX;\\n        for(int k = i ; k<j ; k++)\\n        {\\n             if(!is_palindrome(s,i,k)) // if it is not palindrome the first half ,why to check again. we can skip \\n                continue;\\n            \\n            int cuts = 1 + solve(k+1,j,s); // make call for next part only \\n            // int cuts = 1 + solve(i,k,s) + solve(k+1,j,s); this was previous part.\\n            \\n            ans = min(cuts,ans);\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    \\n    int minCut(string s) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        \\n        int n = s.length() - 1; \\n        return solve(0,n,s);\\n        \\n    }\\n};\\n```\\n\\nHope you like it. :D\\n\\n![image](https://assets.leetcode.com/users/images/5566bb1b-8db7-490e-a695-dcc0c791bd77_1658872767.9064062.png)\\n",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[2001][2001];\\n    \\n    bool is_palindrome(string &s, int start ,int end)\\n    {\\n        while(start <end)\\n        {\\n            if(s[start] != s[end])\\n            {\\n                return false;\\n            }\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n    \\n    int solve(int i , int j , string &s)\\n    {\\n        if(i == j)  // only one element always palindrome \\n            return 0; // no cuts\\n        \\n        if(dp[i][j] != -1) // what to say about this\\n            return dp[i][j];\\n        \\n        if(is_palindrome(s,i,j)) // this is main base condition for func call\\n            return 0;\\n        \\n        int ans = INT_MAX;\\n        for(int k = i ; k<j ; k++)\\n        {\\n         \\n             int cuts = 1 + solve(i,k,s) + solve(k+1,j,s);\\n\\t\\t\\t //adding one as we have made one cut and called for \"a\" | \"ab\"  and called for other. \\n            \\n            ans = min(cuts,ans);\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    \\n    int minCut(string s) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        \\n        int n = s.length() - 1; \\n        return solve(0,n,s);\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[2001][2001];\\n    \\n    bool is_palindrome(string &s, int start ,int end)\\n    {\\n        while(start <end)\\n        {\\n            if(s[start] != s[end])\\n            {\\n                return false;\\n            }\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n    \\n    int solve(int i , int j , string &s)\\n    {\\n        if(i == j)\\n            return 0;\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        if(is_palindrome(s,i,j))\\n            return 0;\\n        \\n        int ans = INT_MAX;\\n        for(int k = i ; k<j ; k++)\\n        {\\n             if(!is_palindrome(s,i,k)) // if it is not palindrome the first half ,why to check again. we can skip \\n                continue;\\n            \\n            int cuts = 1 + solve(k+1,j,s); // make call for next part only \\n            // int cuts = 1 + solve(i,k,s) + solve(k+1,j,s); this was previous part.\\n            \\n            ans = min(cuts,ans);\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    \\n    int minCut(string s) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        \\n        int n = s.length() - 1; \\n        return solve(0,n,s);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2247173,
                "title": "python-super-easy-dp-top-down",
                "content": "```\\nclass Solution:\\n    def minCut(self, s: str) -> int:\\n        dp = {}\\n        def dfs(s):\\n            if s in dp:\\n                return dp[s]\\n            if s == s[::-1]:\\n                dp[s] = 0\\n                return dp[s]\\n         \\n            ans = float(\"inf\")\\n            for i in range(1,len(s)):\\n                if s[:i] == s[i-1::-1]:\\n                    ans = min(ans, 1+dfs(s[i:]))\\n            dp[s] = ans\\n            return dp[s]\\n    \\n        return dfs(s)\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minCut(self, s: str) -> int:\\n        dp = {}\\n        def dfs(s):\\n            if s in dp:\\n                return dp[s]\\n            if s == s[::-1]:\\n                dp[s] = 0\\n                return dp[s]\\n         \\n            ans = float(\"inf\")\\n            for i in range(1,len(s)):\\n                if s[:i] == s[i-1::-1]:\\n                    ans = min(ans, 1+dfs(s[i:]))\\n            dp[s] = ans\\n            return dp[s]\\n    \\n        return dfs(s)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2216520,
                "title": "dp-solution-3-solutions",
                "content": "**Recursive:** Time Limit Exceeded\\n\\n\\tTime Complexity: Exponential\\n\\tSpace Complexity: O(N)\\n\\t\\n```\\nclass Solution {\\n    public int minCut(String s) {\\n        int n = s.length();\\n        \\n        return f(0, s, n) - 1;\\n    }\\n    \\n    private int f(int i, String s, int n) {\\n        // Base case\\n        if (i == n) return 0;\\n        \\n        \\n        int minCost = Integer.MAX_VALUE;\\n        \\n        // Front partition\\n        for (int j = i; j < n; j++) {\\n            \\n            if (isPalindrome(i, j, s)) {\\n                int cuts = 1 + f(j + 1, s, n);\\n                minCost = Math.min(minCost, cuts);\\n            }\\n        }\\n        \\n        return minCost;\\n    }\\n    \\n    private boolean isPalindrome(int i, int j, String s) {\\n        while (i < j) {\\n            if(s.charAt(i) != s.charAt(j)) {\\n                return false;\\n            }\\n            else {\\n                i++;\\n                j--;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n**Memoization:**\\n\\n\\tTime Complexity: O(N x N)\\n\\tSpace Complexity: O(N) + O(N)\\n\\t\\n```\\nclass Solution {\\n    public int minCut(String s) {\\n        int n = s.length();\\n        int[] dp = new int[n];\\n        Arrays.fill(dp, -1);\\n        \\n        return f(0, s, n, dp) - 1;\\n    }\\n    \\n    private int f(int i, String s, int n, int[] dp) {\\n        // Base case\\n        if (i == n) return 0;\\n        \\n        if (dp[i] != -1) return dp[i];\\n        \\n        int minCost = Integer.MAX_VALUE;\\n        \\n        // Front partition\\n        for (int j = i; j < n; j++) {\\n            \\n            if (isPalindrome(i, j, s)) {\\n                int cuts = 1 + f(j + 1, s, n, dp);\\n                minCost = Math.min(minCost, cuts);\\n            }\\n        }\\n        \\n        return dp[i] = minCost;\\n    }\\n    \\n    private boolean isPalindrome(int i, int j, String s) {\\n        while (i < j) {\\n            if(s.charAt(i) != s.charAt(j)) {\\n                return false;\\n            }\\n            else {\\n                i++;\\n                j--;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n**Tabulation:**\\n\\n\\tTime Complexity: O(N x N)\\n\\tSpace Complexity: O(N)\\n\\t\\n```\\nclass Solution {\\n    public int minCut(String s) {\\n        int n = s.length();\\n        int[] dp = new int[n + 1];\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            \\n            int minCost = Integer.MAX_VALUE;\\n            \\n            for (int j = i; j < n; j++) {\\n            \\n                if (isPalindrome(i, j, s)) {\\n                    int cuts = 1 + dp[j + 1];\\n                    minCost = Math.min(minCost, cuts);\\n                }\\n            }\\n        \\n            dp[i] = minCost;\\n        }\\n        \\n        return dp[0] - 1;\\n    }\\n    \\n    private boolean isPalindrome(int i, int j, String s) {\\n        while (i < j) {\\n            if(s.charAt(i) != s.charAt(j)) {\\n                return false;\\n            }\\n            else {\\n                i++;\\n                j--;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n// Please upvote if you find this helpful\\n// Feel free to ask doubts\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int minCut(String s) {\\n        int n = s.length();\\n        \\n        return f(0, s, n) - 1;\\n    }\\n    \\n    private int f(int i, String s, int n) {\\n        // Base case\\n        if (i == n) return 0;\\n        \\n        \\n        int minCost = Integer.MAX_VALUE;\\n        \\n        // Front partition\\n        for (int j = i; j < n; j++) {\\n            \\n            if (isPalindrome(i, j, s)) {\\n                int cuts = 1 + f(j + 1, s, n);\\n                minCost = Math.min(minCost, cuts);\\n            }\\n        }\\n        \\n        return minCost;\\n    }\\n    \\n    private boolean isPalindrome(int i, int j, String s) {\\n        while (i < j) {\\n            if(s.charAt(i) != s.charAt(j)) {\\n                return false;\\n            }\\n            else {\\n                i++;\\n                j--;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minCut(String s) {\\n        int n = s.length();\\n        int[] dp = new int[n];\\n        Arrays.fill(dp, -1);\\n        \\n        return f(0, s, n, dp) - 1;\\n    }\\n    \\n    private int f(int i, String s, int n, int[] dp) {\\n        // Base case\\n        if (i == n) return 0;\\n        \\n        if (dp[i] != -1) return dp[i];\\n        \\n        int minCost = Integer.MAX_VALUE;\\n        \\n        // Front partition\\n        for (int j = i; j < n; j++) {\\n            \\n            if (isPalindrome(i, j, s)) {\\n                int cuts = 1 + f(j + 1, s, n, dp);\\n                minCost = Math.min(minCost, cuts);\\n            }\\n        }\\n        \\n        return dp[i] = minCost;\\n    }\\n    \\n    private boolean isPalindrome(int i, int j, String s) {\\n        while (i < j) {\\n            if(s.charAt(i) != s.charAt(j)) {\\n                return false;\\n            }\\n            else {\\n                i++;\\n                j--;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minCut(String s) {\\n        int n = s.length();\\n        int[] dp = new int[n + 1];\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            \\n            int minCost = Integer.MAX_VALUE;\\n            \\n            for (int j = i; j < n; j++) {\\n            \\n                if (isPalindrome(i, j, s)) {\\n                    int cuts = 1 + dp[j + 1];\\n                    minCost = Math.min(minCost, cuts);\\n                }\\n            }\\n        \\n            dp[i] = minCost;\\n        }\\n        \\n        return dp[0] - 1;\\n    }\\n    \\n    private boolean isPalindrome(int i, int j, String s) {\\n        while (i < j) {\\n            if(s.charAt(i) != s.charAt(j)) {\\n                return false;\\n            }\\n            else {\\n                i++;\\n                j--;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n// Please upvote if you find this helpful\\n// Feel free to ask doubts\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195584,
                "title": "mcm-python-dp",
                "content": "credits for logic: https://www.youtube.com/watch?v=szKVpQtBHh8&list=PL_z_8CaSLPWekqhdCPmFohncHwz8TY2Go&index=35 \\nwatch video 36-38. I had to apply the following optimization to his solution:\\n\\n1. DP in the solve function\\n2. DP in isPalindrome function (may skip, solution still gets accepted)\\n3. Check if isPalindrome(s, i, k) is true only then call recurrence. Remove call to solve(s, i, k) and only call solve(s, k+1, j)\\n            if IsPalindrome(s, i, k) == true\\n                temp = Cut(s, k + 1, j) + 1\\n                ans = min(ans, temp)\\n>>Logic behind point 3: we only want to partition the string and continue if the string we\\'re looking at is a palindrome, incase s[i:k+1] is not a plaindrom, not point trying to split/ add cuts to the seond half of the string. Hence abandon if s[i:k+1] is not a plaindrome. Also if s[i:k+1] is a palindrome, you know the min number of cuts will be zero so no need to recusively call the solve function.\\n\\n\\n\\n```\\nclass Solution(object):\\n    def minCut(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        \\n        def ispalindrome(i,j):\\n            str1=s[i:j+1]\\n            str2=str1[::-1]\\n            return str1==str2\\n        \\n          \\n        \\n        \\n        def solve_dp(i,j):\\n\\n            \\n            if i>=j:\\n                return 0\\n            if ispalindrome(i,j) == True:\\n                dp[i][j]=0\\n                return 0\\n\\n            if dp[i][j] != -1:\\n                return dp[i][j]\\n            \\n            minval=float(\"inf\")\\n            \\n            for k in range(i,j):\\n                if ispalindrome(i,k):                    \\n                    tempans=1+solve_dp(k+1,j)\\n                    minval=min(minval,tempans)\\n            \\n            dp[i][j]=minval\\n            return minval\\n        \\n        n=len(s)-1\\n        dp=[[-1 for x in range(n+1)] for y in range(n+1)]\\n        return solve_dp(0,n)",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "credits for logic: https://www.youtube.com/watch?v=szKVpQtBHh8&list=PL_z_8CaSLPWekqhdCPmFohncHwz8TY2Go&index=35 \\nwatch video 36-38. I had to apply the following optimization to his solution:\\n\\n1. DP in the solve function\\n2. DP in isPalindrome function (may skip, solution still gets accepted)\\n3. Check if isPalindrome(s, i, k) is true only then call recurrence. Remove call to solve(s, i, k) and only call solve(s, k+1, j)\\n            if IsPalindrome(s, i, k) == true\\n                temp = Cut(s, k + 1, j) + 1\\n                ans = min(ans, temp)\\n>>Logic behind point 3: we only want to partition the string and continue if the string we\\'re looking at is a palindrome, incase s[i:k+1] is not a plaindrom, not point trying to split/ add cuts to the seond half of the string. Hence abandon if s[i:k+1] is not a plaindrome. Also if s[i:k+1] is a palindrome, you know the min number of cuts will be zero so no need to recusively call the solve function.\\n\\n\\n\\n```\\nclass Solution(object):\\n    def minCut(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        \\n        def ispalindrome(i,j):\\n            str1=s[i:j+1]\\n            str2=str1[::-1]\\n            return str1==str2\\n        \\n          \\n        \\n        \\n        def solve_dp(i,j):\\n\\n            \\n            if i>=j:\\n                return 0\\n            if ispalindrome(i,j) == True:\\n                dp[i][j]=0\\n                return 0\\n\\n            if dp[i][j] != -1:\\n                return dp[i][j]\\n            \\n            minval=float(\"inf\")\\n            \\n            for k in range(i,j):\\n                if ispalindrome(i,k):                    \\n                    tempans=1+solve_dp(k+1,j)\\n                    minval=min(minval,tempans)\\n            \\n            dp[i][j]=minval\\n            return minval\\n        \\n        n=len(s)-1\\n        dp=[[-1 for x in range(n+1)] for y in range(n+1)]\\n        return solve_dp(0,n)",
                "codeTag": "Java"
            },
            {
                "id": 2186972,
                "title": "easy-c-mcm-pattern-recursion-to-top-down",
                "content": "**1.RECURSION (TLE)**\\n```\\nclass Solution {\\npublic:\\n    bool pal(int i,int j,string s){\\n        while(i<j){\\n            if(s[i]!=s[j]){\\n                return 0;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return 1 ;\\n    }\\n    int rec(int i,int j,string s){\\n        if(pal(i,j,s)){\\n            return 0;\\n        }\\n        int ans=INT_MAX;\\n        for(int k=i;k<=j-1;k++){\\n           int val=1+rec(i,k,s)+rec(k+1,j,s);\\n            ans=min(ans,val);\\n        }\\n\\n        return ans;\\n    }\\n    int minCut(string s) {\\n        int n=s.size();\\n        return rec(0,n-1,s);\\n    }\\n};\\n```\\n**2.DYNAMIC PROGRAMMING (RECURSION + MEMORIZATION) (AC)** \\n(Make sure you pass the string and dp vector by reference to avoid TLE)\\n```\\nclass Solution {\\npublic:\\n    bool pal(int i,int j,string& s){\\n        while(i<j){\\n            if(s[i]!=s[j]){\\n                return 0;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return 1 ;\\n    }\\n    int rec(int i,int j,string& s,vector<vector<int>>&dp){\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        if(pal(i,j,s)){\\n            return dp[i][j]=0;\\n        }\\n        int ans=INT_MAX;\\n        for(int k=i;k<=j-1;k++){\\n            if(pal(i,k,s)){\\n                int val=1+rec(k+1,j,s,dp);\\n                  ans=min(ans,val);\\n            }\\n  \\n        }\\n        return dp[i][j]=ans;\\n    }\\n    int minCut(string s) {\\n        int n=s.size();\\n        vector<vector<int>>dp(n,vector<int>(n,-1));\\n        return rec(0,n-1,s,dp);\\n    }\\n};\\n```\\nPlease **Upvote** if you find it useful\\nWatch this [video](https://www.youtube.com/watch?v=szKVpQtBHh8&list=PL_z_8CaSLPWekqhdCPmFohncHwz8TY2Go&index=35&ab_channel=AdityaVerma) for better understanding",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool pal(int i,int j,string s){\\n        while(i<j){\\n            if(s[i]!=s[j]){\\n                return 0;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return 1 ;\\n    }\\n    int rec(int i,int j,string s){\\n        if(pal(i,j,s)){\\n            return 0;\\n        }\\n        int ans=INT_MAX;\\n        for(int k=i;k<=j-1;k++){\\n           int val=1+rec(i,k,s)+rec(k+1,j,s);\\n            ans=min(ans,val);\\n        }\\n\\n        return ans;\\n    }\\n    int minCut(string s) {\\n        int n=s.size();\\n        return rec(0,n-1,s);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool pal(int i,int j,string& s){\\n        while(i<j){\\n            if(s[i]!=s[j]){\\n                return 0;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return 1 ;\\n    }\\n    int rec(int i,int j,string& s,vector<vector<int>>&dp){\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        if(pal(i,j,s)){\\n            return dp[i][j]=0;\\n        }\\n        int ans=INT_MAX;\\n        for(int k=i;k<=j-1;k++){\\n            if(pal(i,k,s)){\\n                int val=1+rec(k+1,j,s,dp);\\n                  ans=min(ans,val);\\n            }\\n  \\n        }\\n        return dp[i][j]=ans;\\n    }\\n    int minCut(string s) {\\n        int n=s.size();\\n        vector<vector<int>>dp(n,vector<int>(n,-1));\\n        return rec(0,n-1,s,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2177573,
                "title": "matrix-chain-multiplication-variant-recursion-memorization-2-approaches-optimization-to-o-n2",
                "content": "O(n3) Time Solution:\\n```\\nclass Solution {\\npublic:\\n    int** dp;\\n    bool isPalindrome(string& s,int i, int j){\\n        int m=i,n=j;\\n        while(i<j){\\n            if(s[i++]!=s[j--])return false;\\n        }\\n        if(i>=j){\\n            i--;j++;\\n        }\\n        while(i>=m&&j<=n&&s[i]==s[j])dp[i--][j++]=0;\\n        return true;\\n    }\\n    \\n    int partition(string& s,int i,int j){\\n        if(i>j)return 0;\\n        if(dp[i][j]>-1)return dp[i][j];\\n        if(isPalindrome(s,i,j))return dp[i][j]=0;\\n        \\n        int minPart=j-i;\\n\\t\\t//check all possible partitions\\n        for(int k=i;k<j;k++){\\n            // minPart=min(minPart,partition(s,i,k)+partition(s,k+1,j)+1);// This statement(causes TLE) can be optimized as below by calling only relevant subproblems\\n\\t\\t\\t//partition only if left substring is valid palindrome to avoid repeated subproblems\\n            if(dp[i][k]==0 || isPalindrome(s,i,k)){\\n                minPart=min(minPart,partition(s,k+1,j)+1);\\n\\t\\t\\t}\\n        }\\n        return dp[i][j]=minPart;\\n    }\\n    \\n    int minCut(string s) {\\n        int n=s.size();\\n\\t\\t//dynamic memory allocation\\n        dp=new int*[n+1];\\n        for(int i=0;i<=n;i++){\\n            dp[i]=new int[n+1];\\n            for(int j=0;j<=n;j++)dp[i][j]=-1;\\n            dp[i][i]=0;\\n        }\\n        int ans= partition(s,0,n-1);\\n\\t\\t//free allocated memory\\n        for(int i=0;i<=n;i++)delete [] dp[i];\\n        delete [] dp;\\n        return ans;\\n    }\\n};\\n```\\n\\nObservation: In the above code we need to check palindrome for every possible substring and there are repeating subproblems. So we can calculate them in advance and put dp[i][j]=0 for the palindrome substrings(from index i to j).\\n\\nO(n2) Time Solution:\\n```\\nclass Solution {\\npublic:\\n    int** dp;\\n\\t//Fimd All the palindrome substrings at once and initialize them to  zero as it doesn\\'t require any partition\\n    void findPalindrome(string& s){\\n        for(int i=0;i<s.length();i++){\\n            dp[i][i]=0;\\n            for(int j=i-1,k=i+1;j>=0&&k<s.length();j--,k++){\\n                if(s[j]==s[k])dp[j][k]=0;\\n                else break;\\n            }\\n            for(int j=i,k=i+1;j>=0&&k<s.length();j--,k++){\\n                if(s[j]==s[k])dp[j][k]=0;\\n                else break;\\n            }\\n        }\\n    }\\n    \\n    int partition(string& s,int i,int j){\\n        if(i>=j)return 0;\\n        if(dp[i][j]>-1)return dp[i][j];\\n        \\n        int minPart=j-i;\\n\\t\\t//check all possible partitions\\n        for(int k=i;k<j;k++){\\n\\t\\t\\t//partition only if left substring is valid palindrome to avoid repeated subproblems\\n            if(dp[i][k]==0 )minPart=min(minPart,partition(s,k+1,j)+1);\\n        }\\n        return dp[i][j]=minPart;\\n    }\\n    \\n    int minCut(string s) {\\n        int n=s.size();\\n\\t\\t//dynamic memory allocation\\n        dp=new int*[n+1];\\n        for(int i=0;i<=n;i++){\\n            dp[i]=new int[n+1];\\n            for(int j=0;j<=n;j++)dp[i][j]=-1;\\n        }\\n        findPalindrome(s);\\n        int ans= partition(s,0,n-1);\\n\\t\\t//free allocated memory\\n        for(int i=0;i<=n;i++)delete [] dp[i];\\n        delete [] dp;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int** dp;\\n    bool isPalindrome(string& s,int i, int j){\\n        int m=i,n=j;\\n        while(i<j){\\n            if(s[i++]!=s[j--])return false;\\n        }\\n        if(i>=j){\\n            i--;j++;\\n        }\\n        while(i>=m&&j<=n&&s[i]==s[j])dp[i--][j++]=0;\\n        return true;\\n    }\\n    \\n    int partition(string& s,int i,int j){\\n        if(i>j)return 0;\\n        if(dp[i][j]>-1)return dp[i][j];\\n        if(isPalindrome(s,i,j))return dp[i][j]=0;\\n        \\n        int minPart=j-i;\\n\\t\\t//check all possible partitions\\n        for(int k=i;k<j;k++){\\n            // minPart=min(minPart,partition(s,i,k)+partition(s,k+1,j)+1);// This statement(causes TLE) can be optimized as below by calling only relevant subproblems\\n\\t\\t\\t//partition only if left substring is valid palindrome to avoid repeated subproblems\\n            if(dp[i][k]==0 || isPalindrome(s,i,k)){\\n                minPart=min(minPart,partition(s,k+1,j)+1);\\n\\t\\t\\t}\\n        }\\n        return dp[i][j]=minPart;\\n    }\\n    \\n    int minCut(string s) {\\n        int n=s.size();\\n\\t\\t//dynamic memory allocation\\n        dp=new int*[n+1];\\n        for(int i=0;i<=n;i++){\\n            dp[i]=new int[n+1];\\n            for(int j=0;j<=n;j++)dp[i][j]=-1;\\n            dp[i][i]=0;\\n        }\\n        int ans= partition(s,0,n-1);\\n\\t\\t//free allocated memory\\n        for(int i=0;i<=n;i++)delete [] dp[i];\\n        delete [] dp;\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int** dp;\\n\\t//Fimd All the palindrome substrings at once and initialize them to  zero as it doesn\\'t require any partition\\n    void findPalindrome(string& s){\\n        for(int i=0;i<s.length();i++){\\n            dp[i][i]=0;\\n            for(int j=i-1,k=i+1;j>=0&&k<s.length();j--,k++){\\n                if(s[j]==s[k])dp[j][k]=0;\\n                else break;\\n            }\\n            for(int j=i,k=i+1;j>=0&&k<s.length();j--,k++){\\n                if(s[j]==s[k])dp[j][k]=0;\\n                else break;\\n            }\\n        }\\n    }\\n    \\n    int partition(string& s,int i,int j){\\n        if(i>=j)return 0;\\n        if(dp[i][j]>-1)return dp[i][j];\\n        \\n        int minPart=j-i;\\n\\t\\t//check all possible partitions\\n        for(int k=i;k<j;k++){\\n\\t\\t\\t//partition only if left substring is valid palindrome to avoid repeated subproblems\\n            if(dp[i][k]==0 )minPart=min(minPart,partition(s,k+1,j)+1);\\n        }\\n        return dp[i][j]=minPart;\\n    }\\n    \\n    int minCut(string s) {\\n        int n=s.size();\\n\\t\\t//dynamic memory allocation\\n        dp=new int*[n+1];\\n        for(int i=0;i<=n;i++){\\n            dp[i]=new int[n+1];\\n            for(int j=0;j<=n;j++)dp[i][j]=-1;\\n        }\\n        findPalindrome(s);\\n        int ans= partition(s,0,n-1);\\n\\t\\t//free allocated memory\\n        for(int i=0;i<=n;i++)delete [] dp[i];\\n        delete [] dp;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2152294,
                "title": "c-dp-aditya-verma-memoization-easy",
                "content": "class Solution {\\n \\n      int dp [2001][2001];\\n      private:\\n        bool ispalindrome(string &s,int i,int j){\\n           if(i>=j){\\n                return true;\\n            }\\n            while(i<=j){\\n                if(s[i]!=s[j]){\\n                    return false;\\n                }\\n                else{\\n                    i++;\\n                    j--;\\n                }\\n            }\\n            return true;\\n        }\\n        private:\\n        int solve(string &s,int i,int j){\\n            if(i>=j){\\n                return 0;\\n            }\\n            if(ispalindrome(s,i,j)){\\n                return dp[i][j] =0;\\n            }\\n            if(dp[i][j]!=-1){\\n                return dp[i][j];\\n            }\\n            int mn = INT_MAX;\\n            for(int k =i;k<j;k++){\\n                if(ispalindrome(s,i,k)){\\n                int temp =solve(s,i,k)+solve(s,k+1,j)+1;\\n                mn = min(temp,mn);\\n                }\\n            }\\n            return dp[i][j] =mn;\\n\\n        }\\n        public:\\n        int minCut(string s) {\\n            memset(dp,-1,sizeof(dp));\\n            return solve(s,0,s.size()-1);\\n\\n        }\\n    };\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\n \\n      int dp [2001][2001];\\n      private:\\n        bool ispalindrome(string &s,int i,int j){\\n           if(i>=j){\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2126920,
                "title": "clear-solution-with-step-by-step-approach",
                "content": "***In order to best understand the solution and the way to approach this problem, let\\'s go back to the baiscs and simply write the recursive solution to this problem. That way we will understand this better.***\\n\\n**Recursive Code:**\\n```\\nclass  Solution {\\n\\tpublic int minCut(String s){\\n\\t\\treturn solve(s, 0) - 1;\\n\\t}\\n\\tpublic int solve(String s, int i){\\n\\t\\tif(i == s.length())\\n\\t\\t\\treturn 0;\\n\\t\\tfor(int j = 0; j < s.length(); j++{\\n\\t\\t\\tif(isPalindrome(s, i, j)){\\n\\t\\t\\t\\tint cost = 1 + solve(s, j+1);\\n\\t\\t\\t\\tminCost = Math.min(minCost, cost);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn minCost;\\n\\t}\\n\\tpublic boolean isPalindrome(String s, int i, int j){\\n\\t\\twhile(i <= j){\\n\\t\\t\\tif(s.charAt(i) != s.charAt(j))\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\ti++;  j--;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n}\\n```\\n\\nAlthough this is a correct solution yet you will get a *TLE* because of the exponential T.C..\\n\\nNow let\\'s memoize this recursion code.\\n\\n**Memoized Solution (Bottom Up DP):**\\n\\n```\\n\\tclass Solution {\\n    int dp[];\\n    public int minCut(String s) {\\n        dp = new int[s.length()];\\n        Arrays.fill(dp, -1);\\n        return solve(s, 0) - 1;\\n    }\\n    \\n    public int solve(String s, int i){\\n        if(i == s.length())\\n            return 0;\\n        \\n        if(dp[i] != -1)\\n            return dp[i];\\n        \\n        int minCost = Integer.MAX_VALUE;\\n        for(int j = i; j < s.length(); j++){\\n            if(isPalindrome(s, i, j)){\\n                int cost = 1 + solve(s, j+1);\\n                minCost = Math.min(minCost, cost);\\n            }\\n        }\\n        return dp[i] = minCost;\\n    }\\n    \\n    public boolean isPalindrome(String s, int i, int j){\\n        while(i <= j){\\n            if(s.charAt(i) != s.charAt(j))\\n                return false;\\n            i++; j--;\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\nHere, there will be an auxillary stack space extra. Let\\'s optimise it further.\\n\\n**Tabulation DP:**\\n\\n```\\nclass Solution {\\n\\tpublic int minCut(String s){\\n\\t\\tint n = s.length();\\n\\t\\tint dp = new int[n+1];\\n\\t\\tArrays.fill(dp, 0);\\n\\t\\tfor(int i = n-1; i>= 0; i--{\\n\\t\\t\\tint minCost = Integer.MAX_VALUE;\\n\\t\\t\\tfor(int j = i; j < n; j++){\\n\\t\\t\\t\\tif(isPalindrome(s,i,j)){\\n\\t\\t\\t\\t\\tint cost = 1 + dp[j+1];\\n\\t\\t\\t\\t\\tminCost = Math.min(minCost, cost);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tdp[i] = minCost;\\n\\t\\t}\\n\\t\\treturn dp[0] - 1;\\n\\t}\\n\\tpublic boolean isPalindrome(String s, int i, int j){\\n        while(i <= j){\\n            if(s.charAt(i) != s.charAt(j))\\n                return false;\\n            i++; j--;\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\nPlease upvote if you like this. \\uD83D\\uDC4D",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass  Solution {\\n\\tpublic int minCut(String s){\\n\\t\\treturn solve(s, 0) - 1;\\n\\t}\\n\\tpublic int solve(String s, int i){\\n\\t\\tif(i == s.length())\\n\\t\\t\\treturn 0;\\n\\t\\tfor(int j = 0; j < s.length(); j++{\\n\\t\\t\\tif(isPalindrome(s, i, j)){\\n\\t\\t\\t\\tint cost = 1 + solve(s, j+1);\\n\\t\\t\\t\\tminCost = Math.min(minCost, cost);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn minCost;\\n\\t}\\n\\tpublic boolean isPalindrome(String s, int i, int j){\\n\\t\\twhile(i <= j){\\n\\t\\t\\tif(s.charAt(i) != s.charAt(j))\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\ti++;  j--;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n}\\n```\n```\\n\\tclass Solution {\\n    int dp[];\\n    public int minCut(String s) {\\n        dp = new int[s.length()];\\n        Arrays.fill(dp, -1);\\n        return solve(s, 0) - 1;\\n    }\\n    \\n    public int solve(String s, int i){\\n        if(i == s.length())\\n            return 0;\\n        \\n        if(dp[i] != -1)\\n            return dp[i];\\n        \\n        int minCost = Integer.MAX_VALUE;\\n        for(int j = i; j < s.length(); j++){\\n            if(isPalindrome(s, i, j)){\\n                int cost = 1 + solve(s, j+1);\\n                minCost = Math.min(minCost, cost);\\n            }\\n        }\\n        return dp[i] = minCost;\\n    }\\n    \\n    public boolean isPalindrome(String s, int i, int j){\\n        while(i <= j){\\n            if(s.charAt(i) != s.charAt(j))\\n                return false;\\n            i++; j--;\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n\\tpublic int minCut(String s){\\n\\t\\tint n = s.length();\\n\\t\\tint dp = new int[n+1];\\n\\t\\tArrays.fill(dp, 0);\\n\\t\\tfor(int i = n-1; i>= 0; i--{\\n\\t\\t\\tint minCost = Integer.MAX_VALUE;\\n\\t\\t\\tfor(int j = i; j < n; j++){\\n\\t\\t\\t\\tif(isPalindrome(s,i,j)){\\n\\t\\t\\t\\t\\tint cost = 1 + dp[j+1];\\n\\t\\t\\t\\t\\tminCost = Math.min(minCost, cost);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tdp[i] = minCost;\\n\\t\\t}\\n\\t\\treturn dp[0] - 1;\\n\\t}\\n\\tpublic boolean isPalindrome(String s, int i, int j){\\n        while(i <= j){\\n            if(s.charAt(i) != s.charAt(j))\\n                return false;\\n            i++; j--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2075792,
                "title": "c-clean-code-all-approaches",
                "content": "```\\n// Recursive:\\nclass Solution {\\npublic:\\n    bool isPalindrome(int i, int j, string s){\\n        while(i<j){\\n            if(s[i++]!=s[j--]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int solve(int i, int j, string s){\\n        if(i==j)\\n            return 0;\\n        \\n        int mini = INT_MAX;\\n        for(int k = i; k < j; k++){\\n            if(isPalindrome(i, k, s)){\\n                int cost = 1 + solve(k+1, j, s);\\n                mini = min(mini, cost);\\n            }\\n                \\n        }\\n        \\n        return mini;\\n    }\\n    \\n    int minCut(string s) {\\n        int n = s.length();\\n        return solve(0, n, s)-1;\\n    }\\n};\\n\\n\\n//Memoization\\nclass Solution {\\npublic:\\n    bool isPalindrome(int i, int j, string& s){\\n        while(i<=j){\\n            if(s[i++]!=s[j--]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int solve(int i, int j, string& s, vector<int>& memo){\\n        if(i==j)\\n            return 0;\\n        if(memo[i]!= -1)\\n            return memo[i];\\n        int mini = INT_MAX;\\n        for(int k = i; k < j; k++){\\n            if(isPalindrome(i, k, s)){\\n                int cost = 1 + solve(k+1, j, s, memo);\\n                mini = min(mini, cost);\\n            }\\n                \\n        }\\n        \\n        return memo[i] = mini;\\n    }\\n    \\n    int minCut(string s) {\\n        int n = s.length();\\n        vector<int> memo(n, -1);\\n        return solve(0, n, s, memo)-1;\\n    }\\n};\\n\\n\\n//Tabulation\\nclass Solution {\\npublic:\\n    bool isPalindrome(int i, int j, string& s){\\n        while(i<=j){\\n            if(s[i++]!=s[j--]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int minCut(string s) {\\n        int n = s.length();\\n        vector<int> dp(n+1, 0);\\n        dp[n] = 0;\\n        for(int i=n-1; i>=0; i--){\\n            int mini = INT_MAX;\\n            for(int k = i; k < n; k++){\\n                if(isPalindrome(i, k, s)){\\n                    int cost = 1 + dp[k+1];\\n                    mini = min(mini, cost);\\n                }\\n\\n            }\\n            dp[i] = mini;\\n        }\\n        \\n        return dp[0] - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n// Recursive:\\nclass Solution {\\npublic:\\n    bool isPalindrome(int i, int j, string s){\\n        while(i<j){\\n            if(s[i++]!=s[j--]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int solve(int i, int j, string s){\\n        if(i==j)\\n            return 0;\\n        \\n        int mini = INT_MAX;\\n        for(int k = i; k < j; k++){\\n            if(isPalindrome(i, k, s)){\\n                int cost = 1 + solve(k+1, j, s);\\n                mini = min(mini, cost);\\n            }\\n                \\n        }\\n        \\n        return mini;\\n    }\\n    \\n    int minCut(string s) {\\n        int n = s.length();\\n        return solve(0, n, s)-1;\\n    }\\n};\\n\\n\\n//Memoization\\nclass Solution {\\npublic:\\n    bool isPalindrome(int i, int j, string& s){\\n        while(i<=j){\\n            if(s[i++]!=s[j--]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int solve(int i, int j, string& s, vector<int>& memo){\\n        if(i==j)\\n            return 0;\\n        if(memo[i]!= -1)\\n            return memo[i];\\n        int mini = INT_MAX;\\n        for(int k = i; k < j; k++){\\n            if(isPalindrome(i, k, s)){\\n                int cost = 1 + solve(k+1, j, s, memo);\\n                mini = min(mini, cost);\\n            }\\n                \\n        }\\n        \\n        return memo[i] = mini;\\n    }\\n    \\n    int minCut(string s) {\\n        int n = s.length();\\n        vector<int> memo(n, -1);\\n        return solve(0, n, s, memo)-1;\\n    }\\n};\\n\\n\\n//Tabulation\\nclass Solution {\\npublic:\\n    bool isPalindrome(int i, int j, string& s){\\n        while(i<=j){\\n            if(s[i++]!=s[j--]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int minCut(string s) {\\n        int n = s.length();\\n        vector<int> dp(n+1, 0);\\n        dp[n] = 0;\\n        for(int i=n-1; i>=0; i--){\\n            int mini = INT_MAX;\\n            for(int k = i; k < n; k++){\\n                if(isPalindrome(i, k, s)){\\n                    int cost = 1 + dp[k+1];\\n                    mini = min(mini, cost);\\n                }\\n\\n            }\\n            dp[i] = mini;\\n        }\\n        \\n        return dp[0] - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1916792,
                "title": "c-o-n-2-time-o-n-space",
                "content": "```\\n//Credits to @tqlong\\n\\nclass Solution {\\npublic:\\n    int minCut(string s) {\\n        int n = s.length();\\n        vector<int> dp(n+1,n-1);\\n        dp[0] = -1;\\n        for(int i=0;i<n;i++)\\n        {\\n            //odd length\\n            int l = i , r = i;\\n            while(l>=0 and r<n and s[l] == s[r])\\n            {\\n                dp[r+1] = min(dp[r+1],1+dp[l]);\\n                l--;\\n                r++;\\n            }\\n            //even length\\n            l = i , r = i+1;\\n            while(l>=0 and r<n and s[l] == s[r])\\n            {\\n                dp[r+1] = min(dp[r+1],1+dp[l]);\\n                l--;\\n                r++;\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n/*   for string 0-1-2--------8 if (2-8) is palindrome then the no of partitions will equal no of\\n     cuts in string(0-1) + 1(cut) + 0(as 2-8 is palindrome)*/\\n\\n//O(n^2) time and O(n) space\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n//Credits to @tqlong\\n\\nclass Solution {\\npublic:\\n    int minCut(string s) {\\n        int n = s.length();\\n        vector<int> dp(n+1,n-1);\\n        dp[0] = -1;\\n        for(int i=0;i<n;i++)\\n        {\\n            //odd length\\n            int l = i , r = i;\\n            while(l>=0 and r<n and s[l] == s[r])\\n            {\\n                dp[r+1] = min(dp[r+1],1+dp[l]);\\n                l--;\\n                r++;\\n            }\\n            //even length\\n            l = i , r = i+1;\\n            while(l>=0 and r<n and s[l] == s[r])\\n            {\\n                dp[r+1] = min(dp[r+1],1+dp[l]);\\n                l--;\\n                r++;\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n/*   for string 0-1-2--------8 if (2-8) is palindrome then the no of partitions will equal no of\\n     cuts in string(0-1) + 1(cut) + 0(as 2-8 is palindrome)*/\\n\\n//O(n^2) time and O(n) space\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1807722,
                "title": "c-dp-simple",
                "content": "class Solution {\\npublic:\\n     int dp[2005][2005];\\n    int dp1[2005][2005];\\n   \\n\\tbool isPalindrome(string& s, int i, int j) {\\n\\t\\tif (i >= j)\\n            return true;\\n\\t\\tif (dp1[i][j] != -1) \\n            return dp1[i][j];\\n\\t\\tif (s[i] == s[j]) \\n            return dp1[i][j] = isPalindrome(s, i + 1, j - 1);\\n\\t\\treturn dp1[i][j] = false;\\n\\t}\\n\\n\\tint solve(string s, int i, int j){\\n\\t\\tif(i>=j) \\n          return 0;\\n\\t\\tif(dp[i][j]!=-1)\\n            return dp[i][j];\\n\\t\\tif(isPalindrome(s,i,j)) \\n            return 0;\\n\\t\\tint mn = INT_MAX;\\n\\t\\tfor(int k=i;k<=j-1;k++){\\n\\t\\t\\tif(isPalindrome(s,i,k)) \\n                mn = min(mn, 1+solve(s,k+1,j));\\n            dp[i][j] = mn;\\n\\t\\t}\\n        \\n\\t\\treturn dp[i][j];\\n\\t}\\n\\n    int minCut(string s) {\\n        int l=s.length();\\n        memset(dp,-1,sizeof(dp));\\n        memset(dp1,-1,sizeof(dp1));\\n       int ans=solve(s,0,l-1);\\n        return ans;\\n        \\n    }\\n};\\n\\n**Please upvote if you find this solution helpful.**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n     int dp[2005][2005];\\n    int dp1[2005][2005];\\n   \\n\\tbool isPalindrome(string& s, int i, int j) {\\n\\t\\tif (i >= j)\\n            return true;\\n\\t\\tif (dp1[i][j] != -1) \\n            return dp1[i][j];\\n\\t\\tif (s[i] == s[j]) \\n            return dp1[i][j] = isPalindrome(s, i + 1, j - 1);\\n\\t\\treturn dp1[i][j] = false;\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1765230,
                "title": "simple-java-solution-enhancement-of-mcm",
                "content": "since traditional mcm approach is giving tle we need to optimize it. so for that we can observe is that for two calls i,k and k+1,j . we can check if i,k partition is palindrome then only call k+1,j. why? bcoz we want palindrome parititon in answer so if first half is not palindrome. don\\'t call right half.\\n\\nrest code is quite similar to Matrix chain multiplication\\n```\\npublic int topDown(String s) {\\n\\t\\treturn topDown(s, 0, s.length() - 1, new Integer[s.length() + 1][s.length() + 1]);\\n\\t}\\n\\n\\tprivate int topDown(String s, int i, int j, Integer[][] memo) {\\n\\t\\tif (i > j) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tif (memo[i][j] != null) {\\n\\t\\t\\treturn memo[i][j];\\n\\t\\t}\\n\\t\\tif (isPalindrome(s, i, j)) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\tfor (int k = i; k < j; k++) {\\n\\t\\t\\tif (isPalindrome(s, i, k)) {\\n\\t\\t\\t\\tint ans2 = 1 + topDown(s, k + 1, j, memo);\\n\\t\\t\\t\\tmin = Math.min(min, ans2);\\n\\t\\t\\t\\tmemo[i][j] = min;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn min;\\n\\t}\\n\\n\\tprivate boolean isPalindrome(String s, int i, int j) {\\n\\t\\twhile (i < j) {\\n\\t\\t\\tif (s.charAt(i) != s.charAt(j)) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\ti++;\\n\\t\\t\\tj--;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\npublic int topDown(String s) {\\n\\t\\treturn topDown(s, 0, s.length() - 1, new Integer[s.length() + 1][s.length() + 1]);\\n\\t}\\n\\n\\tprivate int topDown(String s, int i, int j, Integer[][] memo) {\\n\\t\\tif (i > j) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tif (memo[i][j] != null) {\\n\\t\\t\\treturn memo[i][j];\\n\\t\\t}\\n\\t\\tif (isPalindrome(s, i, j)) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\tfor (int k = i; k < j; k++) {\\n\\t\\t\\tif (isPalindrome(s, i, k)) {\\n\\t\\t\\t\\tint ans2 = 1 + topDown(s, k + 1, j, memo);\\n\\t\\t\\t\\tmin = Math.min(min, ans2);\\n\\t\\t\\t\\tmemo[i][j] = min;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn min;\\n\\t}\\n\\n\\tprivate boolean isPalindrome(String s, int i, int j) {\\n\\t\\twhile (i < j) {\\n\\t\\t\\tif (s.charAt(i) != s.charAt(j)) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\ti++;\\n\\t\\t\\tj--;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1731612,
                "title": "c-memoization-with-space-and-time-complexity",
                "content": "```\\n// TIME COMPLEXITY AND SPACE COMPLEXITY : O(n*n) and O(n*n)\\nclass Solution {\\npublic:\\n    //pass the address ,instead of copy of parameter to avoid TLE; \\n    //Function to check if the string is Palindrome\\n     bool isPalindrome( string &s, int start, int end)\\n     {\\n          int i= start;\\n          int j= end;\\n         while(i<=j   )\\n         {\\n             if( s[i]!=s[j])\\n                 return false;\\n             i++;\\n             j--;\\n         }\\n         \\n         return true;\\n     }\\n    \\n    int solve(  string &s, int i, int j, vector< vector< int >  >&dp)\\n    {\\n\\n          if(  i>=j)\\n              return 0;\\n        \\n          /*If the current string is palindrome then we dont need to break it into \\n\\tfurther sub problems as we want to minimize the cuts.*/\\n        if( isPalindrome(s,i,j))\\n            return 0;\\n    \\n        if( dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        \\n        int ans=INT_MAX;\\n        //Trying Different possible cuts between i and j\\n        for( int k=i;k<=j;k++)\\n        {\\n            \\n           /*An Optimization: We will make the partition only if the string till the partition \\n\\t\\t(till Kth position) is a valid palindrome. Because the question states that all \\n\\t\\tpartition must be a valid palindrome. If we dont check this, we will have to \\n\\t\\tperform recursion on the left subproblem too (solve(str, i, k)) and\\twe will waste \\n\\t\\ta lot of time on subproblems that is not required. Without this the code will give\\n\\t\\tcorrect answer but TLE on big test cases. */ \\n            \\n            if(isPalindrome(s,i,k))\\n                ans= min( ans, 1+ solve(s,k+1,j,dp));\\n            \\n        \\n     \\n        }\\n        \\n      return   dp[i][j] = ans;   \\n        \\n    }\\n    \\n    \\n    int minCut(string s) {\\n        \\n      vector< vector< int > >dp( s.size()+1, vector< int > ( s.size()+1,-1));\\n        \\n      return solve( s,0,s.size()-1, dp);\\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n// TIME COMPLEXITY AND SPACE COMPLEXITY : O(n*n) and O(n*n)\\nclass Solution {\\npublic:\\n    //pass the address ,instead of copy of parameter to avoid TLE; \\n    //Function to check if the string is Palindrome\\n     bool isPalindrome( string &s, int start, int end)\\n     {\\n          int i= start;\\n          int j= end;\\n         while(i<=j   )\\n         {\\n             if( s[i]!=s[j])\\n                 return false;\\n             i++;\\n             j--;\\n         }\\n         \\n         return true;\\n     }\\n    \\n    int solve(  string &s, int i, int j, vector< vector< int >  >&dp)\\n    {\\n\\n          if(  i>=j)\\n              return 0;\\n        \\n          /*If the current string is palindrome then we dont need to break it into \\n\\tfurther sub problems as we want to minimize the cuts.*/\\n        if( isPalindrome(s,i,j))\\n            return 0;\\n    \\n        if( dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        \\n        int ans=INT_MAX;\\n        //Trying Different possible cuts between i and j\\n        for( int k=i;k<=j;k++)\\n        {\\n            \\n           /*An Optimization: We will make the partition only if the string till the partition \\n\\t\\t(till Kth position) is a valid palindrome. Because the question states that all \\n\\t\\tpartition must be a valid palindrome. If we dont check this, we will have to \\n\\t\\tperform recursion on the left subproblem too (solve(str, i, k)) and\\twe will waste \\n\\t\\ta lot of time on subproblems that is not required. Without this the code will give\\n\\t\\tcorrect answer but TLE on big test cases. */ \\n            \\n            if(isPalindrome(s,i,k))\\n                ans= min( ans, 1+ solve(s,k+1,j,dp));\\n            \\n        \\n     \\n        }\\n        \\n      return   dp[i][j] = ans;   \\n        \\n    }\\n    \\n    \\n    int minCut(string s) {\\n        \\n      vector< vector< int > >dp( s.size()+1, vector< int > ( s.size()+1,-1));\\n        \\n      return solve( s,0,s.size()-1, dp);\\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712917,
                "title": "java-dp-memoization-matrix-chain-multiplication",
                "content": "```\\nclass Solution {\\n    int dp[][]=new int[2001][2001];\\n    public int minCut(String s) {\\n        int n=s.length();\\n        for(int row[]: dp)\\n            Arrays.fill(row, -1);\\n        return solve(s, 0, n-1);\\n    }\\n    public boolean isPalindrome(String s, int i, int j)\\n    {\\n        if(i>=j)\\n            return true;\\n        while(i<j)\\n        {\\n            if(s.charAt(i)!=s.charAt(j))\\n                return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    public int solve(String s, int i, int j)\\n    {\\n       \\n        if(i>=j) return 0;\\n        \\n        if(isPalindrome(s,i,j)==true)\\n            return 0;\\n        \\n        int mn= Integer.MAX_VALUE;\\n        \\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        for(int k = i; k < j; k++)\\n        {\\n    // if substring of str in range [i, k] is a palindrome, then check the range[k+1, j]\\n           if(isPalindrome(s, i , k))\\n           {\\n   // cutting the string from i to k will take 1 cut and from k+1 to j will be returned by the function.\\n               int temp_ans = 1 + solve(s, k+1, j);\\n               mn = Math.min(mn, temp_ans);\\n            }\\n         }\\n        //Because we can check directly that if the first partition is Palindrome we can check for the rest k+1 to j partition but if the first i to k partition is not Palindrome. You need not check the next k+1 to j.\\n        return dp[i][j]=mn;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    int dp[][]=new int[2001][2001];\\n    public int minCut(String s) {\\n        int n=s.length();\\n        for(int row[]: dp)\\n            Arrays.fill(row, -1);\\n        return solve(s, 0, n-1);\\n    }\\n    public boolean isPalindrome(String s, int i, int j)\\n    {\\n        if(i>=j)\\n            return true;\\n        while(i<j)\\n        {\\n            if(s.charAt(i)!=s.charAt(j))\\n                return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    public int solve(String s, int i, int j)\\n    {\\n       \\n        if(i>=j) return 0;\\n        \\n        if(isPalindrome(s,i,j)==true)\\n            return 0;\\n        \\n        int mn= Integer.MAX_VALUE;\\n        \\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        for(int k = i; k < j; k++)\\n        {\\n    // if substring of str in range [i, k] is a palindrome, then check the range[k+1, j]\\n           if(isPalindrome(s, i , k))\\n           {\\n   // cutting the string from i to k will take 1 cut and from k+1 to j will be returned by the function.\\n               int temp_ans = 1 + solve(s, k+1, j);\\n               mn = Math.min(mn, temp_ans);\\n            }\\n         }\\n        //Because we can check directly that if the first partition is Palindrome we can check for the rest k+1 to j partition but if the first i to k partition is not Palindrome. You need not check the next k+1 to j.\\n        return dp[i][j]=mn;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1667691,
                "title": "3-approaches-naive-to-efficient-o-n-3-to-o-n-2-c",
                "content": "Implementation\\n\\n**1st\\nUsing Gap & Cut Strategy\\nWill give TLE\\nNaive Approach\\nTime Complexity = O(N^3), Space Complexity = O(N^2)**\\n```\\nclass Solution {\\npublic:\\n    int minCut(string str) {\\n        int n = str.size();\\n        vector<vector<bool>> dp(n, vector<bool>(n, false));\\n                \\n        for(int gap = 0; gap < n; gap++){\\n            for(int itr = 0, jtr = gap; jtr < n; itr++, jtr++){\\n                if(gap == 0) dp[itr][jtr] = true;\\n                else if(gap == 1) dp[itr][jtr] = str[itr] == str[jtr];\\n                else{\\n                    if(str[itr] == str[jtr] && dp[itr+1][jtr-1]) dp[itr][jtr] = true;\\n                    else dp[itr][jtr] = false;\\n                }\\n            }\\n        }\\n        \\n        vector<vector<int>> res(n, vector<int>(n, 0));\\n        for(int gap = 0; gap < n; gap++){\\n            for(int itr = 0, jtr = gap; jtr < n; itr++, jtr++){                \\n                if(gap == 0) res[itr][jtr] = 0;\\n                else if(gap == 1) res[itr][jtr] = (dp[itr][jtr]) ? 0 : 1;\\n                else{\\n                    if(dp[itr][jtr]){\\n                        res[itr][jtr] = 0;\\n                    }\\n                    else{\\n                        int minValue = INT_MAX;                    \\n                        for(int ktr = itr; ktr < jtr; ktr++){\\n                            int left = res[itr][ktr];\\n                            int right = res[ktr+1][jtr];\\n\\n                            minValue = min(minValue, left+right+1);\\n                        }\\n\\n                        res[itr][jtr] = minValue;\\n                    }                    \\n                }\\n            }\\n        }\\n        \\n        // returning the last index of the first row\\n        return res[0][n-1];\\n    }\\n};\\n```\\n\\n\\n**2nd\\nUsing Gap & Cut Strategy\\nEfficient Approach\\nTime Complexity = O(N^2), Space Complexity = O(N^2)**\\n```\\nclass Solution {\\npublic:\\n    int minCut(string str) {\\n        int n = str.size();\\n        vector<vector<bool>> dp(n, vector<bool>(n, false));\\n                \\n        for(int gap = 0; gap < n; gap++){\\n            for(int itr = 0, jtr = gap; jtr < n; itr++, jtr++){\\n                if(gap == 0) dp[itr][jtr] = true;\\n                else if(gap == 1) dp[itr][jtr] = str[itr] == str[jtr];\\n                else{\\n                    if(str[itr] == str[jtr] && dp[itr+1][jtr-1]) dp[itr][jtr] = true;\\n                    else dp[itr][jtr] = false;\\n                }\\n            }\\n        }\\n        \\n        // using suffix technique\\n        vector<int> res(n);\\n        res[0] = 0;     // first char will always be pallindrome\\n        \\n        for(int itr = 1; itr < n; itr++){\\n            if(dp[0][itr]) res[itr] = 0;\\n            else{\\n                int minCut = INT_MAX;\\n                \\n                for(int jtr = itr; jtr >= 1; jtr--){                    \\n                    // if its pallindrome then only, we can find how many cut we can make\\n                    if(dp[jtr][itr]){\\n                        minCut = min(minCut, res[jtr-1]);\\n                    }\\n                }\\n                res[itr] = minCut + 1;  // +1 bcz we are making cut on current char as well\\n            }\\n        }\\n        \\n        // returning the last index of the res\\n        return res[n-1];\\n    }\\n};\\n```\\n\\n\\n**3rd\\nUsing Gap & Cut Strategy\\nMost Efficient Approach\\nTime Complexity = O(N^2), Space Complexity = O(N^2)**\\n```\\nclass Solution {\\npublic:\\n    int minCut(string str) {\\n        int n = str.size();\\n        \\n        // for gap strategy\\n        vector<vector<bool>> dp(n, vector<bool>(n, false));\\n        vector<int> res(n);\\n        \\n        // using prefix technique\\n        for(int itr = 0; itr < n; itr++){\\n            int minValue = itr;\\n            \\n            for(int jtr = 0; jtr <= itr; jtr++){\\n                \\n                if(str[itr] == str[jtr] && (itr-jtr<3 || dp[jtr+1][itr-1])){\\n                    dp[jtr][itr] = true; \\n                    minValue = (jtr == 0) ? 0 : min(minValue, res[jtr-1]+1);\\n                }\\n            }\\n            \\n            res[itr] = minValue;\\n        }\\n        \\n        // returning the last index of the res\\n        return res[n-1];\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCut(string str) {\\n        int n = str.size();\\n        vector<vector<bool>> dp(n, vector<bool>(n, false));\\n                \\n        for(int gap = 0; gap < n; gap++){\\n            for(int itr = 0, jtr = gap; jtr < n; itr++, jtr++){\\n                if(gap == 0) dp[itr][jtr] = true;\\n                else if(gap == 1) dp[itr][jtr] = str[itr] == str[jtr];\\n                else{\\n                    if(str[itr] == str[jtr] && dp[itr+1][jtr-1]) dp[itr][jtr] = true;\\n                    else dp[itr][jtr] = false;\\n                }\\n            }\\n        }\\n        \\n        vector<vector<int>> res(n, vector<int>(n, 0));\\n        for(int gap = 0; gap < n; gap++){\\n            for(int itr = 0, jtr = gap; jtr < n; itr++, jtr++){                \\n                if(gap == 0) res[itr][jtr] = 0;\\n                else if(gap == 1) res[itr][jtr] = (dp[itr][jtr]) ? 0 : 1;\\n                else{\\n                    if(dp[itr][jtr]){\\n                        res[itr][jtr] = 0;\\n                    }\\n                    else{\\n                        int minValue = INT_MAX;                    \\n                        for(int ktr = itr; ktr < jtr; ktr++){\\n                            int left = res[itr][ktr];\\n                            int right = res[ktr+1][jtr];\\n\\n                            minValue = min(minValue, left+right+1);\\n                        }\\n\\n                        res[itr][jtr] = minValue;\\n                    }                    \\n                }\\n            }\\n        }\\n        \\n        // returning the last index of the first row\\n        return res[0][n-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minCut(string str) {\\n        int n = str.size();\\n        vector<vector<bool>> dp(n, vector<bool>(n, false));\\n                \\n        for(int gap = 0; gap < n; gap++){\\n            for(int itr = 0, jtr = gap; jtr < n; itr++, jtr++){\\n                if(gap == 0) dp[itr][jtr] = true;\\n                else if(gap == 1) dp[itr][jtr] = str[itr] == str[jtr];\\n                else{\\n                    if(str[itr] == str[jtr] && dp[itr+1][jtr-1]) dp[itr][jtr] = true;\\n                    else dp[itr][jtr] = false;\\n                }\\n            }\\n        }\\n        \\n        // using suffix technique\\n        vector<int> res(n);\\n        res[0] = 0;     // first char will always be pallindrome\\n        \\n        for(int itr = 1; itr < n; itr++){\\n            if(dp[0][itr]) res[itr] = 0;\\n            else{\\n                int minCut = INT_MAX;\\n                \\n                for(int jtr = itr; jtr >= 1; jtr--){                    \\n                    // if its pallindrome then only, we can find how many cut we can make\\n                    if(dp[jtr][itr]){\\n                        minCut = min(minCut, res[jtr-1]);\\n                    }\\n                }\\n                res[itr] = minCut + 1;  // +1 bcz we are making cut on current char as well\\n            }\\n        }\\n        \\n        // returning the last index of the res\\n        return res[n-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minCut(string str) {\\n        int n = str.size();\\n        \\n        // for gap strategy\\n        vector<vector<bool>> dp(n, vector<bool>(n, false));\\n        vector<int> res(n);\\n        \\n        // using prefix technique\\n        for(int itr = 0; itr < n; itr++){\\n            int minValue = itr;\\n            \\n            for(int jtr = 0; jtr <= itr; jtr++){\\n                \\n                if(str[itr] == str[jtr] && (itr-jtr<3 || dp[jtr+1][itr-1])){\\n                    dp[jtr][itr] = true; \\n                    minValue = (jtr == 0) ? 0 : min(minValue, res[jtr-1]+1);\\n                }\\n            }\\n            \\n            res[itr] = minValue;\\n        }\\n        \\n        // returning the last index of the res\\n        return res[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1665041,
                "title": "java-dp-explained-dp-in-detail",
                "content": "// The idea is to maintain a dp[] (minCutUptoI[]) where minCutUptoI[i] means that min cut needed for a palindrome partitioning of s.substring(0 , i +1).\\n// Basically, how many minimum cuts needed in substring(0 , i) so that every cut makes the strings palindorme within (0 , i + 1)\\n// If in a string, no substring can make a palindorme (apart from single chars which are also palindrome) then for base case we would require \\'i\\' cuts in substring(0, i) (for those individuals chars)\\n\\n// Then, maintain a for loop which will do foloowing\\n// EVERY index of the string would act as the MIDDLE index and we would expand in both directions from this middle index (START would go to left & END would go to right) and will try to find the palindromes that are forming and updates the DP[]\\n\\n// TC : O(N^2)\\n// SC : O(N)\\n\\n```\\nclass Solution {\\n    public int minCut(String s) {\\n        if(s == null || s.length() == 0) return 0;\\n        \\n        int[] minCutUptoI = new int[s.length()]; // minCutUptoI[i] means the minumum cuts needed for a palindrome partitioning of s.substring(0, i+1).\\n        \\n        for(int i = 0; i < s.length(); i++) {\\n            minCutUptoI[i] = i; // base case -> the maximum cut needed to cut the s.substring(0, i + 1) is i -> in case of no palindromes in substring (remember single char is also a palindrome )\\n        }\\n        \\n        for(int mid = 0; mid < s.length(); mid++) { // iterate through all chars as mid point of palindrome\\n            \\n            // CASE 1. odd len: center is at index mid, expand on both sides\\n            for(int start = mid, end = mid; start >= 0 && end < s.length() && s.charAt(start) == s.charAt(end); start--, end++) {\\n                int minCutUptoEnd = (start == 0) ? 0 : minCutUptoI[start - 1] + 1; // if start has reached 0, means that s.substring(0, end + 1) is palindrome and so NO cut is required (that is why 0) otherwise CUTS require upto substring(0, start) and + 1 because of the substring between start and end needed that 1 cut\\n                minCutUptoI[end] = Math.min(minCutUptoEnd, minCutUptoI[end]);\\n            }\\n            \\n            // CASE 2: even len: center is between [mid-1,mid], expand on both sides\\n            for(int start = mid - 1, end = mid; start >= 0 && end < s.length() && s.charAt(start) == s.charAt(end); start--, end++) {\\n                int minCutUptoEnd = (start == 0) ? 0 : minCutUptoI[start - 1] + 1;\\n                minCutUptoI[end] = Math.min(minCutUptoEnd, minCutUptoI[end]);\\n            }\\n        }\\n        \\n        return minCutUptoI[s.length() - 1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minCut(String s) {\\n        if(s == null || s.length() == 0) return 0;\\n        \\n        int[] minCutUptoI = new int[s.length()]; // minCutUptoI[i] means the minumum cuts needed for a palindrome partitioning of s.substring(0, i+1).\\n        \\n        for(int i = 0; i < s.length(); i++) {\\n            minCutUptoI[i] = i; // base case -> the maximum cut needed to cut the s.substring(0, i + 1) is i -> in case of no palindromes in substring (remember single char is also a palindrome )\\n        }\\n        \\n        for(int mid = 0; mid < s.length(); mid++) { // iterate through all chars as mid point of palindrome\\n            \\n            // CASE 1. odd len: center is at index mid, expand on both sides\\n            for(int start = mid, end = mid; start >= 0 && end < s.length() && s.charAt(start) == s.charAt(end); start--, end++) {\\n                int minCutUptoEnd = (start == 0) ? 0 : minCutUptoI[start - 1] + 1; // if start has reached 0, means that s.substring(0, end + 1) is palindrome and so NO cut is required (that is why 0) otherwise CUTS require upto substring(0, start) and + 1 because of the substring between start and end needed that 1 cut\\n                minCutUptoI[end] = Math.min(minCutUptoEnd, minCutUptoI[end]);\\n            }\\n            \\n            // CASE 2: even len: center is between [mid-1,mid], expand on both sides\\n            for(int start = mid - 1, end = mid; start >= 0 && end < s.length() && s.charAt(start) == s.charAt(end); start--, end++) {\\n                int minCutUptoEnd = (start == 0) ? 0 : minCutUptoI[start - 1] + 1;\\n                minCutUptoI[end] = Math.min(minCutUptoEnd, minCutUptoI[end]);\\n            }\\n        }\\n        \\n        return minCutUptoI[s.length() - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1587659,
                "title": "bottom-up-dp",
                "content": "If you go with traditional DP, i.e. check substring by substring the it will take O(n^3) to fill up the dp table , we can always check with centres and go outwards for palindromes! we first check with odd length palindromes then even length palindromes\\n```\\nclass Solution {\\npublic:\\n    int minCut(string s) {\\n        // dp problem \\n        int n = s.length();\\n        int dp[2001];\\n        for(int i=0;i<2001;i++)dp[i]=(1e9);\\n        dp[0]=-1;\\n        \\n        for(int i=1;i<=n;i++){\\n          // 0 1 2 ... i-1....n-1 here i-1 is the center of the string palindrome\\n            int max_len = min(n-i+1,i);\\n            int l = i-1,r=i-1;\\n\\t\\t\\t// to check the current substring is palindrome or not\\n            int pal=-1;\\n            while(l>=0 && r < n){\\n                if(s[l]==s[r]){\\n\\t\\t\\t\\t// only set if it is the single element\\n                    if(pal==-1)pal=1;\\n                }\\n                else{\\n\\t\\t\\t\\t// even one mismatch will cause all the expanded substrings to not be palindromes\\n                    pal=0;\\n                }\\n                if(pal){\\n\\t\\t\\t\\t// if it is palindrome check with left to substring\\n                    dp[r+1]=min(dp[r+1],dp[l]+1);\\n                }\\n                l--;r++;\\n            }\\n            // even palindrome\\n            l=i-1;\\n            r=l+1;\\n            pal=-1;\\n            while(l>=0 && r < n){\\n                if(s[l]==s[r]){\\n                    if(pal==-1)pal=1;\\n                }\\n                else{\\n                    pal=0;\\n                }\\n                if(pal){\\n                    dp[r+1]=min(dp[r+1],dp[l]+1);\\n                }\\n                l--;r++;\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCut(string s) {\\n        // dp problem \\n        int n = s.length();\\n        int dp[2001];\\n        for(int i=0;i<2001;i++)dp[i]=(1e9);\\n        dp[0]=-1;\\n        \\n        for(int i=1;i<=n;i++){\\n          // 0 1 2 ... i-1....n-1 here i-1 is the center of the string palindrome\\n            int max_len = min(n-i+1,i);\\n            int l = i-1,r=i-1;\\n\\t\\t\\t// to check the current substring is palindrome or not\\n            int pal=-1;\\n            while(l>=0 && r < n){\\n                if(s[l]==s[r]){\\n\\t\\t\\t\\t// only set if it is the single element\\n                    if(pal==-1)pal=1;\\n                }\\n                else{\\n\\t\\t\\t\\t// even one mismatch will cause all the expanded substrings to not be palindromes\\n                    pal=0;\\n                }\\n                if(pal){\\n\\t\\t\\t\\t// if it is palindrome check with left to substring\\n                    dp[r+1]=min(dp[r+1],dp[l]+1);\\n                }\\n                l--;r++;\\n            }\\n            // even palindrome\\n            l=i-1;\\n            r=l+1;\\n            pal=-1;\\n            while(l>=0 && r < n){\\n                if(s[l]==s[r]){\\n                    if(pal==-1)pal=1;\\n                }\\n                else{\\n                    pal=0;\\n                }\\n                if(pal){\\n                    dp[r+1]=min(dp[r+1],dp[l]+1);\\n                }\\n                l--;r++;\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1393999,
                "title": "python3-dp-with-explanations",
                "content": "Let\\'s assume you already know the minimum cut ```n``` required for a substring at the end of given string:\\n```XY...Z```. Now you find a palindrome string ```acbca``` in front of the substring like this: ```acbcaXY...Z```, so the minimum cut of this string will be ```n+1```. So the solution will be search from the end of the given string, for each character ```b```, find all the palindrome strings that centered by ```b```, update the minimum cut of the first character ```a``` with the minimum cut of ```X``` plus 1.\\n```\\n a c b c a X Y ... Z\\n ^         ^\\nn+1        n\\n```\\nCode below:\\n```\\nclass Solution:\\n    def minCut(self, s: str) -> int:\\n        N = len(s)\\n        dp = [x for x in range(N-1, -2, -1)]\\n        \\n        def func(i, j):\\n\\t\\t    # Search all palindrome strings centered by s[i]\\n            while i >= 0 and j < N and s[i] == s[j]:\\n                dp[i] = min(dp[i], dp[j+1]+1)\\n                i-=1\\n                j+=1\\n                \\n        for k in range(N-1, -1, -1):\\n\\t\\t    # Odd palindrome strings\\n            func(k, k)\\n\\t\\t\\t# Even palindrome strings\\n            func(k, k+1)\\n        \\n        return dp[0]\\n```",
                "solutionTags": [],
                "code": "```n```\n```XY...Z```\n```acbca```\n```acbcaXY...Z```\n```n+1```\n```b```\n```b```\n```a```\n```X```\n```\\n a c b c a X Y ... Z\\n ^         ^\\nn+1        n\\n```\n```\\nclass Solution:\\n    def minCut(self, s: str) -> int:\\n        N = len(s)\\n        dp = [x for x in range(N-1, -2, -1)]\\n        \\n        def func(i, j):\\n\\t\\t    # Search all palindrome strings centered by s[i]\\n            while i >= 0 and j < N and s[i] == s[j]:\\n                dp[i] = min(dp[i], dp[j+1]+1)\\n                i-=1\\n                j+=1\\n                \\n        for k in range(N-1, -1, -1):\\n\\t\\t    # Odd palindrome strings\\n            func(k, k)\\n\\t\\t\\t# Even palindrome strings\\n            func(k, k+1)\\n        \\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389281,
                "title": "java-solution-dp",
                "content": "```\\nclass Solution {\\n    public int minCut(String s) {\\n        \\n        // palindrome matrix\\n        boolean[][] dp = new boolean[s.length()][s.length()];\\n        \\n        for(int g = 0; g<s.length();g++){\\n            for(int i=0, j=g; j<dp.length; i++,j++){\\n                if(g==0)\\n                    dp[i][j]=true;\\n                else if(g==1)\\n                    dp[i][j] = s.charAt(i)==s.charAt(j);\\n                else{\\n                    if(s.charAt(i)==s.charAt(j) && dp[i+1][j-1]==true)\\n                        dp[i][j] = true;\\n                    else\\n                        dp[i][j] = false;\\n                }\\n            }\\n        }\\n        \\n        \\n        int[] strg = new int[s.length()];\\n        strg[0] = 0;\\n        \\n        for(int j=1; j<strg.length; j++){\\n            if(dp[0][j]){\\n                strg[j] = 0;\\n            }\\n            else{\\n                int min = Integer.MAX_VALUE;\\n                \\n                for(int i=j; i>=1;i--){\\n                    if(dp[i][j]){\\n                        if(strg[i-1]<min){\\n                            min = strg[i-1];\\n                        }\\n                    }\\n                }\\n                strg[j] = min+1;\\n            }\\n        }\\n        return strg[strg.length-1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minCut(String s) {\\n        \\n        // palindrome matrix\\n        boolean[][] dp = new boolean[s.length()][s.length()];\\n        \\n        for(int g = 0; g<s.length();g++){\\n            for(int i=0, j=g; j<dp.length; i++,j++){\\n                if(g==0)\\n                    dp[i][j]=true;\\n                else if(g==1)\\n                    dp[i][j] = s.charAt(i)==s.charAt(j);\\n                else{\\n                    if(s.charAt(i)==s.charAt(j) && dp[i+1][j-1]==true)\\n                        dp[i][j] = true;\\n                    else\\n                        dp[i][j] = false;\\n                }\\n            }\\n        }\\n        \\n        \\n        int[] strg = new int[s.length()];\\n        strg[0] = 0;\\n        \\n        for(int j=1; j<strg.length; j++){\\n            if(dp[0][j]){\\n                strg[j] = 0;\\n            }\\n            else{\\n                int min = Integer.MAX_VALUE;\\n                \\n                for(int i=j; i>=1;i--){\\n                    if(dp[i][j]){\\n                        if(strg[i-1]<min){\\n                            min = strg[i-1];\\n                        }\\n                    }\\n                }\\n                strg[j] = min+1;\\n            }\\n        }\\n        return strg[strg.length-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1388858,
                "title": "c-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[2001];\\n    int pal[2001][2001];\\n    bool isPalindrome(int i,int j){\\n        return pal[i][j];\\n    }\\n    int Solve(int i , string &s, int n){\\n        if(i >= n){\\n            return 0;\\n        }\\n        if(dp[i] != -1){\\n            return dp[i];\\n        }\\n        int ans = INT_MAX;\\n        for(int j = i; j < n; j++){\\n            // string curr = s.substr(i,j-i+1);\\n            if(isPalindrome(i,j)){\\n                ans = min(ans,Solve(j+1,s,n));\\n            }\\n        }\\n        \\n        dp[i] = (ans == INT_MAX) ? ans : ans + 1;\\n        return dp[i];\\n    }\\n    int minCut(string s) {\\n        memset(dp,-1,sizeof(dp));\\n        int n = s.length();\\n        for(int i = n-1; i >= 0; i--){\\n            for(int j = 0; j < n; j++){\\n                if(i > j){\\n                    pal[i][j] = 0;\\n                }\\n                else if(i == j){\\n                    pal[i][j] = 1;\\n                }\\n                else{\\n                    if(s[i] == s[j]){\\n                        pal[i][j] = i+1 == j ? 1 : pal[i+1][j-1];\\n                    }\\n                    else{\\n                        pal[i][j] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return Solve(0,s,s.length())-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[2001];\\n    int pal[2001][2001];\\n    bool isPalindrome(int i,int j){\\n        return pal[i][j];\\n    }\\n    int Solve(int i , string &s, int n){\\n        if(i >= n){\\n            return 0;\\n        }\\n        if(dp[i] != -1){\\n            return dp[i];\\n        }\\n        int ans = INT_MAX;\\n        for(int j = i; j < n; j++){\\n            // string curr = s.substr(i,j-i+1);\\n            if(isPalindrome(i,j)){\\n                ans = min(ans,Solve(j+1,s,n));\\n            }\\n        }\\n        \\n        dp[i] = (ans == INT_MAX) ? ans : ans + 1;\\n        return dp[i];\\n    }\\n    int minCut(string s) {\\n        memset(dp,-1,sizeof(dp));\\n        int n = s.length();\\n        for(int i = n-1; i >= 0; i--){\\n            for(int j = 0; j < n; j++){\\n                if(i > j){\\n                    pal[i][j] = 0;\\n                }\\n                else if(i == j){\\n                    pal[i][j] = 1;\\n                }\\n                else{\\n                    if(s[i] == s[j]){\\n                        pal[i][j] = i+1 == j ? 1 : pal[i+1][j-1];\\n                    }\\n                    else{\\n                        pal[i][j] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return Solve(0,s,s.length())-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1388853,
                "title": "python-1d-dp-solution",
                "content": "```\\nclass Solution:\\n    def minCut(self, s: str) -> int:\\n        \\n        def is_palindrome(string): \\n            return string == string[::-1]\\n        \\n        dp = [0]*(len(s)+1) #dp[k] will track the minCut of s[:k]\\n        \\n        for k in range(1, len(dp)):\\n            if is_palindrome(s[:k]):\\n                dp[k] = 0  #so if s[:k] is a palindrome, then we dont need to cut it, hence dp[k] = 0\\n            \\n            else:            \\n                dp[k] = dp[k-1] + 1 #initialize, case s[:k] = s[:k-1] + s[k], we know s[k] will always be a palindrome itself (one letter), so we have 1 split.\\n                for j in range(k-1, -1, -1):\\n                    dp[k] = min(dp[k], dp[j] + 1 + int(not(is_palindrome(s[j:k])))*len(s[j:k]))\\n                    #find the best cut (minimizes the number of cuts), at j, where s[:k] = s[:j] + s[j:k]  (add 1 because 1 cut at position j)\\n                    #note that if s[j:k] is a palindrome,  int(not(is_palindrome(s[j:k]))) == 0, so we add nothing for this part\\n                    #when s[j:k] is not a palindrome, int(not(is_palindrome(s[j:k]))) will be 1, we multiply by sth large enough (e.g. len(s[j:k]) or bigger) to \"discard\" the value\\n\\n        return dp[-1]\\n```\\nThis solution is O(N^3) time and O(N) space",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minCut(self, s: str) -> int:\\n        \\n        def is_palindrome(string): \\n            return string == string[::-1]\\n        \\n        dp = [0]*(len(s)+1) #dp[k] will track the minCut of s[:k]\\n        \\n        for k in range(1, len(dp)):\\n            if is_palindrome(s[:k]):\\n                dp[k] = 0  #so if s[:k] is a palindrome, then we dont need to cut it, hence dp[k] = 0\\n            \\n            else:            \\n                dp[k] = dp[k-1] + 1 #initialize, case s[:k] = s[:k-1] + s[k], we know s[k] will always be a palindrome itself (one letter), so we have 1 split.\\n                for j in range(k-1, -1, -1):\\n                    dp[k] = min(dp[k], dp[j] + 1 + int(not(is_palindrome(s[j:k])))*len(s[j:k]))\\n                    #find the best cut (minimizes the number of cuts), at j, where s[:k] = s[:j] + s[j:k]  (add 1 because 1 cut at position j)\\n                    #note that if s[j:k] is a palindrome,  int(not(is_palindrome(s[j:k]))) == 0, so we add nothing for this part\\n                    #when s[j:k] is not a palindrome, int(not(is_palindrome(s[j:k]))) will be 1, we multiply by sth large enough (e.g. len(s[j:k]) or bigger) to \"discard\" the value\\n\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1388696,
                "title": "c-simple-dp-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint n;\\n\\t\\tstring s;\\n\\t\\tvector<int> cuts;\\n\\t\\tvector<vector<int>> dp;\\n\\n\\t\\tbool getPalSub(int i,int j) {\\n\\t\\t\\tif(i>=j) return true;\\n\\t\\t\\tif(dp[i][j]!=-1) return dp[i][j];\\n\\n\\t\\t\\tif(s[i]==s[j] && getPalSub(i+1,j-1)) dp[i][j]=1;\\n\\t\\t\\telse dp[i][j]=0;\\n\\n\\t\\t\\treturn dp[i][j];\\n\\t\\t}\\n\\n\\t\\tint getPalCuts(int i) {\\n\\t\\t\\tif(i==n) return 0;\\n\\t\\t\\tif(cuts[i]!=-1) return cuts[i];\\n\\n\\t\\t\\tint mn=n-i;\\n\\t\\t\\tfor(int j=i;j<n;j++) {\\n\\t\\t\\t\\tif(getPalSub(i,j)) mn= min(mn,getPalCuts(j+1)+1);\\n\\t\\t\\t}\\n\\t\\t\\t// cout<<i<<\"@\"<<mn<<\" \";\\n\\t\\t\\treturn cuts[i]=mn;\\n\\t\\t}\\n\\n\\t\\tint minCut(string s) {\\n\\t\\t\\tn= s.length();\\n\\t\\t\\tthis->s=s;\\n\\t\\t\\tdp.resize(n,vector<int>(n,-1));\\n\\t\\t\\tcuts.resize(n,-1);\\n\\n\\t\\t\\treturn getPalCuts(0)-1;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint n;\\n\\t\\tstring s;\\n\\t\\tvector<int> cuts;\\n\\t\\tvector<vector<int>> dp;\\n\\n\\t\\tbool getPalSub(int i,int j) {\\n\\t\\t\\tif(i>=j) return true;\\n\\t\\t\\tif(dp[i][j]!=-1) return dp[i][j];\\n\\n\\t\\t\\tif(s[i]==s[j] && getPalSub(i+1,j-1)) dp[i][j]=1;\\n\\t\\t\\telse dp[i][j]=0;\\n\\n\\t\\t\\treturn dp[i][j];\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1388625,
                "title": "simple-short-dp-solution-python",
                "content": "```\\nfrom functools import lru_cache\\nclass Solution:\\n    def minCut(self, s: str) -> int:\\n        def palindrome(s):\\n            return s==s[::-1]\\n        @lru_cache(maxsize=None)\\n        def dp(s):\\n            if len(s)==0:\\n                return 0\\n            res = 1e9\\n            for i in range(1,len(s)+1):\\n                if palindrome(s[:i]):\\n                    res = min(res,1 + dp(s[i:]))\\n            return res \\n        return max(0,dp(s)-1)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom functools import lru_cache\\nclass Solution:\\n    def minCut(self, s: str) -> int:\\n        def palindrome(s):\\n            return s==s[::-1]\\n        @lru_cache(maxsize=None)\\n        def dp(s):\\n            if len(s)==0:\\n                return 0\\n            res = 1e9\\n            for i in range(1,len(s)+1):\\n                if palindrome(s[:i]):\\n                    res = min(res,1 + dp(s[i:]))\\n            return res \\n        return max(0,dp(s)-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1388607,
                "title": "python-clean-code-commented",
                "content": "Two step solution:\\n1. We find all the substring that are palindromes using ```getPalindromes```\\n2. We use the recursive formula ```opt(k) = min(opt(k + 1) for k in range(i, n) if (i, k) in palindromes) + 1```\\nto compute the result (i.e. Dynamic Programming).\\n\\n```\\ndef getPalindromes(self, s):\\n    \"\"\"(1) given a string returns a set of all its substring that are palindromes\"\"\"\\n    # Setup:\\n    n = len(s)\\n    palindromes = set()\\n\\n    # Odd length substrings:\\n    for i in range(n):\\n        k = 0\\n        while 0 <= i - k and i + k < n and s[i - k] == s[i + k]:\\n            palindromes.add((i - k, i + k))\\n            k += 1\\n\\n    # Even length substrings:\\n    for i in range(1, n):\\n        k = 0\\n        while 0 <= i - 1 - k and i + k < n and s[i - 1 - k] == s[i + k]:\\n            palindromes.add((i - 1 - k, i + k))\\n            k += 1\\n\\n    return palindromes\\n\\n\\ndef minCut(self, s):\\n    \"\"\"(2) Minimal number of cuts required to partition s into substring that are palindromes\"\"\"\\n\\n    # Setup:\\n    n = len(s)\\n    palindromes = self.getPalindromes(s)\\n\\n    # DP recursive function (minimal number of cuts required for s[i:]):\\n    @functools.cache\\n    def opt(i):\\n        # Breaking Condition (no need to cut at the end of the string)\\n        if i >= n:\\n            return -1\\n        return min(opt(k + 1) for k in range(i, n) if (i, k) in palindromes) + 1\\n\\n    # We compute from the end to the begining to not over use the recurssive stack:\\n    for i in range(n - 1, -1, -1):\\n        result = opt(i)\\n\\n    return result\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```getPalindromes```\n```opt(k) = min(opt(k + 1) for k in range(i, n) if (i, k) in palindromes) + 1```\n```\\ndef getPalindromes(self, s):\\n    \"\"\"(1) given a string returns a set of all its substring that are palindromes\"\"\"\\n    # Setup:\\n    n = len(s)\\n    palindromes = set()\\n\\n    # Odd length substrings:\\n    for i in range(n):\\n        k = 0\\n        while 0 <= i - k and i + k < n and s[i - k] == s[i + k]:\\n            palindromes.add((i - k, i + k))\\n            k += 1\\n\\n    # Even length substrings:\\n    for i in range(1, n):\\n        k = 0\\n        while 0 <= i - 1 - k and i + k < n and s[i - 1 - k] == s[i + k]:\\n            palindromes.add((i - 1 - k, i + k))\\n            k += 1\\n\\n    return palindromes\\n\\n\\ndef minCut(self, s):\\n    \"\"\"(2) Minimal number of cuts required to partition s into substring that are palindromes\"\"\"\\n\\n    # Setup:\\n    n = len(s)\\n    palindromes = self.getPalindromes(s)\\n\\n    # DP recursive function (minimal number of cuts required for s[i:]):\\n    @functools.cache\\n    def opt(i):\\n        # Breaking Condition (no need to cut at the end of the string)\\n        if i >= n:\\n            return -1\\n        return min(opt(k + 1) for k in range(i, n) if (i, k) in palindromes) + 1\\n\\n    # We compute from the end to the begining to not over use the recurssive stack:\\n    for i in range(n - 1, -1, -1):\\n        result = opt(i)\\n\\n    return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1348207,
                "title": "python3-dynamic-programming-min-question-time-complexity-o-n-2",
                "content": "```\\nclass Solution:\\n    def minCut(self, s: str) -> int:\\n        n = len(s)\\n        g = [[True] * n for _ in range(n)]\\n        for i in range(n - 1, -1, -1):\\n            for j in range(i + 1, n):\\n                g[i][j] = s[i] == s[j] and g[i + 1][j - 1] #judge palindrome\\n        f = [float(\\'inf\\')] * n\\n        for i in range(n):\\n            if g[0][i]:\\n                f[i] = 0\\n            else:\\n                for j in range(i):\\n                    if g[j+1][i]:\\n                        f[i] = min(f[i], f[j] + 1)\\n        return f[n-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minCut(self, s: str) -> int:\\n        n = len(s)\\n        g = [[True] * n for _ in range(n)]\\n        for i in range(n - 1, -1, -1):\\n            for j in range(i + 1, n):\\n                g[i][j] = s[i] == s[j] and g[i + 1][j - 1] #judge palindrome\\n        f = [float(\\'inf\\')] * n\\n        for i in range(n):\\n            if g[0][i]:\\n                f[i] = 0\\n            else:\\n                for j in range(i):\\n                    if g[j+1][i]:\\n                        f[i] = min(f[i], f[j] + 1)\\n        return f[n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1294264,
                "title": "easy-o-n-2-approach-in-c",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int minCut(string str) \\n    {\\n        int n=str.length();\\n        // isPalindrom[i][j] reprsents whether string portion from index i to j is a palindrome or not \\n        vector<vector<int>>isPalindrom(n,vector<int>(n,-1));\\n        \\n        // now we\\'ll check for palidroms of different lengths\\n        for(int length=1;length<=n;length++)\\n        {\\n            // string of length 1 is always a palindrome \\n            if(length==1)\\n            {\\n                for(int i=0;i<n;i++)\\n                {\\n                    isPalindrom[i][i]=1;\\n                }\\n            }\\n            \\n            // string of length 2 will be palindrome if first and last charcaters are equal\\n            else if(length==2)\\n            {\\n                for(int i=0;i<n-1;i++)\\n                {\\n                    isPalindrom[i][i+1]=(str[i]==str[i+1]);\\n                }\\n            }\\n            \\n            // now check for palindromes of length>=3\\n            else\\n            {\\n                // if first and last characters are equal and the inner part of the string is a palindrome then the whole string will be a palindrome\\n                for(int i=0;i<=n-length;i++)\\n                {\\n                    int j=i+length-1; // index of the last character\\n                    isPalindrom[i][j]=(str[i]==str[j] && isPalindrom[i+1][j-1]);\\n                }\\n            }\\n        }\\n        // dp[i] gives the minimum cuts for making palindromes till index i\\n        vector<int>dp(n);\\n        dp[0]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            int tmp=INT_MAX;\\n            // search for palindromic suffix and get the cuts before the suffix and add 1 to it to get a temporary answer. dp[i] will be the minimum of all the temporary answers \\n            for(int j=i;j>=0;j--)\\n            {\\n                if(isPalindrom[j][i]==1)\\n                {\\n                    tmp=(j==0?0:min(tmp,dp[j-1]+1));\\n                }\\n            }\\n            dp[i]=tmp;\\n        }\\n        // finally return the cuts till the last index\\n        return dp[n-1];\\n    }\\n};\\n```\\n**Time complexity:- O(n^2)**\\n**Space complexity:- O(n^2)**\\n***Please upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int minCut(string str) \\n    {\\n        int n=str.length();\\n        // isPalindrom[i][j] reprsents whether string portion from index i to j is a palindrome or not \\n        vector<vector<int>>isPalindrom(n,vector<int>(n,-1));\\n        \\n        // now we\\'ll check for palidroms of different lengths\\n        for(int length=1;length<=n;length++)\\n        {\\n            // string of length 1 is always a palindrome \\n            if(length==1)\\n            {\\n                for(int i=0;i<n;i++)\\n                {\\n                    isPalindrom[i][i]=1;\\n                }\\n            }\\n            \\n            // string of length 2 will be palindrome if first and last charcaters are equal\\n            else if(length==2)\\n            {\\n                for(int i=0;i<n-1;i++)\\n                {\\n                    isPalindrom[i][i+1]=(str[i]==str[i+1]);\\n                }\\n            }\\n            \\n            // now check for palindromes of length>=3\\n            else\\n            {\\n                // if first and last characters are equal and the inner part of the string is a palindrome then the whole string will be a palindrome\\n                for(int i=0;i<=n-length;i++)\\n                {\\n                    int j=i+length-1; // index of the last character\\n                    isPalindrom[i][j]=(str[i]==str[j] && isPalindrom[i+1][j-1]);\\n                }\\n            }\\n        }\\n        // dp[i] gives the minimum cuts for making palindromes till index i\\n        vector<int>dp(n);\\n        dp[0]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            int tmp=INT_MAX;\\n            // search for palindromic suffix and get the cuts before the suffix and add 1 to it to get a temporary answer. dp[i] will be the minimum of all the temporary answers \\n            for(int j=i;j>=0;j--)\\n            {\\n                if(isPalindrom[j][i]==1)\\n                {\\n                    tmp=(j==0?0:min(tmp,dp[j-1]+1));\\n                }\\n            }\\n            dp[i]=tmp;\\n        }\\n        // finally return the cuts till the last index\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1281594,
                "title": "cpp-dp-easy-with-explaination-o-n2",
                "content": "We check for both odd length and even length palindromes in the given string. \\nIf a substring is a palindrome, \\n: b (aaa) y  -> here (aaa) is a palindrome so , the cuts required for the string  baaa will be similar to that required for the string ba. \\n\\nThis concept is used, beginning with the maximum value of the cuts required for any string of length n to be n-1 as default.  \\n(even if the string has no actual palindromee with len>1)\\n\\n```\\nclass Solution {\\npublic:\\n    int minCut(string s) {\\n        int n = s.size();\\n        vector<int> cut(n,0);  // number of cuts for the first k characters\\n        for(int i=0; i<n; i++) cut[i]=i;\\n        for(int c=0; c<n; c++){\\n            int l=c,r=c; // odd lenth palindrome with center c\\n            for(;l>=0 && r<n; l--, r++){\\n                if(s[l]!=s[r]) break;\\n                if(l==0) cut[r] = 0;\\n                else cut[r] = min(cut[r], cut[l-1]+1);\\n            }\\n            l=c, r=c+1; // even lenth palindrome with center c\\n            for(;l>=0 && r<n; l--, r++){\\n                if(s[l]!=s[r]) break;\\n                if(l==0) cut[r] = 0;\\n                else cut[r] = min(cut[r], cut[l-1]+1);\\n            }\\n        }\\n        return cut[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCut(string s) {\\n        int n = s.size();\\n        vector<int> cut(n,0);  // number of cuts for the first k characters\\n        for(int i=0; i<n; i++) cut[i]=i;\\n        for(int c=0; c<n; c++){\\n            int l=c,r=c; // odd lenth palindrome with center c\\n            for(;l>=0 && r<n; l--, r++){\\n                if(s[l]!=s[r]) break;\\n                if(l==0) cut[r] = 0;\\n                else cut[r] = min(cut[r], cut[l-1]+1);\\n            }\\n            l=c, r=c+1; // even lenth palindrome with center c\\n            for(;l>=0 && r<n; l--, r++){\\n                if(s[l]!=s[r]) break;\\n                if(l==0) cut[r] = 0;\\n                else cut[r] = min(cut[r], cut[l-1]+1);\\n            }\\n        }\\n        return cut[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1263556,
                "title": "o-n-2-solution-similar-to-pepcoding",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCut(string s) {\\n        int n = s.length();\\n        bool dp[n][n];\\n        for(int i = 0;i<n;i++)\\n            dp[i][i] = true;\\n        for(int g = 1;g<n;g++)\\n        {\\n            for(int i=0,j=g;j<n;i++,j++)\\n            {\\n                if(g == 1)\\n                {\\n                    dp[i][j] = s[i]==s[j];\\n                }\\n                else\\n                {\\n                    if(s[i] == s[j] and dp[i+1][j-1] == true)\\n                        dp[i][j] = true;\\n                    else\\n                        dp[i][j] = false;\\n                }\\n            }\\n        }\\n        int storage[n];\\n        storage[0] = 0;\\n        for(int j = 1;j<n;j++)\\n        {   if(dp[0][j])\\n              storage[j] = 0;\\n           else\\n           {   \\n            int mini = INT_MAX;\\n            for(int i = j;i>=1;i--)\\n            {   \\n                if(dp[i][j])\\n                {\\n                    mini = min(mini,storage[i-1]);\\n                }\\n            } \\n              storage[j] = mini+1;  \\n           }\\n           \\n        }\\n        return storage[n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCut(string s) {\\n        int n = s.length();\\n        bool dp[n][n];\\n        for(int i = 0;i<n;i++)\\n            dp[i][i] = true;\\n        for(int g = 1;g<n;g++)\\n        {\\n            for(int i=0,j=g;j<n;i++,j++)\\n            {\\n                if(g == 1)\\n                {\\n                    dp[i][j] = s[i]==s[j];\\n                }\\n                else\\n                {\\n                    if(s[i] == s[j] and dp[i+1][j-1] == true)\\n                        dp[i][j] = true;\\n                    else\\n                        dp[i][j] = false;\\n                }\\n            }\\n        }\\n        int storage[n];\\n        storage[0] = 0;\\n        for(int j = 1;j<n;j++)\\n        {   if(dp[0][j])\\n              storage[j] = 0;\\n           else\\n           {   \\n            int mini = INT_MAX;\\n            for(int i = j;i>=1;i--)\\n            {   \\n                if(dp[i][j])\\n                {\\n                    mini = min(mini,storage[i-1]);\\n                }\\n            } \\n              storage[j] = mini+1;  \\n           }\\n           \\n        }\\n        return storage[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1258872,
                "title": "accepted-solution-in-5-lines-python",
                "content": "```\\nclass Solution:\\n    def minCut(self, s: str) -> int:\\n        n = len(s)\\n        dp = [n-1] * n\\n        dp[0] = 0 \\n        for i in range( 1, n ):\\n            for j in range( i+1 ):\\n                if( s[j:i+1] == s[j:i+1][::-1] ):\\n                    dp[i] = min( dp[i], dp[j-1] + 1 ) if(j > 0) else 0\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minCut(self, s: str) -> int:\\n        n = len(s)\\n        dp = [n-1] * n\\n        dp[0] = 0 \\n        for i in range( 1, n ):\\n            for j in range( i+1 ):\\n                if( s[j:i+1] == s[j:i+1][::-1] ):\\n                    dp[i] = min( dp[i], dp[j-1] + 1 ) if(j > 0) else 0\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1234086,
                "title": "for-people-getting-tle-28-33-32-33-ac-small-optimizations-clean-explained-c-code",
                "content": "**Intuition**: Let `dp[i][j]` represent the minimum cuts needed for the palindromic partitioning of `s[i...j]`. Our final answer would be `dp[0][n-1]`, where `n` is the length of the input string. It is very obvious reading the question that we\\'ve to search for all the positions where we can cut the string to get the minimum answer. Thus this question is very similar to the **Matrix Chain Multiplication pattern** of DP questions. \\nWe can choose any `k` from `[i...j)` such that `[i....(k), (k+1), ..., j]` will be one possible palindromic partition of the string. Our answer would then be `dp[i][j]= min(dp[i][j], dp[i][k] + dp[k+1][j] + 1)` (for all `i<=k<j` ). We\\'ve added a `+1` in our equation since we need one cut to divide a substring into two palindromic partitions. \\nNote, this alone will time out for not-so-obvious reasons.\\n\\n**Optimizations**: We can store our answer of `isPalindrome(s, i, j)` in a `dp` state `(i, j)`. Note that every recursive call for the left and right parts of the substring stop when the base case (i.e the partitioned string is a palindrome) is reached. The major optimization in this question is that we partition the string only when the left part i.e. `s[i...k]` is a palindrome. Doing this we\\'re effectively reducing a lot of unnecessary checks for every `k`. This small yet useful optimization made my code accepted.\\n\\n**Code**:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    \\n    bool isPalindrome(string &s, int i, int j){\\n        if(i>=j) return true;\\n        if(s[i]!=s[j]) return false;\\n        return isPalindrome(s, i+1, j-1);\\n    }\\n    \\n    int solve(string &s, int i, int j){\\n        if(isPalindrome(s, i, j)){\\n            dp[i][j]= 0;\\n            return 0;\\n        }\\n        if(i>=j) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int res= INT_MAX;\\n        for(int k=i; k<=j-1; k++){\\n            if(!isPalindrome(s, i, k)) continue;\\n            int right, left;\\n            if(dp[i][k]!=-1) left= dp[i][k];\\n            else{\\n                left= solve(s, i, k);\\n                dp[i][k]= left;\\n            }\\n            if(dp[k+1][j]!=-1) right= dp[k+1][j];\\n            else{\\n                right= solve(s, k+1, j);\\n                dp[k+1][j]= right;\\n            }\\n            res= min(res, 1+left+right);\\n        }\\n        return dp[i][j]= res;\\n    }\\n    \\n    int minCut(string s){\\n        int n= s.size();\\n        dp= vector<vector<int>>(n+1, vector<int>(n+1, -1));\\n        return solve(s, 0, n-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    \\n    bool isPalindrome(string &s, int i, int j){\\n        if(i>=j) return true;\\n        if(s[i]!=s[j]) return false;\\n        return isPalindrome(s, i+1, j-1);\\n    }\\n    \\n    int solve(string &s, int i, int j){\\n        if(isPalindrome(s, i, j)){\\n            dp[i][j]= 0;\\n            return 0;\\n        }\\n        if(i>=j) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int res= INT_MAX;\\n        for(int k=i; k<=j-1; k++){\\n            if(!isPalindrome(s, i, k)) continue;\\n            int right, left;\\n            if(dp[i][k]!=-1) left= dp[i][k];\\n            else{\\n                left= solve(s, i, k);\\n                dp[i][k]= left;\\n            }\\n            if(dp[k+1][j]!=-1) right= dp[k+1][j];\\n            else{\\n                right= solve(s, k+1, j);\\n                dp[k+1][j]= right;\\n            }\\n            res= min(res, 1+left+right);\\n        }\\n        return dp[i][j]= res;\\n    }\\n    \\n    int minCut(string s){\\n        int n= s.size();\\n        dp= vector<vector<int>>(n+1, vector<int>(n+1, -1));\\n        return solve(s, 0, n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1171756,
                "title": "my-java-solution-using-recursion-and-memoization",
                "content": "```\\nclass Solution {\\n    private Integer[][] dp;\\n    private Boolean [][] palindromeString;\\n    public int minCut(String s) {\\n        dp = new Integer [s.length()][s.length()];\\n        palindromeString = new Boolean [s.length()][s.length()];\\n        return helper(s, 0, s.length() - 1);\\n    }\\n    \\n    public int  helper(String s, int start, int end) {\\n        if (start == end || isPalindrome(s, start, end)) {\\n            return 0;\\n        }\\n        if (dp[start][end] != null) {\\n            return dp[start][end];\\n        }\\n        int cut = s.length() - 1;\\n        for (int i=start; i<=end; i++) {\\n            if (isPalindrome(s, start, i)) {\\n                cut = Math.min(cut, 1 + helper(s, i + 1, end));\\n            }\\n        }\\n        dp[start][end] = cut;\\n        return cut;\\n    }\\n    \\n    public boolean isPalindrome(String s, int left, int right) {\\n        while (left < right) {\\n            if (s.charAt(left++) != s.charAt(right --))\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    private Integer[][] dp;\\n    private Boolean [][] palindromeString;\\n    public int minCut(String s) {\\n        dp = new Integer [s.length()][s.length()];\\n        palindromeString = new Boolean [s.length()][s.length()];\\n        return helper(s, 0, s.length() - 1);\\n    }\\n    \\n    public int  helper(String s, int start, int end) {\\n        if (start == end || isPalindrome(s, start, end)) {\\n            return 0;\\n        }\\n        if (dp[start][end] != null) {\\n            return dp[start][end];\\n        }\\n        int cut = s.length() - 1;\\n        for (int i=start; i<=end; i++) {\\n            if (isPalindrome(s, start, i)) {\\n                cut = Math.min(cut, 1 + helper(s, i + 1, end));\\n            }\\n        }\\n        dp[start][end] = cut;\\n        return cut;\\n    }\\n    \\n    public boolean isPalindrome(String s, int left, int right) {\\n        while (left < right) {\\n            if (s.charAt(left++) != s.charAt(right --))\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 948923,
                "title": "simple-java-solution-with-memoization",
                "content": "```\\nclass Solution {\\n    public int minCut(String s) {\\n        if(ispalindrome(s.toCharArray(),0, s.length()-1)) {\\n            return 0;\\n        }\\n        int[] dp = new int[s.length()+1];\\n        Arrays.fill(dp, -1);\\n        int min = dfs(s.toCharArray(), 0, dp);\\n        \\n        return min;\\n    }\\n    \\n    int dfs(char[] s, int index, int[] dp) {\\n        if(index==s.length) { \\n            return 0;\\n        }\\n        \\n        if(dp[index]!=-1) return dp[index];\\n        \\n        if(ispalindrome(s, index, s.length-1)) {\\n            dp[index] = 0;\\n            return 0;\\n        }\\n        int min = s.length;\\n        \\n        for(int i=index;i<s.length;i++) {\\n            if(ispalindrome(s, index, i)) {\\n                min = Math.min(min, dfs(s, i+1, dp)+1);\\n                \\n                if(min==1) break;\\n            }\\n        }\\n        dp[index] = min;\\n        return min;\\n    }\\n    \\n    boolean ispalindrome(char[] arr, int i, int j) {\\n        while(i<=j) {\\n            if(arr[i]!=arr[j]) return false;\\n            i++; j--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minCut(String s) {\\n        if(ispalindrome(s.toCharArray(),0, s.length()-1)) {\\n            return 0;\\n        }\\n        int[] dp = new int[s.length()+1];\\n        Arrays.fill(dp, -1);\\n        int min = dfs(s.toCharArray(), 0, dp);\\n        \\n        return min;\\n    }\\n    \\n    int dfs(char[] s, int index, int[] dp) {\\n        if(index==s.length) { \\n            return 0;\\n        }\\n        \\n        if(dp[index]!=-1) return dp[index];\\n        \\n        if(ispalindrome(s, index, s.length-1)) {\\n            dp[index] = 0;\\n            return 0;\\n        }\\n        int min = s.length;\\n        \\n        for(int i=index;i<s.length;i++) {\\n            if(ispalindrome(s, index, i)) {\\n                min = Math.min(min, dfs(s, i+1, dp)+1);\\n                \\n                if(min==1) break;\\n            }\\n        }\\n        dp[index] = min;\\n        return min;\\n    }\\n    \\n    boolean ispalindrome(char[] arr, int i, int j) {\\n        while(i<=j) {\\n            if(arr[i]!=arr[j]) return false;\\n            i++; j--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 923428,
                "title": "3-clear-c-solutions-from-650ms-to-8ms",
                "content": "The last two are the typical methods for the problem with DP. While the first code is my first solution: convert it to a graph problem and use Breadth First Search to get the min cut. It is slow but gives a different view. The third one is the fastest solution.\\n1. Think of it as a graph and use BFS:\\n```\\nint minCut(string s) { // convert it to a graph first, and then do BFS\\n        int len = s.size(), ret = 0;\\n        if(len==0 || len==1) {return ret;}\\n        vector<set<int> > dp(len, set<int>()); // dp[i] is a set, an element j in this set means: (i,j) is a pal.\\n        for(int i=len-1;i>=0;i--){\\n            dp[i].insert(i); // one char is a palindrome itself\\n            for(int j=i+1;j<len;j++){\\n                if(s[j]==s[i]){\\n                    if(j==i+1 || dp[i+1].count(j-1)!=0) dp[i].insert(j);\\n                }\\n            }\\n        }\\n        \\n        // standard BFS on the dp, think of it as a graph\\n        set<int> frontier;\\n        frontier.insert(0);\\n        while(1){\\n            set<int> next;\\n            for(int num : frontier){\\n                for(int i : dp[num]){\\n                    if(i == len-1) return ret;\\n                    next.insert(i+1);\\n                }\\n            }\\n            frontier = next;\\n            ret ++;\\n        }\\n        return ret; // will not execute here\\n    }\\n```\\n\\n2. Maintain a one dimensional array dp to indicate the min cut. Meantime a two dimensional array isPal[i][j] is used to indicate whether string (i,j) is a pal or not. Update dp whenever we find a pal string.\\n```\\nint minCut(string s) { // use two dimentional array isPal[i][j] to indicate whether (i,j) is a pal. \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t//And use one dimention array dp[i] to indicate the min cut needed for the string s[i:].\\n        int len = s.size();\\n        vector<vector<int> > isPal(len, vector<int>(len, 0));\\n        vector<int> dp(len);\\n        \\n        for(int i=len-1;i>=0;i--){\\n            dp[i] = len - 1 - i; // a baseline min cut\\n            for(int j=i;j<len;j++){\\n                if(s[j]==s[i]){\\n                    if(j-i<2 || isPal[i+1][j-1]){ // (i,j) must be a pal string\\n                        isPal[i][j] = 1;\\n                        if(j==len-1) dp[i] = 0;\\n                        else dp[i] = min( dp[i], dp[j+1]+1);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n```\\n3. The two dimensional array isPal can be dropped if we use manchester method to check the pal string. And again update dp if we find a pal string.\\n```\\nint minCut(string s) { // Manchester method to check a string is a pal or not, and no need to use two dimensional array anymore. \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// dp here means the min cut needed for the string s[:i]\\n        int len = s.size();\\n        vector<int> dp(len);\\n        for(int i=0;i<len;i++) dp[i] = i; // baseline min cut\\n        for(int i=0;i<len;i++){\\n            for(int j=0; i-j>=0 && i+j<len && s[i-j]==s[i+j];j++){ // (i-j, i+j) is a pal, odd length\\n                if(i-j==0) dp[i+j] = 0;\\n                else dp[i+j] = min(dp[i+j], dp[i-j-1] + 1);\\n            }\\n            for(int j=0; i-j>=0 && i+j+1<len && s[i-j]==s[i+j+1];j++){ // (i-j, i+j+1) is a pal, even length\\n                if(i-j==0) dp[i+j+1] = 0;\\n                else dp[i+j+1] = min(dp[i+j+1], dp[i-j-1] + 1);\\n            }\\n        }\\n        return dp[len-1];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint minCut(string s) { // convert it to a graph first, and then do BFS\\n        int len = s.size(), ret = 0;\\n        if(len==0 || len==1) {return ret;}\\n        vector<set<int> > dp(len, set<int>()); // dp[i] is a set, an element j in this set means: (i,j) is a pal.\\n        for(int i=len-1;i>=0;i--){\\n            dp[i].insert(i); // one char is a palindrome itself\\n            for(int j=i+1;j<len;j++){\\n                if(s[j]==s[i]){\\n                    if(j==i+1 || dp[i+1].count(j-1)!=0) dp[i].insert(j);\\n                }\\n            }\\n        }\\n        \\n        // standard BFS on the dp, think of it as a graph\\n        set<int> frontier;\\n        frontier.insert(0);\\n        while(1){\\n            set<int> next;\\n            for(int num : frontier){\\n                for(int i : dp[num]){\\n                    if(i == len-1) return ret;\\n                    next.insert(i+1);\\n                }\\n            }\\n            frontier = next;\\n            ret ++;\\n        }\\n        return ret; // will not execute here\\n    }\\n```\n```\\nint minCut(string s) { // use two dimentional array isPal[i][j] to indicate whether (i,j) is a pal. \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t//And use one dimention array dp[i] to indicate the min cut needed for the string s[i:].\\n        int len = s.size();\\n        vector<vector<int> > isPal(len, vector<int>(len, 0));\\n        vector<int> dp(len);\\n        \\n        for(int i=len-1;i>=0;i--){\\n            dp[i] = len - 1 - i; // a baseline min cut\\n            for(int j=i;j<len;j++){\\n                if(s[j]==s[i]){\\n                    if(j-i<2 || isPal[i+1][j-1]){ // (i,j) must be a pal string\\n                        isPal[i][j] = 1;\\n                        if(j==len-1) dp[i] = 0;\\n                        else dp[i] = min( dp[i], dp[j+1]+1);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n```\n```\\nint minCut(string s) { // Manchester method to check a string is a pal or not, and no need to use two dimensional array anymore. \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// dp here means the min cut needed for the string s[:i]\\n        int len = s.size();\\n        vector<int> dp(len);\\n        for(int i=0;i<len;i++) dp[i] = i; // baseline min cut\\n        for(int i=0;i<len;i++){\\n            for(int j=0; i-j>=0 && i+j<len && s[i-j]==s[i+j];j++){ // (i-j, i+j) is a pal, odd length\\n                if(i-j==0) dp[i+j] = 0;\\n                else dp[i+j] = min(dp[i+j], dp[i-j-1] + 1);\\n            }\\n            for(int j=0; i-j>=0 && i+j+1<len && s[i-j]==s[i+j+1];j++){ // (i-j, i+j+1) is a pal, even length\\n                if(i-j==0) dp[i+j+1] = 0;\\n                else dp[i+j+1] = min(dp[i+j+1], dp[i-j-1] + 1);\\n            }\\n        }\\n        return dp[len-1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 906389,
                "title": "java-dp-o-n2-time-and-space-with-explanation",
                "content": "The question is a transfromation of PALINDROME PARTITIONING I.\\n\\nThe common point of the 2 questions is they both utilized a boolean matrix** isPalindrome[][]** to query whether a substring of s is Palindrome or not in **O(1) ** time.\\n\\nThe different point of the 2 questions is that instead of using backtracking, we use dp to get the min cut.\\n\\nFor each **s.charAt(i)** in string, it has the following choices: \\n1) It is part of a Palindrome which starts at index 0 and ends at i. => 0 cut needed.\\n2) It is part of a Palindrome which starts at any index **j** in [1, i] and ends at i. => minCut[j - 1] + 1 cut needed.\\n\\nWhen doing backtracking/dp problems, always think about **what are the CHOICES** we have in each sub-problem.\\n\\nCode can be further optimized and I mainly focused on the idea rather than code.\\n\\n```\\nclass Solution {\\n    public int minCut(String s) {\\n        if(s == null || s.length() == 0) {\\n            return 0;\\n        }\\n        int length = s.length();\\n\\n        boolean[][] isP = new boolean[length][length];\\n        // populate isP\\n        populateIsP(s, isP);\\n        if(isP[0][length - 1]) return 0;\\n\\n        int[] minCut = new int[length];\\n        minCut[0] = 0;\\n\\n        for(int i = 1; i < minCut.length; i++) {\\n            int curMin = Integer.MAX_VALUE;\\n            if(isP[0][i]) {\\n                curMin = 0;\\n            }\\n            // j is the start of the merged Palindrome\\n            for(int j = 1; j <= i; j++) {\\n               if(isP[j][i]) {\\n                    curMin = Math.min(curMin, minCut[j - 1] + 1);\\n                }\\n            }\\n            minCut[i] = curMin;\\n        }\\n        return minCut[length - 1];\\n    }\\n\\n    private void populateIsP(String s, boolean[][] isP) {\\n        int length = s.length();\\n        for(int end = 0; end < length; end++) {\\n            for(int start = 0; start <= end; start++) {\\n                if(start == end) {\\n                    isP[start][end] = true;\\n                } else if(start + 1 == end) {\\n                    isP[start][end] = s.charAt(start) == s.charAt(end);\\n                } else {\\n                    isP[start][end] = s.charAt(start) == s.charAt(end)\\n                            && isP[start + 1][end - 1];\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minCut(String s) {\\n        if(s == null || s.length() == 0) {\\n            return 0;\\n        }\\n        int length = s.length();\\n\\n        boolean[][] isP = new boolean[length][length];\\n        // populate isP\\n        populateIsP(s, isP);\\n        if(isP[0][length - 1]) return 0;\\n\\n        int[] minCut = new int[length];\\n        minCut[0] = 0;\\n\\n        for(int i = 1; i < minCut.length; i++) {\\n            int curMin = Integer.MAX_VALUE;\\n            if(isP[0][i]) {\\n                curMin = 0;\\n            }\\n            // j is the start of the merged Palindrome\\n            for(int j = 1; j <= i; j++) {\\n               if(isP[j][i]) {\\n                    curMin = Math.min(curMin, minCut[j - 1] + 1);\\n                }\\n            }\\n            minCut[i] = curMin;\\n        }\\n        return minCut[length - 1];\\n    }\\n\\n    private void populateIsP(String s, boolean[][] isP) {\\n        int length = s.length();\\n        for(int end = 0; end < length; end++) {\\n            for(int start = 0; start <= end; start++) {\\n                if(start == end) {\\n                    isP[start][end] = true;\\n                } else if(start + 1 == end) {\\n                    isP[start][end] = s.charAt(start) == s.charAt(end);\\n                } else {\\n                    isP[start][end] = s.charAt(start) == s.charAt(end)\\n                            && isP[start + 1][end - 1];\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 841405,
                "title": "dfs-with-explanation-and-time-complexity",
                "content": "We first find all palindromes in string `s`. This forms a graph where the vertices are the start indices, and the edges are the length of the palindromes. Then we run BFS on this graph, visiting the neighbor first that has the longest palindrome. We make this greedy choice based on the common sense that we will need fewer cuts if we can cover more ground by following a longer edge.\\n\\n**Time complexity:**\\n\\nNote that for `1 <= i <= n`, there are `n - i - 1` possible substrings.\\nThus, finding all palindromes takes `n - 1 + n - 2 + ... + 1` time, which is `O(n^2)`.\\nBFS takes `O(n)` time in the worst case when all characters are distinct. Each heap operation takes `O(log n)` time.\\nOverall time complexity: `O(n^2) + O(n log n) = O(n^2)`.\\n\\n```\\nimport heapq\\nfrom typing import MutableMapping, MutableSequence, Set, List, Tuple\\n\\nclass Solution:\\n    def minCut(self, s: str) -> int:\\n        graph: MutableMapping[int, MutableSequence[int]] = dict()\\n        palindromes: Set[Tuple[int, int]] = set()\\n        n = len(s)\\n        for i in range(n):\\n            graph[i] = [i + 1]\\n            palindromes.add((i, i + 1))\\n\\n        for length in range(2, n + 1):\\n            for start in range(n - length + 1):\\n                end = start + length - 1\\n\\n                if s[start] == s[end] and (end - start == 1 or (start + 1, end) in palindromes):\\n                    graph[start].append(end + 1)\\n                    palindromes.add((start, end + 1))\\n\\n        del palindromes\\n\\n        queue: List[Tuple[int, int, int]] = [(0, graph[0][-1], 0)]\\n        seen: Set[int] = set()\\n\\n        while queue:\\n            x = heapq.heappop(queue)\\n            depth, i = x[0], -x[2]\\n            seen.add(i)\\n            if i == n:\\n                return depth - 1\\n\\n            unseen_neighbors = filter(lambda k: k not in seen, graph[i])\\n            for j in unseen_neighbors:\\n                k = graph[j][-1] if j in graph else j\\n                heapq.heappush(queue, (depth + 1, -k, -j))\\n\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\nimport heapq\\nfrom typing import MutableMapping, MutableSequence, Set, List, Tuple\\n\\nclass Solution:\\n    def minCut(self, s: str) -> int:\\n        graph: MutableMapping[int, MutableSequence[int]] = dict()\\n        palindromes: Set[Tuple[int, int]] = set()\\n        n = len(s)\\n        for i in range(n):\\n            graph[i] = [i + 1]\\n            palindromes.add((i, i + 1))\\n\\n        for length in range(2, n + 1):\\n            for start in range(n - length + 1):\\n                end = start + length - 1\\n\\n                if s[start] == s[end] and (end - start == 1 or (start + 1, end) in palindromes):\\n                    graph[start].append(end + 1)\\n                    palindromes.add((start, end + 1))\\n\\n        del palindromes\\n\\n        queue: List[Tuple[int, int, int]] = [(0, graph[0][-1], 0)]\\n        seen: Set[int] = set()\\n\\n        while queue:\\n            x = heapq.heappop(queue)\\n            depth, i = x[0], -x[2]\\n            seen.add(i)\\n            if i == n:\\n                return depth - 1\\n\\n            unseen_neighbors = filter(lambda k: k not in seen, graph[i])\\n            for j in unseen_neighbors:\\n                k = graph[j][-1] if j in graph else j\\n                heapq.heappush(queue, (depth + 1, -k, -j))\\n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 791935,
                "title": "python3-illustrated-explanation",
                "content": "# how to calculate longest palindrome\\n\\n![image](https://assets.leetcode.com/users/images/e9c76343-0ca2-4af9-b182-4c80e0a9bfc1_1597431409.6961389.png)\\n\\n![image](https://assets.leetcode.com/users/images/9e106acb-7336-4faa-a4a0-01e72ea907a1_1597431856.039359.png)\\n\\n\\n```\\n    def longestPalindrome(self, s: str) -> str:  # pylint: disable=invalid-name\\n        \"\"\" O(N^2)T O(N^2)S \"\"\"\\n        if not s:\\n            return \"\"\\n\\n        size = len(s)\\n        table, longest_start, longest_end = [[False] * size for _ in range(size)], None, None\\n\\n        # one letter is palindrome\\n        for i in range(size):\\n            table[i][i] = True\\n\\n        # start from 2-letter words, then 3-letter, etc\\n        for l in range(2, size + 1):\\n            for start in range(size - l + 1):\\n                end = start + l - 1\\n                is_equal_letters = s[start] == s[end]\\n                table[start][end] = is_equal_letters if l == 2 else is_equal_letters and table[start + 1][end - 1]\\n                if table[start][end]: # update longest palindrome\\n                    longest_start, longest_end = start, end\\n\\n        return s[longest_start:longest_end + 1] if longest_start is not None else s[0]\\n```\\n\\n# how to make partitioning\\n\\n![image](https://assets.leetcode.com/users/images/8e35a6a0-5172-405a-9219-d75c8740615b_1597431563.626445.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/2244b68b-8e28-4671-9f2a-2e8335513030_1597431577.652332.png)\\n\\n\\n# how to make final decision\\n\\n![image](https://assets.leetcode.com/users/images/b26a67d7-8b5a-448b-96eb-cec8ed4ddd41_1597431611.9925609.png)\\n\\n\\n```\\ndef palindromePartitioningMinCuts(string):  # pylint: disable=invalid-name\\n    \"\"\" O(N^2)T O(N^2)S \"\"\"\\n    size = len(string)\\n    table, split = [[False] * size for _ in range(size)], [math.inf for _ in range(size)]\\n\\n    # one letter is palindrome\\n    for i in range(size):\\n        table[i][i] = True\\n\\n    # start from 2-letter words, then 3-letter, etc\\n    for l in range(2, size + 1):\\n        for start in range(size - l + 1): #[0 size-l]\\n            end = start + l - 1\\n            is_equal_letters = string[start] == string[end]\\n            table[start][end] = is_equal_letters if l == 2 else is_equal_letters and table[start + 1][end - 1]\\n\\n    # each cell of split table is count splitters\\n    for x in range(size):\\n        if table[0][x]:\\n            split[x] = 0  # if word from start to given index is palindrome then no splitter\\n        else:\\n            split[x] = split[x - 1] + 1  # each letter give +1 splitter\\n            for y in range(1, x):  # skip first row and last-diagonal row\\n                if table[y][x]:\\n                    split[x] = min(split[x], split[y - 1] + 1)  # find palindrome and  before_palindrome_cnt+1\\n    return split[-1]\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n    def longestPalindrome(self, s: str) -> str:  # pylint: disable=invalid-name\\n        \"\"\" O(N^2)T O(N^2)S \"\"\"\\n        if not s:\\n            return \"\"\\n\\n        size = len(s)\\n        table, longest_start, longest_end = [[False] * size for _ in range(size)], None, None\\n\\n        # one letter is palindrome\\n        for i in range(size):\\n            table[i][i] = True\\n\\n        # start from 2-letter words, then 3-letter, etc\\n        for l in range(2, size + 1):\\n            for start in range(size - l + 1):\\n                end = start + l - 1\\n                is_equal_letters = s[start] == s[end]\\n                table[start][end] = is_equal_letters if l == 2 else is_equal_letters and table[start + 1][end - 1]\\n                if table[start][end]: # update longest palindrome\\n                    longest_start, longest_end = start, end\\n\\n        return s[longest_start:longest_end + 1] if longest_start is not None else s[0]\\n```\n```\\ndef palindromePartitioningMinCuts(string):  # pylint: disable=invalid-name\\n    \"\"\" O(N^2)T O(N^2)S \"\"\"\\n    size = len(string)\\n    table, split = [[False] * size for _ in range(size)], [math.inf for _ in range(size)]\\n\\n    # one letter is palindrome\\n    for i in range(size):\\n        table[i][i] = True\\n\\n    # start from 2-letter words, then 3-letter, etc\\n    for l in range(2, size + 1):\\n        for start in range(size - l + 1): #[0 size-l]\\n            end = start + l - 1\\n            is_equal_letters = string[start] == string[end]\\n            table[start][end] = is_equal_letters if l == 2 else is_equal_letters and table[start + 1][end - 1]\\n\\n    # each cell of split table is count splitters\\n    for x in range(size):\\n        if table[0][x]:\\n            split[x] = 0  # if word from start to given index is palindrome then no splitter\\n        else:\\n            split[x] = split[x - 1] + 1  # each letter give +1 splitter\\n            for y in range(1, x):  # skip first row and last-diagonal row\\n                if table[y][x]:\\n                    split[x] = min(split[x], split[y - 1] + 1)  # find palindrome and  before_palindrome_cnt+1\\n    return split[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 780249,
                "title": "shortest-path-algo-o-n-2",
                "content": "Find all possible indices of palindromes in a string, which we can find in O(n^2). After which the problem translates to find shortest pathe between source and destination where source is the starting index (0) and destination the length of the string (n).\\n\\n```\\n#define pii pair <int, int>\\n#define MAX 100005\\nclass Solution {\\npublic:\\n    vector <int> edge[MAX];\\n    void expand(string s, int low, int high, set <pii> &pid) {\\n        int n = s.size();\\n        while (low >= 0 and high < n and s[low] == s[high]) {\\n            pid.insert(make_pair(low, high));\\n            low--;\\n            high++;\\n        }\\n    }\\n    int path(int src, int dest, int n) {\\n        queue <int> q;\\n        int dist[n + 1];\\n        \\n        for (int i = 0; i <= n; i++) dist[i] = -1;\\n\\n        dist[src] = 0;\\n        q.push(src);\\n        \\n        while(!q.empty()) {\\n            int u = q.front();\\n            q.pop();\\n            \\n            if (u == n) break;\\n            \\n            for (auto v : edge[u]) {\\n                if (dist[v] == -1) {\\n                    dist[v] = dist[u] + 1;\\n                    q.push(v);\\n                }\\n            }\\n        }\\n        \\n        return dist[n] - 1;\\n    }\\n    int minCut(string s) {\\n        set <pii> pid;\\n        int n = s.size(), res = 0;\\n        for (int i = 0; i < n; i++) {\\n            expand(s, i, i, pid);\\n            expand(s, i, i + 1, pid);\\n        }\\n        \\n        for (auto id: pid) {\\n            edge[id.first].push_back(id.second + 1);\\n        }\\n        \\n        return path(0, n - 1, n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define pii pair <int, int>\\n#define MAX 100005\\nclass Solution {\\npublic:\\n    vector <int> edge[MAX];\\n    void expand(string s, int low, int high, set <pii> &pid) {\\n        int n = s.size();\\n        while (low >= 0 and high < n and s[low] == s[high]) {\\n            pid.insert(make_pair(low, high));\\n            low--;\\n            high++;\\n        }\\n    }\\n    int path(int src, int dest, int n) {\\n        queue <int> q;\\n        int dist[n + 1];\\n        \\n        for (int i = 0; i <= n; i++) dist[i] = -1;\\n\\n        dist[src] = 0;\\n        q.push(src);\\n        \\n        while(!q.empty()) {\\n            int u = q.front();\\n            q.pop();\\n            \\n            if (u == n) break;\\n            \\n            for (auto v : edge[u]) {\\n                if (dist[v] == -1) {\\n                    dist[v] = dist[u] + 1;\\n                    q.push(v);\\n                }\\n            }\\n        }\\n        \\n        return dist[n] - 1;\\n    }\\n    int minCut(string s) {\\n        set <pii> pid;\\n        int n = s.size(), res = 0;\\n        for (int i = 0; i < n; i++) {\\n            expand(s, i, i, pid);\\n            expand(s, i, i + 1, pid);\\n        }\\n        \\n        for (auto id: pid) {\\n            edge[id.first].push_back(id.second + 1);\\n        }\\n        \\n        return path(0, n - 1, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 713271,
                "title": "python3-dp-top-down-bottom-up",
                "content": "Algo: \\n\\nThe top-down implementation is to be consistent with [131. Palindrome Partitioning ](http://https://leetcode.com/problems/palindrome-partitioning/discuss/713192/Python3-dp-with-pre-processing). Define `fn(i)` as the minimum palindrome partitioning of `s[i:]`. Then, \\n\\n`fn(i) = min(1 + fn(ii+1))` if `s[i:ii+1]` is palindrome. \\n\\n```\\nclass Solution:\\n    def minCut(self, s: str) -> int:\\n        #pre-processing\\n        palin = dict()\\n        for k in range(len(s)):\\n            for i, j in (k, k), (k, k+1):\\n                while 0 <= i and j < len(s) and s[i] == s[j]: \\n                    palin.setdefault(i, []).append(j)\\n                    i, j = i-1, j+1\\n                \\n        #dp \\n        @lru_cache(None)\\n        def fn(i):\\n            \"\"\"Return minimum palindrome partitioning of s[i:]\"\"\"\\n            if i == len(s): return 0\\n            return min(1 + fn(ii+1) for ii in palin[i])\\n        \\n        return fn(0)-1\\n```\\n\\nThe above implementation can be directly translated into below bottom-up implementation which is more concise. \\n```\\nclass Solution:\\n    def minCut(self, s: str) -> int:\\n        ans = [inf]*len(s) + [0] #min palindrome partition for s[i:]\\n        for k in reversed(range(len(s))): \\n            for i, j in (k, k), (k, k+1):\\n                while 0 <= i and j < len(s) and s[i] == s[j]: \\n                    ans[i] = min(ans[i], 1 + ans[j+1])\\n                    i, j = i-1, j+1\\n        return ans[0]-1\\n```\\n\\nIn fact, I feel that this problem is simpler than [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/), even though this is marked Hard and yet that one is marked Medium.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCut(self, s: str) -> int:\\n        #pre-processing\\n        palin = dict()\\n        for k in range(len(s)):\\n            for i, j in (k, k), (k, k+1):\\n                while 0 <= i and j < len(s) and s[i] == s[j]: \\n                    palin.setdefault(i, []).append(j)\\n                    i, j = i-1, j+1\\n                \\n        #dp \\n        @lru_cache(None)\\n        def fn(i):\\n            \"\"\"Return minimum palindrome partitioning of s[i:]\"\"\"\\n            if i == len(s): return 0\\n            return min(1 + fn(ii+1) for ii in palin[i])\\n        \\n        return fn(0)-1\\n```\n```\\nclass Solution:\\n    def minCut(self, s: str) -> int:\\n        ans = [inf]*len(s) + [0] #min palindrome partition for s[i:]\\n        for k in reversed(range(len(s))): \\n            for i, j in (k, k), (k, k+1):\\n                while 0 <= i and j < len(s) and s[i] == s[j]: \\n                    ans[i] = min(ans[i], 1 + ans[j+1])\\n                    i, j = i-1, j+1\\n        return ans[0]-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 711980,
                "title": "partitioning-when-left-part-is-palindromic",
                "content": "i have look at many codes of people here, and found out they are partioning the string only whenever left part is palindromic and searching for the cuts in right part.\\n it seems something like greedy to me,\\n but how is this possible, is i am thinking correctly? \\n i have implemented and test that , and it work perfectly\\n help me with this\\n \\n \\n```\\n dp[i][j]=INT_MAX;\\n    for(int k=i;k<j;k++)\\n    {\\n        if(p[i][k]==false) continue;\\n        dp[i][j]=min(dp[i][j],helper(s,k+1,j)+1); // breaking to make sure left part palindromic \\n\\t\\t}\\n```",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\n dp[i][j]=INT_MAX;\\n    for(int k=i;k<j;k++)\\n    {\\n        if(p[i][k]==false) continue;\\n        dp[i][j]=min(dp[i][j],helper(s,k+1,j)+1); // breaking to make sure left part palindromic \\n\\t\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 654715,
                "title": "how-to-optimize-ispalindrome-in-my-code-below-code-works-optimized-ispalindrome",
                "content": "```\\nclass Solution {\\n    public int minCut(String s) {  \\n    int n = s.length();\\n        int[][] dp = new int[n][n];\\n        for(int[] d : dp){\\n            Arrays.fill(d,-1);\\n        }\\n        return minCut(s, 0, n-1,dp);\\n    }\\n\\n    private int minCut(String s, int i, int j,int[][] dp){\\n        if(i >= j)\\n            return 0;\\n\\n        \\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        if(isPalindrome(s,i,j)){\\n            dp[i][j] = 0;\\n            return 0;\\n        }\\n         int left = 0, right = 0;\\n        int ans = Integer.MAX_VALUE;\\n        for(int k = i;k<=j-1;k++){\\n            if(dp[i][k] != -1){\\n                 left = dp[i][k];\\n            }else {\\n                left = minCut(s,i,k,dp);\\n                dp[i][k] = left;\\n            }\\n            if(dp[k+1][j] != -1){\\n                right = dp[k+1][j];\\n            }else {\\n                right = minCut(s,k+1,j,dp);\\n                dp[k+1][j] = right;\\n            }\\n            int tempAns =1+left+right;\\n            ans = Math.min(ans,tempAns);\\n        }\\n        return dp[i][j] = ans;\\n    }\\n\\n    private boolean isPalindrome(String s, int i, int j){\\n        while(i<=j){\\n            if(s.charAt(i) != s.charAt(j)){\\n\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minCut(String s) {  \\n    int n = s.length();\\n        int[][] dp = new int[n][n];\\n        for(int[] d : dp){\\n            Arrays.fill(d,-1);\\n        }\\n        return minCut(s, 0, n-1,dp);\\n    }\\n\\n    private int minCut(String s, int i, int j,int[][] dp){\\n        if(i >= j)\\n            return 0;\\n\\n        \\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        if(isPalindrome(s,i,j)){\\n            dp[i][j] = 0;\\n            return 0;\\n        }\\n         int left = 0, right = 0;\\n        int ans = Integer.MAX_VALUE;\\n        for(int k = i;k<=j-1;k++){\\n            if(dp[i][k] != -1){\\n                 left = dp[i][k];\\n            }else {\\n                left = minCut(s,i,k,dp);\\n                dp[i][k] = left;\\n            }\\n            if(dp[k+1][j] != -1){\\n                right = dp[k+1][j];\\n            }else {\\n                right = minCut(s,k+1,j,dp);\\n                dp[k+1][j] = right;\\n            }\\n            int tempAns =1+left+right;\\n            ans = Math.min(ans,tempAns);\\n        }\\n        return dp[i][j] = ans;\\n    }\\n\\n    private boolean isPalindrome(String s, int i, int j){\\n        while(i<=j){\\n            if(s.charAt(i) != s.charAt(j)){\\n\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 636761,
                "title": "c-dp-with-explanation-using-palindromic-substring",
                "content": "```\\n/* Calculate and maintain 2 DP states:\\n   pal[i][j] , which is whether s[i..j] forms a palindrome\\n\\n   d[i], which is the minCut for s[i..n-1]\\n\\n   Once we comes to a pal[i][j] == true:\\n\\n   if j==n-1, the string s[i..n-1] is a Palindrome, minCut is 0, d[i]=0;\\n   else: the current cut num ( first cut s[i..j] and then cut the rest\\n   s[j+1...n-1]) is 1 + d[j+1], compare it to the exisiting minCut num\\n   d[i], replace if smaller.\\n   d[0] is the answer.\\n*/\\n\\nint minCut( string s ) {\\n\\tif( s.empty() ) return 0;\\n\\n\\tint n = s.size();\\n\\tvector<vector<bool>> pal( n,vector<bool>(n,false) );\\n\\t// pal[i][j] = true => s[i...j] is palindrome\\n\\tvector<int> dp(n);\\n\\t// d[i] => minCut for s[i..n-1]\\n\\n\\tfor( int i=n-1; i >= 0; i-- ) {\\n\\t\\tdp[i] = n-i-1;\\n\\t\\tfor( int j=i; j < n ; j++ )\\n\\t\\t\\tif( s[i] == s[j] && ( j-i < 3 || pal[i+1][j-1] ) ) {\\n\\t\\t\\t\\tpal[i][j]=true;\\n\\t\\t\\t\\tif( j == n-1 ) dp[i] = 0;\\n\\t\\t\\t\\telse dp[i] = min( dp[i], 1 + dp[j+1] ); \\n\\t\\t\\t}\\n\\t}\\n\\treturn dp[0];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/* Calculate and maintain 2 DP states:\\n   pal[i][j] , which is whether s[i..j] forms a palindrome\\n\\n   d[i], which is the minCut for s[i..n-1]\\n\\n   Once we comes to a pal[i][j] == true:\\n\\n   if j==n-1, the string s[i..n-1] is a Palindrome, minCut is 0, d[i]=0;\\n   else: the current cut num ( first cut s[i..j] and then cut the rest\\n   s[j+1...n-1]) is 1 + d[j+1], compare it to the exisiting minCut num\\n   d[i], replace if smaller.\\n   d[0] is the answer.\\n*/\\n\\nint minCut( string s ) {\\n\\tif( s.empty() ) return 0;\\n\\n\\tint n = s.size();\\n\\tvector<vector<bool>> pal( n,vector<bool>(n,false) );\\n\\t// pal[i][j] = true => s[i...j] is palindrome\\n\\tvector<int> dp(n);\\n\\t// d[i] => minCut for s[i..n-1]\\n\\n\\tfor( int i=n-1; i >= 0; i-- ) {\\n\\t\\tdp[i] = n-i-1;\\n\\t\\tfor( int j=i; j < n ; j++ )\\n\\t\\t\\tif( s[i] == s[j] && ( j-i < 3 || pal[i+1][j-1] ) ) {\\n\\t\\t\\t\\tpal[i][j]=true;\\n\\t\\t\\t\\tif( j == n-1 ) dp[i] = 0;\\n\\t\\t\\t\\telse dp[i] = min( dp[i], 1 + dp[j+1] ); \\n\\t\\t\\t}\\n\\t}\\n\\treturn dp[0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 601608,
                "title": "youtube-solution-video-link",
                "content": "https://www.youtube.com/watch?v=rmNK2awrhkU",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=rmNK2awrhkU",
                "codeTag": "Unknown"
            },
            {
                "id": 591033,
                "title": "java-simple-dfs-memo-solution",
                "content": "```\\nclass Solution {\\n    public boolean isPalindrome(String s, int i, int j) {\\n        while (i < j) {\\n            if (s.charAt(i++) != s.charAt(j--)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    public int minCut(String s) {\\n        if (isPalindrome(s, 0, s.length()-1)) return 0;\\n        return dfs(s, 0);\\n    }\\n    \\n    HashMap<Integer, Integer> memo = new HashMap<>();\\n    public int dfs(String s, int idx) {\\n        if (idx >= s.length() || isPalindrome(s, idx, s.length()-1)) {\\n            return 0;\\n        }\\n        if (memo.containsKey(idx)) {\\n            return memo.get(idx);\\n        }\\n        \\n        int result = Integer.MAX_VALUE;\\n        for (int i = idx+1; i <= s.length(); i++) {\\n            if (i != s.length() && isPalindrome(s, idx, i-1)) {\\n                result = Math.min(result, 1 + dfs(s, i));\\n            }\\n        }\\n        result = (result == Integer.MAX_VALUE)? 0 : result;\\n        memo.put(idx, result);\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPalindrome(String s, int i, int j) {\\n        while (i < j) {\\n            if (s.charAt(i++) != s.charAt(j--)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    public int minCut(String s) {\\n        if (isPalindrome(s, 0, s.length()-1)) return 0;\\n        return dfs(s, 0);\\n    }\\n    \\n    HashMap<Integer, Integer> memo = new HashMap<>();\\n    public int dfs(String s, int idx) {\\n        if (idx >= s.length() || isPalindrome(s, idx, s.length()-1)) {\\n            return 0;\\n        }\\n        if (memo.containsKey(idx)) {\\n            return memo.get(idx);\\n        }\\n        \\n        int result = Integer.MAX_VALUE;\\n        for (int i = idx+1; i <= s.length(); i++) {\\n            if (i != s.length() && isPalindrome(s, idx, i-1)) {\\n                result = Math.min(result, 1 + dfs(s, i));\\n            }\\n        }\\n        result = (result == Integer.MAX_VALUE)? 0 : result;\\n        memo.put(idx, result);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1570538,
                "content": [
                    {
                        "username": "dhnanj",
                        "content": "for the test case s = \"aabaa\" the expected answer by leetcode is 0 as it is a palindrome in whole but, as far as my understanding of the question we need a partitioning which has all its substrings as palindrome and if we don\\'t partition here then the substrings \"aab\" & \"baa\" are not palindromes thus the answer for the above test case should be 2 (aa|b|aa).\\npls correct me if I\\'m wrong.\\nthanks in advance!"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Q says that after cuts , every substring generated should be palindrome, \"aabaa\" => 0 cut then this substring is palindrome itself"
                    },
                    {
                        "username": "Chandrachur",
                        "content": "The original string is also a substring of itself."
                    },
                    {
                        "username": "niketan21",
                        "content": "From what I have understood, \"every substring of the partition\" means that all the those strings which are generated by the partition. So, \"every substring of the partition\" for the partition which you mentioned (aa|b|aa) would be 3 strings \"aa\", \"b\", \"aa\". In this case, the original string is palindrome itself so the answer would be 0. \\n\\nI agree the description of the question is quite confusing, initially I myself got confused just like you."
                    },
                    {
                        "username": "akhilg11",
                        "content": "Gives TLE if you follow striver\\'s code for this question"
                    },
                    {
                        "username": "nerdstv",
                        "content": "[@shadab-malik](/shadab-malik) Thanks man, it worked!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@shadab-malik](/shadab-malik) still TLE"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "pass string by refernce even in palindrome function\\n "
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- TLE on last testcase, 36 / 37 testcases passed\\n- I mean, for real dude?\\n- Test Case 37 : \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab\"\\n- My Code: \\n```\\nclass Solution {\\n    private static boolean isPalindrome(int i, int j, String s){\\n        while(i<=j){\\n            if(s.charAt(i)!=s.charAt(j)) return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n\\n    private static int fun(String s){\\n        int len = s.length();\\n        int[] dp = new int[len+1];\\n        dp[len] = 0;\\n        for(int cut=len-1;cut>=0;cut--){\\n            int minCuts = Integer.MAX_VALUE;\\n            for(int partition=cut;partition<len;partition++){\\n                if(isPalindrome(cut,partition,s)){\\n                    int cuts = 1 + dp[partition+1];\\n                    minCuts = Math.min(minCuts,cuts);\\n                }\\n            }\\n            dp[cut] = minCuts;\\n        }\\n        return dp[0]-1;\\n    }\\n\\n    public int minCut(String s){\\n        return fun(s);\\n    }\\n}\\n// Tabulation Code \\n// Time Complexity : ~ O(n*n), Quadratic Complexity\\n// Space Complexity : O(n)\\n```"
                    },
                    {
                        "username": "aviralagrawal",
                        "content": "Passing string by reference solved the problem in C++"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "[@Adhiraj-MNNIT](/Adhiraj-MNNIT) i got mle on this testcase"
                    },
                    {
                        "username": "f20212091",
                        "content": "This is cubic complexity ig"
                    },
                    {
                        "username": "curryGoat",
                        "content": "string must be refernce"
                    },
                    {
                        "username": "akhilg11",
                        "content": "How did you get over the TLE then?"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "same bro "
                    },
                    {
                        "username": "Kurdush",
                        "content": "here all the test cases  are given with small length there should be atleast one test case with length =5 "
                    },
                    {
                        "username": "Hitesh_9099",
                        "content": "There is mistake in the last testcase the length of the string is 1 to 2000  but the last testcase has empty string so please correct it"
                    },
                    {
                        "username": "sanjanarana101coding",
                        "content": "Hi guys,  solution video to this problem is provided here in the link.\\nSolution Link:-https://youtu.be/qmTtAbOTqcg\\n\\n"
                    },
                    {
                        "username": "bhardwajshubh",
                        "content": "Incase if you get Memory exceed try to give string as refrence in every function."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "how to do it in python there is no such concept of reference\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1. Check whether the given string is a palindrome or not. If it is, return 0 as no cuts are needed.\\n\\n2. Otherwise, use dynamic programming to solve the problem. We will define an array dp such that dp[i] represents the minimum number of cuts needed to partition the substring from index 0 to index i into palindrome substrings.\\n\\n3. To compute dp[i], we need to consider all possible partitions of the substring from index 0 to index i. For each partition, we will check if the first part of the partition is a palindrome or not. If it is, we will add 1 to the minimum number of cuts required to partition the second part of the partition, which can be computed using dp[j] + 1, where j is the index where the second part of the partition starts.\\n\\n4. We will update dp[i] to be the minimum of all the values computed in step3.\\n\\n5. Finally, we will return dp[n-1], where n is the length of the given string."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro this approach might give tle\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "it is not *the* approach, it is an approach. I did something different, so you can go with something else\nAlso, I thought you were not supposed to post solutions in discussion section. What you give here is a lot more than a tip"
                    },
                    {
                        "username": "pallavi1k1",
                        "content": "Easy Java Solution\\nMCM Varaition - Palindrome Partitioning\\n\\nclass Solution {\\n    public int minCut(String s) {\\n        int n = s.length()-1;\\n        int[][] t = new int[n+2][n+2];\\n        \\n        for(int i=0;i<n+2;i++){\\n            for(int j=0;j<n+2;j++)\\n               t[i][j]=-1;\\n        }\\n        return solve(t,s,0,n);\\n    }\\n    int solve(int[][] t,String s, int i, int j){\\n        if(i>=j)\\n            return 0;\\n    \\n        if(isPallindrom(s,i,j) ||i>=j){\\n            // t[i][j]=0;\\n            return 0;\\n        }\\n\\n        if(t[i][j]!=-1)\\n           return t[i][j];\\n\\n        int ans = Integer.MAX_VALUE;\\n        for(int k=i;k<=j-1;k++){\\n            if (isPallindrom(s, i, k))\\n \\t\\t\\t{\\n \\t\\t\\t\\tans = Math.min(ans, 1 + solve(t,s, k + 1, j));\\n \\t\\t\\t}\\n            \\n        }\\n        return t[i][j]=ans;\\n    }\\n\\n     boolean isPallindrom(String s, int i, int j){\\n         if(i==j) return true;\\n         if(i>j) return false;\\n        while( i < j){\\n            if(s.charAt(i) != s.charAt(j) )  return false; \\n            i++; j--;\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Stop posting solution in the discussion section"
                    },
                    {
                        "username": "dvakar",
                        "content": " `\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"`"
                    }
                ]
            },
            {
                "id": 1946701,
                "content": [
                    {
                        "username": "dhnanj",
                        "content": "for the test case s = \"aabaa\" the expected answer by leetcode is 0 as it is a palindrome in whole but, as far as my understanding of the question we need a partitioning which has all its substrings as palindrome and if we don\\'t partition here then the substrings \"aab\" & \"baa\" are not palindromes thus the answer for the above test case should be 2 (aa|b|aa).\\npls correct me if I\\'m wrong.\\nthanks in advance!"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Q says that after cuts , every substring generated should be palindrome, \"aabaa\" => 0 cut then this substring is palindrome itself"
                    },
                    {
                        "username": "Chandrachur",
                        "content": "The original string is also a substring of itself."
                    },
                    {
                        "username": "niketan21",
                        "content": "From what I have understood, \"every substring of the partition\" means that all the those strings which are generated by the partition. So, \"every substring of the partition\" for the partition which you mentioned (aa|b|aa) would be 3 strings \"aa\", \"b\", \"aa\". In this case, the original string is palindrome itself so the answer would be 0. \\n\\nI agree the description of the question is quite confusing, initially I myself got confused just like you."
                    },
                    {
                        "username": "akhilg11",
                        "content": "Gives TLE if you follow striver\\'s code for this question"
                    },
                    {
                        "username": "nerdstv",
                        "content": "[@shadab-malik](/shadab-malik) Thanks man, it worked!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@shadab-malik](/shadab-malik) still TLE"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "pass string by refernce even in palindrome function\\n "
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- TLE on last testcase, 36 / 37 testcases passed\\n- I mean, for real dude?\\n- Test Case 37 : \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab\"\\n- My Code: \\n```\\nclass Solution {\\n    private static boolean isPalindrome(int i, int j, String s){\\n        while(i<=j){\\n            if(s.charAt(i)!=s.charAt(j)) return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n\\n    private static int fun(String s){\\n        int len = s.length();\\n        int[] dp = new int[len+1];\\n        dp[len] = 0;\\n        for(int cut=len-1;cut>=0;cut--){\\n            int minCuts = Integer.MAX_VALUE;\\n            for(int partition=cut;partition<len;partition++){\\n                if(isPalindrome(cut,partition,s)){\\n                    int cuts = 1 + dp[partition+1];\\n                    minCuts = Math.min(minCuts,cuts);\\n                }\\n            }\\n            dp[cut] = minCuts;\\n        }\\n        return dp[0]-1;\\n    }\\n\\n    public int minCut(String s){\\n        return fun(s);\\n    }\\n}\\n// Tabulation Code \\n// Time Complexity : ~ O(n*n), Quadratic Complexity\\n// Space Complexity : O(n)\\n```"
                    },
                    {
                        "username": "aviralagrawal",
                        "content": "Passing string by reference solved the problem in C++"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "[@Adhiraj-MNNIT](/Adhiraj-MNNIT) i got mle on this testcase"
                    },
                    {
                        "username": "f20212091",
                        "content": "This is cubic complexity ig"
                    },
                    {
                        "username": "curryGoat",
                        "content": "string must be refernce"
                    },
                    {
                        "username": "akhilg11",
                        "content": "How did you get over the TLE then?"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "same bro "
                    },
                    {
                        "username": "Kurdush",
                        "content": "here all the test cases  are given with small length there should be atleast one test case with length =5 "
                    },
                    {
                        "username": "Hitesh_9099",
                        "content": "There is mistake in the last testcase the length of the string is 1 to 2000  but the last testcase has empty string so please correct it"
                    },
                    {
                        "username": "sanjanarana101coding",
                        "content": "Hi guys,  solution video to this problem is provided here in the link.\\nSolution Link:-https://youtu.be/qmTtAbOTqcg\\n\\n"
                    },
                    {
                        "username": "bhardwajshubh",
                        "content": "Incase if you get Memory exceed try to give string as refrence in every function."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "how to do it in python there is no such concept of reference\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1. Check whether the given string is a palindrome or not. If it is, return 0 as no cuts are needed.\\n\\n2. Otherwise, use dynamic programming to solve the problem. We will define an array dp such that dp[i] represents the minimum number of cuts needed to partition the substring from index 0 to index i into palindrome substrings.\\n\\n3. To compute dp[i], we need to consider all possible partitions of the substring from index 0 to index i. For each partition, we will check if the first part of the partition is a palindrome or not. If it is, we will add 1 to the minimum number of cuts required to partition the second part of the partition, which can be computed using dp[j] + 1, where j is the index where the second part of the partition starts.\\n\\n4. We will update dp[i] to be the minimum of all the values computed in step3.\\n\\n5. Finally, we will return dp[n-1], where n is the length of the given string."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro this approach might give tle\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "it is not *the* approach, it is an approach. I did something different, so you can go with something else\nAlso, I thought you were not supposed to post solutions in discussion section. What you give here is a lot more than a tip"
                    },
                    {
                        "username": "pallavi1k1",
                        "content": "Easy Java Solution\\nMCM Varaition - Palindrome Partitioning\\n\\nclass Solution {\\n    public int minCut(String s) {\\n        int n = s.length()-1;\\n        int[][] t = new int[n+2][n+2];\\n        \\n        for(int i=0;i<n+2;i++){\\n            for(int j=0;j<n+2;j++)\\n               t[i][j]=-1;\\n        }\\n        return solve(t,s,0,n);\\n    }\\n    int solve(int[][] t,String s, int i, int j){\\n        if(i>=j)\\n            return 0;\\n    \\n        if(isPallindrom(s,i,j) ||i>=j){\\n            // t[i][j]=0;\\n            return 0;\\n        }\\n\\n        if(t[i][j]!=-1)\\n           return t[i][j];\\n\\n        int ans = Integer.MAX_VALUE;\\n        for(int k=i;k<=j-1;k++){\\n            if (isPallindrom(s, i, k))\\n \\t\\t\\t{\\n \\t\\t\\t\\tans = Math.min(ans, 1 + solve(t,s, k + 1, j));\\n \\t\\t\\t}\\n            \\n        }\\n        return t[i][j]=ans;\\n    }\\n\\n     boolean isPallindrom(String s, int i, int j){\\n         if(i==j) return true;\\n         if(i>j) return false;\\n        while( i < j){\\n            if(s.charAt(i) != s.charAt(j) )  return false; \\n            i++; j--;\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Stop posting solution in the discussion section"
                    },
                    {
                        "username": "dvakar",
                        "content": " `\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"`"
                    }
                ]
            },
            {
                "id": 1926566,
                "content": [
                    {
                        "username": "dhnanj",
                        "content": "for the test case s = \"aabaa\" the expected answer by leetcode is 0 as it is a palindrome in whole but, as far as my understanding of the question we need a partitioning which has all its substrings as palindrome and if we don\\'t partition here then the substrings \"aab\" & \"baa\" are not palindromes thus the answer for the above test case should be 2 (aa|b|aa).\\npls correct me if I\\'m wrong.\\nthanks in advance!"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Q says that after cuts , every substring generated should be palindrome, \"aabaa\" => 0 cut then this substring is palindrome itself"
                    },
                    {
                        "username": "Chandrachur",
                        "content": "The original string is also a substring of itself."
                    },
                    {
                        "username": "niketan21",
                        "content": "From what I have understood, \"every substring of the partition\" means that all the those strings which are generated by the partition. So, \"every substring of the partition\" for the partition which you mentioned (aa|b|aa) would be 3 strings \"aa\", \"b\", \"aa\". In this case, the original string is palindrome itself so the answer would be 0. \\n\\nI agree the description of the question is quite confusing, initially I myself got confused just like you."
                    },
                    {
                        "username": "akhilg11",
                        "content": "Gives TLE if you follow striver\\'s code for this question"
                    },
                    {
                        "username": "nerdstv",
                        "content": "[@shadab-malik](/shadab-malik) Thanks man, it worked!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@shadab-malik](/shadab-malik) still TLE"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "pass string by refernce even in palindrome function\\n "
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- TLE on last testcase, 36 / 37 testcases passed\\n- I mean, for real dude?\\n- Test Case 37 : \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab\"\\n- My Code: \\n```\\nclass Solution {\\n    private static boolean isPalindrome(int i, int j, String s){\\n        while(i<=j){\\n            if(s.charAt(i)!=s.charAt(j)) return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n\\n    private static int fun(String s){\\n        int len = s.length();\\n        int[] dp = new int[len+1];\\n        dp[len] = 0;\\n        for(int cut=len-1;cut>=0;cut--){\\n            int minCuts = Integer.MAX_VALUE;\\n            for(int partition=cut;partition<len;partition++){\\n                if(isPalindrome(cut,partition,s)){\\n                    int cuts = 1 + dp[partition+1];\\n                    minCuts = Math.min(minCuts,cuts);\\n                }\\n            }\\n            dp[cut] = minCuts;\\n        }\\n        return dp[0]-1;\\n    }\\n\\n    public int minCut(String s){\\n        return fun(s);\\n    }\\n}\\n// Tabulation Code \\n// Time Complexity : ~ O(n*n), Quadratic Complexity\\n// Space Complexity : O(n)\\n```"
                    },
                    {
                        "username": "aviralagrawal",
                        "content": "Passing string by reference solved the problem in C++"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "[@Adhiraj-MNNIT](/Adhiraj-MNNIT) i got mle on this testcase"
                    },
                    {
                        "username": "f20212091",
                        "content": "This is cubic complexity ig"
                    },
                    {
                        "username": "curryGoat",
                        "content": "string must be refernce"
                    },
                    {
                        "username": "akhilg11",
                        "content": "How did you get over the TLE then?"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "same bro "
                    },
                    {
                        "username": "Kurdush",
                        "content": "here all the test cases  are given with small length there should be atleast one test case with length =5 "
                    },
                    {
                        "username": "Hitesh_9099",
                        "content": "There is mistake in the last testcase the length of the string is 1 to 2000  but the last testcase has empty string so please correct it"
                    },
                    {
                        "username": "sanjanarana101coding",
                        "content": "Hi guys,  solution video to this problem is provided here in the link.\\nSolution Link:-https://youtu.be/qmTtAbOTqcg\\n\\n"
                    },
                    {
                        "username": "bhardwajshubh",
                        "content": "Incase if you get Memory exceed try to give string as refrence in every function."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "how to do it in python there is no such concept of reference\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1. Check whether the given string is a palindrome or not. If it is, return 0 as no cuts are needed.\\n\\n2. Otherwise, use dynamic programming to solve the problem. We will define an array dp such that dp[i] represents the minimum number of cuts needed to partition the substring from index 0 to index i into palindrome substrings.\\n\\n3. To compute dp[i], we need to consider all possible partitions of the substring from index 0 to index i. For each partition, we will check if the first part of the partition is a palindrome or not. If it is, we will add 1 to the minimum number of cuts required to partition the second part of the partition, which can be computed using dp[j] + 1, where j is the index where the second part of the partition starts.\\n\\n4. We will update dp[i] to be the minimum of all the values computed in step3.\\n\\n5. Finally, we will return dp[n-1], where n is the length of the given string."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro this approach might give tle\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "it is not *the* approach, it is an approach. I did something different, so you can go with something else\nAlso, I thought you were not supposed to post solutions in discussion section. What you give here is a lot more than a tip"
                    },
                    {
                        "username": "pallavi1k1",
                        "content": "Easy Java Solution\\nMCM Varaition - Palindrome Partitioning\\n\\nclass Solution {\\n    public int minCut(String s) {\\n        int n = s.length()-1;\\n        int[][] t = new int[n+2][n+2];\\n        \\n        for(int i=0;i<n+2;i++){\\n            for(int j=0;j<n+2;j++)\\n               t[i][j]=-1;\\n        }\\n        return solve(t,s,0,n);\\n    }\\n    int solve(int[][] t,String s, int i, int j){\\n        if(i>=j)\\n            return 0;\\n    \\n        if(isPallindrom(s,i,j) ||i>=j){\\n            // t[i][j]=0;\\n            return 0;\\n        }\\n\\n        if(t[i][j]!=-1)\\n           return t[i][j];\\n\\n        int ans = Integer.MAX_VALUE;\\n        for(int k=i;k<=j-1;k++){\\n            if (isPallindrom(s, i, k))\\n \\t\\t\\t{\\n \\t\\t\\t\\tans = Math.min(ans, 1 + solve(t,s, k + 1, j));\\n \\t\\t\\t}\\n            \\n        }\\n        return t[i][j]=ans;\\n    }\\n\\n     boolean isPallindrom(String s, int i, int j){\\n         if(i==j) return true;\\n         if(i>j) return false;\\n        while( i < j){\\n            if(s.charAt(i) != s.charAt(j) )  return false; \\n            i++; j--;\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Stop posting solution in the discussion section"
                    },
                    {
                        "username": "dvakar",
                        "content": " `\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"`"
                    }
                ]
            },
            {
                "id": 1713274,
                "content": [
                    {
                        "username": "dhnanj",
                        "content": "for the test case s = \"aabaa\" the expected answer by leetcode is 0 as it is a palindrome in whole but, as far as my understanding of the question we need a partitioning which has all its substrings as palindrome and if we don\\'t partition here then the substrings \"aab\" & \"baa\" are not palindromes thus the answer for the above test case should be 2 (aa|b|aa).\\npls correct me if I\\'m wrong.\\nthanks in advance!"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Q says that after cuts , every substring generated should be palindrome, \"aabaa\" => 0 cut then this substring is palindrome itself"
                    },
                    {
                        "username": "Chandrachur",
                        "content": "The original string is also a substring of itself."
                    },
                    {
                        "username": "niketan21",
                        "content": "From what I have understood, \"every substring of the partition\" means that all the those strings which are generated by the partition. So, \"every substring of the partition\" for the partition which you mentioned (aa|b|aa) would be 3 strings \"aa\", \"b\", \"aa\". In this case, the original string is palindrome itself so the answer would be 0. \\n\\nI agree the description of the question is quite confusing, initially I myself got confused just like you."
                    },
                    {
                        "username": "akhilg11",
                        "content": "Gives TLE if you follow striver\\'s code for this question"
                    },
                    {
                        "username": "nerdstv",
                        "content": "[@shadab-malik](/shadab-malik) Thanks man, it worked!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@shadab-malik](/shadab-malik) still TLE"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "pass string by refernce even in palindrome function\\n "
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- TLE on last testcase, 36 / 37 testcases passed\\n- I mean, for real dude?\\n- Test Case 37 : \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab\"\\n- My Code: \\n```\\nclass Solution {\\n    private static boolean isPalindrome(int i, int j, String s){\\n        while(i<=j){\\n            if(s.charAt(i)!=s.charAt(j)) return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n\\n    private static int fun(String s){\\n        int len = s.length();\\n        int[] dp = new int[len+1];\\n        dp[len] = 0;\\n        for(int cut=len-1;cut>=0;cut--){\\n            int minCuts = Integer.MAX_VALUE;\\n            for(int partition=cut;partition<len;partition++){\\n                if(isPalindrome(cut,partition,s)){\\n                    int cuts = 1 + dp[partition+1];\\n                    minCuts = Math.min(minCuts,cuts);\\n                }\\n            }\\n            dp[cut] = minCuts;\\n        }\\n        return dp[0]-1;\\n    }\\n\\n    public int minCut(String s){\\n        return fun(s);\\n    }\\n}\\n// Tabulation Code \\n// Time Complexity : ~ O(n*n), Quadratic Complexity\\n// Space Complexity : O(n)\\n```"
                    },
                    {
                        "username": "aviralagrawal",
                        "content": "Passing string by reference solved the problem in C++"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "[@Adhiraj-MNNIT](/Adhiraj-MNNIT) i got mle on this testcase"
                    },
                    {
                        "username": "f20212091",
                        "content": "This is cubic complexity ig"
                    },
                    {
                        "username": "curryGoat",
                        "content": "string must be refernce"
                    },
                    {
                        "username": "akhilg11",
                        "content": "How did you get over the TLE then?"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "same bro "
                    },
                    {
                        "username": "Kurdush",
                        "content": "here all the test cases  are given with small length there should be atleast one test case with length =5 "
                    },
                    {
                        "username": "Hitesh_9099",
                        "content": "There is mistake in the last testcase the length of the string is 1 to 2000  but the last testcase has empty string so please correct it"
                    },
                    {
                        "username": "sanjanarana101coding",
                        "content": "Hi guys,  solution video to this problem is provided here in the link.\\nSolution Link:-https://youtu.be/qmTtAbOTqcg\\n\\n"
                    },
                    {
                        "username": "bhardwajshubh",
                        "content": "Incase if you get Memory exceed try to give string as refrence in every function."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "how to do it in python there is no such concept of reference\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1. Check whether the given string is a palindrome or not. If it is, return 0 as no cuts are needed.\\n\\n2. Otherwise, use dynamic programming to solve the problem. We will define an array dp such that dp[i] represents the minimum number of cuts needed to partition the substring from index 0 to index i into palindrome substrings.\\n\\n3. To compute dp[i], we need to consider all possible partitions of the substring from index 0 to index i. For each partition, we will check if the first part of the partition is a palindrome or not. If it is, we will add 1 to the minimum number of cuts required to partition the second part of the partition, which can be computed using dp[j] + 1, where j is the index where the second part of the partition starts.\\n\\n4. We will update dp[i] to be the minimum of all the values computed in step3.\\n\\n5. Finally, we will return dp[n-1], where n is the length of the given string."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro this approach might give tle\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "it is not *the* approach, it is an approach. I did something different, so you can go with something else\nAlso, I thought you were not supposed to post solutions in discussion section. What you give here is a lot more than a tip"
                    },
                    {
                        "username": "pallavi1k1",
                        "content": "Easy Java Solution\\nMCM Varaition - Palindrome Partitioning\\n\\nclass Solution {\\n    public int minCut(String s) {\\n        int n = s.length()-1;\\n        int[][] t = new int[n+2][n+2];\\n        \\n        for(int i=0;i<n+2;i++){\\n            for(int j=0;j<n+2;j++)\\n               t[i][j]=-1;\\n        }\\n        return solve(t,s,0,n);\\n    }\\n    int solve(int[][] t,String s, int i, int j){\\n        if(i>=j)\\n            return 0;\\n    \\n        if(isPallindrom(s,i,j) ||i>=j){\\n            // t[i][j]=0;\\n            return 0;\\n        }\\n\\n        if(t[i][j]!=-1)\\n           return t[i][j];\\n\\n        int ans = Integer.MAX_VALUE;\\n        for(int k=i;k<=j-1;k++){\\n            if (isPallindrom(s, i, k))\\n \\t\\t\\t{\\n \\t\\t\\t\\tans = Math.min(ans, 1 + solve(t,s, k + 1, j));\\n \\t\\t\\t}\\n            \\n        }\\n        return t[i][j]=ans;\\n    }\\n\\n     boolean isPallindrom(String s, int i, int j){\\n         if(i==j) return true;\\n         if(i>j) return false;\\n        while( i < j){\\n            if(s.charAt(i) != s.charAt(j) )  return false; \\n            i++; j--;\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Stop posting solution in the discussion section"
                    },
                    {
                        "username": "dvakar",
                        "content": " `\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"`"
                    }
                ]
            },
            {
                "id": 1982248,
                "content": [
                    {
                        "username": "dhnanj",
                        "content": "for the test case s = \"aabaa\" the expected answer by leetcode is 0 as it is a palindrome in whole but, as far as my understanding of the question we need a partitioning which has all its substrings as palindrome and if we don\\'t partition here then the substrings \"aab\" & \"baa\" are not palindromes thus the answer for the above test case should be 2 (aa|b|aa).\\npls correct me if I\\'m wrong.\\nthanks in advance!"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Q says that after cuts , every substring generated should be palindrome, \"aabaa\" => 0 cut then this substring is palindrome itself"
                    },
                    {
                        "username": "Chandrachur",
                        "content": "The original string is also a substring of itself."
                    },
                    {
                        "username": "niketan21",
                        "content": "From what I have understood, \"every substring of the partition\" means that all the those strings which are generated by the partition. So, \"every substring of the partition\" for the partition which you mentioned (aa|b|aa) would be 3 strings \"aa\", \"b\", \"aa\". In this case, the original string is palindrome itself so the answer would be 0. \\n\\nI agree the description of the question is quite confusing, initially I myself got confused just like you."
                    },
                    {
                        "username": "akhilg11",
                        "content": "Gives TLE if you follow striver\\'s code for this question"
                    },
                    {
                        "username": "nerdstv",
                        "content": "[@shadab-malik](/shadab-malik) Thanks man, it worked!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@shadab-malik](/shadab-malik) still TLE"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "pass string by refernce even in palindrome function\\n "
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- TLE on last testcase, 36 / 37 testcases passed\\n- I mean, for real dude?\\n- Test Case 37 : \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab\"\\n- My Code: \\n```\\nclass Solution {\\n    private static boolean isPalindrome(int i, int j, String s){\\n        while(i<=j){\\n            if(s.charAt(i)!=s.charAt(j)) return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n\\n    private static int fun(String s){\\n        int len = s.length();\\n        int[] dp = new int[len+1];\\n        dp[len] = 0;\\n        for(int cut=len-1;cut>=0;cut--){\\n            int minCuts = Integer.MAX_VALUE;\\n            for(int partition=cut;partition<len;partition++){\\n                if(isPalindrome(cut,partition,s)){\\n                    int cuts = 1 + dp[partition+1];\\n                    minCuts = Math.min(minCuts,cuts);\\n                }\\n            }\\n            dp[cut] = minCuts;\\n        }\\n        return dp[0]-1;\\n    }\\n\\n    public int minCut(String s){\\n        return fun(s);\\n    }\\n}\\n// Tabulation Code \\n// Time Complexity : ~ O(n*n), Quadratic Complexity\\n// Space Complexity : O(n)\\n```"
                    },
                    {
                        "username": "aviralagrawal",
                        "content": "Passing string by reference solved the problem in C++"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "[@Adhiraj-MNNIT](/Adhiraj-MNNIT) i got mle on this testcase"
                    },
                    {
                        "username": "f20212091",
                        "content": "This is cubic complexity ig"
                    },
                    {
                        "username": "curryGoat",
                        "content": "string must be refernce"
                    },
                    {
                        "username": "akhilg11",
                        "content": "How did you get over the TLE then?"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "same bro "
                    },
                    {
                        "username": "Kurdush",
                        "content": "here all the test cases  are given with small length there should be atleast one test case with length =5 "
                    },
                    {
                        "username": "Hitesh_9099",
                        "content": "There is mistake in the last testcase the length of the string is 1 to 2000  but the last testcase has empty string so please correct it"
                    },
                    {
                        "username": "sanjanarana101coding",
                        "content": "Hi guys,  solution video to this problem is provided here in the link.\\nSolution Link:-https://youtu.be/qmTtAbOTqcg\\n\\n"
                    },
                    {
                        "username": "bhardwajshubh",
                        "content": "Incase if you get Memory exceed try to give string as refrence in every function."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "how to do it in python there is no such concept of reference\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1. Check whether the given string is a palindrome or not. If it is, return 0 as no cuts are needed.\\n\\n2. Otherwise, use dynamic programming to solve the problem. We will define an array dp such that dp[i] represents the minimum number of cuts needed to partition the substring from index 0 to index i into palindrome substrings.\\n\\n3. To compute dp[i], we need to consider all possible partitions of the substring from index 0 to index i. For each partition, we will check if the first part of the partition is a palindrome or not. If it is, we will add 1 to the minimum number of cuts required to partition the second part of the partition, which can be computed using dp[j] + 1, where j is the index where the second part of the partition starts.\\n\\n4. We will update dp[i] to be the minimum of all the values computed in step3.\\n\\n5. Finally, we will return dp[n-1], where n is the length of the given string."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro this approach might give tle\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "it is not *the* approach, it is an approach. I did something different, so you can go with something else\nAlso, I thought you were not supposed to post solutions in discussion section. What you give here is a lot more than a tip"
                    },
                    {
                        "username": "pallavi1k1",
                        "content": "Easy Java Solution\\nMCM Varaition - Palindrome Partitioning\\n\\nclass Solution {\\n    public int minCut(String s) {\\n        int n = s.length()-1;\\n        int[][] t = new int[n+2][n+2];\\n        \\n        for(int i=0;i<n+2;i++){\\n            for(int j=0;j<n+2;j++)\\n               t[i][j]=-1;\\n        }\\n        return solve(t,s,0,n);\\n    }\\n    int solve(int[][] t,String s, int i, int j){\\n        if(i>=j)\\n            return 0;\\n    \\n        if(isPallindrom(s,i,j) ||i>=j){\\n            // t[i][j]=0;\\n            return 0;\\n        }\\n\\n        if(t[i][j]!=-1)\\n           return t[i][j];\\n\\n        int ans = Integer.MAX_VALUE;\\n        for(int k=i;k<=j-1;k++){\\n            if (isPallindrom(s, i, k))\\n \\t\\t\\t{\\n \\t\\t\\t\\tans = Math.min(ans, 1 + solve(t,s, k + 1, j));\\n \\t\\t\\t}\\n            \\n        }\\n        return t[i][j]=ans;\\n    }\\n\\n     boolean isPallindrom(String s, int i, int j){\\n         if(i==j) return true;\\n         if(i>j) return false;\\n        while( i < j){\\n            if(s.charAt(i) != s.charAt(j) )  return false; \\n            i++; j--;\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Stop posting solution in the discussion section"
                    },
                    {
                        "username": "dvakar",
                        "content": " `\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"`"
                    }
                ]
            },
            {
                "id": 1574419,
                "content": [
                    {
                        "username": "dhnanj",
                        "content": "for the test case s = \"aabaa\" the expected answer by leetcode is 0 as it is a palindrome in whole but, as far as my understanding of the question we need a partitioning which has all its substrings as palindrome and if we don\\'t partition here then the substrings \"aab\" & \"baa\" are not palindromes thus the answer for the above test case should be 2 (aa|b|aa).\\npls correct me if I\\'m wrong.\\nthanks in advance!"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Q says that after cuts , every substring generated should be palindrome, \"aabaa\" => 0 cut then this substring is palindrome itself"
                    },
                    {
                        "username": "Chandrachur",
                        "content": "The original string is also a substring of itself."
                    },
                    {
                        "username": "niketan21",
                        "content": "From what I have understood, \"every substring of the partition\" means that all the those strings which are generated by the partition. So, \"every substring of the partition\" for the partition which you mentioned (aa|b|aa) would be 3 strings \"aa\", \"b\", \"aa\". In this case, the original string is palindrome itself so the answer would be 0. \\n\\nI agree the description of the question is quite confusing, initially I myself got confused just like you."
                    },
                    {
                        "username": "akhilg11",
                        "content": "Gives TLE if you follow striver\\'s code for this question"
                    },
                    {
                        "username": "nerdstv",
                        "content": "[@shadab-malik](/shadab-malik) Thanks man, it worked!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@shadab-malik](/shadab-malik) still TLE"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "pass string by refernce even in palindrome function\\n "
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- TLE on last testcase, 36 / 37 testcases passed\\n- I mean, for real dude?\\n- Test Case 37 : \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab\"\\n- My Code: \\n```\\nclass Solution {\\n    private static boolean isPalindrome(int i, int j, String s){\\n        while(i<=j){\\n            if(s.charAt(i)!=s.charAt(j)) return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n\\n    private static int fun(String s){\\n        int len = s.length();\\n        int[] dp = new int[len+1];\\n        dp[len] = 0;\\n        for(int cut=len-1;cut>=0;cut--){\\n            int minCuts = Integer.MAX_VALUE;\\n            for(int partition=cut;partition<len;partition++){\\n                if(isPalindrome(cut,partition,s)){\\n                    int cuts = 1 + dp[partition+1];\\n                    minCuts = Math.min(minCuts,cuts);\\n                }\\n            }\\n            dp[cut] = minCuts;\\n        }\\n        return dp[0]-1;\\n    }\\n\\n    public int minCut(String s){\\n        return fun(s);\\n    }\\n}\\n// Tabulation Code \\n// Time Complexity : ~ O(n*n), Quadratic Complexity\\n// Space Complexity : O(n)\\n```"
                    },
                    {
                        "username": "aviralagrawal",
                        "content": "Passing string by reference solved the problem in C++"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "[@Adhiraj-MNNIT](/Adhiraj-MNNIT) i got mle on this testcase"
                    },
                    {
                        "username": "f20212091",
                        "content": "This is cubic complexity ig"
                    },
                    {
                        "username": "curryGoat",
                        "content": "string must be refernce"
                    },
                    {
                        "username": "akhilg11",
                        "content": "How did you get over the TLE then?"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "same bro "
                    },
                    {
                        "username": "Kurdush",
                        "content": "here all the test cases  are given with small length there should be atleast one test case with length =5 "
                    },
                    {
                        "username": "Hitesh_9099",
                        "content": "There is mistake in the last testcase the length of the string is 1 to 2000  but the last testcase has empty string so please correct it"
                    },
                    {
                        "username": "sanjanarana101coding",
                        "content": "Hi guys,  solution video to this problem is provided here in the link.\\nSolution Link:-https://youtu.be/qmTtAbOTqcg\\n\\n"
                    },
                    {
                        "username": "bhardwajshubh",
                        "content": "Incase if you get Memory exceed try to give string as refrence in every function."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "how to do it in python there is no such concept of reference\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1. Check whether the given string is a palindrome or not. If it is, return 0 as no cuts are needed.\\n\\n2. Otherwise, use dynamic programming to solve the problem. We will define an array dp such that dp[i] represents the minimum number of cuts needed to partition the substring from index 0 to index i into palindrome substrings.\\n\\n3. To compute dp[i], we need to consider all possible partitions of the substring from index 0 to index i. For each partition, we will check if the first part of the partition is a palindrome or not. If it is, we will add 1 to the minimum number of cuts required to partition the second part of the partition, which can be computed using dp[j] + 1, where j is the index where the second part of the partition starts.\\n\\n4. We will update dp[i] to be the minimum of all the values computed in step3.\\n\\n5. Finally, we will return dp[n-1], where n is the length of the given string."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro this approach might give tle\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "it is not *the* approach, it is an approach. I did something different, so you can go with something else\nAlso, I thought you were not supposed to post solutions in discussion section. What you give here is a lot more than a tip"
                    },
                    {
                        "username": "pallavi1k1",
                        "content": "Easy Java Solution\\nMCM Varaition - Palindrome Partitioning\\n\\nclass Solution {\\n    public int minCut(String s) {\\n        int n = s.length()-1;\\n        int[][] t = new int[n+2][n+2];\\n        \\n        for(int i=0;i<n+2;i++){\\n            for(int j=0;j<n+2;j++)\\n               t[i][j]=-1;\\n        }\\n        return solve(t,s,0,n);\\n    }\\n    int solve(int[][] t,String s, int i, int j){\\n        if(i>=j)\\n            return 0;\\n    \\n        if(isPallindrom(s,i,j) ||i>=j){\\n            // t[i][j]=0;\\n            return 0;\\n        }\\n\\n        if(t[i][j]!=-1)\\n           return t[i][j];\\n\\n        int ans = Integer.MAX_VALUE;\\n        for(int k=i;k<=j-1;k++){\\n            if (isPallindrom(s, i, k))\\n \\t\\t\\t{\\n \\t\\t\\t\\tans = Math.min(ans, 1 + solve(t,s, k + 1, j));\\n \\t\\t\\t}\\n            \\n        }\\n        return t[i][j]=ans;\\n    }\\n\\n     boolean isPallindrom(String s, int i, int j){\\n         if(i==j) return true;\\n         if(i>j) return false;\\n        while( i < j){\\n            if(s.charAt(i) != s.charAt(j) )  return false; \\n            i++; j--;\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Stop posting solution in the discussion section"
                    },
                    {
                        "username": "dvakar",
                        "content": " `\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"`"
                    }
                ]
            },
            {
                "id": 2024514,
                "content": [
                    {
                        "username": "dhnanj",
                        "content": "for the test case s = \"aabaa\" the expected answer by leetcode is 0 as it is a palindrome in whole but, as far as my understanding of the question we need a partitioning which has all its substrings as palindrome and if we don\\'t partition here then the substrings \"aab\" & \"baa\" are not palindromes thus the answer for the above test case should be 2 (aa|b|aa).\\npls correct me if I\\'m wrong.\\nthanks in advance!"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Q says that after cuts , every substring generated should be palindrome, \"aabaa\" => 0 cut then this substring is palindrome itself"
                    },
                    {
                        "username": "Chandrachur",
                        "content": "The original string is also a substring of itself."
                    },
                    {
                        "username": "niketan21",
                        "content": "From what I have understood, \"every substring of the partition\" means that all the those strings which are generated by the partition. So, \"every substring of the partition\" for the partition which you mentioned (aa|b|aa) would be 3 strings \"aa\", \"b\", \"aa\". In this case, the original string is palindrome itself so the answer would be 0. \\n\\nI agree the description of the question is quite confusing, initially I myself got confused just like you."
                    },
                    {
                        "username": "akhilg11",
                        "content": "Gives TLE if you follow striver\\'s code for this question"
                    },
                    {
                        "username": "nerdstv",
                        "content": "[@shadab-malik](/shadab-malik) Thanks man, it worked!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@shadab-malik](/shadab-malik) still TLE"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "pass string by refernce even in palindrome function\\n "
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- TLE on last testcase, 36 / 37 testcases passed\\n- I mean, for real dude?\\n- Test Case 37 : \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab\"\\n- My Code: \\n```\\nclass Solution {\\n    private static boolean isPalindrome(int i, int j, String s){\\n        while(i<=j){\\n            if(s.charAt(i)!=s.charAt(j)) return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n\\n    private static int fun(String s){\\n        int len = s.length();\\n        int[] dp = new int[len+1];\\n        dp[len] = 0;\\n        for(int cut=len-1;cut>=0;cut--){\\n            int minCuts = Integer.MAX_VALUE;\\n            for(int partition=cut;partition<len;partition++){\\n                if(isPalindrome(cut,partition,s)){\\n                    int cuts = 1 + dp[partition+1];\\n                    minCuts = Math.min(minCuts,cuts);\\n                }\\n            }\\n            dp[cut] = minCuts;\\n        }\\n        return dp[0]-1;\\n    }\\n\\n    public int minCut(String s){\\n        return fun(s);\\n    }\\n}\\n// Tabulation Code \\n// Time Complexity : ~ O(n*n), Quadratic Complexity\\n// Space Complexity : O(n)\\n```"
                    },
                    {
                        "username": "aviralagrawal",
                        "content": "Passing string by reference solved the problem in C++"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "[@Adhiraj-MNNIT](/Adhiraj-MNNIT) i got mle on this testcase"
                    },
                    {
                        "username": "f20212091",
                        "content": "This is cubic complexity ig"
                    },
                    {
                        "username": "curryGoat",
                        "content": "string must be refernce"
                    },
                    {
                        "username": "akhilg11",
                        "content": "How did you get over the TLE then?"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "same bro "
                    },
                    {
                        "username": "Kurdush",
                        "content": "here all the test cases  are given with small length there should be atleast one test case with length =5 "
                    },
                    {
                        "username": "Hitesh_9099",
                        "content": "There is mistake in the last testcase the length of the string is 1 to 2000  but the last testcase has empty string so please correct it"
                    },
                    {
                        "username": "sanjanarana101coding",
                        "content": "Hi guys,  solution video to this problem is provided here in the link.\\nSolution Link:-https://youtu.be/qmTtAbOTqcg\\n\\n"
                    },
                    {
                        "username": "bhardwajshubh",
                        "content": "Incase if you get Memory exceed try to give string as refrence in every function."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "how to do it in python there is no such concept of reference\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1. Check whether the given string is a palindrome or not. If it is, return 0 as no cuts are needed.\\n\\n2. Otherwise, use dynamic programming to solve the problem. We will define an array dp such that dp[i] represents the minimum number of cuts needed to partition the substring from index 0 to index i into palindrome substrings.\\n\\n3. To compute dp[i], we need to consider all possible partitions of the substring from index 0 to index i. For each partition, we will check if the first part of the partition is a palindrome or not. If it is, we will add 1 to the minimum number of cuts required to partition the second part of the partition, which can be computed using dp[j] + 1, where j is the index where the second part of the partition starts.\\n\\n4. We will update dp[i] to be the minimum of all the values computed in step3.\\n\\n5. Finally, we will return dp[n-1], where n is the length of the given string."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro this approach might give tle\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "it is not *the* approach, it is an approach. I did something different, so you can go with something else\nAlso, I thought you were not supposed to post solutions in discussion section. What you give here is a lot more than a tip"
                    },
                    {
                        "username": "pallavi1k1",
                        "content": "Easy Java Solution\\nMCM Varaition - Palindrome Partitioning\\n\\nclass Solution {\\n    public int minCut(String s) {\\n        int n = s.length()-1;\\n        int[][] t = new int[n+2][n+2];\\n        \\n        for(int i=0;i<n+2;i++){\\n            for(int j=0;j<n+2;j++)\\n               t[i][j]=-1;\\n        }\\n        return solve(t,s,0,n);\\n    }\\n    int solve(int[][] t,String s, int i, int j){\\n        if(i>=j)\\n            return 0;\\n    \\n        if(isPallindrom(s,i,j) ||i>=j){\\n            // t[i][j]=0;\\n            return 0;\\n        }\\n\\n        if(t[i][j]!=-1)\\n           return t[i][j];\\n\\n        int ans = Integer.MAX_VALUE;\\n        for(int k=i;k<=j-1;k++){\\n            if (isPallindrom(s, i, k))\\n \\t\\t\\t{\\n \\t\\t\\t\\tans = Math.min(ans, 1 + solve(t,s, k + 1, j));\\n \\t\\t\\t}\\n            \\n        }\\n        return t[i][j]=ans;\\n    }\\n\\n     boolean isPallindrom(String s, int i, int j){\\n         if(i==j) return true;\\n         if(i>j) return false;\\n        while( i < j){\\n            if(s.charAt(i) != s.charAt(j) )  return false; \\n            i++; j--;\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Stop posting solution in the discussion section"
                    },
                    {
                        "username": "dvakar",
                        "content": " `\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"`"
                    }
                ]
            },
            {
                "id": 1831408,
                "content": [
                    {
                        "username": "dhnanj",
                        "content": "for the test case s = \"aabaa\" the expected answer by leetcode is 0 as it is a palindrome in whole but, as far as my understanding of the question we need a partitioning which has all its substrings as palindrome and if we don\\'t partition here then the substrings \"aab\" & \"baa\" are not palindromes thus the answer for the above test case should be 2 (aa|b|aa).\\npls correct me if I\\'m wrong.\\nthanks in advance!"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Q says that after cuts , every substring generated should be palindrome, \"aabaa\" => 0 cut then this substring is palindrome itself"
                    },
                    {
                        "username": "Chandrachur",
                        "content": "The original string is also a substring of itself."
                    },
                    {
                        "username": "niketan21",
                        "content": "From what I have understood, \"every substring of the partition\" means that all the those strings which are generated by the partition. So, \"every substring of the partition\" for the partition which you mentioned (aa|b|aa) would be 3 strings \"aa\", \"b\", \"aa\". In this case, the original string is palindrome itself so the answer would be 0. \\n\\nI agree the description of the question is quite confusing, initially I myself got confused just like you."
                    },
                    {
                        "username": "akhilg11",
                        "content": "Gives TLE if you follow striver\\'s code for this question"
                    },
                    {
                        "username": "nerdstv",
                        "content": "[@shadab-malik](/shadab-malik) Thanks man, it worked!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@shadab-malik](/shadab-malik) still TLE"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "pass string by refernce even in palindrome function\\n "
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- TLE on last testcase, 36 / 37 testcases passed\\n- I mean, for real dude?\\n- Test Case 37 : \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab\"\\n- My Code: \\n```\\nclass Solution {\\n    private static boolean isPalindrome(int i, int j, String s){\\n        while(i<=j){\\n            if(s.charAt(i)!=s.charAt(j)) return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n\\n    private static int fun(String s){\\n        int len = s.length();\\n        int[] dp = new int[len+1];\\n        dp[len] = 0;\\n        for(int cut=len-1;cut>=0;cut--){\\n            int minCuts = Integer.MAX_VALUE;\\n            for(int partition=cut;partition<len;partition++){\\n                if(isPalindrome(cut,partition,s)){\\n                    int cuts = 1 + dp[partition+1];\\n                    minCuts = Math.min(minCuts,cuts);\\n                }\\n            }\\n            dp[cut] = minCuts;\\n        }\\n        return dp[0]-1;\\n    }\\n\\n    public int minCut(String s){\\n        return fun(s);\\n    }\\n}\\n// Tabulation Code \\n// Time Complexity : ~ O(n*n), Quadratic Complexity\\n// Space Complexity : O(n)\\n```"
                    },
                    {
                        "username": "aviralagrawal",
                        "content": "Passing string by reference solved the problem in C++"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "[@Adhiraj-MNNIT](/Adhiraj-MNNIT) i got mle on this testcase"
                    },
                    {
                        "username": "f20212091",
                        "content": "This is cubic complexity ig"
                    },
                    {
                        "username": "curryGoat",
                        "content": "string must be refernce"
                    },
                    {
                        "username": "akhilg11",
                        "content": "How did you get over the TLE then?"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "same bro "
                    },
                    {
                        "username": "Kurdush",
                        "content": "here all the test cases  are given with small length there should be atleast one test case with length =5 "
                    },
                    {
                        "username": "Hitesh_9099",
                        "content": "There is mistake in the last testcase the length of the string is 1 to 2000  but the last testcase has empty string so please correct it"
                    },
                    {
                        "username": "sanjanarana101coding",
                        "content": "Hi guys,  solution video to this problem is provided here in the link.\\nSolution Link:-https://youtu.be/qmTtAbOTqcg\\n\\n"
                    },
                    {
                        "username": "bhardwajshubh",
                        "content": "Incase if you get Memory exceed try to give string as refrence in every function."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "how to do it in python there is no such concept of reference\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1. Check whether the given string is a palindrome or not. If it is, return 0 as no cuts are needed.\\n\\n2. Otherwise, use dynamic programming to solve the problem. We will define an array dp such that dp[i] represents the minimum number of cuts needed to partition the substring from index 0 to index i into palindrome substrings.\\n\\n3. To compute dp[i], we need to consider all possible partitions of the substring from index 0 to index i. For each partition, we will check if the first part of the partition is a palindrome or not. If it is, we will add 1 to the minimum number of cuts required to partition the second part of the partition, which can be computed using dp[j] + 1, where j is the index where the second part of the partition starts.\\n\\n4. We will update dp[i] to be the minimum of all the values computed in step3.\\n\\n5. Finally, we will return dp[n-1], where n is the length of the given string."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro this approach might give tle\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "it is not *the* approach, it is an approach. I did something different, so you can go with something else\nAlso, I thought you were not supposed to post solutions in discussion section. What you give here is a lot more than a tip"
                    },
                    {
                        "username": "pallavi1k1",
                        "content": "Easy Java Solution\\nMCM Varaition - Palindrome Partitioning\\n\\nclass Solution {\\n    public int minCut(String s) {\\n        int n = s.length()-1;\\n        int[][] t = new int[n+2][n+2];\\n        \\n        for(int i=0;i<n+2;i++){\\n            for(int j=0;j<n+2;j++)\\n               t[i][j]=-1;\\n        }\\n        return solve(t,s,0,n);\\n    }\\n    int solve(int[][] t,String s, int i, int j){\\n        if(i>=j)\\n            return 0;\\n    \\n        if(isPallindrom(s,i,j) ||i>=j){\\n            // t[i][j]=0;\\n            return 0;\\n        }\\n\\n        if(t[i][j]!=-1)\\n           return t[i][j];\\n\\n        int ans = Integer.MAX_VALUE;\\n        for(int k=i;k<=j-1;k++){\\n            if (isPallindrom(s, i, k))\\n \\t\\t\\t{\\n \\t\\t\\t\\tans = Math.min(ans, 1 + solve(t,s, k + 1, j));\\n \\t\\t\\t}\\n            \\n        }\\n        return t[i][j]=ans;\\n    }\\n\\n     boolean isPallindrom(String s, int i, int j){\\n         if(i==j) return true;\\n         if(i>j) return false;\\n        while( i < j){\\n            if(s.charAt(i) != s.charAt(j) )  return false; \\n            i++; j--;\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Stop posting solution in the discussion section"
                    },
                    {
                        "username": "dvakar",
                        "content": " `\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"`"
                    }
                ]
            },
            {
                "id": 1772498,
                "content": [
                    {
                        "username": "dhnanj",
                        "content": "for the test case s = \"aabaa\" the expected answer by leetcode is 0 as it is a palindrome in whole but, as far as my understanding of the question we need a partitioning which has all its substrings as palindrome and if we don\\'t partition here then the substrings \"aab\" & \"baa\" are not palindromes thus the answer for the above test case should be 2 (aa|b|aa).\\npls correct me if I\\'m wrong.\\nthanks in advance!"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Q says that after cuts , every substring generated should be palindrome, \"aabaa\" => 0 cut then this substring is palindrome itself"
                    },
                    {
                        "username": "Chandrachur",
                        "content": "The original string is also a substring of itself."
                    },
                    {
                        "username": "niketan21",
                        "content": "From what I have understood, \"every substring of the partition\" means that all the those strings which are generated by the partition. So, \"every substring of the partition\" for the partition which you mentioned (aa|b|aa) would be 3 strings \"aa\", \"b\", \"aa\". In this case, the original string is palindrome itself so the answer would be 0. \\n\\nI agree the description of the question is quite confusing, initially I myself got confused just like you."
                    },
                    {
                        "username": "akhilg11",
                        "content": "Gives TLE if you follow striver\\'s code for this question"
                    },
                    {
                        "username": "nerdstv",
                        "content": "[@shadab-malik](/shadab-malik) Thanks man, it worked!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@shadab-malik](/shadab-malik) still TLE"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "pass string by refernce even in palindrome function\\n "
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- TLE on last testcase, 36 / 37 testcases passed\\n- I mean, for real dude?\\n- Test Case 37 : \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab\"\\n- My Code: \\n```\\nclass Solution {\\n    private static boolean isPalindrome(int i, int j, String s){\\n        while(i<=j){\\n            if(s.charAt(i)!=s.charAt(j)) return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n\\n    private static int fun(String s){\\n        int len = s.length();\\n        int[] dp = new int[len+1];\\n        dp[len] = 0;\\n        for(int cut=len-1;cut>=0;cut--){\\n            int minCuts = Integer.MAX_VALUE;\\n            for(int partition=cut;partition<len;partition++){\\n                if(isPalindrome(cut,partition,s)){\\n                    int cuts = 1 + dp[partition+1];\\n                    minCuts = Math.min(minCuts,cuts);\\n                }\\n            }\\n            dp[cut] = minCuts;\\n        }\\n        return dp[0]-1;\\n    }\\n\\n    public int minCut(String s){\\n        return fun(s);\\n    }\\n}\\n// Tabulation Code \\n// Time Complexity : ~ O(n*n), Quadratic Complexity\\n// Space Complexity : O(n)\\n```"
                    },
                    {
                        "username": "aviralagrawal",
                        "content": "Passing string by reference solved the problem in C++"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "[@Adhiraj-MNNIT](/Adhiraj-MNNIT) i got mle on this testcase"
                    },
                    {
                        "username": "f20212091",
                        "content": "This is cubic complexity ig"
                    },
                    {
                        "username": "curryGoat",
                        "content": "string must be refernce"
                    },
                    {
                        "username": "akhilg11",
                        "content": "How did you get over the TLE then?"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "same bro "
                    },
                    {
                        "username": "Kurdush",
                        "content": "here all the test cases  are given with small length there should be atleast one test case with length =5 "
                    },
                    {
                        "username": "Hitesh_9099",
                        "content": "There is mistake in the last testcase the length of the string is 1 to 2000  but the last testcase has empty string so please correct it"
                    },
                    {
                        "username": "sanjanarana101coding",
                        "content": "Hi guys,  solution video to this problem is provided here in the link.\\nSolution Link:-https://youtu.be/qmTtAbOTqcg\\n\\n"
                    },
                    {
                        "username": "bhardwajshubh",
                        "content": "Incase if you get Memory exceed try to give string as refrence in every function."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "how to do it in python there is no such concept of reference\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1. Check whether the given string is a palindrome or not. If it is, return 0 as no cuts are needed.\\n\\n2. Otherwise, use dynamic programming to solve the problem. We will define an array dp such that dp[i] represents the minimum number of cuts needed to partition the substring from index 0 to index i into palindrome substrings.\\n\\n3. To compute dp[i], we need to consider all possible partitions of the substring from index 0 to index i. For each partition, we will check if the first part of the partition is a palindrome or not. If it is, we will add 1 to the minimum number of cuts required to partition the second part of the partition, which can be computed using dp[j] + 1, where j is the index where the second part of the partition starts.\\n\\n4. We will update dp[i] to be the minimum of all the values computed in step3.\\n\\n5. Finally, we will return dp[n-1], where n is the length of the given string."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro this approach might give tle\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "it is not *the* approach, it is an approach. I did something different, so you can go with something else\nAlso, I thought you were not supposed to post solutions in discussion section. What you give here is a lot more than a tip"
                    },
                    {
                        "username": "pallavi1k1",
                        "content": "Easy Java Solution\\nMCM Varaition - Palindrome Partitioning\\n\\nclass Solution {\\n    public int minCut(String s) {\\n        int n = s.length()-1;\\n        int[][] t = new int[n+2][n+2];\\n        \\n        for(int i=0;i<n+2;i++){\\n            for(int j=0;j<n+2;j++)\\n               t[i][j]=-1;\\n        }\\n        return solve(t,s,0,n);\\n    }\\n    int solve(int[][] t,String s, int i, int j){\\n        if(i>=j)\\n            return 0;\\n    \\n        if(isPallindrom(s,i,j) ||i>=j){\\n            // t[i][j]=0;\\n            return 0;\\n        }\\n\\n        if(t[i][j]!=-1)\\n           return t[i][j];\\n\\n        int ans = Integer.MAX_VALUE;\\n        for(int k=i;k<=j-1;k++){\\n            if (isPallindrom(s, i, k))\\n \\t\\t\\t{\\n \\t\\t\\t\\tans = Math.min(ans, 1 + solve(t,s, k + 1, j));\\n \\t\\t\\t}\\n            \\n        }\\n        return t[i][j]=ans;\\n    }\\n\\n     boolean isPallindrom(String s, int i, int j){\\n         if(i==j) return true;\\n         if(i>j) return false;\\n        while( i < j){\\n            if(s.charAt(i) != s.charAt(j) )  return false; \\n            i++; j--;\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Stop posting solution in the discussion section"
                    },
                    {
                        "username": "dvakar",
                        "content": " `\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"`"
                    }
                ]
            },
            {
                "id": 2072886,
                "content": [
                    {
                        "username": "dhnanj",
                        "content": "for the test case s = \"aabaa\" the expected answer by leetcode is 0 as it is a palindrome in whole but, as far as my understanding of the question we need a partitioning which has all its substrings as palindrome and if we don\\'t partition here then the substrings \"aab\" & \"baa\" are not palindromes thus the answer for the above test case should be 2 (aa|b|aa).\\npls correct me if I\\'m wrong.\\nthanks in advance!"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Q says that after cuts , every substring generated should be palindrome, \"aabaa\" => 0 cut then this substring is palindrome itself"
                    },
                    {
                        "username": "Chandrachur",
                        "content": "The original string is also a substring of itself."
                    },
                    {
                        "username": "niketan21",
                        "content": "From what I have understood, \"every substring of the partition\" means that all the those strings which are generated by the partition. So, \"every substring of the partition\" for the partition which you mentioned (aa|b|aa) would be 3 strings \"aa\", \"b\", \"aa\". In this case, the original string is palindrome itself so the answer would be 0. \\n\\nI agree the description of the question is quite confusing, initially I myself got confused just like you."
                    },
                    {
                        "username": "akhilg11",
                        "content": "Gives TLE if you follow striver\\'s code for this question"
                    },
                    {
                        "username": "nerdstv",
                        "content": "[@shadab-malik](/shadab-malik) Thanks man, it worked!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@shadab-malik](/shadab-malik) still TLE"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "pass string by refernce even in palindrome function\\n "
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- TLE on last testcase, 36 / 37 testcases passed\\n- I mean, for real dude?\\n- Test Case 37 : \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab\"\\n- My Code: \\n```\\nclass Solution {\\n    private static boolean isPalindrome(int i, int j, String s){\\n        while(i<=j){\\n            if(s.charAt(i)!=s.charAt(j)) return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n\\n    private static int fun(String s){\\n        int len = s.length();\\n        int[] dp = new int[len+1];\\n        dp[len] = 0;\\n        for(int cut=len-1;cut>=0;cut--){\\n            int minCuts = Integer.MAX_VALUE;\\n            for(int partition=cut;partition<len;partition++){\\n                if(isPalindrome(cut,partition,s)){\\n                    int cuts = 1 + dp[partition+1];\\n                    minCuts = Math.min(minCuts,cuts);\\n                }\\n            }\\n            dp[cut] = minCuts;\\n        }\\n        return dp[0]-1;\\n    }\\n\\n    public int minCut(String s){\\n        return fun(s);\\n    }\\n}\\n// Tabulation Code \\n// Time Complexity : ~ O(n*n), Quadratic Complexity\\n// Space Complexity : O(n)\\n```"
                    },
                    {
                        "username": "aviralagrawal",
                        "content": "Passing string by reference solved the problem in C++"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "[@Adhiraj-MNNIT](/Adhiraj-MNNIT) i got mle on this testcase"
                    },
                    {
                        "username": "f20212091",
                        "content": "This is cubic complexity ig"
                    },
                    {
                        "username": "curryGoat",
                        "content": "string must be refernce"
                    },
                    {
                        "username": "akhilg11",
                        "content": "How did you get over the TLE then?"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "same bro "
                    },
                    {
                        "username": "Kurdush",
                        "content": "here all the test cases  are given with small length there should be atleast one test case with length =5 "
                    },
                    {
                        "username": "Hitesh_9099",
                        "content": "There is mistake in the last testcase the length of the string is 1 to 2000  but the last testcase has empty string so please correct it"
                    },
                    {
                        "username": "sanjanarana101coding",
                        "content": "Hi guys,  solution video to this problem is provided here in the link.\\nSolution Link:-https://youtu.be/qmTtAbOTqcg\\n\\n"
                    },
                    {
                        "username": "bhardwajshubh",
                        "content": "Incase if you get Memory exceed try to give string as refrence in every function."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "how to do it in python there is no such concept of reference\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1. Check whether the given string is a palindrome or not. If it is, return 0 as no cuts are needed.\\n\\n2. Otherwise, use dynamic programming to solve the problem. We will define an array dp such that dp[i] represents the minimum number of cuts needed to partition the substring from index 0 to index i into palindrome substrings.\\n\\n3. To compute dp[i], we need to consider all possible partitions of the substring from index 0 to index i. For each partition, we will check if the first part of the partition is a palindrome or not. If it is, we will add 1 to the minimum number of cuts required to partition the second part of the partition, which can be computed using dp[j] + 1, where j is the index where the second part of the partition starts.\\n\\n4. We will update dp[i] to be the minimum of all the values computed in step3.\\n\\n5. Finally, we will return dp[n-1], where n is the length of the given string."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro this approach might give tle\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "it is not *the* approach, it is an approach. I did something different, so you can go with something else\nAlso, I thought you were not supposed to post solutions in discussion section. What you give here is a lot more than a tip"
                    },
                    {
                        "username": "pallavi1k1",
                        "content": "Easy Java Solution\\nMCM Varaition - Palindrome Partitioning\\n\\nclass Solution {\\n    public int minCut(String s) {\\n        int n = s.length()-1;\\n        int[][] t = new int[n+2][n+2];\\n        \\n        for(int i=0;i<n+2;i++){\\n            for(int j=0;j<n+2;j++)\\n               t[i][j]=-1;\\n        }\\n        return solve(t,s,0,n);\\n    }\\n    int solve(int[][] t,String s, int i, int j){\\n        if(i>=j)\\n            return 0;\\n    \\n        if(isPallindrom(s,i,j) ||i>=j){\\n            // t[i][j]=0;\\n            return 0;\\n        }\\n\\n        if(t[i][j]!=-1)\\n           return t[i][j];\\n\\n        int ans = Integer.MAX_VALUE;\\n        for(int k=i;k<=j-1;k++){\\n            if (isPallindrom(s, i, k))\\n \\t\\t\\t{\\n \\t\\t\\t\\tans = Math.min(ans, 1 + solve(t,s, k + 1, j));\\n \\t\\t\\t}\\n            \\n        }\\n        return t[i][j]=ans;\\n    }\\n\\n     boolean isPallindrom(String s, int i, int j){\\n         if(i==j) return true;\\n         if(i>j) return false;\\n        while( i < j){\\n            if(s.charAt(i) != s.charAt(j) )  return false; \\n            i++; j--;\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Stop posting solution in the discussion section"
                    },
                    {
                        "username": "dvakar",
                        "content": " `\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"`"
                    }
                ]
            },
            {
                "id": 1570538,
                "content": [
                    {
                        "username": "dhnanj",
                        "content": "for the test case s = \"aabaa\" the expected answer by leetcode is 0 as it is a palindrome in whole but, as far as my understanding of the question we need a partitioning which has all its substrings as palindrome and if we don\\'t partition here then the substrings \"aab\" & \"baa\" are not palindromes thus the answer for the above test case should be 2 (aa|b|aa).\\npls correct me if I\\'m wrong.\\nthanks in advance!"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Q says that after cuts , every substring generated should be palindrome, \"aabaa\" => 0 cut then this substring is palindrome itself"
                    },
                    {
                        "username": "Chandrachur",
                        "content": "The original string is also a substring of itself."
                    },
                    {
                        "username": "niketan21",
                        "content": "From what I have understood, \"every substring of the partition\" means that all the those strings which are generated by the partition. So, \"every substring of the partition\" for the partition which you mentioned (aa|b|aa) would be 3 strings \"aa\", \"b\", \"aa\". In this case, the original string is palindrome itself so the answer would be 0. \\n\\nI agree the description of the question is quite confusing, initially I myself got confused just like you."
                    },
                    {
                        "username": "akhilg11",
                        "content": "Gives TLE if you follow striver\\'s code for this question"
                    },
                    {
                        "username": "nerdstv",
                        "content": "[@shadab-malik](/shadab-malik) Thanks man, it worked!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@shadab-malik](/shadab-malik) still TLE"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "pass string by refernce even in palindrome function\\n "
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- TLE on last testcase, 36 / 37 testcases passed\\n- I mean, for real dude?\\n- Test Case 37 : \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab\"\\n- My Code: \\n```\\nclass Solution {\\n    private static boolean isPalindrome(int i, int j, String s){\\n        while(i<=j){\\n            if(s.charAt(i)!=s.charAt(j)) return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n\\n    private static int fun(String s){\\n        int len = s.length();\\n        int[] dp = new int[len+1];\\n        dp[len] = 0;\\n        for(int cut=len-1;cut>=0;cut--){\\n            int minCuts = Integer.MAX_VALUE;\\n            for(int partition=cut;partition<len;partition++){\\n                if(isPalindrome(cut,partition,s)){\\n                    int cuts = 1 + dp[partition+1];\\n                    minCuts = Math.min(minCuts,cuts);\\n                }\\n            }\\n            dp[cut] = minCuts;\\n        }\\n        return dp[0]-1;\\n    }\\n\\n    public int minCut(String s){\\n        return fun(s);\\n    }\\n}\\n// Tabulation Code \\n// Time Complexity : ~ O(n*n), Quadratic Complexity\\n// Space Complexity : O(n)\\n```"
                    },
                    {
                        "username": "aviralagrawal",
                        "content": "Passing string by reference solved the problem in C++"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "[@Adhiraj-MNNIT](/Adhiraj-MNNIT) i got mle on this testcase"
                    },
                    {
                        "username": "f20212091",
                        "content": "This is cubic complexity ig"
                    },
                    {
                        "username": "curryGoat",
                        "content": "string must be refernce"
                    },
                    {
                        "username": "akhilg11",
                        "content": "How did you get over the TLE then?"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "same bro "
                    },
                    {
                        "username": "Kurdush",
                        "content": "here all the test cases  are given with small length there should be atleast one test case with length =5 "
                    },
                    {
                        "username": "Hitesh_9099",
                        "content": "There is mistake in the last testcase the length of the string is 1 to 2000  but the last testcase has empty string so please correct it"
                    },
                    {
                        "username": "sanjanarana101coding",
                        "content": "Hi guys,  solution video to this problem is provided here in the link.\\nSolution Link:-https://youtu.be/qmTtAbOTqcg\\n\\n"
                    },
                    {
                        "username": "bhardwajshubh",
                        "content": "Incase if you get Memory exceed try to give string as refrence in every function."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "how to do it in python there is no such concept of reference\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1. Check whether the given string is a palindrome or not. If it is, return 0 as no cuts are needed.\\n\\n2. Otherwise, use dynamic programming to solve the problem. We will define an array dp such that dp[i] represents the minimum number of cuts needed to partition the substring from index 0 to index i into palindrome substrings.\\n\\n3. To compute dp[i], we need to consider all possible partitions of the substring from index 0 to index i. For each partition, we will check if the first part of the partition is a palindrome or not. If it is, we will add 1 to the minimum number of cuts required to partition the second part of the partition, which can be computed using dp[j] + 1, where j is the index where the second part of the partition starts.\\n\\n4. We will update dp[i] to be the minimum of all the values computed in step3.\\n\\n5. Finally, we will return dp[n-1], where n is the length of the given string."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro this approach might give tle\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "it is not *the* approach, it is an approach. I did something different, so you can go with something else\nAlso, I thought you were not supposed to post solutions in discussion section. What you give here is a lot more than a tip"
                    },
                    {
                        "username": "pallavi1k1",
                        "content": "Easy Java Solution\\nMCM Varaition - Palindrome Partitioning\\n\\nclass Solution {\\n    public int minCut(String s) {\\n        int n = s.length()-1;\\n        int[][] t = new int[n+2][n+2];\\n        \\n        for(int i=0;i<n+2;i++){\\n            for(int j=0;j<n+2;j++)\\n               t[i][j]=-1;\\n        }\\n        return solve(t,s,0,n);\\n    }\\n    int solve(int[][] t,String s, int i, int j){\\n        if(i>=j)\\n            return 0;\\n    \\n        if(isPallindrom(s,i,j) ||i>=j){\\n            // t[i][j]=0;\\n            return 0;\\n        }\\n\\n        if(t[i][j]!=-1)\\n           return t[i][j];\\n\\n        int ans = Integer.MAX_VALUE;\\n        for(int k=i;k<=j-1;k++){\\n            if (isPallindrom(s, i, k))\\n \\t\\t\\t{\\n \\t\\t\\t\\tans = Math.min(ans, 1 + solve(t,s, k + 1, j));\\n \\t\\t\\t}\\n            \\n        }\\n        return t[i][j]=ans;\\n    }\\n\\n     boolean isPallindrom(String s, int i, int j){\\n         if(i==j) return true;\\n         if(i>j) return false;\\n        while( i < j){\\n            if(s.charAt(i) != s.charAt(j) )  return false; \\n            i++; j--;\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Stop posting solution in the discussion section"
                    },
                    {
                        "username": "dvakar",
                        "content": " `\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"`"
                    }
                ]
            },
            {
                "id": 1946701,
                "content": [
                    {
                        "username": "dhnanj",
                        "content": "for the test case s = \"aabaa\" the expected answer by leetcode is 0 as it is a palindrome in whole but, as far as my understanding of the question we need a partitioning which has all its substrings as palindrome and if we don\\'t partition here then the substrings \"aab\" & \"baa\" are not palindromes thus the answer for the above test case should be 2 (aa|b|aa).\\npls correct me if I\\'m wrong.\\nthanks in advance!"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Q says that after cuts , every substring generated should be palindrome, \"aabaa\" => 0 cut then this substring is palindrome itself"
                    },
                    {
                        "username": "Chandrachur",
                        "content": "The original string is also a substring of itself."
                    },
                    {
                        "username": "niketan21",
                        "content": "From what I have understood, \"every substring of the partition\" means that all the those strings which are generated by the partition. So, \"every substring of the partition\" for the partition which you mentioned (aa|b|aa) would be 3 strings \"aa\", \"b\", \"aa\". In this case, the original string is palindrome itself so the answer would be 0. \\n\\nI agree the description of the question is quite confusing, initially I myself got confused just like you."
                    },
                    {
                        "username": "akhilg11",
                        "content": "Gives TLE if you follow striver\\'s code for this question"
                    },
                    {
                        "username": "nerdstv",
                        "content": "[@shadab-malik](/shadab-malik) Thanks man, it worked!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@shadab-malik](/shadab-malik) still TLE"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "pass string by refernce even in palindrome function\\n "
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- TLE on last testcase, 36 / 37 testcases passed\\n- I mean, for real dude?\\n- Test Case 37 : \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab\"\\n- My Code: \\n```\\nclass Solution {\\n    private static boolean isPalindrome(int i, int j, String s){\\n        while(i<=j){\\n            if(s.charAt(i)!=s.charAt(j)) return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n\\n    private static int fun(String s){\\n        int len = s.length();\\n        int[] dp = new int[len+1];\\n        dp[len] = 0;\\n        for(int cut=len-1;cut>=0;cut--){\\n            int minCuts = Integer.MAX_VALUE;\\n            for(int partition=cut;partition<len;partition++){\\n                if(isPalindrome(cut,partition,s)){\\n                    int cuts = 1 + dp[partition+1];\\n                    minCuts = Math.min(minCuts,cuts);\\n                }\\n            }\\n            dp[cut] = minCuts;\\n        }\\n        return dp[0]-1;\\n    }\\n\\n    public int minCut(String s){\\n        return fun(s);\\n    }\\n}\\n// Tabulation Code \\n// Time Complexity : ~ O(n*n), Quadratic Complexity\\n// Space Complexity : O(n)\\n```"
                    },
                    {
                        "username": "aviralagrawal",
                        "content": "Passing string by reference solved the problem in C++"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "[@Adhiraj-MNNIT](/Adhiraj-MNNIT) i got mle on this testcase"
                    },
                    {
                        "username": "f20212091",
                        "content": "This is cubic complexity ig"
                    },
                    {
                        "username": "curryGoat",
                        "content": "string must be refernce"
                    },
                    {
                        "username": "akhilg11",
                        "content": "How did you get over the TLE then?"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "same bro "
                    },
                    {
                        "username": "Kurdush",
                        "content": "here all the test cases  are given with small length there should be atleast one test case with length =5 "
                    },
                    {
                        "username": "Hitesh_9099",
                        "content": "There is mistake in the last testcase the length of the string is 1 to 2000  but the last testcase has empty string so please correct it"
                    },
                    {
                        "username": "sanjanarana101coding",
                        "content": "Hi guys,  solution video to this problem is provided here in the link.\\nSolution Link:-https://youtu.be/qmTtAbOTqcg\\n\\n"
                    },
                    {
                        "username": "bhardwajshubh",
                        "content": "Incase if you get Memory exceed try to give string as refrence in every function."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "how to do it in python there is no such concept of reference\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1. Check whether the given string is a palindrome or not. If it is, return 0 as no cuts are needed.\\n\\n2. Otherwise, use dynamic programming to solve the problem. We will define an array dp such that dp[i] represents the minimum number of cuts needed to partition the substring from index 0 to index i into palindrome substrings.\\n\\n3. To compute dp[i], we need to consider all possible partitions of the substring from index 0 to index i. For each partition, we will check if the first part of the partition is a palindrome or not. If it is, we will add 1 to the minimum number of cuts required to partition the second part of the partition, which can be computed using dp[j] + 1, where j is the index where the second part of the partition starts.\\n\\n4. We will update dp[i] to be the minimum of all the values computed in step3.\\n\\n5. Finally, we will return dp[n-1], where n is the length of the given string."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro this approach might give tle\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "it is not *the* approach, it is an approach. I did something different, so you can go with something else\nAlso, I thought you were not supposed to post solutions in discussion section. What you give here is a lot more than a tip"
                    },
                    {
                        "username": "pallavi1k1",
                        "content": "Easy Java Solution\\nMCM Varaition - Palindrome Partitioning\\n\\nclass Solution {\\n    public int minCut(String s) {\\n        int n = s.length()-1;\\n        int[][] t = new int[n+2][n+2];\\n        \\n        for(int i=0;i<n+2;i++){\\n            for(int j=0;j<n+2;j++)\\n               t[i][j]=-1;\\n        }\\n        return solve(t,s,0,n);\\n    }\\n    int solve(int[][] t,String s, int i, int j){\\n        if(i>=j)\\n            return 0;\\n    \\n        if(isPallindrom(s,i,j) ||i>=j){\\n            // t[i][j]=0;\\n            return 0;\\n        }\\n\\n        if(t[i][j]!=-1)\\n           return t[i][j];\\n\\n        int ans = Integer.MAX_VALUE;\\n        for(int k=i;k<=j-1;k++){\\n            if (isPallindrom(s, i, k))\\n \\t\\t\\t{\\n \\t\\t\\t\\tans = Math.min(ans, 1 + solve(t,s, k + 1, j));\\n \\t\\t\\t}\\n            \\n        }\\n        return t[i][j]=ans;\\n    }\\n\\n     boolean isPallindrom(String s, int i, int j){\\n         if(i==j) return true;\\n         if(i>j) return false;\\n        while( i < j){\\n            if(s.charAt(i) != s.charAt(j) )  return false; \\n            i++; j--;\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Stop posting solution in the discussion section"
                    },
                    {
                        "username": "dvakar",
                        "content": " `\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"`"
                    }
                ]
            },
            {
                "id": 1926566,
                "content": [
                    {
                        "username": "dhnanj",
                        "content": "for the test case s = \"aabaa\" the expected answer by leetcode is 0 as it is a palindrome in whole but, as far as my understanding of the question we need a partitioning which has all its substrings as palindrome and if we don\\'t partition here then the substrings \"aab\" & \"baa\" are not palindromes thus the answer for the above test case should be 2 (aa|b|aa).\\npls correct me if I\\'m wrong.\\nthanks in advance!"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Q says that after cuts , every substring generated should be palindrome, \"aabaa\" => 0 cut then this substring is palindrome itself"
                    },
                    {
                        "username": "Chandrachur",
                        "content": "The original string is also a substring of itself."
                    },
                    {
                        "username": "niketan21",
                        "content": "From what I have understood, \"every substring of the partition\" means that all the those strings which are generated by the partition. So, \"every substring of the partition\" for the partition which you mentioned (aa|b|aa) would be 3 strings \"aa\", \"b\", \"aa\". In this case, the original string is palindrome itself so the answer would be 0. \\n\\nI agree the description of the question is quite confusing, initially I myself got confused just like you."
                    },
                    {
                        "username": "akhilg11",
                        "content": "Gives TLE if you follow striver\\'s code for this question"
                    },
                    {
                        "username": "nerdstv",
                        "content": "[@shadab-malik](/shadab-malik) Thanks man, it worked!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@shadab-malik](/shadab-malik) still TLE"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "pass string by refernce even in palindrome function\\n "
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- TLE on last testcase, 36 / 37 testcases passed\\n- I mean, for real dude?\\n- Test Case 37 : \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab\"\\n- My Code: \\n```\\nclass Solution {\\n    private static boolean isPalindrome(int i, int j, String s){\\n        while(i<=j){\\n            if(s.charAt(i)!=s.charAt(j)) return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n\\n    private static int fun(String s){\\n        int len = s.length();\\n        int[] dp = new int[len+1];\\n        dp[len] = 0;\\n        for(int cut=len-1;cut>=0;cut--){\\n            int minCuts = Integer.MAX_VALUE;\\n            for(int partition=cut;partition<len;partition++){\\n                if(isPalindrome(cut,partition,s)){\\n                    int cuts = 1 + dp[partition+1];\\n                    minCuts = Math.min(minCuts,cuts);\\n                }\\n            }\\n            dp[cut] = minCuts;\\n        }\\n        return dp[0]-1;\\n    }\\n\\n    public int minCut(String s){\\n        return fun(s);\\n    }\\n}\\n// Tabulation Code \\n// Time Complexity : ~ O(n*n), Quadratic Complexity\\n// Space Complexity : O(n)\\n```"
                    },
                    {
                        "username": "aviralagrawal",
                        "content": "Passing string by reference solved the problem in C++"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "[@Adhiraj-MNNIT](/Adhiraj-MNNIT) i got mle on this testcase"
                    },
                    {
                        "username": "f20212091",
                        "content": "This is cubic complexity ig"
                    },
                    {
                        "username": "curryGoat",
                        "content": "string must be refernce"
                    },
                    {
                        "username": "akhilg11",
                        "content": "How did you get over the TLE then?"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "same bro "
                    },
                    {
                        "username": "Kurdush",
                        "content": "here all the test cases  are given with small length there should be atleast one test case with length =5 "
                    },
                    {
                        "username": "Hitesh_9099",
                        "content": "There is mistake in the last testcase the length of the string is 1 to 2000  but the last testcase has empty string so please correct it"
                    },
                    {
                        "username": "sanjanarana101coding",
                        "content": "Hi guys,  solution video to this problem is provided here in the link.\\nSolution Link:-https://youtu.be/qmTtAbOTqcg\\n\\n"
                    },
                    {
                        "username": "bhardwajshubh",
                        "content": "Incase if you get Memory exceed try to give string as refrence in every function."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "how to do it in python there is no such concept of reference\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1. Check whether the given string is a palindrome or not. If it is, return 0 as no cuts are needed.\\n\\n2. Otherwise, use dynamic programming to solve the problem. We will define an array dp such that dp[i] represents the minimum number of cuts needed to partition the substring from index 0 to index i into palindrome substrings.\\n\\n3. To compute dp[i], we need to consider all possible partitions of the substring from index 0 to index i. For each partition, we will check if the first part of the partition is a palindrome or not. If it is, we will add 1 to the minimum number of cuts required to partition the second part of the partition, which can be computed using dp[j] + 1, where j is the index where the second part of the partition starts.\\n\\n4. We will update dp[i] to be the minimum of all the values computed in step3.\\n\\n5. Finally, we will return dp[n-1], where n is the length of the given string."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro this approach might give tle\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "it is not *the* approach, it is an approach. I did something different, so you can go with something else\nAlso, I thought you were not supposed to post solutions in discussion section. What you give here is a lot more than a tip"
                    },
                    {
                        "username": "pallavi1k1",
                        "content": "Easy Java Solution\\nMCM Varaition - Palindrome Partitioning\\n\\nclass Solution {\\n    public int minCut(String s) {\\n        int n = s.length()-1;\\n        int[][] t = new int[n+2][n+2];\\n        \\n        for(int i=0;i<n+2;i++){\\n            for(int j=0;j<n+2;j++)\\n               t[i][j]=-1;\\n        }\\n        return solve(t,s,0,n);\\n    }\\n    int solve(int[][] t,String s, int i, int j){\\n        if(i>=j)\\n            return 0;\\n    \\n        if(isPallindrom(s,i,j) ||i>=j){\\n            // t[i][j]=0;\\n            return 0;\\n        }\\n\\n        if(t[i][j]!=-1)\\n           return t[i][j];\\n\\n        int ans = Integer.MAX_VALUE;\\n        for(int k=i;k<=j-1;k++){\\n            if (isPallindrom(s, i, k))\\n \\t\\t\\t{\\n \\t\\t\\t\\tans = Math.min(ans, 1 + solve(t,s, k + 1, j));\\n \\t\\t\\t}\\n            \\n        }\\n        return t[i][j]=ans;\\n    }\\n\\n     boolean isPallindrom(String s, int i, int j){\\n         if(i==j) return true;\\n         if(i>j) return false;\\n        while( i < j){\\n            if(s.charAt(i) != s.charAt(j) )  return false; \\n            i++; j--;\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Stop posting solution in the discussion section"
                    },
                    {
                        "username": "dvakar",
                        "content": " `\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"`"
                    }
                ]
            },
            {
                "id": 1713274,
                "content": [
                    {
                        "username": "dhnanj",
                        "content": "for the test case s = \"aabaa\" the expected answer by leetcode is 0 as it is a palindrome in whole but, as far as my understanding of the question we need a partitioning which has all its substrings as palindrome and if we don\\'t partition here then the substrings \"aab\" & \"baa\" are not palindromes thus the answer for the above test case should be 2 (aa|b|aa).\\npls correct me if I\\'m wrong.\\nthanks in advance!"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Q says that after cuts , every substring generated should be palindrome, \"aabaa\" => 0 cut then this substring is palindrome itself"
                    },
                    {
                        "username": "Chandrachur",
                        "content": "The original string is also a substring of itself."
                    },
                    {
                        "username": "niketan21",
                        "content": "From what I have understood, \"every substring of the partition\" means that all the those strings which are generated by the partition. So, \"every substring of the partition\" for the partition which you mentioned (aa|b|aa) would be 3 strings \"aa\", \"b\", \"aa\". In this case, the original string is palindrome itself so the answer would be 0. \\n\\nI agree the description of the question is quite confusing, initially I myself got confused just like you."
                    },
                    {
                        "username": "akhilg11",
                        "content": "Gives TLE if you follow striver\\'s code for this question"
                    },
                    {
                        "username": "nerdstv",
                        "content": "[@shadab-malik](/shadab-malik) Thanks man, it worked!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@shadab-malik](/shadab-malik) still TLE"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "pass string by refernce even in palindrome function\\n "
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- TLE on last testcase, 36 / 37 testcases passed\\n- I mean, for real dude?\\n- Test Case 37 : \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab\"\\n- My Code: \\n```\\nclass Solution {\\n    private static boolean isPalindrome(int i, int j, String s){\\n        while(i<=j){\\n            if(s.charAt(i)!=s.charAt(j)) return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n\\n    private static int fun(String s){\\n        int len = s.length();\\n        int[] dp = new int[len+1];\\n        dp[len] = 0;\\n        for(int cut=len-1;cut>=0;cut--){\\n            int minCuts = Integer.MAX_VALUE;\\n            for(int partition=cut;partition<len;partition++){\\n                if(isPalindrome(cut,partition,s)){\\n                    int cuts = 1 + dp[partition+1];\\n                    minCuts = Math.min(minCuts,cuts);\\n                }\\n            }\\n            dp[cut] = minCuts;\\n        }\\n        return dp[0]-1;\\n    }\\n\\n    public int minCut(String s){\\n        return fun(s);\\n    }\\n}\\n// Tabulation Code \\n// Time Complexity : ~ O(n*n), Quadratic Complexity\\n// Space Complexity : O(n)\\n```"
                    },
                    {
                        "username": "aviralagrawal",
                        "content": "Passing string by reference solved the problem in C++"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "[@Adhiraj-MNNIT](/Adhiraj-MNNIT) i got mle on this testcase"
                    },
                    {
                        "username": "f20212091",
                        "content": "This is cubic complexity ig"
                    },
                    {
                        "username": "curryGoat",
                        "content": "string must be refernce"
                    },
                    {
                        "username": "akhilg11",
                        "content": "How did you get over the TLE then?"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "same bro "
                    },
                    {
                        "username": "Kurdush",
                        "content": "here all the test cases  are given with small length there should be atleast one test case with length =5 "
                    },
                    {
                        "username": "Hitesh_9099",
                        "content": "There is mistake in the last testcase the length of the string is 1 to 2000  but the last testcase has empty string so please correct it"
                    },
                    {
                        "username": "sanjanarana101coding",
                        "content": "Hi guys,  solution video to this problem is provided here in the link.\\nSolution Link:-https://youtu.be/qmTtAbOTqcg\\n\\n"
                    },
                    {
                        "username": "bhardwajshubh",
                        "content": "Incase if you get Memory exceed try to give string as refrence in every function."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "how to do it in python there is no such concept of reference\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1. Check whether the given string is a palindrome or not. If it is, return 0 as no cuts are needed.\\n\\n2. Otherwise, use dynamic programming to solve the problem. We will define an array dp such that dp[i] represents the minimum number of cuts needed to partition the substring from index 0 to index i into palindrome substrings.\\n\\n3. To compute dp[i], we need to consider all possible partitions of the substring from index 0 to index i. For each partition, we will check if the first part of the partition is a palindrome or not. If it is, we will add 1 to the minimum number of cuts required to partition the second part of the partition, which can be computed using dp[j] + 1, where j is the index where the second part of the partition starts.\\n\\n4. We will update dp[i] to be the minimum of all the values computed in step3.\\n\\n5. Finally, we will return dp[n-1], where n is the length of the given string."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro this approach might give tle\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "it is not *the* approach, it is an approach. I did something different, so you can go with something else\nAlso, I thought you were not supposed to post solutions in discussion section. What you give here is a lot more than a tip"
                    },
                    {
                        "username": "pallavi1k1",
                        "content": "Easy Java Solution\\nMCM Varaition - Palindrome Partitioning\\n\\nclass Solution {\\n    public int minCut(String s) {\\n        int n = s.length()-1;\\n        int[][] t = new int[n+2][n+2];\\n        \\n        for(int i=0;i<n+2;i++){\\n            for(int j=0;j<n+2;j++)\\n               t[i][j]=-1;\\n        }\\n        return solve(t,s,0,n);\\n    }\\n    int solve(int[][] t,String s, int i, int j){\\n        if(i>=j)\\n            return 0;\\n    \\n        if(isPallindrom(s,i,j) ||i>=j){\\n            // t[i][j]=0;\\n            return 0;\\n        }\\n\\n        if(t[i][j]!=-1)\\n           return t[i][j];\\n\\n        int ans = Integer.MAX_VALUE;\\n        for(int k=i;k<=j-1;k++){\\n            if (isPallindrom(s, i, k))\\n \\t\\t\\t{\\n \\t\\t\\t\\tans = Math.min(ans, 1 + solve(t,s, k + 1, j));\\n \\t\\t\\t}\\n            \\n        }\\n        return t[i][j]=ans;\\n    }\\n\\n     boolean isPallindrom(String s, int i, int j){\\n         if(i==j) return true;\\n         if(i>j) return false;\\n        while( i < j){\\n            if(s.charAt(i) != s.charAt(j) )  return false; \\n            i++; j--;\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Stop posting solution in the discussion section"
                    },
                    {
                        "username": "dvakar",
                        "content": " `\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"`"
                    }
                ]
            },
            {
                "id": 1982248,
                "content": [
                    {
                        "username": "dhnanj",
                        "content": "for the test case s = \"aabaa\" the expected answer by leetcode is 0 as it is a palindrome in whole but, as far as my understanding of the question we need a partitioning which has all its substrings as palindrome and if we don\\'t partition here then the substrings \"aab\" & \"baa\" are not palindromes thus the answer for the above test case should be 2 (aa|b|aa).\\npls correct me if I\\'m wrong.\\nthanks in advance!"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Q says that after cuts , every substring generated should be palindrome, \"aabaa\" => 0 cut then this substring is palindrome itself"
                    },
                    {
                        "username": "Chandrachur",
                        "content": "The original string is also a substring of itself."
                    },
                    {
                        "username": "niketan21",
                        "content": "From what I have understood, \"every substring of the partition\" means that all the those strings which are generated by the partition. So, \"every substring of the partition\" for the partition which you mentioned (aa|b|aa) would be 3 strings \"aa\", \"b\", \"aa\". In this case, the original string is palindrome itself so the answer would be 0. \\n\\nI agree the description of the question is quite confusing, initially I myself got confused just like you."
                    },
                    {
                        "username": "akhilg11",
                        "content": "Gives TLE if you follow striver\\'s code for this question"
                    },
                    {
                        "username": "nerdstv",
                        "content": "[@shadab-malik](/shadab-malik) Thanks man, it worked!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@shadab-malik](/shadab-malik) still TLE"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "pass string by refernce even in palindrome function\\n "
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- TLE on last testcase, 36 / 37 testcases passed\\n- I mean, for real dude?\\n- Test Case 37 : \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab\"\\n- My Code: \\n```\\nclass Solution {\\n    private static boolean isPalindrome(int i, int j, String s){\\n        while(i<=j){\\n            if(s.charAt(i)!=s.charAt(j)) return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n\\n    private static int fun(String s){\\n        int len = s.length();\\n        int[] dp = new int[len+1];\\n        dp[len] = 0;\\n        for(int cut=len-1;cut>=0;cut--){\\n            int minCuts = Integer.MAX_VALUE;\\n            for(int partition=cut;partition<len;partition++){\\n                if(isPalindrome(cut,partition,s)){\\n                    int cuts = 1 + dp[partition+1];\\n                    minCuts = Math.min(minCuts,cuts);\\n                }\\n            }\\n            dp[cut] = minCuts;\\n        }\\n        return dp[0]-1;\\n    }\\n\\n    public int minCut(String s){\\n        return fun(s);\\n    }\\n}\\n// Tabulation Code \\n// Time Complexity : ~ O(n*n), Quadratic Complexity\\n// Space Complexity : O(n)\\n```"
                    },
                    {
                        "username": "aviralagrawal",
                        "content": "Passing string by reference solved the problem in C++"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "[@Adhiraj-MNNIT](/Adhiraj-MNNIT) i got mle on this testcase"
                    },
                    {
                        "username": "f20212091",
                        "content": "This is cubic complexity ig"
                    },
                    {
                        "username": "curryGoat",
                        "content": "string must be refernce"
                    },
                    {
                        "username": "akhilg11",
                        "content": "How did you get over the TLE then?"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "same bro "
                    },
                    {
                        "username": "Kurdush",
                        "content": "here all the test cases  are given with small length there should be atleast one test case with length =5 "
                    },
                    {
                        "username": "Hitesh_9099",
                        "content": "There is mistake in the last testcase the length of the string is 1 to 2000  but the last testcase has empty string so please correct it"
                    },
                    {
                        "username": "sanjanarana101coding",
                        "content": "Hi guys,  solution video to this problem is provided here in the link.\\nSolution Link:-https://youtu.be/qmTtAbOTqcg\\n\\n"
                    },
                    {
                        "username": "bhardwajshubh",
                        "content": "Incase if you get Memory exceed try to give string as refrence in every function."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "how to do it in python there is no such concept of reference\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1. Check whether the given string is a palindrome or not. If it is, return 0 as no cuts are needed.\\n\\n2. Otherwise, use dynamic programming to solve the problem. We will define an array dp such that dp[i] represents the minimum number of cuts needed to partition the substring from index 0 to index i into palindrome substrings.\\n\\n3. To compute dp[i], we need to consider all possible partitions of the substring from index 0 to index i. For each partition, we will check if the first part of the partition is a palindrome or not. If it is, we will add 1 to the minimum number of cuts required to partition the second part of the partition, which can be computed using dp[j] + 1, where j is the index where the second part of the partition starts.\\n\\n4. We will update dp[i] to be the minimum of all the values computed in step3.\\n\\n5. Finally, we will return dp[n-1], where n is the length of the given string."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro this approach might give tle\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "it is not *the* approach, it is an approach. I did something different, so you can go with something else\nAlso, I thought you were not supposed to post solutions in discussion section. What you give here is a lot more than a tip"
                    },
                    {
                        "username": "pallavi1k1",
                        "content": "Easy Java Solution\\nMCM Varaition - Palindrome Partitioning\\n\\nclass Solution {\\n    public int minCut(String s) {\\n        int n = s.length()-1;\\n        int[][] t = new int[n+2][n+2];\\n        \\n        for(int i=0;i<n+2;i++){\\n            for(int j=0;j<n+2;j++)\\n               t[i][j]=-1;\\n        }\\n        return solve(t,s,0,n);\\n    }\\n    int solve(int[][] t,String s, int i, int j){\\n        if(i>=j)\\n            return 0;\\n    \\n        if(isPallindrom(s,i,j) ||i>=j){\\n            // t[i][j]=0;\\n            return 0;\\n        }\\n\\n        if(t[i][j]!=-1)\\n           return t[i][j];\\n\\n        int ans = Integer.MAX_VALUE;\\n        for(int k=i;k<=j-1;k++){\\n            if (isPallindrom(s, i, k))\\n \\t\\t\\t{\\n \\t\\t\\t\\tans = Math.min(ans, 1 + solve(t,s, k + 1, j));\\n \\t\\t\\t}\\n            \\n        }\\n        return t[i][j]=ans;\\n    }\\n\\n     boolean isPallindrom(String s, int i, int j){\\n         if(i==j) return true;\\n         if(i>j) return false;\\n        while( i < j){\\n            if(s.charAt(i) != s.charAt(j) )  return false; \\n            i++; j--;\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Stop posting solution in the discussion section"
                    },
                    {
                        "username": "dvakar",
                        "content": " `\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"`"
                    }
                ]
            },
            {
                "id": 1574419,
                "content": [
                    {
                        "username": "dhnanj",
                        "content": "for the test case s = \"aabaa\" the expected answer by leetcode is 0 as it is a palindrome in whole but, as far as my understanding of the question we need a partitioning which has all its substrings as palindrome and if we don\\'t partition here then the substrings \"aab\" & \"baa\" are not palindromes thus the answer for the above test case should be 2 (aa|b|aa).\\npls correct me if I\\'m wrong.\\nthanks in advance!"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Q says that after cuts , every substring generated should be palindrome, \"aabaa\" => 0 cut then this substring is palindrome itself"
                    },
                    {
                        "username": "Chandrachur",
                        "content": "The original string is also a substring of itself."
                    },
                    {
                        "username": "niketan21",
                        "content": "From what I have understood, \"every substring of the partition\" means that all the those strings which are generated by the partition. So, \"every substring of the partition\" for the partition which you mentioned (aa|b|aa) would be 3 strings \"aa\", \"b\", \"aa\". In this case, the original string is palindrome itself so the answer would be 0. \\n\\nI agree the description of the question is quite confusing, initially I myself got confused just like you."
                    },
                    {
                        "username": "akhilg11",
                        "content": "Gives TLE if you follow striver\\'s code for this question"
                    },
                    {
                        "username": "nerdstv",
                        "content": "[@shadab-malik](/shadab-malik) Thanks man, it worked!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@shadab-malik](/shadab-malik) still TLE"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "pass string by refernce even in palindrome function\\n "
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- TLE on last testcase, 36 / 37 testcases passed\\n- I mean, for real dude?\\n- Test Case 37 : \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab\"\\n- My Code: \\n```\\nclass Solution {\\n    private static boolean isPalindrome(int i, int j, String s){\\n        while(i<=j){\\n            if(s.charAt(i)!=s.charAt(j)) return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n\\n    private static int fun(String s){\\n        int len = s.length();\\n        int[] dp = new int[len+1];\\n        dp[len] = 0;\\n        for(int cut=len-1;cut>=0;cut--){\\n            int minCuts = Integer.MAX_VALUE;\\n            for(int partition=cut;partition<len;partition++){\\n                if(isPalindrome(cut,partition,s)){\\n                    int cuts = 1 + dp[partition+1];\\n                    minCuts = Math.min(minCuts,cuts);\\n                }\\n            }\\n            dp[cut] = minCuts;\\n        }\\n        return dp[0]-1;\\n    }\\n\\n    public int minCut(String s){\\n        return fun(s);\\n    }\\n}\\n// Tabulation Code \\n// Time Complexity : ~ O(n*n), Quadratic Complexity\\n// Space Complexity : O(n)\\n```"
                    },
                    {
                        "username": "aviralagrawal",
                        "content": "Passing string by reference solved the problem in C++"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "[@Adhiraj-MNNIT](/Adhiraj-MNNIT) i got mle on this testcase"
                    },
                    {
                        "username": "f20212091",
                        "content": "This is cubic complexity ig"
                    },
                    {
                        "username": "curryGoat",
                        "content": "string must be refernce"
                    },
                    {
                        "username": "akhilg11",
                        "content": "How did you get over the TLE then?"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "same bro "
                    },
                    {
                        "username": "Kurdush",
                        "content": "here all the test cases  are given with small length there should be atleast one test case with length =5 "
                    },
                    {
                        "username": "Hitesh_9099",
                        "content": "There is mistake in the last testcase the length of the string is 1 to 2000  but the last testcase has empty string so please correct it"
                    },
                    {
                        "username": "sanjanarana101coding",
                        "content": "Hi guys,  solution video to this problem is provided here in the link.\\nSolution Link:-https://youtu.be/qmTtAbOTqcg\\n\\n"
                    },
                    {
                        "username": "bhardwajshubh",
                        "content": "Incase if you get Memory exceed try to give string as refrence in every function."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "how to do it in python there is no such concept of reference\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1. Check whether the given string is a palindrome or not. If it is, return 0 as no cuts are needed.\\n\\n2. Otherwise, use dynamic programming to solve the problem. We will define an array dp such that dp[i] represents the minimum number of cuts needed to partition the substring from index 0 to index i into palindrome substrings.\\n\\n3. To compute dp[i], we need to consider all possible partitions of the substring from index 0 to index i. For each partition, we will check if the first part of the partition is a palindrome or not. If it is, we will add 1 to the minimum number of cuts required to partition the second part of the partition, which can be computed using dp[j] + 1, where j is the index where the second part of the partition starts.\\n\\n4. We will update dp[i] to be the minimum of all the values computed in step3.\\n\\n5. Finally, we will return dp[n-1], where n is the length of the given string."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro this approach might give tle\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "it is not *the* approach, it is an approach. I did something different, so you can go with something else\nAlso, I thought you were not supposed to post solutions in discussion section. What you give here is a lot more than a tip"
                    },
                    {
                        "username": "pallavi1k1",
                        "content": "Easy Java Solution\\nMCM Varaition - Palindrome Partitioning\\n\\nclass Solution {\\n    public int minCut(String s) {\\n        int n = s.length()-1;\\n        int[][] t = new int[n+2][n+2];\\n        \\n        for(int i=0;i<n+2;i++){\\n            for(int j=0;j<n+2;j++)\\n               t[i][j]=-1;\\n        }\\n        return solve(t,s,0,n);\\n    }\\n    int solve(int[][] t,String s, int i, int j){\\n        if(i>=j)\\n            return 0;\\n    \\n        if(isPallindrom(s,i,j) ||i>=j){\\n            // t[i][j]=0;\\n            return 0;\\n        }\\n\\n        if(t[i][j]!=-1)\\n           return t[i][j];\\n\\n        int ans = Integer.MAX_VALUE;\\n        for(int k=i;k<=j-1;k++){\\n            if (isPallindrom(s, i, k))\\n \\t\\t\\t{\\n \\t\\t\\t\\tans = Math.min(ans, 1 + solve(t,s, k + 1, j));\\n \\t\\t\\t}\\n            \\n        }\\n        return t[i][j]=ans;\\n    }\\n\\n     boolean isPallindrom(String s, int i, int j){\\n         if(i==j) return true;\\n         if(i>j) return false;\\n        while( i < j){\\n            if(s.charAt(i) != s.charAt(j) )  return false; \\n            i++; j--;\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Stop posting solution in the discussion section"
                    },
                    {
                        "username": "dvakar",
                        "content": " `\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"`"
                    }
                ]
            },
            {
                "id": 2024514,
                "content": [
                    {
                        "username": "dhnanj",
                        "content": "for the test case s = \"aabaa\" the expected answer by leetcode is 0 as it is a palindrome in whole but, as far as my understanding of the question we need a partitioning which has all its substrings as palindrome and if we don\\'t partition here then the substrings \"aab\" & \"baa\" are not palindromes thus the answer for the above test case should be 2 (aa|b|aa).\\npls correct me if I\\'m wrong.\\nthanks in advance!"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Q says that after cuts , every substring generated should be palindrome, \"aabaa\" => 0 cut then this substring is palindrome itself"
                    },
                    {
                        "username": "Chandrachur",
                        "content": "The original string is also a substring of itself."
                    },
                    {
                        "username": "niketan21",
                        "content": "From what I have understood, \"every substring of the partition\" means that all the those strings which are generated by the partition. So, \"every substring of the partition\" for the partition which you mentioned (aa|b|aa) would be 3 strings \"aa\", \"b\", \"aa\". In this case, the original string is palindrome itself so the answer would be 0. \\n\\nI agree the description of the question is quite confusing, initially I myself got confused just like you."
                    },
                    {
                        "username": "akhilg11",
                        "content": "Gives TLE if you follow striver\\'s code for this question"
                    },
                    {
                        "username": "nerdstv",
                        "content": "[@shadab-malik](/shadab-malik) Thanks man, it worked!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@shadab-malik](/shadab-malik) still TLE"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "pass string by refernce even in palindrome function\\n "
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- TLE on last testcase, 36 / 37 testcases passed\\n- I mean, for real dude?\\n- Test Case 37 : \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab\"\\n- My Code: \\n```\\nclass Solution {\\n    private static boolean isPalindrome(int i, int j, String s){\\n        while(i<=j){\\n            if(s.charAt(i)!=s.charAt(j)) return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n\\n    private static int fun(String s){\\n        int len = s.length();\\n        int[] dp = new int[len+1];\\n        dp[len] = 0;\\n        for(int cut=len-1;cut>=0;cut--){\\n            int minCuts = Integer.MAX_VALUE;\\n            for(int partition=cut;partition<len;partition++){\\n                if(isPalindrome(cut,partition,s)){\\n                    int cuts = 1 + dp[partition+1];\\n                    minCuts = Math.min(minCuts,cuts);\\n                }\\n            }\\n            dp[cut] = minCuts;\\n        }\\n        return dp[0]-1;\\n    }\\n\\n    public int minCut(String s){\\n        return fun(s);\\n    }\\n}\\n// Tabulation Code \\n// Time Complexity : ~ O(n*n), Quadratic Complexity\\n// Space Complexity : O(n)\\n```"
                    },
                    {
                        "username": "aviralagrawal",
                        "content": "Passing string by reference solved the problem in C++"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "[@Adhiraj-MNNIT](/Adhiraj-MNNIT) i got mle on this testcase"
                    },
                    {
                        "username": "f20212091",
                        "content": "This is cubic complexity ig"
                    },
                    {
                        "username": "curryGoat",
                        "content": "string must be refernce"
                    },
                    {
                        "username": "akhilg11",
                        "content": "How did you get over the TLE then?"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "same bro "
                    },
                    {
                        "username": "Kurdush",
                        "content": "here all the test cases  are given with small length there should be atleast one test case with length =5 "
                    },
                    {
                        "username": "Hitesh_9099",
                        "content": "There is mistake in the last testcase the length of the string is 1 to 2000  but the last testcase has empty string so please correct it"
                    },
                    {
                        "username": "sanjanarana101coding",
                        "content": "Hi guys,  solution video to this problem is provided here in the link.\\nSolution Link:-https://youtu.be/qmTtAbOTqcg\\n\\n"
                    },
                    {
                        "username": "bhardwajshubh",
                        "content": "Incase if you get Memory exceed try to give string as refrence in every function."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "how to do it in python there is no such concept of reference\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1. Check whether the given string is a palindrome or not. If it is, return 0 as no cuts are needed.\\n\\n2. Otherwise, use dynamic programming to solve the problem. We will define an array dp such that dp[i] represents the minimum number of cuts needed to partition the substring from index 0 to index i into palindrome substrings.\\n\\n3. To compute dp[i], we need to consider all possible partitions of the substring from index 0 to index i. For each partition, we will check if the first part of the partition is a palindrome or not. If it is, we will add 1 to the minimum number of cuts required to partition the second part of the partition, which can be computed using dp[j] + 1, where j is the index where the second part of the partition starts.\\n\\n4. We will update dp[i] to be the minimum of all the values computed in step3.\\n\\n5. Finally, we will return dp[n-1], where n is the length of the given string."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro this approach might give tle\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "it is not *the* approach, it is an approach. I did something different, so you can go with something else\nAlso, I thought you were not supposed to post solutions in discussion section. What you give here is a lot more than a tip"
                    },
                    {
                        "username": "pallavi1k1",
                        "content": "Easy Java Solution\\nMCM Varaition - Palindrome Partitioning\\n\\nclass Solution {\\n    public int minCut(String s) {\\n        int n = s.length()-1;\\n        int[][] t = new int[n+2][n+2];\\n        \\n        for(int i=0;i<n+2;i++){\\n            for(int j=0;j<n+2;j++)\\n               t[i][j]=-1;\\n        }\\n        return solve(t,s,0,n);\\n    }\\n    int solve(int[][] t,String s, int i, int j){\\n        if(i>=j)\\n            return 0;\\n    \\n        if(isPallindrom(s,i,j) ||i>=j){\\n            // t[i][j]=0;\\n            return 0;\\n        }\\n\\n        if(t[i][j]!=-1)\\n           return t[i][j];\\n\\n        int ans = Integer.MAX_VALUE;\\n        for(int k=i;k<=j-1;k++){\\n            if (isPallindrom(s, i, k))\\n \\t\\t\\t{\\n \\t\\t\\t\\tans = Math.min(ans, 1 + solve(t,s, k + 1, j));\\n \\t\\t\\t}\\n            \\n        }\\n        return t[i][j]=ans;\\n    }\\n\\n     boolean isPallindrom(String s, int i, int j){\\n         if(i==j) return true;\\n         if(i>j) return false;\\n        while( i < j){\\n            if(s.charAt(i) != s.charAt(j) )  return false; \\n            i++; j--;\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Stop posting solution in the discussion section"
                    },
                    {
                        "username": "dvakar",
                        "content": " `\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"`"
                    }
                ]
            },
            {
                "id": 1831408,
                "content": [
                    {
                        "username": "dhnanj",
                        "content": "for the test case s = \"aabaa\" the expected answer by leetcode is 0 as it is a palindrome in whole but, as far as my understanding of the question we need a partitioning which has all its substrings as palindrome and if we don\\'t partition here then the substrings \"aab\" & \"baa\" are not palindromes thus the answer for the above test case should be 2 (aa|b|aa).\\npls correct me if I\\'m wrong.\\nthanks in advance!"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Q says that after cuts , every substring generated should be palindrome, \"aabaa\" => 0 cut then this substring is palindrome itself"
                    },
                    {
                        "username": "Chandrachur",
                        "content": "The original string is also a substring of itself."
                    },
                    {
                        "username": "niketan21",
                        "content": "From what I have understood, \"every substring of the partition\" means that all the those strings which are generated by the partition. So, \"every substring of the partition\" for the partition which you mentioned (aa|b|aa) would be 3 strings \"aa\", \"b\", \"aa\". In this case, the original string is palindrome itself so the answer would be 0. \\n\\nI agree the description of the question is quite confusing, initially I myself got confused just like you."
                    },
                    {
                        "username": "akhilg11",
                        "content": "Gives TLE if you follow striver\\'s code for this question"
                    },
                    {
                        "username": "nerdstv",
                        "content": "[@shadab-malik](/shadab-malik) Thanks man, it worked!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@shadab-malik](/shadab-malik) still TLE"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "pass string by refernce even in palindrome function\\n "
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- TLE on last testcase, 36 / 37 testcases passed\\n- I mean, for real dude?\\n- Test Case 37 : \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab\"\\n- My Code: \\n```\\nclass Solution {\\n    private static boolean isPalindrome(int i, int j, String s){\\n        while(i<=j){\\n            if(s.charAt(i)!=s.charAt(j)) return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n\\n    private static int fun(String s){\\n        int len = s.length();\\n        int[] dp = new int[len+1];\\n        dp[len] = 0;\\n        for(int cut=len-1;cut>=0;cut--){\\n            int minCuts = Integer.MAX_VALUE;\\n            for(int partition=cut;partition<len;partition++){\\n                if(isPalindrome(cut,partition,s)){\\n                    int cuts = 1 + dp[partition+1];\\n                    minCuts = Math.min(minCuts,cuts);\\n                }\\n            }\\n            dp[cut] = minCuts;\\n        }\\n        return dp[0]-1;\\n    }\\n\\n    public int minCut(String s){\\n        return fun(s);\\n    }\\n}\\n// Tabulation Code \\n// Time Complexity : ~ O(n*n), Quadratic Complexity\\n// Space Complexity : O(n)\\n```"
                    },
                    {
                        "username": "aviralagrawal",
                        "content": "Passing string by reference solved the problem in C++"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "[@Adhiraj-MNNIT](/Adhiraj-MNNIT) i got mle on this testcase"
                    },
                    {
                        "username": "f20212091",
                        "content": "This is cubic complexity ig"
                    },
                    {
                        "username": "curryGoat",
                        "content": "string must be refernce"
                    },
                    {
                        "username": "akhilg11",
                        "content": "How did you get over the TLE then?"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "same bro "
                    },
                    {
                        "username": "Kurdush",
                        "content": "here all the test cases  are given with small length there should be atleast one test case with length =5 "
                    },
                    {
                        "username": "Hitesh_9099",
                        "content": "There is mistake in the last testcase the length of the string is 1 to 2000  but the last testcase has empty string so please correct it"
                    },
                    {
                        "username": "sanjanarana101coding",
                        "content": "Hi guys,  solution video to this problem is provided here in the link.\\nSolution Link:-https://youtu.be/qmTtAbOTqcg\\n\\n"
                    },
                    {
                        "username": "bhardwajshubh",
                        "content": "Incase if you get Memory exceed try to give string as refrence in every function."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "how to do it in python there is no such concept of reference\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1. Check whether the given string is a palindrome or not. If it is, return 0 as no cuts are needed.\\n\\n2. Otherwise, use dynamic programming to solve the problem. We will define an array dp such that dp[i] represents the minimum number of cuts needed to partition the substring from index 0 to index i into palindrome substrings.\\n\\n3. To compute dp[i], we need to consider all possible partitions of the substring from index 0 to index i. For each partition, we will check if the first part of the partition is a palindrome or not. If it is, we will add 1 to the minimum number of cuts required to partition the second part of the partition, which can be computed using dp[j] + 1, where j is the index where the second part of the partition starts.\\n\\n4. We will update dp[i] to be the minimum of all the values computed in step3.\\n\\n5. Finally, we will return dp[n-1], where n is the length of the given string."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro this approach might give tle\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "it is not *the* approach, it is an approach. I did something different, so you can go with something else\nAlso, I thought you were not supposed to post solutions in discussion section. What you give here is a lot more than a tip"
                    },
                    {
                        "username": "pallavi1k1",
                        "content": "Easy Java Solution\\nMCM Varaition - Palindrome Partitioning\\n\\nclass Solution {\\n    public int minCut(String s) {\\n        int n = s.length()-1;\\n        int[][] t = new int[n+2][n+2];\\n        \\n        for(int i=0;i<n+2;i++){\\n            for(int j=0;j<n+2;j++)\\n               t[i][j]=-1;\\n        }\\n        return solve(t,s,0,n);\\n    }\\n    int solve(int[][] t,String s, int i, int j){\\n        if(i>=j)\\n            return 0;\\n    \\n        if(isPallindrom(s,i,j) ||i>=j){\\n            // t[i][j]=0;\\n            return 0;\\n        }\\n\\n        if(t[i][j]!=-1)\\n           return t[i][j];\\n\\n        int ans = Integer.MAX_VALUE;\\n        for(int k=i;k<=j-1;k++){\\n            if (isPallindrom(s, i, k))\\n \\t\\t\\t{\\n \\t\\t\\t\\tans = Math.min(ans, 1 + solve(t,s, k + 1, j));\\n \\t\\t\\t}\\n            \\n        }\\n        return t[i][j]=ans;\\n    }\\n\\n     boolean isPallindrom(String s, int i, int j){\\n         if(i==j) return true;\\n         if(i>j) return false;\\n        while( i < j){\\n            if(s.charAt(i) != s.charAt(j) )  return false; \\n            i++; j--;\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Stop posting solution in the discussion section"
                    },
                    {
                        "username": "dvakar",
                        "content": " `\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"`"
                    }
                ]
            },
            {
                "id": 1772498,
                "content": [
                    {
                        "username": "dhnanj",
                        "content": "for the test case s = \"aabaa\" the expected answer by leetcode is 0 as it is a palindrome in whole but, as far as my understanding of the question we need a partitioning which has all its substrings as palindrome and if we don\\'t partition here then the substrings \"aab\" & \"baa\" are not palindromes thus the answer for the above test case should be 2 (aa|b|aa).\\npls correct me if I\\'m wrong.\\nthanks in advance!"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Q says that after cuts , every substring generated should be palindrome, \"aabaa\" => 0 cut then this substring is palindrome itself"
                    },
                    {
                        "username": "Chandrachur",
                        "content": "The original string is also a substring of itself."
                    },
                    {
                        "username": "niketan21",
                        "content": "From what I have understood, \"every substring of the partition\" means that all the those strings which are generated by the partition. So, \"every substring of the partition\" for the partition which you mentioned (aa|b|aa) would be 3 strings \"aa\", \"b\", \"aa\". In this case, the original string is palindrome itself so the answer would be 0. \\n\\nI agree the description of the question is quite confusing, initially I myself got confused just like you."
                    },
                    {
                        "username": "akhilg11",
                        "content": "Gives TLE if you follow striver\\'s code for this question"
                    },
                    {
                        "username": "nerdstv",
                        "content": "[@shadab-malik](/shadab-malik) Thanks man, it worked!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@shadab-malik](/shadab-malik) still TLE"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "pass string by refernce even in palindrome function\\n "
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- TLE on last testcase, 36 / 37 testcases passed\\n- I mean, for real dude?\\n- Test Case 37 : \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab\"\\n- My Code: \\n```\\nclass Solution {\\n    private static boolean isPalindrome(int i, int j, String s){\\n        while(i<=j){\\n            if(s.charAt(i)!=s.charAt(j)) return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n\\n    private static int fun(String s){\\n        int len = s.length();\\n        int[] dp = new int[len+1];\\n        dp[len] = 0;\\n        for(int cut=len-1;cut>=0;cut--){\\n            int minCuts = Integer.MAX_VALUE;\\n            for(int partition=cut;partition<len;partition++){\\n                if(isPalindrome(cut,partition,s)){\\n                    int cuts = 1 + dp[partition+1];\\n                    minCuts = Math.min(minCuts,cuts);\\n                }\\n            }\\n            dp[cut] = minCuts;\\n        }\\n        return dp[0]-1;\\n    }\\n\\n    public int minCut(String s){\\n        return fun(s);\\n    }\\n}\\n// Tabulation Code \\n// Time Complexity : ~ O(n*n), Quadratic Complexity\\n// Space Complexity : O(n)\\n```"
                    },
                    {
                        "username": "aviralagrawal",
                        "content": "Passing string by reference solved the problem in C++"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "[@Adhiraj-MNNIT](/Adhiraj-MNNIT) i got mle on this testcase"
                    },
                    {
                        "username": "f20212091",
                        "content": "This is cubic complexity ig"
                    },
                    {
                        "username": "curryGoat",
                        "content": "string must be refernce"
                    },
                    {
                        "username": "akhilg11",
                        "content": "How did you get over the TLE then?"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "same bro "
                    },
                    {
                        "username": "Kurdush",
                        "content": "here all the test cases  are given with small length there should be atleast one test case with length =5 "
                    },
                    {
                        "username": "Hitesh_9099",
                        "content": "There is mistake in the last testcase the length of the string is 1 to 2000  but the last testcase has empty string so please correct it"
                    },
                    {
                        "username": "sanjanarana101coding",
                        "content": "Hi guys,  solution video to this problem is provided here in the link.\\nSolution Link:-https://youtu.be/qmTtAbOTqcg\\n\\n"
                    },
                    {
                        "username": "bhardwajshubh",
                        "content": "Incase if you get Memory exceed try to give string as refrence in every function."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "how to do it in python there is no such concept of reference\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1. Check whether the given string is a palindrome or not. If it is, return 0 as no cuts are needed.\\n\\n2. Otherwise, use dynamic programming to solve the problem. We will define an array dp such that dp[i] represents the minimum number of cuts needed to partition the substring from index 0 to index i into palindrome substrings.\\n\\n3. To compute dp[i], we need to consider all possible partitions of the substring from index 0 to index i. For each partition, we will check if the first part of the partition is a palindrome or not. If it is, we will add 1 to the minimum number of cuts required to partition the second part of the partition, which can be computed using dp[j] + 1, where j is the index where the second part of the partition starts.\\n\\n4. We will update dp[i] to be the minimum of all the values computed in step3.\\n\\n5. Finally, we will return dp[n-1], where n is the length of the given string."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro this approach might give tle\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "it is not *the* approach, it is an approach. I did something different, so you can go with something else\nAlso, I thought you were not supposed to post solutions in discussion section. What you give here is a lot more than a tip"
                    },
                    {
                        "username": "pallavi1k1",
                        "content": "Easy Java Solution\\nMCM Varaition - Palindrome Partitioning\\n\\nclass Solution {\\n    public int minCut(String s) {\\n        int n = s.length()-1;\\n        int[][] t = new int[n+2][n+2];\\n        \\n        for(int i=0;i<n+2;i++){\\n            for(int j=0;j<n+2;j++)\\n               t[i][j]=-1;\\n        }\\n        return solve(t,s,0,n);\\n    }\\n    int solve(int[][] t,String s, int i, int j){\\n        if(i>=j)\\n            return 0;\\n    \\n        if(isPallindrom(s,i,j) ||i>=j){\\n            // t[i][j]=0;\\n            return 0;\\n        }\\n\\n        if(t[i][j]!=-1)\\n           return t[i][j];\\n\\n        int ans = Integer.MAX_VALUE;\\n        for(int k=i;k<=j-1;k++){\\n            if (isPallindrom(s, i, k))\\n \\t\\t\\t{\\n \\t\\t\\t\\tans = Math.min(ans, 1 + solve(t,s, k + 1, j));\\n \\t\\t\\t}\\n            \\n        }\\n        return t[i][j]=ans;\\n    }\\n\\n     boolean isPallindrom(String s, int i, int j){\\n         if(i==j) return true;\\n         if(i>j) return false;\\n        while( i < j){\\n            if(s.charAt(i) != s.charAt(j) )  return false; \\n            i++; j--;\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Stop posting solution in the discussion section"
                    },
                    {
                        "username": "dvakar",
                        "content": " `\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"`"
                    }
                ]
            },
            {
                "id": 2072886,
                "content": [
                    {
                        "username": "dhnanj",
                        "content": "for the test case s = \"aabaa\" the expected answer by leetcode is 0 as it is a palindrome in whole but, as far as my understanding of the question we need a partitioning which has all its substrings as palindrome and if we don\\'t partition here then the substrings \"aab\" & \"baa\" are not palindromes thus the answer for the above test case should be 2 (aa|b|aa).\\npls correct me if I\\'m wrong.\\nthanks in advance!"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Q says that after cuts , every substring generated should be palindrome, \"aabaa\" => 0 cut then this substring is palindrome itself"
                    },
                    {
                        "username": "Chandrachur",
                        "content": "The original string is also a substring of itself."
                    },
                    {
                        "username": "niketan21",
                        "content": "From what I have understood, \"every substring of the partition\" means that all the those strings which are generated by the partition. So, \"every substring of the partition\" for the partition which you mentioned (aa|b|aa) would be 3 strings \"aa\", \"b\", \"aa\". In this case, the original string is palindrome itself so the answer would be 0. \\n\\nI agree the description of the question is quite confusing, initially I myself got confused just like you."
                    },
                    {
                        "username": "akhilg11",
                        "content": "Gives TLE if you follow striver\\'s code for this question"
                    },
                    {
                        "username": "nerdstv",
                        "content": "[@shadab-malik](/shadab-malik) Thanks man, it worked!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@shadab-malik](/shadab-malik) still TLE"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "pass string by refernce even in palindrome function\\n "
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- TLE on last testcase, 36 / 37 testcases passed\\n- I mean, for real dude?\\n- Test Case 37 : \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab\"\\n- My Code: \\n```\\nclass Solution {\\n    private static boolean isPalindrome(int i, int j, String s){\\n        while(i<=j){\\n            if(s.charAt(i)!=s.charAt(j)) return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n\\n    private static int fun(String s){\\n        int len = s.length();\\n        int[] dp = new int[len+1];\\n        dp[len] = 0;\\n        for(int cut=len-1;cut>=0;cut--){\\n            int minCuts = Integer.MAX_VALUE;\\n            for(int partition=cut;partition<len;partition++){\\n                if(isPalindrome(cut,partition,s)){\\n                    int cuts = 1 + dp[partition+1];\\n                    minCuts = Math.min(minCuts,cuts);\\n                }\\n            }\\n            dp[cut] = minCuts;\\n        }\\n        return dp[0]-1;\\n    }\\n\\n    public int minCut(String s){\\n        return fun(s);\\n    }\\n}\\n// Tabulation Code \\n// Time Complexity : ~ O(n*n), Quadratic Complexity\\n// Space Complexity : O(n)\\n```"
                    },
                    {
                        "username": "aviralagrawal",
                        "content": "Passing string by reference solved the problem in C++"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "[@Adhiraj-MNNIT](/Adhiraj-MNNIT) i got mle on this testcase"
                    },
                    {
                        "username": "f20212091",
                        "content": "This is cubic complexity ig"
                    },
                    {
                        "username": "curryGoat",
                        "content": "string must be refernce"
                    },
                    {
                        "username": "akhilg11",
                        "content": "How did you get over the TLE then?"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "same bro "
                    },
                    {
                        "username": "Kurdush",
                        "content": "here all the test cases  are given with small length there should be atleast one test case with length =5 "
                    },
                    {
                        "username": "Hitesh_9099",
                        "content": "There is mistake in the last testcase the length of the string is 1 to 2000  but the last testcase has empty string so please correct it"
                    },
                    {
                        "username": "sanjanarana101coding",
                        "content": "Hi guys,  solution video to this problem is provided here in the link.\\nSolution Link:-https://youtu.be/qmTtAbOTqcg\\n\\n"
                    },
                    {
                        "username": "bhardwajshubh",
                        "content": "Incase if you get Memory exceed try to give string as refrence in every function."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "how to do it in python there is no such concept of reference\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1. Check whether the given string is a palindrome or not. If it is, return 0 as no cuts are needed.\\n\\n2. Otherwise, use dynamic programming to solve the problem. We will define an array dp such that dp[i] represents the minimum number of cuts needed to partition the substring from index 0 to index i into palindrome substrings.\\n\\n3. To compute dp[i], we need to consider all possible partitions of the substring from index 0 to index i. For each partition, we will check if the first part of the partition is a palindrome or not. If it is, we will add 1 to the minimum number of cuts required to partition the second part of the partition, which can be computed using dp[j] + 1, where j is the index where the second part of the partition starts.\\n\\n4. We will update dp[i] to be the minimum of all the values computed in step3.\\n\\n5. Finally, we will return dp[n-1], where n is the length of the given string."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro this approach might give tle\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "it is not *the* approach, it is an approach. I did something different, so you can go with something else\nAlso, I thought you were not supposed to post solutions in discussion section. What you give here is a lot more than a tip"
                    },
                    {
                        "username": "pallavi1k1",
                        "content": "Easy Java Solution\\nMCM Varaition - Palindrome Partitioning\\n\\nclass Solution {\\n    public int minCut(String s) {\\n        int n = s.length()-1;\\n        int[][] t = new int[n+2][n+2];\\n        \\n        for(int i=0;i<n+2;i++){\\n            for(int j=0;j<n+2;j++)\\n               t[i][j]=-1;\\n        }\\n        return solve(t,s,0,n);\\n    }\\n    int solve(int[][] t,String s, int i, int j){\\n        if(i>=j)\\n            return 0;\\n    \\n        if(isPallindrom(s,i,j) ||i>=j){\\n            // t[i][j]=0;\\n            return 0;\\n        }\\n\\n        if(t[i][j]!=-1)\\n           return t[i][j];\\n\\n        int ans = Integer.MAX_VALUE;\\n        for(int k=i;k<=j-1;k++){\\n            if (isPallindrom(s, i, k))\\n \\t\\t\\t{\\n \\t\\t\\t\\tans = Math.min(ans, 1 + solve(t,s, k + 1, j));\\n \\t\\t\\t}\\n            \\n        }\\n        return t[i][j]=ans;\\n    }\\n\\n     boolean isPallindrom(String s, int i, int j){\\n         if(i==j) return true;\\n         if(i>j) return false;\\n        while( i < j){\\n            if(s.charAt(i) != s.charAt(j) )  return false; \\n            i++; j--;\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Stop posting solution in the discussion section"
                    },
                    {
                        "username": "dvakar",
                        "content": " `\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"`"
                    }
                ]
            },
            {
                "id": 2057936,
                "content": [
                    {
                        "username": "nazimazhaan17",
                        "content": "worst test case\\n"
                    },
                    {
                        "username": "kumar_Aman1",
                        "content": "NOTE :- Remember to pass the string by reference even in your palindrome function."
                    },
                    {
                        "username": "anandA3B",
                        "content": "the test case 37 is incorrect. it is blank. not even \"\" or null works for this."
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "TLE?\\nUse recursion to check for palindrome and memoize the results."
                    },
                    {
                        "username": "HemantChoudhary",
                        "content": "Please confirm if their code if giving TLE when no input is given I don\\'t know if the test case is correct or not feels like it is incorrect  "
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "My Code is Passing close to 30TC fails on \"aaabaa\" can anyone please point out the error. Thank You\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n   bool isP(string &s, int start,int end){\\n       while(start<end){\\n       if(s[start]!=s[end]) return false;\\n       start++; end--;\\n       }\\n       return true;\\n   }\\n\\n    int f(int i,int j,string &s,vector<int>&dp){\\n         if(j==s.size()-1){\\n           \\n            if(isP(s,i,j)==true) return 0;\\n            return 1e7;\\n        }\\n        if(dp[j]<1e7) return dp[j];\\n\\n       \\n        int nt=f(i,j+1,s,dp);\\n        int t=1e7;\\n        if(isP(s,i,j)==true){\\n            t=1+f(j+1,j+1,s,dp);\\n        }\\n        int x=min(nt,t);\\n        dp[j]=min(dp[j],x); return dp[j];\\n    }\\n\\n    int minCut(string s) {\\n        int n=s.size();\\n        vector<int>dp(n,INT_MAX);\\n        return f(0,0,s,dp);\\n    }\\n};"
                    },
                    {
                        "username": "Dark_Orion",
                        "content": "Hey!\\nI think changing the line `t=1+f(j+1,j+1,s,dp);`  to `t=1+f(j,j+1,s,dp);` should work, since if you increment both, you would miss a case."
                    },
                    {
                        "username": "Abhi_Secular",
                        "content": "Can anyone let me know, why my solution is having TLE while almost similar DP solution in [this post](https://leetcode.com/problems/palindrome-partitioning-ii/solutions/590653/from-brute-force-to-top-down-dp/) is passing all test case.\nMy code:\n\n `class Solution {\n    public static boolean isPalindrome(String s,int i, int n){\n        // int n=s.length()-1;\n        while(n>i && s.charAt(n)==s.charAt(i)){\n            n--;\n            i++;\n            continue;\n        }\n        if(n<=i) return true;\n        return false;\n    }\n    public static int findMinCuts(String s, int idx, int[] dp, int[][] palDP){\n        int n = s.length();\n        if(idx==n || isPalindrome(s, 0, n-1)) return 0;\n        if(dp[idx]!=-1) return dp[idx];\n        int res = Integer.MAX_VALUE;\n        for(int i=idx;i<n;i++){\n                boolean isPal = false;\n                isPal = palDP[idx][i] == 1?true:isPalindrome(s, idx,i);\n                palDP[idx][i] = isPal==true?1:0;\n                if(isPal){\n                    res = Math.min(res,1+findMinCuts(s,i+1,dp,palDP));\n                }  \n        }\n        return dp[idx]=res;\n    }\n    public int minCut(String s) {\n        int n = s.length();\n        if(isPalindrome(s,0,n-1)) return 0;\n        int dp[] = new int[n+1];\n        Arrays.fill(dp, -1);\n        int palDP[][]=new int[n][n];\n        for(int i=0;i<n;i++){\n            Arrays.fill(palDP[i],-1);\n        }\n        int res=findMinCuts(s, 0, dp, palDP)-1;\n        // if(res==1)return res-1;\n        return res;\n    }\n}`"
                    },
                    {
                        "username": "nikks1234",
                        "content": "class Solution {\\npublic:\\n    bool checkPallindrome(string s){\\n        if (s.empty()||s.length()==1){\\n            return true;\\n        }\\n        if (s[0]!=s[s.length()-1]){\\n            return false;\\n        }\\n        return checkPallindrome(s.substr(1, s.length()-2));\\n    }\\n    int minCut(string s) {\\n        vector<int> ans(s.length(), 1);\\n        map<char, vector<int>> M;\\n        for (int i=s.length()-1; i>=0; i--){\\n            if (i+1!=s.length()){\\n                ans[i]=ans[i]+ans[i+1];\\n            }\\n            for (int j=0; j<M[s[i]].size(); j++){\\n                if (checkPallindrome(s.substr(i, M[s[i]][j]-i+1))){\\n                    if (M[s[i]][j]+1!=s.length()){\\n                        ans[i]=min(ans[i], 1+ans[M[s[i]][j]+1]);\\n                    }\\n                    else{\\n                        ans[i]=min(ans[i], 1);\\n                    }\\n                }\\n            }\\n            M[s[i]].push_back(i);\\n        }\\n        // for (int i=0; i<s.length(); i++){\\n        //     cout<<ans[i]<<\" \";\\n        // }\\n        return ans[0]-1;\\n    }\\n};\\n\\n\\nmy code gives TLE, though it does exactly the same thing as what others\\' submission, please help"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: It is a bit of an exotic method, but you could reformulate it as a variation of the Jump Game problem, which is medium level!\nIf you are curious, check out my [solution](https://leetcode.com/problems/palindrome-partitioning-ii/solutions/3408076/its-just-another-jump-game-medium-level-reformulation/)!"
                    },
                    {
                        "username": "aayush15082002",
                        "content": "The code is giving TLE. Can anyone suggest?\\n\\nclass Solution {\\npublic:\\nbool isPalindrome(string &s, int i, int j){\\n    if(i==j){\\n        return true;\\n    }\\n    if(i>j){\\n        return true;\\n    }\\n    while(i<j){\\n    \\n            if(s[i]!=s[j]) return false;\\n            i++; j--;\\n        }\\n        return true;\\n}\\nint solve(string &s, int i, int j, vector<vector<int>> &dp  ){\\n    int mn=INT_MAX;\\n    if(i>=j){\\n        return 0;\\n    }\\n    if(isPalindrome(s, i, j)){\\n        return 0;\\n    }\\n    if(dp[i][j]!=-1){\\n        return dp[i][j];\\n    }\\n    for(int k=i;k<=j-1;k++){\\n        int left, right, temp;\\n        \\n        if(isPalindrome(s,i,k)){\\n            if(isPalindrome(s,k+1,j)){\\n                temp=1;\\n            }\\n            else{\\n                if(dp[k+1][j]!=-1){\\n                    right=dp[k+1][j];\\n                    \\n                }\\n                else{\\n                    right=solve(s,k+1,j,dp);\\n                    dp[k+1][j]=right;\\n                }\\n                temp=1+0+right;\\n            }\\n        }\\n         \\n        else{\\n            if(dp[i][k]!=-1){\\n                left=dp[i][k];\\n             }\\n            else{\\n                left=solve(s,i,k,dp);\\n                dp[i][k]=left;\\n            }\\n            if(isPalindrome(s,k+1,j)){\\n                temp=1+left+0;\\n            }\\n            else{\\n                if(dp[k+1][j]!=-1){\\n                  right=dp[k+1][j];   \\n                }\\n                else{\\n                    right=solve(s,k+1,j,dp);\\n                    dp[k+1][j]=right;\\n                }\\n             temp=1+left+right;\\n            }\\n\\n        }\\n        if(temp<mn){\\n            mn=temp;\\n        }\\n        \\n    }\\n    return dp[i][j]=mn;\\n}\\n    int minCut(string s) {\\n        vector<vector<int>> dp(2001, vector<int>(2001,-1));\\n       return solve(s, 0, s.size()-1, dp);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2035802,
                "content": [
                    {
                        "username": "nazimazhaan17",
                        "content": "worst test case\\n"
                    },
                    {
                        "username": "kumar_Aman1",
                        "content": "NOTE :- Remember to pass the string by reference even in your palindrome function."
                    },
                    {
                        "username": "anandA3B",
                        "content": "the test case 37 is incorrect. it is blank. not even \"\" or null works for this."
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "TLE?\\nUse recursion to check for palindrome and memoize the results."
                    },
                    {
                        "username": "HemantChoudhary",
                        "content": "Please confirm if their code if giving TLE when no input is given I don\\'t know if the test case is correct or not feels like it is incorrect  "
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "My Code is Passing close to 30TC fails on \"aaabaa\" can anyone please point out the error. Thank You\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n   bool isP(string &s, int start,int end){\\n       while(start<end){\\n       if(s[start]!=s[end]) return false;\\n       start++; end--;\\n       }\\n       return true;\\n   }\\n\\n    int f(int i,int j,string &s,vector<int>&dp){\\n         if(j==s.size()-1){\\n           \\n            if(isP(s,i,j)==true) return 0;\\n            return 1e7;\\n        }\\n        if(dp[j]<1e7) return dp[j];\\n\\n       \\n        int nt=f(i,j+1,s,dp);\\n        int t=1e7;\\n        if(isP(s,i,j)==true){\\n            t=1+f(j+1,j+1,s,dp);\\n        }\\n        int x=min(nt,t);\\n        dp[j]=min(dp[j],x); return dp[j];\\n    }\\n\\n    int minCut(string s) {\\n        int n=s.size();\\n        vector<int>dp(n,INT_MAX);\\n        return f(0,0,s,dp);\\n    }\\n};"
                    },
                    {
                        "username": "Dark_Orion",
                        "content": "Hey!\\nI think changing the line `t=1+f(j+1,j+1,s,dp);`  to `t=1+f(j,j+1,s,dp);` should work, since if you increment both, you would miss a case."
                    },
                    {
                        "username": "Abhi_Secular",
                        "content": "Can anyone let me know, why my solution is having TLE while almost similar DP solution in [this post](https://leetcode.com/problems/palindrome-partitioning-ii/solutions/590653/from-brute-force-to-top-down-dp/) is passing all test case.\nMy code:\n\n `class Solution {\n    public static boolean isPalindrome(String s,int i, int n){\n        // int n=s.length()-1;\n        while(n>i && s.charAt(n)==s.charAt(i)){\n            n--;\n            i++;\n            continue;\n        }\n        if(n<=i) return true;\n        return false;\n    }\n    public static int findMinCuts(String s, int idx, int[] dp, int[][] palDP){\n        int n = s.length();\n        if(idx==n || isPalindrome(s, 0, n-1)) return 0;\n        if(dp[idx]!=-1) return dp[idx];\n        int res = Integer.MAX_VALUE;\n        for(int i=idx;i<n;i++){\n                boolean isPal = false;\n                isPal = palDP[idx][i] == 1?true:isPalindrome(s, idx,i);\n                palDP[idx][i] = isPal==true?1:0;\n                if(isPal){\n                    res = Math.min(res,1+findMinCuts(s,i+1,dp,palDP));\n                }  \n        }\n        return dp[idx]=res;\n    }\n    public int minCut(String s) {\n        int n = s.length();\n        if(isPalindrome(s,0,n-1)) return 0;\n        int dp[] = new int[n+1];\n        Arrays.fill(dp, -1);\n        int palDP[][]=new int[n][n];\n        for(int i=0;i<n;i++){\n            Arrays.fill(palDP[i],-1);\n        }\n        int res=findMinCuts(s, 0, dp, palDP)-1;\n        // if(res==1)return res-1;\n        return res;\n    }\n}`"
                    },
                    {
                        "username": "nikks1234",
                        "content": "class Solution {\\npublic:\\n    bool checkPallindrome(string s){\\n        if (s.empty()||s.length()==1){\\n            return true;\\n        }\\n        if (s[0]!=s[s.length()-1]){\\n            return false;\\n        }\\n        return checkPallindrome(s.substr(1, s.length()-2));\\n    }\\n    int minCut(string s) {\\n        vector<int> ans(s.length(), 1);\\n        map<char, vector<int>> M;\\n        for (int i=s.length()-1; i>=0; i--){\\n            if (i+1!=s.length()){\\n                ans[i]=ans[i]+ans[i+1];\\n            }\\n            for (int j=0; j<M[s[i]].size(); j++){\\n                if (checkPallindrome(s.substr(i, M[s[i]][j]-i+1))){\\n                    if (M[s[i]][j]+1!=s.length()){\\n                        ans[i]=min(ans[i], 1+ans[M[s[i]][j]+1]);\\n                    }\\n                    else{\\n                        ans[i]=min(ans[i], 1);\\n                    }\\n                }\\n            }\\n            M[s[i]].push_back(i);\\n        }\\n        // for (int i=0; i<s.length(); i++){\\n        //     cout<<ans[i]<<\" \";\\n        // }\\n        return ans[0]-1;\\n    }\\n};\\n\\n\\nmy code gives TLE, though it does exactly the same thing as what others\\' submission, please help"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: It is a bit of an exotic method, but you could reformulate it as a variation of the Jump Game problem, which is medium level!\nIf you are curious, check out my [solution](https://leetcode.com/problems/palindrome-partitioning-ii/solutions/3408076/its-just-another-jump-game-medium-level-reformulation/)!"
                    },
                    {
                        "username": "aayush15082002",
                        "content": "The code is giving TLE. Can anyone suggest?\\n\\nclass Solution {\\npublic:\\nbool isPalindrome(string &s, int i, int j){\\n    if(i==j){\\n        return true;\\n    }\\n    if(i>j){\\n        return true;\\n    }\\n    while(i<j){\\n    \\n            if(s[i]!=s[j]) return false;\\n            i++; j--;\\n        }\\n        return true;\\n}\\nint solve(string &s, int i, int j, vector<vector<int>> &dp  ){\\n    int mn=INT_MAX;\\n    if(i>=j){\\n        return 0;\\n    }\\n    if(isPalindrome(s, i, j)){\\n        return 0;\\n    }\\n    if(dp[i][j]!=-1){\\n        return dp[i][j];\\n    }\\n    for(int k=i;k<=j-1;k++){\\n        int left, right, temp;\\n        \\n        if(isPalindrome(s,i,k)){\\n            if(isPalindrome(s,k+1,j)){\\n                temp=1;\\n            }\\n            else{\\n                if(dp[k+1][j]!=-1){\\n                    right=dp[k+1][j];\\n                    \\n                }\\n                else{\\n                    right=solve(s,k+1,j,dp);\\n                    dp[k+1][j]=right;\\n                }\\n                temp=1+0+right;\\n            }\\n        }\\n         \\n        else{\\n            if(dp[i][k]!=-1){\\n                left=dp[i][k];\\n             }\\n            else{\\n                left=solve(s,i,k,dp);\\n                dp[i][k]=left;\\n            }\\n            if(isPalindrome(s,k+1,j)){\\n                temp=1+left+0;\\n            }\\n            else{\\n                if(dp[k+1][j]!=-1){\\n                  right=dp[k+1][j];   \\n                }\\n                else{\\n                    right=solve(s,k+1,j,dp);\\n                    dp[k+1][j]=right;\\n                }\\n             temp=1+left+right;\\n            }\\n\\n        }\\n        if(temp<mn){\\n            mn=temp;\\n        }\\n        \\n    }\\n    return dp[i][j]=mn;\\n}\\n    int minCut(string s) {\\n        vector<vector<int>> dp(2001, vector<int>(2001,-1));\\n       return solve(s, 0, s.size()-1, dp);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1999991,
                "content": [
                    {
                        "username": "nazimazhaan17",
                        "content": "worst test case\\n"
                    },
                    {
                        "username": "kumar_Aman1",
                        "content": "NOTE :- Remember to pass the string by reference even in your palindrome function."
                    },
                    {
                        "username": "anandA3B",
                        "content": "the test case 37 is incorrect. it is blank. not even \"\" or null works for this."
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "TLE?\\nUse recursion to check for palindrome and memoize the results."
                    },
                    {
                        "username": "HemantChoudhary",
                        "content": "Please confirm if their code if giving TLE when no input is given I don\\'t know if the test case is correct or not feels like it is incorrect  "
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "My Code is Passing close to 30TC fails on \"aaabaa\" can anyone please point out the error. Thank You\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n   bool isP(string &s, int start,int end){\\n       while(start<end){\\n       if(s[start]!=s[end]) return false;\\n       start++; end--;\\n       }\\n       return true;\\n   }\\n\\n    int f(int i,int j,string &s,vector<int>&dp){\\n         if(j==s.size()-1){\\n           \\n            if(isP(s,i,j)==true) return 0;\\n            return 1e7;\\n        }\\n        if(dp[j]<1e7) return dp[j];\\n\\n       \\n        int nt=f(i,j+1,s,dp);\\n        int t=1e7;\\n        if(isP(s,i,j)==true){\\n            t=1+f(j+1,j+1,s,dp);\\n        }\\n        int x=min(nt,t);\\n        dp[j]=min(dp[j],x); return dp[j];\\n    }\\n\\n    int minCut(string s) {\\n        int n=s.size();\\n        vector<int>dp(n,INT_MAX);\\n        return f(0,0,s,dp);\\n    }\\n};"
                    },
                    {
                        "username": "Dark_Orion",
                        "content": "Hey!\\nI think changing the line `t=1+f(j+1,j+1,s,dp);`  to `t=1+f(j,j+1,s,dp);` should work, since if you increment both, you would miss a case."
                    },
                    {
                        "username": "Abhi_Secular",
                        "content": "Can anyone let me know, why my solution is having TLE while almost similar DP solution in [this post](https://leetcode.com/problems/palindrome-partitioning-ii/solutions/590653/from-brute-force-to-top-down-dp/) is passing all test case.\nMy code:\n\n `class Solution {\n    public static boolean isPalindrome(String s,int i, int n){\n        // int n=s.length()-1;\n        while(n>i && s.charAt(n)==s.charAt(i)){\n            n--;\n            i++;\n            continue;\n        }\n        if(n<=i) return true;\n        return false;\n    }\n    public static int findMinCuts(String s, int idx, int[] dp, int[][] palDP){\n        int n = s.length();\n        if(idx==n || isPalindrome(s, 0, n-1)) return 0;\n        if(dp[idx]!=-1) return dp[idx];\n        int res = Integer.MAX_VALUE;\n        for(int i=idx;i<n;i++){\n                boolean isPal = false;\n                isPal = palDP[idx][i] == 1?true:isPalindrome(s, idx,i);\n                palDP[idx][i] = isPal==true?1:0;\n                if(isPal){\n                    res = Math.min(res,1+findMinCuts(s,i+1,dp,palDP));\n                }  \n        }\n        return dp[idx]=res;\n    }\n    public int minCut(String s) {\n        int n = s.length();\n        if(isPalindrome(s,0,n-1)) return 0;\n        int dp[] = new int[n+1];\n        Arrays.fill(dp, -1);\n        int palDP[][]=new int[n][n];\n        for(int i=0;i<n;i++){\n            Arrays.fill(palDP[i],-1);\n        }\n        int res=findMinCuts(s, 0, dp, palDP)-1;\n        // if(res==1)return res-1;\n        return res;\n    }\n}`"
                    },
                    {
                        "username": "nikks1234",
                        "content": "class Solution {\\npublic:\\n    bool checkPallindrome(string s){\\n        if (s.empty()||s.length()==1){\\n            return true;\\n        }\\n        if (s[0]!=s[s.length()-1]){\\n            return false;\\n        }\\n        return checkPallindrome(s.substr(1, s.length()-2));\\n    }\\n    int minCut(string s) {\\n        vector<int> ans(s.length(), 1);\\n        map<char, vector<int>> M;\\n        for (int i=s.length()-1; i>=0; i--){\\n            if (i+1!=s.length()){\\n                ans[i]=ans[i]+ans[i+1];\\n            }\\n            for (int j=0; j<M[s[i]].size(); j++){\\n                if (checkPallindrome(s.substr(i, M[s[i]][j]-i+1))){\\n                    if (M[s[i]][j]+1!=s.length()){\\n                        ans[i]=min(ans[i], 1+ans[M[s[i]][j]+1]);\\n                    }\\n                    else{\\n                        ans[i]=min(ans[i], 1);\\n                    }\\n                }\\n            }\\n            M[s[i]].push_back(i);\\n        }\\n        // for (int i=0; i<s.length(); i++){\\n        //     cout<<ans[i]<<\" \";\\n        // }\\n        return ans[0]-1;\\n    }\\n};\\n\\n\\nmy code gives TLE, though it does exactly the same thing as what others\\' submission, please help"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: It is a bit of an exotic method, but you could reformulate it as a variation of the Jump Game problem, which is medium level!\nIf you are curious, check out my [solution](https://leetcode.com/problems/palindrome-partitioning-ii/solutions/3408076/its-just-another-jump-game-medium-level-reformulation/)!"
                    },
                    {
                        "username": "aayush15082002",
                        "content": "The code is giving TLE. Can anyone suggest?\\n\\nclass Solution {\\npublic:\\nbool isPalindrome(string &s, int i, int j){\\n    if(i==j){\\n        return true;\\n    }\\n    if(i>j){\\n        return true;\\n    }\\n    while(i<j){\\n    \\n            if(s[i]!=s[j]) return false;\\n            i++; j--;\\n        }\\n        return true;\\n}\\nint solve(string &s, int i, int j, vector<vector<int>> &dp  ){\\n    int mn=INT_MAX;\\n    if(i>=j){\\n        return 0;\\n    }\\n    if(isPalindrome(s, i, j)){\\n        return 0;\\n    }\\n    if(dp[i][j]!=-1){\\n        return dp[i][j];\\n    }\\n    for(int k=i;k<=j-1;k++){\\n        int left, right, temp;\\n        \\n        if(isPalindrome(s,i,k)){\\n            if(isPalindrome(s,k+1,j)){\\n                temp=1;\\n            }\\n            else{\\n                if(dp[k+1][j]!=-1){\\n                    right=dp[k+1][j];\\n                    \\n                }\\n                else{\\n                    right=solve(s,k+1,j,dp);\\n                    dp[k+1][j]=right;\\n                }\\n                temp=1+0+right;\\n            }\\n        }\\n         \\n        else{\\n            if(dp[i][k]!=-1){\\n                left=dp[i][k];\\n             }\\n            else{\\n                left=solve(s,i,k,dp);\\n                dp[i][k]=left;\\n            }\\n            if(isPalindrome(s,k+1,j)){\\n                temp=1+left+0;\\n            }\\n            else{\\n                if(dp[k+1][j]!=-1){\\n                  right=dp[k+1][j];   \\n                }\\n                else{\\n                    right=solve(s,k+1,j,dp);\\n                    dp[k+1][j]=right;\\n                }\\n             temp=1+left+right;\\n            }\\n\\n        }\\n        if(temp<mn){\\n            mn=temp;\\n        }\\n        \\n    }\\n    return dp[i][j]=mn;\\n}\\n    int minCut(string s) {\\n        vector<vector<int>> dp(2001, vector<int>(2001,-1));\\n       return solve(s, 0, s.size()-1, dp);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1996032,
                "content": [
                    {
                        "username": "nazimazhaan17",
                        "content": "worst test case\\n"
                    },
                    {
                        "username": "kumar_Aman1",
                        "content": "NOTE :- Remember to pass the string by reference even in your palindrome function."
                    },
                    {
                        "username": "anandA3B",
                        "content": "the test case 37 is incorrect. it is blank. not even \"\" or null works for this."
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "TLE?\\nUse recursion to check for palindrome and memoize the results."
                    },
                    {
                        "username": "HemantChoudhary",
                        "content": "Please confirm if their code if giving TLE when no input is given I don\\'t know if the test case is correct or not feels like it is incorrect  "
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "My Code is Passing close to 30TC fails on \"aaabaa\" can anyone please point out the error. Thank You\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n   bool isP(string &s, int start,int end){\\n       while(start<end){\\n       if(s[start]!=s[end]) return false;\\n       start++; end--;\\n       }\\n       return true;\\n   }\\n\\n    int f(int i,int j,string &s,vector<int>&dp){\\n         if(j==s.size()-1){\\n           \\n            if(isP(s,i,j)==true) return 0;\\n            return 1e7;\\n        }\\n        if(dp[j]<1e7) return dp[j];\\n\\n       \\n        int nt=f(i,j+1,s,dp);\\n        int t=1e7;\\n        if(isP(s,i,j)==true){\\n            t=1+f(j+1,j+1,s,dp);\\n        }\\n        int x=min(nt,t);\\n        dp[j]=min(dp[j],x); return dp[j];\\n    }\\n\\n    int minCut(string s) {\\n        int n=s.size();\\n        vector<int>dp(n,INT_MAX);\\n        return f(0,0,s,dp);\\n    }\\n};"
                    },
                    {
                        "username": "Dark_Orion",
                        "content": "Hey!\\nI think changing the line `t=1+f(j+1,j+1,s,dp);`  to `t=1+f(j,j+1,s,dp);` should work, since if you increment both, you would miss a case."
                    },
                    {
                        "username": "Abhi_Secular",
                        "content": "Can anyone let me know, why my solution is having TLE while almost similar DP solution in [this post](https://leetcode.com/problems/palindrome-partitioning-ii/solutions/590653/from-brute-force-to-top-down-dp/) is passing all test case.\nMy code:\n\n `class Solution {\n    public static boolean isPalindrome(String s,int i, int n){\n        // int n=s.length()-1;\n        while(n>i && s.charAt(n)==s.charAt(i)){\n            n--;\n            i++;\n            continue;\n        }\n        if(n<=i) return true;\n        return false;\n    }\n    public static int findMinCuts(String s, int idx, int[] dp, int[][] palDP){\n        int n = s.length();\n        if(idx==n || isPalindrome(s, 0, n-1)) return 0;\n        if(dp[idx]!=-1) return dp[idx];\n        int res = Integer.MAX_VALUE;\n        for(int i=idx;i<n;i++){\n                boolean isPal = false;\n                isPal = palDP[idx][i] == 1?true:isPalindrome(s, idx,i);\n                palDP[idx][i] = isPal==true?1:0;\n                if(isPal){\n                    res = Math.min(res,1+findMinCuts(s,i+1,dp,palDP));\n                }  \n        }\n        return dp[idx]=res;\n    }\n    public int minCut(String s) {\n        int n = s.length();\n        if(isPalindrome(s,0,n-1)) return 0;\n        int dp[] = new int[n+1];\n        Arrays.fill(dp, -1);\n        int palDP[][]=new int[n][n];\n        for(int i=0;i<n;i++){\n            Arrays.fill(palDP[i],-1);\n        }\n        int res=findMinCuts(s, 0, dp, palDP)-1;\n        // if(res==1)return res-1;\n        return res;\n    }\n}`"
                    },
                    {
                        "username": "nikks1234",
                        "content": "class Solution {\\npublic:\\n    bool checkPallindrome(string s){\\n        if (s.empty()||s.length()==1){\\n            return true;\\n        }\\n        if (s[0]!=s[s.length()-1]){\\n            return false;\\n        }\\n        return checkPallindrome(s.substr(1, s.length()-2));\\n    }\\n    int minCut(string s) {\\n        vector<int> ans(s.length(), 1);\\n        map<char, vector<int>> M;\\n        for (int i=s.length()-1; i>=0; i--){\\n            if (i+1!=s.length()){\\n                ans[i]=ans[i]+ans[i+1];\\n            }\\n            for (int j=0; j<M[s[i]].size(); j++){\\n                if (checkPallindrome(s.substr(i, M[s[i]][j]-i+1))){\\n                    if (M[s[i]][j]+1!=s.length()){\\n                        ans[i]=min(ans[i], 1+ans[M[s[i]][j]+1]);\\n                    }\\n                    else{\\n                        ans[i]=min(ans[i], 1);\\n                    }\\n                }\\n            }\\n            M[s[i]].push_back(i);\\n        }\\n        // for (int i=0; i<s.length(); i++){\\n        //     cout<<ans[i]<<\" \";\\n        // }\\n        return ans[0]-1;\\n    }\\n};\\n\\n\\nmy code gives TLE, though it does exactly the same thing as what others\\' submission, please help"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: It is a bit of an exotic method, but you could reformulate it as a variation of the Jump Game problem, which is medium level!\nIf you are curious, check out my [solution](https://leetcode.com/problems/palindrome-partitioning-ii/solutions/3408076/its-just-another-jump-game-medium-level-reformulation/)!"
                    },
                    {
                        "username": "aayush15082002",
                        "content": "The code is giving TLE. Can anyone suggest?\\n\\nclass Solution {\\npublic:\\nbool isPalindrome(string &s, int i, int j){\\n    if(i==j){\\n        return true;\\n    }\\n    if(i>j){\\n        return true;\\n    }\\n    while(i<j){\\n    \\n            if(s[i]!=s[j]) return false;\\n            i++; j--;\\n        }\\n        return true;\\n}\\nint solve(string &s, int i, int j, vector<vector<int>> &dp  ){\\n    int mn=INT_MAX;\\n    if(i>=j){\\n        return 0;\\n    }\\n    if(isPalindrome(s, i, j)){\\n        return 0;\\n    }\\n    if(dp[i][j]!=-1){\\n        return dp[i][j];\\n    }\\n    for(int k=i;k<=j-1;k++){\\n        int left, right, temp;\\n        \\n        if(isPalindrome(s,i,k)){\\n            if(isPalindrome(s,k+1,j)){\\n                temp=1;\\n            }\\n            else{\\n                if(dp[k+1][j]!=-1){\\n                    right=dp[k+1][j];\\n                    \\n                }\\n                else{\\n                    right=solve(s,k+1,j,dp);\\n                    dp[k+1][j]=right;\\n                }\\n                temp=1+0+right;\\n            }\\n        }\\n         \\n        else{\\n            if(dp[i][k]!=-1){\\n                left=dp[i][k];\\n             }\\n            else{\\n                left=solve(s,i,k,dp);\\n                dp[i][k]=left;\\n            }\\n            if(isPalindrome(s,k+1,j)){\\n                temp=1+left+0;\\n            }\\n            else{\\n                if(dp[k+1][j]!=-1){\\n                  right=dp[k+1][j];   \\n                }\\n                else{\\n                    right=solve(s,k+1,j,dp);\\n                    dp[k+1][j]=right;\\n                }\\n             temp=1+left+right;\\n            }\\n\\n        }\\n        if(temp<mn){\\n            mn=temp;\\n        }\\n        \\n    }\\n    return dp[i][j]=mn;\\n}\\n    int minCut(string s) {\\n        vector<vector<int>> dp(2001, vector<int>(2001,-1));\\n       return solve(s, 0, s.size()-1, dp);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1986344,
                "content": [
                    {
                        "username": "nazimazhaan17",
                        "content": "worst test case\\n"
                    },
                    {
                        "username": "kumar_Aman1",
                        "content": "NOTE :- Remember to pass the string by reference even in your palindrome function."
                    },
                    {
                        "username": "anandA3B",
                        "content": "the test case 37 is incorrect. it is blank. not even \"\" or null works for this."
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "TLE?\\nUse recursion to check for palindrome and memoize the results."
                    },
                    {
                        "username": "HemantChoudhary",
                        "content": "Please confirm if their code if giving TLE when no input is given I don\\'t know if the test case is correct or not feels like it is incorrect  "
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "My Code is Passing close to 30TC fails on \"aaabaa\" can anyone please point out the error. Thank You\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n   bool isP(string &s, int start,int end){\\n       while(start<end){\\n       if(s[start]!=s[end]) return false;\\n       start++; end--;\\n       }\\n       return true;\\n   }\\n\\n    int f(int i,int j,string &s,vector<int>&dp){\\n         if(j==s.size()-1){\\n           \\n            if(isP(s,i,j)==true) return 0;\\n            return 1e7;\\n        }\\n        if(dp[j]<1e7) return dp[j];\\n\\n       \\n        int nt=f(i,j+1,s,dp);\\n        int t=1e7;\\n        if(isP(s,i,j)==true){\\n            t=1+f(j+1,j+1,s,dp);\\n        }\\n        int x=min(nt,t);\\n        dp[j]=min(dp[j],x); return dp[j];\\n    }\\n\\n    int minCut(string s) {\\n        int n=s.size();\\n        vector<int>dp(n,INT_MAX);\\n        return f(0,0,s,dp);\\n    }\\n};"
                    },
                    {
                        "username": "Dark_Orion",
                        "content": "Hey!\\nI think changing the line `t=1+f(j+1,j+1,s,dp);`  to `t=1+f(j,j+1,s,dp);` should work, since if you increment both, you would miss a case."
                    },
                    {
                        "username": "Abhi_Secular",
                        "content": "Can anyone let me know, why my solution is having TLE while almost similar DP solution in [this post](https://leetcode.com/problems/palindrome-partitioning-ii/solutions/590653/from-brute-force-to-top-down-dp/) is passing all test case.\nMy code:\n\n `class Solution {\n    public static boolean isPalindrome(String s,int i, int n){\n        // int n=s.length()-1;\n        while(n>i && s.charAt(n)==s.charAt(i)){\n            n--;\n            i++;\n            continue;\n        }\n        if(n<=i) return true;\n        return false;\n    }\n    public static int findMinCuts(String s, int idx, int[] dp, int[][] palDP){\n        int n = s.length();\n        if(idx==n || isPalindrome(s, 0, n-1)) return 0;\n        if(dp[idx]!=-1) return dp[idx];\n        int res = Integer.MAX_VALUE;\n        for(int i=idx;i<n;i++){\n                boolean isPal = false;\n                isPal = palDP[idx][i] == 1?true:isPalindrome(s, idx,i);\n                palDP[idx][i] = isPal==true?1:0;\n                if(isPal){\n                    res = Math.min(res,1+findMinCuts(s,i+1,dp,palDP));\n                }  \n        }\n        return dp[idx]=res;\n    }\n    public int minCut(String s) {\n        int n = s.length();\n        if(isPalindrome(s,0,n-1)) return 0;\n        int dp[] = new int[n+1];\n        Arrays.fill(dp, -1);\n        int palDP[][]=new int[n][n];\n        for(int i=0;i<n;i++){\n            Arrays.fill(palDP[i],-1);\n        }\n        int res=findMinCuts(s, 0, dp, palDP)-1;\n        // if(res==1)return res-1;\n        return res;\n    }\n}`"
                    },
                    {
                        "username": "nikks1234",
                        "content": "class Solution {\\npublic:\\n    bool checkPallindrome(string s){\\n        if (s.empty()||s.length()==1){\\n            return true;\\n        }\\n        if (s[0]!=s[s.length()-1]){\\n            return false;\\n        }\\n        return checkPallindrome(s.substr(1, s.length()-2));\\n    }\\n    int minCut(string s) {\\n        vector<int> ans(s.length(), 1);\\n        map<char, vector<int>> M;\\n        for (int i=s.length()-1; i>=0; i--){\\n            if (i+1!=s.length()){\\n                ans[i]=ans[i]+ans[i+1];\\n            }\\n            for (int j=0; j<M[s[i]].size(); j++){\\n                if (checkPallindrome(s.substr(i, M[s[i]][j]-i+1))){\\n                    if (M[s[i]][j]+1!=s.length()){\\n                        ans[i]=min(ans[i], 1+ans[M[s[i]][j]+1]);\\n                    }\\n                    else{\\n                        ans[i]=min(ans[i], 1);\\n                    }\\n                }\\n            }\\n            M[s[i]].push_back(i);\\n        }\\n        // for (int i=0; i<s.length(); i++){\\n        //     cout<<ans[i]<<\" \";\\n        // }\\n        return ans[0]-1;\\n    }\\n};\\n\\n\\nmy code gives TLE, though it does exactly the same thing as what others\\' submission, please help"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: It is a bit of an exotic method, but you could reformulate it as a variation of the Jump Game problem, which is medium level!\nIf you are curious, check out my [solution](https://leetcode.com/problems/palindrome-partitioning-ii/solutions/3408076/its-just-another-jump-game-medium-level-reformulation/)!"
                    },
                    {
                        "username": "aayush15082002",
                        "content": "The code is giving TLE. Can anyone suggest?\\n\\nclass Solution {\\npublic:\\nbool isPalindrome(string &s, int i, int j){\\n    if(i==j){\\n        return true;\\n    }\\n    if(i>j){\\n        return true;\\n    }\\n    while(i<j){\\n    \\n            if(s[i]!=s[j]) return false;\\n            i++; j--;\\n        }\\n        return true;\\n}\\nint solve(string &s, int i, int j, vector<vector<int>> &dp  ){\\n    int mn=INT_MAX;\\n    if(i>=j){\\n        return 0;\\n    }\\n    if(isPalindrome(s, i, j)){\\n        return 0;\\n    }\\n    if(dp[i][j]!=-1){\\n        return dp[i][j];\\n    }\\n    for(int k=i;k<=j-1;k++){\\n        int left, right, temp;\\n        \\n        if(isPalindrome(s,i,k)){\\n            if(isPalindrome(s,k+1,j)){\\n                temp=1;\\n            }\\n            else{\\n                if(dp[k+1][j]!=-1){\\n                    right=dp[k+1][j];\\n                    \\n                }\\n                else{\\n                    right=solve(s,k+1,j,dp);\\n                    dp[k+1][j]=right;\\n                }\\n                temp=1+0+right;\\n            }\\n        }\\n         \\n        else{\\n            if(dp[i][k]!=-1){\\n                left=dp[i][k];\\n             }\\n            else{\\n                left=solve(s,i,k,dp);\\n                dp[i][k]=left;\\n            }\\n            if(isPalindrome(s,k+1,j)){\\n                temp=1+left+0;\\n            }\\n            else{\\n                if(dp[k+1][j]!=-1){\\n                  right=dp[k+1][j];   \\n                }\\n                else{\\n                    right=solve(s,k+1,j,dp);\\n                    dp[k+1][j]=right;\\n                }\\n             temp=1+left+right;\\n            }\\n\\n        }\\n        if(temp<mn){\\n            mn=temp;\\n        }\\n        \\n    }\\n    return dp[i][j]=mn;\\n}\\n    int minCut(string s) {\\n        vector<vector<int>> dp(2001, vector<int>(2001,-1));\\n       return solve(s, 0, s.size()-1, dp);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1968932,
                "content": [
                    {
                        "username": "nazimazhaan17",
                        "content": "worst test case\\n"
                    },
                    {
                        "username": "kumar_Aman1",
                        "content": "NOTE :- Remember to pass the string by reference even in your palindrome function."
                    },
                    {
                        "username": "anandA3B",
                        "content": "the test case 37 is incorrect. it is blank. not even \"\" or null works for this."
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "TLE?\\nUse recursion to check for palindrome and memoize the results."
                    },
                    {
                        "username": "HemantChoudhary",
                        "content": "Please confirm if their code if giving TLE when no input is given I don\\'t know if the test case is correct or not feels like it is incorrect  "
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "My Code is Passing close to 30TC fails on \"aaabaa\" can anyone please point out the error. Thank You\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n   bool isP(string &s, int start,int end){\\n       while(start<end){\\n       if(s[start]!=s[end]) return false;\\n       start++; end--;\\n       }\\n       return true;\\n   }\\n\\n    int f(int i,int j,string &s,vector<int>&dp){\\n         if(j==s.size()-1){\\n           \\n            if(isP(s,i,j)==true) return 0;\\n            return 1e7;\\n        }\\n        if(dp[j]<1e7) return dp[j];\\n\\n       \\n        int nt=f(i,j+1,s,dp);\\n        int t=1e7;\\n        if(isP(s,i,j)==true){\\n            t=1+f(j+1,j+1,s,dp);\\n        }\\n        int x=min(nt,t);\\n        dp[j]=min(dp[j],x); return dp[j];\\n    }\\n\\n    int minCut(string s) {\\n        int n=s.size();\\n        vector<int>dp(n,INT_MAX);\\n        return f(0,0,s,dp);\\n    }\\n};"
                    },
                    {
                        "username": "Dark_Orion",
                        "content": "Hey!\\nI think changing the line `t=1+f(j+1,j+1,s,dp);`  to `t=1+f(j,j+1,s,dp);` should work, since if you increment both, you would miss a case."
                    },
                    {
                        "username": "Abhi_Secular",
                        "content": "Can anyone let me know, why my solution is having TLE while almost similar DP solution in [this post](https://leetcode.com/problems/palindrome-partitioning-ii/solutions/590653/from-brute-force-to-top-down-dp/) is passing all test case.\nMy code:\n\n `class Solution {\n    public static boolean isPalindrome(String s,int i, int n){\n        // int n=s.length()-1;\n        while(n>i && s.charAt(n)==s.charAt(i)){\n            n--;\n            i++;\n            continue;\n        }\n        if(n<=i) return true;\n        return false;\n    }\n    public static int findMinCuts(String s, int idx, int[] dp, int[][] palDP){\n        int n = s.length();\n        if(idx==n || isPalindrome(s, 0, n-1)) return 0;\n        if(dp[idx]!=-1) return dp[idx];\n        int res = Integer.MAX_VALUE;\n        for(int i=idx;i<n;i++){\n                boolean isPal = false;\n                isPal = palDP[idx][i] == 1?true:isPalindrome(s, idx,i);\n                palDP[idx][i] = isPal==true?1:0;\n                if(isPal){\n                    res = Math.min(res,1+findMinCuts(s,i+1,dp,palDP));\n                }  \n        }\n        return dp[idx]=res;\n    }\n    public int minCut(String s) {\n        int n = s.length();\n        if(isPalindrome(s,0,n-1)) return 0;\n        int dp[] = new int[n+1];\n        Arrays.fill(dp, -1);\n        int palDP[][]=new int[n][n];\n        for(int i=0;i<n;i++){\n            Arrays.fill(palDP[i],-1);\n        }\n        int res=findMinCuts(s, 0, dp, palDP)-1;\n        // if(res==1)return res-1;\n        return res;\n    }\n}`"
                    },
                    {
                        "username": "nikks1234",
                        "content": "class Solution {\\npublic:\\n    bool checkPallindrome(string s){\\n        if (s.empty()||s.length()==1){\\n            return true;\\n        }\\n        if (s[0]!=s[s.length()-1]){\\n            return false;\\n        }\\n        return checkPallindrome(s.substr(1, s.length()-2));\\n    }\\n    int minCut(string s) {\\n        vector<int> ans(s.length(), 1);\\n        map<char, vector<int>> M;\\n        for (int i=s.length()-1; i>=0; i--){\\n            if (i+1!=s.length()){\\n                ans[i]=ans[i]+ans[i+1];\\n            }\\n            for (int j=0; j<M[s[i]].size(); j++){\\n                if (checkPallindrome(s.substr(i, M[s[i]][j]-i+1))){\\n                    if (M[s[i]][j]+1!=s.length()){\\n                        ans[i]=min(ans[i], 1+ans[M[s[i]][j]+1]);\\n                    }\\n                    else{\\n                        ans[i]=min(ans[i], 1);\\n                    }\\n                }\\n            }\\n            M[s[i]].push_back(i);\\n        }\\n        // for (int i=0; i<s.length(); i++){\\n        //     cout<<ans[i]<<\" \";\\n        // }\\n        return ans[0]-1;\\n    }\\n};\\n\\n\\nmy code gives TLE, though it does exactly the same thing as what others\\' submission, please help"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: It is a bit of an exotic method, but you could reformulate it as a variation of the Jump Game problem, which is medium level!\nIf you are curious, check out my [solution](https://leetcode.com/problems/palindrome-partitioning-ii/solutions/3408076/its-just-another-jump-game-medium-level-reformulation/)!"
                    },
                    {
                        "username": "aayush15082002",
                        "content": "The code is giving TLE. Can anyone suggest?\\n\\nclass Solution {\\npublic:\\nbool isPalindrome(string &s, int i, int j){\\n    if(i==j){\\n        return true;\\n    }\\n    if(i>j){\\n        return true;\\n    }\\n    while(i<j){\\n    \\n            if(s[i]!=s[j]) return false;\\n            i++; j--;\\n        }\\n        return true;\\n}\\nint solve(string &s, int i, int j, vector<vector<int>> &dp  ){\\n    int mn=INT_MAX;\\n    if(i>=j){\\n        return 0;\\n    }\\n    if(isPalindrome(s, i, j)){\\n        return 0;\\n    }\\n    if(dp[i][j]!=-1){\\n        return dp[i][j];\\n    }\\n    for(int k=i;k<=j-1;k++){\\n        int left, right, temp;\\n        \\n        if(isPalindrome(s,i,k)){\\n            if(isPalindrome(s,k+1,j)){\\n                temp=1;\\n            }\\n            else{\\n                if(dp[k+1][j]!=-1){\\n                    right=dp[k+1][j];\\n                    \\n                }\\n                else{\\n                    right=solve(s,k+1,j,dp);\\n                    dp[k+1][j]=right;\\n                }\\n                temp=1+0+right;\\n            }\\n        }\\n         \\n        else{\\n            if(dp[i][k]!=-1){\\n                left=dp[i][k];\\n             }\\n            else{\\n                left=solve(s,i,k,dp);\\n                dp[i][k]=left;\\n            }\\n            if(isPalindrome(s,k+1,j)){\\n                temp=1+left+0;\\n            }\\n            else{\\n                if(dp[k+1][j]!=-1){\\n                  right=dp[k+1][j];   \\n                }\\n                else{\\n                    right=solve(s,k+1,j,dp);\\n                    dp[k+1][j]=right;\\n                }\\n             temp=1+left+right;\\n            }\\n\\n        }\\n        if(temp<mn){\\n            mn=temp;\\n        }\\n        \\n    }\\n    return dp[i][j]=mn;\\n}\\n    int minCut(string s) {\\n        vector<vector<int>> dp(2001, vector<int>(2001,-1));\\n       return solve(s, 0, s.size()-1, dp);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1946849,
                "content": [
                    {
                        "username": "nazimazhaan17",
                        "content": "worst test case\\n"
                    },
                    {
                        "username": "kumar_Aman1",
                        "content": "NOTE :- Remember to pass the string by reference even in your palindrome function."
                    },
                    {
                        "username": "anandA3B",
                        "content": "the test case 37 is incorrect. it is blank. not even \"\" or null works for this."
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "TLE?\\nUse recursion to check for palindrome and memoize the results."
                    },
                    {
                        "username": "HemantChoudhary",
                        "content": "Please confirm if their code if giving TLE when no input is given I don\\'t know if the test case is correct or not feels like it is incorrect  "
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "My Code is Passing close to 30TC fails on \"aaabaa\" can anyone please point out the error. Thank You\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n   bool isP(string &s, int start,int end){\\n       while(start<end){\\n       if(s[start]!=s[end]) return false;\\n       start++; end--;\\n       }\\n       return true;\\n   }\\n\\n    int f(int i,int j,string &s,vector<int>&dp){\\n         if(j==s.size()-1){\\n           \\n            if(isP(s,i,j)==true) return 0;\\n            return 1e7;\\n        }\\n        if(dp[j]<1e7) return dp[j];\\n\\n       \\n        int nt=f(i,j+1,s,dp);\\n        int t=1e7;\\n        if(isP(s,i,j)==true){\\n            t=1+f(j+1,j+1,s,dp);\\n        }\\n        int x=min(nt,t);\\n        dp[j]=min(dp[j],x); return dp[j];\\n    }\\n\\n    int minCut(string s) {\\n        int n=s.size();\\n        vector<int>dp(n,INT_MAX);\\n        return f(0,0,s,dp);\\n    }\\n};"
                    },
                    {
                        "username": "Dark_Orion",
                        "content": "Hey!\\nI think changing the line `t=1+f(j+1,j+1,s,dp);`  to `t=1+f(j,j+1,s,dp);` should work, since if you increment both, you would miss a case."
                    },
                    {
                        "username": "Abhi_Secular",
                        "content": "Can anyone let me know, why my solution is having TLE while almost similar DP solution in [this post](https://leetcode.com/problems/palindrome-partitioning-ii/solutions/590653/from-brute-force-to-top-down-dp/) is passing all test case.\nMy code:\n\n `class Solution {\n    public static boolean isPalindrome(String s,int i, int n){\n        // int n=s.length()-1;\n        while(n>i && s.charAt(n)==s.charAt(i)){\n            n--;\n            i++;\n            continue;\n        }\n        if(n<=i) return true;\n        return false;\n    }\n    public static int findMinCuts(String s, int idx, int[] dp, int[][] palDP){\n        int n = s.length();\n        if(idx==n || isPalindrome(s, 0, n-1)) return 0;\n        if(dp[idx]!=-1) return dp[idx];\n        int res = Integer.MAX_VALUE;\n        for(int i=idx;i<n;i++){\n                boolean isPal = false;\n                isPal = palDP[idx][i] == 1?true:isPalindrome(s, idx,i);\n                palDP[idx][i] = isPal==true?1:0;\n                if(isPal){\n                    res = Math.min(res,1+findMinCuts(s,i+1,dp,palDP));\n                }  \n        }\n        return dp[idx]=res;\n    }\n    public int minCut(String s) {\n        int n = s.length();\n        if(isPalindrome(s,0,n-1)) return 0;\n        int dp[] = new int[n+1];\n        Arrays.fill(dp, -1);\n        int palDP[][]=new int[n][n];\n        for(int i=0;i<n;i++){\n            Arrays.fill(palDP[i],-1);\n        }\n        int res=findMinCuts(s, 0, dp, palDP)-1;\n        // if(res==1)return res-1;\n        return res;\n    }\n}`"
                    },
                    {
                        "username": "nikks1234",
                        "content": "class Solution {\\npublic:\\n    bool checkPallindrome(string s){\\n        if (s.empty()||s.length()==1){\\n            return true;\\n        }\\n        if (s[0]!=s[s.length()-1]){\\n            return false;\\n        }\\n        return checkPallindrome(s.substr(1, s.length()-2));\\n    }\\n    int minCut(string s) {\\n        vector<int> ans(s.length(), 1);\\n        map<char, vector<int>> M;\\n        for (int i=s.length()-1; i>=0; i--){\\n            if (i+1!=s.length()){\\n                ans[i]=ans[i]+ans[i+1];\\n            }\\n            for (int j=0; j<M[s[i]].size(); j++){\\n                if (checkPallindrome(s.substr(i, M[s[i]][j]-i+1))){\\n                    if (M[s[i]][j]+1!=s.length()){\\n                        ans[i]=min(ans[i], 1+ans[M[s[i]][j]+1]);\\n                    }\\n                    else{\\n                        ans[i]=min(ans[i], 1);\\n                    }\\n                }\\n            }\\n            M[s[i]].push_back(i);\\n        }\\n        // for (int i=0; i<s.length(); i++){\\n        //     cout<<ans[i]<<\" \";\\n        // }\\n        return ans[0]-1;\\n    }\\n};\\n\\n\\nmy code gives TLE, though it does exactly the same thing as what others\\' submission, please help"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: It is a bit of an exotic method, but you could reformulate it as a variation of the Jump Game problem, which is medium level!\nIf you are curious, check out my [solution](https://leetcode.com/problems/palindrome-partitioning-ii/solutions/3408076/its-just-another-jump-game-medium-level-reformulation/)!"
                    },
                    {
                        "username": "aayush15082002",
                        "content": "The code is giving TLE. Can anyone suggest?\\n\\nclass Solution {\\npublic:\\nbool isPalindrome(string &s, int i, int j){\\n    if(i==j){\\n        return true;\\n    }\\n    if(i>j){\\n        return true;\\n    }\\n    while(i<j){\\n    \\n            if(s[i]!=s[j]) return false;\\n            i++; j--;\\n        }\\n        return true;\\n}\\nint solve(string &s, int i, int j, vector<vector<int>> &dp  ){\\n    int mn=INT_MAX;\\n    if(i>=j){\\n        return 0;\\n    }\\n    if(isPalindrome(s, i, j)){\\n        return 0;\\n    }\\n    if(dp[i][j]!=-1){\\n        return dp[i][j];\\n    }\\n    for(int k=i;k<=j-1;k++){\\n        int left, right, temp;\\n        \\n        if(isPalindrome(s,i,k)){\\n            if(isPalindrome(s,k+1,j)){\\n                temp=1;\\n            }\\n            else{\\n                if(dp[k+1][j]!=-1){\\n                    right=dp[k+1][j];\\n                    \\n                }\\n                else{\\n                    right=solve(s,k+1,j,dp);\\n                    dp[k+1][j]=right;\\n                }\\n                temp=1+0+right;\\n            }\\n        }\\n         \\n        else{\\n            if(dp[i][k]!=-1){\\n                left=dp[i][k];\\n             }\\n            else{\\n                left=solve(s,i,k,dp);\\n                dp[i][k]=left;\\n            }\\n            if(isPalindrome(s,k+1,j)){\\n                temp=1+left+0;\\n            }\\n            else{\\n                if(dp[k+1][j]!=-1){\\n                  right=dp[k+1][j];   \\n                }\\n                else{\\n                    right=solve(s,k+1,j,dp);\\n                    dp[k+1][j]=right;\\n                }\\n             temp=1+left+right;\\n            }\\n\\n        }\\n        if(temp<mn){\\n            mn=temp;\\n        }\\n        \\n    }\\n    return dp[i][j]=mn;\\n}\\n    int minCut(string s) {\\n        vector<vector<int>> dp(2001, vector<int>(2001,-1));\\n       return solve(s, 0, s.size()-1, dp);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1917927,
                "content": [
                    {
                        "username": "nazimazhaan17",
                        "content": "worst test case\\n"
                    },
                    {
                        "username": "kumar_Aman1",
                        "content": "NOTE :- Remember to pass the string by reference even in your palindrome function."
                    },
                    {
                        "username": "anandA3B",
                        "content": "the test case 37 is incorrect. it is blank. not even \"\" or null works for this."
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "TLE?\\nUse recursion to check for palindrome and memoize the results."
                    },
                    {
                        "username": "HemantChoudhary",
                        "content": "Please confirm if their code if giving TLE when no input is given I don\\'t know if the test case is correct or not feels like it is incorrect  "
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "My Code is Passing close to 30TC fails on \"aaabaa\" can anyone please point out the error. Thank You\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n   bool isP(string &s, int start,int end){\\n       while(start<end){\\n       if(s[start]!=s[end]) return false;\\n       start++; end--;\\n       }\\n       return true;\\n   }\\n\\n    int f(int i,int j,string &s,vector<int>&dp){\\n         if(j==s.size()-1){\\n           \\n            if(isP(s,i,j)==true) return 0;\\n            return 1e7;\\n        }\\n        if(dp[j]<1e7) return dp[j];\\n\\n       \\n        int nt=f(i,j+1,s,dp);\\n        int t=1e7;\\n        if(isP(s,i,j)==true){\\n            t=1+f(j+1,j+1,s,dp);\\n        }\\n        int x=min(nt,t);\\n        dp[j]=min(dp[j],x); return dp[j];\\n    }\\n\\n    int minCut(string s) {\\n        int n=s.size();\\n        vector<int>dp(n,INT_MAX);\\n        return f(0,0,s,dp);\\n    }\\n};"
                    },
                    {
                        "username": "Dark_Orion",
                        "content": "Hey!\\nI think changing the line `t=1+f(j+1,j+1,s,dp);`  to `t=1+f(j,j+1,s,dp);` should work, since if you increment both, you would miss a case."
                    },
                    {
                        "username": "Abhi_Secular",
                        "content": "Can anyone let me know, why my solution is having TLE while almost similar DP solution in [this post](https://leetcode.com/problems/palindrome-partitioning-ii/solutions/590653/from-brute-force-to-top-down-dp/) is passing all test case.\nMy code:\n\n `class Solution {\n    public static boolean isPalindrome(String s,int i, int n){\n        // int n=s.length()-1;\n        while(n>i && s.charAt(n)==s.charAt(i)){\n            n--;\n            i++;\n            continue;\n        }\n        if(n<=i) return true;\n        return false;\n    }\n    public static int findMinCuts(String s, int idx, int[] dp, int[][] palDP){\n        int n = s.length();\n        if(idx==n || isPalindrome(s, 0, n-1)) return 0;\n        if(dp[idx]!=-1) return dp[idx];\n        int res = Integer.MAX_VALUE;\n        for(int i=idx;i<n;i++){\n                boolean isPal = false;\n                isPal = palDP[idx][i] == 1?true:isPalindrome(s, idx,i);\n                palDP[idx][i] = isPal==true?1:0;\n                if(isPal){\n                    res = Math.min(res,1+findMinCuts(s,i+1,dp,palDP));\n                }  \n        }\n        return dp[idx]=res;\n    }\n    public int minCut(String s) {\n        int n = s.length();\n        if(isPalindrome(s,0,n-1)) return 0;\n        int dp[] = new int[n+1];\n        Arrays.fill(dp, -1);\n        int palDP[][]=new int[n][n];\n        for(int i=0;i<n;i++){\n            Arrays.fill(palDP[i],-1);\n        }\n        int res=findMinCuts(s, 0, dp, palDP)-1;\n        // if(res==1)return res-1;\n        return res;\n    }\n}`"
                    },
                    {
                        "username": "nikks1234",
                        "content": "class Solution {\\npublic:\\n    bool checkPallindrome(string s){\\n        if (s.empty()||s.length()==1){\\n            return true;\\n        }\\n        if (s[0]!=s[s.length()-1]){\\n            return false;\\n        }\\n        return checkPallindrome(s.substr(1, s.length()-2));\\n    }\\n    int minCut(string s) {\\n        vector<int> ans(s.length(), 1);\\n        map<char, vector<int>> M;\\n        for (int i=s.length()-1; i>=0; i--){\\n            if (i+1!=s.length()){\\n                ans[i]=ans[i]+ans[i+1];\\n            }\\n            for (int j=0; j<M[s[i]].size(); j++){\\n                if (checkPallindrome(s.substr(i, M[s[i]][j]-i+1))){\\n                    if (M[s[i]][j]+1!=s.length()){\\n                        ans[i]=min(ans[i], 1+ans[M[s[i]][j]+1]);\\n                    }\\n                    else{\\n                        ans[i]=min(ans[i], 1);\\n                    }\\n                }\\n            }\\n            M[s[i]].push_back(i);\\n        }\\n        // for (int i=0; i<s.length(); i++){\\n        //     cout<<ans[i]<<\" \";\\n        // }\\n        return ans[0]-1;\\n    }\\n};\\n\\n\\nmy code gives TLE, though it does exactly the same thing as what others\\' submission, please help"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: It is a bit of an exotic method, but you could reformulate it as a variation of the Jump Game problem, which is medium level!\nIf you are curious, check out my [solution](https://leetcode.com/problems/palindrome-partitioning-ii/solutions/3408076/its-just-another-jump-game-medium-level-reformulation/)!"
                    },
                    {
                        "username": "aayush15082002",
                        "content": "The code is giving TLE. Can anyone suggest?\\n\\nclass Solution {\\npublic:\\nbool isPalindrome(string &s, int i, int j){\\n    if(i==j){\\n        return true;\\n    }\\n    if(i>j){\\n        return true;\\n    }\\n    while(i<j){\\n    \\n            if(s[i]!=s[j]) return false;\\n            i++; j--;\\n        }\\n        return true;\\n}\\nint solve(string &s, int i, int j, vector<vector<int>> &dp  ){\\n    int mn=INT_MAX;\\n    if(i>=j){\\n        return 0;\\n    }\\n    if(isPalindrome(s, i, j)){\\n        return 0;\\n    }\\n    if(dp[i][j]!=-1){\\n        return dp[i][j];\\n    }\\n    for(int k=i;k<=j-1;k++){\\n        int left, right, temp;\\n        \\n        if(isPalindrome(s,i,k)){\\n            if(isPalindrome(s,k+1,j)){\\n                temp=1;\\n            }\\n            else{\\n                if(dp[k+1][j]!=-1){\\n                    right=dp[k+1][j];\\n                    \\n                }\\n                else{\\n                    right=solve(s,k+1,j,dp);\\n                    dp[k+1][j]=right;\\n                }\\n                temp=1+0+right;\\n            }\\n        }\\n         \\n        else{\\n            if(dp[i][k]!=-1){\\n                left=dp[i][k];\\n             }\\n            else{\\n                left=solve(s,i,k,dp);\\n                dp[i][k]=left;\\n            }\\n            if(isPalindrome(s,k+1,j)){\\n                temp=1+left+0;\\n            }\\n            else{\\n                if(dp[k+1][j]!=-1){\\n                  right=dp[k+1][j];   \\n                }\\n                else{\\n                    right=solve(s,k+1,j,dp);\\n                    dp[k+1][j]=right;\\n                }\\n             temp=1+left+right;\\n            }\\n\\n        }\\n        if(temp<mn){\\n            mn=temp;\\n        }\\n        \\n    }\\n    return dp[i][j]=mn;\\n}\\n    int minCut(string s) {\\n        vector<vector<int>> dp(2001, vector<int>(2001,-1));\\n       return solve(s, 0, s.size()-1, dp);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1861201,
                "content": [
                    {
                        "username": "nazimazhaan17",
                        "content": "worst test case\\n"
                    },
                    {
                        "username": "kumar_Aman1",
                        "content": "NOTE :- Remember to pass the string by reference even in your palindrome function."
                    },
                    {
                        "username": "anandA3B",
                        "content": "the test case 37 is incorrect. it is blank. not even \"\" or null works for this."
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "TLE?\\nUse recursion to check for palindrome and memoize the results."
                    },
                    {
                        "username": "HemantChoudhary",
                        "content": "Please confirm if their code if giving TLE when no input is given I don\\'t know if the test case is correct or not feels like it is incorrect  "
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "My Code is Passing close to 30TC fails on \"aaabaa\" can anyone please point out the error. Thank You\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n   bool isP(string &s, int start,int end){\\n       while(start<end){\\n       if(s[start]!=s[end]) return false;\\n       start++; end--;\\n       }\\n       return true;\\n   }\\n\\n    int f(int i,int j,string &s,vector<int>&dp){\\n         if(j==s.size()-1){\\n           \\n            if(isP(s,i,j)==true) return 0;\\n            return 1e7;\\n        }\\n        if(dp[j]<1e7) return dp[j];\\n\\n       \\n        int nt=f(i,j+1,s,dp);\\n        int t=1e7;\\n        if(isP(s,i,j)==true){\\n            t=1+f(j+1,j+1,s,dp);\\n        }\\n        int x=min(nt,t);\\n        dp[j]=min(dp[j],x); return dp[j];\\n    }\\n\\n    int minCut(string s) {\\n        int n=s.size();\\n        vector<int>dp(n,INT_MAX);\\n        return f(0,0,s,dp);\\n    }\\n};"
                    },
                    {
                        "username": "Dark_Orion",
                        "content": "Hey!\\nI think changing the line `t=1+f(j+1,j+1,s,dp);`  to `t=1+f(j,j+1,s,dp);` should work, since if you increment both, you would miss a case."
                    },
                    {
                        "username": "Abhi_Secular",
                        "content": "Can anyone let me know, why my solution is having TLE while almost similar DP solution in [this post](https://leetcode.com/problems/palindrome-partitioning-ii/solutions/590653/from-brute-force-to-top-down-dp/) is passing all test case.\nMy code:\n\n `class Solution {\n    public static boolean isPalindrome(String s,int i, int n){\n        // int n=s.length()-1;\n        while(n>i && s.charAt(n)==s.charAt(i)){\n            n--;\n            i++;\n            continue;\n        }\n        if(n<=i) return true;\n        return false;\n    }\n    public static int findMinCuts(String s, int idx, int[] dp, int[][] palDP){\n        int n = s.length();\n        if(idx==n || isPalindrome(s, 0, n-1)) return 0;\n        if(dp[idx]!=-1) return dp[idx];\n        int res = Integer.MAX_VALUE;\n        for(int i=idx;i<n;i++){\n                boolean isPal = false;\n                isPal = palDP[idx][i] == 1?true:isPalindrome(s, idx,i);\n                palDP[idx][i] = isPal==true?1:0;\n                if(isPal){\n                    res = Math.min(res,1+findMinCuts(s,i+1,dp,palDP));\n                }  \n        }\n        return dp[idx]=res;\n    }\n    public int minCut(String s) {\n        int n = s.length();\n        if(isPalindrome(s,0,n-1)) return 0;\n        int dp[] = new int[n+1];\n        Arrays.fill(dp, -1);\n        int palDP[][]=new int[n][n];\n        for(int i=0;i<n;i++){\n            Arrays.fill(palDP[i],-1);\n        }\n        int res=findMinCuts(s, 0, dp, palDP)-1;\n        // if(res==1)return res-1;\n        return res;\n    }\n}`"
                    },
                    {
                        "username": "nikks1234",
                        "content": "class Solution {\\npublic:\\n    bool checkPallindrome(string s){\\n        if (s.empty()||s.length()==1){\\n            return true;\\n        }\\n        if (s[0]!=s[s.length()-1]){\\n            return false;\\n        }\\n        return checkPallindrome(s.substr(1, s.length()-2));\\n    }\\n    int minCut(string s) {\\n        vector<int> ans(s.length(), 1);\\n        map<char, vector<int>> M;\\n        for (int i=s.length()-1; i>=0; i--){\\n            if (i+1!=s.length()){\\n                ans[i]=ans[i]+ans[i+1];\\n            }\\n            for (int j=0; j<M[s[i]].size(); j++){\\n                if (checkPallindrome(s.substr(i, M[s[i]][j]-i+1))){\\n                    if (M[s[i]][j]+1!=s.length()){\\n                        ans[i]=min(ans[i], 1+ans[M[s[i]][j]+1]);\\n                    }\\n                    else{\\n                        ans[i]=min(ans[i], 1);\\n                    }\\n                }\\n            }\\n            M[s[i]].push_back(i);\\n        }\\n        // for (int i=0; i<s.length(); i++){\\n        //     cout<<ans[i]<<\" \";\\n        // }\\n        return ans[0]-1;\\n    }\\n};\\n\\n\\nmy code gives TLE, though it does exactly the same thing as what others\\' submission, please help"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: It is a bit of an exotic method, but you could reformulate it as a variation of the Jump Game problem, which is medium level!\nIf you are curious, check out my [solution](https://leetcode.com/problems/palindrome-partitioning-ii/solutions/3408076/its-just-another-jump-game-medium-level-reformulation/)!"
                    },
                    {
                        "username": "aayush15082002",
                        "content": "The code is giving TLE. Can anyone suggest?\\n\\nclass Solution {\\npublic:\\nbool isPalindrome(string &s, int i, int j){\\n    if(i==j){\\n        return true;\\n    }\\n    if(i>j){\\n        return true;\\n    }\\n    while(i<j){\\n    \\n            if(s[i]!=s[j]) return false;\\n            i++; j--;\\n        }\\n        return true;\\n}\\nint solve(string &s, int i, int j, vector<vector<int>> &dp  ){\\n    int mn=INT_MAX;\\n    if(i>=j){\\n        return 0;\\n    }\\n    if(isPalindrome(s, i, j)){\\n        return 0;\\n    }\\n    if(dp[i][j]!=-1){\\n        return dp[i][j];\\n    }\\n    for(int k=i;k<=j-1;k++){\\n        int left, right, temp;\\n        \\n        if(isPalindrome(s,i,k)){\\n            if(isPalindrome(s,k+1,j)){\\n                temp=1;\\n            }\\n            else{\\n                if(dp[k+1][j]!=-1){\\n                    right=dp[k+1][j];\\n                    \\n                }\\n                else{\\n                    right=solve(s,k+1,j,dp);\\n                    dp[k+1][j]=right;\\n                }\\n                temp=1+0+right;\\n            }\\n        }\\n         \\n        else{\\n            if(dp[i][k]!=-1){\\n                left=dp[i][k];\\n             }\\n            else{\\n                left=solve(s,i,k,dp);\\n                dp[i][k]=left;\\n            }\\n            if(isPalindrome(s,k+1,j)){\\n                temp=1+left+0;\\n            }\\n            else{\\n                if(dp[k+1][j]!=-1){\\n                  right=dp[k+1][j];   \\n                }\\n                else{\\n                    right=solve(s,k+1,j,dp);\\n                    dp[k+1][j]=right;\\n                }\\n             temp=1+left+right;\\n            }\\n\\n        }\\n        if(temp<mn){\\n            mn=temp;\\n        }\\n        \\n    }\\n    return dp[i][j]=mn;\\n}\\n    int minCut(string s) {\\n        vector<vector<int>> dp(2001, vector<int>(2001,-1));\\n       return solve(s, 0, s.size()-1, dp);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1769813,
                "content": [
                    {
                        "username": "nazimazhaan17",
                        "content": "worst test case\\n"
                    },
                    {
                        "username": "kumar_Aman1",
                        "content": "NOTE :- Remember to pass the string by reference even in your palindrome function."
                    },
                    {
                        "username": "anandA3B",
                        "content": "the test case 37 is incorrect. it is blank. not even \"\" or null works for this."
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "TLE?\\nUse recursion to check for palindrome and memoize the results."
                    },
                    {
                        "username": "HemantChoudhary",
                        "content": "Please confirm if their code if giving TLE when no input is given I don\\'t know if the test case is correct or not feels like it is incorrect  "
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "My Code is Passing close to 30TC fails on \"aaabaa\" can anyone please point out the error. Thank You\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n   bool isP(string &s, int start,int end){\\n       while(start<end){\\n       if(s[start]!=s[end]) return false;\\n       start++; end--;\\n       }\\n       return true;\\n   }\\n\\n    int f(int i,int j,string &s,vector<int>&dp){\\n         if(j==s.size()-1){\\n           \\n            if(isP(s,i,j)==true) return 0;\\n            return 1e7;\\n        }\\n        if(dp[j]<1e7) return dp[j];\\n\\n       \\n        int nt=f(i,j+1,s,dp);\\n        int t=1e7;\\n        if(isP(s,i,j)==true){\\n            t=1+f(j+1,j+1,s,dp);\\n        }\\n        int x=min(nt,t);\\n        dp[j]=min(dp[j],x); return dp[j];\\n    }\\n\\n    int minCut(string s) {\\n        int n=s.size();\\n        vector<int>dp(n,INT_MAX);\\n        return f(0,0,s,dp);\\n    }\\n};"
                    },
                    {
                        "username": "Dark_Orion",
                        "content": "Hey!\\nI think changing the line `t=1+f(j+1,j+1,s,dp);`  to `t=1+f(j,j+1,s,dp);` should work, since if you increment both, you would miss a case."
                    },
                    {
                        "username": "Abhi_Secular",
                        "content": "Can anyone let me know, why my solution is having TLE while almost similar DP solution in [this post](https://leetcode.com/problems/palindrome-partitioning-ii/solutions/590653/from-brute-force-to-top-down-dp/) is passing all test case.\nMy code:\n\n `class Solution {\n    public static boolean isPalindrome(String s,int i, int n){\n        // int n=s.length()-1;\n        while(n>i && s.charAt(n)==s.charAt(i)){\n            n--;\n            i++;\n            continue;\n        }\n        if(n<=i) return true;\n        return false;\n    }\n    public static int findMinCuts(String s, int idx, int[] dp, int[][] palDP){\n        int n = s.length();\n        if(idx==n || isPalindrome(s, 0, n-1)) return 0;\n        if(dp[idx]!=-1) return dp[idx];\n        int res = Integer.MAX_VALUE;\n        for(int i=idx;i<n;i++){\n                boolean isPal = false;\n                isPal = palDP[idx][i] == 1?true:isPalindrome(s, idx,i);\n                palDP[idx][i] = isPal==true?1:0;\n                if(isPal){\n                    res = Math.min(res,1+findMinCuts(s,i+1,dp,palDP));\n                }  \n        }\n        return dp[idx]=res;\n    }\n    public int minCut(String s) {\n        int n = s.length();\n        if(isPalindrome(s,0,n-1)) return 0;\n        int dp[] = new int[n+1];\n        Arrays.fill(dp, -1);\n        int palDP[][]=new int[n][n];\n        for(int i=0;i<n;i++){\n            Arrays.fill(palDP[i],-1);\n        }\n        int res=findMinCuts(s, 0, dp, palDP)-1;\n        // if(res==1)return res-1;\n        return res;\n    }\n}`"
                    },
                    {
                        "username": "nikks1234",
                        "content": "class Solution {\\npublic:\\n    bool checkPallindrome(string s){\\n        if (s.empty()||s.length()==1){\\n            return true;\\n        }\\n        if (s[0]!=s[s.length()-1]){\\n            return false;\\n        }\\n        return checkPallindrome(s.substr(1, s.length()-2));\\n    }\\n    int minCut(string s) {\\n        vector<int> ans(s.length(), 1);\\n        map<char, vector<int>> M;\\n        for (int i=s.length()-1; i>=0; i--){\\n            if (i+1!=s.length()){\\n                ans[i]=ans[i]+ans[i+1];\\n            }\\n            for (int j=0; j<M[s[i]].size(); j++){\\n                if (checkPallindrome(s.substr(i, M[s[i]][j]-i+1))){\\n                    if (M[s[i]][j]+1!=s.length()){\\n                        ans[i]=min(ans[i], 1+ans[M[s[i]][j]+1]);\\n                    }\\n                    else{\\n                        ans[i]=min(ans[i], 1);\\n                    }\\n                }\\n            }\\n            M[s[i]].push_back(i);\\n        }\\n        // for (int i=0; i<s.length(); i++){\\n        //     cout<<ans[i]<<\" \";\\n        // }\\n        return ans[0]-1;\\n    }\\n};\\n\\n\\nmy code gives TLE, though it does exactly the same thing as what others\\' submission, please help"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: It is a bit of an exotic method, but you could reformulate it as a variation of the Jump Game problem, which is medium level!\nIf you are curious, check out my [solution](https://leetcode.com/problems/palindrome-partitioning-ii/solutions/3408076/its-just-another-jump-game-medium-level-reformulation/)!"
                    },
                    {
                        "username": "aayush15082002",
                        "content": "The code is giving TLE. Can anyone suggest?\\n\\nclass Solution {\\npublic:\\nbool isPalindrome(string &s, int i, int j){\\n    if(i==j){\\n        return true;\\n    }\\n    if(i>j){\\n        return true;\\n    }\\n    while(i<j){\\n    \\n            if(s[i]!=s[j]) return false;\\n            i++; j--;\\n        }\\n        return true;\\n}\\nint solve(string &s, int i, int j, vector<vector<int>> &dp  ){\\n    int mn=INT_MAX;\\n    if(i>=j){\\n        return 0;\\n    }\\n    if(isPalindrome(s, i, j)){\\n        return 0;\\n    }\\n    if(dp[i][j]!=-1){\\n        return dp[i][j];\\n    }\\n    for(int k=i;k<=j-1;k++){\\n        int left, right, temp;\\n        \\n        if(isPalindrome(s,i,k)){\\n            if(isPalindrome(s,k+1,j)){\\n                temp=1;\\n            }\\n            else{\\n                if(dp[k+1][j]!=-1){\\n                    right=dp[k+1][j];\\n                    \\n                }\\n                else{\\n                    right=solve(s,k+1,j,dp);\\n                    dp[k+1][j]=right;\\n                }\\n                temp=1+0+right;\\n            }\\n        }\\n         \\n        else{\\n            if(dp[i][k]!=-1){\\n                left=dp[i][k];\\n             }\\n            else{\\n                left=solve(s,i,k,dp);\\n                dp[i][k]=left;\\n            }\\n            if(isPalindrome(s,k+1,j)){\\n                temp=1+left+0;\\n            }\\n            else{\\n                if(dp[k+1][j]!=-1){\\n                  right=dp[k+1][j];   \\n                }\\n                else{\\n                    right=solve(s,k+1,j,dp);\\n                    dp[k+1][j]=right;\\n                }\\n             temp=1+left+right;\\n            }\\n\\n        }\\n        if(temp<mn){\\n            mn=temp;\\n        }\\n        \\n    }\\n    return dp[i][j]=mn;\\n}\\n    int minCut(string s) {\\n        vector<vector<int>> dp(2001, vector<int>(2001,-1));\\n       return solve(s, 0, s.size()-1, dp);\\n    }\\n};"
                    }
                ]
            }
        ]
    }
]