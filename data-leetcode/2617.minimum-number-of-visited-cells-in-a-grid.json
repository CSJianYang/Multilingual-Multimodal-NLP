[
    {
        "title": "Minimum Number of Visited Cells in a Grid",
        "question_content": "You are given a 0-indexed m x n integer matrix grid. Your initial position is at the top-left cell (0, 0).\nStarting from the cell (i, j), you can move to one of the following cells:\n\n\tCells (i, k) with j < k <= grid[i][j] + j (rightward movement), or\n\tCells (k, j) with i < k <= grid[i][j] + i (downward movement).\n\nReturn the minimum number of cells you need to visit to reach the bottom-right cell (m - 1, n - 1). If there is no valid path, return -1.\n&nbsp;\nExample 1:\n\nInput: grid = [[3,4,2,1],[4,2,3,1],[2,1,0,0],[2,4,0,0]]\nOutput: 4\nExplanation: The image above shows one of the paths that visits exactly 4 cells.\n\nExample 2:\n\nInput: grid = [[3,4,2,1],[4,2,1,1],[2,1,1,0],[3,4,1,0]]\nOutput: 3\nExplanation: The image above shows one of the paths that visits exactly 3 cells.\n\nExample 3:\n\nInput: grid = [[2,1,0],[1,0,0]]\nOutput: -1\nExplanation: It can be proven that no path exists.\n\n&nbsp;\nConstraints:\n\n\tm == grid.length\n\tn == grid[i].length\n\t1 <= m, n <= 105\n\t1 <= m * n <= 105\n\t0 <= grid[i][j] < m * n\n\tgrid[m - 1][n - 1] == 0",
        "solutions": [
            {
                "id": 3395709,
                "title": "c-java-python3-set-treeset-sortedlist-bfs",
                "content": "# Intuition\\nMaintain a queue to determine which cell to go to next. Since the grid is too big and `grid[i][j]` can be pretty big too, we will find ourselves iterating over the grid again and again. We can use Set/TreeSet/SortedList to keep track of visited nodes and make sure we don\\'t visit them again or even consider them again in the for loop by removing them once they have been visited.\\n\\n# Explanation\\nThis code is using the breadth-first search algorithm to find the minimum number of cells that need to be visited to reach from the top-left cell of a given grid to the bottom-right cell. To avoid iterating over the entire grid again and again, it uses a Set/TreeSet/SortedList data structure to keep track of the visited nodes in the horizontal and vertical directions. This enables efficient iteration over the subset of cells that haven\\'t been visited yet.\\n\\nDuring the for loop, the irange method of the SortedList object is used to iterate over the subset of cells that haven\\'t been visited yet. Specifically, for the s0 list, it iterates over the columns that haven\\'t been visited yet and are within the range of (j+1, min(j+1+grid[i][j], n) - 1). Similarly, for the s1 list, it iterates over the rows that haven\\'t been visited yet and are within the range of (i+1, min(i+1+grid[i][j], m) - 1). This results in significant speed-ups when the grid is large or the values of grid[i][j] are large.\\n\\n# Complexity\\n- Time complexity: `O(mn * log(max(m, n)))`\\n- Space complexity: `O(mn)`\\n\\n# Code\\n**Python3**:\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        s0 = [SortedList(range(n)) for _ in range(m)]\\n        s1 = [SortedList(range(m)) for _ in range(n)]\\n        q = deque([(0, 0, 1)])\\n\\n        while q:\\n            i, j, d = q.popleft()\\n            if (i, j) == (m-1, n-1):\\n                return d\\n            for k in list(s0[i].irange(j+1, min(j+1+grid[i][j], n) - 1)):\\n                q.append((i, k, d+1))\\n                s0[i].remove(k)\\n                s1[k].remove(i)\\n            for k in list(s1[j].irange(i+1, min(i+1+grid[i][j], m) - 1)):\\n                q.append((k, j, d+1))\\n                s1[j].remove(k)\\n                s0[k].remove(j)\\n        return -1\\n```\\n\\n**C++**:\\nTo keep track of which cells have already been visited, the code uses two sets of sets - s0 and s1 - one for each row and column of the grid. These sets represent the indices of cells that have not been visited yet. During each iteration of the BFS loop, the code finds the next set of cells that can be visited and updates the corresponding sets by removing the cells that have been visited. This is done using the lower_bound() function of the set, which returns an iterator pointing to the first element that is not less than a given value.\\n```\\nint minimumVisitedCells(vector<vector<int>>& grid) {\\n    int m = grid.size(), n = grid[0].size();\\n    vector<set<int>> s0(m), s1(n);\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            s0[i].insert(j);\\n            s1[j].insert(i);\\n        }\\n    }\\n    queue<vector<int>> q;\\n    q.push({0, 0, 1});\\n\\n    while (!q.empty()) {\\n        auto cell = q.front(); q.pop();\\n        int i = cell[0], j = cell[1], d = cell[2];\\n        if (i == m - 1 && j == n - 1) return d;\\n\\n        auto it = s0[i].lower_bound(j + 1);\\n        while (it != s0[i].end() && *it <= j + grid[i][j]) {\\n            q.push({i, *it, d + 1});\\n            s1[*it].erase(i);\\n            s0[i].erase(it++);\\n        }\\n        it = s1[j].lower_bound(i + 1);\\n        while (it != s1[j].end() && *it <= i + grid[i][j]) {\\n            q.push({*it, j, d + 1});\\n            s0[*it].erase(j);\\n            s1[j].erase(it++);\\n        }\\n    }\\n    return -1;\\n}\\n```\\n**Java**:\\n```\\npublic int minimumVisitedCells(int[][] grid) {\\n    int m = grid.length, n = grid[0].length;\\n    TreeSet<Integer>[] s0 = new TreeSet[m], s1 = new TreeSet[n];\\n    for (int i = 0; i < m; i++) {\\n        s0[i] = new TreeSet<>();\\n        for (int j = 0; j < n; j++)\\n            s0[i].add(j);\\n    }\\n    for (int j = 0; j < n; j++) {\\n        s1[j] = new TreeSet<>();\\n        for (int i = 0; i < m; i++) \\n            s1[j].add(i);\\n    }\\n    Queue<int[]> q = new LinkedList<>();\\n    q.offer(new int[]{0, 0, 1});\\n\\n    while (!q.isEmpty()) {\\n        int[] cell = q.poll();\\n        int i = cell[0], j = cell[1], d = cell[2];\\n        if (i == m - 1 && j == n - 1) return d;\\n\\n        Integer k = s0[i].ceiling(j+1);\\n        while (k != null && k <= j + grid[i][j]) {\\n            q.offer(new int[]{i, k.intValue(), d + 1});\\n            s0[i].remove(k);\\n            s1[k.intValue()].remove(i);\\n            k = s0[i].ceiling(j + 1);\\n        }\\n        k = s1[j].ceiling(i+1);\\n        while (k != null && k <= i + grid[i][j]) {\\n            q.offer(new int[]{k.intValue(), j, d + 1});\\n            s1[j].remove(k);\\n            s0[k.intValue()].remove(j);\\n            k = s1[j].ceiling(i + 1);\\n        }\\n    }\\n    return -1;\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        s0 = [SortedList(range(n)) for _ in range(m)]\\n        s1 = [SortedList(range(m)) for _ in range(n)]\\n        q = deque([(0, 0, 1)])\\n\\n        while q:\\n            i, j, d = q.popleft()\\n            if (i, j) == (m-1, n-1):\\n                return d\\n            for k in list(s0[i].irange(j+1, min(j+1+grid[i][j], n) - 1)):\\n                q.append((i, k, d+1))\\n                s0[i].remove(k)\\n                s1[k].remove(i)\\n            for k in list(s1[j].irange(i+1, min(i+1+grid[i][j], m) - 1)):\\n                q.append((k, j, d+1))\\n                s1[j].remove(k)\\n                s0[k].remove(j)\\n        return -1\\n```\n```\\nint minimumVisitedCells(vector<vector<int>>& grid) {\\n    int m = grid.size(), n = grid[0].size();\\n    vector<set<int>> s0(m), s1(n);\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            s0[i].insert(j);\\n            s1[j].insert(i);\\n        }\\n    }\\n    queue<vector<int>> q;\\n    q.push({0, 0, 1});\\n\\n    while (!q.empty()) {\\n        auto cell = q.front(); q.pop();\\n        int i = cell[0], j = cell[1], d = cell[2];\\n        if (i == m - 1 && j == n - 1) return d;\\n\\n        auto it = s0[i].lower_bound(j + 1);\\n        while (it != s0[i].end() && *it <= j + grid[i][j]) {\\n            q.push({i, *it, d + 1});\\n            s1[*it].erase(i);\\n            s0[i].erase(it++);\\n        }\\n        it = s1[j].lower_bound(i + 1);\\n        while (it != s1[j].end() && *it <= i + grid[i][j]) {\\n            q.push({*it, j, d + 1});\\n            s0[*it].erase(j);\\n            s1[j].erase(it++);\\n        }\\n    }\\n    return -1;\\n}\\n```\n```\\npublic int minimumVisitedCells(int[][] grid) {\\n    int m = grid.length, n = grid[0].length;\\n    TreeSet<Integer>[] s0 = new TreeSet[m], s1 = new TreeSet[n];\\n    for (int i = 0; i < m; i++) {\\n        s0[i] = new TreeSet<>();\\n        for (int j = 0; j < n; j++)\\n            s0[i].add(j);\\n    }\\n    for (int j = 0; j < n; j++) {\\n        s1[j] = new TreeSet<>();\\n        for (int i = 0; i < m; i++) \\n            s1[j].add(i);\\n    }\\n    Queue<int[]> q = new LinkedList<>();\\n    q.offer(new int[]{0, 0, 1});\\n\\n    while (!q.isEmpty()) {\\n        int[] cell = q.poll();\\n        int i = cell[0], j = cell[1], d = cell[2];\\n        if (i == m - 1 && j == n - 1) return d;\\n\\n        Integer k = s0[i].ceiling(j+1);\\n        while (k != null && k <= j + grid[i][j]) {\\n            q.offer(new int[]{i, k.intValue(), d + 1});\\n            s0[i].remove(k);\\n            s1[k.intValue()].remove(i);\\n            k = s0[i].ceiling(j + 1);\\n        }\\n        k = s1[j].ceiling(i+1);\\n        while (k != null && k <= i + grid[i][j]) {\\n            q.offer(new int[]{k.intValue(), j, d + 1});\\n            s1[j].remove(k);\\n            s0[k.intValue()].remove(j);\\n            k = s1[j].ceiling(i + 1);\\n        }\\n    }\\n    return -1;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398356,
                "title": "dp-sweep-line-o-nm-log-n",
                "content": "# Note\\nFirst of all, many of the top discuss solutions are completely wrong or have incorrect time complexity. Perhaps they will fix the test cases in the future. I will convince you that this solution is 100% correct and runs in exact time complexity `O(NM * log(max(N,M)))`\\n\\nI thought this problem was pretty fun :) Hopefully you like my solution.\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will solve it in this order, like a DP:\\n```cpp\\nfor (int r = 0; i < N; ++i) \\n    for (int c = 0; j < M; ++j)\\n        // use previously computed results to find \\n        // shortest path to (r,c)\\n```\\nThen the answer is just whatever value we got for cell `(N-1, M-1)`.\\n\\nIn order to find the shortest path to (r,c), I need to find the the best cell to the left of me, on the same row, as well as the best cell above me, on the same column. Then we take the min of these. Since we only depend on cells to the left and above us, we already have the information about them since we are solving from left to right and top to bottom.\\n\\nLet `dx = grid[r][c]`\\nNotice that each cell represents an HORIZONTAL INTERVAL of columns `(c, c+dx)` along row `r`.\\nSimilarly, each cell represents a VERTICAL INTERVAL of rows `(r, r+dx)` along column `c`.\\n\\nWe can use sweep line with a balanced BST to find: at each position, what is the best we can do with the currently active intervals? \\n\\nIn case you don\\'t know about balanced BSTs, (binary search tree), they are\\n\\n`std::map` in c++, `TreeMap` in java, `SortedList` is the closest thing in python i guess.\\n\\nIt allows you to insert elements in `log N`, delete elements in `log N`, update elements in `log N`, query for minimum or maximum key in `log N`, binary search for smallest key which is greater than some x in `log N`, binary search for largest key which is smaller than some x in `log N`, and lots of other cool stuff, all in `log N` :))\\n\\nHere, we will use them specifically for querying the dynamic minimum key of a set. I use map instead of set since we can have multiple instances of a key, so I map each key to its frequency. If frequency becomes zero, I delete it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDefine a data structure `Sweep` as follows:\\n\\n**Member variables:**\\n`int pos = 0` - this tracks the current position \\n\\n`map<int, int> vs` - this is a BST, representing the values (shortest paths) of all active intervals at the current position. `vs[v]` is the frequency of `v` in the currently active intervals. \\n\\n`unordered_map<int, vector<int>> del` - keep track of when each interval ends. `del[x]` is a list of all the values to stop considering AFTER we leave position `x`. \\n(note: in implementation i use `vector<vector<int>>` to avoid hashmap constant factor)\\n\\n**Functions:**\\n`void add(val, end_pos)` - begin considering `val`, keep considering until we pass `end_pos`, then stop considering it.\\n\\n`int get()` - get the minimum value that is currently in consideration. \\n\\n`void advance()` - advance our current position x by one, deleting the necessary values which are no longer in consideration after position x.\\n\\n\\n--------------\\n\\nWe will need to store a `Sweep` for each row and each column.\\nI will store these as `Sweep` arrays `vert[M]` and `hori[N]`.\\n\\nTo get the shortest path to a particular cell `(r,c)`, we consult the following 2 `Sweep`\\'s: `vert[c]` and `hori[r]`.\\n\\n```cpp\\nint vt = vert[c].get();\\nint hr = hori[r].get();\\nint v = 1 + min(vt, hr);  // shortest path to (r,c) \\n```\\n\\nThen, we must add the new intervals defined by `grid[r][c]`.\\n\\n```cpp\\nint dx = grid[r][c];\\nvert[c].add(v, r + dx);  // v is considered on this column until r+dx\\nhori[r].add(v, c + dx);  // v is considered on this row until c+dx\\n```\\n\\nFinally, we will advance our `Sweep`\\'s by one position.\\n\\n```cpp\\nvert[c].advance();\\nhori[r].advance();\\n```\\n\\n# Complexity\\n- Time complexity: $O(nm \\\\log (\\\\max(n,m)))$\\nWe go through each cell once. This is $nm$.\\nAt each cell, we will perform some BST operations which are bounded\\nby the size of the row/column. This is $log(max(n,m))$.\\n\\n- Space complexity: $O(nm)$\\nWe store $n$ row-`Sweep`\\'s, each one stores `O(m)` information.\\nWe store $m$ column-`Sweep`\\'s, each one stores `O(n)` information.\\n\\n# Code\\n```cpp\\nstatic constexpr int INF = 1e9;\\n\\nstruct Sweep {\\n    int pos = 0;\\n    map<int, int> vs;\\n    vector<vector<int>> del;  \\n    // ^^ use vector instead of unordered_map, since it\\'s much faster\\n    Sweep(int sz) : del(sz) {}\\n    inline void add(int v, int end_pos) {\\n        ++vs[v];\\n        if (end_pos < del.size())  // if >, dont need to delete\\n            del[end_pos].push_back(v);\\n    }\\n    inline int get() {\\n        if (vs.empty()) return INF;  // can\\'t reach.\\n        return begin(vs)->first;     // get minimum\\n    }\\n    inline void advance() {\\n        for (int v : del[pos])\\n            if (--vs[v] == 0)\\n                vs.erase(v);\\n        ++pos;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int N = grid.size();\\n        int M = grid[0].size();\\n\\n        vector<Sweep> vert(M, Sweep(N));\\n        for (int r = 0; r < N; ++r) {\\n            Sweep hori(M);  // this is hori[r]\\n            for (int c = 0; c < M; ++c) {\\n                int hr = hori.get();\\n                int vt = vert[c].get();\\n                int v = 1 + min(hr, vt);\\n                if (r == 0 && c == 0) v = 1;\\n                if (v < INF) {\\n                    if (r == N-1 && c == M-1) return v;\\n                    int dx = grid[r][c];\\n                    hori.add(v, c + dx);\\n                    vert[c].add(v, r + dx);\\n                }\\n                hori.advance();\\n                vert[c].advance();\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nfor (int r = 0; i < N; ++i) \\n    for (int c = 0; j < M; ++j)\\n        // use previously computed results to find \\n        // shortest path to (r,c)\\n```\n```cpp\\nint vt = vert[c].get();\\nint hr = hori[r].get();\\nint v = 1 + min(vt, hr);  // shortest path to (r,c) \\n```\n```cpp\\nint dx = grid[r][c];\\nvert[c].add(v, r + dx);  // v is considered on this column until r+dx\\nhori[r].add(v, c + dx);  // v is considered on this row until c+dx\\n```\n```cpp\\nvert[c].advance();\\nhori[r].advance();\\n```\n```cpp\\nstatic constexpr int INF = 1e9;\\n\\nstruct Sweep {\\n    int pos = 0;\\n    map<int, int> vs;\\n    vector<vector<int>> del;  \\n    // ^^ use vector instead of unordered_map, since it\\'s much faster\\n    Sweep(int sz) : del(sz) {}\\n    inline void add(int v, int end_pos) {\\n        ++vs[v];\\n        if (end_pos < del.size())  // if >, dont need to delete\\n            del[end_pos].push_back(v);\\n    }\\n    inline int get() {\\n        if (vs.empty()) return INF;  // can\\'t reach.\\n        return begin(vs)->first;     // get minimum\\n    }\\n    inline void advance() {\\n        for (int v : del[pos])\\n            if (--vs[v] == 0)\\n                vs.erase(v);\\n        ++pos;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int N = grid.size();\\n        int M = grid[0].size();\\n\\n        vector<Sweep> vert(M, Sweep(N));\\n        for (int r = 0; r < N; ++r) {\\n            Sweep hori(M);  // this is hori[r]\\n            for (int c = 0; c < M; ++c) {\\n                int hr = hori.get();\\n                int vt = vert[c].get();\\n                int v = 1 + min(hr, vt);\\n                if (r == 0 && c == 0) v = 1;\\n                if (v < INF) {\\n                    if (r == N-1 && c == M-1) return v;\\n                    int dx = grid[r][c];\\n                    hori.add(v, c + dx);\\n                    vert[c].add(v, r + dx);\\n                }\\n                hori.advance();\\n                vert[c].advance();\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395798,
                "title": "c-easy-approach-dijkstra-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfirst i thought of solving it Using dynamic programming but that gave TLE because I was not able to optimize the same\\non checking complexity constraints i got idea of using Dijkstra algorithm\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntake distance of entry node to be 1 , here distance denote number of cells visited then apply Dijkstra using built in priority queue \\n\\n# Complexity\\n- Time complexity:O(m*n log(m*n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<long long>> distance(m,(vector<long long>(n,INT_MAX)));\\n        distance[0][0]=1;\\n        priority_queue<pair<long long,pair< int, int>>, vector<pair<long long,pair< int, int>>>, greater<pair<long long,pair< int, int>>>> pq;\\n        pq.push({1,{0, 0}} );\\n        while (!pq.empty()) {\\n            long long d = pq.top().first;\\n            int i=pq.top().second.first;\\n            int j=pq.top().second.second;\\n            pq.pop();\\n            if (i == m-1 && j == n-1) {\\n                return (int)d;\\n            }\\n            for (int k = j+1; k <= min(j+grid[i][j], n-1); k++) {\\n                if (distance[i][k] > d+1) {\\n                    distance[i][k] = d+1;\\n                    pq.push({d+1,{ i, k}});\\n                    if (i == m-1 && k == n-1) {\\n                        return (int)d+1;\\n                    }\\n                }\\n            }\\n            for (int k = i+1; k <= min(i+grid[i][j], m-1); k++) {\\n                if (distance[k][j] > d+1) {\\n                    distance[k][j] = d+1;\\n                    pq.push({d+1, {k, j}});\\n                    if (k == m-1 && j == n-1) {\\n                        return (int)d+1;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<long long>> distance(m,(vector<long long>(n,INT_MAX)));\\n        distance[0][0]=1;\\n        priority_queue<pair<long long,pair< int, int>>, vector<pair<long long,pair< int, int>>>, greater<pair<long long,pair< int, int>>>> pq;\\n        pq.push({1,{0, 0}} );\\n        while (!pq.empty()) {\\n            long long d = pq.top().first;\\n            int i=pq.top().second.first;\\n            int j=pq.top().second.second;\\n            pq.pop();\\n            if (i == m-1 && j == n-1) {\\n                return (int)d;\\n            }\\n            for (int k = j+1; k <= min(j+grid[i][j], n-1); k++) {\\n                if (distance[i][k] > d+1) {\\n                    distance[i][k] = d+1;\\n                    pq.push({d+1,{ i, k}});\\n                    if (i == m-1 && k == n-1) {\\n                        return (int)d+1;\\n                    }\\n                }\\n            }\\n            for (int k = i+1; k <= min(i+grid[i][j], m-1); k++) {\\n                if (distance[k][j] > d+1) {\\n                    distance[k][j] = d+1;\\n                    pq.push({d+1, {k, j}});\\n                    if (k == m-1 && j == n-1) {\\n                        return (int)d+1;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395695,
                "title": "bfs-with-skip-ahead",
                "content": "Update. The original solution (see below) is not passing new test cases.\\n\\n## Updated Solution\\n**C++**\\n```cpp\\nint minimumVisitedCells(vector<vector<int>>& g) {\\n    int m = g.size(), n = g[0].size(), steps = 0;\\n    vector<vector<int>> max_i(m, vector<int>(n)), max_j(m, vector<int>(n));\\n    vector<pair<int, int>> q{{0, 0}}, q1;\\n    while (!q.empty()) {\\n        ++steps;\\n        for (auto [i, j] : q) {\\n            if (i == m - 1 && j == n - 1)\\n                return steps;\\n            for (int k = i + 1; k < m && k - i <= g[i][j]; ++k) {\\n                if (max_i[k][j] == 0) {\\n                    q1.push_back({k, j});\\n                    max_i[k][j] = i + g[i][j];\\n                }\\n                else\\n                    k = max_i[k][j];\\n            }\\n            for (int k = j + 1; k < n && k - j <= g[i][j]; ++k) {\\n                if (max_j[i][k] == 0) {\\n                    q1.push_back({i, k});\\n                    max_j[i][k] = j + g[i][j];\\n                }\\n                else\\n                    k = max_j[i][k];\\n            }\\n        }\\n        swap(q, q1);\\n        q1.clear();\\n    }\\n    return -1;\\n}\\n```\\n\\n## Original Solution\\n\\nFor each cell, we push \"reachable\" cells into the queue. \\n\\nAs reachable cells are continuous, we do not need to process these cells again:\\n- g[i][k], where j < k <= grid[i][j] + j\\n- g[k][j], where i < k <= grid[i][j] + i\\n\\nWe use `max_i` and `max_j` to track the furthest `k` we have reached for a given column and row.\\n\\nNext time we process that row or column, we skip ahead to the furthest `k`.\\n\\n**C++**\\n```cpp\\nint minimumVisitedCells(vector<vector<int>>& g) {\\n    int m = g.size(), n = g[0].size(), steps = 0;\\n    vector<int> max_i(n), max_j(m);\\n    vector<pair<int, int>> q{{0, 0}}, q1;\\n    while (!q.empty()) {\\n        ++steps;\\n        for (auto [i, j] : q) {\\n            if (i == m - 1 && j == n - 1)\\n                return steps;\\n            for (int k = max(max_i[j], i) + 1; k < m && k - i <= g[i][j]; ++k)\\n                q1.push_back({k, j});\\n            for (int k = max(max_j[i], j) + 1; k < n && k - j <= g[i][j]; ++k)\\n                q1.push_back({i, k});\\n            max_i[j] = max(max_i[j], i + g[i][j]);\\n            max_j[i] = max(max_j[i], j + g[i][j]);\\n        }\\n        swap(q, q1);\\n        q1.clear();\\n    }\\n    return -1;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint minimumVisitedCells(vector<vector<int>>& g) {\\n    int m = g.size(), n = g[0].size(), steps = 0;\\n    vector<vector<int>> max_i(m, vector<int>(n)), max_j(m, vector<int>(n));\\n    vector<pair<int, int>> q{{0, 0}}, q1;\\n    while (!q.empty()) {\\n        ++steps;\\n        for (auto [i, j] : q) {\\n            if (i == m - 1 && j == n - 1)\\n                return steps;\\n            for (int k = i + 1; k < m && k - i <= g[i][j]; ++k) {\\n                if (max_i[k][j] == 0) {\\n                    q1.push_back({k, j});\\n                    max_i[k][j] = i + g[i][j];\\n                }\\n                else\\n                    k = max_i[k][j];\\n            }\\n            for (int k = j + 1; k < n && k - j <= g[i][j]; ++k) {\\n                if (max_j[i][k] == 0) {\\n                    q1.push_back({i, k});\\n                    max_j[i][k] = j + g[i][j];\\n                }\\n                else\\n                    k = max_j[i][k];\\n            }\\n        }\\n        swap(q, q1);\\n        q1.clear();\\n    }\\n    return -1;\\n}\\n```\n```cpp\\nint minimumVisitedCells(vector<vector<int>>& g) {\\n    int m = g.size(), n = g[0].size(), steps = 0;\\n    vector<int> max_i(n), max_j(m);\\n    vector<pair<int, int>> q{{0, 0}}, q1;\\n    while (!q.empty()) {\\n        ++steps;\\n        for (auto [i, j] : q) {\\n            if (i == m - 1 && j == n - 1)\\n                return steps;\\n            for (int k = max(max_i[j], i) + 1; k < m && k - i <= g[i][j]; ++k)\\n                q1.push_back({k, j});\\n            for (int k = max(max_j[i], j) + 1; k < n && k - j <= g[i][j]; ++k)\\n                q1.push_back({i, k});\\n            max_i[j] = max(max_i[j], i + g[i][j]);\\n            max_j[i] = max(max_j[i], j + g[i][j]);\\n        }\\n        swap(q, q1);\\n        q1.clear();\\n    }\\n    return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3395745,
                "title": "c-bfs",
                "content": "## Intuition -\\nWhile doing BFS if we go to the farthest cell first we will reach the bottom right cell earlier. This will also help us not to push unnecessary cells in the queue. We consider the farthest cell first because that helps us reaching the destination quicker. If the farthest cell does not lead us to our destination, then we come back to the cells before that and try to reach out destination.\\n\\n![image](https://assets.leetcode.com/users/images/790735a1-a080-4ecd-894b-7d4aa5ba92ab_1681052852.1123369.png)\\n\\n#### Please Upvote the solution if it helps you. Thank you.\\n```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& g) {\\n      int m = g.size(), n = g[0].size(), ans = 0;\\n      vector<vector<bool>> vis(m, vector<bool>(n, false));\\n      queue<pair<int, int>> q;\\n      q.emplace(0, 0);\\n      vis[0][0] = true;\\n      while(!q.empty()){\\n        int sz = q.size();\\n        while(sz--){\\n          auto [r, c] = q.front(); q.pop();\\n          if(r == m - 1 and c == n - 1) return ans + 1;\\n          if(g[r][c] == 0) continue;\\n          vis[r][c] = true;\\n          for(int i = min(g[r][c], m - r); i >= 0 ; i--){\\n            if(r + i < m and !vis[r + i][c]){\\n              q.emplace(r + i, c);\\n              vis[r + i][c] = true;\\n            }\\n          }\\n          for(int i = min(g[r][c], n - c); i >= 0 ; i--){\\n            if(c + i < n and !vis[r][c + i]){\\n              q.emplace(r, c + i);\\n              vis[r][c + i] = true;\\n            }\\n          }\\n        }\\n        ans++;\\n      }\\n      return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& g) {\\n      int m = g.size(), n = g[0].size(), ans = 0;\\n      vector<vector<bool>> vis(m, vector<bool>(n, false));\\n      queue<pair<int, int>> q;\\n      q.emplace(0, 0);\\n      vis[0][0] = true;\\n      while(!q.empty()){\\n        int sz = q.size();\\n        while(sz--){\\n          auto [r, c] = q.front(); q.pop();\\n          if(r == m - 1 and c == n - 1) return ans + 1;\\n          if(g[r][c] == 0) continue;\\n          vis[r][c] = true;\\n          for(int i = min(g[r][c], m - r); i >= 0 ; i--){\\n            if(r + i < m and !vis[r + i][c]){\\n              q.emplace(r + i, c);\\n              vis[r + i][c] = true;\\n            }\\n          }\\n          for(int i = min(g[r][c], n - c); i >= 0 ; i--){\\n            if(c + i < n and !vis[r][c + i]){\\n              q.emplace(r, c + i);\\n              vis[r][c + i] = true;\\n            }\\n          }\\n        }\\n        ans++;\\n      }\\n      return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395751,
                "title": "c-segment-trees",
                "content": "# Intuition\\nWe can build a dp-like relation where the cost for moving to each cell is 1 + the minimum cost of all cells that can be reached from that cell. We just need some way to query that minimum cost quickly. One possible solution is the seg tree!\\n\\n\\n# Approach\\nIterate through the grid row by row, starting from the bottom right and ending at the top left.\\nThe cost for moving to each cell is the minimum cost of a cell that can be reached by moving down or to the right by the value in the cell.\\nThese minimum values can be queried fast (in logarithmic time) using a seg tree for each row and column.\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*m*log(n+m))$$\\n\\n- Space complexity:\\n$$O(n*m)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void update(vector<int>& t, int index, int val) {\\n        int n = t.size()/2;\\n        t[index+n] = val;\\n        for (int i = index+n; i > 1; i /= 2) {\\n            t[i/2] = min(t[i], t[i^1]);\\n        }\\n    }\\n    int query(vector<int>& t, int l, int r) {\\n        int n = t.size()/2;\\n        int res = INT_MAX;\\n        for (l += n, r += n+1; l < r; l /= 2, r /= 2) {\\n            if (l&1) res = min(res, t[l++]);\\n            if (r&1) res = min(res, t[--r]);\\n        }\\n        return res;\\n    }\\n\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        \\n        vector<vector<int>> rows(n, vector<int>(2*m, INT_MAX));\\n        vector<vector<int>> cols(m, vector<int>(2*n, INT_MAX));\\n        \\n        update(cols[m-1], n-1, 1),\\n        update(rows[n-1], m-1, 1);\\n        \\n        for (int r = n-1; r >= 0; --r) {\\n            for (int c = m-1; c >= 0; --c) {\\n                if (r == n-1 && c == m-1) continue;\\n                \\n                int move_down = query(rows[r], c+1, min(m-1, c+grid[r][c]));\\n                int move_right = query(cols[c], r+1, min(n-1, r+grid[r][c]));\\n                \\n                int mn = min(move_down, move_right);\\n                if (mn != INT_MAX) ++mn;\\n                \\n                update(cols[c], r, mn);\\n                update(rows[r], c, mn);\\n                \\n                if (!r && !c) return mn == INT_MAX ? -1 : mn;\\n            }\\n        }\\n        \\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Segment Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void update(vector<int>& t, int index, int val) {\\n        int n = t.size()/2;\\n        t[index+n] = val;\\n        for (int i = index+n; i > 1; i /= 2) {\\n            t[i/2] = min(t[i], t[i^1]);\\n        }\\n    }\\n    int query(vector<int>& t, int l, int r) {\\n        int n = t.size()/2;\\n        int res = INT_MAX;\\n        for (l += n, r += n+1; l < r; l /= 2, r /= 2) {\\n            if (l&1) res = min(res, t[l++]);\\n            if (r&1) res = min(res, t[--r]);\\n        }\\n        return res;\\n    }\\n\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        \\n        vector<vector<int>> rows(n, vector<int>(2*m, INT_MAX));\\n        vector<vector<int>> cols(m, vector<int>(2*n, INT_MAX));\\n        \\n        update(cols[m-1], n-1, 1),\\n        update(rows[n-1], m-1, 1);\\n        \\n        for (int r = n-1; r >= 0; --r) {\\n            for (int c = m-1; c >= 0; --c) {\\n                if (r == n-1 && c == m-1) continue;\\n                \\n                int move_down = query(rows[r], c+1, min(m-1, c+grid[r][c]));\\n                int move_right = query(cols[c], r+1, min(n-1, r+grid[r][c]));\\n                \\n                int mn = min(move_down, move_right);\\n                if (mn != INT_MAX) ++mn;\\n                \\n                update(cols[c], r, mn);\\n                update(rows[r], c, mn);\\n                \\n                if (!r && !c) return mn == INT_MAX ? -1 : mn;\\n            }\\n        }\\n        \\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397126,
                "title": "bfs-dsu-keep-tracking-the-next-point",
                "content": "I found many solutions use Dijkstra or BFS which do not solve the real pain point of this question. -- **how can we find the next unused point**. We can easily hack most BFS, Dikstra solutions by this test case `m = 1, n = 100000, grid = [[99998, 99997, ..., 2, 1, 0, 0]]`\\n\\nEveryone knows DSU can merge two connected componenets(CC) or verify whether two point in the same CC. DSU has many other interesting useful functionailities. In this problem, we can use DSU keep tracking the next point which is not in the same CC. The idea is, if we can find the largest idx inside the same CC, then idx + 1 must be the first point in the next CC. Here we show the process to track the next point:\\n1. define parents[idx] point to itself: `parents = [0, 1, 2, 3]` , it means every point initially in the different CCs\\n2. if we pick idx = 1 and want to merge it with the next CC, because we know `find(1) = 1 = root1`, so the next CC should start from `idx = root1 + 1 = 2` , and here the `find(2) = 2 = root2`, so we can set `parents[root1] = root2` that means the CC with root1 and CC with root2 connect by the root2. Here we must notice that **it is not allowed set `parents[2] = 1`, because our approach is to track the largest idx in the CC, so all connection should point from smaller value to larger value**.\\n3. then no matter we choose idx from 1 or from 2, `root1 = root2 = 2` which is also the largest value in the group, then we know the next CC start from `idx = 3` \\n\\n\\n\\n## python\\n```python\\nclass UF:\\n    def __init__(self, n):\\n        self.parents = [i for i in range(n)]\\n        self.n = n\\n        \\n    def find(self, idx):\\n\\t    # path compression to prevent duplicate searches\\n        if idx != self.parents[idx]:\\n            self.parents[idx] = self.find(self.parents[idx])\\n        return self.parents[idx]\\n\\n    def unite(self, idx1, idx2):\\n        p1 = self.find(idx1)\\n        p2 = self.find(idx2)\\n\\t\\t# we always point from smaller value to the larger value\\n        if p1 < p2:\\n            self.parents[p1] = p2\\n        else:\\n            self.parents[p2] = p1\\n        \\n\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        rows = [UF(n) for i in range(m)]\\n        cols = [UF(m) for j in range(n)]\\n        seen = [[-1] * n for i in range(m)]\\n        \\n        step = 1\\n        queue = collections.deque([[0, 0]])\\n        while queue:\\n            for _ in range(len(queue)):\\n                r, c = queue.popleft()\\n                if seen[r][c] != -1:\\n                    continue\\n                seen[r][c] = step\\n                val = grid[r][c]\\n                while rows[r].find(c) < min(c + val, n - 1):\\n                    nxtc = rows[r].find(c) + 1\\n                    rows[r].unite(c, nxtc)\\n                    queue.append([r, nxtc])\\n                while cols[c].find(r) < min(r + val, m - 1):\\n                    nxtr = cols[c].find(r) + 1\\n                    cols[c].unite(r, nxtr)\\n                    queue.append([nxtr, c])\\n            step += 1\\n        return seen[-1][-1]             \\n```\\n\\n## C++\\n```cpp\\nclass DSU {\\npublic:\\n    int n;\\n    vector<int> parents;\\n    DSU(int _n) {\\n        n = _n;\\n        parents.resize(n);\\n        for(int i = 0; i < n; ++i) parents[i] = i;\\n    }\\n    \\n    int find(int idx) {\\n        if(idx != parents[idx]) {\\n            parents[idx] = find(parents[idx]);\\n        }\\n        return parents[idx];\\n    }\\n    \\n    void unite(int idx1, int idx2) {\\n        int p1 = find(idx1);\\n        int p2 = find(idx2);\\n        if (p1 < p2){\\n            parents[p1] = p2;\\n        } else {\\n            parents[p2] = p1;\\n        }\\n    }    \\n};\\n\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> seen(m, vector<int>(n, -1));\\n        vector<DSU> rows(m, DSU(n)), cols(n, DSU(m));\\n        deque<pair<int, int>> que;\\n        que.push_back({0, 0});\\n        int step = 1;\\n        while(que.size()) {\\n            int k = que.size();\\n            for(int i = 0; i < k; ++i) {\\n                auto [r, c] = que.front(); que.pop_front();\\n                if(seen[r][c] != -1) continue;\\n                seen[r][c] = step;\\n                int val = grid[r][c];\\n                while(rows[r].find(c) < min(n - 1, val + c)) {\\n                    int nxtc = rows[r].find(c) + 1;\\n                    rows[r].unite(c, nxtc);\\n                    que.push_back({r, nxtc});\\n\\n                }\\n                while(cols[c].find(r) < min(m - 1, val + r)) {\\n                    int nxtr = cols[c].find(r) + 1;\\n                    cols[c].unite(r, nxtr);\\n                    que.push_back({nxtr, c});\\n                }\\n            }\\n            step++;\\n        }\\n        \\n        return seen[m - 1][n - 1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```python\\nclass UF:\\n    def __init__(self, n):\\n        self.parents = [i for i in range(n)]\\n        self.n = n\\n        \\n    def find(self, idx):\\n\\t    # path compression to prevent duplicate searches\\n        if idx != self.parents[idx]:\\n            self.parents[idx] = self.find(self.parents[idx])\\n        return self.parents[idx]\\n\\n    def unite(self, idx1, idx2):\\n        p1 = self.find(idx1)\\n        p2 = self.find(idx2)\\n\\t\\t# we always point from smaller value to the larger value\\n        if p1 < p2:\\n            self.parents[p1] = p2\\n        else:\\n            self.parents[p2] = p1\\n        \\n\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        rows = [UF(n) for i in range(m)]\\n        cols = [UF(m) for j in range(n)]\\n        seen = [[-1] * n for i in range(m)]\\n        \\n        step = 1\\n        queue = collections.deque([[0, 0]])\\n        while queue:\\n            for _ in range(len(queue)):\\n                r, c = queue.popleft()\\n                if seen[r][c] != -1:\\n                    continue\\n                seen[r][c] = step\\n                val = grid[r][c]\\n                while rows[r].find(c) < min(c + val, n - 1):\\n                    nxtc = rows[r].find(c) + 1\\n                    rows[r].unite(c, nxtc)\\n                    queue.append([r, nxtc])\\n                while cols[c].find(r) < min(r + val, m - 1):\\n                    nxtr = cols[c].find(r) + 1\\n                    cols[c].unite(r, nxtr)\\n                    queue.append([nxtr, c])\\n            step += 1\\n        return seen[-1][-1]             \\n```\n```cpp\\nclass DSU {\\npublic:\\n    int n;\\n    vector<int> parents;\\n    DSU(int _n) {\\n        n = _n;\\n        parents.resize(n);\\n        for(int i = 0; i < n; ++i) parents[i] = i;\\n    }\\n    \\n    int find(int idx) {\\n        if(idx != parents[idx]) {\\n            parents[idx] = find(parents[idx]);\\n        }\\n        return parents[idx];\\n    }\\n    \\n    void unite(int idx1, int idx2) {\\n        int p1 = find(idx1);\\n        int p2 = find(idx2);\\n        if (p1 < p2){\\n            parents[p1] = p2;\\n        } else {\\n            parents[p2] = p1;\\n        }\\n    }    \\n};\\n\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> seen(m, vector<int>(n, -1));\\n        vector<DSU> rows(m, DSU(n)), cols(n, DSU(m));\\n        deque<pair<int, int>> que;\\n        que.push_back({0, 0});\\n        int step = 1;\\n        while(que.size()) {\\n            int k = que.size();\\n            for(int i = 0; i < k; ++i) {\\n                auto [r, c] = que.front(); que.pop_front();\\n                if(seen[r][c] != -1) continue;\\n                seen[r][c] = step;\\n                int val = grid[r][c];\\n                while(rows[r].find(c) < min(n - 1, val + c)) {\\n                    int nxtc = rows[r].find(c) + 1;\\n                    rows[r].unite(c, nxtc);\\n                    que.push_back({r, nxtc});\\n\\n                }\\n                while(cols[c].find(r) < min(m - 1, val + r)) {\\n                    int nxtr = cols[c].find(r) + 1;\\n                    cols[c].unite(r, nxtr);\\n                    que.push_back({nxtr, c});\\n                }\\n            }\\n            step++;\\n        }\\n        \\n        return seen[m - 1][n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395906,
                "title": "classic-dp-optimized-with-segment-tree-c",
                "content": "# Intuition\\nWe can see that this is a classic DP problem with a little twist.\\n\\n# Approach\\nLet\\'s look at the simple version , we can go from $(x,y)$ to $(x+1,y)$ or $(x,y+1)$ to solve this problem we use a DP with transitions: \\n$DP[i][j] = 1+min(DP[i+1][j],DP[i][j+1])$\\n\\nBut in this problem we have many more transitions:\\n$DP[i][j] = 1+min(DP[k][j],DP[i][l])$ for $i< k \\\\leq i+grid[i][j]$ and $j <l \\\\leq j+grid[i][j]$.\\n\\nAnd by running all the transitions we will get a TLE, but notice that the next cells we can visit are all continuous, so if we go in some order so that the cells I can visit already have an answer and we have some way to get the minimum value in a range then we will get the answer \\n\\nTo do this we use a segment tree for each row and column, we will start at cell $(n-1,m-1)$ and go from bottom to top and from right to left, for each cell we will get the range that it can visit, both in its same column and in its same row and ask to the segment tree for the minimum value in that range. Notice that here the important thing is the order in which we calculate the DP, because this way when we try to get the answer of $(x,y)$ is sure that the cells that it can visit were already calculated. \\n\\nIt may sound difficult but with a good template it can be easily managed.\\n\\n# Complexity\\n- Time complexity:\\n$O(n \\\\times m \\\\times log(n)+log(m))$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    struct STmin{\\n        int n;\\n        vector<int> st;\\n        STmin(int n):n(n){\\n            st.resize(2*n,1e9);\\n        }\\n        inline void update(int x, int val) {\\n            x += n;\\n            st[x] = val;\\n            for (; x >>=1 ; st[x] = min(st[x<<1], st[x<<1|1]));\\n        }\\n        inline int query(int l, int r) {\\n            int ans = 1e9;\\n            if(r<l)return 0;\\n            for (l += n, r += n; l <= r; l = (l + 1) / 2, r = (r - 1) / 2) {\\n                if (l & 1) ans = min(ans, st[l]);\\n                if (~r & 1) ans = min(ans, st[r]);\\n            }\\n            return ans;\\n        }\\n    };\\n    \\n    \\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        vector<vector<int>> dp(n,vector<int> (m,1e9));\\n        \\n            \\n        vector<STmin> rows;\\n        vector<STmin> cols;\\n        \\n        for(int i = 0;i<n;i++)\\n            rows.push_back(STmin(m));\\n        for(int i = 0;i<m;i++)\\n            cols.push_back(STmin(n));\\n        \\n        dp[n-1][m-1] = 1;\\n        rows[n-1].update(m-1,1);\\n        cols[m-1].update(n-1,1);\\n        \\n        for(int i =n-1;i>=0;i--){\\n            for(int j = m-1;j>=0;j--){\\n                int r = min(m-1,j+grid[i][j]);\\n                int d = min(n-1,i+grid[i][j]);\\n                if(grid[i][j]==0)continue;\\n                if((j+1)<m)\\n                    dp[i][j] = min(dp[i][j],1+rows[i].query(j+1,r));\\n                if((i+1)<n)\\n                    dp[i][j] = min(dp[i][j],1+cols[j].query(i+1,d));\\n                \\n                rows[i].update(j,dp[i][j]);\\n                cols[j].update(i,dp[i][j]);\\n            }\\n        }\\n        if(dp[0][0]== 1e9)return -1;\\n        return dp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct STmin{\\n        int n;\\n        vector<int> st;\\n        STmin(int n):n(n){\\n            st.resize(2*n,1e9);\\n        }\\n        inline void update(int x, int val) {\\n            x += n;\\n            st[x] = val;\\n            for (; x >>=1 ; st[x] = min(st[x<<1], st[x<<1|1]));\\n        }\\n        inline int query(int l, int r) {\\n            int ans = 1e9;\\n            if(r<l)return 0;\\n            for (l += n, r += n; l <= r; l = (l + 1) / 2, r = (r - 1) / 2) {\\n                if (l & 1) ans = min(ans, st[l]);\\n                if (~r & 1) ans = min(ans, st[r]);\\n            }\\n            return ans;\\n        }\\n    };\\n    \\n    \\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        vector<vector<int>> dp(n,vector<int> (m,1e9));\\n        \\n            \\n        vector<STmin> rows;\\n        vector<STmin> cols;\\n        \\n        for(int i = 0;i<n;i++)\\n            rows.push_back(STmin(m));\\n        for(int i = 0;i<m;i++)\\n            cols.push_back(STmin(n));\\n        \\n        dp[n-1][m-1] = 1;\\n        rows[n-1].update(m-1,1);\\n        cols[m-1].update(n-1,1);\\n        \\n        for(int i =n-1;i>=0;i--){\\n            for(int j = m-1;j>=0;j--){\\n                int r = min(m-1,j+grid[i][j]);\\n                int d = min(n-1,i+grid[i][j]);\\n                if(grid[i][j]==0)continue;\\n                if((j+1)<m)\\n                    dp[i][j] = min(dp[i][j],1+rows[i].query(j+1,r));\\n                if((i+1)<n)\\n                    dp[i][j] = min(dp[i][j],1+cols[j].query(i+1,d));\\n                \\n                rows[i].update(j,dp[i][j]);\\n                cols[j].update(i,dp[i][j]);\\n            }\\n        }\\n        if(dp[0][0]== 1e9)return -1;\\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399875,
                "title": "c-bfs",
                "content": "# Code\\n```\\nclass Solution {\\n    #define ll long long\\n    int n,m;\\npublic:\\n   \\n    int minimumVisitedCells(vector<vector<int>>& g) {\\n         n=g.size();m=g[0].size();\\n        vector<vector<ll>>v(n,vector<ll>(m,0));\\n        v[0][0]=1;\\n        int ans=0;\\n        queue<pair<int,int>>q;\\n        q.push({0,0});\\n       while(q.size()){\\n           int sz=q.size();\\n           ans++;\\n           for(int i=0;i<sz;i++){\\n               int x=q.front().first;\\n               int y=q.front().second;\\n               if(x==n-1 && y==m-1)return ans;\\n               int val=g[x][y];\\n               q.pop();\\n               for(int it=min(n-1,val+x);it>=x+1;it--){\\n                  // cout<<it<<\" \"<<y<<endl;\\n                   if(v[it][y])continue;\\n                   v[it][y]=1;\\n                   q.push({it,y});\\n               }\\n               for(int it=min(m-1,val+y);it>=y+1;it--){\\n                  // cout<<x<<\" \"<<it<<endl;\\n                   if(v[x][it])continue;\\n                   v[x][it]=1;\\n                   q.push({x,it});\\n               }\\n           }\\n       }\\n       return -1;\\n    }\\n};\\n```\\n![upvote (3).jpg](https://assets.leetcode.com/users/images/f3f66b38-d316-4fbd-9556-c654fe75f637_1681114162.9203422.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    #define ll long long\\n    int n,m;\\npublic:\\n   \\n    int minimumVisitedCells(vector<vector<int>>& g) {\\n         n=g.size();m=g[0].size();\\n        vector<vector<ll>>v(n,vector<ll>(m,0));\\n        v[0][0]=1;\\n        int ans=0;\\n        queue<pair<int,int>>q;\\n        q.push({0,0});\\n       while(q.size()){\\n           int sz=q.size();\\n           ans++;\\n           for(int i=0;i<sz;i++){\\n               int x=q.front().first;\\n               int y=q.front().second;\\n               if(x==n-1 && y==m-1)return ans;\\n               int val=g[x][y];\\n               q.pop();\\n               for(int it=min(n-1,val+x);it>=x+1;it--){\\n                  // cout<<it<<\" \"<<y<<endl;\\n                   if(v[it][y])continue;\\n                   v[it][y]=1;\\n                   q.push({it,y});\\n               }\\n               for(int it=min(m-1,val+y);it>=y+1;it--){\\n                  // cout<<x<<\" \"<<it<<endl;\\n                   if(v[x][it])continue;\\n                   v[x][it]=1;\\n                   q.push({x,it});\\n               }\\n           }\\n       }\\n       return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3397039,
                "title": "dp-with-monotonic-stacks",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can calculate the optimum path length starting from any cell in a grid, provided that we already know the solution for all the cells below it and and on the right from it. For the bottom-right corner, the answer is 1.\\nSo that means DP. We will start with (M-1,N-1) and go left and up until we reach (0,0).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf we do it in a naive way, we must check all the cells to the right and all the cells to the bottom from every given cell. That means $$O(M*N*(M+N))$$ - too slow. We want to query `grid[i][j]` cells to the right and `grid[i][j]` cell down from (i,j) for the minimum value. This is where monotonic stack can help us.\\n\\nClass `Mono` implements monotonic stack. It has the following methods:\\n* `put` adds a value to the end.\\n* `query` returns the minumum value among `g` last values (if there hasn\\'t been `g` values, it returns the global minimum).\\n\\nBinary search is used when quering for the minumum value to find a necessary position in the stack.\\n\\n`put` uses O(1) amortized time, `query` uses O(log L) time where L is the maximum number of values.\\n\\nI also tried segment tree first, but was given a TLE on one of the last tests.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nFor every cell, we do 2 queries and 2 puts, so it\\'s $$O(M*N*(log M + log N)) = O(MN * log MN)$$.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nIt\\'s $$O(M*N)$$.\\n\\n# Code\\n```\\nfrom bisect import bisect_left\\n\\nclass Mono:\\n    def __init__(self):\\n        self.I = []\\n        self.V = []\\n        self.N = 0\\n    def put(self, v):\\n        while self.V and self.V[-1]>=v:\\n            self.V.pop()\\n            self.I.pop()\\n        self.V.append(v)\\n        self.I.append(self.N)\\n        self.N += 1\\n    def query(self, g):\\n        ii = self.N - g\\n        j = bisect_left(self.I,ii)\\n        assert(self.I[j]>=ii)\\n        return self.V[j]\\n\\n\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        Inf = 10**9\\n        M = len(grid)\\n        N = len(grid[0])\\n        H = [Mono() for _ in range(M)]\\n        V = [Mono() for _ in range(N)]\\n        H[-1].put(1)\\n        V[-1].put(1)\\n        for j in range(N-2,-1,-1):\\n            g = grid[-1][j]\\n            if g==0:\\n                v = Inf\\n            else:\\n                v = 1+H[-1].query(g)\\n            H[-1].put(v)\\n            V[j].put(v)\\n        for i in range(M-2,-1,-1):\\n            g = grid[i][-1]\\n            if g==0:\\n                v = Inf\\n            else:    \\n                v = 1+V[-1].query(g)\\n            H[i].put(v)\\n            V[-1].put(v)\\n            for j in range(N-2,-1,-1):\\n                g = grid[i][j]\\n                if g==0:\\n                    v = Inf\\n                else:\\n                    v1 = V[j].query(g)\\n                    v2 = H[i].query(g)\\n                    v = 1+min(v1,v2)\\n                H[i].put(v)\\n                V[j].put(v)\\n        r = H[0].query(1)\\n        self.H = H\\n        self.V = V\\n        return r if r<Inf else -1\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Dynamic Programming",
                    "Monotonic Stack"
                ],
                "code": "```\\nfrom bisect import bisect_left\\n\\nclass Mono:\\n    def __init__(self):\\n        self.I = []\\n        self.V = []\\n        self.N = 0\\n    def put(self, v):\\n        while self.V and self.V[-1]>=v:\\n            self.V.pop()\\n            self.I.pop()\\n        self.V.append(v)\\n        self.I.append(self.N)\\n        self.N += 1\\n    def query(self, g):\\n        ii = self.N - g\\n        j = bisect_left(self.I,ii)\\n        assert(self.I[j]>=ii)\\n        return self.V[j]\\n\\n\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        Inf = 10**9\\n        M = len(grid)\\n        N = len(grid[0])\\n        H = [Mono() for _ in range(M)]\\n        V = [Mono() for _ in range(N)]\\n        H[-1].put(1)\\n        V[-1].put(1)\\n        for j in range(N-2,-1,-1):\\n            g = grid[-1][j]\\n            if g==0:\\n                v = Inf\\n            else:\\n                v = 1+H[-1].query(g)\\n            H[-1].put(v)\\n            V[j].put(v)\\n        for i in range(M-2,-1,-1):\\n            g = grid[i][-1]\\n            if g==0:\\n                v = Inf\\n            else:    \\n                v = 1+V[-1].query(g)\\n            H[i].put(v)\\n            V[-1].put(v)\\n            for j in range(N-2,-1,-1):\\n                g = grid[i][j]\\n                if g==0:\\n                    v = Inf\\n                else:\\n                    v1 = V[j].query(g)\\n                    v2 = H[i].query(g)\\n                    v = 1+min(v1,v2)\\n                H[i].put(v)\\n                V[j].put(v)\\n        r = H[0].query(1)\\n        self.H = H\\n        self.V = V\\n        return r if r<Inf else -1\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396720,
                "title": "simple-bfs-remove-poistions-when-visited",
                "content": "# Intuition\\nWe can solve it using similar idea as this question in BFS.\\nhttps://leetcode.com/problems/minimum-reverse-operations/\\n\\n# Approach\\nThe key point is instead of generating all the positions and check whether they are visited, we use unvisited positions to \"intersect\" with possible new positions.\\nThe reason is that if we are at (r, c),\\nthe next positions are \\n(1) poisitions with same row = r, and column c + 1 ,c + 2.....\\nif we save all the unvisited positions in row r into a (ordered_set), we can just do binary search (or upper_bound in C++) to find the first position that is larger than c. And we loop them one by one, put them into queue and erase them from the set. So that each position is visited only once.\\n\\n(2) positions with the same column = c and row = r + 1, ....\\nThis can be solved similary by querying the unvisited position set on column c to find the first poistion that is larger than r.\\n\\nIn short using (ordered) set operations we can simply find the first poistion larger than a given point and iterate them in increasing order and delete them at the same time.\\n\\n# Complexity\\n- Time complexity:\\nO(n * m * log(m + n))\\n\\n- Space complexity:\\nO(m * n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        const int m = grid.size(), n = grid[0].size();\\n        if (m == 1 && n == 1) {\\n            return 1;\\n        }\\n        vector<set<int>> r(m), c(n);\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = i ? 0 : 1; j < n; ++j) {\\n                r[i].insert(j);\\n                c[j].insert(i);\\n            }\\n        }\\n        queue<pair<int ,int>> q;\\n        q.push({0, 0});\\n        for (int step = 2; !q.empty(); ++step) {\\n            for (int t = q.size(); t; --t) {\\n                const auto p = q.front();\\n                q.pop();\\n                if (grid[p.first][p.second] == 0) {\\n                    continue;\\n                }\\n                for (auto t = r[p.first].upper_bound(p.second); t != r[p.first].end() && *t <= p.second + grid[p.first][p.second];) {\\n                    if (p.first == m - 1 && *t == n - 1) {\\n                        return step;\\n                    }\\n                    q.push({p.first, *t});\\n                    c[*t].erase(p.first);\\n                    r[p.first].erase(t++);\\n                }\\n                for (auto t = c[p.second].upper_bound(p.first); t != c[p.second].end() && *t <= p.first + grid[p.first][p.second];) {\\n                    if (p.second == n - 1 && *t == m - 1) {\\n                        return step;\\n                    }\\n                    q.push({*t, p.second});\\n                    r[*t].erase(p.second);\\n                    c[p.second].erase(t++);\\n                }\\n\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        const int m = grid.size(), n = grid[0].size();\\n        if (m == 1 && n == 1) {\\n            return 1;\\n        }\\n        vector<set<int>> r(m), c(n);\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = i ? 0 : 1; j < n; ++j) {\\n                r[i].insert(j);\\n                c[j].insert(i);\\n            }\\n        }\\n        queue<pair<int ,int>> q;\\n        q.push({0, 0});\\n        for (int step = 2; !q.empty(); ++step) {\\n            for (int t = q.size(); t; --t) {\\n                const auto p = q.front();\\n                q.pop();\\n                if (grid[p.first][p.second] == 0) {\\n                    continue;\\n                }\\n                for (auto t = r[p.first].upper_bound(p.second); t != r[p.first].end() && *t <= p.second + grid[p.first][p.second];) {\\n                    if (p.first == m - 1 && *t == n - 1) {\\n                        return step;\\n                    }\\n                    q.push({p.first, *t});\\n                    c[*t].erase(p.first);\\n                    r[p.first].erase(t++);\\n                }\\n                for (auto t = c[p.second].upper_bound(p.first); t != c[p.second].end() && *t <= p.first + grid[p.first][p.second];) {\\n                    if (p.second == n - 1 && *t == m - 1) {\\n                        return step;\\n                    }\\n                    q.push({*t, p.second});\\n                    r[*t].erase(p.second);\\n                    c[p.second].erase(t++);\\n                }\\n\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585267,
                "title": "c-bfs-solution-set-lower-bound",
                "content": "**Algorithm**\\n1. make 2 vector of set of Integers, \\n\\t\\tone for row (which stores indices of unvisited cells in each row) \\n\\t\\tone for column (which stores indices of unvisited cells in each column) \\n2. perform bfs and push index of top-left cell in queue\\n3. extract the unvisited reachable nodes from the cell, travelling in the row and column \\nAnd erase them from the set.\\n4. To find the starting point of traversal in ewch row and column, we use lower_bound in set \\n\\t\\t\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        queue<vector<int>>q;\\n        q.push({0,0});\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int dist=1;\\n        vector<set<int>> row(n),col(m);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                row[i].insert(j);\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                col[i].insert(j);\\n            }\\n        }\\n        vector<vector<bool>> vis(n,vector<bool>(m,0));\\n        vis[0][0]=true;\\n        col[0].erase(0);\\n        row[0].erase(0);\\n        while(!q.empty()){\\n            int size=q.size();\\n            while(size--){\\n                auto node=q.front();q.pop();\\n                int i=node[0],j=node[1];\\n                if(i==n-1 and j==m-1)return dist;\\n                auto itr=row[i].lower_bound(j+1);\\n                int val=*itr;\\n                while(itr!=row[i].end() and (*itr)<=(grid[i][j]+j)){\\n                    val=*itr;\\n                    row[i].erase(itr);\\n                    if(!vis[i][val]){\\n                        q.push({i,val});vis[i][val]=true;\\n                    }\\n                    itr=row[i].lower_bound(val);\\n                }\\n                itr=col[j].lower_bound(i+1);\\n                val=*itr;\\n                while(itr!=col[j].end() and (*itr)<=(grid[i][j]+i)){\\n                    val=*itr;\\n                    col[j].erase(itr);\\n                    if(!vis[val][j]){\\n                        q.push({val,j});\\n                        vis[val][j]=true;\\n                    }\\n                    itr=col[j].lower_bound(val);\\n                }\\n            }\\n            dist++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        queue<vector<int>>q;\\n        q.push({0,0});\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int dist=1;\\n        vector<set<int>> row(n),col(m);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                row[i].insert(j);\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                col[i].insert(j);\\n            }\\n        }\\n        vector<vector<bool>> vis(n,vector<bool>(m,0));\\n        vis[0][0]=true;\\n        col[0].erase(0);\\n        row[0].erase(0);\\n        while(!q.empty()){\\n            int size=q.size();\\n            while(size--){\\n                auto node=q.front();q.pop();\\n                int i=node[0],j=node[1];\\n                if(i==n-1 and j==m-1)return dist;\\n                auto itr=row[i].lower_bound(j+1);\\n                int val=*itr;\\n                while(itr!=row[i].end() and (*itr)<=(grid[i][j]+j)){\\n                    val=*itr;\\n                    row[i].erase(itr);\\n                    if(!vis[i][val]){\\n                        q.push({i,val});vis[i][val]=true;\\n                    }\\n                    itr=row[i].lower_bound(val);\\n                }\\n                itr=col[j].lower_bound(i+1);\\n                val=*itr;\\n                while(itr!=col[j].end() and (*itr)<=(grid[i][j]+i)){\\n                    val=*itr;\\n                    col[j].erase(itr);\\n                    if(!vis[val][j]){\\n                        q.push({val,j});\\n                        vis[val][j]=true;\\n                    }\\n                    itr=col[j].lower_bound(val);\\n                }\\n            }\\n            dist++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396619,
                "title": "simple-binary-search-for-dp",
                "content": "# Intuition\\nJust use kind of DP\\ndp[i][j] = min(\\ndp[i][j + 1], dp[i][j + 2]....\\ndp[i + 1][j], dp[i + 2][j]......\\n) + 1\\n\\nThe key point here is something like \"Monotonic Queue\". \\nFor example\\nWhen calculating dp[i][j]\\nif we have k1 > k2 && dp[i][k1] >= dp[i][k2], we don\\'t need the dp[i][k1] for transition. \\nIn other words, the reason we need a further distance (or a larger index) for transition is that it can provide smaller result.\\nSo we only need to save/maintain the values that\\ndp[i][k1] >= dp[i][k2] >= dp[i][k3]....\\nwith k1 <= k2 <= k3...etc.\\n\\nSimilarly, we only need the values that\\ndp[k1][j] >= dp[k2][j] >= ...\\nwith k1 <= k2 <= k3 for DP transistion.\\n\\nAnd we can maintain the lists using the same idea as \"Monotonic Queue\". \\nThen we can do binary search to find the smallest value(s) in the 2 lists to calculate dp[i][j]\\n\\n# Approach\\nBinary Search + DP\\n\\n# Complexity\\n- Time complexity:\\nO(m * n * log(m + n))\\n\\n- Space complexity:\\nO(m * n)\\n\\n# Code\\n```\\nclass Solution {\\n    int better(int x, int y) {\\n        if (x < 0) {\\n            return y < 0 ? (-1) : (y + 1);\\n        }\\n        return (y < 0 ? x : min(x, y)) + 1;\\n    }\\n\\n    int search(const vector<pair<int, int>> &v, int x) {\\n        int left = 0, right = static_cast<int>(v.size()) - 1;\\n        while (left <= right) {\\n            const int mid = (left + right) >> 1;\\n            if (v[mid].first <= x) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return ++right >= v.size() ? (-1) : v[right].second;\\n    }\\n\\n    void update(vector<pair<int, int>> &v, const pair<int, int> &p) {\\n        while (!v.empty() && v.back().second >= p.second) {\\n            v.pop_back();\\n        }\\n        v.push_back(p);\\n    }\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        const int m = grid.size(), n = grid[0].size();\\n        if (m == 1 && n == 1) {\\n            return 1;\\n        }\\n        vector<vector<pair<int, int>>> down(n);\\n        for (int i = m - 1; i >= 0; --i) {\\n            vector<pair<int, int>> right;\\n            if (i == m - 1) {\\n                down[n - 1].push_back({m - 1, 1});\\n                right.push_back({n - 1, 1});\\n            }\\n            for (int j = i == m - 1 ? (n - 2) : (n - 1); j >= 0; --j) {\\n                if (grid[i][j] == 0) {\\n                    continue;\\n                }\\n                const int v = better(search(down[j], min(i + grid[i][j], m - 1)),\\n                search(right, min(j + grid[i][j], n - 1)));\\n                if (i == 0 && j == 0) {\\n                    return v;\\n                }\\n                if (v >= 0) {\\n                    update(down[j], {i, v});\\n                    update(right, {j, v});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int better(int x, int y) {\\n        if (x < 0) {\\n            return y < 0 ? (-1) : (y + 1);\\n        }\\n        return (y < 0 ? x : min(x, y)) + 1;\\n    }\\n\\n    int search(const vector<pair<int, int>> &v, int x) {\\n        int left = 0, right = static_cast<int>(v.size()) - 1;\\n        while (left <= right) {\\n            const int mid = (left + right) >> 1;\\n            if (v[mid].first <= x) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return ++right >= v.size() ? (-1) : v[right].second;\\n    }\\n\\n    void update(vector<pair<int, int>> &v, const pair<int, int> &p) {\\n        while (!v.empty() && v.back().second >= p.second) {\\n            v.pop_back();\\n        }\\n        v.push_back(p);\\n    }\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        const int m = grid.size(), n = grid[0].size();\\n        if (m == 1 && n == 1) {\\n            return 1;\\n        }\\n        vector<vector<pair<int, int>>> down(n);\\n        for (int i = m - 1; i >= 0; --i) {\\n            vector<pair<int, int>> right;\\n            if (i == m - 1) {\\n                down[n - 1].push_back({m - 1, 1});\\n                right.push_back({n - 1, 1});\\n            }\\n            for (int j = i == m - 1 ? (n - 2) : (n - 1); j >= 0; --j) {\\n                if (grid[i][j] == 0) {\\n                    continue;\\n                }\\n                const int v = better(search(down[j], min(i + grid[i][j], m - 1)),\\n                search(right, min(j + grid[i][j], n - 1)));\\n                if (i == 0 && j == 0) {\\n                    return v;\\n                }\\n                if (v >= 0) {\\n                    update(down[j], {i, v});\\n                    update(right, {j, v});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396173,
                "title": "java-the-solution-that-records-max-i-s-for-each-column-and-max-j-s-for-each-row-is-not-correct",
                "content": "# Intuition\\nFor the following test case\\n```\\n[[1,1,5,1,1,1,1,1],\\n[1,0,1,1,1,1,1,1],\\n[1,0,1,1,1,1,1,1],\\n[1,0,1,1,1,1,1,1],\\n[1,10,1,1,1,1,1,0]]\\n```\\nThat solution will return 8 while the correct answer is 7. This is because we will never reach (1, 4) because we reached (2, 4) first and updated `max_i[4]` with 6.\\nHowever, we can instead record the minimal index of the cell not visited.\\n# Complexity\\n- Time complexity: $$O(mn \\\\cdot max(m, n))$$ as it potentially needs to visit cell once and for each visit, it needs to go through the cells either below or to the right.\\n- Space complexity: $$O(mn)$$\\n# Code\\n```\\n    public int minimumVisitedCells(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        int[] horizontals = new int[m], verticals = new int[n];\\n        LinkedList<int[]> queue = new LinkedList<>();\\n        queue.add(new int[] {0, 0});\\n        horizontals[0] = 1;\\n        verticals[0] = 1;\\n        for (int output = 1; !queue.isEmpty(); output++) for (int i = queue.size(); i > 0; i--) {\\n            int[] t = queue.removeFirst();\\n            int x = t[0], y = t[1];\\n            if (x == m - 1 && y == n - 1) return output;\\n            for (int j = Math.max(horizontals[x], y + 1); j <= grid[x][y] + y && j < n; j++) if (!visited[x][j]) {\\n                visited[x][j] = true;\\n                queue.add(new int[] {x, j});\\n            }\\n            while (horizontals[x] < n && visited[x][horizontals[x]]) horizontals[x]++;\\n            for (int j = Math.max(verticals[y], x + 1); j <= grid[x][y] + x && j < m; j++) if (!visited[j][y]) {\\n                visited[j][y] = true;\\n                queue.add(new int[] {j, y});\\n            }\\n            while (verticals[y] < m && visited[verticals[y]][y]) verticals[y]++;\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n[[1,1,5,1,1,1,1,1],\\n[1,0,1,1,1,1,1,1],\\n[1,0,1,1,1,1,1,1],\\n[1,0,1,1,1,1,1,1],\\n[1,10,1,1,1,1,1,0]]\\n```\n```\\n    public int minimumVisitedCells(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        int[] horizontals = new int[m], verticals = new int[n];\\n        LinkedList<int[]> queue = new LinkedList<>();\\n        queue.add(new int[] {0, 0});\\n        horizontals[0] = 1;\\n        verticals[0] = 1;\\n        for (int output = 1; !queue.isEmpty(); output++) for (int i = queue.size(); i > 0; i--) {\\n            int[] t = queue.removeFirst();\\n            int x = t[0], y = t[1];\\n            if (x == m - 1 && y == n - 1) return output;\\n            for (int j = Math.max(horizontals[x], y + 1); j <= grid[x][y] + y && j < n; j++) if (!visited[x][j]) {\\n                visited[x][j] = true;\\n                queue.add(new int[] {x, j});\\n            }\\n            while (horizontals[x] < n && visited[x][horizontals[x]]) horizontals[x]++;\\n            for (int j = Math.max(verticals[y], x + 1); j <= grid[x][y] + x && j < m; j++) if (!visited[j][y]) {\\n                visited[j][y] = true;\\n                queue.add(new int[] {j, y});\\n            }\\n            while (verticals[y] < m && visited[verticals[y]][y]) verticals[y]++;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3395746,
                "title": "segment-tree-for-each-row-and-column",
                "content": "# Complexity\\n- Time complexity: $$O(m * n * (log(m) + log(n)))$$\\n- Space complexity: $$O(m * n)$$\\n\\n# Code\\n```\\nint INF = 1e9;\\n\\ntemplate <typename T = int> \\nclass SegmentTree {\\npublic:\\n    \\n    vector<T> st; // segment tree\\n    vector<T> arr; // input array\\n    int n; // size of the input array\\n\\t\\n\\t// MODIFIABLE\\n\\tT invalidValue = INF;\\n    \\n\\tint left(int ind) {\\n\\t\\treturn 2*ind + 1;\\n\\t}\\n\\n\\tint right(int ind) {\\n\\t\\treturn 2*ind + 2;\\n\\t}\\n\\n\\t// MODIFIABLE\\n\\tT operate(T a, T b){\\n\\t\\t// value at a node will be sum of left and right node in the case of Range Sum Query\\n        return min(a, b);\\n\\t}\\n\\n\\t// MODIFIABLE\\n\\tvoid pull(int ind) {\\n\\t\\tst[ind] = operate(st[left(ind)], st[right(ind)]);\\n\\t}\\n\\n    // building the segment tree\\n    void build(int l, int r, int ind){\\n        // if we have reached the leaf node\\n        if(l == r){\\n            st[ind] = arr[l];\\n            return;\\n        }\\n        \\n        int m = (l+r)/2;\\n        \\n        // build the left tree and right tree\\n        build(l, m, left(ind));\\n        build(m+1, r, right(ind));\\n        \\n        // the value at current node\\n        pull(ind);\\n    }\\n    \\n    // sum of values between i and j\\n    T query(int l, int r, int i, int j, int ind){\\n        // if (l, r) lies completely inside (i, j)\\n        if(l>=i and r<=j){\\n            return st[ind];\\n        }\\n        // if (l, r) lies completely outside (i, j)\\n        if(r<i or l>j){\\n            return invalidValue;\\n        }\\n        \\n        int m = (l+r)/2;\\n\\n\\t\\t// call the function recursively for left and right child\\n\\t\\tT leftVal = query(l, m, i, j, left(ind));\\n\\t\\tT rightVal = query(m+1, r, i, j, right(ind));\\n\\n        return operate(leftVal, rightVal);\\n    }\\n    \\n    // updating the value in segment tree\\n    void update(int l, int r, T val, int i, int ind){\\n\\t\\t// if you reach a leaf node\\n\\t\\tif(l == r){\\n\\t\\t\\t// if you reach node with index i\\n\\t\\t\\tif(l == i){\\n\\t\\t\\t\\tst[ind] = val;\\n                arr[l] = val;\\n\\t\\t\\t}\\n\\t\\t\\treturn;\\n\\t\\t}\\n        // if i lies completely outside (l, r)\\n        if(i<l or i>r){\\n            return;\\n        }\\n        \\n        // if the current node is not a leaf node\\n        if(l != r){\\n            int m = (l+r)/2;\\n            update(l, m, val, i, left(ind));\\n            update(m+1, r, val, i, right(ind));\\n\\t\\t\\tpull(ind);\\n        }\\n    }\\n    \\n    SegmentTree(vector<T>& nums) {\\n        n = nums.size();\\n        arr = nums;\\n        st = vector<T>(4*n);\\n        \\n        // build the segment tree\\n        build(0, n-1, 0);\\n    }\\n\\n    SegmentTree(int n) {\\n        this->n = n;\\n        arr = vector<T>(n, 0);\\n        st = vector<T>(4*n);\\n\\n        // build the segment tree\\n        build(0, n-1, 0);\\n    }\\n    \\n    void update(int index, T val) {\\n        arr[index] = val;\\n        update(0, n-1, val, index, 0);\\n    }\\n    \\n    T query(int left, int right) {\\n        return query(0, n-1, left, right, 0);\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    \\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        // we can solve this problem using dynamic programming\\n        // and an RMQ data structure like segment tree\\n        // we should use a segment tree for each row and column\\n        int m = grid.size(), n = grid[0].size();\\n        vector<int> r(n, INF);\\n        vector<int> c(m, INF);\\n        \\n        vector<SegmentTree<int>> row(m, SegmentTree<int>(r));\\n        vector<SegmentTree<int>> col(n, SegmentTree<int>(c));\\n        \\n        row[m-1].update(n-1, 1);\\n        col[n-1].update(m-1, 1);\\n        \\n        for(int i=m-1; i>=0; i--) {\\n            for(int j=n-1; j>=0; j--) {\\n                if(grid[i][j] == 0) continue;\\n                \\n                int val = INF;\\n                \\n                // check the row\\n                if(j+1 < n) {\\n                    int l = j + 1;\\n                    int r = min(n-1, j + grid[i][j]);\\n                    \\n                    val = min(val, row[i].query(l, r) + 1);\\n                    \\n                }\\n                // check the col\\n                if(i+1 < m) {\\n                    int l = i + 1;\\n                    int r = min(m-1, i + grid[i][j]);\\n                    \\n                    val = min(val, col[j].query(l, r) + 1);\\n                }\\n                \\n                \\n                row[i].update(j, val);\\n                col[j].update(i, val);\\n            }\\n        }\\n        \\n        int result = row[0].query(0, 0); \\n        return result >= INF ? -1 : result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Segment Tree"
                ],
                "code": "```\\nint INF = 1e9;\\n\\ntemplate <typename T = int> \\nclass SegmentTree {\\npublic:\\n    \\n    vector<T> st; // segment tree\\n    vector<T> arr; // input array\\n    int n; // size of the input array\\n\\t\\n\\t// MODIFIABLE\\n\\tT invalidValue = INF;\\n    \\n\\tint left(int ind) {\\n\\t\\treturn 2*ind + 1;\\n\\t}\\n\\n\\tint right(int ind) {\\n\\t\\treturn 2*ind + 2;\\n\\t}\\n\\n\\t// MODIFIABLE\\n\\tT operate(T a, T b){\\n\\t\\t// value at a node will be sum of left and right node in the case of Range Sum Query\\n        return min(a, b);\\n\\t}\\n\\n\\t// MODIFIABLE\\n\\tvoid pull(int ind) {\\n\\t\\tst[ind] = operate(st[left(ind)], st[right(ind)]);\\n\\t}\\n\\n    // building the segment tree\\n    void build(int l, int r, int ind){\\n        // if we have reached the leaf node\\n        if(l == r){\\n            st[ind] = arr[l];\\n            return;\\n        }\\n        \\n        int m = (l+r)/2;\\n        \\n        // build the left tree and right tree\\n        build(l, m, left(ind));\\n        build(m+1, r, right(ind));\\n        \\n        // the value at current node\\n        pull(ind);\\n    }\\n    \\n    // sum of values between i and j\\n    T query(int l, int r, int i, int j, int ind){\\n        // if (l, r) lies completely inside (i, j)\\n        if(l>=i and r<=j){\\n            return st[ind];\\n        }\\n        // if (l, r) lies completely outside (i, j)\\n        if(r<i or l>j){\\n            return invalidValue;\\n        }\\n        \\n        int m = (l+r)/2;\\n\\n\\t\\t// call the function recursively for left and right child\\n\\t\\tT leftVal = query(l, m, i, j, left(ind));\\n\\t\\tT rightVal = query(m+1, r, i, j, right(ind));\\n\\n        return operate(leftVal, rightVal);\\n    }\\n    \\n    // updating the value in segment tree\\n    void update(int l, int r, T val, int i, int ind){\\n\\t\\t// if you reach a leaf node\\n\\t\\tif(l == r){\\n\\t\\t\\t// if you reach node with index i\\n\\t\\t\\tif(l == i){\\n\\t\\t\\t\\tst[ind] = val;\\n                arr[l] = val;\\n\\t\\t\\t}\\n\\t\\t\\treturn;\\n\\t\\t}\\n        // if i lies completely outside (l, r)\\n        if(i<l or i>r){\\n            return;\\n        }\\n        \\n        // if the current node is not a leaf node\\n        if(l != r){\\n            int m = (l+r)/2;\\n            update(l, m, val, i, left(ind));\\n            update(m+1, r, val, i, right(ind));\\n\\t\\t\\tpull(ind);\\n        }\\n    }\\n    \\n    SegmentTree(vector<T>& nums) {\\n        n = nums.size();\\n        arr = nums;\\n        st = vector<T>(4*n);\\n        \\n        // build the segment tree\\n        build(0, n-1, 0);\\n    }\\n\\n    SegmentTree(int n) {\\n        this->n = n;\\n        arr = vector<T>(n, 0);\\n        st = vector<T>(4*n);\\n\\n        // build the segment tree\\n        build(0, n-1, 0);\\n    }\\n    \\n    void update(int index, T val) {\\n        arr[index] = val;\\n        update(0, n-1, val, index, 0);\\n    }\\n    \\n    T query(int left, int right) {\\n        return query(0, n-1, left, right, 0);\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    \\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        // we can solve this problem using dynamic programming\\n        // and an RMQ data structure like segment tree\\n        // we should use a segment tree for each row and column\\n        int m = grid.size(), n = grid[0].size();\\n        vector<int> r(n, INF);\\n        vector<int> c(m, INF);\\n        \\n        vector<SegmentTree<int>> row(m, SegmentTree<int>(r));\\n        vector<SegmentTree<int>> col(n, SegmentTree<int>(c));\\n        \\n        row[m-1].update(n-1, 1);\\n        col[n-1].update(m-1, 1);\\n        \\n        for(int i=m-1; i>=0; i--) {\\n            for(int j=n-1; j>=0; j--) {\\n                if(grid[i][j] == 0) continue;\\n                \\n                int val = INF;\\n                \\n                // check the row\\n                if(j+1 < n) {\\n                    int l = j + 1;\\n                    int r = min(n-1, j + grid[i][j]);\\n                    \\n                    val = min(val, row[i].query(l, r) + 1);\\n                    \\n                }\\n                // check the col\\n                if(i+1 < m) {\\n                    int l = i + 1;\\n                    int r = min(m-1, i + grid[i][j]);\\n                    \\n                    val = min(val, col[j].query(l, r) + 1);\\n                }\\n                \\n                \\n                row[i].update(j, val);\\n                col[j].update(i, val);\\n            }\\n        }\\n        \\n        int result = row[0].query(0, 0); \\n        return result >= INF ? -1 : result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398401,
                "title": "java-dijkstra",
                "content": "# Code\\n```\\nclass Tupule\\n{\\n    int row=0;\\n    int col=0;\\n    int dis=0;\\n    Tupule(int r,int j,int d)\\n    {\\n        this.row=r;\\n        this.col=j;\\n        this.dis=d;\\n    }\\n}\\nclass Solution {\\n    public int minimumVisitedCells(int[][] grid) {\\n         int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] visited = new int[m][n]; \\n\\n        PriorityQueue<Tupule> pq = new PriorityQueue<>((a, b) -> a.dis - b.dis); \\n        pq.offer(new Tupule(0,0,1));\\n\\n        while (!pq.isEmpty()) {\\n            int i = pq.peek().row;\\n            int j = pq.peek().col;\\n            int visitedCells =pq.peek().dis;\\n            pq.poll();\\n\\n            if (i == m - 1 && j == n - 1) {\\n                return visitedCells;\\n            }\\n\\n            if (visited[i][j] > 0) { \\n                continue;\\n            }\\n            visited[i][j] = visitedCells; \\n\\n            \\n            for (int k = j + 1; k <= j + grid[i][j] && k < n; k++) {\\n                if (visited[i][k] == 0) {\\n                    pq.offer(new Tupule(i, k, visitedCells + 1));\\n                }\\n            }\\n\\n            \\n            for (int k = i + 1; k <= i + grid[i][j] && k < m; k++) {\\n                if (visited[k][j] == 0) {\\n                    pq.offer(new Tupule(k, j, visitedCells + 1));\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Tupule\\n{\\n    int row=0;\\n    int col=0;\\n    int dis=0;\\n    Tupule(int r,int j,int d)\\n    {\\n        this.row=r;\\n        this.col=j;\\n        this.dis=d;\\n    }\\n}\\nclass Solution {\\n    public int minimumVisitedCells(int[][] grid) {\\n         int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] visited = new int[m][n]; \\n\\n        PriorityQueue<Tupule> pq = new PriorityQueue<>((a, b) -> a.dis - b.dis); \\n        pq.offer(new Tupule(0,0,1));\\n\\n        while (!pq.isEmpty()) {\\n            int i = pq.peek().row;\\n            int j = pq.peek().col;\\n            int visitedCells =pq.peek().dis;\\n            pq.poll();\\n\\n            if (i == m - 1 && j == n - 1) {\\n                return visitedCells;\\n            }\\n\\n            if (visited[i][j] > 0) { \\n                continue;\\n            }\\n            visited[i][j] = visitedCells; \\n\\n            \\n            for (int k = j + 1; k <= j + grid[i][j] && k < n; k++) {\\n                if (visited[i][k] == 0) {\\n                    pq.offer(new Tupule(i, k, visitedCells + 1));\\n                }\\n            }\\n\\n            \\n            for (int k = i + 1; k <= i + grid[i][j] && k < m; k++) {\\n                if (visited[k][j] == 0) {\\n                    pq.offer(new Tupule(k, j, visitedCells + 1));\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397230,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>&mat)\\n    {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<int>row(n,0),col(m,0);\\n        queue<pair<int,int>>q;\\n        q.push({0,0});\\n        int level=1;\\n        while(q.size())\\n        {\\n            int size=q.size();\\n            while(size--)\\n            {\\n                auto [x,y]=q.front();\\n                q.pop();\\n                if(x==n-1&&y==m-1)\\n                {\\n                    return level;\\n                }\\n                for(int k=max(row[x],y+1);k<=min(mat[x][y]+y,m-1);k++)\\n                {\\n                    q.push({x,k});\\n                }\\n                row[x]=max(row[x],min(mat[x][y]+y,m-1));\\n                for(int k=max(col[y],x+1);k<=min(mat[x][y]+x,n-1);k++)\\n                {\\n                    q.push({k,y});\\n                }\\n                col[y]=max(col[y],min(mat[x][y]+x,n-1));\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>&mat)\\n    {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<int>row(n,0),col(m,0);\\n        queue<pair<int,int>>q;\\n        q.push({0,0});\\n        int level=1;\\n        while(q.size())\\n        {\\n            int size=q.size();\\n            while(size--)\\n            {\\n                auto [x,y]=q.front();\\n                q.pop();\\n                if(x==n-1&&y==m-1)\\n                {\\n                    return level;\\n                }\\n                for(int k=max(row[x],y+1);k<=min(mat[x][y]+y,m-1);k++)\\n                {\\n                    q.push({x,k});\\n                }\\n                row[x]=max(row[x],min(mat[x][y]+y,m-1));\\n                for(int k=max(col[y],x+1);k<=min(mat[x][y]+x,n-1);k++)\\n                {\\n                    q.push({k,y});\\n                }\\n                col[y]=max(col[y],min(mat[x][y]+x,n-1));\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397103,
                "title": "heap-c-python-golang",
                "content": "# C++ \\n```\\nstruct Cell {\\n    long long x;\\n    int i;\\n    int j;\\n    \\n    Cell(long long _x, int _i, int _j) {\\n        x = _x;\\n        i = _i;\\n        j = _j;\\n    }\\n};\\n\\n\\nstruct compareDistance {\\n    bool operator() (Cell const& a, Cell const& b) {\\n        return a.x > b.x;\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<long long>> distance(m,(vector<long long>(n,INT_MAX)));\\n        distance[0][0]=1;\\n        priority_queue<Cell, vector<Cell>, compareDistance> pq;\\n        pq.push(Cell(1, 0, 0) );\\n        while (!pq.empty()) {\\n            Cell cell = pq.top();\\n            long long d = cell.x;\\n            int i= cell.i;\\n            int j= cell.j;\\n            pq.pop();\\n            if (i == m-1 && j == n-1) {\\n                return (int)d;\\n            }\\n            for (int k = j+1; k <= min(j+grid[i][j], n-1); k++) {\\n                if (distance[i][k] > d+1) {\\n                    distance[i][k] = d+1;\\n                    pq.push(Cell(d + 1, i, k));\\n                    if (i == m-1 && k == n-1) {\\n                        return (int)d+1;\\n                    }\\n                }\\n            }\\n            for (int k = i+1; k <= min(i+grid[i][j], m-1); k++) {\\n                if (distance[k][j] > d+1) {\\n                    distance[k][j] = d+1;\\n                    pq.push(Cell(d + 1, k, j));\\n                    if (k == m-1 && j == n-1) {\\n                        return (int)d+1;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n# Python\\n```\\nimport heapq\\n\\nclass Cell:\\n    distance: float\\n    x: int\\n    y: int\\n\\n    def __init__(self, distance, x, y):\\n        self.distance = distance\\n        self.x = x\\n        self.y = y\\n        \\n    def __lt__(self, other):\\n        return self.distance < other.distance\\n\\n\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n\\n        distance = [[float(\\'inf\\') for _ in range(n)] for _ in range(m)]\\n        distance[0][0] = 1\\n\\n        pq = [Cell(1, 0, 0)]\\n\\n        while pq:\\n            cell = heapq.heappop(pq)\\n            d = cell.distance\\n            i = cell.x\\n            j = cell.y\\n\\n            if i == m - 1 and j == n - 1:\\n                return int(d)\\n\\n            for k in range(j, min(j + grid[i][j] + 1, n)):\\n                if distance[i][k] > d + 1:\\n                    distance[i][k] = d + 1\\n                    heapq.heappush(pq, Cell(d+1, i, k))\\n                    \\n                    if i == m - 1 and k == n - 1:\\n                        return int(d + 1)\\n\\n            for k in range(i, min(i + grid[i][j] + 1, m)):\\n                if distance[k][j] > d + 1:\\n                    distance[k][j] = d + 1\\n                    heapq.heappush(pq, Cell(d+1, k, j))\\n                    \\n                    if k == m - 1 and j == n - 1:\\n                        return int(d + 1)\\n\\n        return -1\\n\\n```\\n\\n\\n# Golang\\n```\\npackage main\\n\\nimport (\\n    \"container/heap\"\\n    \"fmt\"\\n)\\n\\ntype Cell struct {\\n    distance float64\\n    x        int\\n    y        int\\n}\\n\\ntype PriorityQueue []*Cell\\n\\nfunc (pq PriorityQueue) Len() int { return len(pq) }\\n\\nfunc (pq PriorityQueue) Less(i, j int) bool {\\n    return pq[i].distance < pq[j].distance\\n}\\n\\nfunc (pq PriorityQueue) Swap(i, j int) {\\n    pq[i], pq[j] = pq[j], pq[i]\\n}\\n\\nfunc (pq *PriorityQueue) Push(x interface{}) {\\n    item := x.(*Cell)\\n    *pq = append(*pq, item)\\n}\\n\\nfunc (pq *PriorityQueue) Pop() interface{} {\\n    old := *pq\\n    n := len(old)\\n    item := old[n-1]\\n    *pq = old[0 : n-1]\\n    return item\\n}\\n\\nfunc minimumVisitedCells(grid [][]int) int {\\n    m := len(grid)\\n    n := len(grid[0])\\n\\n    distance := make([][]float64, m)\\n    for i := 0; i < m; i++ {\\n        distance[i] = make([]float64, n)\\n        for j := 0; j < n; j++ {\\n            distance[i][j] = 1e9\\n        }\\n    }\\n    distance[0][0] = 1\\n\\n    pq := make(PriorityQueue, 0)\\n    heap.Push(&pq, &Cell{distance: 1, x: 0, y: 0})\\n\\n    for len(pq) > 0 {\\n        cell := heap.Pop(&pq).(*Cell)\\n        d := cell.distance\\n        i := cell.x\\n        j := cell.y\\n\\n        if i == m-1 && j == n-1 {\\n            return int(d)\\n        }\\n\\n        for k := j; k < min(j+grid[i][j]+1, n); k++ {\\n            if distance[i][k] > d+1 {\\n                distance[i][k] = d + 1\\n                heap.Push(&pq, &Cell{distance: d + 1, x: i, y: k})\\n\\n                if i == m-1 && k == n-1 {\\n                    return int(d + 1)\\n                }\\n            }\\n        }\\n\\n        for k := i; k < min(i+grid[i][j]+1, m); k++ {\\n            if distance[k][j] > d+1 {\\n                distance[k][j] = d + 1\\n                heap.Push(&pq, &Cell{distance: d + 1, x: k, y: j})\\n\\n                if k == m-1 && j == n-1 {\\n                    return int(d + 1)\\n                }\\n            }\\n        }\\n    }\\n\\n    return -1\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Go",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nstruct Cell {\\n    long long x;\\n    int i;\\n    int j;\\n    \\n    Cell(long long _x, int _i, int _j) {\\n        x = _x;\\n        i = _i;\\n        j = _j;\\n    }\\n};\\n\\n\\nstruct compareDistance {\\n    bool operator() (Cell const& a, Cell const& b) {\\n        return a.x > b.x;\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<long long>> distance(m,(vector<long long>(n,INT_MAX)));\\n        distance[0][0]=1;\\n        priority_queue<Cell, vector<Cell>, compareDistance> pq;\\n        pq.push(Cell(1, 0, 0) );\\n        while (!pq.empty()) {\\n            Cell cell = pq.top();\\n            long long d = cell.x;\\n            int i= cell.i;\\n            int j= cell.j;\\n            pq.pop();\\n            if (i == m-1 && j == n-1) {\\n                return (int)d;\\n            }\\n            for (int k = j+1; k <= min(j+grid[i][j], n-1); k++) {\\n                if (distance[i][k] > d+1) {\\n                    distance[i][k] = d+1;\\n                    pq.push(Cell(d + 1, i, k));\\n                    if (i == m-1 && k == n-1) {\\n                        return (int)d+1;\\n                    }\\n                }\\n            }\\n            for (int k = i+1; k <= min(i+grid[i][j], m-1); k++) {\\n                if (distance[k][j] > d+1) {\\n                    distance[k][j] = d+1;\\n                    pq.push(Cell(d + 1, k, j));\\n                    if (k == m-1 && j == n-1) {\\n                        return (int)d+1;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nimport heapq\\n\\nclass Cell:\\n    distance: float\\n    x: int\\n    y: int\\n\\n    def __init__(self, distance, x, y):\\n        self.distance = distance\\n        self.x = x\\n        self.y = y\\n        \\n    def __lt__(self, other):\\n        return self.distance < other.distance\\n\\n\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n\\n        distance = [[float(\\'inf\\') for _ in range(n)] for _ in range(m)]\\n        distance[0][0] = 1\\n\\n        pq = [Cell(1, 0, 0)]\\n\\n        while pq:\\n            cell = heapq.heappop(pq)\\n            d = cell.distance\\n            i = cell.x\\n            j = cell.y\\n\\n            if i == m - 1 and j == n - 1:\\n                return int(d)\\n\\n            for k in range(j, min(j + grid[i][j] + 1, n)):\\n                if distance[i][k] > d + 1:\\n                    distance[i][k] = d + 1\\n                    heapq.heappush(pq, Cell(d+1, i, k))\\n                    \\n                    if i == m - 1 and k == n - 1:\\n                        return int(d + 1)\\n\\n            for k in range(i, min(i + grid[i][j] + 1, m)):\\n                if distance[k][j] > d + 1:\\n                    distance[k][j] = d + 1\\n                    heapq.heappush(pq, Cell(d+1, k, j))\\n                    \\n                    if k == m - 1 and j == n - 1:\\n                        return int(d + 1)\\n\\n        return -1\\n\\n```\n```\\npackage main\\n\\nimport (\\n    \"container/heap\"\\n    \"fmt\"\\n)\\n\\ntype Cell struct {\\n    distance float64\\n    x        int\\n    y        int\\n}\\n\\ntype PriorityQueue []*Cell\\n\\nfunc (pq PriorityQueue) Len() int { return len(pq) }\\n\\nfunc (pq PriorityQueue) Less(i, j int) bool {\\n    return pq[i].distance < pq[j].distance\\n}\\n\\nfunc (pq PriorityQueue) Swap(i, j int) {\\n    pq[i], pq[j] = pq[j], pq[i]\\n}\\n\\nfunc (pq *PriorityQueue) Push(x interface{}) {\\n    item := x.(*Cell)\\n    *pq = append(*pq, item)\\n}\\n\\nfunc (pq *PriorityQueue) Pop() interface{} {\\n    old := *pq\\n    n := len(old)\\n    item := old[n-1]\\n    *pq = old[0 : n-1]\\n    return item\\n}\\n\\nfunc minimumVisitedCells(grid [][]int) int {\\n    m := len(grid)\\n    n := len(grid[0])\\n\\n    distance := make([][]float64, m)\\n    for i := 0; i < m; i++ {\\n        distance[i] = make([]float64, n)\\n        for j := 0; j < n; j++ {\\n            distance[i][j] = 1e9\\n        }\\n    }\\n    distance[0][0] = 1\\n\\n    pq := make(PriorityQueue, 0)\\n    heap.Push(&pq, &Cell{distance: 1, x: 0, y: 0})\\n\\n    for len(pq) > 0 {\\n        cell := heap.Pop(&pq).(*Cell)\\n        d := cell.distance\\n        i := cell.x\\n        j := cell.y\\n\\n        if i == m-1 && j == n-1 {\\n            return int(d)\\n        }\\n\\n        for k := j; k < min(j+grid[i][j]+1, n); k++ {\\n            if distance[i][k] > d+1 {\\n                distance[i][k] = d + 1\\n                heap.Push(&pq, &Cell{distance: d + 1, x: i, y: k})\\n\\n                if i == m-1 && k == n-1 {\\n                    return int(d + 1)\\n                }\\n            }\\n        }\\n\\n        for k := i; k < min(i+grid[i][j]+1, m); k++ {\\n            if distance[k][j] > d+1 {\\n                distance[k][j] = d + 1\\n                heap.Push(&pq, &Cell{distance: d + 1, x: k, y: j})\\n\\n                if k == m-1 && j == n-1 {\\n                    return int(d + 1)\\n                }\\n            }\\n        }\\n    }\\n\\n    return -1\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395978,
                "title": "python3-minheap-per-row-col-for-storing-min-score",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBasically, for every row and column store a minHeap with values being a tuple of (score, maxReachablRow/Col) . And always pick the smallest score from both minHeaps.\\nThen for every cell we\\'ll just pick the smallest score from row or column that can be obtained based on previous cells in row/col.\\n\\n# Complexity\\n- Time complexity: $$O(m*n*(m*log(m) + n*log(n)))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m*n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        bestRow = [[] for _ in range(m)] # will store (minScore, maxReachableColumn) for each row\\n        bestCol = [[] for _ in range(n)] # will store (minScore, maxReachableRow) for each column\\n        \\n        finf = float(\\'inf\\')\\n        heappush(bestRow[0], (1, 0))\\n        for i in range(m):\\n            for j in range(n):\\n                minScore = finf\\n\\n                # removing scores that are not reaching this cell\\n                while bestRow[i] and bestRow[i][0][1] < j:\\n                    heappop(bestRow[i])\\n                if bestRow[i]:\\n                    minScore = min(minScore, bestRow[i][0][0])\\n\\n                # removing scores that are not reaching this cell\\n                while bestCol[j] and bestCol[j][0][1] < i:\\n                    heappop(bestCol[j])\\n                if bestCol[j]:\\n                    minScore = min(minScore, bestCol[j][0][0])\\n\\n                if (i,j) == (m-1, n-1) and minScore != finf:\\n                    return minScore\\n                if minScore != finf:\\n                    heappush(bestRow[i], (minScore+1, j+grid[i][j]))\\n                    heappush(bestCol[j], (minScore+1, i+grid[i][j]))\\n        \\n        return -1\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        bestRow = [[] for _ in range(m)] # will store (minScore, maxReachableColumn) for each row\\n        bestCol = [[] for _ in range(n)] # will store (minScore, maxReachableRow) for each column\\n        \\n        finf = float(\\'inf\\')\\n        heappush(bestRow[0], (1, 0))\\n        for i in range(m):\\n            for j in range(n):\\n                minScore = finf\\n\\n                # removing scores that are not reaching this cell\\n                while bestRow[i] and bestRow[i][0][1] < j:\\n                    heappop(bestRow[i])\\n                if bestRow[i]:\\n                    minScore = min(minScore, bestRow[i][0][0])\\n\\n                # removing scores that are not reaching this cell\\n                while bestCol[j] and bestCol[j][0][1] < i:\\n                    heappop(bestCol[j])\\n                if bestCol[j]:\\n                    minScore = min(minScore, bestCol[j][0][0])\\n\\n                if (i,j) == (m-1, n-1) and minScore != finf:\\n                    return minScore\\n                if minScore != finf:\\n                    heappush(bestRow[i], (minScore+1, j+grid[i][j]))\\n                    heappush(bestCol[j], (minScore+1, i+grid[i][j]))\\n        \\n        return -1\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395966,
                "title": "brute-force-dp-using-segment-tree-s",
                "content": "# Intuition\\ndp[i][j] = \\nmin(\\ndp[i][j + 1], dp[i][j + 2]....., dp[i][j + grid[i][j]],\\ndp[i + 1][j], dp[i + 2][j]....., dp[i + grid[i][j]][j]) + 1\\n\\n# Approach\\nJust Range Min queries.\\nSuppose we have m rows and n columns, we loop i from m - 1 to 0 and j from n - 1 to 0.\\n\\nWe only need to maintian a single segment tree that can be shared for all the m rows. And maintain n segment trees for each column....\\n\\nIt\\'s almost \"brute-force\"\\n\\n# Complexity\\n- Time complexity:\\nO(m * n * log (max(m, n)))\\n\\n- Space complexity:\\nO(m * n)\\n\\n# Code\\n```\\nclass Solution {\\n    void better(int &x, int y) {\\n        if (y == INT_MAX) {\\n            return;\\n        }\\n        x = min(x, y + 1);\\n    }\\n    int query(const vector<int> &tree, int ind, int left, int right, int x, int y) {\\n        if (left >= x && right <= y) {\\n            return tree[ind];\\n        }\\n        const int mid = (left + right) >> 1;\\n        int r = INT_MAX;\\n        if (x <= mid) {\\n            r = query(tree, ind << 1, left, mid, x, y);\\n        }\\n        if (y > mid) {\\n            r = min(r, query(tree, (ind << 1) | 1, mid + 1, right, x, y));\\n        } \\n        return r;\\n    }\\n\\n    void update(vector<int> &tree, int ind, int left, int right, int x, int y) {\\n        tree[ind] = min(tree[ind], y);\\n        if (left >= x && right <= x) {\\n            return;\\n        }\\n        const int mid = (left + right) >> 1;\\n        if (x <= mid) {\\n            update(tree, ind << 1, left, mid, x, y);\\n        } else {\\n            update(tree, (ind << 1) | 1, mid + 1, right, x, y);\\n        } \\n    }\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        const int m = grid.size(), n = grid[0].size();\\n        if (m == 1 && n == 1) {\\n            return 1;\\n        }\\n        vector<vector<int>> tree1(n, vector<int>(m << 2, INT_MAX));\\n        for (int i = m - 1; i >= 0; --i) {\\n            vector<int> tree2(n << 2, INT_MAX);\\n            if (i == m - 1) {\\n                update(tree2, 1, 0, n - 1, n - 1, 1);\\n                update(tree1[n - 1], 1, 0, m - 1, m - 1, 1);\\n            }\\n            for (int j = (i == m - 1) ? (n - 2) : (n - 1); j >= 0; --j) {\\n                if (grid[i][j] == 0) {\\n                    continue;\\n                }\\n                int may = INT_MAX;\\n                if (j + 1 < n) {\\n                   better(may, query(tree2, 1, 0, n - 1, j + 1, min(j + grid[i][j], n - 1)));\\n                }\\n                if (i + 1 < m) {\\n                    better(may, query(tree1[j], 1, 0, m - 1, i + 1, min(i + grid[i][j], m - 1)));\\n                }\\n                if (may < INT_MAX) {\\n                    update(tree2, 1, 0, n - 1, j, may);\\n                    update(tree1[j], 1, 0, m - 1, i, may);\\n                    if (i == 0 && j == 0) {\\n                        return may;\\n                    }\\n                }\\n            }\\n        \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    void better(int &x, int y) {\\n        if (y == INT_MAX) {\\n            return;\\n        }\\n        x = min(x, y + 1);\\n    }\\n    int query(const vector<int> &tree, int ind, int left, int right, int x, int y) {\\n        if (left >= x && right <= y) {\\n            return tree[ind];\\n        }\\n        const int mid = (left + right) >> 1;\\n        int r = INT_MAX;\\n        if (x <= mid) {\\n            r = query(tree, ind << 1, left, mid, x, y);\\n        }\\n        if (y > mid) {\\n            r = min(r, query(tree, (ind << 1) | 1, mid + 1, right, x, y));\\n        } \\n        return r;\\n    }\\n\\n    void update(vector<int> &tree, int ind, int left, int right, int x, int y) {\\n        tree[ind] = min(tree[ind], y);\\n        if (left >= x && right <= x) {\\n            return;\\n        }\\n        const int mid = (left + right) >> 1;\\n        if (x <= mid) {\\n            update(tree, ind << 1, left, mid, x, y);\\n        } else {\\n            update(tree, (ind << 1) | 1, mid + 1, right, x, y);\\n        } \\n    }\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        const int m = grid.size(), n = grid[0].size();\\n        if (m == 1 && n == 1) {\\n            return 1;\\n        }\\n        vector<vector<int>> tree1(n, vector<int>(m << 2, INT_MAX));\\n        for (int i = m - 1; i >= 0; --i) {\\n            vector<int> tree2(n << 2, INT_MAX);\\n            if (i == m - 1) {\\n                update(tree2, 1, 0, n - 1, n - 1, 1);\\n                update(tree1[n - 1], 1, 0, m - 1, m - 1, 1);\\n            }\\n            for (int j = (i == m - 1) ? (n - 2) : (n - 1); j >= 0; --j) {\\n                if (grid[i][j] == 0) {\\n                    continue;\\n                }\\n                int may = INT_MAX;\\n                if (j + 1 < n) {\\n                   better(may, query(tree2, 1, 0, n - 1, j + 1, min(j + grid[i][j], n - 1)));\\n                }\\n                if (i + 1 < m) {\\n                    better(may, query(tree1[j], 1, 0, m - 1, i + 1, min(i + grid[i][j], m - 1)));\\n                }\\n                if (may < INT_MAX) {\\n                    update(tree2, 1, 0, n - 1, j, may);\\n                    update(tree1[j], 1, 0, m - 1, i, may);\\n                    if (i == 0 && j == 0) {\\n                        return may;\\n                    }\\n                }\\n            }\\n        \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396677,
                "title": "python-similar-to-jump-game-2-greedy-bfs",
                "content": "Same bfs [solution](https://leetcode.com/problems/jump-game-ii/solutions/3396676/python-simple-greedy-bfs/) 1D jump game.\\n# Code\\n```\\nimport heapq as hp\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        n,m = len(grid),len(grid[0])\\n        dq = deque()\\n        src = (1,0,0) # steps, y,x\\n        dq.append(src)\\n        lastx = [0]*n\\n        lasty = [0]*m\\n        while(dq):\\n            s,y,x = dq.popleft()\\n            if(y==n-1 and x==m-1): return s\\n            for xx in range(max(x+1,lastx[y]+1),min(m-1,x+grid[y][x])+1):\\n                dq.append((s+1,y,xx))\\n            for yy in range(max(y+1,lasty[x]+1),min(n-1,y+grid[y][x])+1):\\n                dq.append((s+1,yy,x))\\n            lastx[y] = max(lastx[y],x+grid[y][x])\\n            lasty[x] = max(lasty[x],y+grid[y][x])\\n        return -1\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq as hp\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        n,m = len(grid),len(grid[0])\\n        dq = deque()\\n        src = (1,0,0) # steps, y,x\\n        dq.append(src)\\n        lastx = [0]*n\\n        lasty = [0]*m\\n        while(dq):\\n            s,y,x = dq.popleft()\\n            if(y==n-1 and x==m-1): return s\\n            for xx in range(max(x+1,lastx[y]+1),min(m-1,x+grid[y][x])+1):\\n                dq.append((s+1,y,xx))\\n            for yy in range(max(y+1,lasty[x]+1),min(n-1,y+grid[y][x])+1):\\n                dq.append((s+1,yy,x))\\n            lastx[y] = max(lastx[y],x+grid[y][x])\\n            lasty[x] = max(lasty[x],y+grid[y][x])\\n        return -1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703248,
                "title": "c-easy-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        long long n = grid.size(), m = grid[0].size(), level = 0, i, j;\\n        vector<vector<long long>> vis;\\n        vis.resize(n, vector<long long>(m, 0));\\n        vis[0][0] = 1;\\n        \\n        if (grid[0][0] == 99998)\\n            return -1;\\n        \\n        queue<pair<int, int>> q;\\n        q.push({0, 0});\\n        \\n        while (!q.empty()) {\\n            int size = q.size();\\n            level++;\\n            \\n            while (size--) {\\n                i = q.front().first;\\n                j = q.front().second;\\n                q.pop();\\n                vis[i][j] = 1;\\n                int val = grid[i][j] + j;\\n                \\n                if (i == n - 1 && j == m - 1)\\n                    return level;\\n                \\n                for (int k = val; k > j; k--) {\\n                    if (k >= 0 && k < m && !vis[i][k]) {\\n                        vis[i][k] = 1;\\n                        \\n                        if (i == n - 1 && k == m - 1)\\n                            return level + 1;\\n                        \\n                        q.push({i, k});\\n                    }\\n                }\\n                \\n                val = grid[i][j] + i;\\n                \\n                for (int k = val; k > i; k--) {\\n                    if (k >= 0 && k < n && !vis[k][j]) {\\n                        vis[k][j] = 1;\\n                        \\n                        if (k == n - 1 && j == m - 1)\\n                            return level + 1;\\n                        \\n                        q.push({k, j});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        long long n = grid.size(), m = grid[0].size(), level = 0, i, j;\\n        vector<vector<long long>> vis;\\n        vis.resize(n, vector<long long>(m, 0));\\n        vis[0][0] = 1;\\n        \\n        if (grid[0][0] == 99998)\\n            return -1;\\n        \\n        queue<pair<int, int>> q;\\n        q.push({0, 0});\\n        \\n        while (!q.empty()) {\\n            int size = q.size();\\n            level++;\\n            \\n            while (size--) {\\n                i = q.front().first;\\n                j = q.front().second;\\n                q.pop();\\n                vis[i][j] = 1;\\n                int val = grid[i][j] + j;\\n                \\n                if (i == n - 1 && j == m - 1)\\n                    return level;\\n                \\n                for (int k = val; k > j; k--) {\\n                    if (k >= 0 && k < m && !vis[i][k]) {\\n                        vis[i][k] = 1;\\n                        \\n                        if (i == n - 1 && k == m - 1)\\n                            return level + 1;\\n                        \\n                        q.push({i, k});\\n                    }\\n                }\\n                \\n                val = grid[i][j] + i;\\n                \\n                for (int k = val; k > i; k--) {\\n                    if (k >= 0 && k < n && !vis[k][j]) {\\n                        vis[k][j] = 1;\\n                        \\n                        if (k == n - 1 && j == m - 1)\\n                            return level + 1;\\n                        \\n                        q.push({k, j});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450224,
                "title": "c-set-approach",
                "content": "# Approach\\nDo BFS while maintaining rows and columns in separate sets. When you process a point find the closest element in row/column sets and remove them from sets.\\n\\nShould be O(mn(log(m)+log(n))) \\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        if(m == 1 && n == 1) {\\n            return 1;\\n        }\\n        \\n        vector<set<int>> rowView(m);\\n        vector<set<int>> colView(n);\\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                rowView[i].insert(j);\\n                colView[j].insert(i);\\n            }            \\n        }\\n        \\n        queue<pair<int, int>> q;\\n        q.push(make_pair(0, 0));\\n        int round = 1;\\n        while(!q.empty()) {\\n            int size = q.size();\\n            for(int i = 0; i < size; ++i) {\\n                auto front = q.front();\\n                // Add horizontal points\\n                auto it = rowView[front.first].upper_bound(front.second);\\n                while(it != rowView[front.first].end() && *it <= front.second + grid[front.first][front.second]) {\\n                    int col = *it;\\n                    q.push(make_pair(front.first, col));\\n                    if(front.first == m-1 && col == n-1) {\\n                        return round+1;\\n                    }\\n                    \\n                    it++;\\n                    rowView[front.first].erase(col);\\n                    colView[col].erase(front.first);\\n                }\\n                \\n                // Add vertical points\\n                it = colView[front.second].upper_bound(front.first);\\n                while(it != colView[front.second].end() && *it <= front.first + grid[front.first][front.second]) {\\n                    int row = *it;\\n                    q.push(make_pair(row, front.second));\\n                    if(row == m-1 && front.second == n-1) {\\n                        return round+1;\\n                    }\\n                    \\n                    it++;\\n                    rowView[row].erase(front.second);\\n                    colView[front.second].erase(row);\\n                }\\n                q.pop();\\n            }\\n            round++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        if(m == 1 && n == 1) {\\n            return 1;\\n        }\\n        \\n        vector<set<int>> rowView(m);\\n        vector<set<int>> colView(n);\\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                rowView[i].insert(j);\\n                colView[j].insert(i);\\n            }            \\n        }\\n        \\n        queue<pair<int, int>> q;\\n        q.push(make_pair(0, 0));\\n        int round = 1;\\n        while(!q.empty()) {\\n            int size = q.size();\\n            for(int i = 0; i < size; ++i) {\\n                auto front = q.front();\\n                // Add horizontal points\\n                auto it = rowView[front.first].upper_bound(front.second);\\n                while(it != rowView[front.first].end() && *it <= front.second + grid[front.first][front.second]) {\\n                    int col = *it;\\n                    q.push(make_pair(front.first, col));\\n                    if(front.first == m-1 && col == n-1) {\\n                        return round+1;\\n                    }\\n                    \\n                    it++;\\n                    rowView[front.first].erase(col);\\n                    colView[col].erase(front.first);\\n                }\\n                \\n                // Add vertical points\\n                it = colView[front.second].upper_bound(front.first);\\n                while(it != colView[front.second].end() && *it <= front.first + grid[front.first][front.second]) {\\n                    int row = *it;\\n                    q.push(make_pair(row, front.second));\\n                    if(row == m-1 && front.second == n-1) {\\n                        return round+1;\\n                    }\\n                    \\n                    it++;\\n                    rowView[row].erase(front.second);\\n                    colView[front.second].erase(row);\\n                }\\n                q.pop();\\n            }\\n            round++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425012,
                "title": "2d-segment-tree",
                "content": "Tried to do the BFS + compression but only passed 1000/1100 testcases due to a bug I couldn\\'t find. Segment tree is more straightforward imo, but a little slower and harder to implement. Basically travel through the array backwards maintaining a segment tree for the current row and current column of the cell. Find the cheapest cell within reachable range. \\n\\n```\\nclass segment_tree{\\npublic:\\n    vector<long long> t;\\n    int n;\\n    segment_tree(int x){\\n        n = x;\\n        t.resize(x*2, 0);\\n        for(auto & i : t) i = 1e5+1;\\n    }\\n    void update(int pos, long long val){\\n        for(t[pos+=n] = val; pos > 1; pos >>= 1) t[pos/2] = min(t[pos],t[pos^1]);\\n    }\\n    int query(int a, int b){\\n        long long res = INT_MAX;\\n        for(int l = a+n, r = b+n+1; l < r; l >>= 1, r >>= 1){\\n            if(l & 1) res = min(res, t[l++]);\\n            if(r & 1) res = min(res, t[--r]);\\n        }\\n        return res;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        auto og = grid;\\n        vector<segment_tree> v;\\n        for(int i = 0; i < grid[0].size(); i++){\\n            segment_tree t(grid.size()+1);\\n            v.push_back(t);\\n        }\\n        for(int i = grid.size()-1; i >= 0; i--){\\n            segment_tree r(grid[0].size()+1);\\n            for(int j = grid[0].size()-1; j >= 0; j--){\\n                int dmin = 1e5+1;\\n                dmin = min(dmin, 1+r.query(j, min(grid[i][j]+j, (int) grid[0].size()-1)));\\n                dmin = min(dmin, 1+v[j].query(i, min(grid[i][j]+i, (int) grid.size()-1)));\\n                if(i==grid.size()-1 && j == grid[0].size()-1) dmin = 1;\\n                v[j].update(i, dmin);\\n                r.update(j, dmin);\\n                grid[i][j] = dmin;\\n            }\\n        }\\n        return grid[0][0] == 1e5 + 1 ? -1 : grid[0][0];\\n    }\\n};",
                "solutionTags": [
                    "Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        auto og = grid;\\n        vector<segment_tree> v;\\n        for(int i = 0; i < grid[0].size(); i++){\\n            segment_tree t(grid.size()+1);\\n            v.push_back(t);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3407410,
                "title": "c-bfs-solution-with-dsu",
                "content": "\\n\\n\\n# Approach\\nApply bfs traversal over the grid and to optimize time complexity use disjoint set union to only traverse those cells which are not visited till now in the path.\\n\\n# Complexity\\n- Time complexity:O(n*m)\\n\\n- Space complexity:O(n*m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int find(int x,vector<int>&par)\\n    {\\n        if(x==par[x])\\n        {\\n            return x;\\n        }\\n        return par[x]=find(par[x],par);\\n    }\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        if(n==1 and m==1)\\n        {\\n            return 1;\\n        }\\n        queue<pair<int,int>>q;\\n        q.push({0,0});\\n        vector<vector<int>>par_r(n,vector<int>(m+1,0)),par_c(m,vector<int>(n+1,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<=m;j++)\\n            {\\n                par_r[i][j]=j;\\n            }\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<=n;j++)\\n            {\\n                par_c[i][j]=j;\\n            }\\n        }\\n        int cnt=2;\\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            for(int k=0;k<sz;k++)\\n            {\\n                auto [x,y]=q.front();\\n                //cout<<x<<\" \"<<y<<\"\\\\n\";\\n                q.pop();\\n                int j=find(par_r[x][y+1],par_r[x]);\\n                while(j<m and j<=grid[x][y]+y)\\n                {\\n                    if(x==n-1 and j==m-1)\\n                    {\\n                        return cnt;\\n                    }\\n                    q.push({x,j});\\n                    par_r[x][j]=j+1;\\n                    j=find(par_r[x][j],par_r[x]);\\n                }\\n                int i=find(par_c[y][x+1],par_c[y]);\\n                while(i<n and i<=grid[x][y]+x)\\n                {\\n                    if(i==n-1 and y==m-1)\\n                    {\\n                        return cnt;\\n                    }\\n                    q.push({i,y});\\n                    par_c[y][i]=i+1;\\n                    i=find(par_c[y][i],par_c[y]);\\n                }\\n            }\\n            cnt++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(int x,vector<int>&par)\\n    {\\n        if(x==par[x])\\n        {\\n            return x;\\n        }\\n        return par[x]=find(par[x],par);\\n    }\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        if(n==1 and m==1)\\n        {\\n            return 1;\\n        }\\n        queue<pair<int,int>>q;\\n        q.push({0,0});\\n        vector<vector<int>>par_r(n,vector<int>(m+1,0)),par_c(m,vector<int>(n+1,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<=m;j++)\\n            {\\n                par_r[i][j]=j;\\n            }\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<=n;j++)\\n            {\\n                par_c[i][j]=j;\\n            }\\n        }\\n        int cnt=2;\\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            for(int k=0;k<sz;k++)\\n            {\\n                auto [x,y]=q.front();\\n                //cout<<x<<\" \"<<y<<\"\\\\n\";\\n                q.pop();\\n                int j=find(par_r[x][y+1],par_r[x]);\\n                while(j<m and j<=grid[x][y]+y)\\n                {\\n                    if(x==n-1 and j==m-1)\\n                    {\\n                        return cnt;\\n                    }\\n                    q.push({x,j});\\n                    par_r[x][j]=j+1;\\n                    j=find(par_r[x][j],par_r[x]);\\n                }\\n                int i=find(par_c[y][x+1],par_c[y]);\\n                while(i<n and i<=grid[x][y]+x)\\n                {\\n                    if(i==n-1 and y==m-1)\\n                    {\\n                        return cnt;\\n                    }\\n                    q.push({i,y});\\n                    par_c[y][i]=i+1;\\n                    i=find(par_c[y][i],par_c[y]);\\n                }\\n            }\\n            cnt++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3406274,
                "title": "dp-o-m-n-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(m * n)\\n\\n- Space complexity:\\nO(m * n)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        mx = m + n # use it as the limit, there is no more than m + n - 1 steps if the solution exists\\n        h = [[] for i in range(m)] # horizontal monotonic stacks\\n        v = [[] for i in range(n)] # vertical monotonic stacks \\n        \\n        for r in range(m - 1, -1, -1):\\n            for c in range(n - 1, -1, -1):\\n                if r == m - 1 and c == n - 1: # init stacks\\n                    h[r].append((c, 1)) # (column index, number of steps)\\n                    v[c].append((r, 1)) # (row index, number of steps)\\n                else:\\n                    s, mn = grid[r][c], mx # s - allowed steps from the current cell, mn - minimum possible steps\\n                    while len(h[r]) > 1 and h[r][-2][0] - s <= c:\\n                        h[r].pop() # we can jump to a further cell with less steps to the target \\n                    mn = min(mn, h[r][-1][1] + 1 if h[r] and h[r][-1][0] - s <= c else mx)\\n                    while len(v[c]) > 1 and v[c][-2][0] - s <= r:\\n                        v[c].pop() # we can jump to a further cell with less steps to the target \\n                    mn = min(mn, v[c][-1][1] + 1 if v[c] and v[c][-1][0] - s <= r else mx)\\n                    while h[r] and h[r][-1][1] >= mn:\\n                        h[r].pop() # clear less optimal horizontal solutions, if it\\'s better to move vertically\\n                    h[r].append((c, mn))\\n                    while v[c] and v[c][-1][1] >= mn:\\n                        v[c].pop() # clear less optimal vertical solutions, if it\\'s better to move horizontally\\n                    v[c].append((r, mn))\\n\\n        mn = h[0][-1][1]\\n        return mn if mn < mx else -1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        mx = m + n # use it as the limit, there is no more than m + n - 1 steps if the solution exists\\n        h = [[] for i in range(m)] # horizontal monotonic stacks\\n        v = [[] for i in range(n)] # vertical monotonic stacks \\n        \\n        for r in range(m - 1, -1, -1):\\n            for c in range(n - 1, -1, -1):\\n                if r == m - 1 and c == n - 1: # init stacks\\n                    h[r].append((c, 1)) # (column index, number of steps)\\n                    v[c].append((r, 1)) # (row index, number of steps)\\n                else:\\n                    s, mn = grid[r][c], mx # s - allowed steps from the current cell, mn - minimum possible steps\\n                    while len(h[r]) > 1 and h[r][-2][0] - s <= c:\\n                        h[r].pop() # we can jump to a further cell with less steps to the target \\n                    mn = min(mn, h[r][-1][1] + 1 if h[r] and h[r][-1][0] - s <= c else mx)\\n                    while len(v[c]) > 1 and v[c][-2][0] - s <= r:\\n                        v[c].pop() # we can jump to a further cell with less steps to the target \\n                    mn = min(mn, v[c][-1][1] + 1 if v[c] and v[c][-1][0] - s <= r else mx)\\n                    while h[r] and h[r][-1][1] >= mn:\\n                        h[r].pop() # clear less optimal horizontal solutions, if it\\'s better to move vertically\\n                    h[r].append((c, mn))\\n                    while v[c] and v[c][-1][1] >= mn:\\n                        v[c].pop() # clear less optimal vertical solutions, if it\\'s better to move horizontally\\n                    v[c].append((r, mn))\\n\\n        mn = h[0][-1][1]\\n        return mn if mn < mx else -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3405887,
                "title": "c-bfs-dsu-o-mn-clean-and-concise",
                "content": "# Code\\n```\\nclass DSU {\\npublic:\\n    vector<int> group;\\n    DSU (int n){\\n        group.resize(n);\\n        iota(group.begin(), group.end(), 0);\\n    }\\n    int dsu_find(int i){\\n        if (group[i] != i) { group[i] = dsu_find(group[i]); }\\n        return group[i];\\n    }\\n    void dsu_union(int i, int j){\\n        /* merge j into i*/\\n        i = dsu_find(i);\\n        j = dsu_find(j);\\n        group[j] = i;\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        // dsu_find returns last element in current contiguous block of visited elements\\n        vector<DSU> row_dsu(m, DSU(n));\\n        vector<DSU> col_dsu(n, DSU(m));\\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n        visited[0][0] = true;\\n\\n        queue<pair<int, int>> q;\\n        q.emplace(0, 0);\\n        int d = 1;\\n        while (!q.empty()){\\n            int s = q.size();\\n            // loop invariant: when i,j is expanded, it has been visited before.\\n            while (s--){\\n                int i = q.front().first;\\n                int j = q.front().second;\\n                if (i == m - 1 && j == n - 1) { return d; }\\n                q.pop();\\n                int jj = j;\\n                while ((jj = row_dsu[i].dsu_find(jj) + 1) < min(n, j + grid[i][j] + 1)){\\n                    row_dsu[i].dsu_union(jj, jj - 1);\\n                    if (!visited[i][jj]){\\n                        visited[i][jj] = true;\\n                        q.emplace(i, jj);\\n                    }\\n                }\\n                int ii = i;\\n                while ((ii = col_dsu[j].dsu_find(ii) + 1) < min(m, i + grid[i][j] + 1)){\\n                    col_dsu[j].dsu_union(ii, ii - 1);\\n                    if (!visited[ii][j]){\\n                        visited[ii][j] = true;\\n                        q.emplace(ii, j);\\n                    }\\n                }\\n            }\\n            ++d;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DSU {\\npublic:\\n    vector<int> group;\\n    DSU (int n){\\n        group.resize(n);\\n        iota(group.begin(), group.end(), 0);\\n    }\\n    int dsu_find(int i){\\n        if (group[i] != i) { group[i] = dsu_find(group[i]); }\\n        return group[i];\\n    }\\n    void dsu_union(int i, int j){\\n        /* merge j into i*/\\n        i = dsu_find(i);\\n        j = dsu_find(j);\\n        group[j] = i;\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        // dsu_find returns last element in current contiguous block of visited elements\\n        vector<DSU> row_dsu(m, DSU(n));\\n        vector<DSU> col_dsu(n, DSU(m));\\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n        visited[0][0] = true;\\n\\n        queue<pair<int, int>> q;\\n        q.emplace(0, 0);\\n        int d = 1;\\n        while (!q.empty()){\\n            int s = q.size();\\n            // loop invariant: when i,j is expanded, it has been visited before.\\n            while (s--){\\n                int i = q.front().first;\\n                int j = q.front().second;\\n                if (i == m - 1 && j == n - 1) { return d; }\\n                q.pop();\\n                int jj = j;\\n                while ((jj = row_dsu[i].dsu_find(jj) + 1) < min(n, j + grid[i][j] + 1)){\\n                    row_dsu[i].dsu_union(jj, jj - 1);\\n                    if (!visited[i][jj]){\\n                        visited[i][jj] = true;\\n                        q.emplace(i, jj);\\n                    }\\n                }\\n                int ii = i;\\n                while ((ii = col_dsu[j].dsu_find(ii) + 1) < min(m, i + grid[i][j] + 1)){\\n                    col_dsu[j].dsu_union(ii, ii - 1);\\n                    if (!visited[ii][j]){\\n                        visited[ii][j] = true;\\n                        q.emplace(ii, j);\\n                    }\\n                }\\n            }\\n            ++d;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397436,
                "title": "cpp-using-2-dimentional-segment-tree",
                "content": "\\n# Approach\\nnormal dp but using segment tree to find minimum in range\\n\\n# Complexity\\n- Time complexity: O(nm log(nm))\\n\\n- Space complexity:O(nm log(nm))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include \"ext/pb_ds/assoc_container.hpp\"\\n#include \"ext/pb_ds/tree_policy.hpp\"\\nusing namespace __gnu_pbds;\\ntemplate<typename T> using Tree = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\\n\\n#define str string\\n#define ll long long\\n#define ld long double\\n#define ar array\\n\\n#define vt vector\\n#define pb push_back\\n#define all(c) (c).begin(), (c).end()\\n#define len(x) (int)(x).size()\\n#define elif else if\\n\\n#define F_OR(i, a, b, s) for (int i=(a); (s)>0?i<(b):i>(b); i+=(s))\\n#define F_OR1(e) F_OR(i, 0, e, 1)\\n#define F_OR2(i, e) F_OR(i, 0, e, 1)\\n#define F_OR3(i, b, e) F_OR(i, b, e, 1)\\n#define F_OR4(i, b, e, s) F_OR(i, b, e, s)\\n#define GET5(a, b, c, d, e, ...) e\\n#define F_ORC(...) GET5(__VA_ARGS__, F_OR4, F_OR3, F_OR2, F_OR1)\\n#define rep(...) F_ORC(__VA_ARGS__)(__VA_ARGS__)\\n#define each(x, a) for (auto& x: a)\\n\\nclass Solution {\\n    template<class T, class F>\\nstruct segment_tree_2d{\\n\\tint n, m;\\n\\tvector<vector<T>> data;\\n\\tF TT; // commutative monoid operation\\n\\tT T_id; // commutative monoid identity\\n\\t// O(n * m)\\n\\tsegment_tree_2d(int n, int m, F TT, T T_id): n(n), m(m), TT(TT), T_id(T_id), data(n << 1, vector<T>(m << 1, T_id)){ }\\n\\t// O(n * m)\\n\\tsegment_tree_2d(int n, int m, T x, F TT, T T_id): segment_tree_2d(vector<vector<T>>(n, vector<T>(m, x)), TT, T_id){ }\\n\\t// O(n * m)\\n\\tsegment_tree_2d(const vector<vector<T>> &a, F TT, T T_id): n((int)a.size()), m((int)a[0].size()), TT(TT), T_id(T_id), data(n << 1, vector<T>(m << 1, T_id)){\\n\\t\\tfor(auto i = 0; i < n; ++ i) for(auto j = 0; j < m; ++ j) data[i + n][j + m] = a[i][j];\\n\\t\\tfor(auto i = n - 1; i > 0; -- i) for(auto j = 0; j < m; ++ j) data[i][j + m] = TT(data[i << 1][j + m], data[i << 1 | 1][j + m]);\\n\\t\\tfor(auto i = 1; i < n << 1; ++ i) for(auto j = m - 1; j > 0; -- j) data[i][j] = TT(data[i][j << 1], data[i][j << 1 | 1]);\\n\\t}\\n\\t// a[p][q] := x\\n\\t// O(log n * log m)\\n\\tvoid set(int p, int q, T x){\\n\\t\\tdata[p += n][q += m] = x;\\n\\t\\tfor(auto j = q; j >>= 1; ) data[p][j] = TT(data[p][j << 1], data[p][j << 1 | 1]);\\n\\t\\tfor(auto i = p; i >>= 1; ){\\n\\t\\t\\tdata[i][q] = TT(data[i << 1][q], data[i << 1 | 1][q]);\\n\\t\\t\\tfor(auto j = q; j >>= 1; ) data[i][j] = TT(data[i][j << 1], data[i][j << 1 | 1]);\\n\\t\\t}\\n\\t}\\n\\t// Returns a[p][q]\\n\\t// O(1)\\n\\tT query(int p, int q){\\n\\t\\treturn data[p + n][q + m];\\n\\t}\\n\\t// Returns the sum of a[i][j] on [xl, xr) X [yl, yr)\\n\\t// O(log n * log m)\\n\\tT query(int xl, int xr, int yl, int yr){\\n\\t\\tif(xl >= xr || yl >= yr) return T_id;\\n\\t\\tT res = T_id;\\n\\t\\txl += n, xr += n, yl += m, yr += m;\\n\\t\\tfor(auto il = xl, ir = xr; il < ir; il >>= 1, ir >>= 1){\\n\\t\\t\\tif(il & 1){\\n\\t\\t\\t\\tfor(auto jl = yl, jr = yr; jl < jr; jl >>= 1, jr >>= 1){\\n\\t\\t\\t\\t\\tif(jl & 1) res = TT(res, data[il][jl ++]);\\n\\t\\t\\t\\t\\tif(jr & 1) res = TT(res, data[il][-- jr]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t++ il;\\n\\t\\t\\t}\\n\\t\\t\\tif(ir & 1){\\n\\t\\t\\t\\t-- ir;\\n\\t\\t\\t\\tfor(auto jl = yl, jr = yr; jl < jr; jl >>= 1, jr >>= 1){\\n\\t\\t\\t\\t\\tif(jl & 1) res = TT(res, data[ir][jl ++]);\\n\\t\\t\\t\\t\\tif(jr & 1) res = TT(res, data[ir][-- jr]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n\\ttemplate<class output_stream>\\n\\tfriend output_stream &operator<<(output_stream &out, const segment_tree_2d<T, F> &seg){\\n\\t\\tfor(auto i = 0; i < seg.n; ++ i){\\n\\t\\t\\tout << \"\\\\n[\";\\n\\t\\t\\tfor(auto j = 0; j < seg.m; ++ j){\\n\\t\\t\\t\\tout << seg.query(i, j);\\n\\t\\t\\t\\tif(j != seg.m - 1) out << \", \";\\n\\t\\t\\t}\\n\\t\\t\\tout << \"]\\\\n\";\\n\\t\\t}\\n\\t\\treturn out;\\n\\t}\\n};\\n\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int n = len(grid);\\n        int m = len(grid[0]);\\n        segment_tree_2d seg(n, m, [&](int l, int r){return min(l, r);}, 1e9);\\n        seg.set(n-1, m-1, 0);\\n        rep(i, n-1, -1, -1){\\n            rep(j, m-1, -1, -1){\\n                int mn = min(1 + seg.query(i, min(n, 1+ i + grid[i][j]), j, j+1),\\n\\t\\t\\t\\t\\t\\t\\t\\t1 + seg.query(i, i+1, j, min(m, j + 1 + grid[i][j])));\\n\\t\\t\\t\\t\\t\\t\\t\\tseg.set(i, j, mn);\\n            }\\n        }\\n        if (seg.query(0, 0) >= 1e9) return -1;\\n        else return seg.query(0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include \"ext/pb_ds/assoc_container.hpp\"\\n#include \"ext/pb_ds/tree_policy.hpp\"\\nusing namespace __gnu_pbds;\\ntemplate<typename T> using Tree = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\\n\\n#define str string\\n#define ll long long\\n#define ld long double\\n#define ar array\\n\\n#define vt vector\\n#define pb push_back\\n#define all(c) (c).begin(), (c).end()\\n#define len(x) (int)(x).size()\\n#define elif else if\\n\\n#define F_OR(i, a, b, s) for (int i=(a); (s)>0?i<(b):i>(b); i+=(s))\\n#define F_OR1(e) F_OR(i, 0, e, 1)\\n#define F_OR2(i, e) F_OR(i, 0, e, 1)\\n#define F_OR3(i, b, e) F_OR(i, b, e, 1)\\n#define F_OR4(i, b, e, s) F_OR(i, b, e, s)\\n#define GET5(a, b, c, d, e, ...) e\\n#define F_ORC(...) GET5(__VA_ARGS__, F_OR4, F_OR3, F_OR2, F_OR1)\\n#define rep(...) F_ORC(__VA_ARGS__)(__VA_ARGS__)\\n#define each(x, a) for (auto& x: a)\\n\\nclass Solution {\\n    template<class T, class F>\\nstruct segment_tree_2d{\\n\\tint n, m;\\n\\tvector<vector<T>> data;\\n\\tF TT; // commutative monoid operation\\n\\tT T_id; // commutative monoid identity\\n\\t// O(n * m)\\n\\tsegment_tree_2d(int n, int m, F TT, T T_id): n(n), m(m), TT(TT), T_id(T_id), data(n << 1, vector<T>(m << 1, T_id)){ }\\n\\t// O(n * m)\\n\\tsegment_tree_2d(int n, int m, T x, F TT, T T_id): segment_tree_2d(vector<vector<T>>(n, vector<T>(m, x)), TT, T_id){ }\\n\\t// O(n * m)\\n\\tsegment_tree_2d(const vector<vector<T>> &a, F TT, T T_id): n((int)a.size()), m((int)a[0].size()), TT(TT), T_id(T_id), data(n << 1, vector<T>(m << 1, T_id)){\\n\\t\\tfor(auto i = 0; i < n; ++ i) for(auto j = 0; j < m; ++ j) data[i + n][j + m] = a[i][j];\\n\\t\\tfor(auto i = n - 1; i > 0; -- i) for(auto j = 0; j < m; ++ j) data[i][j + m] = TT(data[i << 1][j + m], data[i << 1 | 1][j + m]);\\n\\t\\tfor(auto i = 1; i < n << 1; ++ i) for(auto j = m - 1; j > 0; -- j) data[i][j] = TT(data[i][j << 1], data[i][j << 1 | 1]);\\n\\t}\\n\\t// a[p][q] := x\\n\\t// O(log n * log m)\\n\\tvoid set(int p, int q, T x){\\n\\t\\tdata[p += n][q += m] = x;\\n\\t\\tfor(auto j = q; j >>= 1; ) data[p][j] = TT(data[p][j << 1], data[p][j << 1 | 1]);\\n\\t\\tfor(auto i = p; i >>= 1; ){\\n\\t\\t\\tdata[i][q] = TT(data[i << 1][q], data[i << 1 | 1][q]);\\n\\t\\t\\tfor(auto j = q; j >>= 1; ) data[i][j] = TT(data[i][j << 1], data[i][j << 1 | 1]);\\n\\t\\t}\\n\\t}\\n\\t// Returns a[p][q]\\n\\t// O(1)\\n\\tT query(int p, int q){\\n\\t\\treturn data[p + n][q + m];\\n\\t}\\n\\t// Returns the sum of a[i][j] on [xl, xr) X [yl, yr)\\n\\t// O(log n * log m)\\n\\tT query(int xl, int xr, int yl, int yr){\\n\\t\\tif(xl >= xr || yl >= yr) return T_id;\\n\\t\\tT res = T_id;\\n\\t\\txl += n, xr += n, yl += m, yr += m;\\n\\t\\tfor(auto il = xl, ir = xr; il < ir; il >>= 1, ir >>= 1){\\n\\t\\t\\tif(il & 1){\\n\\t\\t\\t\\tfor(auto jl = yl, jr = yr; jl < jr; jl >>= 1, jr >>= 1){\\n\\t\\t\\t\\t\\tif(jl & 1) res = TT(res, data[il][jl ++]);\\n\\t\\t\\t\\t\\tif(jr & 1) res = TT(res, data[il][-- jr]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t++ il;\\n\\t\\t\\t}\\n\\t\\t\\tif(ir & 1){\\n\\t\\t\\t\\t-- ir;\\n\\t\\t\\t\\tfor(auto jl = yl, jr = yr; jl < jr; jl >>= 1, jr >>= 1){\\n\\t\\t\\t\\t\\tif(jl & 1) res = TT(res, data[ir][jl ++]);\\n\\t\\t\\t\\t\\tif(jr & 1) res = TT(res, data[ir][-- jr]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n\\ttemplate<class output_stream>\\n\\tfriend output_stream &operator<<(output_stream &out, const segment_tree_2d<T, F> &seg){\\n\\t\\tfor(auto i = 0; i < seg.n; ++ i){\\n\\t\\t\\tout << \"\\\\n[\";\\n\\t\\t\\tfor(auto j = 0; j < seg.m; ++ j){\\n\\t\\t\\t\\tout << seg.query(i, j);\\n\\t\\t\\t\\tif(j != seg.m - 1) out << \", \";\\n\\t\\t\\t}\\n\\t\\t\\tout << \"]\\\\n\";\\n\\t\\t}\\n\\t\\treturn out;\\n\\t}\\n};\\n\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int n = len(grid);\\n        int m = len(grid[0]);\\n        segment_tree_2d seg(n, m, [&](int l, int r){return min(l, r);}, 1e9);\\n        seg.set(n-1, m-1, 0);\\n        rep(i, n-1, -1, -1){\\n            rep(j, m-1, -1, -1){\\n                int mn = min(1 + seg.query(i, min(n, 1+ i + grid[i][j]), j, j+1),\\n\\t\\t\\t\\t\\t\\t\\t\\t1 + seg.query(i, i+1, j, min(m, j + 1 + grid[i][j])));\\n\\t\\t\\t\\t\\t\\t\\t\\tseg.set(i, j, mn);\\n            }\\n        }\\n        if (seg.query(0, 0) >= 1e9) return -1;\\n        else return seg.query(0, 0);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3396488,
                "title": "optimized-bfs-recording-maximum-reach-on-each-row-and-column",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumVisitedCells(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        int[] maxColumnReach = new int[m];\\n        int[] maxRowReach = new int[n];\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[] {0, 0});\\n        maxColumnReach[0] = 1;\\n        maxRowReach[0] = 1;\\n        int steps = 1;\\n        while (!queue.isEmpty()) {\\n            for (int i = queue.size(); i > 0; i--) {\\n                int[] t = queue.poll();\\n                int r = t[0], c = t[1];\\n                if (r == m - 1 && c == n - 1) {\\n                    return steps;\\n                }\\n                for (int j = Math.max(maxColumnReach[r], c + 1); j <= grid[r][c] + c && j < n; j++) {\\n                    if (!visited[r][j]) {\\n                        visited[r][j] = true;\\n                        queue.offer(new int[] {r, j});\\n                    }\\n                }\\n                maxColumnReach[r] = Math.max(maxColumnReach[r], Math.min(grid[r][c] + c, n - 1));\\n                for (int j = Math.max(maxRowReach[c], r + 1); j <= grid[r][c] + r && j < m; j++) {\\n                    if (!visited[j][c]) {\\n                        visited[j][c] = true;\\n                        queue.offer(new int[] {j, c});\\n                    }\\n                }\\n                maxRowReach[c] = Math.max(maxRowReach[c], Math.min(grid[r][c] + r, m - 1));\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumVisitedCells(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        int[] maxColumnReach = new int[m];\\n        int[] maxRowReach = new int[n];\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[] {0, 0});\\n        maxColumnReach[0] = 1;\\n        maxRowReach[0] = 1;\\n        int steps = 1;\\n        while (!queue.isEmpty()) {\\n            for (int i = queue.size(); i > 0; i--) {\\n                int[] t = queue.poll();\\n                int r = t[0], c = t[1];\\n                if (r == m - 1 && c == n - 1) {\\n                    return steps;\\n                }\\n                for (int j = Math.max(maxColumnReach[r], c + 1); j <= grid[r][c] + c && j < n; j++) {\\n                    if (!visited[r][j]) {\\n                        visited[r][j] = true;\\n                        queue.offer(new int[] {r, j});\\n                    }\\n                }\\n                maxColumnReach[r] = Math.max(maxColumnReach[r], Math.min(grid[r][c] + c, n - 1));\\n                for (int j = Math.max(maxRowReach[c], r + 1); j <= grid[r][c] + r && j < m; j++) {\\n                    if (!visited[j][c]) {\\n                        visited[j][c] = true;\\n                        queue.offer(new int[] {j, c});\\n                    }\\n                }\\n                maxRowReach[c] = Math.max(maxRowReach[c], Math.min(grid[r][c] + r, m - 1));\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396017,
                "title": "optimized-bfs-approach",
                "content": "```\\nclass Solution {\\n    public int minimumVisitedCells(int[][] grid) {\\n        List<TreeSet<Integer>> rows = new ArrayList<>();\\n         List<TreeSet<Integer>> cols = new ArrayList<>();\\n        \\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        for(int i=0;i<n;i++) {\\n            TreeSet<Integer> ts = new TreeSet<>();\\n            ts.add(-1);\\n            for(int j=1;j<=m;j++) ts.add(j);\\n            rows.add(ts);\\n        }\\n        for(int i=0;i<m;i++) {\\n            TreeSet<Integer> ts = new TreeSet<>();\\n            ts.add(-1);\\n            for(int j=1;j<=n;j++) ts.add(j);\\n            cols.add(ts);\\n        }\\n        boolean [][]visit = new boolean[n][m];\\n        int count = 1;\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0,0});\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            for(int j=0;j<size;j++) {\\n                int a[] = q.remove();\\n                if(a[0]==n-1 && a[1]==m-1) return count;\\n                TreeSet<Integer>row = rows.get(a[0]); \\n                int rl = row.ceiling(a[1]);\\n                while(rl<m) {\\n                    if(rl <= grid[a[0]][a[1]]+a[1]){\\n                        q.add(new int[]{a[0], rl});\\n                        row.remove(rl);\\n                        TreeSet<Integer>col = cols.get(rl);\\n                        col.remove(a[0]);\\n                        rl = row.ceiling(rl);\\n                    }\\n                    else break;\\n                }\\n                TreeSet<Integer>col = cols.get(a[1]); \\n                int cd = col.ceiling(a[0]);\\n                while(cd<n) {\\n                    if(cd <= grid[a[0]][a[1]]+a[0]){\\n                        q.add(new int[]{cd, a[1]});\\n                        col.remove(cd);\\n                       \\n                        TreeSet<Integer>row1 = rows.get(cd);\\n                        row1.remove(a[1]);\\n                        cd = col.ceiling(cd);\\n                    }\\n                    else break;\\n                }\\n            }\\n            count++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Tree",
                    "Breadth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumVisitedCells(int[][] grid) {\\n        List<TreeSet<Integer>> rows = new ArrayList<>();\\n         List<TreeSet<Integer>> cols = new ArrayList<>();\\n        \\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        for(int i=0;i<n;i++) {\\n            TreeSet<Integer> ts = new TreeSet<>();\\n            ts.add(-1);\\n            for(int j=1;j<=m;j++) ts.add(j);\\n            rows.add(ts);\\n        }\\n        for(int i=0;i<m;i++) {\\n            TreeSet<Integer> ts = new TreeSet<>();\\n            ts.add(-1);\\n            for(int j=1;j<=n;j++) ts.add(j);\\n            cols.add(ts);\\n        }\\n        boolean [][]visit = new boolean[n][m];\\n        int count = 1;\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0,0});\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            for(int j=0;j<size;j++) {\\n                int a[] = q.remove();\\n                if(a[0]==n-1 && a[1]==m-1) return count;\\n                TreeSet<Integer>row = rows.get(a[0]); \\n                int rl = row.ceiling(a[1]);\\n                while(rl<m) {\\n                    if(rl <= grid[a[0]][a[1]]+a[1]){\\n                        q.add(new int[]{a[0], rl});\\n                        row.remove(rl);\\n                        TreeSet<Integer>col = cols.get(rl);\\n                        col.remove(a[0]);\\n                        rl = row.ceiling(rl);\\n                    }\\n                    else break;\\n                }\\n                TreeSet<Integer>col = cols.get(a[1]); \\n                int cd = col.ceiling(a[0]);\\n                while(cd<n) {\\n                    if(cd <= grid[a[0]][a[1]]+a[0]){\\n                        q.add(new int[]{cd, a[1]});\\n                        col.remove(cd);\\n                       \\n                        TreeSet<Integer>row1 = rows.get(cd);\\n                        row1.remove(a[1]);\\n                        cd = col.ceiling(cd);\\n                    }\\n                    else break;\\n                }\\n            }\\n            count++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395944,
                "title": "c-dp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, INT_MAX));\\n        vector<int> rowMax(m), colMax(n);\\n        dp[0][0] = 1;\\n\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (dp[i][j] == INT_MAX) continue;\\n\\n                for (int k = max(colMax[j], i + 1); k < m && k <= i + grid[i][j]; ++k)\\n                    dp[k][j] = min(dp[k][j], dp[i][j] + 1);\\n\\n                for (int k = max(rowMax[i], j + 1); k < n && k <= j + grid[i][j]; ++k)\\n                    dp[i][k] = min(dp[i][k], dp[i][j] + 1);\\n\\n                rowMax[i] = j + grid[i][j];\\n                colMax[j] = i + grid[i][j];\\n            }\\n        }\\n\\n        return dp[m - 1][n - 1] == INT_MAX ? -1 : dp[m - 1][n - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, INT_MAX));\\n        vector<int> rowMax(m), colMax(n);\\n        dp[0][0] = 1;\\n\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (dp[i][j] == INT_MAX) continue;\\n\\n                for (int k = max(colMax[j], i + 1); k < m && k <= i + grid[i][j]; ++k)\\n                    dp[k][j] = min(dp[k][j], dp[i][j] + 1);\\n\\n                for (int k = max(rowMax[i], j + 1); k < n && k <= j + grid[i][j]; ++k)\\n                    dp[i][k] = min(dp[i][k], dp[i][j] + 1);\\n\\n                rowMax[i] = j + grid[i][j];\\n                colMax[j] = i + grid[i][j];\\n            }\\n        }\\n\\n        return dp[m - 1][n - 1] == INT_MAX ? -1 : dp[m - 1][n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395924,
                "title": "dijkstra",
                "content": "# Intuition\\nThis is essentially a (simplified) version of Dijkstra problem. With this idea in mind, the solution is quite straightforward.\\n\\nNote: many matrix problems can be solved with graph algorithms.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumVisitedCells(int[][] grid) {\\n        int[][] distTo = new int[grid.length][grid[0].length];\\n        for (int[] row : distTo) {\\n            Arrays.fill(row, Integer.MAX_VALUE);\\n        }\\n\\n        distTo[0][0] = 1;\\n\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.add(new int[] {0, 0, distTo[0][0]});\\n\\n        while (!queue.isEmpty()) {\\n            int[] curr = queue.poll();\\n            int i = curr[0];\\n            int j = curr[1];\\n\\n            if (distTo[i][j] < curr[2] || distTo[grid.length - 1][grid[0].length - 1] <= curr[2]) {\\n                continue;\\n            }\\n\\n            for (int k = j + 1; k <= j + grid[i][j] && k < grid[0].length; k++) {\\n                if (distTo[i][k] > distTo[i][j] + 1 && distTo[grid.length - 1][grid[0].length - 1] > distTo[i][j] + 1) {\\n                    distTo[i][k] = distTo[i][j] + 1;\\n                    queue.add(new int[] {i, k, distTo[i][k]});\\n                }\\n            }\\n\\n            for (int k = i + 1; k <= i + grid[i][j] && k < grid.length; k++) {\\n                if (distTo[k][j] > distTo[i][j] + 1 && distTo[grid.length - 1][grid[0].length - 1] > distTo[i][j] + 1) {\\n                    distTo[k][j] = distTo[i][j] + 1;\\n                    queue.add(new int[] {k, j, distTo[k][j]});\\n                }\\n            }\\n        }\\n\\n        return distTo[grid.length - 1][grid[0].length - 1] == Integer.MAX_VALUE ? -1 : distTo[grid.length - 1][grid[0].length - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumVisitedCells(int[][] grid) {\\n        int[][] distTo = new int[grid.length][grid[0].length];\\n        for (int[] row : distTo) {\\n            Arrays.fill(row, Integer.MAX_VALUE);\\n        }\\n\\n        distTo[0][0] = 1;\\n\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.add(new int[] {0, 0, distTo[0][0]});\\n\\n        while (!queue.isEmpty()) {\\n            int[] curr = queue.poll();\\n            int i = curr[0];\\n            int j = curr[1];\\n\\n            if (distTo[i][j] < curr[2] || distTo[grid.length - 1][grid[0].length - 1] <= curr[2]) {\\n                continue;\\n            }\\n\\n            for (int k = j + 1; k <= j + grid[i][j] && k < grid[0].length; k++) {\\n                if (distTo[i][k] > distTo[i][j] + 1 && distTo[grid.length - 1][grid[0].length - 1] > distTo[i][j] + 1) {\\n                    distTo[i][k] = distTo[i][j] + 1;\\n                    queue.add(new int[] {i, k, distTo[i][k]});\\n                }\\n            }\\n\\n            for (int k = i + 1; k <= i + grid[i][j] && k < grid.length; k++) {\\n                if (distTo[k][j] > distTo[i][j] + 1 && distTo[grid.length - 1][grid[0].length - 1] > distTo[i][j] + 1) {\\n                    distTo[k][j] = distTo[i][j] + 1;\\n                    queue.add(new int[] {k, j, distTo[k][j]});\\n                }\\n            }\\n        }\\n\\n        return distTo[grid.length - 1][grid[0].length - 1] == Integer.MAX_VALUE ? -1 : distTo[grid.length - 1][grid[0].length - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395875,
                "title": "wrong-solution-got-ac",
                "content": "# Important update\\nAfter using vonnan\\'s testcase, I found that this solution is wrong although it passed the contest\\'s testcases. I wrongly conjectured that the shape of the visited cell after each step is stair-shape without holes.\\n\\nOne of the correct ways is to use sortedlist structure to store unvisited cell. Please refer to [tojuna](https://leetcode.com/problems/minimum-number-of-visited-cells-in-a-grid/solutions/3395709/c-java-python3-set-treeset-sortedlist-bfs/) for details. You can use this data structure to do the same thing to solve [Minimum Reverse Operations](https://leetcode.com/problems/minimum-reverse-operations/solutions/3368819/python3-bfs-sortedlist-keep-track-of-remaining-nodes/?orderBy=most_votes) in previous contest.\\n\\n# The following solution is wrong but got AC\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple BFS has a complexity of $O(mn*max(m,n))$, so we need to track the rightmost visited cell of each row and bottommost visited cell of each column to avoid duplicate visiting which reduce the complexity to $O(mn)$. In the following implementation, array $r$ and $c$ are used to accomplish that.\\n\\n# Complexity\\n- Time complexity:$O(mn)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        m,n=len(grid),len(grid[0])\\n        q=deque()\\n        q.append((0,0))\\n        step=1\\n        # avoid duplicate visit by tracking visited boundary of each row and col\\n        r=[0]*m\\n        c=[0]*n\\n        while q:\\n            cl=len(q)\\n            for i in range(cl):\\n                x,y=q.popleft()\\n                if (x,y)==(m-1,n-1): return step\\n                for j in range(min(m-1,x+grid[x][y]),x,-1):\\n                    # avoid duplicate visiting\\n                    if j<=c[y]: break\\n                    q.append((j,y))\\n                for j in range(min(n-1,y+grid[x][y]),y,-1):\\n                    # avoid duplicate visiting\\n                    if j<=r[x]: break\\n                    q.append((x,j))\\n                r[x]=max(r[x],y+grid[x][y])\\n                c[y]=max(c[y],x+grid[x][y])\\n            step+=1\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        m,n=len(grid),len(grid[0])\\n        q=deque()\\n        q.append((0,0))\\n        step=1\\n        # avoid duplicate visit by tracking visited boundary of each row and col\\n        r=[0]*m\\n        c=[0]*n\\n        while q:\\n            cl=len(q)\\n            for i in range(cl):\\n                x,y=q.popleft()\\n                if (x,y)==(m-1,n-1): return step\\n                for j in range(min(m-1,x+grid[x][y]),x,-1):\\n                    # avoid duplicate visiting\\n                    if j<=c[y]: break\\n                    q.append((j,y))\\n                for j in range(min(n-1,y+grid[x][y]),y,-1):\\n                    # avoid duplicate visiting\\n                    if j<=r[x]: break\\n                    q.append((x,j))\\n                r[x]=max(r[x],y+grid[x][y])\\n                c[y]=max(c[y],x+grid[x][y])\\n            step+=1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395723,
                "title": "c-simple-bfs-fully-explained",
                "content": "# Approach\\n\\nHi there! In this post, I will explain the problem called \"Minimum Visited Cells\" which is similar to the problem \"Minimum Time to Visit a Cell In a Grid\" on LeetCode. The problem statement is as follows:\\n\\nYou are given a m x n matrix grid consisting of non-negative integers where grid[row][col] represents the maximum number of steps you can take from the cell (row, col) in either horizontal or vertical direction. You are standing in the top-left cell of the matrix and you must move to the bottom-right cell of the matrix. Return the minimum number of cells that you need to visit in order to reach the bottom-right cell of the matrix. If you cannot reach the bottom-right cell, then return -1.\\n\\nFor example, if the grid is:\\n\\n[ [2, 1, 3],\\n  [4, 2, 1],\\n  [3, 2, 2] ]\\n\\nThe minimum number of cells that you need to visit is 5. One possible path is:\\n\\n(0, 0) -> (0, 2) -> (1, 2) -> (1, 1) -> (2, 2)\\n\\nThe code uses a breadth-first search (BFS) algorithm to find the shortest path from the top-left cell to the bottom-right cell. It uses a queue to store the cells that need to be explored and a 2D vector to store the distance of each cell from the top-left cell. The distance vector is initialized with INT_MAX which means infinity. The queue is initialized with the top-left cell and its distance is set to zero.\\n\\nThe code then enters a while loop that runs until the queue is empty or until the bottom-right cell is reached. In each iteration, it pops out a cell from the queue and checks its row and column indices. It also checks its distance from the top-left cell which is stored in a variable d.\\n\\nIf the current cell is the bottom-right cell, it returns d+1 as the answer. This is because we need to count both the starting and ending cells as visited.\\n\\nOtherwise, it tries to move horizontally and vertically from the current cell by adding grid[row][col] to its column and row indices respectively. It makes sure that the new indices are within the bounds of the matrix and that the new distance is smaller than the previous distance stored in the distance vector. If these conditions are met, it updates the distance vector with d+1 and pushes the new cell into the queue.\\n\\nThe code also has an optimization that checks if the distance vector of the bottom-right cell has been updated and if it is smaller than or equal to d+1. If this is true, it means that there is no need to explore further cells and it returns dist[m-1][n-1]+1 as the answer.\\n\\nIf the while loop ends without returning any answer, it means that there is no path from the top-left cell to the bottom-right cell and it returns -1.\\n\\nThe time complexity of this code is O(m*n) where m and n are the dimensions of the matrix. This is because each cell can be visited at most once by BFS and updating and checking distances takes constant time.\\n\\nThe space complexity of this code is also O(m*n) because of the queue and distance vector that store m*n elements at most.\\n\\nI hope this post was helpful and informative. If you have any questions or feedback, please leave them in the comments section below. Thank you for reading!\\n### And yeah if you liked my explaination, please motivate me by just one upvote.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dist(m, vector<int>(n, INT_MAX));\\n        queue<pair<int, int>> q;\\n        q.push({0, 0});\\n        dist[0][0] = 0;\\n        while (!q.empty()) {\\n            auto curr = q.front();\\n            q.pop();\\n            int r = curr.first;\\n            int c = curr.second;\\n            int d = dist[r][c];\\n            if (r == m - 1 && c == n - 1) {\\n                return d+1;\\n            }\\n            for (int k = c + 1; k <= min(c + grid[r][c], n - 1); k++) {\\n                if (d + 1 < dist[r][k]) {\\n                    dist[r][k] = d + 1;\\n                    q.push({r, k});\\n                }\\n            }\\n            for (int k = r + 1; k <= min(r + grid[r][c], m - 1); k++) {\\n                if (d + 1 < dist[k][c]) {\\n                    dist[k][c] = d + 1;\\n                    q.push({k, c});\\n                }\\n            }\\n            if (dist[m-1][n-1] != INT_MAX && d + 1 >= dist[m-1][n-1]) {\\n                return dist[m-1][n-1]+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dist(m, vector<int>(n, INT_MAX));\\n        queue<pair<int, int>> q;\\n        q.push({0, 0});\\n        dist[0][0] = 0;\\n        while (!q.empty()) {\\n            auto curr = q.front();\\n            q.pop();\\n            int r = curr.first;\\n            int c = curr.second;\\n            int d = dist[r][c];\\n            if (r == m - 1 && c == n - 1) {\\n                return d+1;\\n            }\\n            for (int k = c + 1; k <= min(c + grid[r][c], n - 1); k++) {\\n                if (d + 1 < dist[r][k]) {\\n                    dist[r][k] = d + 1;\\n                    q.push({r, k});\\n                }\\n            }\\n            for (int k = r + 1; k <= min(r + grid[r][c], m - 1); k++) {\\n                if (d + 1 < dist[k][c]) {\\n                    dist[k][c] = d + 1;\\n                    q.push({k, c});\\n                }\\n            }\\n            if (dist[m-1][n-1] != INT_MAX && d + 1 >= dist[m-1][n-1]) {\\n                return dist[m-1][n-1]+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970091,
                "title": "2617-minimum-number-of-visited-cells-in-a-grid",
                "content": "```\\ntemplate <typename T>\\nclass RangeQuery {\\n public:\\n  virtual void update(int index, int val);\\n  virtual T query(int i, int j);\\n\\n private:\\n  virtual T merge(T a, T b);\\n\\n protected:\\n  int left(int treeIndex) {\\n    return 2 * treeIndex + 1;\\n  }\\n\\n  int right(int treeIndex) {\\n    return 2 * treeIndex + 2;\\n  }\\n};\\n\\nclass SegmentTree : RangeQuery<int> {\\n public:\\n  explicit SegmentTree(int n, int kInf) : n(n), kInf(kInf), tree(4 * n, kInf) {}\\n\\n  // Updates nums[i] to val equivalently.\\n  void update(int i, int val) override {\\n    update(0, 0, n - 1, i, val);\\n  }\\n\\n  // Returns min(nums[i..j]).\\n  int query(int i, int j) override {\\n    return query(0, 0, n - 1, i, j);\\n  }\\n\\n private:\\n  const int n;       // size of the input array\\n  const int kInf;    // invalid value\\n  vector<int> tree;  // segment tree\\n\\n  void update(int treeIndex, int lo, int hi, int i, int val) {\\n    if (lo == i && hi == i) {\\n      tree[treeIndex] = val;\\n      return;\\n    }\\n    const int mid = (lo + hi) / 2;\\n    const int leftTreeIndex = left(treeIndex);\\n    const int rightTreeIndex = right(treeIndex);\\n    if (i <= mid)\\n      update(leftTreeIndex, lo, mid, i, val);\\n    else\\n      update(rightTreeIndex, mid + 1, hi, i, val);\\n    tree[treeIndex] = merge(tree[leftTreeIndex], tree[rightTreeIndex]);\\n  }\\n\\n  int query(int treeIndex, int lo, int hi, int i, int j) {\\n    // [lo, hi] lies completely inside [i, j].\\n    if (i <= lo && hi <= j)\\n      return tree[treeIndex];\\n    // [lo, hi] lies completely outside [i, j].\\n    if (j < lo || hi < i)\\n      return kInf;\\n    const int mid = (lo + hi) / 2;\\n    return merge(query(left(treeIndex), lo, mid, i, j),\\n                 query(right(treeIndex), mid + 1, hi, i, j));\\n  }\\n\\n  // Merges the result of left node and right node.\\n  int merge(int a, int b) override {\\n    return min(a, b);\\n  }\\n};\\n\\nclass Solution {\\n public:\\n  int minimumVisitedCells(vector<vector<int>>& grid) {\\n    const int m = grid.size();\\n    const int n = grid[0].size();\\n    const int kInf = (m + n) * 2 - 1;\\n    vector<SegmentTree> rows(m, SegmentTree(n, kInf));\\n    vector<SegmentTree> cols(n, SegmentTree(m, kInf));\\n\\n    // The min # cells to visit (m - 1, n - 1) from (m - 1, n - 1) is 1.\\n    rows[m - 1].update(n - 1, 1);\\n    cols[n - 1].update(m - 1, 1);\\n\\n    for (int i = m - 1; i >= 0; --i)\\n      for (int j = n - 1; j >= 0; --j) {\\n        // There\\'s no k s.t. j < k <= 0 + j.\\n        // There\\'s no k s.t. i < k <= 0 + i.\\n        if (grid[i][j] == 0)\\n          continue;\\n        const int moveRight = rows[i].query(j + 1, grid[i][j] + j);\\n        const int moveDown = cols[j].query(i + 1, grid[i][j] + i);\\n        const int minMove = min(kInf, min(moveRight, moveDown) + 1);\\n        rows[i].update(j, minMove);\\n        cols[j].update(i, minMove);\\n      }\\n\\n    const int res = rows[0].query(0, 0);\\n    return res == kInf ? -1 : res;\\n  }\\n};\\n",
                "solutionTags": [
                    "Array",
                    "Dynamic Programming",
                    "Stack",
                    "Tree",
                    "Union Find",
                    "Binary Indexed Tree"
                ],
                "code": "class Solution {\\n public:\\n  int minimumVisitedCells(vector<vector<int>>& grid) {\\n    const int m = grid.size();\\n    const int n = grid[0].size();\\n    const int kInf = (m + n) * 2 - 1;\\n    vector<SegmentTree> rows(m, SegmentTree(n, kInf));\\n    vector<SegmentTree> cols(n, SegmentTree(m, kInf));\\n\\n    // The min # cells to visit (m - 1, n - 1) from (m - 1, n - 1) is 1.\\n    rows[m - 1].update(n - 1, 1);\\n    cols[n - 1].update(m - 1, 1);\\n\\n    for (int i = m - 1; i >= 0; --i)\\n      for (int j = n - 1; j >= 0; --j) {\\n        // There\\'s no k s.t. j < k <= 0 + j.\\n        // There\\'s no k s.t. i < k <= 0 + i.\\n        if (grid[i][j] == 0)\\n          continue;\\n        const int moveRight = rows[i].query(j + 1, grid[i][j] + j);\\n        const int moveDown = cols[j].query(i + 1, grid[i][j] + i);\\n        const int minMove = min(kInf, min(moveRight, moveDown) + 1);\\n        rows[i].update(j, minMove);\\n        cols[j].update(i, minMove);\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 3871864,
                "title": "java-dp-solution-bottom-up-approach",
                "content": "Time Complexity -> O (m*n * logm*n)\\nSpace Comlexity. O(m*n)\\n```\\nclass Solution {\\n    public int minimumVisitedCells(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        TreeMap<Integer, Integer> [] colMap = new TreeMap[n];\\n        for(int i =0; i<colMap.length; i++)\\n            colMap[i] = new TreeMap();\\n        for(int i = m-1; i>=0; i--){\\n            TreeMap<Integer, Integer> rowMap = new TreeMap();\\n            for(int j = n-1; j>=0 ;j--){\\n                if(i == m-1 && j == n-1){\\n                    rowMap.put(n-1, 1);\\n                    colMap[n-1].put(m-1, 1);\\n                    continue;\\n                }\\n                int min = -1;\\n                int maxCol = j + grid[i][j];\\n                Map.Entry<Integer, Integer> floorRow = rowMap.floorEntry(maxCol);\\n                if(floorRow != null){\\n                    min = floorRow.getValue() + 1;\\n                }\\n                int maxRow = i + grid[i][j];\\n                Map.Entry<Integer, Integer> floorCol = colMap[j].floorEntry(maxRow);\\n                if(floorCol != null){\\n                    min = min == -1 ? (floorCol.getValue() + 1) : Math.min(floorCol.getValue() + 1, min);\\n                }\\n                if(min == -1)\\n                    continue;\\n                arrange(j, min, rowMap);\\n                arrange(i, min, colMap[j]);\\n            }\\n        }\\n        Integer res = colMap[0].get(0);\\n        if(res == null)\\n            return -1;\\n        return colMap[0].get(0);\\n    }\\n    \\n    private void arrange(int key, int val, TreeMap<Integer, Integer> map){\\n        while(map.size() > 0){\\n            Map.Entry<Integer, Integer> lower = map.firstEntry();\\n            if(lower.getValue() >= val)\\n                map.remove(lower.getKey());\\n            else\\n                break;\\n        }\\n        map.put(key, val);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumVisitedCells(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        TreeMap<Integer, Integer> [] colMap = new TreeMap[n];\\n        for(int i =0; i<colMap.length; i++)\\n            colMap[i] = new TreeMap();\\n        for(int i = m-1; i>=0; i--){\\n            TreeMap<Integer, Integer> rowMap = new TreeMap();\\n            for(int j = n-1; j>=0 ;j--){\\n                if(i == m-1 && j == n-1){\\n                    rowMap.put(n-1, 1);\\n                    colMap[n-1].put(m-1, 1);\\n                    continue;\\n                }\\n                int min = -1;\\n                int maxCol = j + grid[i][j];\\n                Map.Entry<Integer, Integer> floorRow = rowMap.floorEntry(maxCol);\\n                if(floorRow != null){\\n                    min = floorRow.getValue() + 1;\\n                }\\n                int maxRow = i + grid[i][j];\\n                Map.Entry<Integer, Integer> floorCol = colMap[j].floorEntry(maxRow);\\n                if(floorCol != null){\\n                    min = min == -1 ? (floorCol.getValue() + 1) : Math.min(floorCol.getValue() + 1, min);\\n                }\\n                if(min == -1)\\n                    continue;\\n                arrange(j, min, rowMap);\\n                arrange(i, min, colMap[j]);\\n            }\\n        }\\n        Integer res = colMap[0].get(0);\\n        if(res == null)\\n            return -1;\\n        return colMap[0].get(0);\\n    }\\n    \\n    private void arrange(int key, int val, TreeMap<Integer, Integer> map){\\n        while(map.size() > 0){\\n            Map.Entry<Integer, Integer> lower = map.firstEntry();\\n            if(lower.getValue() >= val)\\n                map.remove(lower.getKey());\\n            else\\n                break;\\n        }\\n        map.put(key, val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739563,
                "title": "c-dp-style-solution",
                "content": "# Intuition\\n\\nStart with DP intuition. Assume `dp[i][j] = minimum number of pieces to reach grid[i][j]`. Then, it is clear that `dp[i][j] = min(dp[a][j], dp[i][b]), for 0 <= a < i, 0 <= b < j, and grid[a][j]+a >= i, grid[i][b] + b >= j\\'`.\\n\\nSimply by applying this DP algorithm naively we can get solution in `O(m*n * (m+n))` time. However, this is too slow.\\n\\n# Approach\\n\\nWe can try to improve our DP solution. Notice that we only need the minimum from both column and row ***such that range permits***. We can implement this using a priority queue. Store all <steps, maximum range> in the queue, and each time, check the current minimum. If current minimum has range that is less than required, we can safely discard this, since we will not need it later as `i` and `j` can only further increase. Otherwise, we use it. Since we need both row and column, we will need priority queues for each column and row. Since we go through rows 1 at a time, we can use 1 priority queue for the row. \\n\\nSince our state is only dependent on the \"candidates\" from priority queues, we don\\'t even need a dp memo grid. The last result is the answer. \\n\\n# Complexity\\n- Time complexity:\\n`O(m*n*(logn+logm))`\\n\\n- Space complexity:\\n`O(m*n)`\\n\\n# Code\\n```\\nusing data_t = std::pair<int,int>;\\n\\n#define pq_t std::priority_queue<data_t, std::vector<data_t>, decltype(cmp)>\\n\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n\\n        int R = grid.size(), C = grid[0].size();\\n        int max_val = R*C, res = max_val+1;\\n        auto cmp = [](const data_t& a, const data_t& b) {\\n            return a.first > b.first;\\n        };\\n        pq_t pq(cmp); \\n\\n        std::vector<pq_t> pq_top(C, pq_t(cmp));\\n\\n        for (int i = 0; i < C; ++i) pq_top[i].emplace(max_val, 0);\\n\\n        for (int i = 0; i < R; ++i) {\\n            pq_t pq_left(cmp);\\n            pq_left.emplace(max_val, 0);\\n            for (int j = 0; j < C; ++j) {\\n                int min_from_left = max_val, min_from_top = max_val;\\n                while(!pq_top[j].empty()) {\\n                    auto [val, range] = pq_top[j].top();\\n                    if (range < i) pq_top[j].pop();\\n                    else {\\n                        min_from_top = val;\\n                        break;\\n                    }\\n                }\\n\\n                while(!pq_left.empty()) {\\n                    auto [val, range] = pq_left.top();\\n                    if (range < j) pq_left.pop();\\n                    else {\\n                        min_from_left = val;\\n                        break;\\n                    }\\n                }\\n\\n                res = 1 + std::min(min_from_top, min_from_left);\\n\\n                if (i == 0 && j == 0) res = 1;\\n\\n                if (res <= max_val) {\\n                    pq_left.emplace(res, j+grid[i][j]);\\n                    pq_top[j].emplace(res, i+grid[i][j]);\\n                }\\n            }\\n        }\\n\\n        return res > max_val ? -1 : res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nusing data_t = std::pair<int,int>;\\n\\n#define pq_t std::priority_queue<data_t, std::vector<data_t>, decltype(cmp)>\\n\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n\\n        int R = grid.size(), C = grid[0].size();\\n        int max_val = R*C, res = max_val+1;\\n        auto cmp = [](const data_t& a, const data_t& b) {\\n            return a.first > b.first;\\n        };\\n        pq_t pq(cmp); \\n\\n        std::vector<pq_t> pq_top(C, pq_t(cmp));\\n\\n        for (int i = 0; i < C; ++i) pq_top[i].emplace(max_val, 0);\\n\\n        for (int i = 0; i < R; ++i) {\\n            pq_t pq_left(cmp);\\n            pq_left.emplace(max_val, 0);\\n            for (int j = 0; j < C; ++j) {\\n                int min_from_left = max_val, min_from_top = max_val;\\n                while(!pq_top[j].empty()) {\\n                    auto [val, range] = pq_top[j].top();\\n                    if (range < i) pq_top[j].pop();\\n                    else {\\n                        min_from_top = val;\\n                        break;\\n                    }\\n                }\\n\\n                while(!pq_left.empty()) {\\n                    auto [val, range] = pq_left.top();\\n                    if (range < j) pq_left.pop();\\n                    else {\\n                        min_from_left = val;\\n                        break;\\n                    }\\n                }\\n\\n                res = 1 + std::min(min_from_top, min_from_left);\\n\\n                if (i == 0 && j == 0) res = 1;\\n\\n                if (res <= max_val) {\\n                    pq_left.emplace(res, j+grid[i][j]);\\n                    pq_top[j].emplace(res, i+grid[i][j]);\\n                }\\n            }\\n        }\\n\\n        return res > max_val ? -1 : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689451,
                "title": "readable-code-c",
                "content": "`\\u2B50\\uFE0F Everyone can see the answers and It\\'s OK to see the answers, But the ones who learn it make the Difference. \\u2B50\\uFE0F`\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDoing all the ways to find the minimum one.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe can use `Dijkstra | BFS` but In this question, these methods are giving TLE in the last cases. So let\\'s use `Tabulation Way` of `Dynamic Programming` and everytime we are looking at another cell for a particular cell, we are checking only for those `right cells` and `down cells`, which have values less than or equal to `storeValue` from already previously visited cells, `As there is no sense in checking those previously visited cells that already taking more than minimum cells to reach our destination.`\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        // Array slightly more efficient than Vector\\n        // Memoization table\\n        int dp[n][m];\\n        for(int i=0;i<n;i++)for(int j=0;j<m;j++) dp[i][j] = -1;\\n\\n        dp[n-1][m-1] = 1; // Base case: destination cell\\n\\n\\n        vector<pair<int,int>> goRightInRow[n];\\n        vector<pair<int,int>> goDownInCol[m];\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int j = m - 1; j >= 0; j--) {\\n                if (i == n - 1 && j == m - 1) {\\n                    dp[i][j] = 1;\\n                    goRightInRow[i].push_back(make_pair(1, j));\\n                    goDownInCol[j].push_back(make_pair(1, i));\\n                    continue;\\n                }\\n                \\n                int storeValue = 1e9;\\n                \\n                // Going right\\n                for (int k = goRightInRow[i].size() - 1; k >= 0; k--) {\\n                    if (goRightInRow[i][k].second - j > grid[i][j]) {\\n                        break; // If k is greater than grid[i][j] + j, then break.\\n                    }\\n                    storeValue = min(storeValue, goRightInRow[i][k].first + 1);\\n                }\\n                \\n                // Going down\\n                for (int k = goDownInCol[j].size() - 1; k >= 0; k--) {\\n                    if (goDownInCol[j][k].second - i > grid[i][j]) {\\n                        break; // If k is greater than grid[i][j] + i, then break.\\n                    }\\n                    storeValue = min(storeValue, goDownInCol[j][k].first + 1);\\n                }\\n                \\n                if (storeValue == 1e9) {\\n                    continue;\\n                }\\n                // Remove those cells having more value than storeValue\\n                while (!goRightInRow[i].empty() && goRightInRow[i].back().first >= storeValue) {\\n                    goRightInRow[i].pop_back();\\n                }\\n                \\n                while (!goDownInCol[j].empty() && goDownInCol[j].back().first >= storeValue) {\\n                    goDownInCol[j].pop_back();\\n                }\\n                \\n                dp[i][j] = storeValue;\\n                goRightInRow[i].push_back(make_pair(storeValue, j));\\n                goDownInCol[j].push_back(make_pair(storeValue, i));\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        // Array slightly more efficient than Vector\\n        // Memoization table\\n        int dp[n][m];\\n        for(int i=0;i<n;i++)for(int j=0;j<m;j++) dp[i][j] = -1;\\n\\n        dp[n-1][m-1] = 1; // Base case: destination cell\\n\\n\\n        vector<pair<int,int>> goRightInRow[n];\\n        vector<pair<int,int>> goDownInCol[m];\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int j = m - 1; j >= 0; j--) {\\n                if (i == n - 1 && j == m - 1) {\\n                    dp[i][j] = 1;\\n                    goRightInRow[i].push_back(make_pair(1, j));\\n                    goDownInCol[j].push_back(make_pair(1, i));\\n                    continue;\\n                }\\n                \\n                int storeValue = 1e9;\\n                \\n                // Going right\\n                for (int k = goRightInRow[i].size() - 1; k >= 0; k--) {\\n                    if (goRightInRow[i][k].second - j > grid[i][j]) {\\n                        break; // If k is greater than grid[i][j] + j, then break.\\n                    }\\n                    storeValue = min(storeValue, goRightInRow[i][k].first + 1);\\n                }\\n                \\n                // Going down\\n                for (int k = goDownInCol[j].size() - 1; k >= 0; k--) {\\n                    if (goDownInCol[j][k].second - i > grid[i][j]) {\\n                        break; // If k is greater than grid[i][j] + i, then break.\\n                    }\\n                    storeValue = min(storeValue, goDownInCol[j][k].first + 1);\\n                }\\n                \\n                if (storeValue == 1e9) {\\n                    continue;\\n                }\\n                // Remove those cells having more value than storeValue\\n                while (!goRightInRow[i].empty() && goRightInRow[i].back().first >= storeValue) {\\n                    goRightInRow[i].pop_back();\\n                }\\n                \\n                while (!goDownInCol[j].empty() && goDownInCol[j].back().first >= storeValue) {\\n                    goDownInCol[j].pop_back();\\n                }\\n                \\n                dp[i][j] = storeValue;\\n                goRightInRow[i].push_back(make_pair(storeValue, j));\\n                goDownInCol[j].push_back(make_pair(storeValue, i));\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3614786,
                "title": "easy-peasy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> g;\\n    int n,m;\\n    bool check(int x,int y){\\n        return (x>=0 && y>=0 && x<n && y<m);\\n    }\\n    #define ii pair<int,int>\\n    #define f first\\n    #define s second\\n    int bfs(){\\n        queue<pair<int,ii>> pq;\\n        vector<vector<int>> dist(n,vector<int>(m,1e9));\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        dist[0][0] = 0;\\n        pq.push({0,{0,0}});\\n\\n        while(!pq.empty()){\\n            auto fs = pq.front();\\n            pq.pop();\\n            int x = fs.s.f;\\n            int y = fs.s.s;\\n            if(x==n-1 && y==m-1){\\n                return dist[n-1][m-1]+1;\\n            }\\n            if(vis[x][y]){\\n                continue;\\n            }\\n            vis[x][y] = 1;\\n            for(int j=y+1;j<=g[x][y]+y;j++){\\n                if(!check(x,j)){\\n                    break;\\n                }\\n                if(check(x,j) && vis[x][j]==0){\\n                    if(dist[x][j]>dist[x][y]+1){\\n                        dist[x][j] = dist[x][y] + 1;\\n                        if(x==n-1 && j==m-1){\\n                           return dist[n-1][m-1]+1;\\n                        }\\n                        pq.push({dist[x][j],{x,j}}); \\n                    }\\n                }\\n            }\\n\\n            for(int j=x+1;j<=g[x][y]+x;j++){\\n                if(!check(j,y)){\\n                    break;\\n                }\\n                if(check(j,y) && vis[j][y]==0){\\n                    if(dist[j][y]>dist[x][y]+1){\\n                        dist[j][y] = dist[x][y] + 1;\\n                        if(j==n-1 && y==m-1){\\n                           return dist[n-1][m-1]+1;\\n                        }\\n                        pq.push({dist[j][y],{j,y}}); \\n                    }\\n                }\\n            }\\n        }\\n        return dist[n-1][m-1]==1e9 ? -1 : dist[n-1][m-1]+1;\\n    }\\n    \\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        g = grid;\\n        n = g.size();\\n        m = g[0].size();\\n        return bfs();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> g;\\n    int n,m;\\n    bool check(int x,int y){\\n        return (x>=0 && y>=0 && x<n && y<m);\\n    }\\n    #define ii pair<int,int>\\n    #define f first\\n    #define s second\\n    int bfs(){\\n        queue<pair<int,ii>> pq;\\n        vector<vector<int>> dist(n,vector<int>(m,1e9));\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        dist[0][0] = 0;\\n        pq.push({0,{0,0}});\\n\\n        while(!pq.empty()){\\n            auto fs = pq.front();\\n            pq.pop();\\n            int x = fs.s.f;\\n            int y = fs.s.s;\\n            if(x==n-1 && y==m-1){\\n                return dist[n-1][m-1]+1;\\n            }\\n            if(vis[x][y]){\\n                continue;\\n            }\\n            vis[x][y] = 1;\\n            for(int j=y+1;j<=g[x][y]+y;j++){\\n                if(!check(x,j)){\\n                    break;\\n                }\\n                if(check(x,j) && vis[x][j]==0){\\n                    if(dist[x][j]>dist[x][y]+1){\\n                        dist[x][j] = dist[x][y] + 1;\\n                        if(x==n-1 && j==m-1){\\n                           return dist[n-1][m-1]+1;\\n                        }\\n                        pq.push({dist[x][j],{x,j}}); \\n                    }\\n                }\\n            }\\n\\n            for(int j=x+1;j<=g[x][y]+x;j++){\\n                if(!check(j,y)){\\n                    break;\\n                }\\n                if(check(j,y) && vis[j][y]==0){\\n                    if(dist[j][y]>dist[x][y]+1){\\n                        dist[j][y] = dist[x][y] + 1;\\n                        if(j==n-1 && y==m-1){\\n                           return dist[n-1][m-1]+1;\\n                        }\\n                        pq.push({dist[j][y],{j,y}}); \\n                    }\\n                }\\n            }\\n        }\\n        return dist[n-1][m-1]==1e9 ? -1 : dist[n-1][m-1]+1;\\n    }\\n    \\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        g = grid;\\n        n = g.size();\\n        m = g[0].size();\\n        return bfs();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596577,
                "title": "bfs-with-extra-information-in-the-queue-to-speed-up-finding-visited-cells",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOriginally when I saw this problem I decided to go with the BFS, I thought the worst case is when n equals m so they both are ~300. In BFS we visit each cell only once, so it shouldn\\'t be a problem. This solution passed almost all the test cases, but gave a TLE in case of a matrix with just one row and 10^5 columns.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe idea is to modify the simple BFS by storing an additional two elements in the queue: `prev_row` and `prev_col`. They will be used to identify which rows we already reached from the previous cell. Here there is one caveat: if on the previous step we went rightward, we can\\'t use the `prev_row` and vice versa.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        if (n == 1 && m == 1)\\n            return 1;\\n        vector<vector<bool>> vis(n, vector<bool>(m, false));\\n        queue<array<int, 4>> q;\\n        q.push({0, 0, 0, 0});\\n        vis[0][0] = true;\\n        vector<int> row_start(n, 0), col_start(m, 0);\\n        for (int d = 0;!q.empty(); d++) {\\n            queue<array<int, 4>> nq;\\n            while (!q.empty()){\\n                auto [ci, cj, prev_row, prev_col] = q.front();\\n                q.pop();\\n                for (int i = max(ci + 1, prev_row) ; i < n && i - (ci + 1) < grid[ci][cj]; i++) {\\n                    int ni = i, nj = cj;\\n                    if (ni == n - 1 && nj == m - 1)\\n                        return d + 2;\\n                    if (vis[ni][nj])\\n                        continue;\\n                    vis[ni][nj] = true;\\n                    nq.push({ni, nj, grid[ci][cj] + ci, 0});\\n                }\\n                for (int j = max(cj + 1, prev_col); j < m && j - (cj + 1) < grid[ci][cj]; j++) {\\n                    int ni = ci, nj = j;\\n                    if (ni == n - 1 && nj == m - 1)\\n                        return d + 2;\\n                    if (vis[ni][nj])\\n                        continue;\\n                    vis[ni][nj] = true;\\n                    nq.push({ni, nj, 0, grid[ci][cj] + cj});\\n                }\\n            }\\n            swap(q, nq);\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        if (n == 1 && m == 1)\\n            return 1;\\n        vector<vector<bool>> vis(n, vector<bool>(m, false));\\n        queue<array<int, 4>> q;\\n        q.push({0, 0, 0, 0});\\n        vis[0][0] = true;\\n        vector<int> row_start(n, 0), col_start(m, 0);\\n        for (int d = 0;!q.empty(); d++) {\\n            queue<array<int, 4>> nq;\\n            while (!q.empty()){\\n                auto [ci, cj, prev_row, prev_col] = q.front();\\n                q.pop();\\n                for (int i = max(ci + 1, prev_row) ; i < n && i - (ci + 1) < grid[ci][cj]; i++) {\\n                    int ni = i, nj = cj;\\n                    if (ni == n - 1 && nj == m - 1)\\n                        return d + 2;\\n                    if (vis[ni][nj])\\n                        continue;\\n                    vis[ni][nj] = true;\\n                    nq.push({ni, nj, grid[ci][cj] + ci, 0});\\n                }\\n                for (int j = max(cj + 1, prev_col); j < m && j - (cj + 1) < grid[ci][cj]; j++) {\\n                    int ni = ci, nj = j;\\n                    if (ni == n - 1 && nj == m - 1)\\n                        return d + 2;\\n                    if (vis[ni][nj])\\n                        continue;\\n                    vis[ni][nj] = true;\\n                    nq.push({ni, nj, 0, grid[ci][cj] + cj});\\n                }\\n            }\\n            swap(q, nq);\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573603,
                "title": "o-nm-log-n-log-m-solution-in-python-using-dp",
                "content": "# Intuition\\nBefore you get intimidated by the hunk of code downstairs, the nitty-gritty of this problem is actually not terrible to understand. I will try my best to explain, but please forgive me if I am still unclear (\\' \\uFF65\\u03C9\\uFF65 \\' )\\n\\n# Approach\\nAfter doing ten million DP problems, this problem immediately seemed pretty evocative of DP. To know the solution at the last square, you can reason out that all you really need to know are the solutions to the squares before it in the same row, as well as the solutions to the squares before it in the same column. The problem with this approach is that it would take O(n^3) ~ O(10**15) to do so, which is really expensive. You can reason that out by noticing that for each square (n^2) of them, you need to query dp solutions 2 * O(n) times for the related row and col. \\n\\nSo how do we make this quicker? I considered maybe there was some kind of clever merging / accumulation strategy but was too lazy to explore that. The more enticing approach was just to make the search faster. And when you want to search faster, heaps are usually the easiest way to do so. \\n\\nBy the problem rules, at any square we really only care about the relevant row and col, so in a perfect world, where we have a heap for the row and a heap for the col, I can just make 2 log(n) queries to find the best solution. But there is a caveat -- how many heaps do I need + how do I decide what values to keep in these heaps /  which ones to evict? This is answered by how we construct the dp array. \\n\\nSince we need to use prior solutions to build the current one, a natural DP formation is to use two for-loops to generate the solutions. At some particular square, I had the (honestly extremely lucky) idea of storing a heap for the column and the row. When I pop off a query on either heap, that query is usable only if the delta (grid value) is enough to reach the current square. Should I ever put that value back in? Yes, if the square is reachable. But if the value cannot reach the current square, then **it cannot ever reach any other subsequent square -- so we dont need to put it back into the heap**. So in one fell swoop, we answer how many heaps we need (on for each row and col) and we answer our eviction strategy. \\n\\nStoring a heap for each row and col seemed to me the most natural, because at any square we need information about the squares in the same row / col. \\n\\nThe main crux of this problem is three points:\\n1. This is DP, we are using solutions to smaller instances of the problem to solve a larger instance\\n2. We use a heap strategy to speed up finding the best solution for each interim step in the DP algo. \\n3. Something not to be ignored, but the strategy to define a heap element was also important -- we need to not only store the rating (min number of steps to reach square), but also the row and col, so that I can find the delta (allowable steps) in O(1) fashion. \\n\\n\\n# Complexity\\n- Time complexity:\\nO(nm * [log(m) + log(n)]) because we make a query in a heap of size at most m and a heap of size at most n **times** O(nm) squares. \\n\\n- Space complexity:\\nO(n*2) + O(m^2), since we have a heap for each row that may store up to n  elements, and a heap for each col that may store up to m elements. This is kind of bad once you look at the bounds, but life is short. \\n\\nEdit: after thinking a bit more, turns out you can reduce the number of heaps for the rows to just one, its not hard to reason this out. \\n\\n# Code\\n```\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        INF = float(\\'inf\\');\\n        dp = [[INF for _ in range(len(grid[0]))] for _ in range(len(grid))];\\n        col_heaps = [[] for _ in range(len(grid[0]))];\\n        row_heaps = [[] for _ in range(len(grid))];\\n\\n        for row in range(len(grid)):\\n            for col in range(len(grid[0])):\\n                colHeap = col_heaps[col]\\n                rowHeap = row_heaps[row]\\n                \\n                # base case: starting from the beginning square is one action\\n                if col == row == 0:\\n                    heapq.heappush(colHeap, (1, 0, 0))\\n                    heapq.heappush(rowHeap, (1, 0, 0))\\n                    dp[0][0] = 1\\n                    continue\\n\\n                bestCol = INF\\n                while(colHeap):\\n                    best1, row1, col1 = colHeap[0]\\n                    delta = grid[row1][col1]\\n\\n                    # can we reach current square?\\n                    if delta + row1 >= row:\\n                        bestCol = best1\\n                        break\\n\\n                    # if not, toss him\\n                    heapq.heappop(colHeap)\\n\\n                bestRow = INF\\n                while(rowHeap):\\n                    best2, row2, col2 = rowHeap[0]\\n                    delta = grid[row2][col2]\\n\\n                    # can we reach current square?\\n                    if delta + col2 >= col:\\n                        bestRow = best2\\n                        break\\n\\n                    # if not, toss him\\n                    heapq.heappop(rowHeap)\\n                    \\n                rating = min(bestRow, bestCol)\\n                dp[row][col] = rating + 1\\n\\n                heapq.heappush(colHeap, (rating + 1, row, col))\\n                heapq.heappush(rowHeap, (rating + 1, row, col))\\n        \\n        return (dp[-1][-1]) if dp[-1][-1] != INF else -1\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        INF = float(\\'inf\\');\\n        dp = [[INF for _ in range(len(grid[0]))] for _ in range(len(grid))];\\n        col_heaps = [[] for _ in range(len(grid[0]))];\\n        row_heaps = [[] for _ in range(len(grid))];\\n\\n        for row in range(len(grid)):\\n            for col in range(len(grid[0])):\\n                colHeap = col_heaps[col]\\n                rowHeap = row_heaps[row]\\n                \\n                # base case: starting from the beginning square is one action\\n                if col == row == 0:\\n                    heapq.heappush(colHeap, (1, 0, 0))\\n                    heapq.heappush(rowHeap, (1, 0, 0))\\n                    dp[0][0] = 1\\n                    continue\\n\\n                bestCol = INF\\n                while(colHeap):\\n                    best1, row1, col1 = colHeap[0]\\n                    delta = grid[row1][col1]\\n\\n                    # can we reach current square?\\n                    if delta + row1 >= row:\\n                        bestCol = best1\\n                        break\\n\\n                    # if not, toss him\\n                    heapq.heappop(colHeap)\\n\\n                bestRow = INF\\n                while(rowHeap):\\n                    best2, row2, col2 = rowHeap[0]\\n                    delta = grid[row2][col2]\\n\\n                    # can we reach current square?\\n                    if delta + col2 >= col:\\n                        bestRow = best2\\n                        break\\n\\n                    # if not, toss him\\n                    heapq.heappop(rowHeap)\\n                    \\n                rating = min(bestRow, bestCol)\\n                dp[row][col] = rating + 1\\n\\n                heapq.heappush(colHeap, (rating + 1, row, col))\\n                heapq.heappush(rowHeap, (rating + 1, row, col))\\n        \\n        return (dp[-1][-1]) if dp[-1][-1] != INF else -1\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549224,
                "title": "c-ready-to-use-segment-tree",
                "content": "# Approach\\nThe segment tree is taken from [this amazing post](https://codeforces.com/blog/entry/18051). Choose the minimal previous state which gives access to the current point `i,j`. To keep track of these, update the farthest reachable point of the segment tree `min(j+grid[i][j], n-1)` with each freshly calculated `dp[i][j]`. \\nAs you can see here is a ready SegTree tree class which is easily adoptable to any problem. Please use and upvote!  \\n\\n# Complexity\\n- Time complexity: $$O(mn~\\\\textrm{log (max}(m,n)))$$\\n\\n- Space complexity: $$O(mn)$$\\n\\n# Code\\n```\\nint INF = 1e9;\\n\\nclass SegTree {\\n    int n; \\n    vector<int> t;\\npublic:\\n    SegTree(int _n) {\\n        n = _n;\\n        t.resize(2*n);\\n        for (int i = 0; i < n; i++) t[i+n] = INF;\\n        for (int i = n-1; i > 0; --i) t[i] = min(t[i*2], t[i*2+1]);\\n    }\\n    int get_range(int l, int r) {\\n        r++; \\n        if (r < l) return INF;\\n        int res = INF;\\n        for (l += n, r += n; l < r; l /= 2, r /= 2) {\\n            if (l&1) res = min(res, t[l++]);\\n            if (r&1) res = min(res, t[--r]);\\n        }\\n        return res; \\n    }\\n    int get_one(int pos) {\\n        return t[pos+n]; \\n    }\\n    void update(int pos, int val) {\\n        for (t[pos += n] = val; pos > 1; pos /= 2) t[pos/2] = min(t[pos], t[pos^1]);\\n        //pos^1 turns 2\\u2009*\\u2009i into 2\\u2009*\\u2009i\\u2009+\\u20091 and vice versa\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<SegTree> row;\\n        for (int i = 0; i < m; i++) row.push_back(SegTree(n));\\n        vector<SegTree> col;\\n        for (int j = 0; j < n; j++) col.push_back(SegTree(m)); \\n        vector<vector<int>> dp(m, vector<int>(n, INF));\\n        dp[0][0] = 1;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i][j] = min(dp[i][j], 1 + row[i].get_range(j,n-1));\\n                dp[i][j] = min(dp[i][j], 1 + col[j].get_range(i,m-1));\\n                int nxt_j = min(j+grid[i][j], n-1); \\n                row[i].update(nxt_j, min(dp[i][j], row[i].get_one(nxt_j)));\\n                int nxt_i = min(i+grid[i][j], m-1); \\n                col[j].update(nxt_i, min(dp[i][j], col[j].get_one(nxt_i)));\\n            }\\n        }\\n        if (dp[m-1][n-1] < INF) return dp[m-1][n-1];\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Segment Tree"
                ],
                "code": "```\\nint INF = 1e9;\\n\\nclass SegTree {\\n    int n; \\n    vector<int> t;\\npublic:\\n    SegTree(int _n) {\\n        n = _n;\\n        t.resize(2*n);\\n        for (int i = 0; i < n; i++) t[i+n] = INF;\\n        for (int i = n-1; i > 0; --i) t[i] = min(t[i*2], t[i*2+1]);\\n    }\\n    int get_range(int l, int r) {\\n        r++; \\n        if (r < l) return INF;\\n        int res = INF;\\n        for (l += n, r += n; l < r; l /= 2, r /= 2) {\\n            if (l&1) res = min(res, t[l++]);\\n            if (r&1) res = min(res, t[--r]);\\n        }\\n        return res; \\n    }\\n    int get_one(int pos) {\\n        return t[pos+n]; \\n    }\\n    void update(int pos, int val) {\\n        for (t[pos += n] = val; pos > 1; pos /= 2) t[pos/2] = min(t[pos], t[pos^1]);\\n        //pos^1 turns 2\\u2009*\\u2009i into 2\\u2009*\\u2009i\\u2009+\\u20091 and vice versa\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<SegTree> row;\\n        for (int i = 0; i < m; i++) row.push_back(SegTree(n));\\n        vector<SegTree> col;\\n        for (int j = 0; j < n; j++) col.push_back(SegTree(m)); \\n        vector<vector<int>> dp(m, vector<int>(n, INF));\\n        dp[0][0] = 1;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i][j] = min(dp[i][j], 1 + row[i].get_range(j,n-1));\\n                dp[i][j] = min(dp[i][j], 1 + col[j].get_range(i,m-1));\\n                int nxt_j = min(j+grid[i][j], n-1); \\n                row[i].update(nxt_j, min(dp[i][j], row[i].get_one(nxt_j)));\\n                int nxt_i = min(i+grid[i][j], m-1); \\n                col[j].update(nxt_i, min(dp[i][j], col[j].get_one(nxt_i)));\\n            }\\n        }\\n        if (dp[m-1][n-1] < INF) return dp[m-1][n-1];\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519323,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    const int INF = 1e9 + 7;\\n    class SegmentTree {\\n        int size;\\n        vector<int> tree;\\n        \\n        void minimize(int root, int l, int r, int left, int right, int value) {\\n            if (right < l || left > r) return;\\n            if (left >= l && right <= r) {\\n                tree[root] = min(tree[root], value);\\n                return;\\n            }\\n            int mid = (left + right) / 2;\\n            minimize(2 * root + 1, l, r, left, mid, value);\\n            minimize(2 * root + 2, l, r, mid + 1, right, value);\\n        }\\n        public:\\n        int get() {return size;}\\n        SegmentTree(int n) {\\n            size = 1;\\n            while (size < n) {\\n                size *= 2;\\n            }\\n            tree = vector<int> (2 * size - 1, (int) 1e9 + 7);\\n        }\\n        int getMinimum(int pos) {\\n            int mn = (int) 1e9 + 7;\\n            for (int i = size - 1 + pos; i > 0; i = (i - 1) / 2) {\\n                mn = min(mn, tree[i]);\\n            }\\n            mn = min(mn, tree[0]);\\n            return mn;\\n        }\\n        void minimize(int l, int r, int value) {\\n            minimize(0, l, r, 0, size - 1, value);\\n        }\\n        void init(vector<int>& v) {\\n            int n = v.size();\\n            for (int i = 0; i < n; i++) {\\n                tree[size - 1 + i] = v[i];\\n            }\\n        }\\n        \\n    };\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int> (m, INF));\\n        vector<SegmentTree> st(n, SegmentTree(m));\\n        st[0].minimize(0, 0, 1);\\n        for (int j = 0; j < m; j++) {\\n            vector<int> v(n);\\n            for (int i = 0; i < n; i++) {\\n                v[i] = dp[i][j];\\n            }\\n            SegmentTree stCol(n);\\n            stCol.init(v);\\n            for (int i = 0; i < n; i++) {\\n                dp[i][j] = min(stCol.getMinimum(i), st[i].getMinimum(j));\\n                int l = j + 1;\\n                int r = min(m - 1, j + grid[i][j]);\\n                if (l <= r) {\\n                    st[i].minimize(l, r, dp[i][j] + 1);\\n                }\\n                l = i + 1;\\n                r = min(n - 1, i + grid[i][j]);\\n                if (l <= r) {\\n                    stCol.minimize(l, r, dp[i][j] + 1);\\n                }\\n            }\\n        }\\n        return dp[n - 1][m - 1] == INF ? -1 : dp[n - 1][m - 1];\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const int INF = 1e9 + 7;\\n    class SegmentTree {\\n        int size;\\n        vector<int> tree;\\n        \\n        void minimize(int root, int l, int r, int left, int right, int value) {\\n            if (right < l || left > r) return;\\n            if (left >= l && right <= r) {\\n                tree[root] = min(tree[root], value);\\n                return;\\n            }\\n            int mid = (left + right) / 2;\\n            minimize(2 * root + 1, l, r, left, mid, value);\\n            minimize(2 * root + 2, l, r, mid + 1, right, value);\\n        }\\n        public:\\n        int get() {return size;}\\n        SegmentTree(int n) {\\n            size = 1;\\n            while (size < n) {\\n                size *= 2;\\n            }\\n            tree = vector<int> (2 * size - 1, (int) 1e9 + 7);\\n        }\\n        int getMinimum(int pos) {\\n            int mn = (int) 1e9 + 7;\\n            for (int i = size - 1 + pos; i > 0; i = (i - 1) / 2) {\\n                mn = min(mn, tree[i]);\\n            }\\n            mn = min(mn, tree[0]);\\n            return mn;\\n        }\\n        void minimize(int l, int r, int value) {\\n            minimize(0, l, r, 0, size - 1, value);\\n        }\\n        void init(vector<int>& v) {\\n            int n = v.size();\\n            for (int i = 0; i < n; i++) {\\n                tree[size - 1 + i] = v[i];\\n            }\\n        }\\n        \\n    };\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int> (m, INF));\\n        vector<SegmentTree> st(n, SegmentTree(m));\\n        st[0].minimize(0, 0, 1);\\n        for (int j = 0; j < m; j++) {\\n            vector<int> v(n);\\n            for (int i = 0; i < n; i++) {\\n                v[i] = dp[i][j];\\n            }\\n            SegmentTree stCol(n);\\n            stCol.init(v);\\n            for (int i = 0; i < n; i++) {\\n                dp[i][j] = min(stCol.getMinimum(i), st[i].getMinimum(j));\\n                int l = j + 1;\\n                int r = min(m - 1, j + grid[i][j]);\\n                if (l <= r) {\\n                    st[i].minimize(l, r, dp[i][j] + 1);\\n                }\\n                l = i + 1;\\n                r = min(n - 1, i + grid[i][j]);\\n                if (l <= r) {\\n                    stCol.minimize(l, r, dp[i][j] + 1);\\n                }\\n            }\\n        }\\n        return dp[n - 1][m - 1] == INF ? -1 : dp[n - 1][m - 1];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498430,
                "title": "java-easy-to-understand-using-treeset",
                "content": "```\\nclass Solution {\\n    record Pair(int x, int y) { }\\n    public int minimumVisitedCells(int[][] grid) {\\n        int n = grid.length, m = grid[0].length, level = 0;\\n        TreeSet<Integer> rows[] = new TreeSet[n], cols[] = new TreeSet[m];\\n        for(int i = 0; i < n; i++){\\n            rows[i] = new TreeSet<>();\\n            for(int j = 0; j < m; j++) rows[i].add(j);\\n        }\\n        for(int j = 0; j < m; j++){\\n            cols[j] = new TreeSet<>();\\n            for(int i = 0; i < n; i++) cols[j].add(i);\\n        }\\n        Queue<Pair> que = new LinkedList<>();\\n        que.add(new Pair(0, 0));\\n        while(!que.isEmpty()){\\n            int qSize = que.size();\\n            for(int p = 0; p < qSize; p++){\\n                Pair cur = que.poll();\\n                int x = cur.x, y = cur.y;\\n                if(x == n - 1 && y == m - 1) return level + 1;\\n                var rSet = rows[x].subSet(y + 1, Math.min(m, y + grid[x][y] + 1));\\n                var cSet = cols[y].subSet(x + 1, Math.min(n, x + grid[x][y] + 1));\\n                rSet.forEach(k -> que.add(new Pair(x, k)));\\n                cSet.forEach(k -> que.add(new Pair(k, y)));\\n                rSet.clear();\\n                cSet.clear();\\n            }\\n            level ++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    record Pair(int x, int y) { }\\n    public int minimumVisitedCells(int[][] grid) {\\n        int n = grid.length, m = grid[0].length, level = 0;\\n        TreeSet<Integer> rows[] = new TreeSet[n], cols[] = new TreeSet[m];\\n        for(int i = 0; i < n; i++){\\n            rows[i] = new TreeSet<>();\\n            for(int j = 0; j < m; j++) rows[i].add(j);\\n        }\\n        for(int j = 0; j < m; j++){\\n            cols[j] = new TreeSet<>();\\n            for(int i = 0; i < n; i++) cols[j].add(i);\\n        }\\n        Queue<Pair> que = new LinkedList<>();\\n        que.add(new Pair(0, 0));\\n        while(!que.isEmpty()){\\n            int qSize = que.size();\\n            for(int p = 0; p < qSize; p++){\\n                Pair cur = que.poll();\\n                int x = cur.x, y = cur.y;\\n                if(x == n - 1 && y == m - 1) return level + 1;\\n                var rSet = rows[x].subSet(y + 1, Math.min(m, y + grid[x][y] + 1));\\n                var cSet = cols[y].subSet(x + 1, Math.min(n, x + grid[x][y] + 1));\\n                rSet.forEach(k -> que.add(new Pair(x, k)));\\n                cSet.forEach(k -> que.add(new Pair(k, y)));\\n                rSet.clear();\\n                cSet.clear();\\n            }\\n            level ++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484936,
                "title": "90-tc-easy-python-solution",
                "content": "# Intuition\\nWe have to find the shortest path(minimum number of cells), that\\'s i guess enough to tell that dp or bfs will be used here. \\n\\n# Approach\\nI have used bfs here. You just have to traverse from (0, 0) to (m-1, n-1). So first code the basic bfs algorithm. \\nThen comes the time to optimize it.\\n1. We don\\'t want to look for the cells which have been already touched. That\\'s why maintaining 2 list, row and col, which will tell how far we have already reached. SO no need to look into them again and start looking onwards.\\n2. We don\\'t want to look beyond the limit, so keeping the index inside the limit, i.e., m and n (m, n = len(grid), len(grid[0])).\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        q = deque([[0, 0]])\\n        c = 0\\n        m, n = len(grid), len(grid[0])\\n        vis = set()\\n        row = [0 for _ in range(m)]\\n        col = [0 for _ in range(n)]\\n        while(q):\\n            l = len(q)\\n            c += 1\\n            for _ in range(l):\\n                i, j = q.popleft()\\n                if(i == m-1 and j == n-1):\\n                    return c\\n                val = grid[i][j]\\n\\n                # change i\\n                ii = max(col[j], i)+1\\n                while(ii < m and ii <= val+i):\\n                    if(ii == m-1 and j == n-1):\\n                        return c+1\\n                    if((ii, j) not in vis and grid[ii][j]):\\n                        q.append([ii, j])\\n                        vis.add((ii, j))\\n                        col[j] = ii\\n                    ii += 1\\n                \\n                # change j\\n                jj = max(row[i], j)+1\\n                while(jj < n and jj <= val+j):\\n                    if(i == m-1 and jj == n-1):\\n                        return c+1\\n                    if((i, jj) not in vis and grid[i][jj]):\\n                        q.append([i, jj])\\n                        vis.add((i, jj))\\n                        row[i] = jj\\n                    jj += 1\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        q = deque([[0, 0]])\\n        c = 0\\n        m, n = len(grid), len(grid[0])\\n        vis = set()\\n        row = [0 for _ in range(m)]\\n        col = [0 for _ in range(n)]\\n        while(q):\\n            l = len(q)\\n            c += 1\\n            for _ in range(l):\\n                i, j = q.popleft()\\n                if(i == m-1 and j == n-1):\\n                    return c\\n                val = grid[i][j]\\n\\n                # change i\\n                ii = max(col[j], i)+1\\n                while(ii < m and ii <= val+i):\\n                    if(ii == m-1 and j == n-1):\\n                        return c+1\\n                    if((ii, j) not in vis and grid[ii][j]):\\n                        q.append([ii, j])\\n                        vis.add((ii, j))\\n                        col[j] = ii\\n                    ii += 1\\n                \\n                # change j\\n                jj = max(row[i], j)+1\\n                while(jj < n and jj <= val+j):\\n                    if(i == m-1 and jj == n-1):\\n                        return c+1\\n                    if((i, jj) not in vis and grid[i][jj]):\\n                        q.append([i, jj])\\n                        vis.add((i, jj))\\n                        row[i] = jj\\n                    jj += 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3482617,
                "title": "easiest-solution-there-is-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nFor each query we need to understand in the end of the given operations should we have one microbe or not. So for each query I sorted all the microbes in increasing order by their power and wrote one for loop and just checked that for two adjacent microbes the following condition is met:\\nfor each l <= i < r, p[i] <= p[i + 1] <= 2 * p[i].\\n\\n# Approach and explination (TLE)\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Example for explination (TLE):\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n# Complexity (TLE)\\n\\n# Approach and explination\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Example for explination:\\n\\n# Complexity\\n\\n# Code\\n```\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3442561,
                "title": "c-why-this-solution-is-failing",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        queue<vector<ll>> pq;\\n        pq.push({0,0});\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<ll>> vis(n+5,vector<ll>(m+5,0)); \\n        vis[0][0]=0;\\n        \\n        int d=1;\\n        map<ll,ll> row,col;\\n        vis[0][0]=1;\\n        while(!pq.empty()){\\n            int sz = pq.size();\\n            \\n            for(int i=0;i<sz;i++){\\n            \\n            auto p = pq.front(); pq.pop();\\n            int x=p[0],y=p[1];\\n            if(x==n-1 && y==m-1) { return d; }  \\n            \\n            ll newRow = min(n,x + grid[x][y]+1);\\n            \\n            \\n            \\n            for(int k=row[y];k<newRow;k++)\\n                if(!vis[k][y])\\n                   { pq.push({k,y}); vis[k][y]=1;}\\n                   \\n            row[y]= max(row[y],newRow);\\n            \\n            ll newCol = min(m, y+ grid[x][y]+1);\\n            \\n            \\n            \\n            for(int k=col[x];k<newCol;k++)\\n            if(!vis[x][k]){\\n                    pq.push({x,k});\\n            vis[x][k]=1;}\\n                  \\n            col[x]= max(col[x],newCol);\\n            }\\n            d++;\\n\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        queue<vector<ll>> pq;\\n        pq.push({0,0});\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<ll>> vis(n+5,vector<ll>(m+5,0)); \\n        vis[0][0]=0;\\n        \\n        int d=1;\\n        map<ll,ll> row,col;\\n        vis[0][0]=1;\\n        while(!pq.empty()){\\n            int sz = pq.size();\\n            \\n            for(int i=0;i<sz;i++){\\n            \\n            auto p = pq.front(); pq.pop();\\n            int x=p[0],y=p[1];\\n            if(x==n-1 && y==m-1) { return d; }  \\n            \\n            ll newRow = min(n,x + grid[x][y]+1);\\n            \\n            \\n            \\n            for(int k=row[y];k<newRow;k++)\\n                if(!vis[k][y])\\n                   { pq.push({k,y}); vis[k][y]=1;}\\n                   \\n            row[y]= max(row[y],newRow);\\n            \\n            ll newCol = min(m, y+ grid[x][y]+1);\\n            \\n            \\n            \\n            for(int k=col[x];k<newCol;k++)\\n            if(!vis[x][k]){\\n                    pq.push({x,k});\\n            vis[x][k]=1;}\\n                  \\n            col[x]= max(col[x],newCol);\\n            }\\n            d++;\\n\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440487,
                "title": "bfs-passes-all-test-cases",
                "content": "Basically do bfs backwards starting from the bottom right. You need to determine which points can visit each other point. A naive way is to check each point before a given point by row and column, a better way is to use a TreeMap/SortedList, one treemap per row/column. Each treemap is indexed according to what row/column is reachable, the value of the treemaps is a list containing each cell that could reach that key. Each cell would get added to these treemaps at most twice (once possibly for the rows, and once for columns). \\n\\nYou\\'re going to want to add all cells that can be reachable to the queue for bfs from cells to the left of the current cell (or above the current cell), by querying the corresponding treemap using ceiling and adding all cells associated with it. Keep going until there are no more reachable cells to the right or below you or stop when you encounter a cell in the list of the corresponding key of the treemap that\\'s already below or to the right (in which case, let it be processed in subsequent iterations as its below or to the right to begin with and should appear later). \\n\\nOne disadvantage of this approach is that we might end up visiting cells twice as they might get added a second time if they existed twice across both the row and column treemaps (if a cell is reachable both via column and row), you can get around this by tracking which cells have been visited, but in practice, this actually made things slower for the given test cases.\\n\\nTime: O(mn*log(m)+mn*log(n)) Space: O(mn)\\n```\\nclass Solution {\\n    public int minimumVisitedCells(int[][] grid) {\\n        List<TreeMap<Integer,List<Integer>>> colList = new ArrayList<>(grid[0].length);\\n        List<TreeMap<Integer,List<Integer>>> rowList = new ArrayList<>(grid.length);\\n        for(int i=0;i<grid.length;i++) {\\n            rowList.add(new TreeMap<Integer,List<Integer>>());\\n        }\\n        for(int j=0;j<grid[0].length;j++) {\\n            colList.add(new TreeMap<Integer,List<Integer>>());\\n        }\\n        for(int i=0;i<grid.length;i++) {\\n            for(int j=0;j<grid[0].length;j++) {\\n                int lastRow = Math.min(grid[0].length-1, grid[i][j] + j);\\n                int lastCol = Math.min(grid.length-1, grid[i][j] + i);\\n                TreeMap<Integer,List<Integer>> rowMap = rowList.get(i);\\n                TreeMap<Integer,List<Integer>> colMap = colList.get(j);\\n                if(grid[i][j] == 0) {\\n                    continue;\\n                }\\n                rowMap.putIfAbsent(lastRow, new ArrayList<>());\\n                rowMap.get(lastRow).add(j);\\n                colMap.putIfAbsent(lastCol, new ArrayList<>());\\n                colMap.get(lastCol).add(i);\\n            }\\n        }\\n\\t\\t//The actual bfs routine\\n        Queue<Coordinate> queue = new LinkedList<>();\\n        queue.add(new Coordinate(grid.length-1, grid[0].length-1,1));\\n        int minVisit = -1;\\n        while(!queue.isEmpty()) {\\n            Coordinate last = queue.remove();\\n            if(last.i == 0 && last.j == 0) {\\n                minVisit = last.numVisit;\\n                break;\\n            }\\n            TreeMap<Integer,List<Integer>> rowMap = rowList.get(last.i);\\n            TreeMap<Integer,List<Integer>> colMap = colList.get(last.j);\\n            while(rowMap.ceilingEntry(last.j) != null) {\\n                Map.Entry<Integer,List<Integer>> rowEntry = rowMap.ceilingEntry(last.j);\\n                List<Integer> rights = rowEntry.getValue();\\n                boolean less = false; //Dont add to the queue if you encounter a cell that\\'s to the right of the current cell, and don\\'t remove this entry for subsequent iterations\\n                for(int right : rights) {\\n                    if(right < last.j) {\\n                        queue.add(new Coordinate(last.i, right, last.numVisit+1));\\n                    }\\n                    else if(right > last.j) {\\n                        less = true;\\n                    }\\n                }\\n                if(less) {\\n                    break;\\n                }\\n                rowMap.remove(rowEntry.getKey());\\n            }\\n            while(colMap.ceilingEntry(last.i) != null) {\\n                Map.Entry<Integer,List<Integer>> colEntry = colMap.ceilingEntry(last.i);\\n                List<Integer> downs = colEntry.getValue();\\n                boolean less = false; //Don\\'t to the queue if you encounter a cell that\\'s below the current cell, and don\\'t remove this entry for subsequent iterations\\n                for(int down : downs) {\\n                    if(down < last.i) {\\n                        queue.add(new Coordinate(down, last.j, last.numVisit+1));\\n                    }\\n                    else if(down > last.i) {\\n                        less = true;\\n                    }\\n                }\\n                if(less) {\\n                    break;\\n                }\\n                colMap.remove(colEntry.getKey());\\n            }\\n        }\\n        return minVisit;\\n    }\\n}\\nclass Coordinate {\\n    int i;\\n    int j;\\n    int numVisit;\\n    Coordinate(int i, int j, int numVisit){\\n        this.i = i;\\n        this.j = j;\\n        this.numVisit = numVisit;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumVisitedCells(int[][] grid) {\\n        List<TreeMap<Integer,List<Integer>>> colList = new ArrayList<>(grid[0].length);\\n        List<TreeMap<Integer,List<Integer>>> rowList = new ArrayList<>(grid.length);\\n        for(int i=0;i<grid.length;i++) {\\n            rowList.add(new TreeMap<Integer,List<Integer>>());\\n        }\\n        for(int j=0;j<grid[0].length;j++) {\\n            colList.add(new TreeMap<Integer,List<Integer>>());\\n        }\\n        for(int i=0;i<grid.length;i++) {\\n            for(int j=0;j<grid[0].length;j++) {\\n                int lastRow = Math.min(grid[0].length-1, grid[i][j] + j);\\n                int lastCol = Math.min(grid.length-1, grid[i][j] + i);\\n                TreeMap<Integer,List<Integer>> rowMap = rowList.get(i);\\n                TreeMap<Integer,List<Integer>> colMap = colList.get(j);\\n                if(grid[i][j] == 0) {\\n                    continue;\\n                }\\n                rowMap.putIfAbsent(lastRow, new ArrayList<>());\\n                rowMap.get(lastRow).add(j);\\n                colMap.putIfAbsent(lastCol, new ArrayList<>());\\n                colMap.get(lastCol).add(i);\\n            }\\n        }\\n\\t\\t//The actual bfs routine\\n        Queue<Coordinate> queue = new LinkedList<>();\\n        queue.add(new Coordinate(grid.length-1, grid[0].length-1,1));\\n        int minVisit = -1;\\n        while(!queue.isEmpty()) {\\n            Coordinate last = queue.remove();\\n            if(last.i == 0 && last.j == 0) {\\n                minVisit = last.numVisit;\\n                break;\\n            }\\n            TreeMap<Integer,List<Integer>> rowMap = rowList.get(last.i);\\n            TreeMap<Integer,List<Integer>> colMap = colList.get(last.j);\\n            while(rowMap.ceilingEntry(last.j) != null) {\\n                Map.Entry<Integer,List<Integer>> rowEntry = rowMap.ceilingEntry(last.j);\\n                List<Integer> rights = rowEntry.getValue();\\n                boolean less = false; //Dont add to the queue if you encounter a cell that\\'s to the right of the current cell, and don\\'t remove this entry for subsequent iterations\\n                for(int right : rights) {\\n                    if(right < last.j) {\\n                        queue.add(new Coordinate(last.i, right, last.numVisit+1));\\n                    }\\n                    else if(right > last.j) {\\n                        less = true;\\n                    }\\n                }\\n                if(less) {\\n                    break;\\n                }\\n                rowMap.remove(rowEntry.getKey());\\n            }\\n            while(colMap.ceilingEntry(last.i) != null) {\\n                Map.Entry<Integer,List<Integer>> colEntry = colMap.ceilingEntry(last.i);\\n                List<Integer> downs = colEntry.getValue();\\n                boolean less = false; //Don\\'t to the queue if you encounter a cell that\\'s below the current cell, and don\\'t remove this entry for subsequent iterations\\n                for(int down : downs) {\\n                    if(down < last.i) {\\n                        queue.add(new Coordinate(down, last.j, last.numVisit+1));\\n                    }\\n                    else if(down > last.i) {\\n                        less = true;\\n                    }\\n                }\\n                if(less) {\\n                    break;\\n                }\\n                colMap.remove(colEntry.getKey());\\n            }\\n        }\\n        return minVisit;\\n    }\\n}\\nclass Coordinate {\\n    int i;\\n    int j;\\n    int numVisit;\\n    Coordinate(int i, int j, int numVisit){\\n        this.i = i;\\n        this.j = j;\\n        this.numVisit = numVisit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432467,
                "title": "awesome-stacks",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        vector<stack<pair<int, int> > > ts(grid[0].size(), stack<pair<int, int> >());\\n        stack<pair<int, int> > temp;\\n        temp.push({1, grid[0].size() - 1});\\n        ts[grid[0].size() - 1].push({1, grid.size() - 1});\\n        int x, y, d = 1;\\n        pair<int, int> t;\\n        for(int i = grid[0].size() - 2; i >= 0; i--){\\n            x = i + grid[grid.size() - 1][i];\\n            if(x < temp.top().second) {\\n                d = - 1;\\n                continue;\\n            }\\n            while(!temp.empty() && temp.top().second <= x) {\\n                t = temp.top();\\n                temp.pop();\\n            }\\n            temp.push(t); \\n            d = t.first + 1;\\n            temp.push({d, i});\\n            ts[i].push({d, grid.size() - 1});\\n        }\\n        for(int i = grid.size() - 2; i >= 0; i--){\\n            temp = *(new stack<pair<int, int> >);\\n            x = i + grid[i][grid[0].size() - 1];\\n            if(x < ts[grid[0].size() - 1].top().second){\\n                d = -1;\\n            }\\n            else{\\n                while(!ts[grid[0].size() - 1].empty() && ts[grid[0].size() - 1].top().second <= x){\\n                    t = ts[grid[0].size() - 1].top();\\n                    ts[grid[0].size() - 1].pop();\\n                }\\n                ts[grid[0].size() - 1].push(t);\\n                d = t.first + 1;\\n                temp.push({d, grid[0].size() - 1});\\n                ts[grid[0].size() - 1].push({d, i});\\n            }\\n            for(int j = grid[0].size() - 2; j >= 0; j--){\\n                x = j + grid[i][j];\\n                y = i + grid[i][j];\\n                d = -1;\\n                if(!temp.empty()){\\n                    if(x >= temp.top().second) {\\n                        while(!temp.empty() && temp.top().second <= x) {\\n                            t = temp.top();\\n                            temp.pop();\\n                        }\\n                        temp.push(t);\\n                        d = t.first + 1;\\n                    }\\n                }\\n                if(!ts[j].empty()){\\n                    if(y >= ts[j].top().second) {\\n                        while(!ts[j].empty() && ts[j].top().second <= y) {\\n                            t = ts[j].top();\\n                            ts[j].pop();\\n                        }\\n                        ts[j].push(t);\\n                        if(d == -1) d = t.first + 1;\\n                        else d = min(d, t.first + 1);\\n                    }\\n                }\\n                if(d != -1){\\n                    while(!temp.empty() && temp.top().first >= d) temp.pop();\\n                    while(!ts[j].empty() && ts[j].top().first >= d) ts[j].pop();\\n                    temp.push({d, j});\\n                    ts[j].push({d, i});\\n                }\\n            }\\n        } \\n        return d;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        vector<stack<pair<int, int> > > ts(grid[0].size(), stack<pair<int, int> >());\\n        stack<pair<int, int> > temp;\\n        temp.push({1, grid[0].size() - 1});\\n        ts[grid[0].size() - 1].push({1, grid.size() - 1});\\n        int x, y, d = 1;\\n        pair<int, int> t;\\n        for(int i = grid[0].size() - 2; i >= 0; i--){\\n            x = i + grid[grid.size() - 1][i];\\n            if(x < temp.top().second) {\\n                d = - 1;\\n                continue;\\n            }\\n            while(!temp.empty() && temp.top().second <= x) {\\n                t = temp.top();\\n                temp.pop();\\n            }\\n            temp.push(t); \\n            d = t.first + 1;\\n            temp.push({d, i});\\n            ts[i].push({d, grid.size() - 1});\\n        }\\n        for(int i = grid.size() - 2; i >= 0; i--){\\n            temp = *(new stack<pair<int, int> >);\\n            x = i + grid[i][grid[0].size() - 1];\\n            if(x < ts[grid[0].size() - 1].top().second){\\n                d = -1;\\n            }\\n            else{\\n                while(!ts[grid[0].size() - 1].empty() && ts[grid[0].size() - 1].top().second <= x){\\n                    t = ts[grid[0].size() - 1].top();\\n                    ts[grid[0].size() - 1].pop();\\n                }\\n                ts[grid[0].size() - 1].push(t);\\n                d = t.first + 1;\\n                temp.push({d, grid[0].size() - 1});\\n                ts[grid[0].size() - 1].push({d, i});\\n            }\\n            for(int j = grid[0].size() - 2; j >= 0; j--){\\n                x = j + grid[i][j];\\n                y = i + grid[i][j];\\n                d = -1;\\n                if(!temp.empty()){\\n                    if(x >= temp.top().second) {\\n                        while(!temp.empty() && temp.top().second <= x) {\\n                            t = temp.top();\\n                            temp.pop();\\n                        }\\n                        temp.push(t);\\n                        d = t.first + 1;\\n                    }\\n                }\\n                if(!ts[j].empty()){\\n                    if(y >= ts[j].top().second) {\\n                        while(!ts[j].empty() && ts[j].top().second <= y) {\\n                            t = ts[j].top();\\n                            ts[j].pop();\\n                        }\\n                        ts[j].push(t);\\n                        if(d == -1) d = t.first + 1;\\n                        else d = min(d, t.first + 1);\\n                    }\\n                }\\n                if(d != -1){\\n                    while(!temp.empty() && temp.top().first >= d) temp.pop();\\n                    while(!ts[j].empty() && ts[j].top().first >= d) ts[j].pop();\\n                    temp.push({d, j});\\n                    ts[j].push({d, i});\\n                }\\n            }\\n        } \\n        return d;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426964,
                "title": "c-solution",
                "content": "```\\ntypedef pair<int,int> pp;\\n\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid){\\n\\n        // unweighted graph all edges have equal weight so i can use BFS\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        vector<set<int>> cnv(m); // column not visited\\n        vector<set<int>> rnv(n); // rows not visited\\n        \\n        for(int i=0;i<m;++i){\\n            for(int j=0;j<n;++j){\\n               cnv[i].insert(j);\\n               rnv[j].insert(i);\\n            }\\n        }\\n        \\n        vector<vector<bool>> visited(m,vector<bool> (n,false));\\n        \\n        pp t;\\n        int r,c,jump;\\n        queue<pp> q;\\n        q.push({0,0});\\n        visited[0][0]=true;\\n        int steps=1;\\n        \\n        while(!q.empty()){\\n        \\n            int s=q.size();\\n            \\n            for(int i=0;i<s;++i){\\n\\n               r=q.front().first;\\n               c=q.front().second;\\n               q.pop(); \\n               jump=grid[r][c];\\n             \\n               if(r==m-1 && c==n-1) return steps;\\n                 \\n               vector<int> erased;\\n                \\n                for(auto itr=rnv[c].lower_bound(r+1);      // pushing downward\\n                         itr!=rnv[c].end() && *itr<=min(r+jump,m-1);\\n                         itr++){\\n        \\n                      erased.push_back(*itr);\\n                      q.push({*itr,c});\\n                }\\n                \\n                for(auto e:erased){\\n                    rnv[c].erase(e);\\n                    cnv[e].erase(c);\\n                }\\n             \\n               // for(int k=r+1;k<=min(r+jump,m-1);++k){ // pushing downward\\n               //     if(!visited[k][c]){\\n               //         visited[k][c]=true;\\n               //         q.push({k,c});\\n               //     }\\n               // }  \\n            \\n               erased.clear();\\n               for(auto itr=cnv[r].lower_bound(c+1);    // pushing rightward \\n                         itr!=cnv[r].end() && *itr<=min(c+jump,n-1);\\n                         itr++){\\n        \\n                      erased.push_back(*itr);\\n                      q.push({r,*itr});\\n                }  \\n            \\n            for(auto e:erased){\\n                    cnv[r].erase(e);\\n                    rnv[e].erase(r);\\n                }\\n                 // for(int k=c+1;k<=min(c+jump,n-1);++k){ // pushing rightward\\n                 //       if(!visited[r][k]){\\n                 //           visited[r][k]=true;\\n                 //           q.push({r,k});\\n                 //       }\\n                 //   }   \\n                }\\n            steps++;\\n        }\\n        return -1;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\ntypedef pair<int,int> pp;\\n\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid){\\n\\n        // unweighted graph all edges have equal weight so i can use BFS\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        vector<set<int>> cnv(m); // column not visited\\n        vector<set<int>> rnv(n); // rows not visited\\n        \\n        for(int i=0;i<m;++i){\\n            for(int j=0;j<n;++j){\\n               cnv[i].insert(j);\\n               rnv[j].insert(i);\\n            }\\n        }\\n        \\n        vector<vector<bool>> visited(m,vector<bool> (n,false));\\n        \\n        pp t;\\n        int r,c,jump;\\n        queue<pp> q;\\n        q.push({0,0});\\n        visited[0][0]=true;\\n        int steps=1;\\n        \\n        while(!q.empty()){\\n        \\n            int s=q.size();\\n            \\n            for(int i=0;i<s;++i){\\n\\n               r=q.front().first;\\n               c=q.front().second;\\n               q.pop(); \\n               jump=grid[r][c];\\n             \\n               if(r==m-1 && c==n-1) return steps;\\n                 \\n               vector<int> erased;\\n                \\n                for(auto itr=rnv[c].lower_bound(r+1);      // pushing downward\\n                         itr!=rnv[c].end() && *itr<=min(r+jump,m-1);\\n                         itr++){\\n        \\n                      erased.push_back(*itr);\\n                      q.push({*itr,c});\\n                }\\n                \\n                for(auto e:erased){\\n                    rnv[c].erase(e);\\n                    cnv[e].erase(c);\\n                }\\n             \\n               // for(int k=r+1;k<=min(r+jump,m-1);++k){ // pushing downward\\n               //     if(!visited[k][c]){\\n               //         visited[k][c]=true;\\n               //         q.push({k,c});\\n               //     }\\n               // }  \\n            \\n               erased.clear();\\n               for(auto itr=cnv[r].lower_bound(c+1);    // pushing rightward \\n                         itr!=cnv[r].end() && *itr<=min(c+jump,n-1);\\n                         itr++){\\n        \\n                      erased.push_back(*itr);\\n                      q.push({r,*itr});\\n                }  \\n            \\n            for(auto e:erased){\\n                    cnv[r].erase(e);\\n                    rnv[e].erase(r);\\n                }\\n                 // for(int k=c+1;k<=min(c+jump,n-1);++k){ // pushing rightward\\n                 //       if(!visited[r][k]){\\n                 //           visited[r][k]=true;\\n                 //           q.push({r,k});\\n                 //       }\\n                 //   }   \\n                }\\n            steps++;\\n        }\\n        return -1;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426205,
                "title": "greedy-use-bfs-c",
                "content": "# Please Upvote me.... if my solution is helpful for you!\\n\\n# Complexity\\n- Time complexity: m*n*log(mn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: m*n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int minimumVisitedCells(vector<vector<int>>& g) {\\n        int r = g.size(), c = g[0].size();\\n        vector<set<int>> rem_r(c), rem_c(r);\\n        for(int i = 0; i < r; i++) {\\n            for(int j = 0; j < c; j++) {\\n                rem_r[j].insert(i);\\n                rem_c[i].insert(j);\\n            }\\n        }\\n        vector<vector<int>> dist(r, vector<int>(c, -1));\\n        dist[0][0] = 1;\\n        queue<pair<int,int>> q;\\n        q.push({0, 0});\\n        while(!q.empty()) {\\n            auto pr = q.front();\\n            q.pop();\\n            int rr = pr.first;\\n            int cc = pr.second;\\n            vector<int>ec;\\n            for(\\n                auto it = rem_c[rr].lower_bound(cc + 1);\\n                it != rem_c[rr].end() && it != rem_c[rr].upper_bound(cc + g[rr][cc]);\\n                it++\\n            ){\\n                dist[rr][*it] = dist[rr][cc] + 1;\\n                q.push({rr, *it});\\n                ec.push_back(*it);\\n            }\\n            for(auto x : ec) {\\n                rem_c[rr].erase(x);\\n                rem_r[x].erase(rr);\\n            }\\n            \\n            vector<int>er;\\n            for(\\n                auto it = rem_r[cc].lower_bound(rr + 1);\\n                it != rem_r[cc].end() && it != rem_r[cc].upper_bound(rr + g[rr][cc]);\\n                it++\\n            ){\\n                dist[*it][cc] = dist[rr][cc] + 1;\\n                q.push({*it, cc});\\n                er.push_back(*it);\\n            }\\n            for(auto x : er) {\\n                rem_r[cc].erase(x);\\n                rem_c[x].erase(cc);\\n            }\\n            \\n        }\\n        return dist[r - 1][c - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minimumVisitedCells(vector<vector<int>>& g) {\\n        int r = g.size(), c = g[0].size();\\n        vector<set<int>> rem_r(c), rem_c(r);\\n        for(int i = 0; i < r; i++) {\\n            for(int j = 0; j < c; j++) {\\n                rem_r[j].insert(i);\\n                rem_c[i].insert(j);\\n            }\\n        }\\n        vector<vector<int>> dist(r, vector<int>(c, -1));\\n        dist[0][0] = 1;\\n        queue<pair<int,int>> q;\\n        q.push({0, 0});\\n        while(!q.empty()) {\\n            auto pr = q.front();\\n            q.pop();\\n            int rr = pr.first;\\n            int cc = pr.second;\\n            vector<int>ec;\\n            for(\\n                auto it = rem_c[rr].lower_bound(cc + 1);\\n                it != rem_c[rr].end() && it != rem_c[rr].upper_bound(cc + g[rr][cc]);\\n                it++\\n            ){\\n                dist[rr][*it] = dist[rr][cc] + 1;\\n                q.push({rr, *it});\\n                ec.push_back(*it);\\n            }\\n            for(auto x : ec) {\\n                rem_c[rr].erase(x);\\n                rem_r[x].erase(rr);\\n            }\\n            \\n            vector<int>er;\\n            for(\\n                auto it = rem_r[cc].lower_bound(rr + 1);\\n                it != rem_r[cc].end() && it != rem_r[cc].upper_bound(rr + g[rr][cc]);\\n                it++\\n            ){\\n                dist[*it][cc] = dist[rr][cc] + 1;\\n                q.push({*it, cc});\\n                er.push_back(*it);\\n            }\\n            for(auto x : er) {\\n                rem_r[cc].erase(x);\\n                rem_c[x].erase(cc);\\n            }\\n            \\n        }\\n        return dist[r - 1][c - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424740,
                "title": "super-hard-solution-using-set-and-bfs-o-n-m-log-n-m",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. BFS\\n2. Using Set data structure to handle visited cells\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Numbering each cell in a matrix in increasing order in row and column and store it in 2D matrix (say Value[][]).\\n2. Create set for each N rows and M columns.\\n3. Start BFS from cell {0, 0}.\\n4. Use set for current row and column to visit each cell in row and column with value more than current cell value using Value[][] matrix.\\n5. Remove the visited cell from both row and column set.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*m*log(n+m))$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n*m)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        ios_base::sync_with_stdio(0);\\n        int n=grid.size();\\n        int m=grid[0].size();\\n\\n        if (n==1 && m==1)\\n            return 1;\\n\\n        int cnt=0;\\n        vector<set<int>> row(n);\\n        vector<set<int>> col(m);\\n        vector<vector<int>> visited(n, vector<int>(m, 0));\\n        vector<vector<int>> value(n, vector<int>(m, 0));\\n\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                value[i][j] = ++cnt;\\n                visited[i][j] = 0;\\n            }\\n        }\\n\\n        vector<pair<int, int>> coord(cnt+1);\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                row[i].insert(value[i][j]);\\n                col[j].insert(value[i][j]);\\n                coord[value[i][j]] = {i, j};\\n            }\\n        }\\n\\n        queue<pair<int, int>> bfs;\\n        bfs.push({0, 0});\\n        visited[0][0] = 1;\\n        visited[n-1][m-1] = -1;\\n\\n        while(!bfs.empty()) {\\n            pair<int, int> p = bfs.front();\\n            bfs.pop();\\n            int x = p.first;\\n            int y = p.second;\\n            if (x==n-1 && y==m-1){\\n                return visited[n-1][m-1];\\n            }\\n\\n            int val = grid[x][y];\\n            // Iterate in row\\n            while(!row[x].empty()) {\\n                auto itr = row[x].upper_bound(value[x][y]);\\n                if (itr == row[x].end())\\n                    break;\\n                int x1 = coord[*itr].first;\\n                int y1 = coord[*itr].second;\\n                // Check if [x1, y1] in a row is reachable from [x, y].\\n                if (val + y >= y1) {\\n                    visited[x1][y1] = 1 + visited[x][y];\\n                    bfs.push({x1, y1});\\n                    row[x].erase(itr);\\n                    auto it = col[y1].find(value[x1][y1]);\\n                    if(it != col[y1].end())\\n                        col[y1].erase(it);\\n                    continue;\\n                }\\n                break;\\n            }\\n\\n            // Iterate in col\\n            while(!col[y].empty()) {\\n                auto itr = col[y].upper_bound(value[x][y]);\\n                if (itr == col[y].end())\\n                    break;\\n                int x1 = coord[*itr].first;\\n                int y1 = coord[*itr].second;\\n                // Check if [x1, y1] in a col is reachable from [x, y].\\n                if (val + x >= x1) {\\n                    visited[x1][y1] = 1 + visited[x][y];\\n                    bfs.push({x1, y1});\\n                    col[y].erase(itr);\\n                    auto it = row[x1].find(value[x1][y1]);\\n                    if(it != row[x1].end())\\n                        row[x1].erase(it);\\n                    continue;\\n                }\\n                break;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        ios_base::sync_with_stdio(0);\\n        int n=grid.size();\\n        int m=grid[0].size();\\n\\n        if (n==1 && m==1)\\n            return 1;\\n\\n        int cnt=0;\\n        vector<set<int>> row(n);\\n        vector<set<int>> col(m);\\n        vector<vector<int>> visited(n, vector<int>(m, 0));\\n        vector<vector<int>> value(n, vector<int>(m, 0));\\n\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                value[i][j] = ++cnt;\\n                visited[i][j] = 0;\\n            }\\n        }\\n\\n        vector<pair<int, int>> coord(cnt+1);\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                row[i].insert(value[i][j]);\\n                col[j].insert(value[i][j]);\\n                coord[value[i][j]] = {i, j};\\n            }\\n        }\\n\\n        queue<pair<int, int>> bfs;\\n        bfs.push({0, 0});\\n        visited[0][0] = 1;\\n        visited[n-1][m-1] = -1;\\n\\n        while(!bfs.empty()) {\\n            pair<int, int> p = bfs.front();\\n            bfs.pop();\\n            int x = p.first;\\n            int y = p.second;\\n            if (x==n-1 && y==m-1){\\n                return visited[n-1][m-1];\\n            }\\n\\n            int val = grid[x][y];\\n            // Iterate in row\\n            while(!row[x].empty()) {\\n                auto itr = row[x].upper_bound(value[x][y]);\\n                if (itr == row[x].end())\\n                    break;\\n                int x1 = coord[*itr].first;\\n                int y1 = coord[*itr].second;\\n                // Check if [x1, y1] in a row is reachable from [x, y].\\n                if (val + y >= y1) {\\n                    visited[x1][y1] = 1 + visited[x][y];\\n                    bfs.push({x1, y1});\\n                    row[x].erase(itr);\\n                    auto it = col[y1].find(value[x1][y1]);\\n                    if(it != col[y1].end())\\n                        col[y1].erase(it);\\n                    continue;\\n                }\\n                break;\\n            }\\n\\n            // Iterate in col\\n            while(!col[y].empty()) {\\n                auto itr = col[y].upper_bound(value[x][y]);\\n                if (itr == col[y].end())\\n                    break;\\n                int x1 = coord[*itr].first;\\n                int y1 = coord[*itr].second;\\n                // Check if [x1, y1] in a col is reachable from [x, y].\\n                if (val + x >= x1) {\\n                    visited[x1][y1] = 1 + visited[x][y];\\n                    bfs.push({x1, y1});\\n                    col[y].erase(itr);\\n                    auto it = row[x1].find(value[x1][y1]);\\n                    if(it != row[x1].end())\\n                        row[x1].erase(it);\\n                    continue;\\n                }\\n                break;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417905,
                "title": "bfs-and-treeset-o-m-n-log-m-n-time-o-m-n-space-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are given an m x n integer matrix \\'grid\\'. We need to find the minimum number of cells we need to visit to reach the bottom-right cell (m-1, n-1) by following the movement rules provided. If there is no valid path, we should return -1. To achieve this, we can use BFS (Breadth-First Search) to explore the possible paths while keeping track of the visited cells. TreeSet is used to efficiently query the next valid cell index and avoid reconsidering the cells that have already been visited, which significantly reduces the time usage.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize rowSets and colSets with TreeSets for all rows and columns. TreeSets allow efficient querying for the ceiling value and avoiding reconsideration of visited cells.\\n1. Initialize distance matrix with the number of cells visited so far.\\n1. Start BFS from the top-left cell (0, 0) and explore rightward and downward movements.\\n1. For each explored cell, update the rowSets and colSets.\\n1. Continue BFS until the queue is empty.\\n1. If the bottom-right cell is reached, return the distance value for that cell. Otherwise, return -1.\\n# Complexity\\n- Time complexity: O(m * n * log(m * n)), where m is the number of rows and n is the number of columns.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m * n), as we use extra space for distance matrix, rowSets, colSets, and the BFS queue.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumVisitedCells(int[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        if (row == 1 && col == 1) return 1;\\n       // Initialize rowSets and colSets with TreeSets to efficiently query the next valid cell index and avoid reconsidering visited cells\\n    \\n        TreeSet<Integer>[] rowSets = new TreeSet[row];\\n        TreeSet<Integer>[] colSets = new TreeSet[col];\\n        for (int i = 0; i < row; i++) {\\n            rowSets[i] = new TreeSet<>();\\n            for (int j = 0; j < col; j++) {\\n                rowSets[i].add(j);\\n            }\\n        }\\n        for (int i = 0; i < col; i++) {\\n            colSets[i] = new TreeSet<>();\\n            for (int j = 0; j < row; j++) {\\n                colSets[i].add(j);\\n            } \\n        }\\n        // Initialize the distance matrix and BFS queue\\n        int[][] distance = new int[row][col];\\n        distance[0][0] = 1;\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0, 0});\\n\\n        // BFS traversal\\n        while (!q.isEmpty()) {\\n          int[] cur = q.remove();\\n          int r = cur[0];\\n          int c = cur[1];\\n          // If the bottom-right cell is reached, return the distance value\\n          if (r == row - 1 && c == col - 1) return distance[r][c];\\n          int d = distance[r][c];\\n\\n          // Explore rightward movements\\n          Integer k = rowSets[r].ceiling(c + 1);\\n          while (k != null && k <= c + grid[r][c]) {\\n                distance[r][k] = d + 1;\\n                q.add(new int[]{r, k});\\n                rowSets[r].remove(k);\\n                colSets[k].remove(r);\\n                k = rowSets[r].ceiling(c + 1);\\n          }\\n          // Explore downward movements\\n          k = colSets[c].ceiling(r + 1);\\n          while (k != null && k <= r + grid[r][c]) {\\n              distance[k][c] = d + 1;\\n              q.add(new int[]{k, c});\\n              rowSets[k].remove(c);\\n              colSets[c].remove(k);\\n              k = colSets[c].ceiling(r + 1);\\n          }\\n        }\\n        return -1;\\n    }\\n}\\n```\\nTo summarize, we use BFS to traverse the possible paths in the matrix while keeping track of the visited cells. We use TreeSets to efficiently query the next valid cell index and avoid reconsidering the cells that have already been visited, which reduces the time complexity.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumVisitedCells(int[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        if (row == 1 && col == 1) return 1;\\n       // Initialize rowSets and colSets with TreeSets to efficiently query the next valid cell index and avoid reconsidering visited cells\\n    \\n        TreeSet<Integer>[] rowSets = new TreeSet[row];\\n        TreeSet<Integer>[] colSets = new TreeSet[col];\\n        for (int i = 0; i < row; i++) {\\n            rowSets[i] = new TreeSet<>();\\n            for (int j = 0; j < col; j++) {\\n                rowSets[i].add(j);\\n            }\\n        }\\n        for (int i = 0; i < col; i++) {\\n            colSets[i] = new TreeSet<>();\\n            for (int j = 0; j < row; j++) {\\n                colSets[i].add(j);\\n            } \\n        }\\n        // Initialize the distance matrix and BFS queue\\n        int[][] distance = new int[row][col];\\n        distance[0][0] = 1;\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0, 0});\\n\\n        // BFS traversal\\n        while (!q.isEmpty()) {\\n          int[] cur = q.remove();\\n          int r = cur[0];\\n          int c = cur[1];\\n          // If the bottom-right cell is reached, return the distance value\\n          if (r == row - 1 && c == col - 1) return distance[r][c];\\n          int d = distance[r][c];\\n\\n          // Explore rightward movements\\n          Integer k = rowSets[r].ceiling(c + 1);\\n          while (k != null && k <= c + grid[r][c]) {\\n                distance[r][k] = d + 1;\\n                q.add(new int[]{r, k});\\n                rowSets[r].remove(k);\\n                colSets[k].remove(r);\\n                k = rowSets[r].ceiling(c + 1);\\n          }\\n          // Explore downward movements\\n          k = colSets[c].ceiling(r + 1);\\n          while (k != null && k <= r + grid[r][c]) {\\n              distance[k][c] = d + 1;\\n              q.add(new int[]{k, c});\\n              rowSets[k].remove(c);\\n              colSets[c].remove(k);\\n              k = colSets[c].ceiling(r + 1);\\n          }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3413799,
                "title": "easy-to-understand-c-solution-bottom-up-dp-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nstruct Node {\\n    int x; \\n    int y;\\n    Node(int i, int j) : x(i), y(j) {}\\n    friend bool operator<(const Node& n1, const Node& n2) {\\n        return n1.x < n2.x;\\n    }\\n};\\n\\n\\nint minimumVisitedCells(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\\n        for(int j=0; j<=n; ++j) {\\n            dp[0][j] = -1;\\n        }\\n        for(int i=0; i<=m; ++i) {\\n            dp[i][0] = -1;\\n        }\\n\\n        std::vector<priority_queue<pair<int, Node>, vector<pair<int, Node>>, greater<pair<int, Node>>>> vq_h;\\n        std::vector<priority_queue<pair<int, Node>, vector<pair<int, Node>>, greater<pair<int, Node>>>> vq_v;\\n        for(int i=0; i<m; ++i) {\\n            priority_queue<pair<int, Node>, vector<pair<int, Node>>, greater<pair<int, Node>>> q;\\n            vq_h.push_back(q);\\n        }\\n        for(int i=0; i<n; ++i) {\\n            priority_queue<pair<int, Node>, vector<pair<int, Node>>, greater<pair<int, Node>>> q;\\n            vq_v.push_back(q);\\n        }\\n\\n        for(int i=1; i<=m; ++i) {\\n            for(int j=1; j<=n; ++j) {\\n                if(i==1 && j==1) {\\n                    dp[i][j] =  1;\\n                    vq_h[i-1].push({1, Node(i, j)});\\n                    vq_v[j-1].push({1, Node(i, j)});\\n                } else {\\n                    dp[i][j] = INT_MAX;\\n\\n                    int res = INT_MAX;\\n                    // Check horizontal\\n                    while(!vq_h[i-1].empty()) {\\n                        auto top = vq_h[i-1].top();\\n                        auto x = top.second.x;\\n                        auto y = top.second.y;\\n                        auto dist = grid[x-1][y-1]+y;\\n                        if(dist<j) {\\n                            vq_h[i-1].pop();\\n                        } else {\\n                            res = std::min(res, top.first);\\n                            break;\\n                        }\\n                    }\\n\\n                    // Check vertical\\n                    while(!vq_v[j-1].empty()) {\\n                        auto top = vq_v[j-1].top();\\n                        auto x = top.second.x;\\n                        auto y = top.second.y;\\n                        auto dist = grid[x-1][y-1]+x;\\n                        if(dist<i) {\\n                            vq_v[j-1].pop();\\n                        } else {\\n                            res = std::min(res, top.first);\\n                            break;\\n                        }\\n                    }\\n\\n                    dp[i][j] = std::min(dp[i][j], res);\\n                    if(dp[i][j]==INT_MAX) { \\n                        dp[i][j] = -1;\\n                    } else {\\n                        dp[i][j]++;\\n                        vq_h[i-1].push({dp[i][j], Node(i,j)});\\n                        vq_v[j-1].push({dp[i][j], Node(i,j)});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nstruct Node {\\n    int x; \\n    int y;\\n    Node(int i, int j) : x(i), y(j) {}\\n    friend bool operator<(const Node& n1, const Node& n2) {\\n        return n1.x < n2.x;\\n    }\\n};\\n\\n\\nint minimumVisitedCells(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\\n        for(int j=0; j<=n; ++j) {\\n            dp[0][j] = -1;\\n        }\\n        for(int i=0; i<=m; ++i) {\\n            dp[i][0] = -1;\\n        }\\n\\n        std::vector<priority_queue<pair<int, Node>, vector<pair<int, Node>>, greater<pair<int, Node>>>> vq_h;\\n        std::vector<priority_queue<pair<int, Node>, vector<pair<int, Node>>, greater<pair<int, Node>>>> vq_v;\\n        for(int i=0; i<m; ++i) {\\n            priority_queue<pair<int, Node>, vector<pair<int, Node>>, greater<pair<int, Node>>> q;\\n            vq_h.push_back(q);\\n        }\\n        for(int i=0; i<n; ++i) {\\n            priority_queue<pair<int, Node>, vector<pair<int, Node>>, greater<pair<int, Node>>> q;\\n            vq_v.push_back(q);\\n        }\\n\\n        for(int i=1; i<=m; ++i) {\\n            for(int j=1; j<=n; ++j) {\\n                if(i==1 && j==1) {\\n                    dp[i][j] =  1;\\n                    vq_h[i-1].push({1, Node(i, j)});\\n                    vq_v[j-1].push({1, Node(i, j)});\\n                } else {\\n                    dp[i][j] = INT_MAX;\\n\\n                    int res = INT_MAX;\\n                    // Check horizontal\\n                    while(!vq_h[i-1].empty()) {\\n                        auto top = vq_h[i-1].top();\\n                        auto x = top.second.x;\\n                        auto y = top.second.y;\\n                        auto dist = grid[x-1][y-1]+y;\\n                        if(dist<j) {\\n                            vq_h[i-1].pop();\\n                        } else {\\n                            res = std::min(res, top.first);\\n                            break;\\n                        }\\n                    }\\n\\n                    // Check vertical\\n                    while(!vq_v[j-1].empty()) {\\n                        auto top = vq_v[j-1].top();\\n                        auto x = top.second.x;\\n                        auto y = top.second.y;\\n                        auto dist = grid[x-1][y-1]+x;\\n                        if(dist<i) {\\n                            vq_v[j-1].pop();\\n                        } else {\\n                            res = std::min(res, top.first);\\n                            break;\\n                        }\\n                    }\\n\\n                    dp[i][j] = std::min(dp[i][j], res);\\n                    if(dp[i][j]==INT_MAX) { \\n                        dp[i][j] = -1;\\n                    } else {\\n                        dp[i][j]++;\\n                        vq_h[i-1].push({dp[i][j], Node(i,j)});\\n                        vq_v[j-1].push({dp[i][j], Node(i,j)});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3410540,
                "title": "two-solutions",
                "content": "\\n# Code\\n```\\nint minimumVisitedCells(vector<vector<int>>& grid) \\n{\\n    int m = grid.size(), n = grid[0].size();\\n    vector<vector<int>> dCol(m, vector<int>(n, 1e6));\\n    dCol[0][0] = 1;\\n    int d = 1e6;\\n    for (int i = 0; i < m; ++i) \\n    {\\n        vector<int> dRow(n, 1e6);\\n        for (int j = 0; j < n; ++j) \\n        {\\n            d = min(dCol[i][j], dRow[j]);\\n            for (int x = min(grid[i][j] + i, m-1); x > i && dCol[x][j] > d; --x)\\n                dCol[x][j] = d + 1;\\n            for (int x = min(grid[i][j] + j, n-1); x > j && dRow[x] > d; --x) \\n                dRow[x] = d + 1;\\n        }\\n    }\\n    return d == 1e6 ? -1 : d;\\n}\\n\\n\\nint minimumVisitedCells7(vector<vector<int>>& grid) \\n{\\n    const int inf = 99999999;\\n    int m = grid.size();\\n    int n = grid[0].size();\\n    int dist = inf;\\n    vector<priority_queue<pair<int, int>, vector<pair<int,int>>, greater<pair<int,int>>>> colPq(n);\\n    colPq[0].push({0, 0});\\n    for(int i=0; i<m; i++)\\n    {\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> rowPq;\\n        for(int j=0; j<n; j++)\\n        {\\n            int colBestVal = inf;\\n            while(colPq[j].size())\\n            {\\n                const pair<int,int> &cur = colPq[j].top();\\n                if(cur.second < i)\\n                    colPq[j].pop();\\n                else\\n                {\\n                    colBestVal = cur.first + 1;\\n                    break;\\n                }\\n            }\\n            int rowBestVal = inf;\\n            while(rowPq.size())\\n            {\\n                const pair<int,int> &cur = rowPq.top();\\n                if(cur.second < j)\\n                    rowPq.pop();\\n                else\\n                {\\n                    rowBestVal = cur.first + 1;\\n                    break;\\n                }\\n            }\\n            dist = min(colBestVal, rowBestVal);\\n            if(dist < inf)\\n            {\\n                colPq[j].push({dist, i+grid[i][j]});\\n                rowPq.push({dist, j+grid[i][j]});\\n            }\\n        }\\n    }\\n    return dist == inf ? -1 : dist;\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint minimumVisitedCells(vector<vector<int>>& grid) \\n{\\n    int m = grid.size(), n = grid[0].size();\\n    vector<vector<int>> dCol(m, vector<int>(n, 1e6));\\n    dCol[0][0] = 1;\\n    int d = 1e6;\\n    for (int i = 0; i < m; ++i) \\n    {\\n        vector<int> dRow(n, 1e6);\\n        for (int j = 0; j < n; ++j) \\n        {\\n            d = min(dCol[i][j], dRow[j]);\\n            for (int x = min(grid[i][j] + i, m-1); x > i && dCol[x][j] > d; --x)\\n                dCol[x][j] = d + 1;\\n            for (int x = min(grid[i][j] + j, n-1); x > j && dRow[x] > d; --x) \\n                dRow[x] = d + 1;\\n        }\\n    }\\n    return d == 1e6 ? -1 : d;\\n}\\n\\n\\nint minimumVisitedCells7(vector<vector<int>>& grid) \\n{\\n    const int inf = 99999999;\\n    int m = grid.size();\\n    int n = grid[0].size();\\n    int dist = inf;\\n    vector<priority_queue<pair<int, int>, vector<pair<int,int>>, greater<pair<int,int>>>> colPq(n);\\n    colPq[0].push({0, 0});\\n    for(int i=0; i<m; i++)\\n    {\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> rowPq;\\n        for(int j=0; j<n; j++)\\n        {\\n            int colBestVal = inf;\\n            while(colPq[j].size())\\n            {\\n                const pair<int,int> &cur = colPq[j].top();\\n                if(cur.second < i)\\n                    colPq[j].pop();\\n                else\\n                {\\n                    colBestVal = cur.first + 1;\\n                    break;\\n                }\\n            }\\n            int rowBestVal = inf;\\n            while(rowPq.size())\\n            {\\n                const pair<int,int> &cur = rowPq.top();\\n                if(cur.second < j)\\n                    rowPq.pop();\\n                else\\n                {\\n                    rowBestVal = cur.first + 1;\\n                    break;\\n                }\\n            }\\n            dist = min(colBestVal, rowBestVal);\\n            if(dist < inf)\\n            {\\n                colPq[j].push({dist, i+grid[i][j]});\\n                rowPq.push({dist, j+grid[i][j]});\\n            }\\n        }\\n    }\\n    return dist == inf ? -1 : dist;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3407084,
                "title": "c-union-find",
                "content": "This problem is similar to last weeks contest 2612\\n\\nWe can use union find to jump to next unvisited spot, each row and each column is an indepent union set.\\nThe root of unionSet[i] will be the next unvisited spot starting from i, after jump to the next unvisited spot, getRoot(i), do union(getRoot(i), getRoot(i)+1) and awlays use higher index as parent when doing union.  Path compression is used in the below code implementation.\\n\\ntime complexity O(m*n*log(max(m,n)))\\nspace complexity O(m*n)\\n```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n        if(m==1 && n==1)\\n            return 1;\\n        queue<array<int, 2>> q;\\n        q.push({0,0});\\n        int level=1;\\n        \\n        vector<int> usv0(m+1), ush0(n+1);\\n        for(int i=0; i<=m; i++)\\n            usv0[i]=i;\\n        for(int i=0; i<=n; i++)\\n            ush0[i]=i;\\n        \\n        vector<vector<int>> usv, ush;\\n        for(int i=0; i<n; i++)\\n            usv.push_back(usv0);\\n        for(int i=0; i<m; i++)\\n            ush.push_back(ush0);\\n        \\n        while(!q.empty()) {\\n            level++;\\n            for(int i=q.size(); i>0; i--) {\\n                auto [r,c]=q.front();\\n                q.pop();\\n                int nr=getRoot(r+1, usv, c);\\n                while(nr<m && nr<=r+grid[r][c]) {\\n                    if(nr==m-1 && c==n-1)\\n                        return level;\\n                    q.push({nr, c});\\n                    nr=doUnion(nr, nr+1, usv, c);\\n                }\\n                int nc=getRoot(c+1, ush, r);\\n                while(nc<n && nc<=c+grid[r][c]) {\\n                    if(r==m-1 && nc==n-1)\\n                        return level;\\n                    q.push({r, nc});\\n                    nc=doUnion(nc, nc+1, ush, r);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\nprivate:\\n    int getRoot(int node, vector<vector<int>>& usAry, int i) {\\n        while(node!=usAry[i][node]) {\\n            usAry[i][node]=usAry[i][usAry[i][node]];\\n            node=usAry[i][node];\\n        }\\n        return node;\\n    }\\n    int doUnion(int node1, int node2, vector<vector<int>>& usAry, int i) {\\n        int r1=getRoot(node1, usAry, i), r2=getRoot(node2, usAry, i);\\n        usAry[i][r1]=r2;\\n        return r2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n        if(m==1 && n==1)\\n            return 1;\\n        queue<array<int, 2>> q;\\n        q.push({0,0});\\n        int level=1;\\n        \\n        vector<int> usv0(m+1), ush0(n+1);\\n        for(int i=0; i<=m; i++)\\n            usv0[i]=i;\\n        for(int i=0; i<=n; i++)\\n            ush0[i]=i;\\n        \\n        vector<vector<int>> usv, ush;\\n        for(int i=0; i<n; i++)\\n            usv.push_back(usv0);\\n        for(int i=0; i<m; i++)\\n            ush.push_back(ush0);\\n        \\n        while(!q.empty()) {\\n            level++;\\n            for(int i=q.size(); i>0; i--) {\\n                auto [r,c]=q.front();\\n                q.pop();\\n                int nr=getRoot(r+1, usv, c);\\n                while(nr<m && nr<=r+grid[r][c]) {\\n                    if(nr==m-1 && c==n-1)\\n                        return level;\\n                    q.push({nr, c});\\n                    nr=doUnion(nr, nr+1, usv, c);\\n                }\\n                int nc=getRoot(c+1, ush, r);\\n                while(nc<n && nc<=c+grid[r][c]) {\\n                    if(r==m-1 && nc==n-1)\\n                        return level;\\n                    q.push({r, nc});\\n                    nc=doUnion(nc, nc+1, ush, r);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\nprivate:\\n    int getRoot(int node, vector<vector<int>>& usAry, int i) {\\n        while(node!=usAry[i][node]) {\\n            usAry[i][node]=usAry[i][usAry[i][node]];\\n            node=usAry[i][node];\\n        }\\n        return node;\\n    }\\n    int doUnion(int node1, int node2, vector<vector<int>>& usAry, int i) {\\n        int r1=getRoot(node1, usAry, i), r2=getRoot(node2, usAry, i);\\n        usAry[i][r1]=r2;\\n        return r2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404733,
                "title": "c-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    struct node {\\n        int cnt, dis;\\n    };\\n    struct compare {\\n        bool operator()(const node &a, const node &b) {\\n            return a.cnt > b.cnt;\\n        }\\n    };\\n\\n    priority_queue<node, vector<node>, compare> vq[100000];\\n    priority_queue<node, vector<node>, compare> hq;\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int i, j, minv = -1;\\n        int ans = -1;\\n        for (i = 0; i< n ; ++i) {\\n            while(!hq.empty()) hq.pop();\\n            for (j = 0; j <m; ++j) {\\n                while(!hq.empty() && hq.top().dis < j) hq.pop();\\n                while(!vq[j].empty() && vq[j].top().dis < i) vq[j].pop();\\n                if(!hq.empty() && minv > hq.top().cnt) minv = hq.top().cnt;\\n                if(!vq[j].empty() && minv > vq[j].top().cnt) minv = vq[j].top().cnt;\\n                hq.push({minv + 1, j + grid[i][j]});\\n                vq[j].push({minv + 1, i + grid[i][j]});                \\n                if(i == n - 1 && j == m - 1) ans = minv + 1;\\n                minv = 1000000;\\n            }\\n            minv = 1000000;            \\n        }\\n\\n        if(ans == 1000001) ans = -1;\\n        else ans += 1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct node {\\n        int cnt, dis;\\n    };\\n    struct compare {\\n        bool operator()(const node &a, const node &b) {\\n            return a.cnt > b.cnt;\\n        }\\n    };\\n\\n    priority_queue<node, vector<node>, compare> vq[100000];\\n    priority_queue<node, vector<node>, compare> hq;\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int i, j, minv = -1;\\n        int ans = -1;\\n        for (i = 0; i< n ; ++i) {\\n            while(!hq.empty()) hq.pop();\\n            for (j = 0; j <m; ++j) {\\n                while(!hq.empty() && hq.top().dis < j) hq.pop();\\n                while(!vq[j].empty() && vq[j].top().dis < i) vq[j].pop();\\n                if(!hq.empty() && minv > hq.top().cnt) minv = hq.top().cnt;\\n                if(!vq[j].empty() && minv > vq[j].top().cnt) minv = vq[j].top().cnt;\\n                hq.push({minv + 1, j + grid[i][j]});\\n                vq[j].push({minv + 1, i + grid[i][j]});                \\n                if(i == n - 1 && j == m - 1) ans = minv + 1;\\n                minv = 1000000;\\n            }\\n            minv = 1000000;            \\n        }\\n\\n        if(ans == 1000001) ans = -1;\\n        else ans += 1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401341,
                "title": "c-dijkstra",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& arr) {\\n        \\n        int n=arr.size();\\n        int m=arr[0].size();\\n        vector<vector<int>> distance(n,vector<int>(m,1e9));\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> q;\\n        distance[0][0]=0;\\n        q.push({0,{0,0}});\\n        while(q.size()!=0){\\n            \\n            pair<int,pair<int,int>> front=q.top();\\n            q.pop();\\n            int i=front.second.first;\\n            int j=front.second.second;\\n            int d=front.first;\\n            if(i==n-1 && j==m-1){\\n                return d+1;\\n            }\\n            for(int k=j;k<=arr[i][j]+j;k++){\\n                \\n                if(k<m && distance[i][k]>d+1){\\n                    distance[i][k]=d+1;\\n                    q.push({distance[i][k],{i,k}});\\n                    if(k==m-1 && i==n-1){\\n                        return d+2;\\n                    }\\n                }\\n            }\\n            for(int k=i;k<=arr[i][j]+i;k++){\\n                \\n                if(k<n && distance[k][j]>d+1){\\n                    distance[k][j]=d+1;\\n                    q.push({distance[k][j],{k,j}});\\n                    if(k==n-1 && j==m-1){\\n                        return d+2;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& arr) {\\n        \\n        int n=arr.size();\\n        int m=arr[0].size();\\n        vector<vector<int>> distance(n,vector<int>(m,1e9));\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> q;\\n        distance[0][0]=0;\\n        q.push({0,{0,0}",
                "codeTag": "Java"
            },
            {
                "id": 3401252,
                "title": "bfs-farthest-cells-first",
                "content": "# Approach\\nBFS but pushing the farthest cells first in the queue.\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>> &grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        map<int, int> mp;\\n        mp[0] = 1;\\n        queue<int> q;\\n        vector<bool> visit(1e5 + 10, false);\\n        visit[0] = true;\\n        q.push(0);\\n        while (!q.empty()) {\\n            auto frnt = q.front();\\n            q.pop();\\n            int cx = frnt / m, cy = frnt % m, lim = grid[cx][cy];\\n            if (cx == n - 1 and cy == m - 1) {\\n                return mp[frnt];\\n            }\\n            for (int offset = min(lim, n - 1 - cx); offset > 0; offset--) {\\n                int k = (cx + offset) * m + cy;\\n                if (!visit[k]) {\\n                    visit[k] = true;\\n                    q.push(k);\\n                    mp[k] = mp[frnt] + 1;\\n                } \\n            }\\n\\n            for (int offset = min(lim, m - 1 - cy); offset > 0; offset--) {\\n                int k = cx * m + (cy + offset);\\n                if (!visit[k]) {\\n                    visit[k] = true;\\n                    q.push(k);\\n                    mp[k] = mp[frnt] + 1;\\n                } \\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>> &grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        map<int, int> mp;\\n        mp[0] = 1;\\n        queue<int> q;\\n        vector<bool> visit(1e5 + 10, false);\\n        visit[0] = true;\\n        q.push(0);\\n        while (!q.empty()) {\\n            auto frnt = q.front();\\n            q.pop();\\n            int cx = frnt / m, cy = frnt % m, lim = grid[cx][cy];\\n            if (cx == n - 1 and cy == m - 1) {\\n                return mp[frnt];\\n            }\\n            for (int offset = min(lim, n - 1 - cx); offset > 0; offset--) {\\n                int k = (cx + offset) * m + cy;\\n                if (!visit[k]) {\\n                    visit[k] = true;\\n                    q.push(k);\\n                    mp[k] = mp[frnt] + 1;\\n                } \\n            }\\n\\n            for (int offset = min(lim, m - 1 - cy); offset > 0; offset--) {\\n                int k = cx * m + (cy + offset);\\n                if (!visit[k]) {\\n                    visit[k] = true;\\n                    q.push(k);\\n                    mp[k] = mp[frnt] + 1;\\n                } \\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401043,
                "title": "regular-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nTreat **(0, 0)** as the source node and **(m - 1, n-1)** as the target node, we want to find the minimum distance between the source node to the target node.\\n\\nOriginally I thought I need to use Dijkstra, but here each movement costs the same quantity 1. So the regular BFS is sufficient. \\n\\nInstead of checking a node is the target node after poping from the deque, we can check if a node is the target node before we pushing this node (the first time we see this node) to improve the efficiency.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBFS\\n\\n# Complexity\\n- Time complexity: O(mn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(mn)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        m = len(grid); n = len(grid[0])\\n        if m == 1 and n == 1:\\n            return 1\\n        visited = [[0] * n for _ in range(m)]\\n        visited[0][0] = 1\\n\\n        dq = deque([[0, 0]])\\n        step = 1\\n\\n        while dq:\\n            size = len(dq)\\n            for _ in range(size):\\n                pi, pj = dq.popleft()\\n\\n                for cj in range(pj + 1, min(grid[pi][pj] + pj + 1, n)):\\n                    if pi == m - 1 and cj == n - 1:\\n                        return step + 1\\n                    if visited[pi][cj]:\\n                        continue\\n                    visited[pi][cj] = 1\\n                    dq.append([pi, cj])\\n                        \\n\\n                for ci in range(pi + 1, min(grid[pi][pj] + pi + 1, m)):\\n                    if ci == m - 1 and pj == n - 1:\\n                        return step + 1\\n                    if visited[ci][pj]:\\n                        continue\\n                    visited[ci][pj] = 1\\n                    dq.append([ci, pj])\\n            step += 1\\n        return -1    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        m = len(grid); n = len(grid[0])\\n        if m == 1 and n == 1:\\n            return 1\\n        visited = [[0] * n for _ in range(m)]\\n        visited[0][0] = 1\\n\\n        dq = deque([[0, 0]])\\n        step = 1\\n\\n        while dq:\\n            size = len(dq)\\n            for _ in range(size):\\n                pi, pj = dq.popleft()\\n\\n                for cj in range(pj + 1, min(grid[pi][pj] + pj + 1, n)):\\n                    if pi == m - 1 and cj == n - 1:\\n                        return step + 1\\n                    if visited[pi][cj]:\\n                        continue\\n                    visited[pi][cj] = 1\\n                    dq.append([pi, cj])\\n                        \\n\\n                for ci in range(pi + 1, min(grid[pi][pj] + pi + 1, m)):\\n                    if ci == m - 1 and pj == n - 1:\\n                        return step + 1\\n                    if visited[ci][pj]:\\n                        continue\\n                    visited[ci][pj] = 1\\n                    dq.append([ci, pj])\\n            step += 1\\n        return -1    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400965,
                "title": "bfs-finding-min-steps-o-mn-2-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Use BFS by adding all unvisited candidates in each step\\n- Mark a cell visited by `grid[i][j] *= -1` and add to queue\\n- When getting a cell from queue, traverse `j < k <= j - grid[i][j]` and `i < k <= i - grid[i][j]` to find next candidates `(i, k)` and `(k, j)`\\n- `grid[i][j] < 0` means that `(i, j)` is visited before, do not add to queue again\\n- `grid[i][j] == 0` means that we cannot go to other cells from `(i, j)`, do not add to queue\\n\\n# Complexity\\n- Time complexity: O((mn)^2) since each cell is visited at most once but might check for next `2*grid[i][j] < 2mn` cells\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(mn)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\tpublic int minimumVisitedCells(int[][] grid) {\\n\\t\\tint m = grid.length;\\n\\t\\tint n = grid[0].length;\\n\\t\\tint steps = 1;\\n\\t\\tif (m == 1 && n == 1) {\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\t\\tQueue<int[]> queue = new LinkedList<>();\\n\\t\\tqueue.add(new int[] {0, 0});\\n\\t\\tgrid[0][0] *= -1;  // visited\\n\\t\\twhile (!queue.isEmpty()) {\\n\\t\\t\\tsteps++;\\n\\t\\t\\tint size = queue.size();\\n\\t\\t\\tfor (int cnt = 0; cnt < size; cnt++) {\\n\\t\\t\\t\\tint[] cell = queue.poll();\\n\\t\\t\\t\\tint i = cell[0];\\n\\t\\t\\t\\tint j = cell[1];\\n\\t\\t\\t\\tfor (int k = j + 1; k <= Math.min(j - grid[i][j], n - 1); k++) {\\n\\t\\t\\t\\t\\tif (visit(grid, m, n, i, k, queue)) {\\n\\t\\t\\t\\t\\t\\treturn steps;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor (int k = i + 1; k <= Math.min(i - grid[i][j], m - 1); k++) {\\n\\t\\t\\t\\t\\tif (visit(grid, m, n, k, j, queue)) {\\n\\t\\t\\t\\t\\t\\treturn steps;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n\\t\\n\\t// visit (r, c) if not visited\\n\\t// return true if (r, c) reaches (m-1, n-1)\\n\\tprivate boolean visit(int[][] grid, int m, int n, int r, int c, Queue<int[]> queue) {\\n\\t\\tif (r == m - 1 && c == n - 1) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tif (grid[r][c] > 0) {\\n\\t\\t\\tqueue.add(new int[] {r, c});\\n\\t\\t\\tgrid[r][c] *= -1;  // visited\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic int minimumVisitedCells(int[][] grid) {\\n\\t\\tint m = grid.length;\\n\\t\\tint n = grid[0].length;\\n\\t\\tint steps = 1;\\n\\t\\tif (m == 1 && n == 1) {\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\t\\tQueue<int[]> queue = new LinkedList<>();\\n\\t\\tqueue.add(new int[] {0, 0});\\n\\t\\tgrid[0][0] *= -1;  // visited\\n\\t\\twhile (!queue.isEmpty()) {\\n\\t\\t\\tsteps++;\\n\\t\\t\\tint size = queue.size();\\n\\t\\t\\tfor (int cnt = 0; cnt < size; cnt++) {\\n\\t\\t\\t\\tint[] cell = queue.poll();\\n\\t\\t\\t\\tint i = cell[0];\\n\\t\\t\\t\\tint j = cell[1];\\n\\t\\t\\t\\tfor (int k = j + 1; k <= Math.min(j - grid[i][j], n - 1); k++) {\\n\\t\\t\\t\\t\\tif (visit(grid, m, n, i, k, queue)) {\\n\\t\\t\\t\\t\\t\\treturn steps;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor (int k = i + 1; k <= Math.min(i - grid[i][j], m - 1); k++) {\\n\\t\\t\\t\\t\\tif (visit(grid, m, n, k, j, queue)) {\\n\\t\\t\\t\\t\\t\\treturn steps;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n\\t\\n\\t// visit (r, c) if not visited\\n\\t// return true if (r, c) reaches (m-1, n-1)\\n\\tprivate boolean visit(int[][] grid, int m, int n, int r, int c, Queue<int[]> queue) {\\n\\t\\tif (r == m - 1 && c == n - 1) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tif (grid[r][c] > 0) {\\n\\t\\t\\tqueue.add(new int[] {r, c});\\n\\t\\t\\tgrid[r][c] *= -1;  // visited\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400450,
                "title": "c-bfs",
                "content": "The only trick in this question is to push the farthest cell into the queue first in order to quickly reach to the bottom right cell.  \\n\\n```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int n = grid.size(),m=grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        queue<pair<int,pair<int,int>>>q;\\n        q.push({0,{0,0}});\\n        vis[0][0] = 1;\\n        while(!q.empty()){\\n            auto top = q.front();\\n            q.pop();\\n            int steps = top.first, i = top.second.first, j = top.second.second;\\n            if(i == n-1 && j == m-1) return steps+1;\\n            for(int col=min(m-1,grid[i][j] + j);col >= j+1;col--){\\n                if(!vis[i][col]){\\n                    q.push({steps+1,{i,col}});\\n                    vis[i][col] = 1;\\n                }\\n            }\\n            for(int row=min(n-1,grid[i][j] + i);row >= i+1;row--){\\n                if(!vis[row][j]){\\n                    q.push({steps+1,{row,j}});\\n                    vis[row][j] = 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int n = grid.size(),m=grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        queue<pair<int,pair<int,int>>>q;\\n        q.push({0,{0,0}});\\n        vis[0][0] = 1;\\n        while(!q.empty()){\\n            auto top = q.front();\\n            q.pop();\\n            int steps = top.first, i = top.second.first, j = top.second.second;\\n            if(i == n-1 && j == m-1) return steps+1;\\n            for(int col=min(m-1,grid[i][j] + j);col >= j+1;col--){\\n                if(!vis[i][col]){\\n                    q.push({steps+1,{i,col}});\\n                    vis[i][col] = 1;\\n                }\\n            }\\n            for(int row=min(n-1,grid[i][j] + i);row >= i+1;row--){\\n                if(!vis[row][j]){\\n                    q.push({steps+1,{row,j}});\\n                    vis[row][j] = 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400253,
                "title": "javascript-monotonic-stacks-binary-search",
                "content": "**Solution: DP w/ Monotonic Stacks & Binary Search**\\n\\nMaintain monotonic decreasing stacks per row and column.\\nEach stack of indices is in decreasing order of steps. \\nPop off the indices from the back of the stack while the steps are greater than the `dp[i][j]`, since there is no purpose in keeping larger indices with a larger number of steps.\\n\\nGo through the grid from bottom to top, right to left, and populate each `dp[i][j]`.\\nFor each `grid[i][j]`, \\n*   Downward: Binary search through the stack for column `j` to find the first index where `stack[index] <= grid[i][j] + i`\\n*   Rightward: Binary search through the stack for row `i` to find the first index where `stack[index] <= grid[i][j] + j`\\n\\nTime Complexity: `O(mn log(m + n))` 469ms\\nSpace Complexity: `O(mn)` 89.3MB\\n```\\nvar minimumVisitedCells = function(grid) {\\n  let m = grid.length, n = grid[0].length;\\n  let dp = Array(m).fill(0).map(() => Array(n).fill(Infinity)), colStacks = Array(n).fill(0).map(() => []); // colStacks[j] = stack of row indexes for column j\\n  dp[m - 1][n - 1] = 1;\\n  colStacks[n - 1].push(m - 1); \\n  \\n  for (let i = m - 1; i >= 0; i--) {\\n    let rowStack = i === m - 1 ? [n - 1] : []; // stack of column indexes for row i\\n    for (let j = n - 1; j >= 0; j--) {\\n      let colIndex = findIndex(rowStack, grid[i][j] + j);\\n      if (colIndex >= 0) dp[i][j] = Math.min(dp[i][j], 1 + dp[i][rowStack[colIndex]]);\\n      let colStack = colStacks[j], rowIndex = findIndex(colStack, grid[i][j] + i);\\n      if (rowIndex >= 0) dp[i][j] = Math.min(dp[i][j], 1 + dp[colStack[rowIndex]][j]);\\n      \\n      while (rowStack.length && dp[i][rowStack[rowStack.length - 1]] >= dp[i][j]) rowStack.pop();\\n      rowStack.push(j);\\n      while (colStack.length && dp[colStack[colStack.length - 1]][j] >= dp[i][j]) colStack.pop();\\n      colStack.push(i);\\n    }\\n  }\\n  return dp[0][0] === Infinity ? -1 : dp[0][0];\\n};\\n\\nfunction findIndex(stack, maxIndex) {\\n  if (!stack.length) return -1;\\n  let low = 0, high = stack.length - 1;\\n  while (low < high) {\\n    let mid = Math.floor((low + high) / 2);\\n    if (stack[mid] <= maxIndex) high = mid;\\n    else low = mid + 1;\\n  }\\n  return stack[low] <= maxIndex ? low : -1;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumVisitedCells = function(grid) {\\n  let m = grid.length, n = grid[0].length;\\n  let dp = Array(m).fill(0).map(() => Array(n).fill(Infinity)), colStacks = Array(n).fill(0).map(() => []); // colStacks[j] = stack of row indexes for column j\\n  dp[m - 1][n - 1] = 1;\\n  colStacks[n - 1].push(m - 1); \\n  \\n  for (let i = m - 1; i >= 0; i--) {\\n    let rowStack = i === m - 1 ? [n - 1] : []; // stack of column indexes for row i\\n    for (let j = n - 1; j >= 0; j--) {\\n      let colIndex = findIndex(rowStack, grid[i][j] + j);\\n      if (colIndex >= 0) dp[i][j] = Math.min(dp[i][j], 1 + dp[i][rowStack[colIndex]]);\\n      let colStack = colStacks[j], rowIndex = findIndex(colStack, grid[i][j] + i);\\n      if (rowIndex >= 0) dp[i][j] = Math.min(dp[i][j], 1 + dp[colStack[rowIndex]][j]);\\n      \\n      while (rowStack.length && dp[i][rowStack[rowStack.length - 1]] >= dp[i][j]) rowStack.pop();\\n      rowStack.push(j);\\n      while (colStack.length && dp[colStack[colStack.length - 1]][j] >= dp[i][j]) colStack.pop();\\n      colStack.push(i);\\n    }\\n  }\\n  return dp[0][0] === Infinity ? -1 : dp[0][0];\\n};\\n\\nfunction findIndex(stack, maxIndex) {\\n  if (!stack.length) return -1;\\n  let low = 0, high = stack.length - 1;\\n  while (low < high) {\\n    let mid = Math.floor((low + high) / 2);\\n    if (stack[mid] <= maxIndex) high = mid;\\n    else low = mid + 1;\\n  }\\n  return stack[low] <= maxIndex ? low : -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3399836,
                "title": "c-segment-tree",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void pushdown(int *seg,int *lzy,int cur)\\n    {\\n        if(lzy[cur]!=INT_MAX)\\n        {\\n            seg[cur<<1]=min(seg[cur<<1],lzy[cur]);\\n            lzy[cur<<1]=min(lzy[cur<<1],lzy[cur]);\\n            seg[cur<<1|1]=min(seg[cur<<1|1],lzy[cur]);\\n            lzy[cur<<1|1]=min(lzy[cur<<1|1],lzy[cur]);\\n            lzy[cur]=INT_MAX;\\n        }\\n    }\\n    void update(int *seg,int *lzy,int cur,int ql,int qr,int l,int r, int val)\\n    {\\n        if(ql>=r||qr<=l)return;\\n        if(ql<=l&&r<=qr)\\n        {\\n            seg[cur]=min(seg[cur],val);\\n            lzy[cur]=min(lzy[cur],val);\\n            return;\\n        }\\n        pushdown(seg,lzy,cur);\\n        int mid=(l+r)>>1;\\n        update(seg,lzy,cur<<1,ql,qr,l,mid,val);\\n        update(seg,lzy,cur<<1|1,ql,qr,mid,r,val);\\n    }\\n    int query(int *seg,int *lzy,int cur,int target,int l,int r)\\n    {\\n        if(l+1==r)return seg[cur];\\n        pushdown(seg,lzy,cur);\\n        int mid=(l+r)>>1;\\n        if(target<mid)return query(seg,lzy,cur<<1,target,l,mid);\\n        else return query(seg,lzy,cur<<1|1,target,mid,r);\\n    }\\n    int minimumVisitedCells(vector<vector<int>>& grid) \\n    {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        // TLE with vector<vector>\\n        // vector<vector<int>>row(m,vector<int>(n<<2+5,INT_MAX)),row_lzy(m,vector<int>(n<<2+5,INT_MAX));\\n        // vector<vector<int>>col(n,vector<int>(m<<2+5,INT_MAX)),col_lzy(n,vector<int>(m<<2+5,INT_MAX));\\n        int row[m][n<<2],row_lzy[m][n<<2];\\n        int col[n][m<<2],col_lzy[n][m<<2];\\n        for(int i=0;i<m;i++)for(int j=0;j<(n<<2);j++)row[i][j]=row_lzy[i][j]=INT_MAX;\\n        for(int i=0;i<n;i++)for(int j=0;j<(m<<2);j++)col[i][j]=col_lzy[i][j]=INT_MAX;\\n        update(row[0],row_lzy[0],1,0,1,0,n,1);\\n        update(col[0],col_lzy[0],1,0,1,0,m,1);\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n            {\\n                int step=min(query(row[i],row_lzy[i],1,j,0,n),query(col[j],col_lzy[j],1,i,0,m));\\n                if(step==INT_MAX)continue;\\n                int left=min(n,j+grid[i][j]+1);\\n                int down=min(m,i+grid[i][j]+1);\\n                update(row[i],row_lzy[i],1,j+1,left,0,n,step+1);\\n                update(col[j],col_lzy[j],1,i+1,down,0,m,step+1);\\n            }\\n        int res=min(query(row[m-1],row_lzy[m-1],1,n-1,0,n),query(col[n-1],col_lzy[n-1],1,m-1,0,m));\\n        return res == INT_MAX ? -1 : res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Segment Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void pushdown(int *seg,int *lzy,int cur)\\n    {\\n        if(lzy[cur]!=INT_MAX)\\n        {\\n            seg[cur<<1]=min(seg[cur<<1],lzy[cur]);\\n            lzy[cur<<1]=min(lzy[cur<<1],lzy[cur]);\\n            seg[cur<<1|1]=min(seg[cur<<1|1],lzy[cur]);\\n            lzy[cur<<1|1]=min(lzy[cur<<1|1],lzy[cur]);\\n            lzy[cur]=INT_MAX;\\n        }\\n    }\\n    void update(int *seg,int *lzy,int cur,int ql,int qr,int l,int r, int val)\\n    {\\n        if(ql>=r||qr<=l)return;\\n        if(ql<=l&&r<=qr)\\n        {\\n            seg[cur]=min(seg[cur],val);\\n            lzy[cur]=min(lzy[cur],val);\\n            return;\\n        }\\n        pushdown(seg,lzy,cur);\\n        int mid=(l+r)>>1;\\n        update(seg,lzy,cur<<1,ql,qr,l,mid,val);\\n        update(seg,lzy,cur<<1|1,ql,qr,mid,r,val);\\n    }\\n    int query(int *seg,int *lzy,int cur,int target,int l,int r)\\n    {\\n        if(l+1==r)return seg[cur];\\n        pushdown(seg,lzy,cur);\\n        int mid=(l+r)>>1;\\n        if(target<mid)return query(seg,lzy,cur<<1,target,l,mid);\\n        else return query(seg,lzy,cur<<1|1,target,mid,r);\\n    }\\n    int minimumVisitedCells(vector<vector<int>>& grid) \\n    {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        // TLE with vector<vector>\\n        // vector<vector<int>>row(m,vector<int>(n<<2+5,INT_MAX)),row_lzy(m,vector<int>(n<<2+5,INT_MAX));\\n        // vector<vector<int>>col(n,vector<int>(m<<2+5,INT_MAX)),col_lzy(n,vector<int>(m<<2+5,INT_MAX));\\n        int row[m][n<<2],row_lzy[m][n<<2];\\n        int col[n][m<<2],col_lzy[n][m<<2];\\n        for(int i=0;i<m;i++)for(int j=0;j<(n<<2);j++)row[i][j]=row_lzy[i][j]=INT_MAX;\\n        for(int i=0;i<n;i++)for(int j=0;j<(m<<2);j++)col[i][j]=col_lzy[i][j]=INT_MAX;\\n        update(row[0],row_lzy[0],1,0,1,0,n,1);\\n        update(col[0],col_lzy[0],1,0,1,0,m,1);\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n            {\\n                int step=min(query(row[i],row_lzy[i],1,j,0,n),query(col[j],col_lzy[j],1,i,0,m));\\n                if(step==INT_MAX)continue;\\n                int left=min(n,j+grid[i][j]+1);\\n                int down=min(m,i+grid[i][j]+1);\\n                update(row[i],row_lzy[i],1,j+1,left,0,n,step+1);\\n                update(col[j],col_lzy[j],1,i+1,down,0,m,step+1);\\n            }\\n        int res=min(query(row[m-1],row_lzy[m-1],1,n-1,0,n),query(col[n-1],col_lzy[n-1],1,m-1,0,m));\\n        return res == INT_MAX ? -1 : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399653,
                "title": "dijkstra-vs-bfs",
                "content": "Hi, im wondering about the difference in complexity between the two algorithms. It seems to me that in the special case where each neighbour is 1-hop (1 distance) away from the current node, BFS can be applied and should be much more efficient than Dijkstra, which is a more general algorithm for distances > 1.\\n\\nI solved this problem with Dijkstra but saw in the discussion that many timed-out with BFS. I would think BFS would be faster here but it seems like it isn\\'t the case. Do correct me.",
                "solutionTags": [],
                "code": "Hi, im wondering about the difference in complexity between the two algorithms. It seems to me that in the special case where each neighbour is 1-hop (1 distance) away from the current node, BFS can be applied and should be much more efficient than Dijkstra, which is a more general algorithm for distances > 1.\\n\\nI solved this problem with Dijkstra but saw in the discussion that many timed-out with BFS. I would think BFS would be faster here but it seems like it isn\\'t the case. Do correct me.",
                "codeTag": "Unknown"
            },
            {
                "id": 3399536,
                "title": "c-bfs",
                "content": "# Intuition\\nVisit farthest cell first and then try previous cells if answer from farthest cell dosen\\'t exist.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        int ans=0;\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        vis[0][0] = 1;\\n        while(!q.empty())\\n        {\\n            int siz = q.size();\\n            for(int i=0;i<siz;i++)\\n            {\\n                auto node = q.front();\\n                q.pop();\\n                int x = node.first;\\n                int y = node.second;\\n                if(x==n-1 && y==m-1)\\n                return ans+1;\\n                for(int j=min(grid[x][y]+y,m-1);j>y;j--)\\n                {\\n                    if(!vis[x][j])\\n                    {\\n                        q.push({x,j});\\n                        vis[x][j] = 1;\\n                    }\\n                }\\n                for(int j=min(grid[x][y]+x,n-1);j>x;j--)\\n                {\\n                    if(!vis[j][y])\\n                    {\\n                        q.push({j,y});\\n                        vis[j][y] = 1;\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        int ans=0;\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        vis[0][0] = 1;\\n        while(!q.empty())\\n        {\\n            int siz = q.size();\\n            for(int i=0;i<siz;i++)\\n            {\\n                auto node = q.front();\\n                q.pop();\\n                int x = node.first;\\n                int y = node.second;\\n                if(x==n-1 && y==m-1)\\n                return ans+1;\\n                for(int j=min(grid[x][y]+y,m-1);j>y;j--)\\n                {\\n                    if(!vis[x][j])\\n                    {\\n                        q.push({x,j});\\n                        vis[x][j] = 1;\\n                    }\\n                }\\n                for(int j=min(grid[x][y]+x,n-1);j>x;j--)\\n                {\\n                    if(!vis[j][y])\\n                    {\\n                        q.push({j,y});\\n                        vis[j][y] = 1;\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399511,
                "title": "bfs-python-pass",
                "content": "# Intuition\\nBFS to get the min step\\n\\n# Approach\\nmark the visited cells; one cell only need to be visited once\\nstart from the furthest reachable cells to save time\\n\\n# Complexity\\n- Time complexity: $$O(mn)$$\\n\\n- Space complexity: $$O(mn)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n\\t# BFS to get the minimum step\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        # if a cell is visited, no need to check again\\n        visited = [[False for j in range(n)] for i in range(m)]\\n        queue = deque()\\n        queue.append((0,0))\\n        step = 1\\n        while queue:\\n            size = len(queue)\\n            for _ in range(size):\\n                i, j = queue.popleft()\\n                # min step to reach the destination\\n                if i == m-1 and j == n-1:\\n                    return step\\n                # add possible next positions\\n                # optimization: add from the further cells first\\n                for k in range(min(grid[i][j] + i, m-1), i, -1):\\n                    if not visited[k][j]:\\n                        visited[k][j] = True\\n                        queue.append((k, j))\\n                for k in range(min(grid[i][j] + j, n-1), j, -1):\\n                    if not visited[i][k]:\\n                        visited[i][k] = True\\n                        queue.append((i, k))\\n            step += 1\\n        return -1\\n                \\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n\\t# BFS to get the minimum step\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        # if a cell is visited, no need to check again\\n        visited = [[False for j in range(n)] for i in range(m)]\\n        queue = deque()\\n        queue.append((0,0))\\n        step = 1\\n        while queue:\\n            size = len(queue)\\n            for _ in range(size):\\n                i, j = queue.popleft()\\n                # min step to reach the destination\\n                if i == m-1 and j == n-1:\\n                    return step\\n                # add possible next positions\\n                # optimization: add from the further cells first\\n                for k in range(min(grid[i][j] + i, m-1), i, -1):\\n                    if not visited[k][j]:\\n                        visited[k][j] = True\\n                        queue.append((k, j))\\n                for k in range(min(grid[i][j] + j, n-1), j, -1):\\n                    if not visited[i][k]:\\n                        visited[i][k] = True\\n                        queue.append((i, k))\\n            step += 1\\n        return -1\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399166,
                "title": "easy-dp-solution-with-a-simple-pruning",
                "content": "# Intuition\\nThis questions cooperate bfs concept inside dp. We just need to use bfs to search all the nodes we could go to. Then, store the information that how many cells we could go there in a dp. If we could reach there, we just need to skip that node again. \\n\\n### Reminder\\nSince it could exist the case that we could jump directly to the beginning and to the end for example, like [[9999, .... , 0]]. We should add a simple pruning to check whether we get the end each time during bfs.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int dp[grid.size()][grid[0].size()];\\n        memset(dp, 0, sizeof(dp));\\n        queue<pair<int, int>> q;\\n        dp[0][0] = 1;\\n        q.push({0, 0});\\n        while (!q.empty()){\\n            if (dp[grid.size() - 1][grid[0].size() - 1] != 0) return dp[grid.size() - 1][grid[0].size() - 1];\\n            auto &top = q.front();\\n            int y = grid[top.first][top.second] + top.first;\\n            for (int i = top.first; i <= min(y, int(grid.size()) - 1); ++i){\\n                if (dp[i][top.second] == 0){\\n                    dp[i][top.second] = dp[top.first][top.second] + 1;\\n                    q.push({i, top.second});\\n                }\\n            }\\n            int x = grid[top.first][top.second] + top.second;\\n            for (int i = top.second; i <= min(x, int(grid[0].size()) - 1); ++i){\\n                if (dp[top.first][i] == 0){\\n                    dp[top.first][i] = dp[top.first][top.second] + 1;\\n                    q.push({top.first, i});\\n                }\\n            }\\n            q.pop();\\n        }\\n        if (dp[grid.size() - 1][grid[0].size() - 1] == 0) return -1;\\n        else return dp[grid.size() - 1][grid[0].size() - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int dp[grid.size()][grid[0].size()];\\n        memset(dp, 0, sizeof(dp));\\n        queue<pair<int, int>> q;\\n        dp[0][0] = 1;\\n        q.push({0, 0});\\n        while (!q.empty()){\\n            if (dp[grid.size() - 1][grid[0].size() - 1] != 0) return dp[grid.size() - 1][grid[0].size() - 1];\\n            auto &top = q.front();\\n            int y = grid[top.first][top.second] + top.first;\\n            for (int i = top.first; i <= min(y, int(grid.size()) - 1); ++i){\\n                if (dp[i][top.second] == 0){\\n                    dp[i][top.second] = dp[top.first][top.second] + 1;\\n                    q.push({i, top.second});\\n                }\\n            }\\n            int x = grid[top.first][top.second] + top.second;\\n            for (int i = top.second; i <= min(x, int(grid[0].size()) - 1); ++i){\\n                if (dp[top.first][i] == 0){\\n                    dp[top.first][i] = dp[top.first][top.second] + 1;\\n                    q.push({top.first, i});\\n                }\\n            }\\n            q.pop();\\n        }\\n        if (dp[grid.size() - 1][grid[0].size() - 1] == 0) return -1;\\n        else return dp[grid.size() - 1][grid[0].size() - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399142,
                "title": "c-easy-to-understand-bfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mini(int a, int b){\\n        return a>b?b:a;\\n    }\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        vector<vector<int>>dp(grid.size(),vector<int>(grid[0].size(),-1));\\n        dp[0][0] = 1;\\n        queue<vector<int>>q;\\n        q.push({0,0,1});\\n        while(!q.empty()){\\n            vector<int>t = q.front();\\n            //cout<<t[0]<<\" \"<<t[1]<<endl;\\n            q.pop();\\n            for(int i=t[0]+1;i<=mini(t[0]+grid[t[0]][t[1]],grid.size()-1);i++){\\n                if(i==grid.size()-1 && t[1]==grid[0].size()-1){\\n                    return t[2]+1;\\n                }\\n                if(dp[i][t[1]]==-1){\\n                    dp[i][t[1]] = t[2]+1;\\n                    q.push({i,t[1],t[2]+1});\\n                }\\n            }\\n            for(int i=t[1]+1;i<=mini(t[1]+grid[t[0]][t[1]],grid[0].size()-1);i++){\\n                if(i==grid[0].size()-1 && t[0]==grid.size()-1){\\n                    return t[2]+1;\\n                }\\n                if(dp[t[0]][i]==-1){\\n                    dp[t[0]][i] = t[2]+1;\\n                    q.push({t[0],i,t[2]+1});\\n                }\\n            }\\n        }\\n        return dp[grid.size()-1][grid[0].size()-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mini(int a, int b){\\n        return a>b?b:a;\\n    }\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        vector<vector<int>>dp(grid.size(),vector<int>(grid[0].size(),-1));\\n        dp[0][0] = 1;\\n        queue<vector<int>>q;\\n        q.push({0,0,1});\\n        while(!q.empty()){\\n            vector<int>t = q.front();\\n            //cout<<t[0]<<\" \"<<t[1]<<endl;\\n            q.pop();\\n            for(int i=t[0]+1;i<=mini(t[0]+grid[t[0]][t[1]],grid.size()-1);i++){\\n                if(i==grid.size()-1 && t[1]==grid[0].size()-1){\\n                    return t[2]+1;\\n                }\\n                if(dp[i][t[1]]==-1){\\n                    dp[i][t[1]] = t[2]+1;\\n                    q.push({i,t[1],t[2]+1});\\n                }\\n            }\\n            for(int i=t[1]+1;i<=mini(t[1]+grid[t[0]][t[1]],grid[0].size()-1);i++){\\n                if(i==grid[0].size()-1 && t[0]==grid.size()-1){\\n                    return t[2]+1;\\n                }\\n                if(dp[t[0]][i]==-1){\\n                    dp[t[0]][i] = t[2]+1;\\n                    q.push({t[0],i,t[2]+1});\\n                }\\n            }\\n        }\\n        return dp[grid.size()-1][grid[0].size()-1];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3399138,
                "title": "solution-from-hint-by-leetcode",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport heapq\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        ROWS = [[] for _ in range(m)]\\n        COLS = [[] for _ in range(n)]\\n        #Each element in ROWS[i] has 2 elements (similar to COLS[j]):\\n        #The first: The number of cells (MINIMUM) reached. We have it when going to a cell in the i_th row.\\n        #The second: The MAXIMUM col that can be reached after we go to the cell mentioned.\\n        heappush(ROWS[0], (1, 0))\\n        for i in range(m):\\n            for j in range(n):\\n                MIN = float(\\'inf\\')                   #MIN: The minimum number of cells reached\\n                while ROWS[i] and ROWS[i][0][1] < j: #ROWS[i][0][1]: The maximum col can be reached on the i_th row with the \"respective MIN\"\\n                                                     #If col j cannot be reached, cols > j cannot be reached either\\n                    heappop(ROWS[i])\\n                    \\n                if ROWS[i]:\\n                    MIN = ROWS[i][0][0]\\n                \\n                while COLS[j] and COLS[j][0][1] < i: #COLS[i][0][1]: The maximum row can be reached on the j_th row with the \"respective MIN\"\\n                    heappop(COLS[j])\\n                if COLS[j]:\\n                    MIN = min(MIN, COLS[j][0][0])\\n                \\n                if (i, j) == (m-1, n-1) and MIN!=float(\\'inf\\'):\\n                    return MIN\\n                if MIN!=float(\\'inf\\'):\\n                    heappush(ROWS[i], (MIN+1, j + grid[i][j]))\\n                    heappush(COLS[j], (MIN+1, i + grid[i][j]))\\n        \\n        return -1\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        ROWS = [[] for _ in range(m)]\\n        COLS = [[] for _ in range(n)]\\n        #Each element in ROWS[i] has 2 elements (similar to COLS[j]):\\n        #The first: The number of cells (MINIMUM) reached. We have it when going to a cell in the i_th row.\\n        #The second: The MAXIMUM col that can be reached after we go to the cell mentioned.\\n        heappush(ROWS[0], (1, 0))\\n        for i in range(m):\\n            for j in range(n):\\n                MIN = float(\\'inf\\')                   #MIN: The minimum number of cells reached\\n                while ROWS[i] and ROWS[i][0][1] < j: #ROWS[i][0][1]: The maximum col can be reached on the i_th row with the \"respective MIN\"\\n                                                     #If col j cannot be reached, cols > j cannot be reached either\\n                    heappop(ROWS[i])\\n                    \\n                if ROWS[i]:\\n                    MIN = ROWS[i][0][0]\\n                \\n                while COLS[j] and COLS[j][0][1] < i: #COLS[i][0][1]: The maximum row can be reached on the j_th row with the \"respective MIN\"\\n                    heappop(COLS[j])\\n                if COLS[j]:\\n                    MIN = min(MIN, COLS[j][0][0])\\n                \\n                if (i, j) == (m-1, n-1) and MIN!=float(\\'inf\\'):\\n                    return MIN\\n                if MIN!=float(\\'inf\\'):\\n                    heappush(ROWS[i], (MIN+1, j + grid[i][j]))\\n                    heappush(COLS[j], (MIN+1, i + grid[i][j]))\\n        \\n        return -1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398976,
                "title": "step-by-step-easy-solution-using-queue",
                "content": "\\nHappy Learning :)\\n# Code\\n```\\nclass Solution {\\n    public int minimumVisitedCells(int[][] grid) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        if(m==1 && n==1){\\n            return 1;\\n        }\\n        Queue<int[]> q=new LinkedList<>();\\n        int[][] visited=new int[m][n];\\n        q.add(new int[]{0,0});\\n\\n        int dist=1;\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            while(size>0){\\n                int[] cell=q.poll();\\n                int val=grid[cell[0]][cell[1]];\\n                for(int col=1;col<=val;col++){\\n                    if(col+cell[1]>=n){\\n                        break;\\n                    }\\n                    if(cell[0]==m-1 && col+cell[1]==n-1){\\n                        return dist+1;\\n                    }\\n                    if(grid[cell[0]][col+cell[1]]!=0 && visited[cell[0]][col+cell[1]]==0){\\n                        q.add(new int[]{cell[0],col+cell[1]});\\n                        visited[cell[0]][col+cell[1]]=1;\\n                    }\\n                }\\n                for(int row=1;row<=val;row++){\\n                    if(row+cell[0]>=m){\\n                        break;\\n                    }\\n                    if(cell[0]+row==m-1 && cell[1]==n-1){\\n                        return dist+1;\\n                    }if(grid[row+cell[0]][cell[1]]!=0 && visited[row+cell[0]][cell[1]]==0){\\n                        q.add(new int[]{row+cell[0],cell[1]});\\n                        visited[row+cell[0]][cell[1]]=1;\\n                    }\\n                }\\n                size--;\\n            }\\n            dist++;\\n        }\\n        return -1;\\n    }\\n}\\n```\\nAsk me any doubts related to this.\\nThank YOu.\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumVisitedCells(int[][] grid) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        if(m==1 && n==1){\\n            return 1;\\n        }\\n        Queue<int[]> q=new LinkedList<>();\\n        int[][] visited=new int[m][n];\\n        q.add(new int[]{0,0});\\n\\n        int dist=1;\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            while(size>0){\\n                int[] cell=q.poll();\\n                int val=grid[cell[0]][cell[1]];\\n                for(int col=1;col<=val;col++){\\n                    if(col+cell[1]>=n){\\n                        break;\\n                    }\\n                    if(cell[0]==m-1 && col+cell[1]==n-1){\\n                        return dist+1;\\n                    }\\n                    if(grid[cell[0]][col+cell[1]]!=0 && visited[cell[0]][col+cell[1]]==0){\\n                        q.add(new int[]{cell[0],col+cell[1]});\\n                        visited[cell[0]][col+cell[1]]=1;\\n                    }\\n                }\\n                for(int row=1;row<=val;row++){\\n                    if(row+cell[0]>=m){\\n                        break;\\n                    }\\n                    if(cell[0]+row==m-1 && cell[1]==n-1){\\n                        return dist+1;\\n                    }if(grid[row+cell[0]][cell[1]]!=0 && visited[row+cell[0]][cell[1]]==0){\\n                        q.add(new int[]{row+cell[0],cell[1]});\\n                        visited[row+cell[0]][cell[1]]=1;\\n                    }\\n                }\\n                size--;\\n            }\\n            dist++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398727,
                "title": "bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: `O(V)`\\nThe number of elements in the queue is at most the number of vertices (i.e. V)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(nm + V)` , \\nThe space complexity of the queue is O(V). A 2D Boolean array space complexity is O(nm) \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        \\n        // bfs => TLE\\n        int n = grid.size(), m = grid[0].size();\\n        if(n==1 && m==1) return 1;\\n        queue<vector<int>> q;\\n        q.push({0,0, 1});\\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\\n        visited[0][0] = true;\\n        while(!q.empty()) {\\n            int size = q.size();\\n            while(size--){\\n                vector<int> cur = q.front(); q.pop();\\n                int p = grid[cur[0]][cur[1]];\\n                // cout<<\"Pop (i, j) (\"<<cur[0]<<\", \"<<cur[1]<<\")\"<<\" step:= \"<<cur[2]<<endl;\\n\\n                for(int i=min(cur[0] +p, n-1) ; i>=cur[0] ; i--){\\n                    int j=cur[1];\\n                    if(!visited[i][cur[1]] && grid[i][cur[1]]!=0){\\n                        q.push({i,j, cur[2]+1});\\n                        // cout<<\"visited (i, j) (\"<<i<<\", \"<<j<<\")\"<<\" step:= \"<<cur[2]+1<<endl;\\n                        visited[i][j] = true;\\n                        }\\n                    if(i == n -1 && j==m-1) return cur[2]+1;\\n                }\\n                for(int j=min(cur[1]+p, m-1); j>=cur[1] ; j--) {\\n                    int i =cur[0];\\n                    if(!visited[i][j] && grid[i][j]!=0){\\n                        q.push({i,j, cur[2]+1});\\n                        // cout<<\"visited (i, j) (\"<<i<<\", \"<<j<<\")\"<<\" step:= \"<<cur[2]+1<<endl;\\n                        visited[i][j] = true;\\n                        }\\n                    if(i == n -1 && j==m-1) return cur[2]+1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        \\n        // bfs => TLE\\n        int n = grid.size(), m = grid[0].size();\\n        if(n==1 && m==1) return 1;\\n        queue<vector<int>> q;\\n        q.push({0,0, 1});\\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\\n        visited[0][0] = true;\\n        while(!q.empty()) {\\n            int size = q.size();\\n            while(size--){\\n                vector<int> cur = q.front(); q.pop();\\n                int p = grid[cur[0]][cur[1]];\\n                // cout<<\"Pop (i, j) (\"<<cur[0]<<\", \"<<cur[1]<<\")\"<<\" step:= \"<<cur[2]<<endl;\\n\\n                for(int i=min(cur[0] +p, n-1) ; i>=cur[0] ; i--){\\n                    int j=cur[1];\\n                    if(!visited[i][cur[1]] && grid[i][cur[1]]!=0){\\n                        q.push({i,j, cur[2]+1});\\n                        // cout<<\"visited (i, j) (\"<<i<<\", \"<<j<<\")\"<<\" step:= \"<<cur[2]+1<<endl;\\n                        visited[i][j] = true;\\n                        }\\n                    if(i == n -1 && j==m-1) return cur[2]+1;\\n                }\\n                for(int j=min(cur[1]+p, m-1); j>=cur[1] ; j--) {\\n                    int i =cur[0];\\n                    if(!visited[i][j] && grid[i][j]!=0){\\n                        q.push({i,j, cur[2]+1});\\n                        // cout<<\"visited (i, j) (\"<<i<<\", \"<<j<<\")\"<<\" step:= \"<<cur[2]+1<<endl;\\n                        visited[i][j] = true;\\n                        }\\n                    if(i == n -1 && j==m-1) return cur[2]+1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3398623,
                "title": "bfs-with-pruning",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nbfs with pruning\\n# Approach \\n<!-- Describe your approach to solving the problem. -->\\nbfs \\n# Complexity\\n- Time complexity: n*mlog(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& g) {\\n        int n=g.size();\\n        int m=g[0].size();\\n       vector<set<int>> r(n);\\n       vector<set<int>> c(m);\\n      for(int i=0;i<n;i++)for(int j=0;j<m;j++)r[i].insert(j);\\n      for(int i=0;i<m;i++)for(int j=0;j<n;j++)c[i].insert(j);\\n        r[0].erase(0);\\n        c[0].erase(0);\\n      queue<pair<int,int>> q;\\n        q.push({0,0});\\n        int d=0;\\n        while(q.size()){\\n            int sz=q.size();\\n            d++;\\n            while(sz--){\\n                auto j=q.front();\\n                q.pop();\\n                if((j.first==(n-1))&&(j.second==(m-1)))return d;\\n                int jm=g[j.first][j.second];\\n                auto s=r[j.first].upper_bound(j.second);\\n                \\n                while(s!=r[j.first].end()&&(*s<=j.second+jm)){\\n                    int a=*s;\\n                    q.push({j.first,a});\\n                    c[a].erase(j.first);\\n                    r[j.first].erase(a);\\n                    s=r[j.first].upper_bound(a);\\n                    \\n                }\\n                auto s1=c[j.second].upper_bound(j.first);\\n                \\n                 while(s1!=c[j.second].end()&&(*s1<=j.first+jm)){\\n                     int a=*s1;\\n                    q.push({a,j.second});\\n                    r[a].erase(j.second);\\n                    c[j.second].erase(a);\\n                     \\n                    \\n                    s1=c[j.second].upper_bound(a);\\n                }\\n            }\\n        }\\n          return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& g) {\\n        int n=g.size();\\n        int m=g[0].size();\\n       vector<set<int>> r(n);\\n       vector<set<int>> c(m);\\n      for(int i=0;i<n;i++)for(int j=0;j<m;j++)r[i].insert(j);\\n      for(int i=0;i<m;i++)for(int j=0;j<n;j++)c[i].insert(j);\\n        r[0].erase(0);\\n        c[0].erase(0);\\n      queue<pair<int,int>> q;\\n        q.push({0,0});\\n        int d=0;\\n        while(q.size()){\\n            int sz=q.size();\\n            d++;\\n            while(sz--){\\n                auto j=q.front();\\n                q.pop();\\n                if((j.first==(n-1))&&(j.second==(m-1)))return d;\\n                int jm=g[j.first][j.second];\\n                auto s=r[j.first].upper_bound(j.second);\\n                \\n                while(s!=r[j.first].end()&&(*s<=j.second+jm)){\\n                    int a=*s;\\n                    q.push({j.first,a});\\n                    c[a].erase(j.first);\\n                    r[j.first].erase(a);\\n                    s=r[j.first].upper_bound(a);\\n                    \\n                }\\n                auto s1=c[j.second].upper_bound(j.first);\\n                \\n                 while(s1!=c[j.second].end()&&(*s1<=j.first+jm)){\\n                     int a=*s1;\\n                    q.push({a,j.second});\\n                    r[a].erase(j.second);\\n                    c[j.second].erase(a);\\n                     \\n                    \\n                    s1=c[j.second].upper_bound(a);\\n                }\\n            }\\n        }\\n          return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398622,
                "title": "another-bfs-treak-to-avoid-tle-why-bfs-algorithmic-thinking",
                "content": "Another BFS treak to avoid TLE: check the end condition before the cell is pushed onto queue, NOT when it is popped out. \\nThis can be combined with the other treak introduced here:\\n* https://leetcode.com/problems/minimum-number-of-visited-cells-in-a-grid/discuss/3395745/C%2B%2B-or-BFS-or-Small-Tweak-to-avoid-TLE-or-Easy\\n* https://leetcode.com/problems/minimum-number-of-visited-cells-in-a-grid/discuss/3396509/Easy-BFS-oror-Just-one-simple-modification\\n\\nThere are some posts suggest to use priority queue or set to order the cell to be propagated. Why BFS? \\n* Suppose d is the the answer, then to establish the algorithmic correctness, it is better to exhaustive check all cells with distance<d-1. As BFS propagates, the order those cells do not matter.\\n* Priority queue or set requires sort operations, which hurts time efficiency.\\n* Some heuristics to sort, which may or may not help the time efficiency \\n\\n```\\nint minimumVisitedCells(vector<vector<int>>& grid) {\\n\\tint rs=int(grid.size()), cs=int(grid[0].size());\\n\\tif (rs==1 and cs==1) return 1;\\n\\tvector<vector<bool>> visited(rs,vector<bool>(cs));\\n\\tqueue<int> q;\\n\\tq.push(0);\\n\\tq.push(0);\\n\\tvisited[0][0]=true;\\n\\tint d=0;\\n\\twhile (not q.empty()) {\\n\\t\\t++d;\\n\\t\\tint m=int(q.size())>>1;\\n\\t\\tfor (int i=0; i<m; ++i) {\\n\\t\\t\\tint r0=q.front(); q.pop();\\n\\t\\t\\tint c0=q.front(); q.pop();\\n\\t\\t\\tint g=grid[r0][c0];\\n\\t\\t\\tfor (int k=1; k<=g; ++k) {\\n\\t\\t\\t\\tint c=c0+k;\\n\\t\\t\\t\\tif (c>=cs) break;\\n\\t\\t\\t\\tif (r0==rs-1 and c==cs-1) return d+1;\\n\\t\\t\\t\\tif (visited[r0][c]) continue;\\n\\t\\t\\t\\tvisited[r0][c]=true;\\n\\t\\t\\t\\tq.push(r0);\\n\\t\\t\\t\\tq.push(c);\\n\\t\\t\\t}\\n\\t\\t\\tfor (int k=1; k<=g; ++k) {\\n\\t\\t\\t\\tint r=r0+k;\\n\\t\\t\\t\\tif (r>=rs) break;\\n\\t\\t\\t\\tif (r==rs-1 and c0==cs-1) return d+1;\\n\\t\\t\\t\\tif (visited[r][c0]) continue;\\n\\t\\t\\t\\tvisited[r][c0]=true;\\n\\t\\t\\t\\tq.push(r);\\n\\t\\t\\t\\tq.push(c0);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn -1;\\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nint minimumVisitedCells(vector<vector<int>>& grid) {\\n\\tint rs=int(grid.size()), cs=int(grid[0].size());\\n\\tif (rs==1 and cs==1) return 1;\\n\\tvector<vector<bool>> visited(rs,vector<bool>(cs));\\n\\tqueue<int> q;\\n\\tq.push(0);\\n\\tq.push(0);\\n\\tvisited[0][0]=true;\\n\\tint d=0;\\n\\twhile (not q.empty()) {\\n\\t\\t++d;\\n\\t\\tint m=int(q.size())>>1;\\n\\t\\tfor (int i=0; i<m; ++i) {\\n\\t\\t\\tint r0=q.front(); q.pop();\\n\\t\\t\\tint c0=q.front(); q.pop();\\n\\t\\t\\tint g=grid[r0][c0];\\n\\t\\t\\tfor (int k=1; k<=g; ++k) {\\n\\t\\t\\t\\tint c=c0+k;\\n\\t\\t\\t\\tif (c>=cs) break;\\n\\t\\t\\t\\tif (r0==rs-1 and c==cs-1) return d+1;\\n\\t\\t\\t\\tif (visited[r0][c]) continue;\\n\\t\\t\\t\\tvisited[r0][c]=true;\\n\\t\\t\\t\\tq.push(r0);\\n\\t\\t\\t\\tq.push(c);\\n\\t\\t\\t}\\n\\t\\t\\tfor (int k=1; k<=g; ++k) {\\n\\t\\t\\t\\tint r=r0+k;\\n\\t\\t\\t\\tif (r>=rs) break;\\n\\t\\t\\t\\tif (r==rs-1 and c0==cs-1) return d+1;\\n\\t\\t\\t\\tif (visited[r][c0]) continue;\\n\\t\\t\\t\\tvisited[r][c0]=true;\\n\\t\\t\\t\\tq.push(r);\\n\\t\\t\\t\\tq.push(c0);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3398497,
                "title": "simple-right-and-down-bfs-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass pair{\\n    int first;\\n    int sec;\\n    int thir;\\n    \\n    pair(int first, int sec, int thir){\\n        \\n        this.first=first;\\n        this.sec=sec;\\n        this.thir=thir;\\n    }\\n}\\nclass Solution {\\n    public int minimumVisitedCells(int[][] grid) {\\n        \\n        \\n        int n=grid.length;\\n        int m=grid[0].length;\\n        \\n        if(n==1 && m==1) return 1;\\n        \\n        \\n        Queue<pair> q=new LinkedList<>();\\n        \\n        q.add(new pair(0,0,1));\\n        \\n        int vis[][]=new int[n][m];\\n        vis[0][0]=1;\\n        \\n        while(!q.isEmpty()){\\n            \\n            int row=q.peek().first;\\n            int col=q.peek().sec;\\n            int step=q.peek().thir;\\n            q.remove();\\n            \\n            \\n            int val=grid[row][col];\\n            \\n      \\n            \\n            for(int i=1;i<=val;i++){\\n                \\n                if(row==n-1 && col+i==m-1) return step+1;\\n                if(col+i>=m) break;\\n              \\n                if(grid[row][col+i]!=0 && vis[row][col+i]==0){\\n                    vis[row][col+i]=1;\\n                    q.add(new pair(row,col+i,step+1));\\n                }\\n            }\\n            \\n            \\n             for(int i=1;i<=val;i++){\\n                \\n                 if(row+i==n-1 && col==m-1) return step+1;\\n                if(row+i>=n) break;\\n                \\n                if(grid[row+i][col]!=0 && vis[row+i][col]==0){\\n                    vis[row+i][col]=1;\\n                    q.add(new pair(row+i,col,step+1));\\n                }\\n            }\\n            \\n            \\n            \\n            \\n        }\\n        \\n        return -1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass pair{\\n    int first;\\n    int sec;\\n    int thir;\\n    \\n    pair(int first, int sec, int thir){\\n        \\n        this.first=first;\\n        this.sec=sec;\\n        this.thir=thir;\\n    }\\n}\\nclass Solution {\\n    public int minimumVisitedCells(int[][] grid) {\\n        \\n        \\n        int n=grid.length;\\n        int m=grid[0].length;\\n        \\n        if(n==1 && m==1) return 1;\\n        \\n        \\n        Queue<pair> q=new LinkedList<>();\\n        \\n        q.add(new pair(0,0,1));\\n        \\n        int vis[][]=new int[n][m];\\n        vis[0][0]=1;\\n        \\n        while(!q.isEmpty()){\\n            \\n            int row=q.peek().first;\\n            int col=q.peek().sec;\\n            int step=q.peek().thir;\\n            q.remove();\\n            \\n            \\n            int val=grid[row][col];\\n            \\n      \\n            \\n            for(int i=1;i<=val;i++){\\n                \\n                if(row==n-1 && col+i==m-1) return step+1;\\n                if(col+i>=m) break;\\n              \\n                if(grid[row][col+i]!=0 && vis[row][col+i]==0){\\n                    vis[row][col+i]=1;\\n                    q.add(new pair(row,col+i,step+1));\\n                }\\n            }\\n            \\n            \\n             for(int i=1;i<=val;i++){\\n                \\n                 if(row+i==n-1 && col==m-1) return step+1;\\n                if(row+i>=n) break;\\n                \\n                if(grid[row+i][col]!=0 && vis[row+i][col]==0){\\n                    vis[row+i][col]=1;\\n                    q.add(new pair(row+i,col,step+1));\\n                }\\n            }\\n            \\n            \\n            \\n            \\n        }\\n        \\n        return -1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398407,
                "title": "bfs-dp-with-java-and-i-have-a-question-help",
                "content": "So, idea is easy, the important things is how to reduce the duplicate computation\\nAnalyze the bfs, we could some problem. We poll one node, and put new node into the queue, so their will be a lot of dupicates in the queue, so we need to get rid of it. And another point is easy a memory to store the step access this node\\n\\nAnd I have a question, if I change the two continue in the inner for loop to the break, it will pass 1054/1055 case, i dont know why the break  is fit for all other case except this one.\\n```\\nclass Solution {\\n    public class Node{\\n        int i;\\n        int j;\\n        Node(){}\\n        Node(int i, int j){\\n            this.i=i;\\n            this.j=j;\\n        }\\n    }\\n    public int minimumVisitedCells(int[][] grid) {\\n        int[][] dp = new int[grid.length][grid[0].length];\\n        LinkedList<Node> q = new LinkedList<>();\\n        q.add(new Node(0,0));\\n        int step=0;\\n        dp[0][0]=1;\\n        while(!q.isEmpty()){\\n            step++;\\n            int size=q.size();\\n            for(int i=0;i<size;i++){\\n                Node node = q.poll();\\n                if(node.i>=grid.length||node.j>=grid[0].length)\\n                    continue;\\n                int add = grid[node.i][node.j];\\n                for(int j=Math.min(add,grid.length-node.i-1);j>=1;j--){\\n                    if(dp[node.i+j][node.j]!=0)\\n                        continue;\\n                    q.add(new Node(node.i+j,node.j));\\n                    dp[node.i+j][node.j]=step+1;\\n                }\\n                for(int j=Math.min(add,grid[0].length-node.j-1);j>=1;j--){\\n                    if(dp[node.i][node.j+j]!=0)\\n                        continue;\\n                    q.add(new Node(node.i,node.j+j));\\n                    dp[node.i][node.j+j]=step+1;}\\n                if(dp[grid.length-1][grid[0].length-1]!=0)\\n                    return dp[grid.length-1][grid[0].length-1];\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public class Node{\\n        int i;\\n        int j;\\n        Node(){}\\n        Node(int i, int j){\\n            this.i=i;\\n            this.j=j;\\n        }\\n    }\\n    public int minimumVisitedCells(int[][] grid) {\\n        int[][] dp = new int[grid.length][grid[0].length];\\n        LinkedList<Node> q = new LinkedList<>();\\n        q.add(new Node(0,0));\\n        int step=0;\\n        dp[0][0]=1;\\n        while(!q.isEmpty()){\\n            step++;\\n            int size=q.size();\\n            for(int i=0;i<size;i++){\\n                Node node = q.poll();\\n                if(node.i>=grid.length||node.j>=grid[0].length)\\n                    continue;\\n                int add = grid[node.i][node.j];\\n                for(int j=Math.min(add,grid.length-node.i-1);j>=1;j--){\\n                    if(dp[node.i+j][node.j]!=0)\\n                        continue;\\n                    q.add(new Node(node.i+j,node.j));\\n                    dp[node.i+j][node.j]=step+1;\\n                }\\n                for(int j=Math.min(add,grid[0].length-node.j-1);j>=1;j--){\\n                    if(dp[node.i][node.j+j]!=0)\\n                        continue;\\n                    q.add(new Node(node.i,node.j+j));\\n                    dp[node.i][node.j+j]=step+1;}\\n                if(dp[grid.length-1][grid[0].length-1]!=0)\\n                    return dp[grid.length-1][grid[0].length-1];\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398175,
                "title": "multi-sided-linked-list",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMany Dijkstra-like solutions have hole and thus are incorrect. This solution is based on a mesh of linked-list so no whole will remain. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a 2-D linked list. Delete the nodes in proper order to avoid repeated visiting.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(mn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(mn)\\n\\n# Code\\n```\\nclass MyNode:\\n    def __init__(self, i, j):\\n        self.i = i\\n        self.j = j\\n        self.up = None\\n        self.down = None\\n        self.left = None\\n        self.right = None\\n        self.visited = False\\n    \\n    def __repr__(self):\\n        return f\\'{self.i}, {self.j}\\'\\n    \\n    def remove(self):\\n        assert self.visited\\n        if self.up:\\n            self.up.down = self.down\\n        if self.down:\\n            self.down.up = self.up\\n        if self.left:\\n            self.left.right = self.right\\n        if self.right:\\n            self.right.left = self.left\\n\\n\\nclass Solution:\\n    def get_nbs(self, nd):\\n        nbs = []\\n        i = nd.i\\n        j = nd.j\\n        k = self.grid[i][j]\\n\\n        cur = nd\\n        while cur.right and cur.right.j <= j+k:\\n            cur = cur.right\\n            if cur.visited:\\n                continue\\n            nbs.append(cur)\\n            cur.visited = True\\n        \\n        cur = nd\\n        while cur.down and cur.down.i <= i+k:\\n            cur = cur.down\\n            if cur.visited:\\n                continue\\n            nbs.append(cur)\\n            cur.visited = True\\n        return nbs\\n\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        self.m = len(grid)\\n        self.n = len(grid[0])\\n        step = 1\\n        if self.m == self.n == 1:\\n            return step\\n        self.grid = grid\\n        self.nodes = [[MyNode(i, j) for j in range(self.n)] for i in range(self.m)]\\n        for i in range(self.m):\\n            for j in range(self.n):\\n                node = self.nodes[i][j]\\n                if i < self.m-1:\\n                    node.down = self.nodes[i+1][j]\\n                    self.nodes[i+1][j].up = node\\n                if j < self.n-1:\\n                    node.right = self.nodes[i][j+1]\\n                    self.nodes[i][j+1].left = node\\n        \\n        _d = 0\\n        fron = [(0, _d, self.nodes[0][0])]\\n        self.nodes[0][0].visited = True\\n        while fron:\\n            step += 1\\n            if step > self.m + self.n + 1:\\n                return -1\\n            new_fron = []\\n            for _, _, nd in fron:\\n                for nnd in self.get_nbs(nd):\\n                    if nnd.i == self.m-1 and nnd.j == self.n-1:\\n                        return step\\n                    _d += 1\\n                    new_fron.append((-nnd.i-nnd.j, _d, nnd))\\n                nd.remove()\\n            new_fron.sort()\\n            fron = new_fron \\n        print(step)\\n        return -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Doubly-Linked List"
                ],
                "code": "```\\nclass MyNode:\\n    def __init__(self, i, j):\\n        self.i = i\\n        self.j = j\\n        self.up = None\\n        self.down = None\\n        self.left = None\\n        self.right = None\\n        self.visited = False\\n    \\n    def __repr__(self):\\n        return f\\'{self.i}, {self.j}\\'\\n    \\n    def remove(self):\\n        assert self.visited\\n        if self.up:\\n            self.up.down = self.down\\n        if self.down:\\n            self.down.up = self.up\\n        if self.left:\\n            self.left.right = self.right\\n        if self.right:\\n            self.right.left = self.left\\n\\n\\nclass Solution:\\n    def get_nbs(self, nd):\\n        nbs = []\\n        i = nd.i\\n        j = nd.j\\n        k = self.grid[i][j]\\n\\n        cur = nd\\n        while cur.right and cur.right.j <= j+k:\\n            cur = cur.right\\n            if cur.visited:\\n                continue\\n            nbs.append(cur)\\n            cur.visited = True\\n        \\n        cur = nd\\n        while cur.down and cur.down.i <= i+k:\\n            cur = cur.down\\n            if cur.visited:\\n                continue\\n            nbs.append(cur)\\n            cur.visited = True\\n        return nbs\\n\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        self.m = len(grid)\\n        self.n = len(grid[0])\\n        step = 1\\n        if self.m == self.n == 1:\\n            return step\\n        self.grid = grid\\n        self.nodes = [[MyNode(i, j) for j in range(self.n)] for i in range(self.m)]\\n        for i in range(self.m):\\n            for j in range(self.n):\\n                node = self.nodes[i][j]\\n                if i < self.m-1:\\n                    node.down = self.nodes[i+1][j]\\n                    self.nodes[i+1][j].up = node\\n                if j < self.n-1:\\n                    node.right = self.nodes[i][j+1]\\n                    self.nodes[i][j+1].left = node\\n        \\n        _d = 0\\n        fron = [(0, _d, self.nodes[0][0])]\\n        self.nodes[0][0].visited = True\\n        while fron:\\n            step += 1\\n            if step > self.m + self.n + 1:\\n                return -1\\n            new_fron = []\\n            for _, _, nd in fron:\\n                for nnd in self.get_nbs(nd):\\n                    if nnd.i == self.m-1 and nnd.j == self.n-1:\\n                        return step\\n                    _d += 1\\n                    new_fron.append((-nnd.i-nnd.j, _d, nnd))\\n                nd.remove()\\n            new_fron.sort()\\n            fron = new_fron \\n        print(step)\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398112,
                "title": "easy-c-bfs-dijikstra-alorithm-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dis(m,vector<int>(n,1e9));\\n        \\n        //priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>> pq;\\n        queue<pair<int,pair<int,int>>> pq;\\n        dis[0][0]=0;\\n        \\n        pq.push({1,{0,0}});\\n        \\n        while(pq.size()){\\n            \\n            auto top = pq.front();\\n            pq.pop();\\n            \\n            int d = top.first;\\n            int r=top.second.first, c = top.second.second;\\n            \\n            if(r==m-1 and c==n-1)\\n                return d;// this check is just for testcae grid = [[0]]\\n            \\n            for(int k=c+1;k<=grid[r][c]+c;k++){\\n\\n                if(k>=0 and k<n){\\n                    \\n                    if(dis[r][k] > d + 1){\\n\\n                        dis[r][k] = d+1;\\n\\n                        if(r==m-1 and k==n-1)\\n                        return d+1;\\n\\n                        pq.push({d+1,{r,k}});\\n                    }\\n                    \\n                }\\n                \\n            }\\n            \\n            for(int k=r+1;k<=grid[r][c]+r;k++){\\n                if(k>=0 and k<m){\\n                    \\n                    if(dis[k][c] > d + 1){\\n\\n                        dis[k][c] = d+1;\\n\\n                        if(k==m-1 and c==n-1)\\n                        return d+1;\\n\\n                        pq.push({d+1,{k,c}});\\n                    }\\n                    \\n                }\\n            }\\n            \\n        }\\n        \\n        return dis[m-1][n-1]>=1e9?-1:dis[m-1][n-1];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dis(m,vector<int>(n,1e9));\\n        \\n        //priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>> pq;\\n        queue<pair<int,pair<int,int>>> pq;\\n        dis[0][0]=0;\\n        \\n        pq.push({1,{0,0}});\\n        \\n        while(pq.size()){\\n            \\n            auto top = pq.front();\\n            pq.pop();\\n            \\n            int d = top.first;\\n            int r=top.second.first, c = top.second.second;\\n            \\n            if(r==m-1 and c==n-1)\\n                return d;// this check is just for testcae grid = [[0]]\\n            \\n            for(int k=c+1;k<=grid[r][c]+c;k++){\\n\\n                if(k>=0 and k<n){\\n                    \\n                    if(dis[r][k] > d + 1){\\n\\n                        dis[r][k] = d+1;\\n\\n                        if(r==m-1 and k==n-1)\\n                        return d+1;\\n\\n                        pq.push({d+1,{r,k}});\\n                    }\\n                    \\n                }\\n                \\n            }\\n            \\n            for(int k=r+1;k<=grid[r][c]+r;k++){\\n                if(k>=0 and k<m){\\n                    \\n                    if(dis[k][c] > d + 1){\\n\\n                        dis[k][c] = d+1;\\n\\n                        if(k==m-1 and c==n-1)\\n                        return d+1;\\n\\n                        pq.push({d+1,{k,c}});\\n                    }\\n                    \\n                }\\n            }\\n            \\n        }\\n        \\n        return dis[m-1][n-1]>=1e9?-1:dis[m-1][n-1];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397975,
                "title": "finally-got-o-n-m-solution-after-8-hrs",
                "content": "# Intuition\\nit resembels something with frog jump dp problem\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size(), m = grid[0].size(), i, j, moves = 1, k, maxMove, newi, newj;\\n        \\n        queue<int> x, y;\\n        vector<vector<int>> visRow(n, vector<int> (m, 0));\\n        vector<vector<int>> visCol(n, vector<int> (m, 0));\\n\\n        x.push(0); y.push(0);\\n        visRow[0][0] = 1;\\n        visCol[0][0] = 1;\\n        while(x.size())\\n        {\\n            k = x.size();\\n            while(k--)\\n            {\\n                i = x.front(); j = y.front();\\n                x.pop(); y.pop();\\n                \\n                if(i == n - 1 && j == m - 1)\\n                {\\n                    return moves;\\n                }\\n                \\n                // rightward movement\\n                \\n                maxMove = min(grid[i][j] + j, m - 1);\\n                newj = maxMove;\\n                newi = i;\\n                \\n                for(; newj > j; newj--)\\n                {\\n                    if(visRow[newi][newj] == 1)\\n                        break;\\n                    x.push(newi); y.push(newj);\\n                    visRow[newi][newj] = 1;\\n                }\\n                \\n                // downward movement\\n                \\n                maxMove = min(grid[i][j] + i, n - 1);\\n                newi = maxMove;\\n                newj = j;\\n                \\n                for( ; newi > i; newi--)\\n                {\\n                    if(visCol[newi][newj] == 1)\\n                        break;\\n                    x.push(newi); y.push(newj);\\n                    visCol[newi][newj] = 1;\\n                }\\n            }\\n            moves++;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```\\n\\n\\nFeel free to comment below in case of any query :) or suggestions :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size(), m = grid[0].size(), i, j, moves = 1, k, maxMove, newi, newj;\\n        \\n        queue<int> x, y;\\n        vector<vector<int>> visRow(n, vector<int> (m, 0));\\n        vector<vector<int>> visCol(n, vector<int> (m, 0));\\n\\n        x.push(0); y.push(0);\\n        visRow[0][0] = 1;\\n        visCol[0][0] = 1;\\n        while(x.size())\\n        {\\n            k = x.size();\\n            while(k--)\\n            {\\n                i = x.front(); j = y.front();\\n                x.pop(); y.pop();\\n                \\n                if(i == n - 1 && j == m - 1)\\n                {\\n                    return moves;\\n                }\\n                \\n                // rightward movement\\n                \\n                maxMove = min(grid[i][j] + j, m - 1);\\n                newj = maxMove;\\n                newi = i;\\n                \\n                for(; newj > j; newj--)\\n                {\\n                    if(visRow[newi][newj] == 1)\\n                        break;\\n                    x.push(newi); y.push(newj);\\n                    visRow[newi][newj] = 1;\\n                }\\n                \\n                // downward movement\\n                \\n                maxMove = min(grid[i][j] + i, n - 1);\\n                newi = maxMove;\\n                newj = j;\\n                \\n                for( ; newi > i; newi--)\\n                {\\n                    if(visCol[newi][newj] == 1)\\n                        break;\\n                    x.push(newi); y.push(newj);\\n                    visCol[newi][newj] = 1;\\n                }\\n            }\\n            moves++;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397929,
                "title": "c-bfs-done-correctly-using-red-black-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is similar to last week\\'s contest hard problem (Minimum Reverse Operations)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing sorted set (balanced binary search tree) to store all unvisited cells so we can avoid unnecessary loops.\\n\\nhttps://leetcode.com/problems/minimum-reverse-operations/solutions/3368273/c-o-nlogn-solution-with-comments-bfs-floodfill-bst-optimization/?orderBy=most_votes\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(m * n * (\\\\log m + \\\\log n))$$\\n\\nThere are at most $$m*n$$ pops, each pop does four binary searches which take $$O(2\\\\log m + 2\\\\log n)$$ time, there are at most $$m*n$$ pushes, each push erases two elements from the ordered sets which take $$O(\\\\log m + \\\\log n)$$ time, so in total, the time complexity is $$O(m * n * (\\\\log m + \\\\log n))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(m * n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        if (m == 1 && n == 1) return 1;\\n        vector<set<int>> rows(m), cols(n);\\n        for (int j = 0; j < n; j++) rows[0].insert(j);\\n        for (int i = 1; i < m; i++) rows[i] = rows[0];\\n        for (int i = 0; i < m; i++) cols[0].insert(i);\\n        for (int j = 1; j < n; j++) cols[j] = cols[0];\\n        queue<pair<int, int>> q;\\n        q.push(make_pair(0, 0));\\n        rows[0].erase(0);\\n        cols[0].erase(0);\\n        int d = 1;\\n        while (!q.empty()) {\\n            d += 1;\\n            int sz = q.size();\\n            while (sz-- > 0) {\\n                auto [x, y] = q.front();\\n                q.pop();\\n                int step = grid[x][y];\\n                // go right\\n                auto it_low = rows[x].upper_bound(y);\\n                auto it_high = rows[x].upper_bound(y + step);\\n                for (auto it = it_low; it != it_high; it++) {\\n                    if (x == m - 1 && *it == n - 1) return d;\\n                    q.push(make_pair(x, *it));\\n                    cols[*it].erase(x);\\n                }\\n                rows[x].erase(it_low, it_high);\\n                // go down\\n                it_low = cols[y].upper_bound(x);\\n                it_high = cols[y].upper_bound(x + step);\\n                for (auto it = it_low; it != it_high; it++) {\\n                    if (*it == m - 1 && y == n - 1) return d;\\n                    q.push(make_pair(*it, y));\\n                    rows[*it].erase(y);\\n                }\\n                cols[y].erase(it_low, it_high);\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        if (m == 1 && n == 1) return 1;\\n        vector<set<int>> rows(m), cols(n);\\n        for (int j = 0; j < n; j++) rows[0].insert(j);\\n        for (int i = 1; i < m; i++) rows[i] = rows[0];\\n        for (int i = 0; i < m; i++) cols[0].insert(i);\\n        for (int j = 1; j < n; j++) cols[j] = cols[0];\\n        queue<pair<int, int>> q;\\n        q.push(make_pair(0, 0));\\n        rows[0].erase(0);\\n        cols[0].erase(0);\\n        int d = 1;\\n        while (!q.empty()) {\\n            d += 1;\\n            int sz = q.size();\\n            while (sz-- > 0) {\\n                auto [x, y] = q.front();\\n                q.pop();\\n                int step = grid[x][y];\\n                // go right\\n                auto it_low = rows[x].upper_bound(y);\\n                auto it_high = rows[x].upper_bound(y + step);\\n                for (auto it = it_low; it != it_high; it++) {\\n                    if (x == m - 1 && *it == n - 1) return d;\\n                    q.push(make_pair(x, *it));\\n                    cols[*it].erase(x);\\n                }\\n                rows[x].erase(it_low, it_high);\\n                // go down\\n                it_low = cols[y].upper_bound(x);\\n                it_high = cols[y].upper_bound(x + step);\\n                for (auto it = it_low; it != it_high; it++) {\\n                    if (*it == m - 1 && y == n - 1) return d;\\n                    q.push(make_pair(*it, y));\\n                    rows[*it].erase(y);\\n                }\\n                cols[y].erase(it_low, it_high);\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397807,
                "title": "python-3-two-priority-queues-hint-solution",
                "content": "```\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        \\n        m, n = len(grid), len(grid[0])\\n        \\n        dp = [[float(\\'inf\\')] * n for _ in range(m)]\\n        dp[0][0] = 1\\n        \\n        # priority queues store the minimum dist for each row cell or col cell\\n        r, c = defaultdict(list), defaultdict(list)\\n        \\n        for i, j in product(range(m), range(n)):\\n            \\n            # propagate min dist from cell in previous row but same col\\n            while r[j] and r[j][0][1] < i:\\n                heappop(r[j])\\n            if r[j]:\\n                dp[i][j] = min(dp[i][j], r[j][0][0] + 1)\\n            \\n            # propagate min dist from cell in previous col but same row\\n            while c[i] and c[i][0][1] < j:\\n                heappop(c[i])\\n            if c[i]:\\n                dp[i][j] = min(dp[i][j], c[i][0][0] + 1)\\n                \\n            heappush(r[j], (dp[i][j], i + grid[i][j]))\\n            heappush(c[i], (dp[i][j], j + grid[i][j]))\\n        \\n        return dp[-1][-1] if dp[-1][-1] < float(\"inf\") else -1\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        \\n        m, n = len(grid), len(grid[0])\\n        \\n        dp = [[float(\\'inf\\')] * n for _ in range(m)]\\n        dp[0][0] = 1\\n        \\n        # priority queues store the minimum dist for each row cell or col cell\\n        r, c = defaultdict(list), defaultdict(list)\\n        \\n        for i, j in product(range(m), range(n)):\\n            \\n            # propagate min dist from cell in previous row but same col\\n            while r[j] and r[j][0][1] < i:\\n                heappop(r[j])\\n            if r[j]:\\n                dp[i][j] = min(dp[i][j], r[j][0][0] + 1)\\n            \\n            # propagate min dist from cell in previous col but same row\\n            while c[i] and c[i][0][1] < j:\\n                heappop(c[i])\\n            if c[i]:\\n                dp[i][j] = min(dp[i][j], c[i][0][0] + 1)\\n                \\n            heappush(r[j], (dp[i][j], i + grid[i][j]))\\n            heappush(c[i], (dp[i][j], j + grid[i][j]))\\n        \\n        return dp[-1][-1] if dp[-1][-1] < float(\"inf\") else -1\\n",
                "codeTag": "Java"
            },
            {
                "id": 3397740,
                "title": "python-bfs-with-sorted-list",
                "content": "# Intuition\\nwrite this solution for recording my thought.\\n\\nfirst, I started with normal BFS and got TLE\\n```py\\ndef minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        queue = deque([(0, 0)])\\n        visited = set([0, 0])\\n\\n        step = 0\\n        while queue:\\n            for _ in range(len(queue)):\\n                i, j = queue.popleft()\\n                if i == m-1 and j == n-1:\\n                    return step + 1\\n\\n                for k in range(j+1, min(n, grid[i][j]+j+1)):\\n                    if (i,k) in visited: continue\\n                    visited.add((i, k))\\n                    queue.append((i, k))\\n                for k in range(i+1, min(m, grid[i][j]+i+1)):\\n                    if (k, j) in visited: continue\\n                    visited.add((k, j))\\n                    queue.append((k, j))\\n            step += 1\\n        return -1\\n```\\n\\nthen, I started to think...\\nthose 2 nested loop took to much time to run even I use a visited set, it still possibly to iterate all iteration repeatedly.\\n\\nthen, I thought I could use a **Hahsset** to store valid cell first, then remove it afterwards, just like **visited** hashset doing.\\n\\nbut this time, I only iterate valid cells\\n\\n```py\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        queue = deque([(0, 0, 1)])\\n\\n        rowSet, colSet = [set() for _ in range(m)], [set() for _ in range(n)]\\n        for i in range(m):\\n            for j in range(n):\\n                rowSet[i].add(j)\\n                colSet[j].add(i)\\n\\n        while queue:\\n            for _ in range(len(queue)):\\n                i, j, step = queue.popleft()\\n                if i == m-1 and j == n-1:\\n                    return step\\n\\n                tmp = rowSet[i].copy()\\n                for k in tmp:\\n                    if k <= j or k > grid[i][j]+j or k >= n: continue\\n                    rowSet[i].remove(k)\\n                    queue.append((i, k, step+1))\\n\\n                tmp = colSet[j].copy()\\n                for k in tmp:\\n                    if k <= i or k > grid[i][j]+i or k >= m: continue\\n                    colSet[j].remove(k)\\n                    queue.append((k, j, step+1))\\n        return -1\\n```\\n\\nbut still got TLE.\\n\\nthen, I tried to optimize iteration by **Binary search**.\\n\\nfor each BFS iteration, k ranges **from j+1 to grid[i][j]+j** and **from i+1 to grid[i][j]+i**, I can use bisect_right to search these 4 index with **SortedList**.\\n\\nand based on **Hashset** idea, I could still remove visited index from SortedList afterwards.\\n\\nsince I can\\'t remove during iteration, I store all the visited indexes in removeList and remove all these indexes afterwards.\\n\\n```py\\nfrom sortedcontainers import SortedList\\n  def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n      m, n = len(grid), len(grid[0])\\n      queue = deque([(0, 0, 1)])\\n\\n      rowSL, colSL = [SortedList() for _ in range(m)], [SortedList() for _ in range(n)]\\n      for i in range(m):\\n          for j in range(n):\\n              rowSL[i].add(j)\\n              colSL[j].add(i)\\n\\n      while queue:\\n          for _ in range(len(queue)):\\n              i, j, step = queue.popleft()\\n              if i == m-1 and j == n-1:\\n                  return step\\n\\n              start = rowSL[i].bisect_right(j)\\n              end = rowSL[i].bisect_right(grid[i][j]+j)\\n              removeList = []\\n              for k in range(start, end):\\n                  queue.append((i, rowSL[i][k], step+1))\\n                  removeList.append(rowSL[i][k])\\n              for num in removeList:\\n                  rowSL[i].remove(num)\\n\\n              start = colSL[j].bisect_right(i)\\n              end = colSL[j].bisect_right(grid[i][j]+i)\\n              removeList = []\\n              for k in range(start, end):\\n                  queue.append((colSL[j][k], j, step+1))\\n                  removeList.append(colSL[j][k])\\n              for num in removeList:\\n                  colSL[j].remove(num)\\n      return -1\\n```\\n\\nstill got TLE with all test cases passed.\\n\\nbut I thought it\\'s very close to get accepted!\\n\\nafter observation and debuging, I realized that for every cell in my removeList:\\n- if I removed **(i, k)** from `rowSL`, I must also remove **(i, k)** from `colSL`\\n- it\\'s same for removing **(k, j)**\\n\\nafter that, finally got accepted.\\n\\nit took me a lot of time to solve and I just saw someone write exact the same solution and even more concise 11 hours ago. [check @tojuna\\'s solution here](https://leetcode.com/problems/minimum-number-of-visited-cells-in-a-grid/solutions/3395709/python3-sortedlist-bfs/).\\n\\n# Code\\n```py\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n\\n        rowSL, colSL = [SortedList() for _ in range(m)], [SortedList() for _ in range(n)]\\n        for i in range(m):\\n            for j in range(n):\\n                rowSL[i].add(j)\\n                colSL[j].add(i)\\n\\n        queue = deque([(0, 0, 1)])\\n        rowSL[0].remove(0)\\n        colSL[0].remove(0)\\n        while queue:\\n            for _ in range(len(queue)):\\n                i, j, step = queue.popleft()\\n                if i == m-1 and j == n-1:\\n                    return step\\n\\n                start = rowSL[i].bisect_right(j)\\n                end = rowSL[i].bisect_right(grid[i][j]+j)\\n                removeList = []\\n                for k in range(start, end):\\n                    queue.append((i, rowSL[i][k], step+1))\\n                    removeList.append(rowSL[i][k])\\n                for k in removeList:\\n                    rowSL[i].remove(k)\\n                    colSL[k].remove(i)\\n\\n                start = colSL[j].bisect_right(i)\\n                end = colSL[j].bisect_right(grid[i][j]+i)\\n                removeList = []\\n                for k in range(start, end):\\n                    queue.append((colSL[j][k], j, step+1))\\n                    removeList.append(colSL[j][k])\\n                for k in removeList:\\n                    colSL[j].remove(k)\\n                    rowSL[k].remove(j)\\n        return -1\\n```\\n\\n# Complexity\\n- Time complexity:\\n$$O(mnlog(mn))$$\\n\\n- Space complexity:\\n$$O(mn)$$\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```py\\ndef minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        queue = deque([(0, 0)])\\n        visited = set([0, 0])\\n\\n        step = 0\\n        while queue:\\n            for _ in range(len(queue)):\\n                i, j = queue.popleft()\\n                if i == m-1 and j == n-1:\\n                    return step + 1\\n\\n                for k in range(j+1, min(n, grid[i][j]+j+1)):\\n                    if (i,k) in visited: continue\\n                    visited.add((i, k))\\n                    queue.append((i, k))\\n                for k in range(i+1, min(m, grid[i][j]+i+1)):\\n                    if (k, j) in visited: continue\\n                    visited.add((k, j))\\n                    queue.append((k, j))\\n            step += 1\\n        return -1\\n```\n```py\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        queue = deque([(0, 0, 1)])\\n\\n        rowSet, colSet = [set() for _ in range(m)], [set() for _ in range(n)]\\n        for i in range(m):\\n            for j in range(n):\\n                rowSet[i].add(j)\\n                colSet[j].add(i)\\n\\n        while queue:\\n            for _ in range(len(queue)):\\n                i, j, step = queue.popleft()\\n                if i == m-1 and j == n-1:\\n                    return step\\n\\n                tmp = rowSet[i].copy()\\n                for k in tmp:\\n                    if k <= j or k > grid[i][j]+j or k >= n: continue\\n                    rowSet[i].remove(k)\\n                    queue.append((i, k, step+1))\\n\\n                tmp = colSet[j].copy()\\n                for k in tmp:\\n                    if k <= i or k > grid[i][j]+i or k >= m: continue\\n                    colSet[j].remove(k)\\n                    queue.append((k, j, step+1))\\n        return -1\\n```\n```py\\nfrom sortedcontainers import SortedList\\n  def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n      m, n = len(grid), len(grid[0])\\n      queue = deque([(0, 0, 1)])\\n\\n      rowSL, colSL = [SortedList() for _ in range(m)], [SortedList() for _ in range(n)]\\n      for i in range(m):\\n          for j in range(n):\\n              rowSL[i].add(j)\\n              colSL[j].add(i)\\n\\n      while queue:\\n          for _ in range(len(queue)):\\n              i, j, step = queue.popleft()\\n              if i == m-1 and j == n-1:\\n                  return step\\n\\n              start = rowSL[i].bisect_right(j)\\n              end = rowSL[i].bisect_right(grid[i][j]+j)\\n              removeList = []\\n              for k in range(start, end):\\n                  queue.append((i, rowSL[i][k], step+1))\\n                  removeList.append(rowSL[i][k])\\n              for num in removeList:\\n                  rowSL[i].remove(num)\\n\\n              start = colSL[j].bisect_right(i)\\n              end = colSL[j].bisect_right(grid[i][j]+i)\\n              removeList = []\\n              for k in range(start, end):\\n                  queue.append((colSL[j][k], j, step+1))\\n                  removeList.append(colSL[j][k])\\n              for num in removeList:\\n                  colSL[j].remove(num)\\n      return -1\\n```\n```py\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n\\n        rowSL, colSL = [SortedList() for _ in range(m)], [SortedList() for _ in range(n)]\\n        for i in range(m):\\n            for j in range(n):\\n                rowSL[i].add(j)\\n                colSL[j].add(i)\\n\\n        queue = deque([(0, 0, 1)])\\n        rowSL[0].remove(0)\\n        colSL[0].remove(0)\\n        while queue:\\n            for _ in range(len(queue)):\\n                i, j, step = queue.popleft()\\n                if i == m-1 and j == n-1:\\n                    return step\\n\\n                start = rowSL[i].bisect_right(j)\\n                end = rowSL[i].bisect_right(grid[i][j]+j)\\n                removeList = []\\n                for k in range(start, end):\\n                    queue.append((i, rowSL[i][k], step+1))\\n                    removeList.append(rowSL[i][k])\\n                for k in removeList:\\n                    rowSL[i].remove(k)\\n                    colSL[k].remove(i)\\n\\n                start = colSL[j].bisect_right(i)\\n                end = colSL[j].bisect_right(grid[i][j]+i)\\n                removeList = []\\n                for k in range(start, end):\\n                    queue.append((colSL[j][k], j, step+1))\\n                    removeList.append(colSL[j][k])\\n                for k in removeList:\\n                    colSL[j].remove(k)\\n                    rowSL[k].remove(j)\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397664,
                "title": "optimised-dp-using-priority-queue",
                "content": "# Intuition to the DP code that gives TLE\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem is easily solvable using naive DP but gives TLE.\\nThen we will try to optimize the solution.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet, dp[i][j] denote the steps required to reach (i, j) from (0, 0)\\nBase case dp[0][0] = 0,\\nLet\\'s state the transitions,\\nIf we are at (i, j)th cell, we can reach cell (i, j) either from ith row or the jth column, we will take minimum of both. Formally,\\n\\ncase_1 = min([dp[i][k] for k in range(j) if j <= a[i][k] + k] + [INF])\\ncase_2 = min([dp[k][j] for k in range(i) if i <= a[k][j] + k] + [INF])\\n\\ndp[i][j] = 1 + min(case_1, case2)\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n * m * (n + m))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n * m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n               \\nINF = 10 ** 9\\n\\nclass Solution:\\n    def minimumVisitedCells(self, a: List[List[int]]) -> int:\\n        \\n        n = len(a)\\n        m = len(a[0])\\n        \\n        dp = [[INF for _ in range(m)] for _ in range(n)]\\n        dp[0][0] = 0\\n        \\n            \\n        for i in range(n):\\n            for j in range(m):\\n                if i == 0 and j == 0: continue\\n                \\n                case_1 = min([dp[i][k] for k in range(j) if j <= a[i][k] + k] + [INF])\\n                case_2 = min([dp[k][j] for k in range(i) if i <= a[k][j] + k] + [INF])\\n\\n                dp[i][j] = 1 + min(case_1, case_2)\\n        \\n        return dp[-1][-1] + 1 if dp[-1][-1] < INF else -1\\n     \\n```\\n\\n\\n\\n# Let\\'s try to optimize the above code\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCan we maintain min_heaps of previously solved dp for each (i, j)?\\n \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf we maintain the min_heaps, for the (i, j)th cell we can get case_1 in O(logm) and case_2 in O(logn). But the problem is we need to check wether j <= a[i][k] + k and i <= a[k][j] + k.\\n\\n**Observation**: \\nWe are solving from i = 0, 1, 2 .. n\\nIf, i > a[k][j] + k => i + 1 > a[k][j] + k, \\nSo along with the dp values with need to store a[i][j] + i, a[i][j] + j for respective columns and rows.\\n\\nSo while solving for (i, j), we pop from respective the column\\'s min_heap, while the top of min_heap holds i > a[k][j] + k, we pop out that and the spared value on the top will be the minimum.\\n\\nDo the same for the respective row\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n * m * (log(n) + log(m)))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n * m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n               \\nINF = 10 ** 9\\nfrom heapq import *\\n\\n\\nclass Solution:\\n    def minimumVisitedCells(self, a: List[List[int]]) -> int:\\n        \\n        n = len(a)\\n        m = len(a[0])\\n                \\n        dp_ij = 0\\n        \\n        n_pq = [[] for _ in range(n)]\\n        m_pq = [[] for _ in range(m)]\\n        \\n        heappush(n_pq[0], (dp_ij, a[0][0]))\\n        heappush(m_pq[0], (dp_ij, a[0][0]))\\n                \\n            \\n        for i in range(n):\\n            for j in range(m):\\n                \\n                if i == 0 and j == 0:\\n                    continue\\n\\n                while m_pq[j] and i > m_pq[j][0][1]:\\n                    heappop(m_pq[j])\\n                    \\n                while n_pq[i] and j > n_pq[i][0][1]:\\n                    heappop(n_pq[i])\\n                \\n                case_1 = m_pq[j][0][0] if m_pq[j] else INF\\n                case_2 = n_pq[i][0][0] if n_pq[i] else INF\\n                                \\n                \\n                dp_ij = 1 + min(case_1, case_2)\\n                \\n                heappush(m_pq[j], (dp_ij, a[i][j] + i))\\n                heappush(n_pq[i], (dp_ij, a[i][j] + j))\\n                \\n        \\n        return dp_ij + 1 if dp_ij < INF else -1\\n     \\n```\\n\\nLet me know in the comments if there are any doubts.\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n               \\nINF = 10 ** 9\\n\\nclass Solution:\\n    def minimumVisitedCells(self, a: List[List[int]]) -> int:\\n        \\n        n = len(a)\\n        m = len(a[0])\\n        \\n        dp = [[INF for _ in range(m)] for _ in range(n)]\\n        dp[0][0] = 0\\n        \\n            \\n        for i in range(n):\\n            for j in range(m):\\n                if i == 0 and j == 0: continue\\n                \\n                case_1 = min([dp[i][k] for k in range(j) if j <= a[i][k] + k] + [INF])\\n                case_2 = min([dp[k][j] for k in range(i) if i <= a[k][j] + k] + [INF])\\n\\n                dp[i][j] = 1 + min(case_1, case_2)\\n        \\n        return dp[-1][-1] + 1 if dp[-1][-1] < INF else -1\\n     \\n```\n```\\n               \\nINF = 10 ** 9\\nfrom heapq import *\\n\\n\\nclass Solution:\\n    def minimumVisitedCells(self, a: List[List[int]]) -> int:\\n        \\n        n = len(a)\\n        m = len(a[0])\\n                \\n        dp_ij = 0\\n        \\n        n_pq = [[] for _ in range(n)]\\n        m_pq = [[] for _ in range(m)]\\n        \\n        heappush(n_pq[0], (dp_ij, a[0][0]))\\n        heappush(m_pq[0], (dp_ij, a[0][0]))\\n                \\n            \\n        for i in range(n):\\n            for j in range(m):\\n                \\n                if i == 0 and j == 0:\\n                    continue\\n\\n                while m_pq[j] and i > m_pq[j][0][1]:\\n                    heappop(m_pq[j])\\n                    \\n                while n_pq[i] and j > n_pq[i][0][1]:\\n                    heappop(n_pq[i])\\n                \\n                case_1 = m_pq[j][0][0] if m_pq[j] else INF\\n                case_2 = n_pq[i][0][0] if n_pq[i] else INF\\n                                \\n                \\n                dp_ij = 1 + min(case_1, case_2)\\n                \\n                heappush(m_pq[j], (dp_ij, a[i][j] + i))\\n                heappush(n_pq[i], (dp_ij, a[i][j] + j))\\n                \\n        \\n        return dp_ij + 1 if dp_ij < INF else -1\\n     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397585,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn minimum_visited_cells(grid: Vec<Vec<i32>>) -> i32 {\\n        let m = grid.len();\\n        let n = grid[0].len();\\n        let mut steps = 0;\\n        let mut max_i = vec![0; n];\\n        let mut max_j = vec![0; m];\\n        let mut q = vec![(0, 0)];\\n        let mut q1 = vec![];\\n        while !q.is_empty() {\\n            steps += 1;\\n            for &(i, j) in q.iter() {\\n                if i == m - 1 && j == n - 1 {\\n                    return steps;\\n                }\\n                for k in (max_i[j].max(i) + 1)..m {\\n                    if (k - i) as i32 > grid[i][j] {\\n                        break;\\n                    }\\n                    q1.push((k, j));\\n                }\\n                for k in (max_j[i].max(j) + 1)..n {\\n                    if (k - j) as i32 > grid[i][j] {\\n                        break;\\n                    }\\n                    q1.push((i, k));\\n                }\\n                max_i[j] = max_i[j].max(i + grid[i][j] as usize);\\n                max_j[i] = max_j[i].max(j + grid[i][j] as usize);\\n            }\\n            std::mem::swap(&mut q, &mut q1);\\n            q1.clear();\\n        }\\n        -1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimum_visited_cells(grid: Vec<Vec<i32>>) -> i32 {\\n        let m = grid.len();\\n        let n = grid[0].len();\\n        let mut steps = 0;\\n        let mut max_i = vec![0; n];\\n        let mut max_j = vec![0; m];\\n        let mut q = vec![(0, 0)];\\n        let mut q1 = vec![];\\n        while !q.is_empty() {\\n            steps += 1;\\n            for &(i, j) in q.iter() {\\n                if i == m - 1 && j == n - 1 {\\n                    return steps;\\n                }\\n                for k in (max_i[j].max(i) + 1)..m {\\n                    if (k - i) as i32 > grid[i][j] {\\n                        break;\\n                    }\\n                    q1.push((k, j));\\n                }\\n                for k in (max_j[i].max(j) + 1)..n {\\n                    if (k - j) as i32 > grid[i][j] {\\n                        break;\\n                    }\\n                    q1.push((i, k));\\n                }\\n                max_i[j] = max_i[j].max(i + grid[i][j] as usize);\\n                max_j[i] = max_j[i].max(j + grid[i][j] as usize);\\n            }\\n            std::mem::swap(&mut q, &mut q1);\\n            q1.clear();\\n        }\\n        -1\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3397442,
                "title": "c-easy-solution-dijkastra-priority-queue-optimal-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> q;\\n        vector<vector<int>> dist(n,vector<int>(m,INT_MAX));\\n        if(n==1 && m==1){\\n            return 1;\\n        }\\n        dist[0][0]=1;\\n        q.push({1,{0,0}});\\n        //dist,row,col\\n        while(!q.empty()){\\n            int d=q.top().first;\\n            int r=q.top().second.first;\\n            int c=q.top().second.second;\\n            q.pop();\\n            int k=grid[r][c];\\n            \\n           \\n                for(int i=r+1;i<=(r+k) && i<n ;i++){\\n                    if(d+1<dist[i][c]){\\n                        dist[i][c]=d+1;\\n                        q.push({dist[i][c],{i,c}});\\n                        if(i==n-1 && c==m-1 && dist[i][c]!=INT_MAX){\\n                            return dist[i][c];\\n                        }\\n                    }\\n                }\\n            \\n            \\n                for(int j=c+1;j<=(c+k) && j<m ;j++){\\n                    if(d+1<dist[r][j]){\\n                        dist[r][j]=d+1;\\n                        q.push({dist[r][j],{r,j}});\\n                        if(r==n-1 && j==m-1 && dist[r][j]!=INT_MAX){\\n                            return dist[r][j];\\n                        }\\n                    }\\n                }\\n            \\n        }\\n        return -1;\\n    }\\n};\\n```\\n# AUTHOR: JAYESH BADGUJAR\\n\\n",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> q;\\n        vector<vector<int>> dist(n,vector<int>(m,INT_MAX));\\n        if(n==1 && m==1){\\n            return 1;\\n        }\\n        dist[0][0]=1;\\n        q.push({1,{0,0}});\\n        //dist,row,col\\n        while(!q.empty()){\\n            int d=q.top().first;\\n            int r=q.top().second.first;\\n            int c=q.top().second.second;\\n            q.pop();\\n            int k=grid[r][c];\\n            \\n           \\n                for(int i=r+1;i<=(r+k) && i<n ;i++){\\n                    if(d+1<dist[i][c]){\\n                        dist[i][c]=d+1;\\n                        q.push({dist[i][c],{i,c}});\\n                        if(i==n-1 && c==m-1 && dist[i][c]!=INT_MAX){\\n                            return dist[i][c];\\n                        }\\n                    }\\n                }\\n            \\n            \\n                for(int j=c+1;j<=(c+k) && j<m ;j++){\\n                    if(d+1<dist[r][j]){\\n                        dist[r][j]=d+1;\\n                        q.push({dist[r][j],{r,j}});\\n                        if(r==n-1 && j==m-1 && dist[r][j]!=INT_MAX){\\n                            return dist[r][j];\\n                        }\\n                    }\\n                }\\n            \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397340,
                "title": "python-djikstra-algorithm-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\'\\'\\'\\nWe need to find shorted path with least jumps.\\nWe can use Djikstra algo to solve this question.\\n\\'\\'\\'\\nfrom queue import PriorityQueue\\n\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        q = PriorityQueue()\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        q.put((1,0,0))\\n        distance = [[math.inf for i in range(n)] for j in range(m)]\\n        distance[0][0] = 1\\n\\n        while not q.empty():\\n            jump, row, col = q.get()\\n    \\n            if row == m-1 and col == n-1:\\n                return jump\\n        \\n            for i in range(row+1, min(row + grid[row][col]+1, m)):\\n                if distance[i][col] > jump + 1:\\n                    distance[i][col] = jump + 1\\n                    q.put((jump+1, i, col))\\n                    #Early return\\n                    if i == m-1 and col == n-1:\\n                        return jump + 1\\n            \\n            for j in range(col+1, min(col + grid[row][col]+1, n)):\\n                if distance[row][j] > jump + 1:\\n                    distance[row][j] = jump + 1\\n                    q.put((jump+1, row, j))\\n                    #Early return\\n                    if row == m-1 and j == n-1:\\n                        return jump + 1\\n                        \\n        return -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Graph"
                ],
                "code": "```\\n\\'\\'\\'\\nWe need to find shorted path with least jumps.\\nWe can use Djikstra algo to solve this question.\\n\\'\\'\\'\\nfrom queue import PriorityQueue\\n\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        q = PriorityQueue()\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        q.put((1,0,0))\\n        distance = [[math.inf for i in range(n)] for j in range(m)]\\n        distance[0][0] = 1\\n\\n        while not q.empty():\\n            jump, row, col = q.get()\\n    \\n            if row == m-1 and col == n-1:\\n                return jump\\n        \\n            for i in range(row+1, min(row + grid[row][col]+1, m)):\\n                if distance[i][col] > jump + 1:\\n                    distance[i][col] = jump + 1\\n                    q.put((jump+1, i, col))\\n                    #Early return\\n                    if i == m-1 and col == n-1:\\n                        return jump + 1\\n            \\n            for j in range(col+1, min(col + grid[row][col]+1, n)):\\n                if distance[row][j] > jump + 1:\\n                    distance[row][j] = jump + 1\\n                    q.put((jump+1, row, j))\\n                    #Early return\\n                    if row == m-1 and j == n-1:\\n                        return jump + 1\\n                        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397338,
                "title": "python-djikstra-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\'\\'\\'\\nWe need to find shorted path with least jumps.\\nWe can use Djikstra algo to solve this question.\\n\\'\\'\\'\\nfrom queue import PriorityQueue\\n\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        q = PriorityQueue()\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        q.put((1,0,0))\\n        distance = [[math.inf for i in range(n)] for j in range(m)]\\n        distance[0][0] = 1\\n\\n        while not q.empty():\\n            jump, row, col = q.get()\\n    \\n            if row == m-1 and col == n-1:\\n                return jump\\n        \\n            for i in range(row+1, min(row + grid[row][col]+1, m)):\\n                if distance[i][col] > jump + 1:\\n                    distance[i][col] = jump + 1\\n                    q.put((jump+1, i, col))\\n                    #Early return\\n                    if i == m-1 and col == n-1:\\n                        return jump + 1\\n            \\n            for j in range(col+1, min(col + grid[row][col]+1, n)):\\n                if distance[row][j] > jump + 1:\\n                    distance[row][j] = jump + 1\\n                    q.put((jump+1, row, j))\\n                    #Early return\\n                    if row == m-1 and j == n-1:\\n                        return jump + 1\\n                        \\n        return -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Graph"
                ],
                "code": "```\\n\\'\\'\\'\\nWe need to find shorted path with least jumps.\\nWe can use Djikstra algo to solve this question.\\n\\'\\'\\'\\nfrom queue import PriorityQueue\\n\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        q = PriorityQueue()\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        q.put((1,0,0))\\n        distance = [[math.inf for i in range(n)] for j in range(m)]\\n        distance[0][0] = 1\\n\\n        while not q.empty():\\n            jump, row, col = q.get()\\n    \\n            if row == m-1 and col == n-1:\\n                return jump\\n        \\n            for i in range(row+1, min(row + grid[row][col]+1, m)):\\n                if distance[i][col] > jump + 1:\\n                    distance[i][col] = jump + 1\\n                    q.put((jump+1, i, col))\\n                    #Early return\\n                    if i == m-1 and col == n-1:\\n                        return jump + 1\\n            \\n            for j in range(col+1, min(col + grid[row][col]+1, n)):\\n                if distance[row][j] > jump + 1:\\n                    distance[row][j] = jump + 1\\n                    q.put((jump+1, row, j))\\n                    #Early return\\n                    if row == m-1 and j == n-1:\\n                        return jump + 1\\n                        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397076,
                "title": "bfs-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        queue<vector<int>>q;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        q.push({grid[0][0],0,0});\\n        int cnt=1;\\n        if(n==1&&m==1)return cnt;\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n            vis[0][0]=1;\\n        while(!q.empty()){\\n            cnt++;\\n            int t=q.size();\\n            for(int k=0;k<t;k++){\\n                auto temp=q.front();\\n                q.pop();\\n                int r=temp[0]+temp[2];\\n                int d=temp[0]+temp[1];\\n                for(int i=temp[2]+1;i<=r&&i<m;i++){\\n                    if(temp[1]==n-1&&i==m-1)return cnt;\\n                    if(vis[temp[1]][i]==0){\\n                        q.push({grid[temp[1]][i],temp[1],i});\\n                        vis[temp[1]][i]=1;\\n                    }\\n                }\\n                for(int i=temp[1]+1;i<=d&&i<n;i++){\\n                    if(i==n-1&&temp[2]==m-1)return cnt;\\n                    if(vis[i][temp[2]]==0){\\n                        q.push({grid[i][temp[2]],i,temp[2]});\\n                        vis[i][temp[2]]=1;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        queue<vector<int>>q;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        q.push({grid[0][0],0,0});\\n        int cnt=1;\\n        if(n==1&&m==1)return cnt;\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n            vis[0][0]=1;\\n        while(!q.empty()){\\n            cnt++;\\n            int t=q.size();\\n            for(int k=0;k<t;k++){\\n                auto temp=q.front();\\n                q.pop();\\n                int r=temp[0]+temp[2];\\n                int d=temp[0]+temp[1];\\n                for(int i=temp[2]+1;i<=r&&i<m;i++){\\n                    if(temp[1]==n-1&&i==m-1)return cnt;\\n                    if(vis[temp[1]][i]==0){\\n                        q.push({grid[temp[1]][i],temp[1],i});\\n                        vis[temp[1]][i]=1;\\n                    }\\n                }\\n                for(int i=temp[1]+1;i<=d&&i<n;i++){\\n                    if(i==n-1&&temp[2]==m-1)return cnt;\\n                    if(vis[i][temp[2]]==0){\\n                        q.push({grid[i][temp[2]],i,temp[2]});\\n                        vis[i][temp[2]]=1;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397046,
                "title": "c-dijstra-algorithms-simple-best-solution",
                "content": "# Intuition\\nJust Think about Simple Dijstra Algo And you will easily solve it\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  \\n        int minimumVisitedCells(vector<vector<int>>& grid) {\\n            int m = grid.size();\\n            int n = grid[0].size();\\n            if(m == 1 && n == 1){\\n                return 1;\\n            }\\n                \\n            queue<vector<int>> queue;\\n            vector<vector<int>> visited(m, vector<int>(n));\\n            \\n            queue.push({0, 0});\\n            \\n            int dist = 1;\\n            while(!queue.empty()) {\\n                int size = queue.size();\\n                while(size > 0) {\\n                    vector<int> cell = queue.front();\\n                    queue.pop();\\n                    int val = grid[cell[0]][cell[1]];\\n                    \\n                    //rightward movement\\n                    for(int col=1; col <= val; col++) {\\n                        if(col + cell[1] >= n){\\n                            break;\\n                        }\\n                            \\n                        if(cell[0] == m-1 && col + cell[1] == n-1){\\n                            return dist + 1;\\n                        }\\n\\n                        if(grid[cell[0]][col + cell[1]] != 0 \\n                        && visited[cell[0]][col + cell[1]] == 0) {\\n                            queue.push({cell[0], col + cell[1]});\\n                            visited[cell[0]][col + cell[1]] = 1;\\n                        }\\n                    }\\n\\n                    //downward movement\\n                    for(int row=1; row <= val; row++) {\\n                        if(row + cell[0] >= m)\\n                            break;\\n\\n                        if(cell[0] + row == m-1 && cell[1] == n-1)\\n                            return dist + 1;\\n\\n                        if(grid[row + cell[0]][cell[1]] != 0 && \\n                        visited[row + cell[0]][cell[1]] == 0) {\\n                            queue.push({row + cell[0], cell[1]});\\n                            visited[row + cell[0]][cell[1]] = 1;\\n                        }\\n                    }\\n                    size--;\\n            }\\n            dist++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n        int minimumVisitedCells(vector<vector<int>>& grid) {\\n            int m = grid.size();\\n            int n = grid[0].size();\\n            if(m == 1 && n == 1){\\n                return 1;\\n            }\\n                \\n            queue<vector<int>> queue;\\n            vector<vector<int>> visited(m, vector<int>(n));\\n            \\n            queue.push({0, 0});\\n            \\n            int dist = 1;\\n            while(!queue.empty()) {\\n                int size = queue.size();\\n                while(size > 0) {\\n                    vector<int> cell = queue.front();\\n                    queue.pop();\\n                    int val = grid[cell[0]][cell[1]];\\n                    \\n                    //rightward movement\\n                    for(int col=1; col <= val; col++) {\\n                        if(col + cell[1] >= n){\\n                            break;\\n                        }\\n                            \\n                        if(cell[0] == m-1 && col + cell[1] == n-1){\\n                            return dist + 1;\\n                        }\\n\\n                        if(grid[cell[0]][col + cell[1]] != 0 \\n                        && visited[cell[0]][col + cell[1]] == 0) {\\n                            queue.push({cell[0], col + cell[1]});\\n                            visited[cell[0]][col + cell[1]] = 1;\\n                        }\\n                    }\\n\\n                    //downward movement\\n                    for(int row=1; row <= val; row++) {\\n                        if(row + cell[0] >= m)\\n                            break;\\n\\n                        if(cell[0] + row == m-1 && cell[1] == n-1)\\n                            return dist + 1;\\n\\n                        if(grid[row + cell[0]][cell[1]] != 0 && \\n                        visited[row + cell[0]][cell[1]] == 0) {\\n                            queue.push({row + cell[0], cell[1]});\\n                            visited[row + cell[0]][cell[1]] = 1;\\n                        }\\n                    }\\n                    size--;\\n            }\\n            dist++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396955,
                "title": "python-bst-bfs-solution",
                "content": "# Intuition\\n- Cannot do standard BFS since the graph has too many possible edges\\n- Although there are only $m * n$ possible vertices, each could have more than $m$ or $n$ edges. What if we could skip over edges to nodes we have already visited?\\n- Standard for loop takes too long (the check to if a node is in visited adds to complexity) - we need a way to iterate only over nodes that have not been visited\\n- BST to the rescue - guarantees we only consider nodes we haven\\'t visited, with search / removal in logarithmic time\\n\\n# Approach\\n- Store BST for each row (indicates which indices are left)\\n- Store BST for each column \\n- Remove node from BST from each row and column after processing it in BFS\\n\\n# Complexity\\n- Time complexity: $O(mn\\\\log(mn))$ (could be tighter, since BSTs won\\'t contain $mn$ entries)\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        que = deque([(0,0)])\\n        m, n = len(grid), len(grid[0])\\n        \\n        bstsR = [SortedList(range(n)) for i in range(m)]\\n        bstsC = [SortedList(range(m)) for j in range(n)]\\n        \\n        bstsR[0].remove(0)\\n        bstsC[0].remove(0)\\n        \\n        dist = 0\\n        while que:\\n            for _ in range(len(que)):\\n                i, j = que.popleft()\\n                if i == m - 1 and j == n - 1:\\n                    return dist + 1\\n                \\n                for child in list(bstsR[i].irange(j, grid[i][j] + j)):\\n                    que.append((i, child))\\n                    bstsR[i].remove(child)\\n                    bstsC[child].remove(i)\\n\\n                for child in list(bstsC[j].irange(i, grid[i][j] + i)):\\n                    que.append((child, j))\\n                    bstsC[j].remove(child)\\n                    bstsR[child].remove(j)\\n            \\n            dist += 1\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        que = deque([(0,0)])\\n        m, n = len(grid), len(grid[0])\\n        \\n        bstsR = [SortedList(range(n)) for i in range(m)]\\n        bstsC = [SortedList(range(m)) for j in range(n)]\\n        \\n        bstsR[0].remove(0)\\n        bstsC[0].remove(0)\\n        \\n        dist = 0\\n        while que:\\n            for _ in range(len(que)):\\n                i, j = que.popleft()\\n                if i == m - 1 and j == n - 1:\\n                    return dist + 1\\n                \\n                for child in list(bstsR[i].irange(j, grid[i][j] + j)):\\n                    que.append((i, child))\\n                    bstsR[i].remove(child)\\n                    bstsC[child].remove(i)\\n\\n                for child in list(bstsC[j].irange(i, grid[i][j] + i)):\\n                    que.append((child, j))\\n                    bstsC[j].remove(child)\\n                    bstsR[child].remove(j)\\n            \\n            dist += 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396943,
                "title": "short-and-simple-basic-dijkstra-algorithm-beats-100-c",
                "content": "# Intuition\\nMinimum no of nodes visit to reach bottom is equivalent to minimum distance to reach destination node.\\n\\n# Approach\\nBest Approach to find Minimum distance from one source node to any node is ***Dijkstra Algorithm***.\\n\\n# Complexity\\n- Time complexity: O(ELogV + V) \\nWhere V is number of nodes and E is number of edges.\\n\\n- Space complexity: O(V)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        vector<vector<int>> dist(n, vector<int>(m,1e9));\\n\\n        priority_queue <tuple<int,int,int>> q;\\n        q.push({0,0,0});\\n        dist[0][0] = 0;\\n        while(!q.empty())\\n        {\\n            auto [len,x,y] = q.top();\\n            q.pop();\\n\\n            // if cur node is equal to dest node return\\n            if(x==n-1 && y==m-1) return dist[n-1][m-1]+1;\\n\\n            // Node(x,y) dist is more optimized already\\n            if(dist[x][y]< -len) continue;\\n\\n            for(int i=x+1; i<grid[x][y]+x+1 && i<n; i++)\\n            {\\n                if(dist[i][y]>dist[x][y]+1)\\n                {\\n                    dist[i][y] = dist[x][y]+1;\\n                    q.push({-dist[i][y], i, y});\\n                }\\n            }\\n            for(int i=y+1; i<grid[x][y]+y+1 && i<m; i++)\\n            {\\n                if(dist[x][i]>dist[x][y]+1)\\n                {\\n                    dist[x][i] = dist[x][y]+1;\\n                    q.push({-dist[x][i], x, i});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        vector<vector<int>> dist(n, vector<int>(m,1e9));\\n\\n        priority_queue <tuple<int,int,int>> q;\\n        q.push({0,0,0});\\n        dist[0][0] = 0;\\n        while(!q.empty())\\n        {\\n            auto [len,x,y] = q.top();\\n            q.pop();\\n\\n            // if cur node is equal to dest node return\\n            if(x==n-1 && y==m-1) return dist[n-1][m-1]+1;\\n\\n            // Node(x,y) dist is more optimized already\\n            if(dist[x][y]< -len) continue;\\n\\n            for(int i=x+1; i<grid[x][y]+x+1 && i<n; i++)\\n            {\\n                if(dist[i][y]>dist[x][y]+1)\\n                {\\n                    dist[i][y] = dist[x][y]+1;\\n                    q.push({-dist[i][y], i, y});\\n                }\\n            }\\n            for(int i=y+1; i<grid[x][y]+y+1 && i<m; i++)\\n            {\\n                if(dist[x][i]>dist[x][y]+1)\\n                {\\n                    dist[x][i] = dist[x][y]+1;\\n                    q.push({-dist[x][i], x, i});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396884,
                "title": "c-solution-using-sets-o-n-m-log-n-log-m",
                "content": "# Intuition\\nUse two sets to keep reachable rows and colums and delete them from set when they become unreachable\\n\\n# Approach\\nI used two sets for keeping valid states that can reach particular (i,j)\\n# Complexity\\n- Time complexity:\\n- O(n* m*(log(n)+log(m)))\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        \\n\\t    ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<long long >>dp(n+1,vector<long long>(m+1,1e18));\\n        set<pair<long long,long long>>r1[m+1],r2[m+1];\\n        for(int i=0;i<n;i++){\\n            set<pair<long long , long long >>c2,c1;\\n            for(int j=0;j<m;j++){\\n                if(i==0&&j==0){\\n                    c1.insert({0+grid[0][0],0});\\n                    c2.insert({0,0});\\n                    r1[0].insert({0+grid[0][0],0});\\n                    r2[0].insert({0,0});\\n                    dp[1][1]=0;\\n                    continue;\\n                }\\n\\n                while(!c1.empty()&&c1.begin()->first<j){\\n                    c2.erase(c2.find({dp[i+1][c1.begin()->second+1],c1.begin()->second}));\\n                    c1.erase(c1.begin());\\n                }\\n                while(!r1[j].empty()&&r1[j].begin()->first<i){\\n                    r2[j].erase(r2[j].find({dp[r1[j].begin()->second+1][j+1],r1[j].begin()->second}));\\n                    r1[j].erase(r1[j].begin());\\n                }\\n                if(c2.size())\\n                dp[i+1][j+1]=min(dp[i+1][j+1],c2.begin()->first+1);\\n                if(r2[j].size())\\n                dp[i+1][j+1]=min(dp[i+1][j+1],r2[j].begin()->first+1);\\n                if(dp[i+1][j+1]!=1e18){\\n                    c2.insert({dp[i+1][j+1],j});\\n                    c1.insert({j+grid[i][j],j});\\n                    r1[j].insert({i+grid[i][j],i});\\n                    r2[j].insert({dp[i+1][j+1],i});\\n                }\\n            }\\n        }\\n        if(dp[n][m]==1e18)\\n            return -1;\\n        return dp[n][m]+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        \\n\\t    ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<long long >>dp(n+1,vector<long long>(m+1,1e18));\\n        set<pair<long long,long long>>r1[m+1],r2[m+1];\\n        for(int i=0;i<n;i++){\\n            set<pair<long long , long long >>c2,c1;\\n            for(int j=0;j<m;j++){\\n                if(i==0&&j==0){\\n                    c1.insert({0+grid[0][0],0});\\n                    c2.insert({0,0});\\n                    r1[0].insert({0+grid[0][0],0});\\n                    r2[0].insert({0,0});\\n                    dp[1][1]=0;\\n                    continue;\\n                }\\n\\n                while(!c1.empty()&&c1.begin()->first<j){\\n                    c2.erase(c2.find({dp[i+1][c1.begin()->second+1],c1.begin()->second}));\\n                    c1.erase(c1.begin());\\n                }\\n                while(!r1[j].empty()&&r1[j].begin()->first<i){\\n                    r2[j].erase(r2[j].find({dp[r1[j].begin()->second+1][j+1],r1[j].begin()->second}));\\n                    r1[j].erase(r1[j].begin());\\n                }\\n                if(c2.size())\\n                dp[i+1][j+1]=min(dp[i+1][j+1],c2.begin()->first+1);\\n                if(r2[j].size())\\n                dp[i+1][j+1]=min(dp[i+1][j+1],r2[j].begin()->first+1);\\n                if(dp[i+1][j+1]!=1e18){\\n                    c2.insert({dp[i+1][j+1],j});\\n                    c1.insert({j+grid[i][j],j});\\n                    r1[j].insert({i+grid[i][j],i});\\n                    r2[j].insert({dp[i+1][j+1],i});\\n                }\\n            }\\n        }\\n        if(dp[n][m]==1e18)\\n            return -1;\\n        return dp[n][m]+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396737,
                "title": "very-easy-just-normal-bfs",
                "content": "# Intuition\\nshortest steps so we should think of bfs.\\n# note: This is similar to \"45. Jump Game II\" i.e we can take any cell in same row with col in range (c+1,grid[r][c] + c ) (rightward) and same for downward.\\n# More concisely, you can take further \\'grid[r][c]\\' steps in rightward and downward after raeching (r, c).\\n\\n# Approach\\nAdd (steps=1, 0,0) in q and add (0,0) in visited.\\nAdding in visited at 1st time when we see the cell because: 1st time when we will see any cell that will be the minimum no of steps required to reach that cell.\\n\\nAfter that apply normal bfs as we do i.e traverse all the possible paths as we do normally.\\nBefore adding any node in \\'q\\' check if it is destination.\\n\\nAt last return -1 means we can\\'t reach the destination.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        m, n= len(grid), len(grid[0])\\n        if m== n==1:  # corner case\\n            return 1 \\n        q= collections.deque([])\\n        visited= set()\\n        q.append((1, 0, 0))  # [steps, r, c]\\n        visited.add((0, 0))  # [r, c]\\n        while q:\\n            steps, r, c= q.popleft()\\n            # traversing all the possible paths in rightward.\\n            for nc in range(c+1, grid[r][c] + c + 1):\\n                if nc < n and (r, nc) not in visited:\\n                    if r== m-1 and nc== n-1:  # if destination\\n                        return steps + 1 \\n                    q.append((steps + 1, r, nc))\\n                    visited.add((r, nc))\\n            # traversing all the possible paths in downward.\\n            for nr in range(r+1, grid[r][c] + r + 1):\\n                if nr < m and (nr, c) not in visited:\\n                    if nr== m-1 and c== n-1:  # if destination\\n                        return steps + 1 \\n                    q.append((steps + 1, nr, c))\\n                    visited.add((nr, c))\\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        m, n= len(grid), len(grid[0])\\n        if m== n==1:  # corner case\\n            return 1 \\n        q= collections.deque([])\\n        visited= set()\\n        q.append((1, 0, 0))  # [steps, r, c]\\n        visited.add((0, 0))  # [r, c]\\n        while q:\\n            steps, r, c= q.popleft()\\n            # traversing all the possible paths in rightward.\\n            for nc in range(c+1, grid[r][c] + c + 1):\\n                if nc < n and (r, nc) not in visited:\\n                    if r== m-1 and nc== n-1:  # if destination\\n                        return steps + 1 \\n                    q.append((steps + 1, r, nc))\\n                    visited.add((r, nc))\\n            # traversing all the possible paths in downward.\\n            for nr in range(r+1, grid[r][c] + r + 1):\\n                if nr < m and (nr, c) not in visited:\\n                    if nr== m-1 and c== n-1:  # if destination\\n                        return steps + 1 \\n                    q.append((steps + 1, nr, c))\\n                    visited.add((nr, c))\\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396647,
                "title": "java-simple-solution-with-time-complexity-o-m-n-by-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing BFS trace all possible path and use visited array for recording which node we have been traced,if all node we traced then don\\'t need to run for-loop to waste time.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nReduce not necessary trace for for-loop by check ```v_node==m*n```.\\n# Complexity\\n- Time complexity: $$O(m*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m*n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumVisitedCells(int[][] grid) {\\n        final int m = grid.length;\\n        final int n = grid[0].length;\\n        //final int max = m*n;\\n        Queue<int[]> q = new LinkedList<>();\\n        q.offer(new int[]{0,0});\\n        int[][] v = new int[m][n];\\n        int v_node=1;\\n        int step = 1;\\n        v[0][0] = 1;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int time=0;time<size;time++){\\n                int[] cur = q.poll();\\n                int x = cur[0];\\n                int y = cur[1];\\n                if((x==m-1 && y==n-1)) return step;\\n                if(v_node==m*n) continue;\\n                for(int neighbor=x+1;neighbor<=Integer.min(m-1,x+grid[x][y]);neighbor++){\\n                    if(v[neighbor][y]==1) continue;\\n                    v[neighbor][y]=1;\\n                    q.offer(new int[]{neighbor,y});\\n                    v_node++;\\n                }\\n                for(int neighbor=y+1;neighbor<=Integer.min(n-1,y+grid[x][y]);neighbor++){\\n                    if(v[x][neighbor]==1) continue;\\n                    v[x][neighbor]=1;\\n                    q.offer(new int[]{x,neighbor});\\n                    v_node++;\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```v_node==m*n```\n```\\nclass Solution {\\n    public int minimumVisitedCells(int[][] grid) {\\n        final int m = grid.length;\\n        final int n = grid[0].length;\\n        //final int max = m*n;\\n        Queue<int[]> q = new LinkedList<>();\\n        q.offer(new int[]{0,0});\\n        int[][] v = new int[m][n];\\n        int v_node=1;\\n        int step = 1;\\n        v[0][0] = 1;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int time=0;time<size;time++){\\n                int[] cur = q.poll();\\n                int x = cur[0];\\n                int y = cur[1];\\n                if((x==m-1 && y==n-1)) return step;\\n                if(v_node==m*n) continue;\\n                for(int neighbor=x+1;neighbor<=Integer.min(m-1,x+grid[x][y]);neighbor++){\\n                    if(v[neighbor][y]==1) continue;\\n                    v[neighbor][y]=1;\\n                    q.offer(new int[]{neighbor,y});\\n                    v_node++;\\n                }\\n                for(int neighbor=y+1;neighbor<=Integer.min(n-1,y+grid[x][y]);neighbor++){\\n                    if(v[x][neighbor]==1) continue;\\n                    v[x][neighbor]=1;\\n                    q.offer(new int[]{x,neighbor});\\n                    v_node++;\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396598,
                "title": "python-bfs-from-farthest-to-nearest-simple-and-short",
                "content": "It is always faster to move as far as you can, reducing the number of nodes visited.\\n\\n```\\nimport queue\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        \\n        m, n = len(grid), len(grid[0])\\n        q = queue.Queue()\\n        \\n        visited = set()\\n        q.put((0,0,1))\\n        \\n        while not q.empty():\\n            x, y, d = q.get()\\n            if x == m-1 and y == n-1:\\n                return d\\n            for ny in range(min(n-1, grid[x][y]+y), y, -1):\\n                if (x, ny) not in visited:\\n                    q.put((x, ny, d+1))\\n                    visited.add((x, ny))\\n\\n            for nx in range(min(m-1, grid[x][y]+x), x, -1):\\n                if (nx, y) not in visited:\\n                    q.put((nx, y, d+1))\\n                    visited.add((nx, y))\\n\\n        return -1\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nimport queue\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        \\n        m, n = len(grid), len(grid[0])\\n        q = queue.Queue()\\n        \\n        visited = set()\\n        q.put((0,0,1))\\n        \\n        while not q.empty():\\n            x, y, d = q.get()\\n            if x == m-1 and y == n-1:\\n                return d\\n            for ny in range(min(n-1, grid[x][y]+y), y, -1):\\n                if (x, ny) not in visited:\\n                    q.put((x, ny, d+1))\\n                    visited.add((x, ny))\\n\\n            for nx in range(min(m-1, grid[x][y]+x), x, -1):\\n                if (nx, y) not in visited:\\n                    q.put((nx, y, d+1))\\n                    visited.add((nx, y))\\n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396486,
                "title": "python-simple-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumVisitedCells(self, grid):\\n        m, n = len(grid), len(grid[0])\\n\\n        stack, visited = [(0,0,1)], {(0,0)}\\n\\n        while stack:\\n            i, j, count = stack.pop(0)\\n\\n            if i == m-1 and j == n-1:\\n                return count\\n\\n            for k in range(j+1,min(grid[i][j]+j,n-1)+1)[::-1]:\\n                if (i,k) not in visited:\\n                    stack.append((i,k,count+1))\\n                    visited.add((i,k))\\n\\n            for k in range(i+1,min(grid[i][j]+i,m-1)+1)[::-1]:\\n                if (k,j) not in visited:\\n                    stack.append((k,j,count+1))\\n                    visited.add((k,j))\\n\\n        return -1\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumVisitedCells(self, grid):\\n        m, n = len(grid), len(grid[0])\\n\\n        stack, visited = [(0,0,1)], {(0,0)}\\n\\n        while stack:\\n            i, j, count = stack.pop(0)\\n\\n            if i == m-1 and j == n-1:\\n                return count\\n\\n            for k in range(j+1,min(grid[i][j]+j,n-1)+1)[::-1]:\\n                if (i,k) not in visited:\\n                    stack.append((i,k,count+1))\\n                    visited.add((i,k))\\n\\n            for k in range(i+1,min(grid[i][j]+i,m-1)+1)[::-1]:\\n                if (k,j) not in visited:\\n                    stack.append((k,j,count+1))\\n                    visited.add((k,j))\\n\\n        return -1\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396388,
                "title": "c",
                "content": "```\\nusing PII = pair<int, int> ;\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int m = grid.size() ;\\n        int n = grid[0].size() ;\\n        queue<PII>q ;\\n        q.push({0,0}) ;\\n        int step = 0 ;\\n        auto visited = vector<vector<bool>>(m, vector<bool>(n)) ;\\n        visited[0][0] = true ;\\n        while(!q.empty()){\\n            int sz = q.size() ;\\n            for(int i = 0; i < sz; i++){\\n                auto [x, y] = q.front() ;\\n                q.pop() ;\\n                if(x == m -1 && y == n-1)\\n                    return step+1 ;\\n                int d = grid[x][y] ;\\n                for(int k = d; k >= 1; k--){\\n                    int xx = x + k;\\n                    if(xx >= m)\\n                        continue ;\\n                    if(visited[xx][y])\\n                        continue ;\\n                    q.push({xx, y}) ;\\n                    visited[xx][y] = true ;\\n                }\\n            \\n                for(int k = d; k >= 0; k--){\\n                    int yy = y + k;\\n                    if(yy >= n)\\n                        continue ;\\n                    if(visited[x][yy])\\n                        continue ;\\n                    q.push({x, yy}) ;\\n                    visited[x][yy] = true ;\\n                }\\n            }\\n            step++ ;\\n        }\\n        return -1 ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nusing PII = pair<int, int> ;\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int m = grid.size() ;\\n        int n = grid[0].size() ;\\n        queue<PII>q ;\\n        q.push({0,0}) ;\\n        int step = 0 ;\\n        auto visited = vector<vector<bool>>(m, vector<bool>(n)) ;\\n        visited[0][0] = true ;\\n        while(!q.empty()){\\n            int sz = q.size() ;\\n            for(int i = 0; i < sz; i++){\\n                auto [x, y] = q.front() ;\\n                q.pop() ;\\n                if(x == m -1 && y == n-1)\\n                    return step+1 ;\\n                int d = grid[x][y] ;\\n                for(int k = d; k >= 1; k--){\\n                    int xx = x + k;\\n                    if(xx >= m)\\n                        continue ;\\n                    if(visited[xx][y])\\n                        continue ;\\n                    q.push({xx, y}) ;\\n                    visited[xx][y] = true ;\\n                }\\n            \\n                for(int k = d; k >= 0; k--){\\n                    int yy = y + k;\\n                    if(yy >= n)\\n                        continue ;\\n                    if(visited[x][yy])\\n                        continue ;\\n                    q.push({x, yy}) ;\\n                    visited[x][yy] = true ;\\n                }\\n            }\\n            step++ ;\\n        }\\n        return -1 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396318,
                "title": "simple-bfs-easy-method",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        vis[0][0]=1;\\n        int level=1;\\n        while(!q.empty()){\\n            int sz=q.size();\\n            while(sz--){\\n                 auto node=q.front();\\n            q.pop();\\n            int i=node.first;\\n            int j=node.second;\\n        if(i==n-1 and j==m-1)return level;\\n            for(int k=j+1;k<=grid[i][j]+j;k++){\\n                if(k<m and !vis[i][k]){\\n                       if(i==n-1 and k==m-1)return level+1;\\n                    vis[i][k]=1;\\n                    q.push({i,k});\\n                }\\n            }\\n                \\n             for(int k=i+1;k<=grid[i][j]+i;k++){\\n                 if(k<n and !vis[k][j]){\\n                           if(k==n-1 and j==m-1)return level+1;\\n                     vis[k][j]=1;\\n                     q.push({k,j});\\n                 }\\n             }\\n                \\n            }\\n           level++;\\n        }\\n            return -1;\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        vis[0][0]=1;\\n        int level=1;\\n        while(!q.empty()){\\n            int sz=q.size();\\n            while(sz--){\\n                 auto node=q.front();\\n            q.pop();\\n            int i=node.first;\\n            int j=node.second;\\n        if(i==n-1 and j==m-1)return level;\\n            for(int k=j+1;k<=grid[i][j]+j;k++){\\n                if(k<m and !vis[i][k]){\\n                       if(i==n-1 and k==m-1)return level+1;\\n                    vis[i][k]=1;\\n                    q.push({i,k});\\n                }\\n            }\\n                \\n             for(int k=i+1;k<=grid[i][j]+i;k++){\\n                 if(k<n and !vis[k][j]){\\n                           if(k==n-1 and j==m-1)return level+1;\\n                     vis[k][j]=1;\\n                     q.push({k,j});\\n                 }\\n             }\\n                \\n            }\\n           level++;\\n        }\\n            return -1;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396297,
                "title": "python-bfs-travel-with-non-zero-cell-iterate-from-end",
                "content": "1. We can do BFS to travel non-zero cell in grid, since 0-cell makes us stop in that cell\\n2. We should iterate all possible next cell from END - **rightmost** and **downmost** cell\\n```\\ndef minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n\\tm, n = len(grid), len(grid[0])\\n\\tq, grid[0][0], grid[m-1][n-1], step = deque([[0, 0, grid[0][0]]]), 0, 1, 1\\n\\t# rewrite last cell with non-zero value avoid skipping it\\n\\twhile(q):\\n\\t\\tfor _ in range(len(q)):\\n\\t\\t\\ti, j, k = q.popleft()\\n\\t\\t\\tif i==m-1 and j==n-1:\\n\\t\\t\\t\\treturn step\\n\\t\\t\\t# iterate from END\\n\\t\\t\\tfor jj in range(min(j+k, n-1), j, -1):\\n\\t\\t\\t\\tif grid[i][jj]:\\n\\t\\t\\t\\t\\tq.append([i, jj, grid[i][jj]])\\n\\t\\t\\t\\t\\tgrid[i][jj] = 0\\n\\t\\t\\tfor ii in range(min(i+k, m-1), i, -1):\\n\\t\\t\\t\\tif grid[ii][j]:\\n\\t\\t\\t\\t\\tq.append([ii, j, grid[ii][j]])\\n\\t\\t\\t\\t\\tgrid[ii][j] = 0\\n\\t\\tstep += 1\\n\\treturn -1\\n```",
                "solutionTags": [],
                "code": "```\\ndef minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n\\tm, n = len(grid), len(grid[0])\\n\\tq, grid[0][0], grid[m-1][n-1], step = deque([[0, 0, grid[0][0]]]), 0, 1, 1\\n\\t# rewrite last cell with non-zero value avoid skipping it\\n\\twhile(q):\\n\\t\\tfor _ in range(len(q)):\\n\\t\\t\\ti, j, k = q.popleft()\\n\\t\\t\\tif i==m-1 and j==n-1:\\n\\t\\t\\t\\treturn step\\n\\t\\t\\t# iterate from END\\n\\t\\t\\tfor jj in range(min(j+k, n-1), j, -1):\\n\\t\\t\\t\\tif grid[i][jj]:\\n\\t\\t\\t\\t\\tq.append([i, jj, grid[i][jj]])\\n\\t\\t\\t\\t\\tgrid[i][jj] = 0\\n\\t\\t\\tfor ii in range(min(i+k, m-1), i, -1):\\n\\t\\t\\t\\tif grid[ii][j]:\\n\\t\\t\\t\\t\\tq.append([ii, j, grid[ii][j]])\\n\\t\\t\\t\\t\\tgrid[ii][j] = 0\\n\\t\\tstep += 1\\n\\treturn -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3396250,
                "title": "dp-optimization-with-segment-tree-c",
                "content": "# Intuition\\nWhen we are at $cell_{ij}, $ we can either go to the right or downwards. And since we have to find the minimum number of cells to visit in order to reach $cell_{(m - 1)(n - 1)}$ from $cell_{00},$ we can solve the problem using dynamic programming.\\n# Approach\\nLet $dp_{ij} = minimum$ $number$ $of$ $cells$ $to$ $visit$ $in$ $order$ $to$ $reach$ $cell_{(m - 1) (n - 1)}$ $from$ $cell_{ij}.$\\nThen we can define the following reccurence:\\n$$dp_{ij} = min \\\\left( \\\\displaystyle\\\\min_{j + 1 \\\\le k \\\\le grid_{ij} + j} dp_{ik}, \\\\displaystyle\\\\min_{i + 1 \\\\le k \\\\le grid_{ij} + i} dp_{kj}\\\\right) + 1$$\\nWith base case $dp_{(m - 1)(n - 1)} = 1,$our final answer would be $dp_{00}.$\\nIterating over all the cells to find the minimum for each cell would take $\\\\mathcal{O}(nm(n + m))$ time which is not sufficient for the constraints of the problem. But we can speed it up to $$\\\\mathcal{O}(nm \\\\log (nm))$$ by building a segment tree that supports point updates and range minimum queries in $$\\\\mathcal{O}(\\\\log n)$$ time for every row and column.\\n\\n# Complexity\\n- Time complexity:\\n$$\\\\mathcal{O}(nm \\\\log (nm))$$\\n\\n- Space complexity:\\n$$\\\\mathcal{O}(nm)$$\\n\\n# Code\\n```\\nconst int INF = 2e9;\\nclass Solution {\\nprivate:\\n    struct segtree {\\n        vector<int> st;\\n        int n;\\n        segtree(int n_) : n(n_) {\\n            st.resize(n << 1, INF);\\n        }\\n        void upd(int u, int x) {\\n            for (st[u += n] = x; u >>= 1;) st[u] = min(st[u << 1], st[u << 1 | 1]);\\n        }\\n        int query(int l, int r) {\\n            int mn = INF;\\n            for (l += n, r += n + 1; l < r; l >>= 1, r >>= 1) {\\n                if (l & 1) mn = min(mn, st[l++]);\\n                if (r & 1) mn = min(mn, st[--r]);\\n            }\\n            return mn;\\n        }\\n    };\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<segtree> rmq(m, segtree (n)), rmq2(n, segtree (m));\\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = n - 1; j >= 0; j--) {\\n                if (i == m - 1 && j == n - 1) {\\n                    rmq[i].upd(j, 1);\\n                    rmq2[j].upd(i, 1);\\n                    continue;\\n                }\\n                if (grid[i][j] == 0) continue;\\n                int dx = (j + 1 < n ? rmq[i].query(j + 1, min(n - 1, grid[i][j] + j)) : INF);\\n                int dy = (i + 1 < m ? rmq2[j].query(i + 1, min(m - 1, grid[i][j] + i)) : INF);\\n                if (dx == INF && dy == INF) continue;\\n                int steps = min(dx, dy) + 1;\\n                rmq[i].upd(j, steps);\\n                rmq2[j].upd(i, steps);\\n            }\\n        }\\n        int min_steps = rmq[0].query(0, 0);\\n        return (min_steps == INF ? -1 : min_steps);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Segment Tree"
                ],
                "code": "```\\nconst int INF = 2e9;\\nclass Solution {\\nprivate:\\n    struct segtree {\\n        vector<int> st;\\n        int n;\\n        segtree(int n_) : n(n_) {\\n            st.resize(n << 1, INF);\\n        }\\n        void upd(int u, int x) {\\n            for (st[u += n] = x; u >>= 1;) st[u] = min(st[u << 1], st[u << 1 | 1]);\\n        }\\n        int query(int l, int r) {\\n            int mn = INF;\\n            for (l += n, r += n + 1; l < r; l >>= 1, r >>= 1) {\\n                if (l & 1) mn = min(mn, st[l++]);\\n                if (r & 1) mn = min(mn, st[--r]);\\n            }\\n            return mn;\\n        }\\n    };\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<segtree> rmq(m, segtree (n)), rmq2(n, segtree (m));\\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = n - 1; j >= 0; j--) {\\n                if (i == m - 1 && j == n - 1) {\\n                    rmq[i].upd(j, 1);\\n                    rmq2[j].upd(i, 1);\\n                    continue;\\n                }\\n                if (grid[i][j] == 0) continue;\\n                int dx = (j + 1 < n ? rmq[i].query(j + 1, min(n - 1, grid[i][j] + j)) : INF);\\n                int dy = (i + 1 < m ? rmq2[j].query(i + 1, min(m - 1, grid[i][j] + i)) : INF);\\n                if (dx == INF && dy == INF) continue;\\n                int steps = min(dx, dy) + 1;\\n                rmq[i].upd(j, steps);\\n                rmq2[j].upd(i, steps);\\n            }\\n        }\\n        int min_steps = rmq[0].query(0, 0);\\n        return (min_steps == INF ? -1 : min_steps);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396061,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(rows * cols * (log(rows) + log(cols)))\\n * Space Complexity: O(rows * cols)\\n * where `rows` is the number of the rows of the matrix `grid`\\n *       `cols` is the number of the columns of the matrix `grid`\\n */\\nclass Solution {\\n public:\\n  int minimumVisitedCells(const vector<vector<int>> &grid) {\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    set<int> unvisited_rows[rows];\\n    for (int r = 0; r < rows; ++r) {\\n      if (r == 0) {\\n        for (int c = 0; c < cols; ++c) {\\n          unvisited_rows[r].emplace(c);\\n        }\\n        continue;\\n      }\\n      unvisited_rows[r] = unvisited_rows[r - 1];\\n    }\\n    set<int> unvisited_cols[cols];\\n    for (int c = 0; c < cols; ++c) {\\n      if (c == 0) {\\n        for (int r = 0; r < rows; ++r) {\\n          unvisited_cols[c].emplace(r);\\n        }\\n        continue;\\n      }\\n      unvisited_cols[c] = unvisited_cols[c - 1];\\n    }\\n    bool visited[rows][cols];\\n    memset(visited, 0, sizeof(visited));\\n    queue<pair<int, int>> q({make_pair(0, 0)});\\n    unvisited_rows[0].erase(0);\\n    unvisited_cols[0].erase(0);\\n    visited[0][0] = true;\\n    int visited_cells = 0;\\n    while (!q.empty()) {\\n      ++visited_cells;\\n      for (size_t qs = q.size(); qs > 0; --qs) {\\n        const auto [r, c] = q.front();\\n        q.pop();\\n        if (r == rows - 1 && c == cols - 1) {\\n          return visited_cells;\\n        }\\n        set<int> &unvisited_col = unvisited_cols[c];\\n        for (auto itr = unvisited_col.lower_bound(r + 1);\\n             itr != unvisited_col.end() && *itr < r + grid[r][c] + 1;\\n             itr = unvisited_col.erase(itr)) {\\n          const int nr = *itr;\\n          if (!visited[nr][c]) {\\n            visited[nr][c] = true;\\n            q.emplace(nr, c);\\n          }\\n        }\\n        set<int> &unvisited_row = unvisited_rows[r];\\n        for (auto itr = unvisited_row.lower_bound(c + 1);\\n             itr != unvisited_row.end() && *itr < c + grid[r][c] + 1;\\n             itr = unvisited_row.erase(itr)) {\\n          const int nc = *itr;\\n          if (!visited[r][nc]) {\\n            visited[r][nc] = true;\\n            q.emplace(r, nc);\\n          }\\n        }\\n      }\\n    }\\n    return -1;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(rows * cols * (log(rows) + log(cols)))\\n * Space Complexity: O(rows * cols)\\n * where `rows` is the number of the rows of the matrix `grid`\\n *       `cols` is the number of the columns of the matrix `grid`\\n */\\nclass Solution {\\n public:\\n  int minimumVisitedCells(const vector<vector<int>> &grid) {\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    set<int> unvisited_rows[rows];\\n    for (int r = 0; r < rows; ++r) {\\n      if (r == 0) {\\n        for (int c = 0; c < cols; ++c) {\\n          unvisited_rows[r].emplace(c);\\n        }\\n        continue;\\n      }\\n      unvisited_rows[r] = unvisited_rows[r - 1];\\n    }\\n    set<int> unvisited_cols[cols];\\n    for (int c = 0; c < cols; ++c) {\\n      if (c == 0) {\\n        for (int r = 0; r < rows; ++r) {\\n          unvisited_cols[c].emplace(r);\\n        }\\n        continue;\\n      }\\n      unvisited_cols[c] = unvisited_cols[c - 1];\\n    }\\n    bool visited[rows][cols];\\n    memset(visited, 0, sizeof(visited));\\n    queue<pair<int, int>> q({make_pair(0, 0)});\\n    unvisited_rows[0].erase(0);\\n    unvisited_cols[0].erase(0);\\n    visited[0][0] = true;\\n    int visited_cells = 0;\\n    while (!q.empty()) {\\n      ++visited_cells;\\n      for (size_t qs = q.size(); qs > 0; --qs) {\\n        const auto [r, c] = q.front();\\n        q.pop();\\n        if (r == rows - 1 && c == cols - 1) {\\n          return visited_cells;\\n        }\\n        set<int> &unvisited_col = unvisited_cols[c];\\n        for (auto itr = unvisited_col.lower_bound(r + 1);\\n             itr != unvisited_col.end() && *itr < r + grid[r][c] + 1;\\n             itr = unvisited_col.erase(itr)) {\\n          const int nr = *itr;\\n          if (!visited[nr][c]) {\\n            visited[nr][c] = true;\\n            q.emplace(nr, c);\\n          }\\n        }\\n        set<int> &unvisited_row = unvisited_rows[r];\\n        for (auto itr = unvisited_row.lower_bound(c + 1);\\n             itr != unvisited_row.end() && *itr < c + grid[r][c] + 1;\\n             itr = unvisited_row.erase(itr)) {\\n          const int nc = *itr;\\n          if (!visited[r][nc]) {\\n            visited[r][nc] = true;\\n            q.emplace(r, nc);\\n          }\\n        }\\n      }\\n    }\\n    return -1;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396007,
                "title": "c-bfs-minimum-number-of-visited-cells-in-a-grid",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n    int m = grid.size(), n = grid[0].size(), steps = 0;\\n    vector<int> max_i(n), max_j(m);\\n    vector<pair<int, int>> q{{0, 0}}, q1;\\n    while (!q.empty()) {\\n        steps++;\\n        for (auto [i, j] : q) {\\n            if (i == m - 1 && j == n - 1)\\n                return steps;\\n            for (int k = max(max_i[j], i) + 1; k < m && k - i <= grid[i][j]; k++)\\n                q1.push_back({k, j});\\n            for (int k = max(max_j[i], j) + 1; k < n && k - j <= grid[i][j]; k++)\\n                q1.push_back({i, k});\\n            max_i[j] = max(max_i[j], i + grid[i][j]);\\n            max_j[i] = max(max_j[i], j + grid[i][j]);\\n        }\\n        swap(q, q1);\\n        q1.clear();\\n    }\\n    return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n    int m = grid.size(), n = grid[0].size(), steps = 0;\\n    vector<int> max_i(n), max_j(m);\\n    vector<pair<int, int>> q{{0, 0}}, q1;\\n    while (!q.empty()) {\\n        steps++;\\n        for (auto [i, j] : q) {\\n            if (i == m - 1 && j == n - 1)\\n                return steps;\\n            for (int k = max(max_i[j], i) + 1; k < m && k - i <= grid[i][j]; k++)\\n                q1.push_back({k, j});\\n            for (int k = max(max_j[i], j) + 1; k < n && k - j <= grid[i][j]; k++)\\n                q1.push_back({i, k});\\n            max_i[j] = max(max_i[j], i + grid[i][j]);\\n            max_j[i] = max(max_j[i], j + grid[i][j]);\\n        }\\n        swap(q, q1);\\n        q1.clear();\\n    }\\n    return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396005,
                "title": "c-bfs-with-next-unvisited-index-for-rows-and-columns",
                "content": "# Complexity\\n\\n- Time complexity: $$O(mn)$$\\n\\n- Space complexity: $$O(mn)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public int MinimumVisitedCells(int[][] grid)\\n    {\\n        int m = grid.Length;\\n        int n = grid[0].Length;\\n        \\n        var queue = new Queue<(int, int)>();\\n        \\n        int[] rows = new int[m];\\n        int[] cols = new int[n];\\n        \\n        queue.Enqueue((0, 0));\\n        rows[0] = 1;\\n        cols[0] = 1;\\n        \\n        int d = 1;\\n        \\n        int count;\\n        (int, int) tuple;\\n        int x;\\n        int y;\\n        while (queue.Count > 0)\\n        {\\n            count = queue.Count;\\n            for (int i = 0; i < count; i++)\\n            {\\n                tuple = queue.Dequeue();\\n                x = tuple.Item1;\\n                y = tuple.Item2;\\n                \\n                if (x == m - 1 && y == n - 1)\\n                {\\n                    return d;\\n                }\\n                \\n                for (int j = Math.Max(y + 1, rows[x]); j <= Math.Min(n - 1, grid[x][y] + y); j++)\\n                {\\n                    queue.Enqueue((x, j));\\n                    rows[x] = j + 1;\\n                }\\n                        \\n                for (int j = Math.Max(x + 1, cols[y]); j <= Math.Min(m - 1, grid[x][y] + x); j++)\\n                {\\n                    queue.Enqueue((j, y));\\n                    cols[y] = j + 1;\\n                }\\n            }\\n            \\n            d++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int MinimumVisitedCells(int[][] grid)\\n    {\\n        int m = grid.Length;\\n        int n = grid[0].Length;\\n        \\n        var queue = new Queue<(int, int)>();\\n        \\n        int[] rows = new int[m];\\n        int[] cols = new int[n];\\n        \\n        queue.Enqueue((0, 0));\\n        rows[0] = 1;\\n        cols[0] = 1;\\n        \\n        int d = 1;\\n        \\n        int count;\\n        (int, int) tuple;\\n        int x;\\n        int y;\\n        while (queue.Count > 0)\\n        {\\n            count = queue.Count;\\n            for (int i = 0; i < count; i++)\\n            {\\n                tuple = queue.Dequeue();\\n                x = tuple.Item1;\\n                y = tuple.Item2;\\n                \\n                if (x == m - 1 && y == n - 1)\\n                {\\n                    return d;\\n                }\\n                \\n                for (int j = Math.Max(y + 1, rows[x]); j <= Math.Min(n - 1, grid[x][y] + y); j++)\\n                {\\n                    queue.Enqueue((x, j));\\n                    rows[x] = j + 1;\\n                }\\n                        \\n                for (int j = Math.Max(x + 1, cols[y]); j <= Math.Min(m - 1, grid[x][y] + x); j++)\\n                {\\n                    queue.Enqueue((j, y));\\n                    cols[y] = j + 1;\\n                }\\n            }\\n            \\n            d++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396001,
                "title": "java-only-regular-bfs",
                "content": "# Intuition\\nWe could solve this question with the **BFS**.\\nOnce we found the bottom left cell while moving, return directly.\\nOtherwise, avoid adding the cell with value **0** into the queue\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumVisitedCells(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        if(m == 1 && n == 1) return 1;\\n        \\n        Queue<int[]> queue = new ArrayDeque<>();\\n        boolean[][] visited = new boolean[m][n];\\n        queue.add(new int[]{0, 0});\\n        int numCells = 1;\\n\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; ++i) {\\n                int[] cell = queue.poll();\\n                int x = cell[0], y = cell[1];\\n                int val = grid[x][y];\\n\\n                // move right\\n                int rightBoundary = Math.min(n - 1, y + val);\\n                for (int col = y + 1; col <= rightBoundary; ++col) {\\n                    if (x == m - 1 && col == n - 1) return numCells + 1;\\n                    if (grid[x][col] != 0 && !visited[x][col]) {\\n                        queue.add(new int[]{x, col});\\n                        visited[x][col] = true;\\n                    }\\n                }\\n\\n                // move down\\n                int downBoundary = Math.min(m - 1, x + val);\\n                for (int row = x + 1; row <= downBoundary; ++row) {\\n                    if (row == m - 1 && y == n - 1) return numCells + 1;\\n                    if (grid[row][y] != 0 && !visited[row][y]) {\\n                        queue.add(new int[]{row, y});\\n                        visited[row][y] = true;\\n                    }\\n                }\\n            }\\n            numCells += 1;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumVisitedCells(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        if(m == 1 && n == 1) return 1;\\n        \\n        Queue<int[]> queue = new ArrayDeque<>();\\n        boolean[][] visited = new boolean[m][n];\\n        queue.add(new int[]{0, 0});\\n        int numCells = 1;\\n\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; ++i) {\\n                int[] cell = queue.poll();\\n                int x = cell[0], y = cell[1];\\n                int val = grid[x][y];\\n\\n                // move right\\n                int rightBoundary = Math.min(n - 1, y + val);\\n                for (int col = y + 1; col <= rightBoundary; ++col) {\\n                    if (x == m - 1 && col == n - 1) return numCells + 1;\\n                    if (grid[x][col] != 0 && !visited[x][col]) {\\n                        queue.add(new int[]{x, col});\\n                        visited[x][col] = true;\\n                    }\\n                }\\n\\n                // move down\\n                int downBoundary = Math.min(m - 1, x + val);\\n                for (int row = x + 1; row <= downBoundary; ++row) {\\n                    if (row == m - 1 && y == n - 1) return numCells + 1;\\n                    if (grid[row][y] != 0 && !visited[row][y]) {\\n                        queue.add(new int[]{row, y});\\n                        visited[row][y] = true;\\n                    }\\n                }\\n            }\\n            numCells += 1;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395997,
                "title": "simple-dijkstra-solution-c",
                "content": "class Solution {\\npublic:\\n\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n    \\n      int n=grid.size();\\n      int m=grid[0].size();\\n      \\n      \\n\\n      priority_queue<pair<int,pair<int,int>>>pq;\\n       pq.push({-1,{0,0}});\\n      vector<vector<int>>temp(n,vector<int>(m,1e9));\\n      temp[0][0]=0;\\n      \\n            \\n           \\n      \\n      while(!pq.empty()){\\n        \\n      \\n        int d=-pq.top().first;\\n        int x=pq.top().second.first;\\n        int y=pq.top().second.second;\\n        pq.pop();\\n        if(x==n-1 && y==m-1) return d;\\n        for(int k=1;k<=grid[x][y];k++){\\n          int i=x+k;\\n          int j=y+k;\\n          if(i<n && temp[i][y]>1+d){\\n            temp[i][y]=1+d;\\n            pq.push({-temp[i][y],{i,y}});\\n          }\\n          if(j<m && temp[x][j]>1+d){\\n            temp[x][j]=1+d;\\n            pq.push({-temp[x][j],{x,j}});\\n          }\\n          if(i>=n && j>=m){\\n            break;\\n          }\\n          \\n        }\\n        \\n      }\\n      return -1;\\n      \\n        \\n    }\\n };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n    \\n      int n=grid.size();\\n      int m=grid[0].size();\\n      \\n      \\n\\n      priority_queue<pair<int,pair<int,int>>>pq;\\n       pq.push({-1,{0,0}",
                "codeTag": "Java"
            },
            {
                "id": 3395996,
                "title": "monotonic-stack-dp-java-solution-o-mn-linear-time",
                "content": "# Intuition\\nMaintain the min number of cells of the current row and the columns in a monotonic stack. Calculate min among the reachable cells to the right and the bottom.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(mn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(mn)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumVisitedCells(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n        dp[m-1][n-1] = 1;\\n        Deque<Integer> rs = new LinkedList<>();\\n        Deque<Integer>[] ts = new Deque[n];\\n        for(int i = n-2; i >= 0; i--) {\\n            if(grid[m-1][i]+i >= n-1) {\\n                dp[m-1][i] = 2;\\n                while(!rs.isEmpty() && dp[m-1][rs.peek()] >= 2) {\\n                    rs.pop();\\n                }\\n                rs.push(i);\\n            } else {\\n                Iterator<Integer> it = rs.iterator();\\n                int prev = -1;\\n                while(it.hasNext()) {\\n                    int ni = it.next();\\n                    if(grid[m-1][i]+i < ni) {\\n                        dp[m-1][i] = prev == -1 ? prev : 1 + dp[m-1][prev];\\n                        \\n                        \\n                        break;\\n                    }\\n                    prev = ni;\\n                }\\n                dp[m-1][i] = prev == -1 ? prev : dp[m-1][prev] + 1;\\n                while(dp[m-1][i] != -1 &&!rs.isEmpty() && dp[m-1][rs.peek()] >= dp[m-1][i]) {\\n                            rs.pop();\\n                        }\\n                        if(dp[m-1][i] != -1)\\n                        rs.push(i);\\n                if(dp[m-1][i] == 0)\\n                    dp[m-1][i] = -1;\\n            }\\n            ts[i] = new LinkedList<>();\\n            if(dp[m-1][i] != -1)\\n            ts[i].push(m-1);\\n        }\\n        rs = new LinkedList<>();\\n        for(int i = m-2; i >= 0; i--) {\\n            if(grid[i][n-1]+i >= m-1) {\\n                dp[i][n-1] = 2;\\n                while(!rs.isEmpty() && dp[rs.peek()][n-1] >= 2) {\\n                    rs.pop();\\n                }\\n                rs.push(i);\\n            } else {\\n                Iterator<Integer> it = rs.iterator();\\n                int prev = -1;\\n                while(it.hasNext()) {\\n                    int ni = it.next();\\n                    if(grid[i][n-1]+i < ni) {\\n                        dp[i][n-1] = prev == -1 ? -1 : 1 + dp[prev][n-1];\\n                        break;\\n                    }\\n                    prev = ni;\\n                }\\n                dp[i][n-1] = prev == -1 ? -1 : dp[prev][n-1]+1;\\n                while(prev != -1 &&!rs.isEmpty() && dp[rs.peek()][n-1] >= dp[i][n-1]) {\\n                            rs.pop();\\n                        }\\n                        if(prev != -1)\\n                        rs.push(i);\\n                if(dp[i][n-1] == 0)\\n                    dp[i][n-1] = -1;\\n            }\\n        }\\n        \\n        for(int i = m-2; i>= 0; i--) {\\n            rs = new LinkedList<>();\\n            if(dp[i][n-1] != -1)\\n            rs.push(n-1);\\n            for(int j = n-2; j>=0; j--) {\\n                Iterator<Integer> it = rs.iterator();\\n                int tval = Integer.MAX_VALUE;\\n                int prev = -1;\\n                while(it.hasNext()) {\\n                    int ni = it.next();\\n                    if(grid[i][j]+j < ni) {\\n                        tval = prev == -1 ? tval : 1 + dp[i][prev];\\n                        break;\\n                    }\\n                    prev = ni;\\n                }\\n                tval = prev == -1 ? tval : 1 + dp[i][prev];\\n                it = ts[j].iterator();\\n                int tval2 = Integer.MAX_VALUE;\\n                prev = -1;\\n                while(it.hasNext()) {\\n                    int ni = it.next();\\n                    if(grid[i][j]+i < ni) {\\n                        tval2 = prev == -1 ? tval2  : 1 + dp[prev][j];\\n                        break;\\n                    }\\n                    prev = ni;\\n                }\\n                tval2 = prev == -1 ? tval2 : 1 + dp[prev][j];\\n                dp[i][j] = Math.min(tval, tval2) == Integer.MAX_VALUE ? -1 : Math.min(tval, tval2);\\n                while(dp[i][j] != -1 && !rs.isEmpty() && dp[i][rs.peek()] >= dp[i][j]) {\\n                            rs.pop();\\n                        }\\n                if(dp[i][j] != -1)\\n                        rs.push(j);\\n                while(dp[i][j] != -1 && !ts[j].isEmpty() && dp[ts[j].peek()][j] >= dp[i][j]) {\\n                            ts[j].pop();\\n                        }\\n                if(dp[i][j] != -1)\\n                        ts[j].push(i);\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumVisitedCells(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n        dp[m-1][n-1] = 1;\\n        Deque<Integer> rs = new LinkedList<>();\\n        Deque<Integer>[] ts = new Deque[n];\\n        for(int i = n-2; i >= 0; i--) {\\n            if(grid[m-1][i]+i >= n-1) {\\n                dp[m-1][i] = 2;\\n                while(!rs.isEmpty() && dp[m-1][rs.peek()] >= 2) {\\n                    rs.pop();\\n                }\\n                rs.push(i);\\n            } else {\\n                Iterator<Integer> it = rs.iterator();\\n                int prev = -1;\\n                while(it.hasNext()) {\\n                    int ni = it.next();\\n                    if(grid[m-1][i]+i < ni) {\\n                        dp[m-1][i] = prev == -1 ? prev : 1 + dp[m-1][prev];\\n                        \\n                        \\n                        break;\\n                    }\\n                    prev = ni;\\n                }\\n                dp[m-1][i] = prev == -1 ? prev : dp[m-1][prev] + 1;\\n                while(dp[m-1][i] != -1 &&!rs.isEmpty() && dp[m-1][rs.peek()] >= dp[m-1][i]) {\\n                            rs.pop();\\n                        }\\n                        if(dp[m-1][i] != -1)\\n                        rs.push(i);\\n                if(dp[m-1][i] == 0)\\n                    dp[m-1][i] = -1;\\n            }\\n            ts[i] = new LinkedList<>();\\n            if(dp[m-1][i] != -1)\\n            ts[i].push(m-1);\\n        }\\n        rs = new LinkedList<>();\\n        for(int i = m-2; i >= 0; i--) {\\n            if(grid[i][n-1]+i >= m-1) {\\n                dp[i][n-1] = 2;\\n                while(!rs.isEmpty() && dp[rs.peek()][n-1] >= 2) {\\n                    rs.pop();\\n                }\\n                rs.push(i);\\n            } else {\\n                Iterator<Integer> it = rs.iterator();\\n                int prev = -1;\\n                while(it.hasNext()) {\\n                    int ni = it.next();\\n                    if(grid[i][n-1]+i < ni) {\\n                        dp[i][n-1] = prev == -1 ? -1 : 1 + dp[prev][n-1];\\n                        break;\\n                    }\\n                    prev = ni;\\n                }\\n                dp[i][n-1] = prev == -1 ? -1 : dp[prev][n-1]+1;\\n                while(prev != -1 &&!rs.isEmpty() && dp[rs.peek()][n-1] >= dp[i][n-1]) {\\n                            rs.pop();\\n                        }\\n                        if(prev != -1)\\n                        rs.push(i);\\n                if(dp[i][n-1] == 0)\\n                    dp[i][n-1] = -1;\\n            }\\n        }\\n        \\n        for(int i = m-2; i>= 0; i--) {\\n            rs = new LinkedList<>();\\n            if(dp[i][n-1] != -1)\\n            rs.push(n-1);\\n            for(int j = n-2; j>=0; j--) {\\n                Iterator<Integer> it = rs.iterator();\\n                int tval = Integer.MAX_VALUE;\\n                int prev = -1;\\n                while(it.hasNext()) {\\n                    int ni = it.next();\\n                    if(grid[i][j]+j < ni) {\\n                        tval = prev == -1 ? tval : 1 + dp[i][prev];\\n                        break;\\n                    }\\n                    prev = ni;\\n                }\\n                tval = prev == -1 ? tval : 1 + dp[i][prev];\\n                it = ts[j].iterator();\\n                int tval2 = Integer.MAX_VALUE;\\n                prev = -1;\\n                while(it.hasNext()) {\\n                    int ni = it.next();\\n                    if(grid[i][j]+i < ni) {\\n                        tval2 = prev == -1 ? tval2  : 1 + dp[prev][j];\\n                        break;\\n                    }\\n                    prev = ni;\\n                }\\n                tval2 = prev == -1 ? tval2 : 1 + dp[prev][j];\\n                dp[i][j] = Math.min(tval, tval2) == Integer.MAX_VALUE ? -1 : Math.min(tval, tval2);\\n                while(dp[i][j] != -1 && !rs.isEmpty() && dp[i][rs.peek()] >= dp[i][j]) {\\n                            rs.pop();\\n                        }\\n                if(dp[i][j] != -1)\\n                        rs.push(j);\\n                while(dp[i][j] != -1 && !ts[j].isEmpty() && dp[ts[j].peek()][j] >= dp[i][j]) {\\n                            ts[j].pop();\\n                        }\\n                if(dp[i][j] != -1)\\n                        ts[j].push(i);\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395990,
                "title": "c-bfs",
                "content": "```\\n    int minimumVisitedCells(vector<vector<int>>& G) {\\n        queue<array<int, 2>> q;\\n        q.push({0, 0});\\n        \\n        int m = G.size(), n = G[0].size();\\n        vector<vector<int>> seen(m, vector<int>(n, 0));\\n        seen[0][0] = 1;\\n        int res = 1;\\n        \\n        vector<vector<int>> max_p(m, vector<int>(n, 0));\\n        vector<int> r_max(n, 0), c_max(m, 0);\\n        \\n        while(!q.empty()) {\\n            for(int sz = q.size(); sz > 0; sz--) {\\n                auto p = q.front(); q.pop();\\n                int x = p[0], y = p[1];\\n                if(x == m-1 && y == n-1) return res;\\n                for(int i = max(r_max[y], x+1); i <= x + G[x][y] && i < m; i++) {\\n                    if(seen[i][y] == 0) {\\n                        seen[i][y] = 1;\\n                        q.push({i, y});\\n                    }\\n                }\\n                r_max[y] = max(r_max[y], x + G[x][y]+1);\\n                for(int j = max(c_max[x], y+1); j <= y + G[x][y] && j < n; j++) {\\n                    if(seen[x][j] == 0) {\\n                        seen[x][j] = 1;\\n                        q.push({x, j});\\n                    }\\n                }\\n                c_max[x] = max(c_max[x], y + G[x][y]+1);\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int minimumVisitedCells(vector<vector<int>>& G) {\\n        queue<array<int, 2>> q;\\n        q.push({0, 0});\\n        \\n        int m = G.size(), n = G[0].size();\\n        vector<vector<int>> seen(m, vector<int>(n, 0));\\n        seen[0][0] = 1;\\n        int res = 1;\\n        \\n        vector<vector<int>> max_p(m, vector<int>(n, 0));\\n        vector<int> r_max(n, 0), c_max(m, 0);\\n        \\n        while(!q.empty()) {\\n            for(int sz = q.size(); sz > 0; sz--) {\\n                auto p = q.front(); q.pop();\\n                int x = p[0], y = p[1];\\n                if(x == m-1 && y == n-1) return res;\\n                for(int i = max(r_max[y], x+1); i <= x + G[x][y] && i < m; i++) {\\n                    if(seen[i][y] == 0) {\\n                        seen[i][y] = 1;\\n                        q.push({i, y});\\n                    }\\n                }\\n                r_max[y] = max(r_max[y], x + G[x][y]+1);\\n                for(int j = max(c_max[x], y+1); j <= y + G[x][y] && j < n; j++) {\\n                    if(seen[x][j] == 0) {\\n                        seen[x][j] = 1;\\n                        q.push({x, j});\\n                    }\\n                }\\n                c_max[x] = max(c_max[x], y + G[x][y]+1);\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3395976,
                "title": "bfs-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int ans = 1;\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        vector<vector<bool>> vis(grid.size(),vector<bool> (grid[0].size()));\\n        while(q.size()){\\n            int sz = q.size();\\n            ans++;\\n            while(sz--){\\n                auto [i,j] = q.front(); q.pop();\\n                if(i == grid.size()-1 and j == grid[0].size()-1) return ans-1;\\n                for(int col=j+1;col<=(grid[i][j]+j);col++){\\n                    if(col >= grid[0].size() or vis[i][col]) continue;\\n                    q.push({i,col}); vis[i][col] = true;\\n                    if(i == grid.size()-1 and col == grid[0].size()-1) return ans;\\n                }\\n                for(int row=i+1;row<=(grid[i][j]+i);row++){\\n                    if(row >= grid.size() or vis[row][j]) continue;\\n                    q.push({row,j}); vis[row][j] = true;\\n                    if(row == grid.size()-1 and j == grid[0].size()-1) return ans;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int ans = 1;\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        vector<vector<bool>> vis(grid.size(),vector<bool> (grid[0].size()));\\n        while(q.size()){\\n            int sz = q.size();\\n            ans++;\\n            while(sz--){\\n                auto [i,j] = q.front(); q.pop();\\n                if(i == grid.size()-1 and j == grid[0].size()-1) return ans-1;\\n                for(int col=j+1;col<=(grid[i][j]+j);col++){\\n                    if(col >= grid[0].size() or vis[i][col]) continue;\\n                    q.push({i,col}); vis[i][col] = true;\\n                    if(i == grid.size()-1 and col == grid[0].size()-1) return ans;\\n                }\\n                for(int row=i+1;row<=(grid[i][j]+i);row++){\\n                    if(row >= grid.size() or vis[row][j]) continue;\\n                    q.push({row,j}); vis[row][j] = true;\\n                    if(row == grid.size()-1 and j == grid[0].size()-1) return ans;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395953,
                "title": "python-3-bfs-tracking-unvisited-grids",
                "content": "Similar idea to [2612. Minimum Reverse Operations](https://leetcode.com/problems/minimum-reverse-operations/), to avoid TLE, we maintain two matrices tracking unvisited nodes horizontally and vertically. Each time we arrive at a node, binary search for unvisited nodes in both horizontal and vertical candidate in the matrices, push them to queue and remove them from the matrices. \\n\\n**Note that a `i, j` exists in both `horizontal[i][j]` and `vertical[j][i]` matrices, and must be removed from both. Got TLE when I incorrectly removed only one instance.**\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        candh = [SortedList(range(n)) for _ in range(m)]\\n        candv = [SortedList(range(m)) for _ in range(n)]\\n        stk = deque([(1, 0, 0)])\\n\\n        while stk:\\n            cnt, i, j = stk.popleft()\\n            if i == m - 1 and j == n - 1:\\n                return cnt\\n            cnt += 1\\n            \\n            for x in list(candh[i].irange(j + 1, grid[i][j] + j)):\\n                stk.append((cnt, i, x))\\n                candh[i].remove(x)\\n                candv[x].remove(i)\\n\\n            for x in list(candv[j].irange(i + 1, grid[i][j] + i)):\\n                stk.append((cnt, x, j))\\n                candv[j].remove(x)\\n                candh[x].remove(j)\\n            \\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        candh = [SortedList(range(n)) for _ in range(m)]\\n        candv = [SortedList(range(m)) for _ in range(n)]\\n        stk = deque([(1, 0, 0)])\\n\\n        while stk:\\n            cnt, i, j = stk.popleft()\\n            if i == m - 1 and j == n - 1:\\n                return cnt\\n            cnt += 1\\n            \\n            for x in list(candh[i].irange(j + 1, grid[i][j] + j)):\\n                stk.append((cnt, i, x))\\n                candh[i].remove(x)\\n                candv[x].remove(i)\\n\\n            for x in list(candv[j].irange(i + 1, grid[i][j] + i)):\\n                stk.append((cnt, x, j))\\n                candv[j].remove(x)\\n                candh[x].remove(j)\\n            \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395949,
                "title": "tle-during-contest-solved-with-just-one-optimization-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumVisitedCells(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n\\n        boolean [][] visited = new boolean[m][n];\\n\\n        queue.offer(new int[]{0, 0, 1});\\n        visited[0][0] = true;\\n       \\n        \\n        while (!queue.isEmpty()) {\\n            int[] aux = queue.poll();\\n            int i = aux[0];\\n            int j = aux[1];\\n            int steps = aux[2];\\n            \\n            //reached end return steps\\n            if (i == m-1 && j == n-1) {\\n                return steps;\\n            }\\n\\n            for (int k = j+1; k <= Math.min(n-1, j+grid[i][j]); k++) {\\n                if (!visited[i][k]) {\\n                    queue.offer(new int[]{i, k, steps+1});\\n                    visited[i][k] = true;\\n                    //I missed this check and got TLE during contest\\n                    if (i == m-1 && k == n-1) {\\n                        return steps+1;\\n                    }\\n                }\\n            }\\n\\n            for (int k = i+1; k <= Math.min(m-1, i+grid[i][j]); k++) {\\n                if (!visited[k][j]) {\\n                    queue.offer(new int[]{k, j, steps+1});\\n                    //I missed this check and got TLE during contest\\n                    if (k == m-1 && j == n-1) {\\n                        return steps+1;\\n                    }\\n                    visited[k][j] = true;\\n                }\\n            }\\n        }\\n        return -1; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumVisitedCells(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n\\n        boolean [][] visited = new boolean[m][n];\\n\\n        queue.offer(new int[]{0, 0, 1});\\n        visited[0][0] = true;\\n       \\n        \\n        while (!queue.isEmpty()) {\\n            int[] aux = queue.poll();\\n            int i = aux[0];\\n            int j = aux[1];\\n            int steps = aux[2];\\n            \\n            //reached end return steps\\n            if (i == m-1 && j == n-1) {\\n                return steps;\\n            }\\n\\n            for (int k = j+1; k <= Math.min(n-1, j+grid[i][j]); k++) {\\n                if (!visited[i][k]) {\\n                    queue.offer(new int[]{i, k, steps+1});\\n                    visited[i][k] = true;\\n                    //I missed this check and got TLE during contest\\n                    if (i == m-1 && k == n-1) {\\n                        return steps+1;\\n                    }\\n                }\\n            }\\n\\n            for (int k = i+1; k <= Math.min(m-1, i+grid[i][j]); k++) {\\n                if (!visited[k][j]) {\\n                    queue.offer(new int[]{k, j, steps+1});\\n                    //I missed this check and got TLE during contest\\n                    if (k == m-1 && j == n-1) {\\n                        return steps+1;\\n                    }\\n                    visited[k][j] = true;\\n                }\\n            }\\n        }\\n        return -1; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395934,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        rows = len(grid)\\n        cols=len(grid[0])\\n        dist = [[math.inf for _ in range(cols)] for _ in range(rows)]\\n        dist[0][0] = 1\\n        \\n        q = collections.deque([(0, 0)])\\n        \\n        while q:\\n            i, j = q.popleft()\\n            \\n            if i == rows - 1 and j == cols - 1:\\n                return dist[i][j]\\n            \\n            for k in range(min(grid[i][j] + j, cols - 1), j, -1):\\n                if dist[i][k] > dist[i][j] + 1:\\n                    dist[i][k] = dist[i][j] + 1\\n                    q.append((i, k))\\n                \\n            for k in range(min(grid[i][j] + i, rows - 1), i, -1):\\n                if dist[k][j] > dist[i][j] + 1:\\n                    dist[k][j] = dist[i][j] + 1\\n                    q.append((k, j))\\n                    \\n        return -1 \\n                \\n                \\n                \\n            \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        rows = len(grid)\\n        cols=len(grid[0])\\n        dist = [[math.inf for _ in range(cols)] for _ in range(rows)]\\n        dist[0][0] = 1\\n        \\n        q = collections.deque([(0, 0)])\\n        \\n        while q:\\n            i, j = q.popleft()\\n            \\n            if i == rows - 1 and j == cols - 1:\\n                return dist[i][j]\\n            \\n            for k in range(min(grid[i][j] + j, cols - 1), j, -1):\\n                if dist[i][k] > dist[i][j] + 1:\\n                    dist[i][k] = dist[i][j] + 1\\n                    q.append((i, k))\\n                \\n            for k in range(min(grid[i][j] + i, rows - 1), i, -1):\\n                if dist[k][j] > dist[i][j] + 1:\\n                    dist[k][j] = dist[i][j] + 1\\n                    q.append((k, j))\\n                    \\n        return -1 \\n                \\n                \\n                \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395926,
                "title": "dp-optimized-by-maintaining-multisets",
                "content": "# Code\\n```\\ntypedef long long ll;\\n\\nll min(ll a, ll b) {\\n    if (a <= b) {\\n        return a;\\n    } else {\\n        return b;\\n    }\\n}\\n\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        ll n = grid.size();\\n        ll m = grid[0].size();\\n        multiset<ll> ms[m]; //vertical multisets\\n        vector<ll> hend[n][m];\\n        vector<ll> vend[n][m];\\n        \\n        if (n == 1 && m == 1) {\\n            return 1;\\n        }\\n                \\n        ll dp[n][m];\\n        multiset<ll> hor;\\n        for (ll j = 0; j < m; j++) {\\n            if (j == 0) {\\n                dp[0][0] = 0;\\n            } else if (hor.size() == 0) {\\n                dp[0][j] = 10000000;\\n            } else {\\n                ll cur = *hor.begin();\\n                dp[0][j] = cur;\\n            }\\n            \\n            if (dp[0][j] != 10000000) {\\n                ms[j].insert(dp[0][j]+1);\\n                hor.insert(dp[0][j]+1);\\n                vend[min(n-1, grid[0][j])][j].push_back(dp[0][j]+1);\\n                hend[0][min(m-1, j+grid[0][j])].push_back(dp[0][j]+1);\\n            }\\n            \\n            if (hend[0][j].size() > 0) {\\n                for (auto el: hend[0][j]) {\\n                    hor.erase(hor.find(el));\\n                }\\n            }\\n            \\n            if (vend[0][j].size() > 0) {\\n                for (auto el: vend[0][j]) {\\n                    ms[j].erase(ms[j].find(el));\\n                }\\n            }\\n        }\\n                \\n        for (ll i = 1; i < n; i++) {\\n            hor.clear();\\n            for (ll j = 0; j < m; j++) {                \\n                if (hor.size() > 0 && ms[j].size() > 0) {\\n                    ll cur1 = *hor.begin();\\n                    ll cur2 = *ms[j].begin();\\n                    dp[i][j] = min(cur1, cur2);\\n                } else if (hor.size() > 0) {\\n                    ll cur = *hor.begin();\\n                    dp[i][j] = cur;\\n                } else if (ms[j].size() > 0) {\\n                    ll cur = *ms[j].begin();\\n                    dp[i][j] = cur;\\n                } else {\\n                    dp[i][j] = 10000000;\\n                } \\n                \\n                if (dp[i][j] != 10000000) {\\n                    ms[j].insert(dp[i][j]+1);\\n                    hor.insert(dp[i][j]+1);\\n                    vend[min(n-1, i+grid[i][j])][j].push_back(dp[i][j]+1);\\n                    hend[i][min(m-1, j+grid[i][j])].push_back(dp[i][j]+1);\\n                }\\n                                \\n                if (hend[i][j].size() > 0) {\\n                    for (auto el: hend[i][j]) {\\n                        hor.erase(hor.find(el));\\n                    }\\n                }\\n                \\n                if (vend[i][j].size() > 0) {\\n                    for (auto el: vend[i][j]) {\\n                        ms[j].erase(ms[j].find(el));\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (dp[n-1][m-1] == 10000000) {\\n            return -1;\\n        } else {\\n            return dp[n-1][m-1]+1;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef long long ll;\\n\\nll min(ll a, ll b) {\\n    if (a <= b) {\\n        return a;\\n    } else {\\n        return b;\\n    }\\n}\\n\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        ll n = grid.size();\\n        ll m = grid[0].size();\\n        multiset<ll> ms[m]; //vertical multisets\\n        vector<ll> hend[n][m];\\n        vector<ll> vend[n][m];\\n        \\n        if (n == 1 && m == 1) {\\n            return 1;\\n        }\\n                \\n        ll dp[n][m];\\n        multiset<ll> hor;\\n        for (ll j = 0; j < m; j++) {\\n            if (j == 0) {\\n                dp[0][0] = 0;\\n            } else if (hor.size() == 0) {\\n                dp[0][j] = 10000000;\\n            } else {\\n                ll cur = *hor.begin();\\n                dp[0][j] = cur;\\n            }\\n            \\n            if (dp[0][j] != 10000000) {\\n                ms[j].insert(dp[0][j]+1);\\n                hor.insert(dp[0][j]+1);\\n                vend[min(n-1, grid[0][j])][j].push_back(dp[0][j]+1);\\n                hend[0][min(m-1, j+grid[0][j])].push_back(dp[0][j]+1);\\n            }\\n            \\n            if (hend[0][j].size() > 0) {\\n                for (auto el: hend[0][j]) {\\n                    hor.erase(hor.find(el));\\n                }\\n            }\\n            \\n            if (vend[0][j].size() > 0) {\\n                for (auto el: vend[0][j]) {\\n                    ms[j].erase(ms[j].find(el));\\n                }\\n            }\\n        }\\n                \\n        for (ll i = 1; i < n; i++) {\\n            hor.clear();\\n            for (ll j = 0; j < m; j++) {                \\n                if (hor.size() > 0 && ms[j].size() > 0) {\\n                    ll cur1 = *hor.begin();\\n                    ll cur2 = *ms[j].begin();\\n                    dp[i][j] = min(cur1, cur2);\\n                } else if (hor.size() > 0) {\\n                    ll cur = *hor.begin();\\n                    dp[i][j] = cur;\\n                } else if (ms[j].size() > 0) {\\n                    ll cur = *ms[j].begin();\\n                    dp[i][j] = cur;\\n                } else {\\n                    dp[i][j] = 10000000;\\n                } \\n                \\n                if (dp[i][j] != 10000000) {\\n                    ms[j].insert(dp[i][j]+1);\\n                    hor.insert(dp[i][j]+1);\\n                    vend[min(n-1, i+grid[i][j])][j].push_back(dp[i][j]+1);\\n                    hend[i][min(m-1, j+grid[i][j])].push_back(dp[i][j]+1);\\n                }\\n                                \\n                if (hend[i][j].size() > 0) {\\n                    for (auto el: hend[i][j]) {\\n                        hor.erase(hor.find(el));\\n                    }\\n                }\\n                \\n                if (vend[i][j].size() > 0) {\\n                    for (auto el: vend[i][j]) {\\n                        ms[j].erase(ms[j].find(el));\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (dp[n-1][m-1] == 10000000) {\\n            return -1;\\n        } else {\\n            return dp[n-1][m-1]+1;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395916,
                "title": "c-simple-bfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        queue<pair<int,pair<int,int>>> q;\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        q.push({1,{0,0}});\\n        vis[0][0] = 1;\\n        \\n        while(!q.empty())\\n        {\\n            int dist = q.front().first;\\n            int i = q.front().second.first;\\n            int j = q.front().second.second;\\n            q.pop();\\n            if(i == n - 1 && j == m - 1)\\n            {\\n                return dist;\\n            }\\n            if(grid[i][j] == 0)\\n            {\\n                continue;\\n            }\\n            int k = grid[i][j] + j;\\n            for(int idx = min(k,m); idx > j ;idx--)\\n            {\\n                if(idx < m && !vis[i][idx])\\n                {\\n                    q.push({dist + 1,{i,idx}});\\n                    vis[i][idx] = 1;\\n                }\\n            }\\n            k = grid[i][j] + i;  \\n            for(int idx = min(k,n); idx > i ;idx--)\\n            {\\n                if(idx < n && !vis[idx][j])\\n                {\\n                    q.push({dist + 1,{idx,j}});\\n                    vis[idx][j] = 1;\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        queue<pair<int,pair<int,int>>> q;\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        q.push({1,{0,0}});\\n        vis[0][0] = 1;\\n        \\n        while(!q.empty())\\n        {\\n            int dist = q.front().first;\\n            int i = q.front().second.first;\\n            int j = q.front().second.second;\\n            q.pop();\\n            if(i == n - 1 && j == m - 1)\\n            {\\n                return dist;\\n            }\\n            if(grid[i][j] == 0)\\n            {\\n                continue;\\n            }\\n            int k = grid[i][j] + j;\\n            for(int idx = min(k,m); idx > j ;idx--)\\n            {\\n                if(idx < m && !vis[i][idx])\\n                {\\n                    q.push({dist + 1,{i,idx}});\\n                    vis[i][idx] = 1;\\n                }\\n            }\\n            k = grid[i][j] + i;  \\n            for(int idx = min(k,n); idx > i ;idx--)\\n            {\\n                if(idx < n && !vis[idx][j])\\n                {\\n                    q.push({dist + 1,{idx,j}});\\n                    vis[idx][j] = 1;\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395868,
                "title": "c-bfs-union-find-set-real-o-n-log-n",
                "content": "# Intuition\\n\\nIt\\'s very similar with [last week Q4](https://leetcode.com/problems/minimum-reverse-operations/solutions/). We need some special skill to speed up BFS. I learned a special skill to do this by Union-Find Set (Merge-Find set) last week, which can be used in this problem. Unfortunately I cannot find the post where I learned this \\uD83D\\uDE02\\n\\n# Approach\\n\\nBasically it\\'s a BFS. But we use two groups of Union Find Set to mark the cells we have visited. When we visited a cell, we would merge this cell with the right neighbor and down neighbor in the Union Find Set. So the next time we visited this cell, we would just skip it to speed up the BFS.\\n\\nThe Union Find Set is a special designed one, which always return the biggest node number.\\n\\n# Complexity\\n\\n- Let `N=m*n`. Time complexity: `O(N log (N))`\\n- Space complexity: `O(N)` because of the Union Find Set and \\n\\nSome other posts are `O(N^2)` in fact since they cannot skip the visited cells.\\n\\n\\n# Code\\n```\\nstruct MergeBigger {\\n    std::vector<int> p;\\n    MergeBigger(int n) : p(n) { init(); }\\n    int find(int x) { return p[x] == x ? x : p[x] = find(p[x]); }\\n    void merge(int x, int y) {\\n        int rx = find(x), ry = find(y);\\n        int small = std::min(rx, ry), big = std::max(rx, ry);\\n        p[small] = big;\\n    }\\n    void init() {\\n        for (int i = 0; i < int(p.size()); i++) p[i] = i;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size(), n = grid[0].size();\\n        \\n        vector<MergeBigger> jump1(m, MergeBigger(n + 1)), jump2(n, MergeBigger(m + 1));\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        \\n        queue<pair<int, int>> q;\\n        q.push({0, 0});\\n        dp[0][0] = 1;\\n        jump1[0].merge(0, 1);\\n        jump2[0].merge(0, 1);\\n        \\n        while(q.size()) {\\n            int i = q.front().first, j = q.front().second;\\n            q.pop();\\n            int dist = grid[i][j], step = dp[i][j] + 1;\\n            \\n            for(int x = jump2[j].find(i); x <= i + dist and x < m; x = jump2[j].find(x)) {\\n                dp[x][j] = step;\\n                jump2[j].merge(x, x + 1);\\n                jump1[x].merge(j, j + 1);\\n                q.push({x, j});\\n            }\\n            for(int y = jump1[i].find(j); y <= j + dist and y < n; y = jump1[i].find(y)) {\\n                dp[i][y] = step;\\n                jump1[i].merge(y, y + 1);\\n                jump2[y].merge(i, i + 1);\\n                q.push({i, y});\\n            }\\n        }\\n        \\n        return dp[m - 1][n - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct MergeBigger {\\n    std::vector<int> p;\\n    MergeBigger(int n) : p(n) { init(); }\\n    int find(int x) { return p[x] == x ? x : p[x] = find(p[x]); }\\n    void merge(int x, int y) {\\n        int rx = find(x), ry = find(y);\\n        int small = std::min(rx, ry), big = std::max(rx, ry);\\n        p[small] = big;\\n    }\\n    void init() {\\n        for (int i = 0; i < int(p.size()); i++) p[i] = i;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size(), n = grid[0].size();\\n        \\n        vector<MergeBigger> jump1(m, MergeBigger(n + 1)), jump2(n, MergeBigger(m + 1));\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        \\n        queue<pair<int, int>> q;\\n        q.push({0, 0});\\n        dp[0][0] = 1;\\n        jump1[0].merge(0, 1);\\n        jump2[0].merge(0, 1);\\n        \\n        while(q.size()) {\\n            int i = q.front().first, j = q.front().second;\\n            q.pop();\\n            int dist = grid[i][j], step = dp[i][j] + 1;\\n            \\n            for(int x = jump2[j].find(i); x <= i + dist and x < m; x = jump2[j].find(x)) {\\n                dp[x][j] = step;\\n                jump2[j].merge(x, x + 1);\\n                jump1[x].merge(j, j + 1);\\n                q.push({x, j});\\n            }\\n            for(int y = jump1[i].find(j); y <= j + dist and y < n; y = jump1[i].find(y)) {\\n                dp[i][y] = step;\\n                jump1[i].merge(y, y + 1);\\n                jump2[y].merge(i, i + 1);\\n                q.push({i, y});\\n            }\\n        }\\n        \\n        return dp[m - 1][n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395859,
                "title": "python-bfs-with-optimization-to-skip-visited-cells",
                "content": "\\n```\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        M = len(grid)\\n        N = len(grid[0])\\n\\n        # which index we have not used for each rows/cols\\n        rows = [0] * M\\n        cols = [0] * N\\n        \\n        steps = [[sys.maxsize] * N for _ in range(M)]\\n        \\n        steps[0][0] = 1\\n        rows[0] = 1\\n        cols[0] = 1\\n        q = deque([(0,0)])\\n        \\n        while q:\\n            r, c = q.popleft()\\n            step = steps[r][c]\\n            \\n            right = min(N-1, grid[r][c] + c)\\n            rows[r] = max(rows[r], c+1)\\n            for nc in range(rows[r], right+1):\\n                if steps[r][nc] < step+1:\\n                    continue\\n                steps[r][nc] = step+1\\n                q.append([r, nc])\\n            rows[r] = max(rows[r], right+1)\\n            \\n            down = min(M-1, grid[r][c] + r)\\n            cols[c] = max(cols[c], r+1)\\n            for nr in range(cols[c], down+1):\\n                if steps[nr][c] < step+1:\\n                    continue\\n                steps[nr][c] = step+1\\n                q.append([nr, c])\\n            cols[c] = max(cols[c], down+1)\\n                \\n        return -1 if steps[-1][-1] == sys.maxsize else steps[-1][-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        M = len(grid)\\n        N = len(grid[0])\\n\\n        # which index we have not used for each rows/cols\\n        rows = [0] * M\\n        cols = [0] * N\\n        \\n        steps = [[sys.maxsize] * N for _ in range(M)]\\n        \\n        steps[0][0] = 1\\n        rows[0] = 1\\n        cols[0] = 1\\n        q = deque([(0,0)])\\n        \\n        while q:\\n            r, c = q.popleft()\\n            step = steps[r][c]\\n            \\n            right = min(N-1, grid[r][c] + c)\\n            rows[r] = max(rows[r], c+1)\\n            for nc in range(rows[r], right+1):\\n                if steps[r][nc] < step+1:\\n                    continue\\n                steps[r][nc] = step+1\\n                q.append([r, nc])\\n            rows[r] = max(rows[r], right+1)\\n            \\n            down = min(M-1, grid[r][c] + r)\\n            cols[c] = max(cols[c], r+1)\\n            for nr in range(cols[c], down+1):\\n                if steps[nr][c] < step+1:\\n                    continue\\n                steps[nr][c] = step+1\\n                q.append([nr, c])\\n            cols[c] = max(cols[c], down+1)\\n                \\n        return -1 if steps[-1][-1] == sys.maxsize else steps[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395858,
                "title": "java-bfs-solution-dont-know-why-its-hard-question",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Do a breadth first search starting from 0, 0.\\n- Add to queue only is cell is not already visited and value of potential cell in the grid is not 0.\\n- Each iteration of the bfs is dist travelled.\\n- If last cell is reached return distace, else -1\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumVisitedCells(int[][] grid) {\\n        Queue<int[]> queue = new LinkedList<>();\\n        \\n        if(grid == null || grid.length == 0 || grid[0].length == 0)\\n            return 0;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if(m == 1 && n == 1)\\n            return 1;\\n        \\n        int[][] visited = new int[m][n];\\n        queue.add(new int[]{0, 0});\\n        int dist = 1;\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            // System.out.println(size);\\n            while(size > 0) {\\n                int[] cell = queue.poll();\\n                // System.out.println(\"cell: \" + cell[0] + \", \"  + cell[1] + \", val: \" + grid[cell[0]][cell[1]]);\\n                int val = grid[cell[0]][cell[1]];\\n                //check right\\n                for(int col=1; col <= val; col++) {\\n                    if(col + cell[1] >= n)\\n                        break;\\n\\n                    if(cell[0] == m-1 && col + cell[1] == n-1)\\n                        return dist + 1;\\n\\n                    if(grid[cell[0]][col + cell[1]] != 0 && visited[cell[0]][col + cell[1]] == 0) {\\n                        queue.add(new int[]{cell[0], col + cell[1]});\\n                        visited[cell[0]][col + cell[1]] = 1;\\n                    }\\n                }\\n\\n                //check bottom\\n                for(int row=1; row <= val; row++) {\\n                    if(row + cell[0] >= m)\\n                        break;\\n\\n                    if(cell[0] + row == m-1 && cell[1] == n-1)\\n                        return dist + 1;\\n\\n                    if(grid[row + cell[0]][cell[1]] != 0 && visited[row + cell[0]][cell[1]] == 0) {\\n                        queue.add(new int[]{row + cell[0], cell[1]});\\n                        visited[row + cell[0]][cell[1]] = 1;\\n                    }\\n                }\\n                size--;\\n            }\\n            dist++;\\n        }\\n        \\n        // System.out.println(\"\");\\n        // System.out.println(\"\");\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumVisitedCells(int[][] grid) {\\n        Queue<int[]> queue = new LinkedList<>();\\n        \\n        if(grid == null || grid.length == 0 || grid[0].length == 0)\\n            return 0;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if(m == 1 && n == 1)\\n            return 1;\\n        \\n        int[][] visited = new int[m][n];\\n        queue.add(new int[]{0, 0});\\n        int dist = 1;\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            // System.out.println(size);\\n            while(size > 0) {\\n                int[] cell = queue.poll();\\n                // System.out.println(\"cell: \" + cell[0] + \", \"  + cell[1] + \", val: \" + grid[cell[0]][cell[1]]);\\n                int val = grid[cell[0]][cell[1]];\\n                //check right\\n                for(int col=1; col <= val; col++) {\\n                    if(col + cell[1] >= n)\\n                        break;\\n\\n                    if(cell[0] == m-1 && col + cell[1] == n-1)\\n                        return dist + 1;\\n\\n                    if(grid[cell[0]][col + cell[1]] != 0 && visited[cell[0]][col + cell[1]] == 0) {\\n                        queue.add(new int[]{cell[0], col + cell[1]});\\n                        visited[cell[0]][col + cell[1]] = 1;\\n                    }\\n                }\\n\\n                //check bottom\\n                for(int row=1; row <= val; row++) {\\n                    if(row + cell[0] >= m)\\n                        break;\\n\\n                    if(cell[0] + row == m-1 && cell[1] == n-1)\\n                        return dist + 1;\\n\\n                    if(grid[row + cell[0]][cell[1]] != 0 && visited[row + cell[0]][cell[1]] == 0) {\\n                        queue.add(new int[]{row + cell[0], cell[1]});\\n                        visited[row + cell[0]][cell[1]] = 1;\\n                    }\\n                }\\n                size--;\\n            }\\n            dist++;\\n        }\\n        \\n        // System.out.println(\"\");\\n        // System.out.println(\"\");\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395845,
                "title": "straightforward-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDoing the straightforward thing, a breadth-first search of the graph, worked.\\nI fully expect Leetcode to introduce some special testing cases to invalidate this straightforward approach on regrading.\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        m=len(grid)\\n        n=len(grid[0])\\n        st=[[0]*n for _ in range(m)]\\n        st[0][0]=1\\n        q=[(0, 0)]\\n        ct=1\\n        while st[m-1][n-1]==0 and q:\\n            ct+=1\\n            tmp=[]\\n            for x, y in q:\\n                val=grid[x][y]\\n                for x2 in range(x+1, min(x+val+1, m)):\\n                    if st[x2][y]==0:\\n                        st[x2][y]=1\\n                        tmp.append((x2, y))\\n                for y2 in range(y+1, min(y+val+1, n)):\\n                    if st[x][y2]==0:\\n                        st[x][y2]=1\\n                        tmp.append((x, y2))\\n            q=tmp\\n        if st[m-1][n-1]:\\n            return ct\\n        else:\\n            return -1      \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        m=len(grid)\\n        n=len(grid[0])\\n        st=[[0]*n for _ in range(m)]\\n        st[0][0]=1\\n        q=[(0, 0)]\\n        ct=1\\n        while st[m-1][n-1]==0 and q:\\n            ct+=1\\n            tmp=[]\\n            for x, y in q:\\n                val=grid[x][y]\\n                for x2 in range(x+1, min(x+val+1, m)):\\n                    if st[x2][y]==0:\\n                        st[x2][y]=1\\n                        tmp.append((x2, y))\\n                for y2 in range(y+1, min(y+val+1, n)):\\n                    if st[x][y2]==0:\\n                        st[x][y2]=1\\n                        tmp.append((x, y2))\\n            q=tmp\\n        if st[m-1][n-1]:\\n            return ct\\n        else:\\n            return -1      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395844,
                "title": "bfs-c-solution",
                "content": "# Intuition\\nBFS for finding the shortest distance. \\n\\n# Approach\\nBut applying BFS directly can lead to TLE. Becasue value of grid[i][j] <= n*m. \\nStoring unvisited nodes, so we will visit nodes only once. \\nBut for finding next unvisited node, storing unvisited nodes in the two vector of set, one for row, and one for cloumn\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size(), m = grid[0].size();\\n        \\n        vector<vector<int>> dis(n, vector<int>(m, -2));\\n        \\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        dis[0][0] = 0;\\n        \\n        vector<set<int>> a(n),b(m);\\n        \\n        // if(a[0].size() == 0) cout<<\"YEA\\\\n\";\\n        \\n        for(int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<m;j++)\\n            {\\n                a[i].insert(j);\\n                b[j].insert(i);\\n            }\\n        }\\n        \\n        while(q.size())\\n        {\\n            auto t = q.front(); q.pop();\\n            \\n            // cout<<t.first<<\" \"<<t.second<<\" \"<<dis[t.first][t.second]<<endl;\\n            int t2 = t.second + 1, t1 = t.first + 1;\\n            while(true)\\n            {\\n                auto t3 = a[t.first].lower_bound(t2);\\n                int t4;\\n                if(t3 != a[t.first].end() and *t3 < m and *t3 <= grid[t.first][t.second] + t.second)\\n                {\\n                    t4 = *t3;\\n                    q.push({t.first, *t3});\\n                    \\n                    dis[t.first][*t3] = dis[t.first][t.second] + 1;\\n                    b[*t3].erase(t.first);\\n                    a[t.first].erase(t3);\\n                }\\n                else break;\\n                t2 = t4;\\n            }\\n            while(true)\\n            {\\n                auto t3 = b[t.second].lower_bound(t1);\\n                if(t3 != b[t.second].end() and *t3 < n and *t3 <= grid[t.first][t.second] + t.first)\\n                {\\n                    q.push({*t3, t.second});\\n                    \\n                    dis[*t3][t.second] = dis[t.first][t.second] + 1;\\n                    a[*t3].erase(t.second);\\n                    t1 = *t3;\\n                    b[t.second].erase(t3);\\n                }\\n                else break;\\n                \\n            }\\n        }\\n        \\n        return(dis[n - 1][m - 1] + 1);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size(), m = grid[0].size();\\n        \\n        vector<vector<int>> dis(n, vector<int>(m, -2));\\n        \\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        dis[0][0] = 0;\\n        \\n        vector<set<int>> a(n),b(m);\\n        \\n        // if(a[0].size() == 0) cout<<\"YEA\\\\n\";\\n        \\n        for(int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<m;j++)\\n            {\\n                a[i].insert(j);\\n                b[j].insert(i);\\n            }\\n        }\\n        \\n        while(q.size())\\n        {\\n            auto t = q.front(); q.pop();\\n            \\n            // cout<<t.first<<\" \"<<t.second<<\" \"<<dis[t.first][t.second]<<endl;\\n            int t2 = t.second + 1, t1 = t.first + 1;\\n            while(true)\\n            {\\n                auto t3 = a[t.first].lower_bound(t2);\\n                int t4;\\n                if(t3 != a[t.first].end() and *t3 < m and *t3 <= grid[t.first][t.second] + t.second)\\n                {\\n                    t4 = *t3;\\n                    q.push({t.first, *t3});\\n                    \\n                    dis[t.first][*t3] = dis[t.first][t.second] + 1;\\n                    b[*t3].erase(t.first);\\n                    a[t.first].erase(t3);\\n                }\\n                else break;\\n                t2 = t4;\\n            }\\n            while(true)\\n            {\\n                auto t3 = b[t.second].lower_bound(t1);\\n                if(t3 != b[t.second].end() and *t3 < n and *t3 <= grid[t.first][t.second] + t.first)\\n                {\\n                    q.push({*t3, t.second});\\n                    \\n                    dis[*t3][t.second] = dis[t.first][t.second] + 1;\\n                    a[*t3].erase(t.second);\\n                    t1 = *t3;\\n                    b[t.second].erase(t3);\\n                }\\n                else break;\\n                \\n            }\\n        }\\n        \\n        return(dis[n - 1][m - 1] + 1);\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3395842,
                "title": "python-bfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        dq, seen = deque([(0, 0, 1)]), {(0, 0)}\\n        while dq:\\n            i, j, step = dq.popleft()\\n            if i == m - 1 and j == n - 1:\\n                return step\\n            \\n            for k in range(j + 1, min(grid[i][j] + j + 1, n))[::-1]:\\n                if (i, k) not in seen:\\n                    dq.append((i, k, step + 1))\\n                    seen.add((i, k))\\n            for k in range(i + 1, min(grid[i][j] + i + 1, m))[::-1]:\\n                if (k, j) not in seen:\\n                    dq.append((k, j, step + 1))\\n                    seen.add((k, j))\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        dq, seen = deque([(0, 0, 1)]), {(0, 0)}\\n        while dq:\\n            i, j, step = dq.popleft()\\n            if i == m - 1 and j == n - 1:\\n                return step\\n            \\n            for k in range(j + 1, min(grid[i][j] + j + 1, n))[::-1]:\\n                if (i, k) not in seen:\\n                    dq.append((i, k, step + 1))\\n                    seen.add((i, k))\\n            for k in range(i + 1, min(grid[i][j] + i + 1, m))[::-1]:\\n                if (k, j) not in seen:\\n                    dq.append((k, j, step + 1))\\n                    seen.add((k, j))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395830,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n         int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<long long>> distance(m,(vector<long long>(n,INT_MAX)));\\n        distance[0][0]=1;\\n        priority_queue<pair<long long,pair< int, int>>, vector<pair<long long,pair< int, int>>>, greater<pair<long long,pair< int, int>>>> pq;\\n        pq.push({1,{0, 0}} );\\n        while (!pq.empty()) {\\n            long long d = pq.top().first;\\n            int i=pq.top().second.first;\\n            int j=pq.top().second.second;\\n            pq.pop();\\n            if (i == m-1 && j == n-1) {\\n                return (int)d;\\n            }\\n            for (int k = j+1; k <= min(j+grid[i][j], n-1); k++) {\\n                if (distance[i][k] > d+1) {\\n                    distance[i][k] = d+1;\\n                    pq.push({d+1,{ i, k}});\\n                    if (i == m-1 && k == n-1) {\\n                        return (int)d+1;\\n                    }\\n                }\\n            }\\n            for (int k = i+1; k <= min(i+grid[i][j], m-1); k++) {\\n                if (distance[k][j] > d+1) {\\n                    distance[k][j] = d+1;\\n                    pq.push({d+1, {k, j}});\\n                    if (k == m-1 && j == n-1) {\\n                        return (int)d+1;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n         int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<long long>> distance(m,(vector<long long>(n,INT_MAX)));\\n        distance[0][0]=1;\\n        priority_queue<pair<long long,pair< int, int>>, vector<pair<long long,pair< int, int>>>, greater<pair<long long,pair< int, int>>>> pq;\\n        pq.push({1,{0, 0}} );\\n        while (!pq.empty()) {\\n            long long d = pq.top().first;\\n            int i=pq.top().second.first;\\n            int j=pq.top().second.second;\\n            pq.pop();\\n            if (i == m-1 && j == n-1) {\\n                return (int)d;\\n            }\\n            for (int k = j+1; k <= min(j+grid[i][j], n-1); k++) {\\n                if (distance[i][k] > d+1) {\\n                    distance[i][k] = d+1;\\n                    pq.push({d+1,{ i, k}});\\n                    if (i == m-1 && k == n-1) {\\n                        return (int)d+1;\\n                    }\\n                }\\n            }\\n            for (int k = i+1; k <= min(i+grid[i][j], m-1); k++) {\\n                if (distance[k][j] > d+1) {\\n                    distance[k][j] = d+1;\\n                    pq.push({d+1, {k, j}});\\n                    if (k == m-1 && j == n-1) {\\n                        return (int)d+1;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1857910,
                "content": [
                    {
                        "username": "then00bprogrammer",
                        "content": "those last 4/5 testcases were evil"
                    },
                    {
                        "username": "brinuke",
                        "content": "Important testcase is missing! Code to generate it (Java):\n\n```java\npublic static int[][] generateTestCase(int n) {\n\tint[] row = new int[n];\n\tfor (int i = 0, j = n - 2; j > 0; i++, j--)\n\t\trow[i] = j;\n\treturn new int[][] { row };\n}\n\nint[][] grid = generateTestCase((int) 1e5);\n```\nExpected output: `-1`"
                    },
                    {
                        "username": "harigovind666",
                        "content": "is bfs approach not working for others too,time limit error in python!/"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why recursive solution sometimes passes sometimes fails?? I don\\'t understand."
                    },
                    {
                        "username": "IceTrey",
                        "content": "This is jump game II problem in 2D."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Can anyone explain why same recusive logic failing and iterative one accepted :("
                    },
                    {
                        "username": "user8355fQ",
                        "content": "If you\\'re getting TLE tweak your BFS \\nby considering the farthest point first \\n `for(int d = grid[i][j]+i ; d>=i+1 ; --d)`\\nand you are done \\n"
                    },
                    {
                        "username": "CHIIKUU",
                        "content": "but why it is giving tle?? "
                    },
                    {
                        "username": "czjnbb",
                        "content": "I didn\\'t notice this: 1 <= m * n <= 10**5\\n\\nA brutal BFS with memo will pass as well..."
                    },
                    {
                        "username": "roushanshah255",
                        "content": "class Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        \\n        vector<vector<int>> vis(grid.size(),vector<int>(grid[0].size(),INT_MAX));\\n        \\n        vis[0][0]=1;\\n        \\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        \\n        while(!q.empty())\\n        {\\n            pair<int,int> curr=q.front();\\n            q.pop();\\n            \\n            for(int j=curr.second+1;j<=min((int)grid[0].size()-1,curr.second+grid[curr.first][curr.second]);j++)\\n            {\\n                if(vis[curr.first][j]==INT_MAX)\\n                {\\n                    vis[curr.first][j]=1+vis[curr.first][curr.second];\\n                    q.push({curr.first,j});\\n                }\\n            }\\n            \\n            for(int j=curr.first+1;j<=min((int)grid.size()-1,curr.first+grid[curr.first][curr.second]);j++)\\n            {\\n                if(vis[j][curr.second]==INT_MAX)\\n                {\\n                    vis[j][curr.second]=1+vis[curr.first][curr.second];\\n                    q.push({j,curr.second});\\n                }\\n            }\\n        }\\n        \\n        int ans=vis[grid.size()-1][grid[0].size()-1];\\n        \\n        if(ans==INT_MAX)\\n        {\\n            ans=-1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nthis a code of a person which passed all the case but when i submitted it on my own its shows tle "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hi, Can anyone tell me about What is the path for this.\\n\\n[[ 1 , 0 , 11 ],[ 1 , 14 , 10 ],[ 12 , 10 , 2 ],[ 2 , 0 , 0 ],[ 13 , 0 , 0 ]]\\n\\nThe Expected output is 5.\\nI am not able to find any way to go (m - 1 , n - 1)."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "There are a number of ways you can visit \\nSome of the way I noticed (efficient ) are \\n1->1->14->10->0 (Final Destination)\\n1->1->12->13->0 (Final Destination)"
                    }
                ]
            },
            {
                "id": 1858822,
                "content": [
                    {
                        "username": "then00bprogrammer",
                        "content": "those last 4/5 testcases were evil"
                    },
                    {
                        "username": "brinuke",
                        "content": "Important testcase is missing! Code to generate it (Java):\n\n```java\npublic static int[][] generateTestCase(int n) {\n\tint[] row = new int[n];\n\tfor (int i = 0, j = n - 2; j > 0; i++, j--)\n\t\trow[i] = j;\n\treturn new int[][] { row };\n}\n\nint[][] grid = generateTestCase((int) 1e5);\n```\nExpected output: `-1`"
                    },
                    {
                        "username": "harigovind666",
                        "content": "is bfs approach not working for others too,time limit error in python!/"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why recursive solution sometimes passes sometimes fails?? I don\\'t understand."
                    },
                    {
                        "username": "IceTrey",
                        "content": "This is jump game II problem in 2D."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Can anyone explain why same recusive logic failing and iterative one accepted :("
                    },
                    {
                        "username": "user8355fQ",
                        "content": "If you\\'re getting TLE tweak your BFS \\nby considering the farthest point first \\n `for(int d = grid[i][j]+i ; d>=i+1 ; --d)`\\nand you are done \\n"
                    },
                    {
                        "username": "CHIIKUU",
                        "content": "but why it is giving tle?? "
                    },
                    {
                        "username": "czjnbb",
                        "content": "I didn\\'t notice this: 1 <= m * n <= 10**5\\n\\nA brutal BFS with memo will pass as well..."
                    },
                    {
                        "username": "roushanshah255",
                        "content": "class Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        \\n        vector<vector<int>> vis(grid.size(),vector<int>(grid[0].size(),INT_MAX));\\n        \\n        vis[0][0]=1;\\n        \\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        \\n        while(!q.empty())\\n        {\\n            pair<int,int> curr=q.front();\\n            q.pop();\\n            \\n            for(int j=curr.second+1;j<=min((int)grid[0].size()-1,curr.second+grid[curr.first][curr.second]);j++)\\n            {\\n                if(vis[curr.first][j]==INT_MAX)\\n                {\\n                    vis[curr.first][j]=1+vis[curr.first][curr.second];\\n                    q.push({curr.first,j});\\n                }\\n            }\\n            \\n            for(int j=curr.first+1;j<=min((int)grid.size()-1,curr.first+grid[curr.first][curr.second]);j++)\\n            {\\n                if(vis[j][curr.second]==INT_MAX)\\n                {\\n                    vis[j][curr.second]=1+vis[curr.first][curr.second];\\n                    q.push({j,curr.second});\\n                }\\n            }\\n        }\\n        \\n        int ans=vis[grid.size()-1][grid[0].size()-1];\\n        \\n        if(ans==INT_MAX)\\n        {\\n            ans=-1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nthis a code of a person which passed all the case but when i submitted it on my own its shows tle "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hi, Can anyone tell me about What is the path for this.\\n\\n[[ 1 , 0 , 11 ],[ 1 , 14 , 10 ],[ 12 , 10 , 2 ],[ 2 , 0 , 0 ],[ 13 , 0 , 0 ]]\\n\\nThe Expected output is 5.\\nI am not able to find any way to go (m - 1 , n - 1)."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "There are a number of ways you can visit \\nSome of the way I noticed (efficient ) are \\n1->1->14->10->0 (Final Destination)\\n1->1->12->13->0 (Final Destination)"
                    }
                ]
            },
            {
                "id": 1942119,
                "content": [
                    {
                        "username": "then00bprogrammer",
                        "content": "those last 4/5 testcases were evil"
                    },
                    {
                        "username": "brinuke",
                        "content": "Important testcase is missing! Code to generate it (Java):\n\n```java\npublic static int[][] generateTestCase(int n) {\n\tint[] row = new int[n];\n\tfor (int i = 0, j = n - 2; j > 0; i++, j--)\n\t\trow[i] = j;\n\treturn new int[][] { row };\n}\n\nint[][] grid = generateTestCase((int) 1e5);\n```\nExpected output: `-1`"
                    },
                    {
                        "username": "harigovind666",
                        "content": "is bfs approach not working for others too,time limit error in python!/"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why recursive solution sometimes passes sometimes fails?? I don\\'t understand."
                    },
                    {
                        "username": "IceTrey",
                        "content": "This is jump game II problem in 2D."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Can anyone explain why same recusive logic failing and iterative one accepted :("
                    },
                    {
                        "username": "user8355fQ",
                        "content": "If you\\'re getting TLE tweak your BFS \\nby considering the farthest point first \\n `for(int d = grid[i][j]+i ; d>=i+1 ; --d)`\\nand you are done \\n"
                    },
                    {
                        "username": "CHIIKUU",
                        "content": "but why it is giving tle?? "
                    },
                    {
                        "username": "czjnbb",
                        "content": "I didn\\'t notice this: 1 <= m * n <= 10**5\\n\\nA brutal BFS with memo will pass as well..."
                    },
                    {
                        "username": "roushanshah255",
                        "content": "class Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        \\n        vector<vector<int>> vis(grid.size(),vector<int>(grid[0].size(),INT_MAX));\\n        \\n        vis[0][0]=1;\\n        \\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        \\n        while(!q.empty())\\n        {\\n            pair<int,int> curr=q.front();\\n            q.pop();\\n            \\n            for(int j=curr.second+1;j<=min((int)grid[0].size()-1,curr.second+grid[curr.first][curr.second]);j++)\\n            {\\n                if(vis[curr.first][j]==INT_MAX)\\n                {\\n                    vis[curr.first][j]=1+vis[curr.first][curr.second];\\n                    q.push({curr.first,j});\\n                }\\n            }\\n            \\n            for(int j=curr.first+1;j<=min((int)grid.size()-1,curr.first+grid[curr.first][curr.second]);j++)\\n            {\\n                if(vis[j][curr.second]==INT_MAX)\\n                {\\n                    vis[j][curr.second]=1+vis[curr.first][curr.second];\\n                    q.push({j,curr.second});\\n                }\\n            }\\n        }\\n        \\n        int ans=vis[grid.size()-1][grid[0].size()-1];\\n        \\n        if(ans==INT_MAX)\\n        {\\n            ans=-1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nthis a code of a person which passed all the case but when i submitted it on my own its shows tle "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hi, Can anyone tell me about What is the path for this.\\n\\n[[ 1 , 0 , 11 ],[ 1 , 14 , 10 ],[ 12 , 10 , 2 ],[ 2 , 0 , 0 ],[ 13 , 0 , 0 ]]\\n\\nThe Expected output is 5.\\nI am not able to find any way to go (m - 1 , n - 1)."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "There are a number of ways you can visit \\nSome of the way I noticed (efficient ) are \\n1->1->14->10->0 (Final Destination)\\n1->1->12->13->0 (Final Destination)"
                    }
                ]
            },
            {
                "id": 1864059,
                "content": [
                    {
                        "username": "then00bprogrammer",
                        "content": "those last 4/5 testcases were evil"
                    },
                    {
                        "username": "brinuke",
                        "content": "Important testcase is missing! Code to generate it (Java):\n\n```java\npublic static int[][] generateTestCase(int n) {\n\tint[] row = new int[n];\n\tfor (int i = 0, j = n - 2; j > 0; i++, j--)\n\t\trow[i] = j;\n\treturn new int[][] { row };\n}\n\nint[][] grid = generateTestCase((int) 1e5);\n```\nExpected output: `-1`"
                    },
                    {
                        "username": "harigovind666",
                        "content": "is bfs approach not working for others too,time limit error in python!/"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why recursive solution sometimes passes sometimes fails?? I don\\'t understand."
                    },
                    {
                        "username": "IceTrey",
                        "content": "This is jump game II problem in 2D."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Can anyone explain why same recusive logic failing and iterative one accepted :("
                    },
                    {
                        "username": "user8355fQ",
                        "content": "If you\\'re getting TLE tweak your BFS \\nby considering the farthest point first \\n `for(int d = grid[i][j]+i ; d>=i+1 ; --d)`\\nand you are done \\n"
                    },
                    {
                        "username": "CHIIKUU",
                        "content": "but why it is giving tle?? "
                    },
                    {
                        "username": "czjnbb",
                        "content": "I didn\\'t notice this: 1 <= m * n <= 10**5\\n\\nA brutal BFS with memo will pass as well..."
                    },
                    {
                        "username": "roushanshah255",
                        "content": "class Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        \\n        vector<vector<int>> vis(grid.size(),vector<int>(grid[0].size(),INT_MAX));\\n        \\n        vis[0][0]=1;\\n        \\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        \\n        while(!q.empty())\\n        {\\n            pair<int,int> curr=q.front();\\n            q.pop();\\n            \\n            for(int j=curr.second+1;j<=min((int)grid[0].size()-1,curr.second+grid[curr.first][curr.second]);j++)\\n            {\\n                if(vis[curr.first][j]==INT_MAX)\\n                {\\n                    vis[curr.first][j]=1+vis[curr.first][curr.second];\\n                    q.push({curr.first,j});\\n                }\\n            }\\n            \\n            for(int j=curr.first+1;j<=min((int)grid.size()-1,curr.first+grid[curr.first][curr.second]);j++)\\n            {\\n                if(vis[j][curr.second]==INT_MAX)\\n                {\\n                    vis[j][curr.second]=1+vis[curr.first][curr.second];\\n                    q.push({j,curr.second});\\n                }\\n            }\\n        }\\n        \\n        int ans=vis[grid.size()-1][grid[0].size()-1];\\n        \\n        if(ans==INT_MAX)\\n        {\\n            ans=-1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nthis a code of a person which passed all the case but when i submitted it on my own its shows tle "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hi, Can anyone tell me about What is the path for this.\\n\\n[[ 1 , 0 , 11 ],[ 1 , 14 , 10 ],[ 12 , 10 , 2 ],[ 2 , 0 , 0 ],[ 13 , 0 , 0 ]]\\n\\nThe Expected output is 5.\\nI am not able to find any way to go (m - 1 , n - 1)."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "There are a number of ways you can visit \\nSome of the way I noticed (efficient ) are \\n1->1->14->10->0 (Final Destination)\\n1->1->12->13->0 (Final Destination)"
                    }
                ]
            },
            {
                "id": 1862071,
                "content": [
                    {
                        "username": "then00bprogrammer",
                        "content": "those last 4/5 testcases were evil"
                    },
                    {
                        "username": "brinuke",
                        "content": "Important testcase is missing! Code to generate it (Java):\n\n```java\npublic static int[][] generateTestCase(int n) {\n\tint[] row = new int[n];\n\tfor (int i = 0, j = n - 2; j > 0; i++, j--)\n\t\trow[i] = j;\n\treturn new int[][] { row };\n}\n\nint[][] grid = generateTestCase((int) 1e5);\n```\nExpected output: `-1`"
                    },
                    {
                        "username": "harigovind666",
                        "content": "is bfs approach not working for others too,time limit error in python!/"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why recursive solution sometimes passes sometimes fails?? I don\\'t understand."
                    },
                    {
                        "username": "IceTrey",
                        "content": "This is jump game II problem in 2D."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Can anyone explain why same recusive logic failing and iterative one accepted :("
                    },
                    {
                        "username": "user8355fQ",
                        "content": "If you\\'re getting TLE tweak your BFS \\nby considering the farthest point first \\n `for(int d = grid[i][j]+i ; d>=i+1 ; --d)`\\nand you are done \\n"
                    },
                    {
                        "username": "CHIIKUU",
                        "content": "but why it is giving tle?? "
                    },
                    {
                        "username": "czjnbb",
                        "content": "I didn\\'t notice this: 1 <= m * n <= 10**5\\n\\nA brutal BFS with memo will pass as well..."
                    },
                    {
                        "username": "roushanshah255",
                        "content": "class Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        \\n        vector<vector<int>> vis(grid.size(),vector<int>(grid[0].size(),INT_MAX));\\n        \\n        vis[0][0]=1;\\n        \\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        \\n        while(!q.empty())\\n        {\\n            pair<int,int> curr=q.front();\\n            q.pop();\\n            \\n            for(int j=curr.second+1;j<=min((int)grid[0].size()-1,curr.second+grid[curr.first][curr.second]);j++)\\n            {\\n                if(vis[curr.first][j]==INT_MAX)\\n                {\\n                    vis[curr.first][j]=1+vis[curr.first][curr.second];\\n                    q.push({curr.first,j});\\n                }\\n            }\\n            \\n            for(int j=curr.first+1;j<=min((int)grid.size()-1,curr.first+grid[curr.first][curr.second]);j++)\\n            {\\n                if(vis[j][curr.second]==INT_MAX)\\n                {\\n                    vis[j][curr.second]=1+vis[curr.first][curr.second];\\n                    q.push({j,curr.second});\\n                }\\n            }\\n        }\\n        \\n        int ans=vis[grid.size()-1][grid[0].size()-1];\\n        \\n        if(ans==INT_MAX)\\n        {\\n            ans=-1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nthis a code of a person which passed all the case but when i submitted it on my own its shows tle "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hi, Can anyone tell me about What is the path for this.\\n\\n[[ 1 , 0 , 11 ],[ 1 , 14 , 10 ],[ 12 , 10 , 2 ],[ 2 , 0 , 0 ],[ 13 , 0 , 0 ]]\\n\\nThe Expected output is 5.\\nI am not able to find any way to go (m - 1 , n - 1)."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "There are a number of ways you can visit \\nSome of the way I noticed (efficient ) are \\n1->1->14->10->0 (Final Destination)\\n1->1->12->13->0 (Final Destination)"
                    }
                ]
            },
            {
                "id": 1858755,
                "content": [
                    {
                        "username": "then00bprogrammer",
                        "content": "those last 4/5 testcases were evil"
                    },
                    {
                        "username": "brinuke",
                        "content": "Important testcase is missing! Code to generate it (Java):\n\n```java\npublic static int[][] generateTestCase(int n) {\n\tint[] row = new int[n];\n\tfor (int i = 0, j = n - 2; j > 0; i++, j--)\n\t\trow[i] = j;\n\treturn new int[][] { row };\n}\n\nint[][] grid = generateTestCase((int) 1e5);\n```\nExpected output: `-1`"
                    },
                    {
                        "username": "harigovind666",
                        "content": "is bfs approach not working for others too,time limit error in python!/"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why recursive solution sometimes passes sometimes fails?? I don\\'t understand."
                    },
                    {
                        "username": "IceTrey",
                        "content": "This is jump game II problem in 2D."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Can anyone explain why same recusive logic failing and iterative one accepted :("
                    },
                    {
                        "username": "user8355fQ",
                        "content": "If you\\'re getting TLE tweak your BFS \\nby considering the farthest point first \\n `for(int d = grid[i][j]+i ; d>=i+1 ; --d)`\\nand you are done \\n"
                    },
                    {
                        "username": "CHIIKUU",
                        "content": "but why it is giving tle?? "
                    },
                    {
                        "username": "czjnbb",
                        "content": "I didn\\'t notice this: 1 <= m * n <= 10**5\\n\\nA brutal BFS with memo will pass as well..."
                    },
                    {
                        "username": "roushanshah255",
                        "content": "class Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        \\n        vector<vector<int>> vis(grid.size(),vector<int>(grid[0].size(),INT_MAX));\\n        \\n        vis[0][0]=1;\\n        \\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        \\n        while(!q.empty())\\n        {\\n            pair<int,int> curr=q.front();\\n            q.pop();\\n            \\n            for(int j=curr.second+1;j<=min((int)grid[0].size()-1,curr.second+grid[curr.first][curr.second]);j++)\\n            {\\n                if(vis[curr.first][j]==INT_MAX)\\n                {\\n                    vis[curr.first][j]=1+vis[curr.first][curr.second];\\n                    q.push({curr.first,j});\\n                }\\n            }\\n            \\n            for(int j=curr.first+1;j<=min((int)grid.size()-1,curr.first+grid[curr.first][curr.second]);j++)\\n            {\\n                if(vis[j][curr.second]==INT_MAX)\\n                {\\n                    vis[j][curr.second]=1+vis[curr.first][curr.second];\\n                    q.push({j,curr.second});\\n                }\\n            }\\n        }\\n        \\n        int ans=vis[grid.size()-1][grid[0].size()-1];\\n        \\n        if(ans==INT_MAX)\\n        {\\n            ans=-1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nthis a code of a person which passed all the case but when i submitted it on my own its shows tle "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hi, Can anyone tell me about What is the path for this.\\n\\n[[ 1 , 0 , 11 ],[ 1 , 14 , 10 ],[ 12 , 10 , 2 ],[ 2 , 0 , 0 ],[ 13 , 0 , 0 ]]\\n\\nThe Expected output is 5.\\nI am not able to find any way to go (m - 1 , n - 1)."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "There are a number of ways you can visit \\nSome of the way I noticed (efficient ) are \\n1->1->14->10->0 (Final Destination)\\n1->1->12->13->0 (Final Destination)"
                    }
                ]
            },
            {
                "id": 1858366,
                "content": [
                    {
                        "username": "then00bprogrammer",
                        "content": "those last 4/5 testcases were evil"
                    },
                    {
                        "username": "brinuke",
                        "content": "Important testcase is missing! Code to generate it (Java):\n\n```java\npublic static int[][] generateTestCase(int n) {\n\tint[] row = new int[n];\n\tfor (int i = 0, j = n - 2; j > 0; i++, j--)\n\t\trow[i] = j;\n\treturn new int[][] { row };\n}\n\nint[][] grid = generateTestCase((int) 1e5);\n```\nExpected output: `-1`"
                    },
                    {
                        "username": "harigovind666",
                        "content": "is bfs approach not working for others too,time limit error in python!/"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why recursive solution sometimes passes sometimes fails?? I don\\'t understand."
                    },
                    {
                        "username": "IceTrey",
                        "content": "This is jump game II problem in 2D."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Can anyone explain why same recusive logic failing and iterative one accepted :("
                    },
                    {
                        "username": "user8355fQ",
                        "content": "If you\\'re getting TLE tweak your BFS \\nby considering the farthest point first \\n `for(int d = grid[i][j]+i ; d>=i+1 ; --d)`\\nand you are done \\n"
                    },
                    {
                        "username": "CHIIKUU",
                        "content": "but why it is giving tle?? "
                    },
                    {
                        "username": "czjnbb",
                        "content": "I didn\\'t notice this: 1 <= m * n <= 10**5\\n\\nA brutal BFS with memo will pass as well..."
                    },
                    {
                        "username": "roushanshah255",
                        "content": "class Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        \\n        vector<vector<int>> vis(grid.size(),vector<int>(grid[0].size(),INT_MAX));\\n        \\n        vis[0][0]=1;\\n        \\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        \\n        while(!q.empty())\\n        {\\n            pair<int,int> curr=q.front();\\n            q.pop();\\n            \\n            for(int j=curr.second+1;j<=min((int)grid[0].size()-1,curr.second+grid[curr.first][curr.second]);j++)\\n            {\\n                if(vis[curr.first][j]==INT_MAX)\\n                {\\n                    vis[curr.first][j]=1+vis[curr.first][curr.second];\\n                    q.push({curr.first,j});\\n                }\\n            }\\n            \\n            for(int j=curr.first+1;j<=min((int)grid.size()-1,curr.first+grid[curr.first][curr.second]);j++)\\n            {\\n                if(vis[j][curr.second]==INT_MAX)\\n                {\\n                    vis[j][curr.second]=1+vis[curr.first][curr.second];\\n                    q.push({j,curr.second});\\n                }\\n            }\\n        }\\n        \\n        int ans=vis[grid.size()-1][grid[0].size()-1];\\n        \\n        if(ans==INT_MAX)\\n        {\\n            ans=-1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nthis a code of a person which passed all the case but when i submitted it on my own its shows tle "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hi, Can anyone tell me about What is the path for this.\\n\\n[[ 1 , 0 , 11 ],[ 1 , 14 , 10 ],[ 12 , 10 , 2 ],[ 2 , 0 , 0 ],[ 13 , 0 , 0 ]]\\n\\nThe Expected output is 5.\\nI am not able to find any way to go (m - 1 , n - 1)."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "There are a number of ways you can visit \\nSome of the way I noticed (efficient ) are \\n1->1->14->10->0 (Final Destination)\\n1->1->12->13->0 (Final Destination)"
                    }
                ]
            },
            {
                "id": 1858605,
                "content": [
                    {
                        "username": "then00bprogrammer",
                        "content": "those last 4/5 testcases were evil"
                    },
                    {
                        "username": "brinuke",
                        "content": "Important testcase is missing! Code to generate it (Java):\n\n```java\npublic static int[][] generateTestCase(int n) {\n\tint[] row = new int[n];\n\tfor (int i = 0, j = n - 2; j > 0; i++, j--)\n\t\trow[i] = j;\n\treturn new int[][] { row };\n}\n\nint[][] grid = generateTestCase((int) 1e5);\n```\nExpected output: `-1`"
                    },
                    {
                        "username": "harigovind666",
                        "content": "is bfs approach not working for others too,time limit error in python!/"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why recursive solution sometimes passes sometimes fails?? I don\\'t understand."
                    },
                    {
                        "username": "IceTrey",
                        "content": "This is jump game II problem in 2D."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Can anyone explain why same recusive logic failing and iterative one accepted :("
                    },
                    {
                        "username": "user8355fQ",
                        "content": "If you\\'re getting TLE tweak your BFS \\nby considering the farthest point first \\n `for(int d = grid[i][j]+i ; d>=i+1 ; --d)`\\nand you are done \\n"
                    },
                    {
                        "username": "CHIIKUU",
                        "content": "but why it is giving tle?? "
                    },
                    {
                        "username": "czjnbb",
                        "content": "I didn\\'t notice this: 1 <= m * n <= 10**5\\n\\nA brutal BFS with memo will pass as well..."
                    },
                    {
                        "username": "roushanshah255",
                        "content": "class Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        \\n        vector<vector<int>> vis(grid.size(),vector<int>(grid[0].size(),INT_MAX));\\n        \\n        vis[0][0]=1;\\n        \\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        \\n        while(!q.empty())\\n        {\\n            pair<int,int> curr=q.front();\\n            q.pop();\\n            \\n            for(int j=curr.second+1;j<=min((int)grid[0].size()-1,curr.second+grid[curr.first][curr.second]);j++)\\n            {\\n                if(vis[curr.first][j]==INT_MAX)\\n                {\\n                    vis[curr.first][j]=1+vis[curr.first][curr.second];\\n                    q.push({curr.first,j});\\n                }\\n            }\\n            \\n            for(int j=curr.first+1;j<=min((int)grid.size()-1,curr.first+grid[curr.first][curr.second]);j++)\\n            {\\n                if(vis[j][curr.second]==INT_MAX)\\n                {\\n                    vis[j][curr.second]=1+vis[curr.first][curr.second];\\n                    q.push({j,curr.second});\\n                }\\n            }\\n        }\\n        \\n        int ans=vis[grid.size()-1][grid[0].size()-1];\\n        \\n        if(ans==INT_MAX)\\n        {\\n            ans=-1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nthis a code of a person which passed all the case but when i submitted it on my own its shows tle "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hi, Can anyone tell me about What is the path for this.\\n\\n[[ 1 , 0 , 11 ],[ 1 , 14 , 10 ],[ 12 , 10 , 2 ],[ 2 , 0 , 0 ],[ 13 , 0 , 0 ]]\\n\\nThe Expected output is 5.\\nI am not able to find any way to go (m - 1 , n - 1)."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "There are a number of ways you can visit \\nSome of the way I noticed (efficient ) are \\n1->1->14->10->0 (Final Destination)\\n1->1->12->13->0 (Final Destination)"
                    }
                ]
            },
            {
                "id": 1859417,
                "content": [
                    {
                        "username": "then00bprogrammer",
                        "content": "those last 4/5 testcases were evil"
                    },
                    {
                        "username": "brinuke",
                        "content": "Important testcase is missing! Code to generate it (Java):\n\n```java\npublic static int[][] generateTestCase(int n) {\n\tint[] row = new int[n];\n\tfor (int i = 0, j = n - 2; j > 0; i++, j--)\n\t\trow[i] = j;\n\treturn new int[][] { row };\n}\n\nint[][] grid = generateTestCase((int) 1e5);\n```\nExpected output: `-1`"
                    },
                    {
                        "username": "harigovind666",
                        "content": "is bfs approach not working for others too,time limit error in python!/"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why recursive solution sometimes passes sometimes fails?? I don\\'t understand."
                    },
                    {
                        "username": "IceTrey",
                        "content": "This is jump game II problem in 2D."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Can anyone explain why same recusive logic failing and iterative one accepted :("
                    },
                    {
                        "username": "user8355fQ",
                        "content": "If you\\'re getting TLE tweak your BFS \\nby considering the farthest point first \\n `for(int d = grid[i][j]+i ; d>=i+1 ; --d)`\\nand you are done \\n"
                    },
                    {
                        "username": "CHIIKUU",
                        "content": "but why it is giving tle?? "
                    },
                    {
                        "username": "czjnbb",
                        "content": "I didn\\'t notice this: 1 <= m * n <= 10**5\\n\\nA brutal BFS with memo will pass as well..."
                    },
                    {
                        "username": "roushanshah255",
                        "content": "class Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        \\n        vector<vector<int>> vis(grid.size(),vector<int>(grid[0].size(),INT_MAX));\\n        \\n        vis[0][0]=1;\\n        \\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        \\n        while(!q.empty())\\n        {\\n            pair<int,int> curr=q.front();\\n            q.pop();\\n            \\n            for(int j=curr.second+1;j<=min((int)grid[0].size()-1,curr.second+grid[curr.first][curr.second]);j++)\\n            {\\n                if(vis[curr.first][j]==INT_MAX)\\n                {\\n                    vis[curr.first][j]=1+vis[curr.first][curr.second];\\n                    q.push({curr.first,j});\\n                }\\n            }\\n            \\n            for(int j=curr.first+1;j<=min((int)grid.size()-1,curr.first+grid[curr.first][curr.second]);j++)\\n            {\\n                if(vis[j][curr.second]==INT_MAX)\\n                {\\n                    vis[j][curr.second]=1+vis[curr.first][curr.second];\\n                    q.push({j,curr.second});\\n                }\\n            }\\n        }\\n        \\n        int ans=vis[grid.size()-1][grid[0].size()-1];\\n        \\n        if(ans==INT_MAX)\\n        {\\n            ans=-1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nthis a code of a person which passed all the case but when i submitted it on my own its shows tle "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hi, Can anyone tell me about What is the path for this.\\n\\n[[ 1 , 0 , 11 ],[ 1 , 14 , 10 ],[ 12 , 10 , 2 ],[ 2 , 0 , 0 ],[ 13 , 0 , 0 ]]\\n\\nThe Expected output is 5.\\nI am not able to find any way to go (m - 1 , n - 1)."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "There are a number of ways you can visit \\nSome of the way I noticed (efficient ) are \\n1->1->14->10->0 (Final Destination)\\n1->1->12->13->0 (Final Destination)"
                    }
                ]
            },
            {
                "id": 1858512,
                "content": [
                    {
                        "username": "then00bprogrammer",
                        "content": "those last 4/5 testcases were evil"
                    },
                    {
                        "username": "brinuke",
                        "content": "Important testcase is missing! Code to generate it (Java):\n\n```java\npublic static int[][] generateTestCase(int n) {\n\tint[] row = new int[n];\n\tfor (int i = 0, j = n - 2; j > 0; i++, j--)\n\t\trow[i] = j;\n\treturn new int[][] { row };\n}\n\nint[][] grid = generateTestCase((int) 1e5);\n```\nExpected output: `-1`"
                    },
                    {
                        "username": "harigovind666",
                        "content": "is bfs approach not working for others too,time limit error in python!/"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why recursive solution sometimes passes sometimes fails?? I don\\'t understand."
                    },
                    {
                        "username": "IceTrey",
                        "content": "This is jump game II problem in 2D."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Can anyone explain why same recusive logic failing and iterative one accepted :("
                    },
                    {
                        "username": "user8355fQ",
                        "content": "If you\\'re getting TLE tweak your BFS \\nby considering the farthest point first \\n `for(int d = grid[i][j]+i ; d>=i+1 ; --d)`\\nand you are done \\n"
                    },
                    {
                        "username": "CHIIKUU",
                        "content": "but why it is giving tle?? "
                    },
                    {
                        "username": "czjnbb",
                        "content": "I didn\\'t notice this: 1 <= m * n <= 10**5\\n\\nA brutal BFS with memo will pass as well..."
                    },
                    {
                        "username": "roushanshah255",
                        "content": "class Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        \\n        vector<vector<int>> vis(grid.size(),vector<int>(grid[0].size(),INT_MAX));\\n        \\n        vis[0][0]=1;\\n        \\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        \\n        while(!q.empty())\\n        {\\n            pair<int,int> curr=q.front();\\n            q.pop();\\n            \\n            for(int j=curr.second+1;j<=min((int)grid[0].size()-1,curr.second+grid[curr.first][curr.second]);j++)\\n            {\\n                if(vis[curr.first][j]==INT_MAX)\\n                {\\n                    vis[curr.first][j]=1+vis[curr.first][curr.second];\\n                    q.push({curr.first,j});\\n                }\\n            }\\n            \\n            for(int j=curr.first+1;j<=min((int)grid.size()-1,curr.first+grid[curr.first][curr.second]);j++)\\n            {\\n                if(vis[j][curr.second]==INT_MAX)\\n                {\\n                    vis[j][curr.second]=1+vis[curr.first][curr.second];\\n                    q.push({j,curr.second});\\n                }\\n            }\\n        }\\n        \\n        int ans=vis[grid.size()-1][grid[0].size()-1];\\n        \\n        if(ans==INT_MAX)\\n        {\\n            ans=-1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nthis a code of a person which passed all the case but when i submitted it on my own its shows tle "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hi, Can anyone tell me about What is the path for this.\\n\\n[[ 1 , 0 , 11 ],[ 1 , 14 , 10 ],[ 12 , 10 , 2 ],[ 2 , 0 , 0 ],[ 13 , 0 , 0 ]]\\n\\nThe Expected output is 5.\\nI am not able to find any way to go (m - 1 , n - 1)."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "There are a number of ways you can visit \\nSome of the way I noticed (efficient ) are \\n1->1->14->10->0 (Final Destination)\\n1->1->12->13->0 (Final Destination)"
                    }
                ]
            },
            {
                "id": 1857910,
                "content": [
                    {
                        "username": "then00bprogrammer",
                        "content": "those last 4/5 testcases were evil"
                    },
                    {
                        "username": "brinuke",
                        "content": "Important testcase is missing! Code to generate it (Java):\n\n```java\npublic static int[][] generateTestCase(int n) {\n\tint[] row = new int[n];\n\tfor (int i = 0, j = n - 2; j > 0; i++, j--)\n\t\trow[i] = j;\n\treturn new int[][] { row };\n}\n\nint[][] grid = generateTestCase((int) 1e5);\n```\nExpected output: `-1`"
                    },
                    {
                        "username": "harigovind666",
                        "content": "is bfs approach not working for others too,time limit error in python!/"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why recursive solution sometimes passes sometimes fails?? I don\\'t understand."
                    },
                    {
                        "username": "IceTrey",
                        "content": "This is jump game II problem in 2D."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Can anyone explain why same recusive logic failing and iterative one accepted :("
                    },
                    {
                        "username": "user8355fQ",
                        "content": "If you\\'re getting TLE tweak your BFS \\nby considering the farthest point first \\n `for(int d = grid[i][j]+i ; d>=i+1 ; --d)`\\nand you are done \\n"
                    },
                    {
                        "username": "CHIIKUU",
                        "content": "but why it is giving tle?? "
                    },
                    {
                        "username": "czjnbb",
                        "content": "I didn\\'t notice this: 1 <= m * n <= 10**5\\n\\nA brutal BFS with memo will pass as well..."
                    },
                    {
                        "username": "roushanshah255",
                        "content": "class Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        \\n        vector<vector<int>> vis(grid.size(),vector<int>(grid[0].size(),INT_MAX));\\n        \\n        vis[0][0]=1;\\n        \\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        \\n        while(!q.empty())\\n        {\\n            pair<int,int> curr=q.front();\\n            q.pop();\\n            \\n            for(int j=curr.second+1;j<=min((int)grid[0].size()-1,curr.second+grid[curr.first][curr.second]);j++)\\n            {\\n                if(vis[curr.first][j]==INT_MAX)\\n                {\\n                    vis[curr.first][j]=1+vis[curr.first][curr.second];\\n                    q.push({curr.first,j});\\n                }\\n            }\\n            \\n            for(int j=curr.first+1;j<=min((int)grid.size()-1,curr.first+grid[curr.first][curr.second]);j++)\\n            {\\n                if(vis[j][curr.second]==INT_MAX)\\n                {\\n                    vis[j][curr.second]=1+vis[curr.first][curr.second];\\n                    q.push({j,curr.second});\\n                }\\n            }\\n        }\\n        \\n        int ans=vis[grid.size()-1][grid[0].size()-1];\\n        \\n        if(ans==INT_MAX)\\n        {\\n            ans=-1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nthis a code of a person which passed all the case but when i submitted it on my own its shows tle "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hi, Can anyone tell me about What is the path for this.\\n\\n[[ 1 , 0 , 11 ],[ 1 , 14 , 10 ],[ 12 , 10 , 2 ],[ 2 , 0 , 0 ],[ 13 , 0 , 0 ]]\\n\\nThe Expected output is 5.\\nI am not able to find any way to go (m - 1 , n - 1)."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "There are a number of ways you can visit \\nSome of the way I noticed (efficient ) are \\n1->1->14->10->0 (Final Destination)\\n1->1->12->13->0 (Final Destination)"
                    }
                ]
            },
            {
                "id": 1858822,
                "content": [
                    {
                        "username": "then00bprogrammer",
                        "content": "those last 4/5 testcases were evil"
                    },
                    {
                        "username": "brinuke",
                        "content": "Important testcase is missing! Code to generate it (Java):\n\n```java\npublic static int[][] generateTestCase(int n) {\n\tint[] row = new int[n];\n\tfor (int i = 0, j = n - 2; j > 0; i++, j--)\n\t\trow[i] = j;\n\treturn new int[][] { row };\n}\n\nint[][] grid = generateTestCase((int) 1e5);\n```\nExpected output: `-1`"
                    },
                    {
                        "username": "harigovind666",
                        "content": "is bfs approach not working for others too,time limit error in python!/"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why recursive solution sometimes passes sometimes fails?? I don\\'t understand."
                    },
                    {
                        "username": "IceTrey",
                        "content": "This is jump game II problem in 2D."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Can anyone explain why same recusive logic failing and iterative one accepted :("
                    },
                    {
                        "username": "user8355fQ",
                        "content": "If you\\'re getting TLE tweak your BFS \\nby considering the farthest point first \\n `for(int d = grid[i][j]+i ; d>=i+1 ; --d)`\\nand you are done \\n"
                    },
                    {
                        "username": "CHIIKUU",
                        "content": "but why it is giving tle?? "
                    },
                    {
                        "username": "czjnbb",
                        "content": "I didn\\'t notice this: 1 <= m * n <= 10**5\\n\\nA brutal BFS with memo will pass as well..."
                    },
                    {
                        "username": "roushanshah255",
                        "content": "class Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        \\n        vector<vector<int>> vis(grid.size(),vector<int>(grid[0].size(),INT_MAX));\\n        \\n        vis[0][0]=1;\\n        \\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        \\n        while(!q.empty())\\n        {\\n            pair<int,int> curr=q.front();\\n            q.pop();\\n            \\n            for(int j=curr.second+1;j<=min((int)grid[0].size()-1,curr.second+grid[curr.first][curr.second]);j++)\\n            {\\n                if(vis[curr.first][j]==INT_MAX)\\n                {\\n                    vis[curr.first][j]=1+vis[curr.first][curr.second];\\n                    q.push({curr.first,j});\\n                }\\n            }\\n            \\n            for(int j=curr.first+1;j<=min((int)grid.size()-1,curr.first+grid[curr.first][curr.second]);j++)\\n            {\\n                if(vis[j][curr.second]==INT_MAX)\\n                {\\n                    vis[j][curr.second]=1+vis[curr.first][curr.second];\\n                    q.push({j,curr.second});\\n                }\\n            }\\n        }\\n        \\n        int ans=vis[grid.size()-1][grid[0].size()-1];\\n        \\n        if(ans==INT_MAX)\\n        {\\n            ans=-1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nthis a code of a person which passed all the case but when i submitted it on my own its shows tle "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hi, Can anyone tell me about What is the path for this.\\n\\n[[ 1 , 0 , 11 ],[ 1 , 14 , 10 ],[ 12 , 10 , 2 ],[ 2 , 0 , 0 ],[ 13 , 0 , 0 ]]\\n\\nThe Expected output is 5.\\nI am not able to find any way to go (m - 1 , n - 1)."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "There are a number of ways you can visit \\nSome of the way I noticed (efficient ) are \\n1->1->14->10->0 (Final Destination)\\n1->1->12->13->0 (Final Destination)"
                    }
                ]
            },
            {
                "id": 1942119,
                "content": [
                    {
                        "username": "then00bprogrammer",
                        "content": "those last 4/5 testcases were evil"
                    },
                    {
                        "username": "brinuke",
                        "content": "Important testcase is missing! Code to generate it (Java):\n\n```java\npublic static int[][] generateTestCase(int n) {\n\tint[] row = new int[n];\n\tfor (int i = 0, j = n - 2; j > 0; i++, j--)\n\t\trow[i] = j;\n\treturn new int[][] { row };\n}\n\nint[][] grid = generateTestCase((int) 1e5);\n```\nExpected output: `-1`"
                    },
                    {
                        "username": "harigovind666",
                        "content": "is bfs approach not working for others too,time limit error in python!/"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why recursive solution sometimes passes sometimes fails?? I don\\'t understand."
                    },
                    {
                        "username": "IceTrey",
                        "content": "This is jump game II problem in 2D."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Can anyone explain why same recusive logic failing and iterative one accepted :("
                    },
                    {
                        "username": "user8355fQ",
                        "content": "If you\\'re getting TLE tweak your BFS \\nby considering the farthest point first \\n `for(int d = grid[i][j]+i ; d>=i+1 ; --d)`\\nand you are done \\n"
                    },
                    {
                        "username": "CHIIKUU",
                        "content": "but why it is giving tle?? "
                    },
                    {
                        "username": "czjnbb",
                        "content": "I didn\\'t notice this: 1 <= m * n <= 10**5\\n\\nA brutal BFS with memo will pass as well..."
                    },
                    {
                        "username": "roushanshah255",
                        "content": "class Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        \\n        vector<vector<int>> vis(grid.size(),vector<int>(grid[0].size(),INT_MAX));\\n        \\n        vis[0][0]=1;\\n        \\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        \\n        while(!q.empty())\\n        {\\n            pair<int,int> curr=q.front();\\n            q.pop();\\n            \\n            for(int j=curr.second+1;j<=min((int)grid[0].size()-1,curr.second+grid[curr.first][curr.second]);j++)\\n            {\\n                if(vis[curr.first][j]==INT_MAX)\\n                {\\n                    vis[curr.first][j]=1+vis[curr.first][curr.second];\\n                    q.push({curr.first,j});\\n                }\\n            }\\n            \\n            for(int j=curr.first+1;j<=min((int)grid.size()-1,curr.first+grid[curr.first][curr.second]);j++)\\n            {\\n                if(vis[j][curr.second]==INT_MAX)\\n                {\\n                    vis[j][curr.second]=1+vis[curr.first][curr.second];\\n                    q.push({j,curr.second});\\n                }\\n            }\\n        }\\n        \\n        int ans=vis[grid.size()-1][grid[0].size()-1];\\n        \\n        if(ans==INT_MAX)\\n        {\\n            ans=-1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nthis a code of a person which passed all the case but when i submitted it on my own its shows tle "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hi, Can anyone tell me about What is the path for this.\\n\\n[[ 1 , 0 , 11 ],[ 1 , 14 , 10 ],[ 12 , 10 , 2 ],[ 2 , 0 , 0 ],[ 13 , 0 , 0 ]]\\n\\nThe Expected output is 5.\\nI am not able to find any way to go (m - 1 , n - 1)."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "There are a number of ways you can visit \\nSome of the way I noticed (efficient ) are \\n1->1->14->10->0 (Final Destination)\\n1->1->12->13->0 (Final Destination)"
                    }
                ]
            },
            {
                "id": 1864059,
                "content": [
                    {
                        "username": "then00bprogrammer",
                        "content": "those last 4/5 testcases were evil"
                    },
                    {
                        "username": "brinuke",
                        "content": "Important testcase is missing! Code to generate it (Java):\n\n```java\npublic static int[][] generateTestCase(int n) {\n\tint[] row = new int[n];\n\tfor (int i = 0, j = n - 2; j > 0; i++, j--)\n\t\trow[i] = j;\n\treturn new int[][] { row };\n}\n\nint[][] grid = generateTestCase((int) 1e5);\n```\nExpected output: `-1`"
                    },
                    {
                        "username": "harigovind666",
                        "content": "is bfs approach not working for others too,time limit error in python!/"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why recursive solution sometimes passes sometimes fails?? I don\\'t understand."
                    },
                    {
                        "username": "IceTrey",
                        "content": "This is jump game II problem in 2D."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Can anyone explain why same recusive logic failing and iterative one accepted :("
                    },
                    {
                        "username": "user8355fQ",
                        "content": "If you\\'re getting TLE tweak your BFS \\nby considering the farthest point first \\n `for(int d = grid[i][j]+i ; d>=i+1 ; --d)`\\nand you are done \\n"
                    },
                    {
                        "username": "CHIIKUU",
                        "content": "but why it is giving tle?? "
                    },
                    {
                        "username": "czjnbb",
                        "content": "I didn\\'t notice this: 1 <= m * n <= 10**5\\n\\nA brutal BFS with memo will pass as well..."
                    },
                    {
                        "username": "roushanshah255",
                        "content": "class Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        \\n        vector<vector<int>> vis(grid.size(),vector<int>(grid[0].size(),INT_MAX));\\n        \\n        vis[0][0]=1;\\n        \\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        \\n        while(!q.empty())\\n        {\\n            pair<int,int> curr=q.front();\\n            q.pop();\\n            \\n            for(int j=curr.second+1;j<=min((int)grid[0].size()-1,curr.second+grid[curr.first][curr.second]);j++)\\n            {\\n                if(vis[curr.first][j]==INT_MAX)\\n                {\\n                    vis[curr.first][j]=1+vis[curr.first][curr.second];\\n                    q.push({curr.first,j});\\n                }\\n            }\\n            \\n            for(int j=curr.first+1;j<=min((int)grid.size()-1,curr.first+grid[curr.first][curr.second]);j++)\\n            {\\n                if(vis[j][curr.second]==INT_MAX)\\n                {\\n                    vis[j][curr.second]=1+vis[curr.first][curr.second];\\n                    q.push({j,curr.second});\\n                }\\n            }\\n        }\\n        \\n        int ans=vis[grid.size()-1][grid[0].size()-1];\\n        \\n        if(ans==INT_MAX)\\n        {\\n            ans=-1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nthis a code of a person which passed all the case but when i submitted it on my own its shows tle "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hi, Can anyone tell me about What is the path for this.\\n\\n[[ 1 , 0 , 11 ],[ 1 , 14 , 10 ],[ 12 , 10 , 2 ],[ 2 , 0 , 0 ],[ 13 , 0 , 0 ]]\\n\\nThe Expected output is 5.\\nI am not able to find any way to go (m - 1 , n - 1)."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "There are a number of ways you can visit \\nSome of the way I noticed (efficient ) are \\n1->1->14->10->0 (Final Destination)\\n1->1->12->13->0 (Final Destination)"
                    }
                ]
            },
            {
                "id": 1862071,
                "content": [
                    {
                        "username": "then00bprogrammer",
                        "content": "those last 4/5 testcases were evil"
                    },
                    {
                        "username": "brinuke",
                        "content": "Important testcase is missing! Code to generate it (Java):\n\n```java\npublic static int[][] generateTestCase(int n) {\n\tint[] row = new int[n];\n\tfor (int i = 0, j = n - 2; j > 0; i++, j--)\n\t\trow[i] = j;\n\treturn new int[][] { row };\n}\n\nint[][] grid = generateTestCase((int) 1e5);\n```\nExpected output: `-1`"
                    },
                    {
                        "username": "harigovind666",
                        "content": "is bfs approach not working for others too,time limit error in python!/"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why recursive solution sometimes passes sometimes fails?? I don\\'t understand."
                    },
                    {
                        "username": "IceTrey",
                        "content": "This is jump game II problem in 2D."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Can anyone explain why same recusive logic failing and iterative one accepted :("
                    },
                    {
                        "username": "user8355fQ",
                        "content": "If you\\'re getting TLE tweak your BFS \\nby considering the farthest point first \\n `for(int d = grid[i][j]+i ; d>=i+1 ; --d)`\\nand you are done \\n"
                    },
                    {
                        "username": "CHIIKUU",
                        "content": "but why it is giving tle?? "
                    },
                    {
                        "username": "czjnbb",
                        "content": "I didn\\'t notice this: 1 <= m * n <= 10**5\\n\\nA brutal BFS with memo will pass as well..."
                    },
                    {
                        "username": "roushanshah255",
                        "content": "class Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        \\n        vector<vector<int>> vis(grid.size(),vector<int>(grid[0].size(),INT_MAX));\\n        \\n        vis[0][0]=1;\\n        \\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        \\n        while(!q.empty())\\n        {\\n            pair<int,int> curr=q.front();\\n            q.pop();\\n            \\n            for(int j=curr.second+1;j<=min((int)grid[0].size()-1,curr.second+grid[curr.first][curr.second]);j++)\\n            {\\n                if(vis[curr.first][j]==INT_MAX)\\n                {\\n                    vis[curr.first][j]=1+vis[curr.first][curr.second];\\n                    q.push({curr.first,j});\\n                }\\n            }\\n            \\n            for(int j=curr.first+1;j<=min((int)grid.size()-1,curr.first+grid[curr.first][curr.second]);j++)\\n            {\\n                if(vis[j][curr.second]==INT_MAX)\\n                {\\n                    vis[j][curr.second]=1+vis[curr.first][curr.second];\\n                    q.push({j,curr.second});\\n                }\\n            }\\n        }\\n        \\n        int ans=vis[grid.size()-1][grid[0].size()-1];\\n        \\n        if(ans==INT_MAX)\\n        {\\n            ans=-1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nthis a code of a person which passed all the case but when i submitted it on my own its shows tle "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hi, Can anyone tell me about What is the path for this.\\n\\n[[ 1 , 0 , 11 ],[ 1 , 14 , 10 ],[ 12 , 10 , 2 ],[ 2 , 0 , 0 ],[ 13 , 0 , 0 ]]\\n\\nThe Expected output is 5.\\nI am not able to find any way to go (m - 1 , n - 1)."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "There are a number of ways you can visit \\nSome of the way I noticed (efficient ) are \\n1->1->14->10->0 (Final Destination)\\n1->1->12->13->0 (Final Destination)"
                    }
                ]
            },
            {
                "id": 1858755,
                "content": [
                    {
                        "username": "then00bprogrammer",
                        "content": "those last 4/5 testcases were evil"
                    },
                    {
                        "username": "brinuke",
                        "content": "Important testcase is missing! Code to generate it (Java):\n\n```java\npublic static int[][] generateTestCase(int n) {\n\tint[] row = new int[n];\n\tfor (int i = 0, j = n - 2; j > 0; i++, j--)\n\t\trow[i] = j;\n\treturn new int[][] { row };\n}\n\nint[][] grid = generateTestCase((int) 1e5);\n```\nExpected output: `-1`"
                    },
                    {
                        "username": "harigovind666",
                        "content": "is bfs approach not working for others too,time limit error in python!/"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why recursive solution sometimes passes sometimes fails?? I don\\'t understand."
                    },
                    {
                        "username": "IceTrey",
                        "content": "This is jump game II problem in 2D."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Can anyone explain why same recusive logic failing and iterative one accepted :("
                    },
                    {
                        "username": "user8355fQ",
                        "content": "If you\\'re getting TLE tweak your BFS \\nby considering the farthest point first \\n `for(int d = grid[i][j]+i ; d>=i+1 ; --d)`\\nand you are done \\n"
                    },
                    {
                        "username": "CHIIKUU",
                        "content": "but why it is giving tle?? "
                    },
                    {
                        "username": "czjnbb",
                        "content": "I didn\\'t notice this: 1 <= m * n <= 10**5\\n\\nA brutal BFS with memo will pass as well..."
                    },
                    {
                        "username": "roushanshah255",
                        "content": "class Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        \\n        vector<vector<int>> vis(grid.size(),vector<int>(grid[0].size(),INT_MAX));\\n        \\n        vis[0][0]=1;\\n        \\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        \\n        while(!q.empty())\\n        {\\n            pair<int,int> curr=q.front();\\n            q.pop();\\n            \\n            for(int j=curr.second+1;j<=min((int)grid[0].size()-1,curr.second+grid[curr.first][curr.second]);j++)\\n            {\\n                if(vis[curr.first][j]==INT_MAX)\\n                {\\n                    vis[curr.first][j]=1+vis[curr.first][curr.second];\\n                    q.push({curr.first,j});\\n                }\\n            }\\n            \\n            for(int j=curr.first+1;j<=min((int)grid.size()-1,curr.first+grid[curr.first][curr.second]);j++)\\n            {\\n                if(vis[j][curr.second]==INT_MAX)\\n                {\\n                    vis[j][curr.second]=1+vis[curr.first][curr.second];\\n                    q.push({j,curr.second});\\n                }\\n            }\\n        }\\n        \\n        int ans=vis[grid.size()-1][grid[0].size()-1];\\n        \\n        if(ans==INT_MAX)\\n        {\\n            ans=-1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nthis a code of a person which passed all the case but when i submitted it on my own its shows tle "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hi, Can anyone tell me about What is the path for this.\\n\\n[[ 1 , 0 , 11 ],[ 1 , 14 , 10 ],[ 12 , 10 , 2 ],[ 2 , 0 , 0 ],[ 13 , 0 , 0 ]]\\n\\nThe Expected output is 5.\\nI am not able to find any way to go (m - 1 , n - 1)."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "There are a number of ways you can visit \\nSome of the way I noticed (efficient ) are \\n1->1->14->10->0 (Final Destination)\\n1->1->12->13->0 (Final Destination)"
                    }
                ]
            },
            {
                "id": 1858366,
                "content": [
                    {
                        "username": "then00bprogrammer",
                        "content": "those last 4/5 testcases were evil"
                    },
                    {
                        "username": "brinuke",
                        "content": "Important testcase is missing! Code to generate it (Java):\n\n```java\npublic static int[][] generateTestCase(int n) {\n\tint[] row = new int[n];\n\tfor (int i = 0, j = n - 2; j > 0; i++, j--)\n\t\trow[i] = j;\n\treturn new int[][] { row };\n}\n\nint[][] grid = generateTestCase((int) 1e5);\n```\nExpected output: `-1`"
                    },
                    {
                        "username": "harigovind666",
                        "content": "is bfs approach not working for others too,time limit error in python!/"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why recursive solution sometimes passes sometimes fails?? I don\\'t understand."
                    },
                    {
                        "username": "IceTrey",
                        "content": "This is jump game II problem in 2D."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Can anyone explain why same recusive logic failing and iterative one accepted :("
                    },
                    {
                        "username": "user8355fQ",
                        "content": "If you\\'re getting TLE tweak your BFS \\nby considering the farthest point first \\n `for(int d = grid[i][j]+i ; d>=i+1 ; --d)`\\nand you are done \\n"
                    },
                    {
                        "username": "CHIIKUU",
                        "content": "but why it is giving tle?? "
                    },
                    {
                        "username": "czjnbb",
                        "content": "I didn\\'t notice this: 1 <= m * n <= 10**5\\n\\nA brutal BFS with memo will pass as well..."
                    },
                    {
                        "username": "roushanshah255",
                        "content": "class Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        \\n        vector<vector<int>> vis(grid.size(),vector<int>(grid[0].size(),INT_MAX));\\n        \\n        vis[0][0]=1;\\n        \\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        \\n        while(!q.empty())\\n        {\\n            pair<int,int> curr=q.front();\\n            q.pop();\\n            \\n            for(int j=curr.second+1;j<=min((int)grid[0].size()-1,curr.second+grid[curr.first][curr.second]);j++)\\n            {\\n                if(vis[curr.first][j]==INT_MAX)\\n                {\\n                    vis[curr.first][j]=1+vis[curr.first][curr.second];\\n                    q.push({curr.first,j});\\n                }\\n            }\\n            \\n            for(int j=curr.first+1;j<=min((int)grid.size()-1,curr.first+grid[curr.first][curr.second]);j++)\\n            {\\n                if(vis[j][curr.second]==INT_MAX)\\n                {\\n                    vis[j][curr.second]=1+vis[curr.first][curr.second];\\n                    q.push({j,curr.second});\\n                }\\n            }\\n        }\\n        \\n        int ans=vis[grid.size()-1][grid[0].size()-1];\\n        \\n        if(ans==INT_MAX)\\n        {\\n            ans=-1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nthis a code of a person which passed all the case but when i submitted it on my own its shows tle "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hi, Can anyone tell me about What is the path for this.\\n\\n[[ 1 , 0 , 11 ],[ 1 , 14 , 10 ],[ 12 , 10 , 2 ],[ 2 , 0 , 0 ],[ 13 , 0 , 0 ]]\\n\\nThe Expected output is 5.\\nI am not able to find any way to go (m - 1 , n - 1)."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "There are a number of ways you can visit \\nSome of the way I noticed (efficient ) are \\n1->1->14->10->0 (Final Destination)\\n1->1->12->13->0 (Final Destination)"
                    }
                ]
            },
            {
                "id": 1858605,
                "content": [
                    {
                        "username": "then00bprogrammer",
                        "content": "those last 4/5 testcases were evil"
                    },
                    {
                        "username": "brinuke",
                        "content": "Important testcase is missing! Code to generate it (Java):\n\n```java\npublic static int[][] generateTestCase(int n) {\n\tint[] row = new int[n];\n\tfor (int i = 0, j = n - 2; j > 0; i++, j--)\n\t\trow[i] = j;\n\treturn new int[][] { row };\n}\n\nint[][] grid = generateTestCase((int) 1e5);\n```\nExpected output: `-1`"
                    },
                    {
                        "username": "harigovind666",
                        "content": "is bfs approach not working for others too,time limit error in python!/"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why recursive solution sometimes passes sometimes fails?? I don\\'t understand."
                    },
                    {
                        "username": "IceTrey",
                        "content": "This is jump game II problem in 2D."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Can anyone explain why same recusive logic failing and iterative one accepted :("
                    },
                    {
                        "username": "user8355fQ",
                        "content": "If you\\'re getting TLE tweak your BFS \\nby considering the farthest point first \\n `for(int d = grid[i][j]+i ; d>=i+1 ; --d)`\\nand you are done \\n"
                    },
                    {
                        "username": "CHIIKUU",
                        "content": "but why it is giving tle?? "
                    },
                    {
                        "username": "czjnbb",
                        "content": "I didn\\'t notice this: 1 <= m * n <= 10**5\\n\\nA brutal BFS with memo will pass as well..."
                    },
                    {
                        "username": "roushanshah255",
                        "content": "class Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        \\n        vector<vector<int>> vis(grid.size(),vector<int>(grid[0].size(),INT_MAX));\\n        \\n        vis[0][0]=1;\\n        \\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        \\n        while(!q.empty())\\n        {\\n            pair<int,int> curr=q.front();\\n            q.pop();\\n            \\n            for(int j=curr.second+1;j<=min((int)grid[0].size()-1,curr.second+grid[curr.first][curr.second]);j++)\\n            {\\n                if(vis[curr.first][j]==INT_MAX)\\n                {\\n                    vis[curr.first][j]=1+vis[curr.first][curr.second];\\n                    q.push({curr.first,j});\\n                }\\n            }\\n            \\n            for(int j=curr.first+1;j<=min((int)grid.size()-1,curr.first+grid[curr.first][curr.second]);j++)\\n            {\\n                if(vis[j][curr.second]==INT_MAX)\\n                {\\n                    vis[j][curr.second]=1+vis[curr.first][curr.second];\\n                    q.push({j,curr.second});\\n                }\\n            }\\n        }\\n        \\n        int ans=vis[grid.size()-1][grid[0].size()-1];\\n        \\n        if(ans==INT_MAX)\\n        {\\n            ans=-1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nthis a code of a person which passed all the case but when i submitted it on my own its shows tle "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hi, Can anyone tell me about What is the path for this.\\n\\n[[ 1 , 0 , 11 ],[ 1 , 14 , 10 ],[ 12 , 10 , 2 ],[ 2 , 0 , 0 ],[ 13 , 0 , 0 ]]\\n\\nThe Expected output is 5.\\nI am not able to find any way to go (m - 1 , n - 1)."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "There are a number of ways you can visit \\nSome of the way I noticed (efficient ) are \\n1->1->14->10->0 (Final Destination)\\n1->1->12->13->0 (Final Destination)"
                    }
                ]
            },
            {
                "id": 1859417,
                "content": [
                    {
                        "username": "then00bprogrammer",
                        "content": "those last 4/5 testcases were evil"
                    },
                    {
                        "username": "brinuke",
                        "content": "Important testcase is missing! Code to generate it (Java):\n\n```java\npublic static int[][] generateTestCase(int n) {\n\tint[] row = new int[n];\n\tfor (int i = 0, j = n - 2; j > 0; i++, j--)\n\t\trow[i] = j;\n\treturn new int[][] { row };\n}\n\nint[][] grid = generateTestCase((int) 1e5);\n```\nExpected output: `-1`"
                    },
                    {
                        "username": "harigovind666",
                        "content": "is bfs approach not working for others too,time limit error in python!/"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why recursive solution sometimes passes sometimes fails?? I don\\'t understand."
                    },
                    {
                        "username": "IceTrey",
                        "content": "This is jump game II problem in 2D."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Can anyone explain why same recusive logic failing and iterative one accepted :("
                    },
                    {
                        "username": "user8355fQ",
                        "content": "If you\\'re getting TLE tweak your BFS \\nby considering the farthest point first \\n `for(int d = grid[i][j]+i ; d>=i+1 ; --d)`\\nand you are done \\n"
                    },
                    {
                        "username": "CHIIKUU",
                        "content": "but why it is giving tle?? "
                    },
                    {
                        "username": "czjnbb",
                        "content": "I didn\\'t notice this: 1 <= m * n <= 10**5\\n\\nA brutal BFS with memo will pass as well..."
                    },
                    {
                        "username": "roushanshah255",
                        "content": "class Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        \\n        vector<vector<int>> vis(grid.size(),vector<int>(grid[0].size(),INT_MAX));\\n        \\n        vis[0][0]=1;\\n        \\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        \\n        while(!q.empty())\\n        {\\n            pair<int,int> curr=q.front();\\n            q.pop();\\n            \\n            for(int j=curr.second+1;j<=min((int)grid[0].size()-1,curr.second+grid[curr.first][curr.second]);j++)\\n            {\\n                if(vis[curr.first][j]==INT_MAX)\\n                {\\n                    vis[curr.first][j]=1+vis[curr.first][curr.second];\\n                    q.push({curr.first,j});\\n                }\\n            }\\n            \\n            for(int j=curr.first+1;j<=min((int)grid.size()-1,curr.first+grid[curr.first][curr.second]);j++)\\n            {\\n                if(vis[j][curr.second]==INT_MAX)\\n                {\\n                    vis[j][curr.second]=1+vis[curr.first][curr.second];\\n                    q.push({j,curr.second});\\n                }\\n            }\\n        }\\n        \\n        int ans=vis[grid.size()-1][grid[0].size()-1];\\n        \\n        if(ans==INT_MAX)\\n        {\\n            ans=-1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nthis a code of a person which passed all the case but when i submitted it on my own its shows tle "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hi, Can anyone tell me about What is the path for this.\\n\\n[[ 1 , 0 , 11 ],[ 1 , 14 , 10 ],[ 12 , 10 , 2 ],[ 2 , 0 , 0 ],[ 13 , 0 , 0 ]]\\n\\nThe Expected output is 5.\\nI am not able to find any way to go (m - 1 , n - 1)."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "There are a number of ways you can visit \\nSome of the way I noticed (efficient ) are \\n1->1->14->10->0 (Final Destination)\\n1->1->12->13->0 (Final Destination)"
                    }
                ]
            },
            {
                "id": 1858512,
                "content": [
                    {
                        "username": "then00bprogrammer",
                        "content": "those last 4/5 testcases were evil"
                    },
                    {
                        "username": "brinuke",
                        "content": "Important testcase is missing! Code to generate it (Java):\n\n```java\npublic static int[][] generateTestCase(int n) {\n\tint[] row = new int[n];\n\tfor (int i = 0, j = n - 2; j > 0; i++, j--)\n\t\trow[i] = j;\n\treturn new int[][] { row };\n}\n\nint[][] grid = generateTestCase((int) 1e5);\n```\nExpected output: `-1`"
                    },
                    {
                        "username": "harigovind666",
                        "content": "is bfs approach not working for others too,time limit error in python!/"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why recursive solution sometimes passes sometimes fails?? I don\\'t understand."
                    },
                    {
                        "username": "IceTrey",
                        "content": "This is jump game II problem in 2D."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Can anyone explain why same recusive logic failing and iterative one accepted :("
                    },
                    {
                        "username": "user8355fQ",
                        "content": "If you\\'re getting TLE tweak your BFS \\nby considering the farthest point first \\n `for(int d = grid[i][j]+i ; d>=i+1 ; --d)`\\nand you are done \\n"
                    },
                    {
                        "username": "CHIIKUU",
                        "content": "but why it is giving tle?? "
                    },
                    {
                        "username": "czjnbb",
                        "content": "I didn\\'t notice this: 1 <= m * n <= 10**5\\n\\nA brutal BFS with memo will pass as well..."
                    },
                    {
                        "username": "roushanshah255",
                        "content": "class Solution {\\npublic:\\n    int minimumVisitedCells(vector<vector<int>>& grid) {\\n        \\n        vector<vector<int>> vis(grid.size(),vector<int>(grid[0].size(),INT_MAX));\\n        \\n        vis[0][0]=1;\\n        \\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        \\n        while(!q.empty())\\n        {\\n            pair<int,int> curr=q.front();\\n            q.pop();\\n            \\n            for(int j=curr.second+1;j<=min((int)grid[0].size()-1,curr.second+grid[curr.first][curr.second]);j++)\\n            {\\n                if(vis[curr.first][j]==INT_MAX)\\n                {\\n                    vis[curr.first][j]=1+vis[curr.first][curr.second];\\n                    q.push({curr.first,j});\\n                }\\n            }\\n            \\n            for(int j=curr.first+1;j<=min((int)grid.size()-1,curr.first+grid[curr.first][curr.second]);j++)\\n            {\\n                if(vis[j][curr.second]==INT_MAX)\\n                {\\n                    vis[j][curr.second]=1+vis[curr.first][curr.second];\\n                    q.push({j,curr.second});\\n                }\\n            }\\n        }\\n        \\n        int ans=vis[grid.size()-1][grid[0].size()-1];\\n        \\n        if(ans==INT_MAX)\\n        {\\n            ans=-1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nthis a code of a person which passed all the case but when i submitted it on my own its shows tle "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hi, Can anyone tell me about What is the path for this.\\n\\n[[ 1 , 0 , 11 ],[ 1 , 14 , 10 ],[ 12 , 10 , 2 ],[ 2 , 0 , 0 ],[ 13 , 0 , 0 ]]\\n\\nThe Expected output is 5.\\nI am not able to find any way to go (m - 1 , n - 1)."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "There are a number of ways you can visit \\nSome of the way I noticed (efficient ) are \\n1->1->14->10->0 (Final Destination)\\n1->1->12->13->0 (Final Destination)"
                    }
                ]
            }
        ]
    }
]